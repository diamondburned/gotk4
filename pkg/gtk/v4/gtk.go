// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"context"
	"fmt"
	"math"
	"runtime"
	_ "runtime/cgo"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/cairo"
	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	"github.com/diamondburned/gotk4/pkg/graphene"
	"github.com/diamondburned/gotk4/pkg/gsk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
// extern void callbackDelete(gpointer);
// extern void _gotk4_gtk4_Window_ConnectKeysChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_Window_ConnectActivateFocus(gpointer, guintptr);
// extern void _gotk4_gtk4_Window_ConnectActivateDefault(gpointer, guintptr);
// extern void _gotk4_gtk4_WindowClass_keys_changed(GtkWindow*);
// extern void _gotk4_gtk4_WindowClass_activate_focus(GtkWindow*);
// extern void _gotk4_gtk4_WindowClass_activate_default(GtkWindow*);
// extern void _gotk4_gtk4_Widget_ConnectUnrealize(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectUnmap(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectStateFlagsChanged(gpointer, GtkStateFlags, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectShow(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectRealize(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectMoveFocus(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectMap(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectHide(gpointer, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectDirectionChanged(gpointer, GtkTextDirection, guintptr);
// extern void _gotk4_gtk4_Widget_ConnectDestroy(gpointer, guintptr);
// extern void _gotk4_gtk4_WidgetClass_unroot(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_unrealize(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_unmap(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_system_setting_changed(GtkWidget*, GtkSystemSetting);
// extern void _gotk4_gtk4_WidgetClass_state_flags_changed(GtkWidget*, GtkStateFlags);
// extern void _gotk4_gtk4_WidgetClass_snapshot(GtkWidget*, GtkSnapshot*);
// extern void _gotk4_gtk4_WidgetClass_size_allocate(GtkWidget*, int, int, int);
// extern void _gotk4_gtk4_WidgetClass_show(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_set_focus_child(GtkWidget*, GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_root(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_realize(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_move_focus(GtkWidget*, GtkDirectionType);
// extern void _gotk4_gtk4_WidgetClass_measure(GtkWidget*, GtkOrientation, int, int*, int*, int*, int*);
// extern void _gotk4_gtk4_WidgetClass_map(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_hide(GtkWidget*);
// extern void _gotk4_gtk4_WidgetClass_direction_changed(GtkWidget*, GtkTextDirection);
// extern void _gotk4_gtk4_TreeView_ConnectRowExpanded(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectRowCollapsed(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectRowActivated(gpointer, GtkTreePath*, GtkTreeViewColumn*, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectCursorChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TreeView_ConnectColumnsChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TreeViewMappingFunc(GtkTreeView*, GtkTreePath*, gpointer);
// extern void _gotk4_gtk4_TreeViewColumn_ConnectClicked(gpointer, guintptr);
// extern void _gotk4_gtk4_TreeViewClass_row_expanded(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern void _gotk4_gtk4_TreeViewClass_row_collapsed(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern void _gotk4_gtk4_TreeViewClass_row_activated(GtkTreeView*, GtkTreePath*, GtkTreeViewColumn*);
// extern void _gotk4_gtk4_TreeViewClass_cursor_changed(GtkTreeView*);
// extern void _gotk4_gtk4_TreeViewClass_columns_changed(GtkTreeView*);
// extern void _gotk4_gtk4_TreeSortable_ConnectSortColumnChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TreeSelection_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TreeSelectionForEachFunc(GtkTreeModel*, GtkTreePath*, GtkTreeIter*, gpointer);
// extern void _gotk4_gtk4_TreeModel_ConnectRowsReordered(gpointer, GtkTreePath*, GtkTreeIter*, gpointer, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowInserted(gpointer, GtkTreePath*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowHasChildToggled(gpointer, GtkTreePath*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowDeleted(gpointer, GtkTreePath*, guintptr);
// extern void _gotk4_gtk4_TreeModel_ConnectRowChanged(gpointer, GtkTreePath*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk4_TreeModelFilterModifyFunc(GtkTreeModel*, GtkTreeIter*, GValue*, int, gpointer);
// extern void _gotk4_gtk4_TreeModelFilterClass_modify(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*, GValue*, int);
// extern void _gotk4_gtk4_TreeCellDataFunc(GtkTreeViewColumn*, GtkCellRenderer*, GtkTreeModel*, GtkTreeIter*, gpointer);
// extern void _gotk4_gtk4_ToggleButton_ConnectToggled(gpointer, guintptr);
// extern void _gotk4_gtk4_ToggleButtonClass_toggled(GtkToggleButton*);
// extern void _gotk4_gtk4_Text_ConnectToggleOverwrite(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_Text_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, guintptr);
// extern void _gotk4_gtk4_Text_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_Text_ConnectDeleteFromCursor(gpointer, GtkDeleteType, gint, guintptr);
// extern void _gotk4_gtk4_Text_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk4_Text_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectToggleOverwrite(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectToggleCursorVisible(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectSetAnchor(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectSelectAll(gpointer, gboolean, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectPreeditChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectPasteClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectMoveViewport(gpointer, GtkScrollStep, gint, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectInsertEmoji(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectInsertAtCursor(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectDeleteFromCursor(gpointer, GtkDeleteType, gint, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectCutClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_TextView_ConnectBackspace(gpointer, guintptr);
// extern void _gotk4_gtk4_TextViewClass_toggle_overwrite(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_snapshot_layer(GtkTextView*, GtkTextViewLayer, GtkSnapshot*);
// extern void _gotk4_gtk4_TextViewClass_set_anchor(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_paste_clipboard(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_move_cursor(GtkTextView*, GtkMovementStep, int, gboolean);
// extern void _gotk4_gtk4_TextViewClass_insert_emoji(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_insert_at_cursor(GtkTextView*, char*);
// extern void _gotk4_gtk4_TextViewClass_delete_from_cursor(GtkTextView*, GtkDeleteType, int);
// extern void _gotk4_gtk4_TextViewClass_cut_clipboard(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_copy_clipboard(GtkTextView*);
// extern void _gotk4_gtk4_TextViewClass_backspace(GtkTextView*);
// extern void _gotk4_gtk4_TextTagTable_ConnectTagRemoved(gpointer, GtkTextTag*, guintptr);
// extern void _gotk4_gtk4_TextTagTable_ConnectTagChanged(gpointer, GtkTextTag*, gboolean, guintptr);
// extern void _gotk4_gtk4_TextTagTable_ConnectTagAdded(gpointer, GtkTextTag*, guintptr);
// extern void _gotk4_gtk4_TextTagTableForEach(GtkTextTag*, gpointer);
// extern void _gotk4_gtk4_TextBuffer_ConnectUndo(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectRemoveTag(gpointer, GtkTextTag*, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectRedo(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectPasteDone(gpointer, GdkClipboard*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectModifiedChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectMarkSet(gpointer, GtkTextIter*, GtkTextMark*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectMarkDeleted(gpointer, GtkTextMark*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertText(gpointer, GtkTextIter*, gchar*, gint, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertPaintable(gpointer, GtkTextIter*, GdkPaintable*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor(gpointer, GtkTextIter*, GtkTextChildAnchor*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectEndUserAction(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectDeleteRange(gpointer, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectBeginUserAction(gpointer, guintptr);
// extern void _gotk4_gtk4_TextBuffer_ConnectApplyTag(gpointer, GtkTextTag*, GtkTextIter*, GtkTextIter*, guintptr);
// extern void _gotk4_gtk4_TextBufferClass_undo(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_remove_tag(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk4_TextBufferClass_redo(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_paste_done(GtkTextBuffer*, GdkClipboard*);
// extern void _gotk4_gtk4_TextBufferClass_modified_changed(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_mark_set(GtkTextBuffer*, GtkTextIter*, GtkTextMark*);
// extern void _gotk4_gtk4_TextBufferClass_mark_deleted(GtkTextBuffer*, GtkTextMark*);
// extern void _gotk4_gtk4_TextBufferClass_insert_text(GtkTextBuffer*, GtkTextIter*, char*, int);
// extern void _gotk4_gtk4_TextBufferClass_insert_paintable(GtkTextBuffer*, GtkTextIter*, GdkPaintable*);
// extern void _gotk4_gtk4_TextBufferClass_insert_child_anchor(GtkTextBuffer*, GtkTextIter*, GtkTextChildAnchor*);
// extern void _gotk4_gtk4_TextBufferClass_end_user_action(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_delete_range(GtkTextBuffer*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk4_TextBufferClass_changed(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_begin_user_action(GtkTextBuffer*);
// extern void _gotk4_gtk4_TextBufferClass_apply_tag(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*);
// extern void _gotk4_gtk4_Switch_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_StyleProvider_ConnectGTKPrivateChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_StyleContextClass_changed(GtkStyleContext*);
// extern void _gotk4_gtk4_Statusbar_ConnectTextPushed(gpointer, guint, gchar*, guintptr);
// extern void _gotk4_gtk4_Statusbar_ConnectTextPopped(gpointer, guint, gchar*, guintptr);
// extern void _gotk4_gtk4_SpinButton_ConnectWrapped(gpointer, guintptr);
// extern void _gotk4_gtk4_SpinButton_ConnectValueChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_SpinButton_ConnectChangeValue(gpointer, GtkScrollType, guintptr);
// extern void _gotk4_gtk4_Sorter_ConnectChanged(gpointer, GtkSorterChange, guintptr);
// extern void _gotk4_gtk4_SignalListItemFactory_ConnectUnbind(gpointer, GtkListItem*, guintptr);
// extern void _gotk4_gtk4_SignalListItemFactory_ConnectTeardown(gpointer, GtkListItem*, guintptr);
// extern void _gotk4_gtk4_SignalListItemFactory_ConnectSetup(gpointer, GtkListItem*, guintptr);
// extern void _gotk4_gtk4_SignalListItemFactory_ConnectBind(gpointer, GtkListItem*, guintptr);
// extern void _gotk4_gtk4_ShortcutsWindow_ConnectSearch(gpointer, guintptr);
// extern void _gotk4_gtk4_ShortcutsWindow_ConnectClose(gpointer, guintptr);
// extern void _gotk4_gtk4_SelectionModel_ConnectSelectionChanged(gpointer, guint, guint, guintptr);
// extern void _gotk4_gtk4_SearchEntry_ConnectStopSearch(gpointer, guintptr);
// extern void _gotk4_gtk4_SearchEntry_ConnectSearchStarted(gpointer, guintptr);
// extern void _gotk4_gtk4_SearchEntry_ConnectSearchChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_SearchEntry_ConnectPreviousMatch(gpointer, guintptr);
// extern void _gotk4_gtk4_SearchEntry_ConnectNextMatch(gpointer, guintptr);
// extern void _gotk4_gtk4_SearchEntry_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_ScrolledWindow_ConnectMoveFocusOut(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk4_ScrolledWindow_ConnectEdgeReached(gpointer, GtkPositionType, guintptr);
// extern void _gotk4_gtk4_ScrolledWindow_ConnectEdgeOvershot(gpointer, GtkPositionType, guintptr);
// extern void _gotk4_gtk4_ScaleClass_get_layout_offsets(GtkScale*, int*, int*);
// extern void _gotk4_gtk4_ScaleButton_ConnectValueChanged(gpointer, gdouble, guintptr);
// extern void _gotk4_gtk4_ScaleButton_ConnectPopup(gpointer, guintptr);
// extern void _gotk4_gtk4_ScaleButton_ConnectPopdown(gpointer, guintptr);
// extern void _gotk4_gtk4_ScaleButtonClass_value_changed(GtkScaleButton*, double);
// extern void _gotk4_gtk4_RecentManager_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_RecentManagerClass_changed(GtkRecentManager*);
// extern void _gotk4_gtk4_Range_ConnectValueChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_Range_ConnectMoveSlider(gpointer, GtkScrollType, guintptr);
// extern void _gotk4_gtk4_Range_ConnectAdjustBounds(gpointer, gdouble, guintptr);
// extern void _gotk4_gtk4_RangeClass_value_changed(GtkRange*);
// extern void _gotk4_gtk4_RangeClass_move_slider(GtkRange*, GtkScrollType);
// extern void _gotk4_gtk4_RangeClass_get_range_border(GtkRange*, GtkBorder*);
// extern void _gotk4_gtk4_RangeClass_adjust_bounds(GtkRange*, double);
// extern void _gotk4_gtk4_PrintSettingsFunc(char*, char*, gpointer);
// extern void _gotk4_gtk4_PrintOperation_ConnectUpdateCustomWidget(gpointer, GtkWidget*, GtkPageSetup*, GtkPrintSettings*, guintptr);
// extern void _gotk4_gtk4_PrintOperation_ConnectStatusChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_PrintOperation_ConnectRequestPageSetup(gpointer, GtkPrintContext*, gint, GtkPageSetup*, guintptr);
// extern void _gotk4_gtk4_PrintOperation_ConnectEndPrint(gpointer, GtkPrintContext*, guintptr);
// extern void _gotk4_gtk4_PrintOperation_ConnectDrawPage(gpointer, GtkPrintContext*, gint, guintptr);
// extern void _gotk4_gtk4_PrintOperation_ConnectDone(gpointer, GtkPrintOperationResult, guintptr);
// extern void _gotk4_gtk4_PrintOperation_ConnectCustomWidgetApply(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk4_PrintOperation_ConnectBeginPrint(gpointer, GtkPrintContext*, guintptr);
// extern void _gotk4_gtk4_PrintOperationPreview_ConnectReady(gpointer, GtkPrintContext*, guintptr);
// extern void _gotk4_gtk4_PrintOperationPreview_ConnectGotPageSize(gpointer, GtkPrintContext*, GtkPageSetup*, guintptr);
// extern void _gotk4_gtk4_PrintOperationClass_update_custom_widget(GtkPrintOperation*, GtkWidget*, GtkPageSetup*, GtkPrintSettings*);
// extern void _gotk4_gtk4_PrintOperationClass_status_changed(GtkPrintOperation*);
// extern void _gotk4_gtk4_PrintOperationClass_request_page_setup(GtkPrintOperation*, GtkPrintContext*, int, GtkPageSetup*);
// extern void _gotk4_gtk4_PrintOperationClass_end_print(GtkPrintOperation*, GtkPrintContext*);
// extern void _gotk4_gtk4_PrintOperationClass_draw_page(GtkPrintOperation*, GtkPrintContext*, int);
// extern void _gotk4_gtk4_PrintOperationClass_done(GtkPrintOperation*, GtkPrintOperationResult);
// extern void _gotk4_gtk4_PrintOperationClass_custom_widget_apply(GtkPrintOperation*, GtkWidget*);
// extern void _gotk4_gtk4_PrintOperationClass_begin_print(GtkPrintOperation*, GtkPrintContext*);
// extern void _gotk4_gtk4_Popover_ConnectClosed(gpointer, guintptr);
// extern void _gotk4_gtk4_Popover_ConnectActivateDefault(gpointer, guintptr);
// extern void _gotk4_gtk4_PopoverClass_closed(GtkPopover*);
// extern void _gotk4_gtk4_PopoverClass_activate_default(GtkPopover*);
// extern void _gotk4_gtk4_PasswordEntry_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_PageSetupDoneFunc(GtkPageSetup*, gpointer);
// extern void _gotk4_gtk4_Notebook_ConnectSwitchPage(gpointer, GtkWidget*, guint, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectPageReordered(gpointer, GtkWidget*, guint, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectPageRemoved(gpointer, GtkWidget*, guint, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectPageAdded(gpointer, GtkWidget*, guint, guintptr);
// extern void _gotk4_gtk4_Notebook_ConnectMoveFocusOut(gpointer, GtkDirectionType, guintptr);
// extern void _gotk4_gtk4_NativeDialog_ConnectResponse(gpointer, gint, guintptr);
// extern void _gotk4_gtk4_NativeDialogClass_show(GtkNativeDialog*);
// extern void _gotk4_gtk4_NativeDialogClass_response(GtkNativeDialog*, int);
// extern void _gotk4_gtk4_NativeDialogClass_hide(GtkNativeDialog*);
// extern void _gotk4_gtk4_MenuButtonCreatePopupFunc(GtkMenuButton*, gpointer);
// extern void _gotk4_gtk4_MediaStreamClass_update_audio(GtkMediaStream*, gboolean, double);
// extern void _gotk4_gtk4_MediaStreamClass_unrealize(GtkMediaStream*, GdkSurface*);
// extern void _gotk4_gtk4_MediaStreamClass_seek(GtkMediaStream*, gint64);
// extern void _gotk4_gtk4_MediaStreamClass_realize(GtkMediaStream*, GdkSurface*);
// extern void _gotk4_gtk4_MediaStreamClass_pause(GtkMediaStream*);
// extern void _gotk4_gtk4_MediaFileClass_open(GtkMediaFile*);
// extern void _gotk4_gtk4_MediaFileClass_close(GtkMediaFile*);
// extern void _gotk4_gtk4_ListView_ConnectActivate(gpointer, guint, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectUnselectAll(gpointer, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectToggleCursorRow(gpointer, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectSelectedRowsChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectSelectAll(gpointer, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectRowSelected(gpointer, GtkListBoxRow*, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectRowActivated(gpointer, GtkListBoxRow*, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, gboolean, guintptr);
// extern void _gotk4_gtk4_ListBox_ConnectActivateCursorRow(gpointer, guintptr);
// extern void _gotk4_gtk4_ListBoxUpdateHeaderFunc(GtkListBoxRow*, GtkListBoxRow*, gpointer);
// extern void _gotk4_gtk4_ListBoxRow_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_ListBoxRowClass_activate(GtkListBoxRow*);
// extern void _gotk4_gtk4_ListBoxForEachFunc(GtkListBox*, GtkListBoxRow*, gpointer);
// extern void _gotk4_gtk4_LevelBar_ConnectOffsetChanged(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_LayoutManagerClass_unroot(GtkLayoutManager*);
// extern void _gotk4_gtk4_LayoutManagerClass_root(GtkLayoutManager*);
// extern void _gotk4_gtk4_LayoutManagerClass_measure(GtkLayoutManager*, GtkWidget*, GtkOrientation, int, int*, int*, int*, int*);
// extern void _gotk4_gtk4_LayoutManagerClass_allocate(GtkLayoutManager*, GtkWidget*, int, int, int);
// extern void _gotk4_gtk4_Label_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, guintptr);
// extern void _gotk4_gtk4_Label_ConnectCopyClipboard(gpointer, guintptr);
// extern void _gotk4_gtk4_Label_ConnectActivateCurrentLink(gpointer, guintptr);
// extern void _gotk4_gtk4_InfoBar_ConnectResponse(gpointer, gint, guintptr);
// extern void _gotk4_gtk4_InfoBar_ConnectClose(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectUnselectAll(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectToggleCursorItem(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectSelectionChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectSelectCursorItem(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectSelectAll(gpointer, guintptr);
// extern void _gotk4_gtk4_IconView_ConnectItemActivated(gpointer, GtkTreePath*, guintptr);
// extern void _gotk4_gtk4_IconViewForEachFunc(GtkIconView*, GtkTreePath*, gpointer);
// extern void _gotk4_gtk4_IconTheme_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_IMContext_ConnectPreeditStart(gpointer, guintptr);
// extern void _gotk4_gtk4_IMContext_ConnectPreeditEnd(gpointer, guintptr);
// extern void _gotk4_gtk4_IMContext_ConnectPreeditChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_IMContext_ConnectCommit(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_IMContextClass_set_use_preedit(GtkIMContext*, gboolean);
// extern void _gotk4_gtk4_IMContextClass_set_surrounding_with_selection(GtkIMContext*, char*, int, int, int);
// extern void _gotk4_gtk4_IMContextClass_set_surrounding(GtkIMContext*, char*, int, int);
// extern void _gotk4_gtk4_IMContextClass_set_cursor_location(GtkIMContext*, GdkRectangle*);
// extern void _gotk4_gtk4_IMContextClass_set_client_widget(GtkIMContext*, GtkWidget*);
// extern void _gotk4_gtk4_IMContextClass_reset(GtkIMContext*);
// extern void _gotk4_gtk4_IMContextClass_preedit_start(GtkIMContext*);
// extern void _gotk4_gtk4_IMContextClass_preedit_end(GtkIMContext*);
// extern void _gotk4_gtk4_IMContextClass_preedit_changed(GtkIMContext*);
// extern void _gotk4_gtk4_IMContextClass_get_preedit_string(GtkIMContext*, char**, PangoAttrList**, int*);
// extern void _gotk4_gtk4_IMContextClass_focus_out(GtkIMContext*);
// extern void _gotk4_gtk4_IMContextClass_focus_in(GtkIMContext*);
// extern void _gotk4_gtk4_IMContextClass_commit(GtkIMContext*, char*);
// extern void _gotk4_gtk4_GridView_ConnectActivate(gpointer, guint, guintptr);
// extern void _gotk4_gtk4_Gesture_ConnectUpdate(gpointer, GdkEventSequence*, guintptr);
// extern void _gotk4_gtk4_Gesture_ConnectSequenceStateChanged(gpointer, GdkEventSequence*, GtkEventSequenceState, guintptr);
// extern void _gotk4_gtk4_Gesture_ConnectEnd(gpointer, GdkEventSequence*, guintptr);
// extern void _gotk4_gtk4_Gesture_ConnectCancel(gpointer, GdkEventSequence*, guintptr);
// extern void _gotk4_gtk4_Gesture_ConnectBegin(gpointer, GdkEventSequence*, guintptr);
// extern void _gotk4_gtk4_GestureZoom_ConnectScaleChanged(gpointer, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureSwipe_ConnectSwipe(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureStylus_ConnectUp(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureStylus_ConnectProximity(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureStylus_ConnectMotion(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureStylus_ConnectDown(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureRotate_ConnectAngleChanged(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GesturePan_ConnectPan(gpointer, GtkPanDirection, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureLongPress_ConnectPressed(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureLongPress_ConnectCancelled(gpointer, guintptr);
// extern void _gotk4_gtk4_GestureDrag_ConnectDragUpdate(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureDrag_ConnectDragEnd(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureDrag_ConnectDragBegin(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureClick_ConnectUnpairedRelease(gpointer, gdouble, gdouble, guint, GdkEventSequence*, guintptr);
// extern void _gotk4_gtk4_GestureClick_ConnectStopped(gpointer, guintptr);
// extern void _gotk4_gtk4_GestureClick_ConnectReleased(gpointer, gint, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GestureClick_ConnectPressed(gpointer, gint, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_GLArea_ConnectResize(gpointer, gint, gint, guintptr);
// extern void _gotk4_gtk4_GLAreaClass_resize(GtkGLArea*, int, int);
// extern void _gotk4_gtk4_FrameClass_compute_child_allocation(GtkFrame*, GtkAllocation*);
// extern void _gotk4_gtk4_FontChooser_ConnectFontActivated(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_FontButton_ConnectFontSet(gpointer, guintptr);
// extern void _gotk4_gtk4_FlowBox_ConnectUnselectAll(gpointer, guintptr);
// extern void _gotk4_gtk4_FlowBox_ConnectToggleCursorChild(gpointer, guintptr);
// extern void _gotk4_gtk4_FlowBox_ConnectSelectedChildrenChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_FlowBox_ConnectSelectAll(gpointer, guintptr);
// extern void _gotk4_gtk4_FlowBox_ConnectChildActivated(gpointer, GtkFlowBoxChild*, guintptr);
// extern void _gotk4_gtk4_FlowBox_ConnectActivateCursorChild(gpointer, guintptr);
// extern void _gotk4_gtk4_FlowBoxForEachFunc(GtkFlowBox*, GtkFlowBoxChild*, gpointer);
// extern void _gotk4_gtk4_FlowBoxChild_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_FlowBoxChildClass_activate(GtkFlowBoxChild*);
// extern void _gotk4_gtk4_Filter_ConnectChanged(gpointer, GtkFilterChange, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectUpFolder(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectShowHidden(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectSearchShortcut(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectRecentShortcut(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectQuickBookmark(gpointer, gint, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectPlacesShortcut(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectLocationTogglePopup(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectLocationPopupOnPaste(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectLocationPopup(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectHomeFolder(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectDownFolder(gpointer, guintptr);
// extern void _gotk4_gtk4_FileChooserWidget_ConnectDesktopFolder(gpointer, guintptr);
// extern void _gotk4_gtk4_ExpressionNotify(gpointer);
// extern void _gotk4_gtk4_Expander_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerScroll_ConnectScrollEnd(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerScroll_ConnectScrollBegin(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerScroll_ConnectDecelerate(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_EventControllerMotion_ConnectMotion(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_EventControllerMotion_ConnectLeave(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerMotion_ConnectEnter(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_EventControllerKey_ConnectKeyReleased(gpointer, guint, guint, GdkModifierType, guintptr);
// extern void _gotk4_gtk4_EventControllerKey_ConnectIMUpdate(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerFocus_ConnectLeave(gpointer, guintptr);
// extern void _gotk4_gtk4_EventControllerFocus_ConnectEnter(gpointer, guintptr);
// extern void _gotk4_gtk4_Entry_ConnectIconRelease(gpointer, GtkEntryIconPosition, guintptr);
// extern void _gotk4_gtk4_Entry_ConnectIconPress(gpointer, GtkEntryIconPosition, guintptr);
// extern void _gotk4_gtk4_Entry_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_EntryCompletion_ConnectNoMatches(gpointer, guintptr);
// extern void _gotk4_gtk4_EntryClass_activate(GtkEntry*);
// extern void _gotk4_gtk4_EntryBuffer_ConnectInsertedText(gpointer, guint, gchar*, guint, guintptr);
// extern void _gotk4_gtk4_EntryBuffer_ConnectDeletedText(gpointer, guint, guint, guintptr);
// extern void _gotk4_gtk4_EntryBufferClass_inserted_text(GtkEntryBuffer*, guint, char*, guint);
// extern void _gotk4_gtk4_EntryBufferClass_deleted_text(GtkEntryBuffer*, guint, guint);
// extern void _gotk4_gtk4_EmojiChooser_ConnectEmojiPicked(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_EditableTextWidget_ConnectDeleteText(gpointer, gint, gint, guintptr);
// extern void _gotk4_gtk4_EditableTextWidget_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_DropTarget_ConnectLeave(gpointer, guintptr);
// extern void _gotk4_gtk4_DropTargetAsync_ConnectDragLeave(gpointer, GdkDrop*, guintptr);
// extern void _gotk4_gtk4_DropControllerMotion_ConnectMotion(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_DropControllerMotion_ConnectLeave(gpointer, guintptr);
// extern void _gotk4_gtk4_DropControllerMotion_ConnectEnter(gpointer, gdouble, gdouble, guintptr);
// extern void _gotk4_gtk4_DrawingArea_ConnectResize(gpointer, gint, gint, guintptr);
// extern void _gotk4_gtk4_DrawingAreaDrawFunc(GtkDrawingArea*, cairo_t*, int, int, gpointer);
// extern void _gotk4_gtk4_DrawingAreaClass_resize(GtkDrawingArea*, int, int);
// extern void _gotk4_gtk4_DragSource_ConnectDragEnd(gpointer, GdkDrag*, gboolean, guintptr);
// extern void _gotk4_gtk4_DragSource_ConnectDragBegin(gpointer, GdkDrag*, guintptr);
// extern void _gotk4_gtk4_Dialog_ConnectResponse(gpointer, gint, guintptr);
// extern void _gotk4_gtk4_Dialog_ConnectClose(gpointer, guintptr);
// extern void _gotk4_gtk4_DialogClass_response(GtkDialog*, int);
// extern void _gotk4_gtk4_DialogClass_close(GtkDialog*);
// extern void _gotk4_gtk4_CssProvider_ConnectParsingError(gpointer, GtkCssSection*, GError*, guintptr);
// extern void _gotk4_gtk4_ComboBox_ConnectPopup(gpointer, guintptr);
// extern void _gotk4_gtk4_ComboBox_ConnectMoveActive(gpointer, GtkScrollType, guintptr);
// extern void _gotk4_gtk4_ComboBox_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_ComboBoxClass_changed(GtkComboBox*);
// extern void _gotk4_gtk4_ColumnView_ConnectActivate(gpointer, guint, guintptr);
// extern void _gotk4_gtk4_ColorChooser_ConnectColorActivated(gpointer, GdkRGBA*, guintptr);
// extern void _gotk4_gtk4_ColorButton_ConnectColorSet(gpointer, guintptr);
// extern void _gotk4_gtk4_CheckButton_ConnectToggled(gpointer, guintptr);
// extern void _gotk4_gtk4_CheckButton_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_CheckButtonClass_toggled(GtkCheckButton*);
// extern void _gotk4_gtk4_CheckButtonClass_activate(GtkCheckButton*);
// extern void _gotk4_gtk4_CellRenderer_ConnectEditingStarted(gpointer, GtkCellEditable*, gchar*, guintptr);
// extern void _gotk4_gtk4_CellRenderer_ConnectEditingCanceled(gpointer, guintptr);
// extern void _gotk4_gtk4_CellRendererToggle_ConnectToggled(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_CellRendererText_ConnectEdited(gpointer, gchar*, gchar*, guintptr);
// extern void _gotk4_gtk4_CellRendererTextClass_edited(GtkCellRendererText*, char*, char*);
// extern void _gotk4_gtk4_CellRendererCombo_ConnectChanged(gpointer, gchar*, GtkTreeIter*, guintptr);
// extern void _gotk4_gtk4_CellRendererClass_snapshot(GtkCellRenderer*, GtkSnapshot*, GtkWidget*, GdkRectangle*, GdkRectangle*, GtkCellRendererState);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_width_for_height(GtkCellRenderer*, GtkWidget*, int, int*, int*);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_width(GtkCellRenderer*, GtkWidget*, int*, int*);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_height_for_width(GtkCellRenderer*, GtkWidget*, int, int*, int*);
// extern void _gotk4_gtk4_CellRendererClass_get_preferred_height(GtkCellRenderer*, GtkWidget*, int*, int*);
// extern void _gotk4_gtk4_CellRendererClass_get_aligned_area(GtkCellRenderer*, GtkWidget*, GtkCellRendererState, GdkRectangle*, GdkRectangle*);
// extern void _gotk4_gtk4_CellRendererClass_editing_started(GtkCellRenderer*, GtkCellEditable*, char*);
// extern void _gotk4_gtk4_CellRendererClass_editing_canceled(GtkCellRenderer*);
// extern void _gotk4_gtk4_CellRendererAccel_ConnectAccelEdited(gpointer, gchar*, guint, GdkModifierType, guint, guintptr);
// extern void _gotk4_gtk4_CellRendererAccel_ConnectAccelCleared(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_CellLayoutDataFunc(GtkCellLayout*, GtkCellRenderer*, GtkTreeModel*, GtkTreeIter*, gpointer);
// extern void _gotk4_gtk4_CellEditable_ConnectRemoveWidget(gpointer, guintptr);
// extern void _gotk4_gtk4_CellEditable_ConnectEditingDone(gpointer, guintptr);
// extern void _gotk4_gtk4_CellArea_ConnectRemoveEditable(gpointer, GtkCellRenderer*, GtkCellEditable*, guintptr);
// extern void _gotk4_gtk4_CellArea_ConnectFocusChanged(gpointer, GtkCellRenderer*, gchar*, guintptr);
// extern void _gotk4_gtk4_CellArea_ConnectApplyAttributes(gpointer, GtkTreeModel*, GtkTreeIter*, gboolean, gboolean, guintptr);
// extern void _gotk4_gtk4_CellArea_ConnectAddEditable(gpointer, GtkCellRenderer*, GtkCellEditable*, GdkRectangle*, gchar*, guintptr);
// extern void _gotk4_gtk4_CellAreaContextClass_reset(GtkCellAreaContext*);
// extern void _gotk4_gtk4_CellAreaContextClass_get_preferred_width_for_height(GtkCellAreaContext*, int, int*, int*);
// extern void _gotk4_gtk4_CellAreaContextClass_get_preferred_height_for_width(GtkCellAreaContext*, int, int*, int*);
// extern void _gotk4_gtk4_CellAreaContextClass_allocate(GtkCellAreaContext*, int, int);
// extern void _gotk4_gtk4_CellAreaClass_snapshot(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GtkSnapshot*, GdkRectangle*, GdkRectangle*, GtkCellRendererState, gboolean);
// extern void _gotk4_gtk4_CellAreaClass_remove(GtkCellArea*, GtkCellRenderer*);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_width_for_height(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_width(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_height_for_width(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_get_preferred_height(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int*, int*);
// extern void _gotk4_gtk4_CellAreaClass_apply_attributes(GtkCellArea*, GtkTreeModel*, GtkTreeIter*, gboolean, gboolean);
// extern void _gotk4_gtk4_CellAreaClass_add(GtkCellArea*, GtkCellRenderer*);
// extern void _gotk4_gtk4_Calendar_ConnectPrevYear(gpointer, guintptr);
// extern void _gotk4_gtk4_Calendar_ConnectPrevMonth(gpointer, guintptr);
// extern void _gotk4_gtk4_Calendar_ConnectNextYear(gpointer, guintptr);
// extern void _gotk4_gtk4_Calendar_ConnectNextMonth(gpointer, guintptr);
// extern void _gotk4_gtk4_Calendar_ConnectDaySelected(gpointer, guintptr);
// extern void _gotk4_gtk4_Button_ConnectClicked(gpointer, guintptr);
// extern void _gotk4_gtk4_Button_ConnectActivate(gpointer, guintptr);
// extern void _gotk4_gtk4_ButtonClass_clicked(GtkButton*);
// extern void _gotk4_gtk4_ButtonClass_activate(GtkButton*);
// extern void _gotk4_gtk4_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern void _gotk4_gtk4_Assistant_ConnectPrepare(gpointer, GtkWidget*, guintptr);
// extern void _gotk4_gtk4_Assistant_ConnectEscape(gpointer, guintptr);
// extern void _gotk4_gtk4_Assistant_ConnectClose(gpointer, guintptr);
// extern void _gotk4_gtk4_Assistant_ConnectCancel(gpointer, guintptr);
// extern void _gotk4_gtk4_Assistant_ConnectApply(gpointer, guintptr);
// extern void _gotk4_gtk4_Application_ConnectWindowRemoved(gpointer, GtkWindow*, guintptr);
// extern void _gotk4_gtk4_Application_ConnectWindowAdded(gpointer, GtkWindow*, guintptr);
// extern void _gotk4_gtk4_Application_ConnectQueryEnd(gpointer, guintptr);
// extern void _gotk4_gtk4_ApplicationClass_window_removed(GtkApplication*, GtkWindow*);
// extern void _gotk4_gtk4_ApplicationClass_window_added(GtkApplication*, GtkWindow*);
// extern void _gotk4_gtk4_AppChooserWidget_ConnectApplicationSelected(gpointer, GAppInfo*, guintptr);
// extern void _gotk4_gtk4_AppChooserWidget_ConnectApplicationActivated(gpointer, GAppInfo*, guintptr);
// extern void _gotk4_gtk4_AppChooserButton_ConnectCustomItemActivated(gpointer, gchar*, guintptr);
// extern void _gotk4_gtk4_AppChooserButton_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_Adjustment_ConnectValueChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_Adjustment_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_AdjustmentClass_value_changed(GtkAdjustment*);
// extern void _gotk4_gtk4_AdjustmentClass_changed(GtkAdjustment*);
// extern void _gotk4_gtk4_ATContext_ConnectStateChange(gpointer, guintptr);
// extern void _gotk4_gio2_AsyncReadyCallback(GObject*, GAsyncResult*, gpointer);
// extern int _gotk4_gtk4_TreeIterCompareFunc(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, gpointer);
// extern int _gotk4_gtk4_ListBoxSortFunc(GtkListBoxRow*, GtkListBoxRow*, gpointer);
// extern int _gotk4_gtk4_FlowBoxSortFunc(GtkFlowBoxChild*, GtkFlowBoxChild*, gpointer);
// extern int _gotk4_gtk4_CellAreaClass_event(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GdkEvent*, GdkRectangle*, GtkCellRendererState);
// extern int _gotk4_gtk4_AssistantPageFunc(int, gpointer);
// extern guint _gotk4_gtk4_EntryBufferClass_insert_text(GtkEntryBuffer*, guint, char*, guint);
// extern guint _gotk4_gtk4_EntryBufferClass_get_length(GtkEntryBuffer*);
// extern guint _gotk4_gtk4_EntryBufferClass_delete_text(GtkEntryBuffer*, guint, guint);
// extern gpointer _gotk4_gtk4_MapListModelMapFunc(gpointer, gpointer);
// extern gint _gotk4_gtk4_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gint _gotk4_glib2_CompareDataFunc(gconstpointer, gconstpointer, gpointer);
// extern gchar* _gotk4_gtk4_ComboBox_ConnectFormatEntryText(gpointer, gchar*, guintptr);
// extern gboolean _gotk4_gtk4_Window_ConnectEnableDebugging(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Window_ConnectCloseRequest(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_WindowClass_enable_debugging(GtkWindow*, gboolean);
// extern gboolean _gotk4_gtk4_WindowClass_close_request(GtkWindow*);
// extern gboolean _gotk4_gtk4_Widget_ConnectQueryTooltip(gpointer, gint, gint, gboolean, GtkTooltip*, guintptr);
// extern gboolean _gotk4_gtk4_Widget_ConnectMnemonicActivate(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Widget_ConnectKeynavFailed(gpointer, GtkDirectionType, guintptr);
// extern gboolean _gotk4_gtk4_WidgetClass_query_tooltip(GtkWidget*, int, int, gboolean, GtkTooltip*);
// extern gboolean _gotk4_gtk4_WidgetClass_mnemonic_activate(GtkWidget*, gboolean);
// extern gboolean _gotk4_gtk4_WidgetClass_keynav_failed(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk4_WidgetClass_grab_focus(GtkWidget*);
// extern gboolean _gotk4_gtk4_WidgetClass_focus(GtkWidget*, GtkDirectionType);
// extern gboolean _gotk4_gtk4_WidgetClass_contains(GtkWidget*, double, double);
// extern gboolean _gotk4_gtk4_TreeView_ConnectUnselectAll(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectToggleCursorRow(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectTestExpandRow(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectTestCollapseRow(gpointer, GtkTreeIter*, GtkTreePath*, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectStartInteractiveSearch(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectSelectCursorRow(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectSelectCursorParent(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectSelectAll(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_TreeView_ConnectExpandCollapseCursorRow(gpointer, gboolean, gboolean, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_TreeViewSearchEqualFunc(GtkTreeModel*, int, char*, GtkTreeIter*, gpointer);
// extern gboolean _gotk4_gtk4_TreeViewRowSeparatorFunc(GtkTreeModel*, GtkTreeIter*, gpointer);
// extern gboolean _gotk4_gtk4_TreeViewColumnDropFunc(GtkTreeView*, GtkTreeViewColumn*, GtkTreeViewColumn*, GtkTreeViewColumn*, gpointer);
// extern gboolean _gotk4_gtk4_TreeViewClass_unselect_all(GtkTreeView*);
// extern gboolean _gotk4_gtk4_TreeViewClass_toggle_cursor_row(GtkTreeView*);
// extern gboolean _gotk4_gtk4_TreeViewClass_test_expand_row(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern gboolean _gotk4_gtk4_TreeViewClass_test_collapse_row(GtkTreeView*, GtkTreeIter*, GtkTreePath*);
// extern gboolean _gotk4_gtk4_TreeViewClass_start_interactive_search(GtkTreeView*);
// extern gboolean _gotk4_gtk4_TreeViewClass_select_cursor_row(GtkTreeView*, gboolean);
// extern gboolean _gotk4_gtk4_TreeViewClass_select_cursor_parent(GtkTreeView*);
// extern gboolean _gotk4_gtk4_TreeViewClass_select_all(GtkTreeView*);
// extern gboolean _gotk4_gtk4_TreeViewClass_move_cursor(GtkTreeView*, GtkMovementStep, int, gboolean, gboolean);
// extern gboolean _gotk4_gtk4_TreeViewClass_expand_collapse_cursor_row(GtkTreeView*, gboolean, gboolean, gboolean);
// extern gboolean _gotk4_gtk4_TreeSelectionFunc(GtkTreeSelection*, GtkTreeModel*, GtkTreePath*, gboolean, gpointer);
// extern gboolean _gotk4_gtk4_TreeModelForEachFunc(GtkTreeModel*, GtkTreePath*, GtkTreeIter*, gpointer);
// extern gboolean _gotk4_gtk4_TreeModelFilterVisibleFunc(GtkTreeModel*, GtkTreeIter*, gpointer);
// extern gboolean _gotk4_gtk4_TreeModelFilterClass_visible(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*);
// extern gboolean _gotk4_gtk4_TickCallback(GtkWidget*, GdkFrameClock*, gpointer);
// extern gboolean _gotk4_gtk4_TextView_ConnectExtendSelection(gpointer, GtkTextExtendSelection, GtkTextIter*, GtkTextIter*, GtkTextIter*, guintptr);
// extern gboolean _gotk4_gtk4_TextViewClass_extend_selection(GtkTextView*, GtkTextExtendSelection, GtkTextIter*, GtkTextIter*, GtkTextIter*);
// extern gboolean _gotk4_gtk4_TextCharPredicate(gunichar, gpointer);
// extern gboolean _gotk4_gtk4_Switch_ConnectStateSet(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_SpinButton_ConnectOutput(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_ShortcutsSection_ConnectChangeCurrentPage(gpointer, gint, guintptr);
// extern gboolean _gotk4_gtk4_ShortcutFunc(GtkWidget*, GVariant*, gpointer);
// extern gboolean _gotk4_gtk4_ScrolledWindow_ConnectScrollChild(gpointer, GtkScrollType, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Range_ConnectChangeValue(gpointer, GtkScrollType, gdouble, guintptr);
// extern gboolean _gotk4_gtk4_RangeClass_change_value(GtkRange*, GtkScrollType, double);
// extern gboolean _gotk4_gtk4_PrintOperation_ConnectPreview(gpointer, GtkPrintOperationPreview*, GtkPrintContext*, GtkWindow*, guintptr);
// extern gboolean _gotk4_gtk4_PrintOperation_ConnectPaginate(gpointer, GtkPrintContext*, guintptr);
// extern gboolean _gotk4_gtk4_PrintOperationClass_preview(GtkPrintOperation*, GtkPrintOperationPreview*, GtkPrintContext*, GtkWindow*);
// extern gboolean _gotk4_gtk4_PrintOperationClass_paginate(GtkPrintOperation*, GtkPrintContext*);
// extern gboolean _gotk4_gtk4_Paned_ConnectToggleHandleFocus(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_Paned_ConnectMoveHandle(gpointer, GtkScrollType, guintptr);
// extern gboolean _gotk4_gtk4_Paned_ConnectCycleHandleFocus(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Paned_ConnectCycleChildFocus(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Paned_ConnectCancelPosition(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_Paned_ConnectAcceptPosition(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_Overlay_ConnectGetChildPosition(gpointer, GtkWidget*, GdkRectangle*, guintptr);
// extern gboolean _gotk4_gtk4_Notebook_ConnectSelectPage(gpointer, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Notebook_ConnectReorderTab(gpointer, GtkDirectionType, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_Notebook_ConnectFocusTab(gpointer, GtkNotebookTab, guintptr);
// extern gboolean _gotk4_gtk4_Notebook_ConnectChangeCurrentPage(gpointer, gint, guintptr);
// extern gboolean _gotk4_gtk4_MediaStreamClass_play(GtkMediaStream*);
// extern gboolean _gotk4_gtk4_ListBoxFilterFunc(GtkListBoxRow*, gpointer);
// extern gboolean _gotk4_gtk4_LinkButton_ConnectActivateLink(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_Label_ConnectActivateLink(gpointer, gchar*, guintptr);
// extern gboolean _gotk4_gtk4_IconView_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_IconView_ConnectActivateCursorItem(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_IMContext_ConnectRetrieveSurrounding(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_IMContext_ConnectDeleteSurrounding(gpointer, gint, gint, guintptr);
// extern gboolean _gotk4_gtk4_IMContextClass_retrieve_surrounding(GtkIMContext*);
// extern gboolean _gotk4_gtk4_IMContextClass_get_surrounding_with_selection(GtkIMContext*, char**, int*, int*);
// extern gboolean _gotk4_gtk4_IMContextClass_get_surrounding(GtkIMContext*, char**, int*);
// extern gboolean _gotk4_gtk4_IMContextClass_filter_keypress(GtkIMContext*, GdkEvent*);
// extern gboolean _gotk4_gtk4_IMContextClass_delete_surrounding(GtkIMContext*, int, int);
// extern gboolean _gotk4_gtk4_GLArea_ConnectRender(gpointer, GdkGLContext*, guintptr);
// extern gboolean _gotk4_gtk4_GLAreaClass_render(GtkGLArea*, GdkGLContext*);
// extern gboolean _gotk4_gtk4_FontFilterFunc(PangoFontFamily*, PangoFontFace*, gpointer);
// extern gboolean _gotk4_gtk4_FlowBox_ConnectMoveCursor(gpointer, GtkMovementStep, gint, gboolean, gboolean, guintptr);
// extern gboolean _gotk4_gtk4_FlowBoxFilterFunc(GtkFlowBoxChild*, gpointer);
// extern gboolean _gotk4_gtk4_FilterClass_match(GtkFilter*, gpointer);
// extern gboolean _gotk4_gtk4_EventControllerScroll_ConnectScroll(gpointer, gdouble, gdouble, guintptr);
// extern gboolean _gotk4_gtk4_EventControllerLegacy_ConnectEvent(gpointer, GdkEvent*, guintptr);
// extern gboolean _gotk4_gtk4_EventControllerKey_ConnectModifiers(gpointer, GdkModifierType, guintptr);
// extern gboolean _gotk4_gtk4_EventControllerKey_ConnectKeyPressed(gpointer, guint, guint, GdkModifierType, guintptr);
// extern gboolean _gotk4_gtk4_EntryCompletion_ConnectMatchSelected(gpointer, GtkTreeModel*, GtkTreeIter*, guintptr);
// extern gboolean _gotk4_gtk4_EntryCompletion_ConnectInsertPrefix(gpointer, gchar*, guintptr);
// extern gboolean _gotk4_gtk4_EntryCompletion_ConnectCursorOnMatch(gpointer, GtkTreeModel*, GtkTreeIter*, guintptr);
// extern gboolean _gotk4_gtk4_EntryCompletionMatchFunc(GtkEntryCompletion*, char*, GtkTreeIter*, gpointer);
// extern gboolean _gotk4_gtk4_DropTarget_ConnectDrop(gpointer, GValue*, gdouble, gdouble, guintptr);
// extern gboolean _gotk4_gtk4_DropTarget_ConnectAccept(gpointer, GdkDrop*, guintptr);
// extern gboolean _gotk4_gtk4_DropTargetAsync_ConnectDrop(gpointer, GdkDrop*, gdouble, gdouble, guintptr);
// extern gboolean _gotk4_gtk4_DropTargetAsync_ConnectAccept(gpointer, GdkDrop*, guintptr);
// extern gboolean _gotk4_gtk4_DragSource_ConnectDragCancel(gpointer, GdkDrag*, GdkDragCancelReason, guintptr);
// extern gboolean _gotk4_gtk4_CustomFilterFunc(gpointer, gpointer);
// extern gboolean _gotk4_gtk4_ComboBox_ConnectPopdown(gpointer, guintptr);
// extern gboolean _gotk4_gtk4_CellRendererClass_activate(GtkCellRenderer*, GdkEvent*, GtkWidget*, char*, GdkRectangle*, GdkRectangle*, GtkCellRendererState);
// extern gboolean _gotk4_gtk4_CellCallback(GtkCellRenderer*, gpointer);
// extern gboolean _gotk4_gtk4_CellAreaClass_is_activatable(GtkCellArea*);
// extern gboolean _gotk4_gtk4_CellAreaClass_focus(GtkCellArea*, GtkDirectionType);
// extern gboolean _gotk4_gtk4_CellAreaClass_activate(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GdkRectangle*, GtkCellRendererState, gboolean);
// extern gboolean _gotk4_gtk4_CellAllocCallback(GtkCellRenderer*, GdkRectangle*, GdkRectangle*, gpointer);
// extern gboolean _gotk4_gtk4_AboutDialog_ConnectActivateLink(gpointer, gchar*, guintptr);
// extern char* _gotk4_gtk4_ScaleFormatValueFunc(GtkScale*, double, gpointer);
// extern char* _gotk4_gtk4_EntryBufferClass_get_text(GtkEntryBuffer*, gsize*);
// extern char* _gotk4_gtk4_ComboBoxClass_format_entry_text(GtkComboBox*, char*);
// extern GtkWidget* _gotk4_gtk4_ListBoxCreateWidgetFunc(gpointer, gpointer);
// extern GtkWidget* _gotk4_gtk4_FlowBoxCreateWidgetFunc(gpointer, gpointer);
// extern GtkSorterOrder _gotk4_gtk4_SorterClass_get_order(GtkSorter*);
// extern GtkSizeRequestMode _gotk4_gtk4_WidgetClass_get_request_mode(GtkWidget*);
// extern GtkSizeRequestMode _gotk4_gtk4_LayoutManagerClass_get_request_mode(GtkLayoutManager*, GtkWidget*);
// extern GtkSizeRequestMode _gotk4_gtk4_CellRendererClass_get_request_mode(GtkCellRenderer*);
// extern GtkSizeRequestMode _gotk4_gtk4_CellAreaClass_get_request_mode(GtkCellArea*);
// extern GtkOrdering _gotk4_gtk4_SorterClass_compare(GtkSorter*, gpointer, gpointer);
// extern GtkNotebook* _gotk4_gtk4_Notebook_ConnectCreateWindow(gpointer, GtkWidget*, guintptr);
// extern GtkLayoutChild* _gotk4_gtk4_LayoutManagerClass_create_layout_child(GtkLayoutManager*, GtkWidget*, GtkWidget*);
// extern GtkFilterMatch _gotk4_gtk4_FilterClass_get_strictness(GtkFilter*);
// extern GtkCellEditable* _gotk4_gtk4_CellRendererClass_start_editing(GtkCellRenderer*, GdkEvent*, GtkWidget*, char*, GdkRectangle*, GdkRectangle*, GtkCellRendererState);
// extern GtkCellAreaContext* _gotk4_gtk4_CellAreaClass_create_context(GtkCellArea*);
// extern GtkCellAreaContext* _gotk4_gtk4_CellAreaClass_copy_context(GtkCellArea*, GtkCellAreaContext*);
// extern GdkGLContext* _gotk4_gtk4_GLArea_ConnectCreateContext(gpointer, guintptr);
// extern GdkDragAction _gotk4_gtk4_DropTarget_ConnectMotion(gpointer, gdouble, gdouble, guintptr);
// extern GdkDragAction _gotk4_gtk4_DropTarget_ConnectEnter(gpointer, gdouble, gdouble, guintptr);
// extern GdkDragAction _gotk4_gtk4_DropTargetAsync_ConnectDragMotion(gpointer, GdkDrop*, gdouble, gdouble, guintptr);
// extern GdkDragAction _gotk4_gtk4_DropTargetAsync_ConnectDragEnter(gpointer, GdkDrop*, gdouble, gdouble, guintptr);
// extern GdkContentProvider* _gotk4_gtk4_DragSource_ConnectPrepare(gpointer, gdouble, gdouble, guintptr);
// extern GObject* _gotk4_gtk4_PrintOperation_ConnectCreateCustomWidget(gpointer, guintptr);
// extern GListModel* _gotk4_gtk4_TreeListModelCreateModelFunc(gpointer, gpointer);
// GList* _gotk4_gtk4_CellLayout_virtual_get_cells(void* fnptr, GtkCellLayout* arg0) {
//   return ((GList* (*)(GtkCellLayout*))(fnptr))(arg0);
// };
// GObject* _gotk4_gtk4_Buildable_virtual_get_internal_child(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, char* arg2) {
//   return ((GObject* (*)(GtkBuildable*, GtkBuilder*, char*))(fnptr))(arg0, arg1, arg2);
// };
// GType _gotk4_gtk4_BuilderScope_virtual_get_type_from_function(void* fnptr, GtkBuilderScope* arg0, GtkBuilder* arg1, char* arg2) {
//   return ((GType (*)(GtkBuilderScope*, GtkBuilder*, char*))(fnptr))(arg0, arg1, arg2);
// };
// GType _gotk4_gtk4_BuilderScope_virtual_get_type_from_name(void* fnptr, GtkBuilderScope* arg0, GtkBuilder* arg1, char* arg2) {
//   return ((GType (*)(GtkBuilderScope*, GtkBuilder*, char*))(fnptr))(arg0, arg1, arg2);
// };
// GType _gotk4_gtk4_TreeModel_virtual_get_column_type(void* fnptr, GtkTreeModel* arg0, int arg1) {
//   return ((GType (*)(GtkTreeModel*, int))(fnptr))(arg0, arg1);
// };
// GVariant* _gotk4_gtk4_Actionable_virtual_get_action_target_value(void* fnptr, GtkActionable* arg0) {
//   return ((GVariant* (*)(GtkActionable*))(fnptr))(arg0);
// };
// GdkContentProvider* _gotk4_gtk4_TreeDragSource_virtual_drag_data_get(void* fnptr, GtkTreeDragSource* arg0, GtkTreePath* arg1) {
//   return ((GdkContentProvider* (*)(GtkTreeDragSource*, GtkTreePath*))(fnptr))(arg0, arg1);
// };
// GtkBitset* _gotk4_gtk4_SelectionModel_virtual_get_selection_in_range(void* fnptr, GtkSelectionModel* arg0, guint arg1, guint arg2) {
//   return ((GtkBitset* (*)(GtkSelectionModel*, guint, guint))(fnptr))(arg0, arg1, arg2);
// };
// GtkCellArea* _gotk4_gtk4_CellLayout_virtual_get_area(void* fnptr, GtkCellLayout* arg0) {
//   return ((GtkCellArea* (*)(GtkCellLayout*))(fnptr))(arg0);
// };
// GtkCellAreaContext* _gotk4_gtk4_CellArea_virtual_copy_context(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1) {
//   return ((GtkCellAreaContext* (*)(GtkCellArea*, GtkCellAreaContext*))(fnptr))(arg0, arg1);
// };
// GtkCellAreaContext* _gotk4_gtk4_CellArea_virtual_create_context(void* fnptr, GtkCellArea* arg0) {
//   return ((GtkCellAreaContext* (*)(GtkCellArea*))(fnptr))(arg0);
// };
// GtkCellEditable* _gotk4_gtk4_CellRenderer_virtual_start_editing(void* fnptr, GtkCellRenderer* arg0, GdkEvent* arg1, GtkWidget* arg2, char* arg3, GdkRectangle* arg4, GdkRectangle* arg5, GtkCellRendererState arg6) {
//   return ((GtkCellEditable* (*)(GtkCellRenderer*, GdkEvent*, GtkWidget*, char*, GdkRectangle*, GdkRectangle*, GtkCellRendererState))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// GtkEditable* _gotk4_gtk4_EditableTextWidget_virtual_get_delegate(void* fnptr, GtkEditable* arg0) {
//   return ((GtkEditable* (*)(GtkEditable*))(fnptr))(arg0);
// };
// GtkFilterMatch _gotk4_gtk4_Filter_virtual_get_strictness(void* fnptr, GtkFilter* arg0) {
//   return ((GtkFilterMatch (*)(GtkFilter*))(fnptr))(arg0);
// };
// GtkLayoutChild* _gotk4_gtk4_LayoutManager_virtual_create_layout_child(void* fnptr, GtkLayoutManager* arg0, GtkWidget* arg1, GtkWidget* arg2) {
//   return ((GtkLayoutChild* (*)(GtkLayoutManager*, GtkWidget*, GtkWidget*))(fnptr))(arg0, arg1, arg2);
// };
// GtkOrdering _gotk4_gtk4_Sorter_virtual_compare(void* fnptr, GtkSorter* arg0, gpointer arg1, gpointer arg2) {
//   return ((GtkOrdering (*)(GtkSorter*, gpointer, gpointer))(fnptr))(arg0, arg1, arg2);
// };
// GtkSizeRequestMode _gotk4_gtk4_CellArea_virtual_get_request_mode(void* fnptr, GtkCellArea* arg0) {
//   return ((GtkSizeRequestMode (*)(GtkCellArea*))(fnptr))(arg0);
// };
// GtkSizeRequestMode _gotk4_gtk4_CellRenderer_virtual_get_request_mode(void* fnptr, GtkCellRenderer* arg0) {
//   return ((GtkSizeRequestMode (*)(GtkCellRenderer*))(fnptr))(arg0);
// };
// GtkSizeRequestMode _gotk4_gtk4_LayoutManager_virtual_get_request_mode(void* fnptr, GtkLayoutManager* arg0, GtkWidget* arg1) {
//   return ((GtkSizeRequestMode (*)(GtkLayoutManager*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// GtkSizeRequestMode _gotk4_gtk4_Widget_virtual_get_request_mode(void* fnptr, GtkWidget* arg0) {
//   return ((GtkSizeRequestMode (*)(GtkWidget*))(fnptr))(arg0);
// };
// GtkSorterOrder _gotk4_gtk4_Sorter_virtual_get_order(void* fnptr, GtkSorter* arg0) {
//   return ((GtkSorterOrder (*)(GtkSorter*))(fnptr))(arg0);
// };
// GtkTreeModelFlags _gotk4_gtk4_TreeModel_virtual_get_flags(void* fnptr, GtkTreeModel* arg0) {
//   return ((GtkTreeModelFlags (*)(GtkTreeModel*))(fnptr))(arg0);
// };
// GtkTreePath* _gotk4_gtk4_TreeModel_virtual_get_path(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1) {
//   return ((GtkTreePath* (*)(GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1);
// };
// GtkWidget* _gotk4_gtk4_dialog_new2(const gchar* title, GtkWindow* parent, GtkDialogFlags flags) {
// 	return gtk_dialog_new_with_buttons(title, parent, flags, NULL, NULL);
// }
// GtkWidget* _gotk4_gtk_message_dialog_new2(GtkWindow* parent, GtkDialogFlags flags, GtkMessageType type, GtkButtonsType buttons) {
// 	return gtk_message_dialog_new_with_markup(parent, flags, type, buttons, NULL);
// }
// PangoFontFace* _gotk4_gtk4_FontChooser_virtual_get_font_face(void* fnptr, GtkFontChooser* arg0) {
//   return ((PangoFontFace* (*)(GtkFontChooser*))(fnptr))(arg0);
// };
// PangoFontFamily* _gotk4_gtk4_FontChooser_virtual_get_font_family(void* fnptr, GtkFontChooser* arg0) {
//   return ((PangoFontFamily* (*)(GtkFontChooser*))(fnptr))(arg0);
// };
// PangoFontMap* _gotk4_gtk4_FontChooser_virtual_get_font_map(void* fnptr, GtkFontChooser* arg0) {
//   return ((PangoFontMap* (*)(GtkFontChooser*))(fnptr))(arg0);
// };
// char* _gotk4_gtk4_Actionable_virtual_get_action_name(void* fnptr, GtkActionable* arg0) {
//   return ((char* (*)(GtkActionable*))(fnptr))(arg0);
// };
// char* _gotk4_gtk4_Buildable_virtual_get_id(void* fnptr, GtkBuildable* arg0) {
//   return ((char* (*)(GtkBuildable*))(fnptr))(arg0);
// };
// char* _gotk4_gtk4_ComboBox_virtual_format_entry_text(void* fnptr, GtkComboBox* arg0, char* arg1) {
//   return ((char* (*)(GtkComboBox*, char*))(fnptr))(arg0, arg1);
// };
// char* _gotk4_gtk4_EditableTextWidget_virtual_get_text(void* fnptr, GtkEditable* arg0) {
//   return ((char* (*)(GtkEditable*))(fnptr))(arg0);
// };
// char* _gotk4_gtk4_EntryBuffer_virtual_get_text(void* fnptr, GtkEntryBuffer* arg0, gsize* arg1) {
//   return ((char* (*)(GtkEntryBuffer*, gsize*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_Buildable_virtual_custom_tag_start(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3, GtkBuildableParser* arg4, gpointer* arg5) {
//   return ((gboolean (*)(GtkBuildable*, GtkBuilder*, GObject*, char*, GtkBuildableParser*, gpointer*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// gboolean _gotk4_gtk4_CellArea_virtual_activate(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, GdkRectangle* arg3, GtkCellRendererState arg4, gboolean arg5) {
//   return ((gboolean (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GdkRectangle*, GtkCellRendererState, gboolean))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// gboolean _gotk4_gtk4_CellArea_virtual_focus(void* fnptr, GtkCellArea* arg0, GtkDirectionType arg1) {
//   return ((gboolean (*)(GtkCellArea*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_CellArea_virtual_is_activatable(void* fnptr, GtkCellArea* arg0) {
//   return ((gboolean (*)(GtkCellArea*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_CellRenderer_virtual_activate(void* fnptr, GtkCellRenderer* arg0, GdkEvent* arg1, GtkWidget* arg2, char* arg3, GdkRectangle* arg4, GdkRectangle* arg5, GtkCellRendererState arg6) {
//   return ((gboolean (*)(GtkCellRenderer*, GdkEvent*, GtkWidget*, char*, GdkRectangle*, GdkRectangle*, GtkCellRendererState))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// gboolean _gotk4_gtk4_EditableTextWidget_virtual_get_selection_bounds(void* fnptr, GtkEditable* arg0, int* arg1, int* arg2) {
//   return ((gboolean (*)(GtkEditable*, int*, int*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_Filter_virtual_match(void* fnptr, GtkFilter* arg0, gpointer arg1) {
//   return ((gboolean (*)(GtkFilter*, gpointer))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_GLArea_virtual_render(void* fnptr, GtkGLArea* arg0, GdkGLContext* arg1) {
//   return ((gboolean (*)(GtkGLArea*, GdkGLContext*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_IMContext_virtual_delete_surrounding(void* fnptr, GtkIMContext* arg0, int arg1, int arg2) {
//   return ((gboolean (*)(GtkIMContext*, int, int))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_IMContext_virtual_filter_keypress(void* fnptr, GtkIMContext* arg0, GdkEvent* arg1) {
//   return ((gboolean (*)(GtkIMContext*, GdkEvent*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_IMContext_virtual_get_surrounding(void* fnptr, GtkIMContext* arg0, char** arg1, int* arg2) {
//   return ((gboolean (*)(GtkIMContext*, char**, int*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_IMContext_virtual_get_surrounding_with_selection(void* fnptr, GtkIMContext* arg0, char** arg1, int* arg2, int* arg3) {
//   return ((gboolean (*)(GtkIMContext*, char**, int*, int*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gtk4_IMContext_virtual_retrieve_surrounding(void* fnptr, GtkIMContext* arg0) {
//   return ((gboolean (*)(GtkIMContext*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_MediaStream_virtual_play(void* fnptr, GtkMediaStream* arg0) {
//   return ((gboolean (*)(GtkMediaStream*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_PrintOperationPreview_virtual_is_selected(void* fnptr, GtkPrintOperationPreview* arg0, int arg1) {
//   return ((gboolean (*)(GtkPrintOperationPreview*, int))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_PrintOperation_virtual_paginate(void* fnptr, GtkPrintOperation* arg0, GtkPrintContext* arg1) {
//   return ((gboolean (*)(GtkPrintOperation*, GtkPrintContext*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_PrintOperation_virtual_preview(void* fnptr, GtkPrintOperation* arg0, GtkPrintOperationPreview* arg1, GtkPrintContext* arg2, GtkWindow* arg3) {
//   return ((gboolean (*)(GtkPrintOperation*, GtkPrintOperationPreview*, GtkPrintContext*, GtkWindow*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gtk4_Range_virtual_change_value(void* fnptr, GtkRange* arg0, GtkScrollType arg1, double arg2) {
//   return ((gboolean (*)(GtkRange*, GtkScrollType, double))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_Scrollable_virtual_get_border(void* fnptr, GtkScrollable* arg0, GtkBorder* arg1) {
//   return ((gboolean (*)(GtkScrollable*, GtkBorder*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_is_selected(void* fnptr, GtkSelectionModel* arg0, guint arg1) {
//   return ((gboolean (*)(GtkSelectionModel*, guint))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_select_all(void* fnptr, GtkSelectionModel* arg0) {
//   return ((gboolean (*)(GtkSelectionModel*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_select_item(void* fnptr, GtkSelectionModel* arg0, guint arg1, gboolean arg2) {
//   return ((gboolean (*)(GtkSelectionModel*, guint, gboolean))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_select_range(void* fnptr, GtkSelectionModel* arg0, guint arg1, guint arg2, gboolean arg3) {
//   return ((gboolean (*)(GtkSelectionModel*, guint, guint, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_set_selection(void* fnptr, GtkSelectionModel* arg0, GtkBitset* arg1, GtkBitset* arg2) {
//   return ((gboolean (*)(GtkSelectionModel*, GtkBitset*, GtkBitset*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_unselect_all(void* fnptr, GtkSelectionModel* arg0) {
//   return ((gboolean (*)(GtkSelectionModel*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_unselect_item(void* fnptr, GtkSelectionModel* arg0, guint arg1) {
//   return ((gboolean (*)(GtkSelectionModel*, guint))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_SelectionModel_virtual_unselect_range(void* fnptr, GtkSelectionModel* arg0, guint arg1, guint arg2) {
//   return ((gboolean (*)(GtkSelectionModel*, guint, guint))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TextView_virtual_extend_selection(void* fnptr, GtkTextView* arg0, GtkTextExtendSelection arg1, GtkTextIter* arg2, GtkTextIter* arg3, GtkTextIter* arg4) {
//   return ((gboolean (*)(GtkTextView*, GtkTextExtendSelection, GtkTextIter*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gtk4_TreeDragDest_virtual_drag_data_received(void* fnptr, GtkTreeDragDest* arg0, GtkTreePath* arg1, GValue* arg2) {
//   return ((gboolean (*)(GtkTreeDragDest*, GtkTreePath*, GValue*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeDragDest_virtual_row_drop_possible(void* fnptr, GtkTreeDragDest* arg0, GtkTreePath* arg1, GValue* arg2) {
//   return ((gboolean (*)(GtkTreeDragDest*, GtkTreePath*, GValue*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeDragSource_virtual_drag_data_delete(void* fnptr, GtkTreeDragSource* arg0, GtkTreePath* arg1) {
//   return ((gboolean (*)(GtkTreeDragSource*, GtkTreePath*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_TreeDragSource_virtual_row_draggable(void* fnptr, GtkTreeDragSource* arg0, GtkTreePath* arg1) {
//   return ((gboolean (*)(GtkTreeDragSource*, GtkTreePath*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_TreeModelFilter_virtual_visible(void* fnptr, GtkTreeModelFilter* arg0, GtkTreeModel* arg1, GtkTreeIter* arg2) {
//   return ((gboolean (*)(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeModel_virtual_get_iter(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1, GtkTreePath* arg2) {
//   return ((gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreePath*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeModel_virtual_iter_children(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1, GtkTreeIter* arg2) {
//   return ((gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeModel_virtual_iter_has_child(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1) {
//   return ((gboolean (*)(GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_TreeModel_virtual_iter_next(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1) {
//   return ((gboolean (*)(GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_TreeModel_virtual_iter_nth_child(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1, GtkTreeIter* arg2, int arg3) {
//   return ((gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gtk4_TreeModel_virtual_iter_parent(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1, GtkTreeIter* arg2) {
//   return ((gboolean (*)(GtkTreeModel*, GtkTreeIter*, GtkTreeIter*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeModel_virtual_iter_previous(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1) {
//   return ((gboolean (*)(GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_TreeSortable_virtual_get_sort_column_id(void* fnptr, GtkTreeSortable* arg0, int* arg1, GtkSortType* arg2) {
//   return ((gboolean (*)(GtkTreeSortable*, int*, GtkSortType*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeSortable_virtual_has_default_sort_func(void* fnptr, GtkTreeSortable* arg0) {
//   return ((gboolean (*)(GtkTreeSortable*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_expand_collapse_cursor_row(void* fnptr, GtkTreeView* arg0, gboolean arg1, gboolean arg2, gboolean arg3) {
//   return ((gboolean (*)(GtkTreeView*, gboolean, gboolean, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_move_cursor(void* fnptr, GtkTreeView* arg0, GtkMovementStep arg1, int arg2, gboolean arg3, gboolean arg4) {
//   return ((gboolean (*)(GtkTreeView*, GtkMovementStep, int, gboolean, gboolean))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_select_all(void* fnptr, GtkTreeView* arg0) {
//   return ((gboolean (*)(GtkTreeView*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_select_cursor_parent(void* fnptr, GtkTreeView* arg0) {
//   return ((gboolean (*)(GtkTreeView*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_select_cursor_row(void* fnptr, GtkTreeView* arg0, gboolean arg1) {
//   return ((gboolean (*)(GtkTreeView*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_start_interactive_search(void* fnptr, GtkTreeView* arg0) {
//   return ((gboolean (*)(GtkTreeView*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_test_collapse_row(void* fnptr, GtkTreeView* arg0, GtkTreeIter* arg1, GtkTreePath* arg2) {
//   return ((gboolean (*)(GtkTreeView*, GtkTreeIter*, GtkTreePath*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_test_expand_row(void* fnptr, GtkTreeView* arg0, GtkTreeIter* arg1, GtkTreePath* arg2) {
//   return ((gboolean (*)(GtkTreeView*, GtkTreeIter*, GtkTreePath*))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_toggle_cursor_row(void* fnptr, GtkTreeView* arg0) {
//   return ((gboolean (*)(GtkTreeView*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_TreeView_virtual_unselect_all(void* fnptr, GtkTreeView* arg0) {
//   return ((gboolean (*)(GtkTreeView*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_Widget_virtual_contains(void* fnptr, GtkWidget* arg0, double arg1, double arg2) {
//   return ((gboolean (*)(GtkWidget*, double, double))(fnptr))(arg0, arg1, arg2);
// };
// gboolean _gotk4_gtk4_Widget_virtual_focus(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   return ((gboolean (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_Widget_virtual_grab_focus(void* fnptr, GtkWidget* arg0) {
//   return ((gboolean (*)(GtkWidget*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_Widget_virtual_keynav_failed(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   return ((gboolean (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_Widget_virtual_mnemonic_activate(void* fnptr, GtkWidget* arg0, gboolean arg1) {
//   return ((gboolean (*)(GtkWidget*, gboolean))(fnptr))(arg0, arg1);
// };
// gboolean _gotk4_gtk4_Widget_virtual_query_tooltip(void* fnptr, GtkWidget* arg0, int arg1, int arg2, gboolean arg3, GtkTooltip* arg4) {
//   return ((gboolean (*)(GtkWidget*, int, int, gboolean, GtkTooltip*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// gboolean _gotk4_gtk4_Window_virtual_close_request(void* fnptr, GtkWindow* arg0) {
//   return ((gboolean (*)(GtkWindow*))(fnptr))(arg0);
// };
// gboolean _gotk4_gtk4_Window_virtual_enable_debugging(void* fnptr, GtkWindow* arg0, gboolean arg1) {
//   return ((gboolean (*)(GtkWindow*, gboolean))(fnptr))(arg0, arg1);
// };
// guint _gotk4_gtk4_EntryBuffer_virtual_delete_text(void* fnptr, GtkEntryBuffer* arg0, guint arg1, guint arg2) {
//   return ((guint (*)(GtkEntryBuffer*, guint, guint))(fnptr))(arg0, arg1, arg2);
// };
// guint _gotk4_gtk4_EntryBuffer_virtual_get_length(void* fnptr, GtkEntryBuffer* arg0) {
//   return ((guint (*)(GtkEntryBuffer*))(fnptr))(arg0);
// };
// guint _gotk4_gtk4_EntryBuffer_virtual_insert_text(void* fnptr, GtkEntryBuffer* arg0, guint arg1, char* arg2, guint arg3) {
//   return ((guint (*)(GtkEntryBuffer*, guint, char*, guint))(fnptr))(arg0, arg1, arg2, arg3);
// };
// int _gotk4_gtk4_CellArea_virtual_event(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, GdkEvent* arg3, GdkRectangle* arg4, GtkCellRendererState arg5) {
//   return ((int (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GdkEvent*, GdkRectangle*, GtkCellRendererState))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// int _gotk4_gtk4_FontChooser_virtual_get_font_size(void* fnptr, GtkFontChooser* arg0) {
//   return ((int (*)(GtkFontChooser*))(fnptr))(arg0);
// };
// int _gotk4_gtk4_TreeModel_virtual_get_n_columns(void* fnptr, GtkTreeModel* arg0) {
//   return ((int (*)(GtkTreeModel*))(fnptr))(arg0);
// };
// int _gotk4_gtk4_TreeModel_virtual_iter_n_children(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1) {
//   return ((int (*)(GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Actionable_virtual_set_action_name(void* fnptr, GtkActionable* arg0, char* arg1) {
//   ((void (*)(GtkActionable*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Actionable_virtual_set_action_target_value(void* fnptr, GtkActionable* arg0, GVariant* arg1) {
//   ((void (*)(GtkActionable*, GVariant*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Adjustment_virtual_changed(void* fnptr, GtkAdjustment* arg0) {
//   ((void (*)(GtkAdjustment*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Adjustment_virtual_value_changed(void* fnptr, GtkAdjustment* arg0) {
//   ((void (*)(GtkAdjustment*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Application_virtual_window_added(void* fnptr, GtkApplication* arg0, GtkWindow* arg1) {
//   ((void (*)(GtkApplication*, GtkWindow*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Application_virtual_window_removed(void* fnptr, GtkApplication* arg0, GtkWindow* arg1) {
//   ((void (*)(GtkApplication*, GtkWindow*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Buildable_virtual_add_child(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, GObject*, char*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Buildable_virtual_custom_finished(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3, gpointer arg4) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, GObject*, char*, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_Buildable_virtual_custom_tag_end(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, GObject* arg2, char* arg3, gpointer arg4) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, GObject*, char*, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_Buildable_virtual_parser_finished(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1) {
//   ((void (*)(GtkBuildable*, GtkBuilder*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Buildable_virtual_set_buildable_property(void* fnptr, GtkBuildable* arg0, GtkBuilder* arg1, char* arg2, GValue* arg3) {
//   ((void (*)(GtkBuildable*, GtkBuilder*, char*, GValue*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Buildable_virtual_set_id(void* fnptr, GtkBuildable* arg0, char* arg1) {
//   ((void (*)(GtkBuildable*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Button_virtual_activate(void* fnptr, GtkButton* arg0) {
//   ((void (*)(GtkButton*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Button_virtual_clicked(void* fnptr, GtkButton* arg0) {
//   ((void (*)(GtkButton*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_CellAreaContext_virtual_allocate(void* fnptr, GtkCellAreaContext* arg0, int arg1, int arg2) {
//   ((void (*)(GtkCellAreaContext*, int, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_CellAreaContext_virtual_get_preferred_height_for_width(void* fnptr, GtkCellAreaContext* arg0, int arg1, int* arg2, int* arg3) {
//   ((void (*)(GtkCellAreaContext*, int, int*, int*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_CellAreaContext_virtual_get_preferred_width_for_height(void* fnptr, GtkCellAreaContext* arg0, int arg1, int* arg2, int* arg3) {
//   ((void (*)(GtkCellAreaContext*, int, int*, int*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_CellAreaContext_virtual_reset(void* fnptr, GtkCellAreaContext* arg0) {
//   ((void (*)(GtkCellAreaContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_CellArea_virtual_add(void* fnptr, GtkCellArea* arg0, GtkCellRenderer* arg1) {
//   ((void (*)(GtkCellArea*, GtkCellRenderer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_CellArea_virtual_apply_attributes(void* fnptr, GtkCellArea* arg0, GtkTreeModel* arg1, GtkTreeIter* arg2, gboolean arg3, gboolean arg4) {
//   ((void (*)(GtkCellArea*, GtkTreeModel*, GtkTreeIter*, gboolean, gboolean))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_CellArea_virtual_foreach(void* fnptr, GtkCellArea* arg0, GtkCellCallback arg1, gpointer arg2) {
//   ((void (*)(GtkCellArea*, GtkCellCallback, gpointer))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_CellArea_virtual_foreach_alloc(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, GdkRectangle* arg3, GdkRectangle* arg4, GtkCellAllocCallback arg5, gpointer arg6) {
//   ((void (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GdkRectangle*, GdkRectangle*, GtkCellAllocCallback, gpointer))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gtk4_CellArea_virtual_get_preferred_height(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, int* arg3, int* arg4) {
//   ((void (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_CellArea_virtual_get_preferred_height_for_width(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, int arg3, int* arg4, int* arg5) {
//   ((void (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gtk4_CellArea_virtual_get_preferred_width(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, int* arg3, int* arg4) {
//   ((void (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_CellArea_virtual_get_preferred_width_for_height(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, int arg3, int* arg4, int* arg5) {
//   ((void (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, int, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gtk4_CellArea_virtual_remove(void* fnptr, GtkCellArea* arg0, GtkCellRenderer* arg1) {
//   ((void (*)(GtkCellArea*, GtkCellRenderer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_CellArea_virtual_snapshot(void* fnptr, GtkCellArea* arg0, GtkCellAreaContext* arg1, GtkWidget* arg2, GtkSnapshot* arg3, GdkRectangle* arg4, GdkRectangle* arg5, GtkCellRendererState arg6, gboolean arg7) {
//   ((void (*)(GtkCellArea*, GtkCellAreaContext*, GtkWidget*, GtkSnapshot*, GdkRectangle*, GdkRectangle*, GtkCellRendererState, gboolean))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
// };
// void _gotk4_gtk4_CellEditable_virtual_editing_done(void* fnptr, GtkCellEditable* arg0) {
//   ((void (*)(GtkCellEditable*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_CellEditable_virtual_remove_widget(void* fnptr, GtkCellEditable* arg0) {
//   ((void (*)(GtkCellEditable*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_CellEditable_virtual_start_editing(void* fnptr, GtkCellEditable* arg0, GdkEvent* arg1) {
//   ((void (*)(GtkCellEditable*, GdkEvent*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_CellLayout_virtual_add_attribute(void* fnptr, GtkCellLayout* arg0, GtkCellRenderer* arg1, char* arg2, int arg3) {
//   ((void (*)(GtkCellLayout*, GtkCellRenderer*, char*, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_CellLayout_virtual_clear(void* fnptr, GtkCellLayout* arg0) {
//   ((void (*)(GtkCellLayout*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_CellLayout_virtual_clear_attributes(void* fnptr, GtkCellLayout* arg0, GtkCellRenderer* arg1) {
//   ((void (*)(GtkCellLayout*, GtkCellRenderer*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_CellLayout_virtual_pack_end(void* fnptr, GtkCellLayout* arg0, GtkCellRenderer* arg1, gboolean arg2) {
//   ((void (*)(GtkCellLayout*, GtkCellRenderer*, gboolean))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_CellLayout_virtual_pack_start(void* fnptr, GtkCellLayout* arg0, GtkCellRenderer* arg1, gboolean arg2) {
//   ((void (*)(GtkCellLayout*, GtkCellRenderer*, gboolean))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_CellLayout_virtual_reorder(void* fnptr, GtkCellLayout* arg0, GtkCellRenderer* arg1, int arg2) {
//   ((void (*)(GtkCellLayout*, GtkCellRenderer*, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_CellLayout_virtual_set_cell_data_func(void* fnptr, GtkCellLayout* arg0, GtkCellRenderer* arg1, GtkCellLayoutDataFunc arg2, gpointer arg3, GDestroyNotify arg4) {
//   ((void (*)(GtkCellLayout*, GtkCellRenderer*, GtkCellLayoutDataFunc, gpointer, GDestroyNotify))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_CellRendererText_virtual_edited(void* fnptr, GtkCellRendererText* arg0, char* arg1, char* arg2) {
//   ((void (*)(GtkCellRendererText*, char*, char*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_CellRenderer_virtual_editing_canceled(void* fnptr, GtkCellRenderer* arg0) {
//   ((void (*)(GtkCellRenderer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_CellRenderer_virtual_editing_started(void* fnptr, GtkCellRenderer* arg0, GtkCellEditable* arg1, char* arg2) {
//   ((void (*)(GtkCellRenderer*, GtkCellEditable*, char*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_CellRenderer_virtual_get_aligned_area(void* fnptr, GtkCellRenderer* arg0, GtkWidget* arg1, GtkCellRendererState arg2, GdkRectangle* arg3, GdkRectangle* arg4) {
//   ((void (*)(GtkCellRenderer*, GtkWidget*, GtkCellRendererState, GdkRectangle*, GdkRectangle*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_CellRenderer_virtual_get_preferred_height(void* fnptr, GtkCellRenderer* arg0, GtkWidget* arg1, int* arg2, int* arg3) {
//   ((void (*)(GtkCellRenderer*, GtkWidget*, int*, int*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_CellRenderer_virtual_get_preferred_height_for_width(void* fnptr, GtkCellRenderer* arg0, GtkWidget* arg1, int arg2, int* arg3, int* arg4) {
//   ((void (*)(GtkCellRenderer*, GtkWidget*, int, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_CellRenderer_virtual_get_preferred_width(void* fnptr, GtkCellRenderer* arg0, GtkWidget* arg1, int* arg2, int* arg3) {
//   ((void (*)(GtkCellRenderer*, GtkWidget*, int*, int*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_CellRenderer_virtual_get_preferred_width_for_height(void* fnptr, GtkCellRenderer* arg0, GtkWidget* arg1, int arg2, int* arg3, int* arg4) {
//   ((void (*)(GtkCellRenderer*, GtkWidget*, int, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_CellRenderer_virtual_snapshot(void* fnptr, GtkCellRenderer* arg0, GtkSnapshot* arg1, GtkWidget* arg2, GdkRectangle* arg3, GdkRectangle* arg4, GtkCellRendererState arg5) {
//   ((void (*)(GtkCellRenderer*, GtkSnapshot*, GtkWidget*, GdkRectangle*, GdkRectangle*, GtkCellRendererState))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5);
// };
// void _gotk4_gtk4_CheckButton_virtual_activate(void* fnptr, GtkCheckButton* arg0) {
//   ((void (*)(GtkCheckButton*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_CheckButton_virtual_toggled(void* fnptr, GtkCheckButton* arg0) {
//   ((void (*)(GtkCheckButton*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_ColorChooser_virtual_add_palette(void* fnptr, GtkColorChooser* arg0, GtkOrientation arg1, int arg2, int arg3, GdkRGBA* arg4) {
//   ((void (*)(GtkColorChooser*, GtkOrientation, int, int, GdkRGBA*))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_ColorChooser_virtual_color_activated(void* fnptr, GtkColorChooser* arg0, GdkRGBA* arg1) {
//   ((void (*)(GtkColorChooser*, GdkRGBA*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_ColorChooser_virtual_get_rgba(void* fnptr, GtkColorChooser* arg0, GdkRGBA* arg1) {
//   ((void (*)(GtkColorChooser*, GdkRGBA*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_ColorChooser_virtual_set_rgba(void* fnptr, GtkColorChooser* arg0, GdkRGBA* arg1) {
//   ((void (*)(GtkColorChooser*, GdkRGBA*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_ComboBox_virtual_changed(void* fnptr, GtkComboBox* arg0) {
//   ((void (*)(GtkComboBox*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Dialog_virtual_close(void* fnptr, GtkDialog* arg0) {
//   ((void (*)(GtkDialog*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Dialog_virtual_response(void* fnptr, GtkDialog* arg0, int arg1) {
//   ((void (*)(GtkDialog*, int))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_DrawingArea_virtual_resize(void* fnptr, GtkDrawingArea* arg0, int arg1, int arg2) {
//   ((void (*)(GtkDrawingArea*, int, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_EditableTextWidget_virtual_changed(void* fnptr, GtkEditable* arg0) {
//   ((void (*)(GtkEditable*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_EditableTextWidget_virtual_delete_text(void* fnptr, GtkEditable* arg0, int arg1, int arg2) {
//   ((void (*)(GtkEditable*, int, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_EditableTextWidget_virtual_do_delete_text(void* fnptr, GtkEditable* arg0, int arg1, int arg2) {
//   ((void (*)(GtkEditable*, int, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_EditableTextWidget_virtual_set_selection_bounds(void* fnptr, GtkEditable* arg0, int arg1, int arg2) {
//   ((void (*)(GtkEditable*, int, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_EntryBuffer_virtual_deleted_text(void* fnptr, GtkEntryBuffer* arg0, guint arg1, guint arg2) {
//   ((void (*)(GtkEntryBuffer*, guint, guint))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_EntryBuffer_virtual_inserted_text(void* fnptr, GtkEntryBuffer* arg0, guint arg1, char* arg2, guint arg3) {
//   ((void (*)(GtkEntryBuffer*, guint, char*, guint))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Entry_virtual_activate(void* fnptr, GtkEntry* arg0) {
//   ((void (*)(GtkEntry*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_FlowBoxChild_virtual_activate(void* fnptr, GtkFlowBoxChild* arg0) {
//   ((void (*)(GtkFlowBoxChild*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_FontChooser_virtual_font_activated(void* fnptr, GtkFontChooser* arg0, char* arg1) {
//   ((void (*)(GtkFontChooser*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_FontChooser_virtual_set_filter_func(void* fnptr, GtkFontChooser* arg0, GtkFontFilterFunc arg1, gpointer arg2, GDestroyNotify arg3) {
//   ((void (*)(GtkFontChooser*, GtkFontFilterFunc, gpointer, GDestroyNotify))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_FontChooser_virtual_set_font_map(void* fnptr, GtkFontChooser* arg0, PangoFontMap* arg1) {
//   ((void (*)(GtkFontChooser*, PangoFontMap*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Frame_virtual_compute_child_allocation(void* fnptr, GtkFrame* arg0, GtkAllocation* arg1) {
//   ((void (*)(GtkFrame*, GtkAllocation*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_GLArea_virtual_resize(void* fnptr, GtkGLArea* arg0, int arg1, int arg2) {
//   ((void (*)(GtkGLArea*, int, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_IMContext_virtual_commit(void* fnptr, GtkIMContext* arg0, char* arg1) {
//   ((void (*)(GtkIMContext*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_IMContext_virtual_focus_in(void* fnptr, GtkIMContext* arg0) {
//   ((void (*)(GtkIMContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_IMContext_virtual_focus_out(void* fnptr, GtkIMContext* arg0) {
//   ((void (*)(GtkIMContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_IMContext_virtual_get_preedit_string(void* fnptr, GtkIMContext* arg0, char** arg1, PangoAttrList** arg2, int* arg3) {
//   ((void (*)(GtkIMContext*, char**, PangoAttrList**, int*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_IMContext_virtual_preedit_changed(void* fnptr, GtkIMContext* arg0) {
//   ((void (*)(GtkIMContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_IMContext_virtual_preedit_end(void* fnptr, GtkIMContext* arg0) {
//   ((void (*)(GtkIMContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_IMContext_virtual_preedit_start(void* fnptr, GtkIMContext* arg0) {
//   ((void (*)(GtkIMContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_IMContext_virtual_reset(void* fnptr, GtkIMContext* arg0) {
//   ((void (*)(GtkIMContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_IMContext_virtual_set_client_widget(void* fnptr, GtkIMContext* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkIMContext*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_IMContext_virtual_set_cursor_location(void* fnptr, GtkIMContext* arg0, GdkRectangle* arg1) {
//   ((void (*)(GtkIMContext*, GdkRectangle*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_IMContext_virtual_set_surrounding(void* fnptr, GtkIMContext* arg0, char* arg1, int arg2, int arg3) {
//   ((void (*)(GtkIMContext*, char*, int, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_IMContext_virtual_set_surrounding_with_selection(void* fnptr, GtkIMContext* arg0, char* arg1, int arg2, int arg3, int arg4) {
//   ((void (*)(GtkIMContext*, char*, int, int, int))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_IMContext_virtual_set_use_preedit(void* fnptr, GtkIMContext* arg0, gboolean arg1) {
//   ((void (*)(GtkIMContext*, gboolean))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_LayoutManager_virtual_allocate(void* fnptr, GtkLayoutManager* arg0, GtkWidget* arg1, int arg2, int arg3, int arg4) {
//   ((void (*)(GtkLayoutManager*, GtkWidget*, int, int, int))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_LayoutManager_virtual_measure(void* fnptr, GtkLayoutManager* arg0, GtkWidget* arg1, GtkOrientation arg2, int arg3, int* arg4, int* arg5, int* arg6, int* arg7) {
//   ((void (*)(GtkLayoutManager*, GtkWidget*, GtkOrientation, int, int*, int*, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
// };
// void _gotk4_gtk4_LayoutManager_virtual_root(void* fnptr, GtkLayoutManager* arg0) {
//   ((void (*)(GtkLayoutManager*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_LayoutManager_virtual_unroot(void* fnptr, GtkLayoutManager* arg0) {
//   ((void (*)(GtkLayoutManager*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_ListBoxRow_virtual_activate(void* fnptr, GtkListBoxRow* arg0) {
//   ((void (*)(GtkListBoxRow*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_MediaFile_virtual_close(void* fnptr, GtkMediaFile* arg0) {
//   ((void (*)(GtkMediaFile*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_MediaFile_virtual_open(void* fnptr, GtkMediaFile* arg0) {
//   ((void (*)(GtkMediaFile*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_MediaStream_virtual_pause(void* fnptr, GtkMediaStream* arg0) {
//   ((void (*)(GtkMediaStream*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_MediaStream_virtual_realize(void* fnptr, GtkMediaStream* arg0, GdkSurface* arg1) {
//   ((void (*)(GtkMediaStream*, GdkSurface*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_MediaStream_virtual_seek(void* fnptr, GtkMediaStream* arg0, gint64 arg1) {
//   ((void (*)(GtkMediaStream*, gint64))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_MediaStream_virtual_unrealize(void* fnptr, GtkMediaStream* arg0, GdkSurface* arg1) {
//   ((void (*)(GtkMediaStream*, GdkSurface*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_MediaStream_virtual_update_audio(void* fnptr, GtkMediaStream* arg0, gboolean arg1, double arg2) {
//   ((void (*)(GtkMediaStream*, gboolean, double))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_NativeDialog_virtual_hide(void* fnptr, GtkNativeDialog* arg0) {
//   ((void (*)(GtkNativeDialog*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_NativeDialog_virtual_response(void* fnptr, GtkNativeDialog* arg0, int arg1) {
//   ((void (*)(GtkNativeDialog*, int))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_NativeDialog_virtual_show(void* fnptr, GtkNativeDialog* arg0) {
//   ((void (*)(GtkNativeDialog*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Popover_virtual_activate_default(void* fnptr, GtkPopover* arg0) {
//   ((void (*)(GtkPopover*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Popover_virtual_closed(void* fnptr, GtkPopover* arg0) {
//   ((void (*)(GtkPopover*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_PrintOperationPreview_virtual_end_preview(void* fnptr, GtkPrintOperationPreview* arg0) {
//   ((void (*)(GtkPrintOperationPreview*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_PrintOperationPreview_virtual_got_page_size(void* fnptr, GtkPrintOperationPreview* arg0, GtkPrintContext* arg1, GtkPageSetup* arg2) {
//   ((void (*)(GtkPrintOperationPreview*, GtkPrintContext*, GtkPageSetup*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_PrintOperationPreview_virtual_ready(void* fnptr, GtkPrintOperationPreview* arg0, GtkPrintContext* arg1) {
//   ((void (*)(GtkPrintOperationPreview*, GtkPrintContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_PrintOperationPreview_virtual_render_page(void* fnptr, GtkPrintOperationPreview* arg0, int arg1) {
//   ((void (*)(GtkPrintOperationPreview*, int))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_PrintOperation_virtual_begin_print(void* fnptr, GtkPrintOperation* arg0, GtkPrintContext* arg1) {
//   ((void (*)(GtkPrintOperation*, GtkPrintContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_PrintOperation_virtual_custom_widget_apply(void* fnptr, GtkPrintOperation* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkPrintOperation*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_PrintOperation_virtual_done(void* fnptr, GtkPrintOperation* arg0, GtkPrintOperationResult arg1) {
//   ((void (*)(GtkPrintOperation*, GtkPrintOperationResult))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_PrintOperation_virtual_draw_page(void* fnptr, GtkPrintOperation* arg0, GtkPrintContext* arg1, int arg2) {
//   ((void (*)(GtkPrintOperation*, GtkPrintContext*, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_PrintOperation_virtual_end_print(void* fnptr, GtkPrintOperation* arg0, GtkPrintContext* arg1) {
//   ((void (*)(GtkPrintOperation*, GtkPrintContext*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_PrintOperation_virtual_request_page_setup(void* fnptr, GtkPrintOperation* arg0, GtkPrintContext* arg1, int arg2, GtkPageSetup* arg3) {
//   ((void (*)(GtkPrintOperation*, GtkPrintContext*, int, GtkPageSetup*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_PrintOperation_virtual_status_changed(void* fnptr, GtkPrintOperation* arg0) {
//   ((void (*)(GtkPrintOperation*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_PrintOperation_virtual_update_custom_widget(void* fnptr, GtkPrintOperation* arg0, GtkWidget* arg1, GtkPageSetup* arg2, GtkPrintSettings* arg3) {
//   ((void (*)(GtkPrintOperation*, GtkWidget*, GtkPageSetup*, GtkPrintSettings*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Range_virtual_adjust_bounds(void* fnptr, GtkRange* arg0, double arg1) {
//   ((void (*)(GtkRange*, double))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Range_virtual_get_range_border(void* fnptr, GtkRange* arg0, GtkBorder* arg1) {
//   ((void (*)(GtkRange*, GtkBorder*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Range_virtual_move_slider(void* fnptr, GtkRange* arg0, GtkScrollType arg1) {
//   ((void (*)(GtkRange*, GtkScrollType))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Range_virtual_value_changed(void* fnptr, GtkRange* arg0) {
//   ((void (*)(GtkRange*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_RecentManager_virtual_changed(void* fnptr, GtkRecentManager* arg0) {
//   ((void (*)(GtkRecentManager*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_ScaleButton_virtual_value_changed(void* fnptr, GtkScaleButton* arg0, double arg1) {
//   ((void (*)(GtkScaleButton*, double))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Scale_virtual_get_layout_offsets(void* fnptr, GtkScale* arg0, int* arg1, int* arg2) {
//   ((void (*)(GtkScale*, int*, int*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_ShortcutManager_virtual_add_controller(void* fnptr, GtkShortcutManager* arg0, GtkShortcutController* arg1) {
//   ((void (*)(GtkShortcutManager*, GtkShortcutController*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_ShortcutManager_virtual_remove_controller(void* fnptr, GtkShortcutManager* arg0, GtkShortcutController* arg1) {
//   ((void (*)(GtkShortcutManager*, GtkShortcutController*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_StyleContext_virtual_changed(void* fnptr, GtkStyleContext* arg0) {
//   ((void (*)(GtkStyleContext*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_apply_tag(void* fnptr, GtkTextBuffer* arg0, GtkTextTag* arg1, GtkTextIter* arg2, GtkTextIter* arg3) {
//   ((void (*)(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TextBuffer_virtual_begin_user_action(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_changed(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_delete_range(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GtkTextIter* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_end_user_action(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_insert_child_anchor(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GtkTextChildAnchor* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GtkTextChildAnchor*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_insert_paintable(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GdkPaintable* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GdkPaintable*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_insert_text(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, char* arg2, int arg3) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, char*, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TextBuffer_virtual_mark_deleted(void* fnptr, GtkTextBuffer* arg0, GtkTextMark* arg1) {
//   ((void (*)(GtkTextBuffer*, GtkTextMark*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TextBuffer_virtual_mark_set(void* fnptr, GtkTextBuffer* arg0, GtkTextIter* arg1, GtkTextMark* arg2) {
//   ((void (*)(GtkTextBuffer*, GtkTextIter*, GtkTextMark*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextBuffer_virtual_modified_changed(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_paste_done(void* fnptr, GtkTextBuffer* arg0, GdkClipboard* arg1) {
//   ((void (*)(GtkTextBuffer*, GdkClipboard*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TextBuffer_virtual_redo(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextBuffer_virtual_remove_tag(void* fnptr, GtkTextBuffer* arg0, GtkTextTag* arg1, GtkTextIter* arg2, GtkTextIter* arg3) {
//   ((void (*)(GtkTextBuffer*, GtkTextTag*, GtkTextIter*, GtkTextIter*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TextBuffer_virtual_undo(void* fnptr, GtkTextBuffer* arg0) {
//   ((void (*)(GtkTextBuffer*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextView_virtual_backspace(void* fnptr, GtkTextView* arg0) {
//   ((void (*)(GtkTextView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextView_virtual_copy_clipboard(void* fnptr, GtkTextView* arg0) {
//   ((void (*)(GtkTextView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextView_virtual_cut_clipboard(void* fnptr, GtkTextView* arg0) {
//   ((void (*)(GtkTextView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextView_virtual_delete_from_cursor(void* fnptr, GtkTextView* arg0, GtkDeleteType arg1, int arg2) {
//   ((void (*)(GtkTextView*, GtkDeleteType, int))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextView_virtual_insert_at_cursor(void* fnptr, GtkTextView* arg0, char* arg1) {
//   ((void (*)(GtkTextView*, char*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TextView_virtual_insert_emoji(void* fnptr, GtkTextView* arg0) {
//   ((void (*)(GtkTextView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextView_virtual_move_cursor(void* fnptr, GtkTextView* arg0, GtkMovementStep arg1, int arg2, gboolean arg3) {
//   ((void (*)(GtkTextView*, GtkMovementStep, int, gboolean))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TextView_virtual_paste_clipboard(void* fnptr, GtkTextView* arg0) {
//   ((void (*)(GtkTextView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextView_virtual_set_anchor(void* fnptr, GtkTextView* arg0) {
//   ((void (*)(GtkTextView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TextView_virtual_snapshot_layer(void* fnptr, GtkTextView* arg0, GtkTextViewLayer arg1, GtkSnapshot* arg2) {
//   ((void (*)(GtkTextView*, GtkTextViewLayer, GtkSnapshot*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TextView_virtual_toggle_overwrite(void* fnptr, GtkTextView* arg0) {
//   ((void (*)(GtkTextView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_ToggleButton_virtual_toggled(void* fnptr, GtkToggleButton* arg0) {
//   ((void (*)(GtkToggleButton*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TreeModelFilter_virtual_modify(void* fnptr, GtkTreeModelFilter* arg0, GtkTreeModel* arg1, GtkTreeIter* arg2, GValue* arg3, int arg4) {
//   ((void (*)(GtkTreeModelFilter*, GtkTreeModel*, GtkTreeIter*, GValue*, int))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_TreeModel_virtual_get_value(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1, int arg2, GValue* arg3) {
//   ((void (*)(GtkTreeModel*, GtkTreeIter*, int, GValue*))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TreeModel_virtual_ref_node(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1) {
//   ((void (*)(GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TreeModel_virtual_row_changed(void* fnptr, GtkTreeModel* arg0, GtkTreePath* arg1, GtkTreeIter* arg2) {
//   ((void (*)(GtkTreeModel*, GtkTreePath*, GtkTreeIter*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TreeModel_virtual_row_deleted(void* fnptr, GtkTreeModel* arg0, GtkTreePath* arg1) {
//   ((void (*)(GtkTreeModel*, GtkTreePath*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TreeModel_virtual_row_has_child_toggled(void* fnptr, GtkTreeModel* arg0, GtkTreePath* arg1, GtkTreeIter* arg2) {
//   ((void (*)(GtkTreeModel*, GtkTreePath*, GtkTreeIter*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TreeModel_virtual_row_inserted(void* fnptr, GtkTreeModel* arg0, GtkTreePath* arg1, GtkTreeIter* arg2) {
//   ((void (*)(GtkTreeModel*, GtkTreePath*, GtkTreeIter*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TreeModel_virtual_unref_node(void* fnptr, GtkTreeModel* arg0, GtkTreeIter* arg1) {
//   ((void (*)(GtkTreeModel*, GtkTreeIter*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_TreeSortable_virtual_set_default_sort_func(void* fnptr, GtkTreeSortable* arg0, GtkTreeIterCompareFunc arg1, gpointer arg2, GDestroyNotify arg3) {
//   ((void (*)(GtkTreeSortable*, GtkTreeIterCompareFunc, gpointer, GDestroyNotify))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_TreeSortable_virtual_set_sort_column_id(void* fnptr, GtkTreeSortable* arg0, int arg1, GtkSortType arg2) {
//   ((void (*)(GtkTreeSortable*, int, GtkSortType))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TreeSortable_virtual_set_sort_func(void* fnptr, GtkTreeSortable* arg0, int arg1, GtkTreeIterCompareFunc arg2, gpointer arg3, GDestroyNotify arg4) {
//   ((void (*)(GtkTreeSortable*, int, GtkTreeIterCompareFunc, gpointer, GDestroyNotify))(fnptr))(arg0, arg1, arg2, arg3, arg4);
// };
// void _gotk4_gtk4_TreeSortable_virtual_sort_column_changed(void* fnptr, GtkTreeSortable* arg0) {
//   ((void (*)(GtkTreeSortable*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TreeView_virtual_columns_changed(void* fnptr, GtkTreeView* arg0) {
//   ((void (*)(GtkTreeView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TreeView_virtual_cursor_changed(void* fnptr, GtkTreeView* arg0) {
//   ((void (*)(GtkTreeView*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_TreeView_virtual_row_activated(void* fnptr, GtkTreeView* arg0, GtkTreePath* arg1, GtkTreeViewColumn* arg2) {
//   ((void (*)(GtkTreeView*, GtkTreePath*, GtkTreeViewColumn*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TreeView_virtual_row_collapsed(void* fnptr, GtkTreeView* arg0, GtkTreeIter* arg1, GtkTreePath* arg2) {
//   ((void (*)(GtkTreeView*, GtkTreeIter*, GtkTreePath*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_TreeView_virtual_row_expanded(void* fnptr, GtkTreeView* arg0, GtkTreeIter* arg1, GtkTreePath* arg2) {
//   ((void (*)(GtkTreeView*, GtkTreeIter*, GtkTreePath*))(fnptr))(arg0, arg1, arg2);
// };
// void _gotk4_gtk4_Widget_virtual_direction_changed(void* fnptr, GtkWidget* arg0, GtkTextDirection arg1) {
//   ((void (*)(GtkWidget*, GtkTextDirection))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_hide(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_map(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_measure(void* fnptr, GtkWidget* arg0, GtkOrientation arg1, int arg2, int* arg3, int* arg4, int* arg5, int* arg6) {
//   ((void (*)(GtkWidget*, GtkOrientation, int, int*, int*, int*, int*))(fnptr))(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
// };
// void _gotk4_gtk4_Widget_virtual_move_focus(void* fnptr, GtkWidget* arg0, GtkDirectionType arg1) {
//   ((void (*)(GtkWidget*, GtkDirectionType))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_realize(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_root(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_set_focus_child(void* fnptr, GtkWidget* arg0, GtkWidget* arg1) {
//   ((void (*)(GtkWidget*, GtkWidget*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_show(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_size_allocate(void* fnptr, GtkWidget* arg0, int arg1, int arg2, int arg3) {
//   ((void (*)(GtkWidget*, int, int, int))(fnptr))(arg0, arg1, arg2, arg3);
// };
// void _gotk4_gtk4_Widget_virtual_snapshot(void* fnptr, GtkWidget* arg0, GtkSnapshot* arg1) {
//   ((void (*)(GtkWidget*, GtkSnapshot*))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_state_flags_changed(void* fnptr, GtkWidget* arg0, GtkStateFlags arg1) {
//   ((void (*)(GtkWidget*, GtkStateFlags))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_system_setting_changed(void* fnptr, GtkWidget* arg0, GtkSystemSetting arg1) {
//   ((void (*)(GtkWidget*, GtkSystemSetting))(fnptr))(arg0, arg1);
// };
// void _gotk4_gtk4_Widget_virtual_unmap(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_unrealize(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Widget_virtual_unroot(void* fnptr, GtkWidget* arg0) {
//   ((void (*)(GtkWidget*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Window_virtual_activate_default(void* fnptr, GtkWindow* arg0) {
//   ((void (*)(GtkWindow*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Window_virtual_activate_focus(void* fnptr, GtkWindow* arg0) {
//   ((void (*)(GtkWindow*))(fnptr))(arg0);
// };
// void _gotk4_gtk4_Window_virtual_keys_changed(void* fnptr, GtkWindow* arg0) {
//   ((void (*)(GtkWindow*))(fnptr))(arg0);
// };
import "C"

// GType values.
var (
	GTypeAccessibleAutocomplete     = coreglib.Type(C.gtk_accessible_autocomplete_get_type())
	GTypeAccessibleInvalidState     = coreglib.Type(C.gtk_accessible_invalid_state_get_type())
	GTypeAccessibleProperty         = coreglib.Type(C.gtk_accessible_property_get_type())
	GTypeAccessibleRelation         = coreglib.Type(C.gtk_accessible_relation_get_type())
	GTypeAccessibleRole             = coreglib.Type(C.gtk_accessible_role_get_type())
	GTypeAccessibleSort             = coreglib.Type(C.gtk_accessible_sort_get_type())
	GTypeAccessibleState            = coreglib.Type(C.gtk_accessible_state_get_type())
	GTypeAccessibleTristate         = coreglib.Type(C.gtk_accessible_tristate_get_type())
	GTypeAlign                      = coreglib.Type(C.gtk_align_get_type())
	GTypeArrowType                  = coreglib.Type(C.gtk_arrow_type_get_type())
	GTypeAssistantPageType          = coreglib.Type(C.gtk_assistant_page_type_get_type())
	GTypeBaselinePosition           = coreglib.Type(C.gtk_baseline_position_get_type())
	GTypeBorderStyle                = coreglib.Type(C.gtk_border_style_get_type())
	GTypeBuilderError               = coreglib.Type(C.gtk_builder_error_get_type())
	GTypeButtonsType                = coreglib.Type(C.gtk_buttons_type_get_type())
	GTypeCellRendererAccelMode      = coreglib.Type(C.gtk_cell_renderer_accel_mode_get_type())
	GTypeCellRendererMode           = coreglib.Type(C.gtk_cell_renderer_mode_get_type())
	GTypeConstraintAttribute        = coreglib.Type(C.gtk_constraint_attribute_get_type())
	GTypeConstraintRelation         = coreglib.Type(C.gtk_constraint_relation_get_type())
	GTypeConstraintStrength         = coreglib.Type(C.gtk_constraint_strength_get_type())
	GTypeConstraintVflParserError   = coreglib.Type(C.gtk_constraint_vfl_parser_error_get_type())
	GTypeCornerType                 = coreglib.Type(C.gtk_corner_type_get_type())
	GTypeDeleteType                 = coreglib.Type(C.gtk_delete_type_get_type())
	GTypeDirectionType              = coreglib.Type(C.gtk_direction_type_get_type())
	GTypeEditableProperties         = coreglib.Type(C.gtk_editable_properties_get_type())
	GTypeEntryIconPosition          = coreglib.Type(C.gtk_entry_icon_position_get_type())
	GTypeEventSequenceState         = coreglib.Type(C.gtk_event_sequence_state_get_type())
	GTypeFileChooserAction          = coreglib.Type(C.gtk_file_chooser_action_get_type())
	GTypeFileChooserError           = coreglib.Type(C.gtk_file_chooser_error_get_type())
	GTypeFilterChange               = coreglib.Type(C.gtk_filter_change_get_type())
	GTypeFilterMatch                = coreglib.Type(C.gtk_filter_match_get_type())
	GTypeIconSize                   = coreglib.Type(C.gtk_icon_size_get_type())
	GTypeIconThemeError             = coreglib.Type(C.gtk_icon_theme_error_get_type())
	GTypeIconViewDropPosition       = coreglib.Type(C.gtk_icon_view_drop_position_get_type())
	GTypeImageType                  = coreglib.Type(C.gtk_image_type_get_type())
	GTypeInputPurpose               = coreglib.Type(C.gtk_input_purpose_get_type())
	GTypeJustification              = coreglib.Type(C.gtk_justification_get_type())
	GTypeLevelBarMode               = coreglib.Type(C.gtk_level_bar_mode_get_type())
	GTypeLicense                    = coreglib.Type(C.gtk_license_get_type())
	GTypeMessageType                = coreglib.Type(C.gtk_message_type_get_type())
	GTypeMovementStep               = coreglib.Type(C.gtk_movement_step_get_type())
	GTypeNotebookTab                = coreglib.Type(C.gtk_notebook_tab_get_type())
	GTypeNumberUpLayout             = coreglib.Type(C.gtk_number_up_layout_get_type())
	GTypeOrdering                   = coreglib.Type(C.gtk_ordering_get_type())
	GTypeOrientation                = coreglib.Type(C.gtk_orientation_get_type())
	GTypeOverflow                   = coreglib.Type(C.gtk_overflow_get_type())
	GTypePackType                   = coreglib.Type(C.gtk_pack_type_get_type())
	GTypePadActionType              = coreglib.Type(C.gtk_pad_action_type_get_type())
	GTypePageOrientation            = coreglib.Type(C.gtk_page_orientation_get_type())
	GTypePageSet                    = coreglib.Type(C.gtk_page_set_get_type())
	GTypePanDirection               = coreglib.Type(C.gtk_pan_direction_get_type())
	GTypePolicyType                 = coreglib.Type(C.gtk_policy_type_get_type())
	GTypePositionType               = coreglib.Type(C.gtk_position_type_get_type())
	GTypePrintDuplex                = coreglib.Type(C.gtk_print_duplex_get_type())
	GTypePrintError                 = coreglib.Type(C.gtk_print_error_get_type())
	GTypePrintOperationAction       = coreglib.Type(C.gtk_print_operation_action_get_type())
	GTypePrintOperationResult       = coreglib.Type(C.gtk_print_operation_result_get_type())
	GTypePrintPages                 = coreglib.Type(C.gtk_print_pages_get_type())
	GTypePrintQuality               = coreglib.Type(C.gtk_print_quality_get_type())
	GTypePrintStatus                = coreglib.Type(C.gtk_print_status_get_type())
	GTypePropagationLimit           = coreglib.Type(C.gtk_propagation_limit_get_type())
	GTypePropagationPhase           = coreglib.Type(C.gtk_propagation_phase_get_type())
	GTypeRecentManagerError         = coreglib.Type(C.gtk_recent_manager_error_get_type())
	GTypeResponseType               = coreglib.Type(C.gtk_response_type_get_type())
	GTypeRevealerTransitionType     = coreglib.Type(C.gtk_revealer_transition_type_get_type())
	GTypeScrollStep                 = coreglib.Type(C.gtk_scroll_step_get_type())
	GTypeScrollType                 = coreglib.Type(C.gtk_scroll_type_get_type())
	GTypeScrollablePolicy           = coreglib.Type(C.gtk_scrollable_policy_get_type())
	GTypeSelectionMode              = coreglib.Type(C.gtk_selection_mode_get_type())
	GTypeSensitivityType            = coreglib.Type(C.gtk_sensitivity_type_get_type())
	GTypeShortcutScope              = coreglib.Type(C.gtk_shortcut_scope_get_type())
	GTypeShortcutType               = coreglib.Type(C.gtk_shortcut_type_get_type())
	GTypeSizeGroupMode              = coreglib.Type(C.gtk_size_group_mode_get_type())
	GTypeSizeRequestMode            = coreglib.Type(C.gtk_size_request_mode_get_type())
	GTypeSortType                   = coreglib.Type(C.gtk_sort_type_get_type())
	GTypeSorterChange               = coreglib.Type(C.gtk_sorter_change_get_type())
	GTypeSorterOrder                = coreglib.Type(C.gtk_sorter_order_get_type())
	GTypeSpinButtonUpdatePolicy     = coreglib.Type(C.gtk_spin_button_update_policy_get_type())
	GTypeSpinType                   = coreglib.Type(C.gtk_spin_type_get_type())
	GTypeStackTransitionType        = coreglib.Type(C.gtk_stack_transition_type_get_type())
	GTypeStringFilterMatchMode      = coreglib.Type(C.gtk_string_filter_match_mode_get_type())
	GTypeSystemSetting              = coreglib.Type(C.gtk_system_setting_get_type())
	GTypeTextDirection              = coreglib.Type(C.gtk_text_direction_get_type())
	GTypeTextExtendSelection        = coreglib.Type(C.gtk_text_extend_selection_get_type())
	GTypeTextViewLayer              = coreglib.Type(C.gtk_text_view_layer_get_type())
	GTypeTextWindowType             = coreglib.Type(C.gtk_text_window_type_get_type())
	GTypeTreeViewColumnSizing       = coreglib.Type(C.gtk_tree_view_column_sizing_get_type())
	GTypeTreeViewDropPosition       = coreglib.Type(C.gtk_tree_view_drop_position_get_type())
	GTypeTreeViewGridLines          = coreglib.Type(C.gtk_tree_view_grid_lines_get_type())
	GTypeUnit                       = coreglib.Type(C.gtk_unit_get_type())
	GTypeWrapMode                   = coreglib.Type(C.gtk_wrap_mode_get_type())
	GTypeApplicationInhibitFlags    = coreglib.Type(C.gtk_application_inhibit_flags_get_type())
	GTypeBuilderClosureFlags        = coreglib.Type(C.gtk_builder_closure_flags_get_type())
	GTypeCellRendererState          = coreglib.Type(C.gtk_cell_renderer_state_get_type())
	GTypeDebugFlags                 = coreglib.Type(C.gtk_debug_flags_get_type())
	GTypeDialogFlags                = coreglib.Type(C.gtk_dialog_flags_get_type())
	GTypeEventControllerScrollFlags = coreglib.Type(C.gtk_event_controller_scroll_flags_get_type())
	GTypeFontChooserLevel           = coreglib.Type(C.gtk_font_chooser_level_get_type())
	GTypeIconLookupFlags            = coreglib.Type(C.gtk_icon_lookup_flags_get_type())
	GTypeInputHints                 = coreglib.Type(C.gtk_input_hints_get_type())
	GTypePickFlags                  = coreglib.Type(C.gtk_pick_flags_get_type())
	GTypePopoverMenuFlags           = coreglib.Type(C.gtk_popover_menu_flags_get_type())
	GTypeShortcutActionFlags        = coreglib.Type(C.gtk_shortcut_action_flags_get_type())
	GTypeStateFlags                 = coreglib.Type(C.gtk_state_flags_get_type())
	GTypeStyleContextPrintFlags     = coreglib.Type(C.gtk_style_context_print_flags_get_type())
	GTypeTextSearchFlags            = coreglib.Type(C.gtk_text_search_flags_get_type())
	GTypeTreeModelFlags             = coreglib.Type(C.gtk_tree_model_flags_get_type())
	GTypeAccessible                 = coreglib.Type(C.gtk_accessible_get_type())
	GTypeActionable                 = coreglib.Type(C.gtk_actionable_get_type())
	GTypeAppChooser                 = coreglib.Type(C.gtk_app_chooser_get_type())
	GTypeBuildable                  = coreglib.Type(C.gtk_buildable_get_type())
	GTypeBuilderScope               = coreglib.Type(C.gtk_builder_scope_get_type())
	GTypeCellEditable               = coreglib.Type(C.gtk_cell_editable_get_type())
	GTypeCellLayout                 = coreglib.Type(C.gtk_cell_layout_get_type())
	GTypeColorChooser               = coreglib.Type(C.gtk_color_chooser_get_type())
	GTypeConstraintTarget           = coreglib.Type(C.gtk_constraint_target_get_type())
	GTypeEditableTextWidget         = coreglib.Type(C.gtk_editable_get_type())
	GTypeFileChooser                = coreglib.Type(C.gtk_file_chooser_get_type())
	GTypeFontChooser                = coreglib.Type(C.gtk_font_chooser_get_type())
	GTypeNativeSurface              = coreglib.Type(C.gtk_native_get_type())
	GTypeOrientable                 = coreglib.Type(C.gtk_orientable_get_type())
	GTypePrintOperationPreview      = coreglib.Type(C.gtk_print_operation_preview_get_type())
	GTypeRoot                       = coreglib.Type(C.gtk_root_get_type())
	GTypeScrollable                 = coreglib.Type(C.gtk_scrollable_get_type())
	GTypeSelectionModel             = coreglib.Type(C.gtk_selection_model_get_type())
	GTypeShortcutManager            = coreglib.Type(C.gtk_shortcut_manager_get_type())
	GTypeStyleProvider              = coreglib.Type(C.gtk_style_provider_get_type())
	GTypeTreeDragDest               = coreglib.Type(C.gtk_tree_drag_dest_get_type())
	GTypeTreeDragSource             = coreglib.Type(C.gtk_tree_drag_source_get_type())
	GTypeTreeModel                  = coreglib.Type(C.gtk_tree_model_get_type())
	GTypeTreeSortable               = coreglib.Type(C.gtk_tree_sortable_get_type())
	GTypeATContext                  = coreglib.Type(C.gtk_at_context_get_type())
	GTypeAboutDialog                = coreglib.Type(C.gtk_about_dialog_get_type())
	GTypeActionBar                  = coreglib.Type(C.gtk_action_bar_get_type())
	GTypeActivateAction             = coreglib.Type(C.gtk_activate_action_get_type())
	GTypeAdjustment                 = coreglib.Type(C.gtk_adjustment_get_type())
	GTypeAlternativeTrigger         = coreglib.Type(C.gtk_alternative_trigger_get_type())
	GTypeAnyFilter                  = coreglib.Type(C.gtk_any_filter_get_type())
	GTypeAppChooserButton           = coreglib.Type(C.gtk_app_chooser_button_get_type())
	GTypeAppChooserDialog           = coreglib.Type(C.gtk_app_chooser_dialog_get_type())
	GTypeAppChooserWidget           = coreglib.Type(C.gtk_app_chooser_widget_get_type())
	GTypeApplication                = coreglib.Type(C.gtk_application_get_type())
	GTypeApplicationWindow          = coreglib.Type(C.gtk_application_window_get_type())
	GTypeAspectFrame                = coreglib.Type(C.gtk_aspect_frame_get_type())
	GTypeAssistant                  = coreglib.Type(C.gtk_assistant_get_type())
	GTypeAssistantPage              = coreglib.Type(C.gtk_assistant_page_get_type())
	GTypeBinLayout                  = coreglib.Type(C.gtk_bin_layout_get_type())
	GTypeBookmarkList               = coreglib.Type(C.gtk_bookmark_list_get_type())
	GTypeBoolFilter                 = coreglib.Type(C.gtk_bool_filter_get_type())
	GTypeBox                        = coreglib.Type(C.gtk_box_get_type())
	GTypeBoxLayout                  = coreglib.Type(C.gtk_box_layout_get_type())
	GTypeBuilder                    = coreglib.Type(C.gtk_builder_get_type())
	GTypeBuilderCScope              = coreglib.Type(C.gtk_builder_cscope_get_type())
	GTypeBuilderListItemFactory     = coreglib.Type(C.gtk_builder_list_item_factory_get_type())
	GTypeButton                     = coreglib.Type(C.gtk_button_get_type())
	GTypeCClosureExpression         = coreglib.Type(C.gtk_cclosure_expression_get_type())
	GTypeCalendar                   = coreglib.Type(C.gtk_calendar_get_type())
	GTypeCallbackAction             = coreglib.Type(C.gtk_callback_action_get_type())
	GTypeCellArea                   = coreglib.Type(C.gtk_cell_area_get_type())
	GTypeCellAreaBox                = coreglib.Type(C.gtk_cell_area_box_get_type())
	GTypeCellAreaContext            = coreglib.Type(C.gtk_cell_area_context_get_type())
	GTypeCellRenderer               = coreglib.Type(C.gtk_cell_renderer_get_type())
	GTypeCellRendererAccel          = coreglib.Type(C.gtk_cell_renderer_accel_get_type())
	GTypeCellRendererCombo          = coreglib.Type(C.gtk_cell_renderer_combo_get_type())
	GTypeCellRendererPixbuf         = coreglib.Type(C.gtk_cell_renderer_pixbuf_get_type())
	GTypeCellRendererProgress       = coreglib.Type(C.gtk_cell_renderer_progress_get_type())
	GTypeCellRendererSpin           = coreglib.Type(C.gtk_cell_renderer_spin_get_type())
	GTypeCellRendererSpinner        = coreglib.Type(C.gtk_cell_renderer_spinner_get_type())
	GTypeCellRendererText           = coreglib.Type(C.gtk_cell_renderer_text_get_type())
	GTypeCellRendererToggle         = coreglib.Type(C.gtk_cell_renderer_toggle_get_type())
	GTypeCellView                   = coreglib.Type(C.gtk_cell_view_get_type())
	GTypeCenterBox                  = coreglib.Type(C.gtk_center_box_get_type())
	GTypeCenterLayout               = coreglib.Type(C.gtk_center_layout_get_type())
	GTypeCheckButton                = coreglib.Type(C.gtk_check_button_get_type())
	GTypeClosureExpression          = coreglib.Type(C.gtk_closure_expression_get_type())
	GTypeColorButton                = coreglib.Type(C.gtk_color_button_get_type())
	GTypeColorChooserDialog         = coreglib.Type(C.gtk_color_chooser_dialog_get_type())
	GTypeColorChooserWidget         = coreglib.Type(C.gtk_color_chooser_widget_get_type())
	GTypeColumnView                 = coreglib.Type(C.gtk_column_view_get_type())
	GTypeColumnViewColumn           = coreglib.Type(C.gtk_column_view_column_get_type())
	GTypeComboBox                   = coreglib.Type(C.gtk_combo_box_get_type())
	GTypeComboBoxText               = coreglib.Type(C.gtk_combo_box_text_get_type())
	GTypeConstantExpression         = coreglib.Type(C.gtk_constant_expression_get_type())
	GTypeConstraint                 = coreglib.Type(C.gtk_constraint_get_type())
	GTypeConstraintGuide            = coreglib.Type(C.gtk_constraint_guide_get_type())
	GTypeConstraintLayout           = coreglib.Type(C.gtk_constraint_layout_get_type())
	GTypeConstraintLayoutChild      = coreglib.Type(C.gtk_constraint_layout_child_get_type())
	GTypeCSSProvider                = coreglib.Type(C.gtk_css_provider_get_type())
	GTypeCustomFilter               = coreglib.Type(C.gtk_custom_filter_get_type())
	GTypeCustomLayout               = coreglib.Type(C.gtk_custom_layout_get_type())
	GTypeCustomSorter               = coreglib.Type(C.gtk_custom_sorter_get_type())
	GTypeDialog                     = coreglib.Type(C.gtk_dialog_get_type())
	GTypeDirectoryList              = coreglib.Type(C.gtk_directory_list_get_type())
	GTypeDragIcon                   = coreglib.Type(C.gtk_drag_icon_get_type())
	GTypeDragSource                 = coreglib.Type(C.gtk_drag_source_get_type())
	GTypeDrawingArea                = coreglib.Type(C.gtk_drawing_area_get_type())
	GTypeDropControllerMotion       = coreglib.Type(C.gtk_drop_controller_motion_get_type())
	GTypeDropDown                   = coreglib.Type(C.gtk_drop_down_get_type())
	GTypeDropTarget                 = coreglib.Type(C.gtk_drop_target_get_type())
	GTypeDropTargetAsync            = coreglib.Type(C.gtk_drop_target_async_get_type())
	GTypeEditableLabel              = coreglib.Type(C.gtk_editable_label_get_type())
	GTypeEmojiChooser               = coreglib.Type(C.gtk_emoji_chooser_get_type())
	GTypeEntry                      = coreglib.Type(C.gtk_entry_get_type())
	GTypeEntryBuffer                = coreglib.Type(C.gtk_entry_buffer_get_type())
	GTypeEntryCompletion            = coreglib.Type(C.gtk_entry_completion_get_type())
	GTypeEventController            = coreglib.Type(C.gtk_event_controller_get_type())
	GTypeEventControllerFocus       = coreglib.Type(C.gtk_event_controller_focus_get_type())
	GTypeEventControllerKey         = coreglib.Type(C.gtk_event_controller_key_get_type())
	GTypeEventControllerLegacy      = coreglib.Type(C.gtk_event_controller_legacy_get_type())
	GTypeEventControllerMotion      = coreglib.Type(C.gtk_event_controller_motion_get_type())
	GTypeEventControllerScroll      = coreglib.Type(C.gtk_event_controller_scroll_get_type())
	GTypeEveryFilter                = coreglib.Type(C.gtk_every_filter_get_type())
	GTypeExpander                   = coreglib.Type(C.gtk_expander_get_type())
	GTypeExpression                 = coreglib.Type(C.gtk_expression_get_type())
	GTypeFileChooserDialog          = coreglib.Type(C.gtk_file_chooser_dialog_get_type())
	GTypeFileChooserNative          = coreglib.Type(C.gtk_file_chooser_native_get_type())
	GTypeFileChooserWidget          = coreglib.Type(C.gtk_file_chooser_widget_get_type())
	GTypeFileFilter                 = coreglib.Type(C.gtk_file_filter_get_type())
	GTypeFilter                     = coreglib.Type(C.gtk_filter_get_type())
	GTypeFilterListModel            = coreglib.Type(C.gtk_filter_list_model_get_type())
	GTypeFixed                      = coreglib.Type(C.gtk_fixed_get_type())
	GTypeFixedLayout                = coreglib.Type(C.gtk_fixed_layout_get_type())
	GTypeFixedLayoutChild           = coreglib.Type(C.gtk_fixed_layout_child_get_type())
	GTypeFlattenListModel           = coreglib.Type(C.gtk_flatten_list_model_get_type())
	GTypeFlowBox                    = coreglib.Type(C.gtk_flow_box_get_type())
	GTypeFlowBoxChild               = coreglib.Type(C.gtk_flow_box_child_get_type())
	GTypeFontButton                 = coreglib.Type(C.gtk_font_button_get_type())
	GTypeFontChooserDialog          = coreglib.Type(C.gtk_font_chooser_dialog_get_type())
	GTypeFontChooserWidget          = coreglib.Type(C.gtk_font_chooser_widget_get_type())
	GTypeFrame                      = coreglib.Type(C.gtk_frame_get_type())
	GTypeGLArea                     = coreglib.Type(C.gtk_gl_area_get_type())
	GTypeGesture                    = coreglib.Type(C.gtk_gesture_get_type())
	GTypeGestureClick               = coreglib.Type(C.gtk_gesture_click_get_type())
	GTypeGestureDrag                = coreglib.Type(C.gtk_gesture_drag_get_type())
	GTypeGestureLongPress           = coreglib.Type(C.gtk_gesture_long_press_get_type())
	GTypeGesturePan                 = coreglib.Type(C.gtk_gesture_pan_get_type())
	GTypeGestureRotate              = coreglib.Type(C.gtk_gesture_rotate_get_type())
	GTypeGestureSingle              = coreglib.Type(C.gtk_gesture_single_get_type())
	GTypeGestureStylus              = coreglib.Type(C.gtk_gesture_stylus_get_type())
	GTypeGestureSwipe               = coreglib.Type(C.gtk_gesture_swipe_get_type())
	GTypeGestureZoom                = coreglib.Type(C.gtk_gesture_zoom_get_type())
	GTypeGrid                       = coreglib.Type(C.gtk_grid_get_type())
	GTypeGridLayout                 = coreglib.Type(C.gtk_grid_layout_get_type())
	GTypeGridLayoutChild            = coreglib.Type(C.gtk_grid_layout_child_get_type())
	GTypeGridView                   = coreglib.Type(C.gtk_grid_view_get_type())
	GTypeHeaderBar                  = coreglib.Type(C.gtk_header_bar_get_type())
	GTypeIMContext                  = coreglib.Type(C.gtk_im_context_get_type())
	GTypeIMContextSimple            = coreglib.Type(C.gtk_im_context_simple_get_type())
	GTypeIMMulticontext             = coreglib.Type(C.gtk_im_multicontext_get_type())
	GTypeIconPaintable              = coreglib.Type(C.gtk_icon_paintable_get_type())
	GTypeIconTheme                  = coreglib.Type(C.gtk_icon_theme_get_type())
	GTypeIconView                   = coreglib.Type(C.gtk_icon_view_get_type())
	GTypeImage                      = coreglib.Type(C.gtk_image_get_type())
	GTypeInfoBar                    = coreglib.Type(C.gtk_info_bar_get_type())
	GTypeKeyvalTrigger              = coreglib.Type(C.gtk_keyval_trigger_get_type())
	GTypeLabel                      = coreglib.Type(C.gtk_label_get_type())
	GTypeLayoutChild                = coreglib.Type(C.gtk_layout_child_get_type())
	GTypeLayoutManager              = coreglib.Type(C.gtk_layout_manager_get_type())
	GTypeLevelBar                   = coreglib.Type(C.gtk_level_bar_get_type())
	GTypeLinkButton                 = coreglib.Type(C.gtk_link_button_get_type())
	GTypeListBase                   = coreglib.Type(C.gtk_list_base_get_type())
	GTypeListBox                    = coreglib.Type(C.gtk_list_box_get_type())
	GTypeListBoxRow                 = coreglib.Type(C.gtk_list_box_row_get_type())
	GTypeListItem                   = coreglib.Type(C.gtk_list_item_get_type())
	GTypeListItemFactory            = coreglib.Type(C.gtk_list_item_factory_get_type())
	GTypeListStore                  = coreglib.Type(C.gtk_list_store_get_type())
	GTypeListView                   = coreglib.Type(C.gtk_list_view_get_type())
	GTypeLockButton                 = coreglib.Type(C.gtk_lock_button_get_type())
	GTypeMapListModel               = coreglib.Type(C.gtk_map_list_model_get_type())
	GTypeMediaControls              = coreglib.Type(C.gtk_media_controls_get_type())
	GTypeMediaFile                  = coreglib.Type(C.gtk_media_file_get_type())
	GTypeMediaStream                = coreglib.Type(C.gtk_media_stream_get_type())
	GTypeMenuButton                 = coreglib.Type(C.gtk_menu_button_get_type())
	GTypeMessageDialog              = coreglib.Type(C.gtk_message_dialog_get_type())
	GTypeMnemonicAction             = coreglib.Type(C.gtk_mnemonic_action_get_type())
	GTypeMnemonicTrigger            = coreglib.Type(C.gtk_mnemonic_trigger_get_type())
	GTypeMountOperation             = coreglib.Type(C.gtk_mount_operation_get_type())
	GTypeMultiFilter                = coreglib.Type(C.gtk_multi_filter_get_type())
	GTypeMultiSelection             = coreglib.Type(C.gtk_multi_selection_get_type())
	GTypeMultiSorter                = coreglib.Type(C.gtk_multi_sorter_get_type())
	GTypeNamedAction                = coreglib.Type(C.gtk_named_action_get_type())
	GTypeNativeDialog               = coreglib.Type(C.gtk_native_dialog_get_type())
	GTypeNeverTrigger               = coreglib.Type(C.gtk_never_trigger_get_type())
	GTypeNoSelection                = coreglib.Type(C.gtk_no_selection_get_type())
	GTypeNotebook                   = coreglib.Type(C.gtk_notebook_get_type())
	GTypeNotebookPage               = coreglib.Type(C.gtk_notebook_page_get_type())
	GTypeNothingAction              = coreglib.Type(C.gtk_nothing_action_get_type())
	GTypeNumericSorter              = coreglib.Type(C.gtk_numeric_sorter_get_type())
	GTypeObjectExpression           = coreglib.Type(C.gtk_object_expression_get_type())
	GTypeOverlay                    = coreglib.Type(C.gtk_overlay_get_type())
	GTypeOverlayLayout              = coreglib.Type(C.gtk_overlay_layout_get_type())
	GTypeOverlayLayoutChild         = coreglib.Type(C.gtk_overlay_layout_child_get_type())
	GTypePadController              = coreglib.Type(C.gtk_pad_controller_get_type())
	GTypePageSetup                  = coreglib.Type(C.gtk_page_setup_get_type())
	GTypePaned                      = coreglib.Type(C.gtk_paned_get_type())
	GTypePasswordEntry              = coreglib.Type(C.gtk_password_entry_get_type())
	GTypePicture                    = coreglib.Type(C.gtk_picture_get_type())
	GTypePopover                    = coreglib.Type(C.gtk_popover_get_type())
	GTypePopoverMenu                = coreglib.Type(C.gtk_popover_menu_get_type())
	GTypePopoverMenuBar             = coreglib.Type(C.gtk_popover_menu_bar_get_type())
	GTypePrintContext               = coreglib.Type(C.gtk_print_context_get_type())
	GTypePrintOperation             = coreglib.Type(C.gtk_print_operation_get_type())
	GTypePrintSettings              = coreglib.Type(C.gtk_print_settings_get_type())
	GTypeProgressBar                = coreglib.Type(C.gtk_progress_bar_get_type())
	GTypePropertyExpression         = coreglib.Type(C.gtk_property_expression_get_type())
	GTypeRange                      = coreglib.Type(C.gtk_range_get_type())
	GTypeRecentManager              = coreglib.Type(C.gtk_recent_manager_get_type())
	GTypeRevealer                   = coreglib.Type(C.gtk_revealer_get_type())
	GTypeScale                      = coreglib.Type(C.gtk_scale_get_type())
	GTypeScaleButton                = coreglib.Type(C.gtk_scale_button_get_type())
	GTypeScrollbar                  = coreglib.Type(C.gtk_scrollbar_get_type())
	GTypeScrolledWindow             = coreglib.Type(C.gtk_scrolled_window_get_type())
	GTypeSearchBar                  = coreglib.Type(C.gtk_search_bar_get_type())
	GTypeSearchEntry                = coreglib.Type(C.gtk_search_entry_get_type())
	GTypeSelectionFilterModel       = coreglib.Type(C.gtk_selection_filter_model_get_type())
	GTypeSeparator                  = coreglib.Type(C.gtk_separator_get_type())
	GTypeSettings                   = coreglib.Type(C.gtk_settings_get_type())
	GTypeShortcut                   = coreglib.Type(C.gtk_shortcut_get_type())
	GTypeShortcutAction             = coreglib.Type(C.gtk_shortcut_action_get_type())
	GTypeShortcutController         = coreglib.Type(C.gtk_shortcut_controller_get_type())
	GTypeShortcutLabel              = coreglib.Type(C.gtk_shortcut_label_get_type())
	GTypeShortcutTrigger            = coreglib.Type(C.gtk_shortcut_trigger_get_type())
	GTypeShortcutsGroup             = coreglib.Type(C.gtk_shortcuts_group_get_type())
	GTypeShortcutsSection           = coreglib.Type(C.gtk_shortcuts_section_get_type())
	GTypeShortcutsShortcut          = coreglib.Type(C.gtk_shortcuts_shortcut_get_type())
	GTypeShortcutsWindow            = coreglib.Type(C.gtk_shortcuts_window_get_type())
	GTypeSignalAction               = coreglib.Type(C.gtk_signal_action_get_type())
	GTypeSignalListItemFactory      = coreglib.Type(C.gtk_signal_list_item_factory_get_type())
	GTypeSingleSelection            = coreglib.Type(C.gtk_single_selection_get_type())
	GTypeSizeGroup                  = coreglib.Type(C.gtk_size_group_get_type())
	GTypeSliceListModel             = coreglib.Type(C.gtk_slice_list_model_get_type())
	GTypeSnapshot                   = coreglib.Type(C.gtk_snapshot_get_type())
	GTypeSortListModel              = coreglib.Type(C.gtk_sort_list_model_get_type())
	GTypeSorter                     = coreglib.Type(C.gtk_sorter_get_type())
	GTypeSpinButton                 = coreglib.Type(C.gtk_spin_button_get_type())
	GTypeSpinner                    = coreglib.Type(C.gtk_spinner_get_type())
	GTypeStack                      = coreglib.Type(C.gtk_stack_get_type())
	GTypeStackPage                  = coreglib.Type(C.gtk_stack_page_get_type())
	GTypeStackSidebar               = coreglib.Type(C.gtk_stack_sidebar_get_type())
	GTypeStackSwitcher              = coreglib.Type(C.gtk_stack_switcher_get_type())
	GTypeStatusbar                  = coreglib.Type(C.gtk_statusbar_get_type())
	GTypeStringFilter               = coreglib.Type(C.gtk_string_filter_get_type())
	GTypeStringList                 = coreglib.Type(C.gtk_string_list_get_type())
	GTypeStringObject               = coreglib.Type(C.gtk_string_object_get_type())
	GTypeStringSorter               = coreglib.Type(C.gtk_string_sorter_get_type())
	GTypeStyleContext               = coreglib.Type(C.gtk_style_context_get_type())
	GTypeSwitch                     = coreglib.Type(C.gtk_switch_get_type())
	GTypeText                       = coreglib.Type(C.gtk_text_get_type())
	GTypeTextBuffer                 = coreglib.Type(C.gtk_text_buffer_get_type())
	GTypeTextChildAnchor            = coreglib.Type(C.gtk_text_child_anchor_get_type())
	GTypeTextMark                   = coreglib.Type(C.gtk_text_mark_get_type())
	GTypeTextTag                    = coreglib.Type(C.gtk_text_tag_get_type())
	GTypeTextTagTable               = coreglib.Type(C.gtk_text_tag_table_get_type())
	GTypeTextView                   = coreglib.Type(C.gtk_text_view_get_type())
	GTypeToggleButton               = coreglib.Type(C.gtk_toggle_button_get_type())
	GTypeTooltip                    = coreglib.Type(C.gtk_tooltip_get_type())
	GTypeTreeExpander               = coreglib.Type(C.gtk_tree_expander_get_type())
	GTypeTreeListModel              = coreglib.Type(C.gtk_tree_list_model_get_type())
	GTypeTreeListRow                = coreglib.Type(C.gtk_tree_list_row_get_type())
	GTypeTreeListRowSorter          = coreglib.Type(C.gtk_tree_list_row_sorter_get_type())
	GTypeTreeModelFilter            = coreglib.Type(C.gtk_tree_model_filter_get_type())
	GTypeTreeModelSort              = coreglib.Type(C.gtk_tree_model_sort_get_type())
	GTypeTreeSelection              = coreglib.Type(C.gtk_tree_selection_get_type())
	GTypeTreeStore                  = coreglib.Type(C.gtk_tree_store_get_type())
	GTypeTreeView                   = coreglib.Type(C.gtk_tree_view_get_type())
	GTypeTreeViewColumn             = coreglib.Type(C.gtk_tree_view_column_get_type())
	GTypeVideo                      = coreglib.Type(C.gtk_video_get_type())
	GTypeViewport                   = coreglib.Type(C.gtk_viewport_get_type())
	GTypeVolumeButton               = coreglib.Type(C.gtk_volume_button_get_type())
	GTypeWidget                     = coreglib.Type(C.gtk_widget_get_type())
	GTypeWidgetPaintable            = coreglib.Type(C.gtk_widget_paintable_get_type())
	GTypeWindow                     = coreglib.Type(C.gtk_window_get_type())
	GTypeWindowControls             = coreglib.Type(C.gtk_window_controls_get_type())
	GTypeWindowGroup                = coreglib.Type(C.gtk_window_group_get_type())
	GTypeWindowHandle               = coreglib.Type(C.gtk_window_handle_get_type())
	GTypeBitset                     = coreglib.Type(C.gtk_bitset_get_type())
	GTypeBorder                     = coreglib.Type(C.gtk_border_get_type())
	GTypeCSSSection                 = coreglib.Type(C.gtk_css_section_get_type())
	GTypeExpressionWatch            = coreglib.Type(C.gtk_expression_watch_get_type())
	GTypePaperSize                  = coreglib.Type(C.gtk_paper_size_get_type())
	GTypeRecentInfo                 = coreglib.Type(C.gtk_recent_info_get_type())
	GTypeRequisition                = coreglib.Type(C.gtk_requisition_get_type())
	GTypeTextIter                   = coreglib.Type(C.gtk_text_iter_get_type())
	GTypeTreeIter                   = coreglib.Type(C.gtk_tree_iter_get_type())
	GTypeTreePath                   = coreglib.Type(C.gtk_tree_path_get_type())
	GTypeTreeRowReference           = coreglib.Type(C.gtk_tree_row_reference_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAccessibleAutocomplete, F: marshalAccessibleAutocomplete},
		coreglib.TypeMarshaler{T: GTypeAccessibleInvalidState, F: marshalAccessibleInvalidState},
		coreglib.TypeMarshaler{T: GTypeAccessibleProperty, F: marshalAccessibleProperty},
		coreglib.TypeMarshaler{T: GTypeAccessibleRelation, F: marshalAccessibleRelation},
		coreglib.TypeMarshaler{T: GTypeAccessibleRole, F: marshalAccessibleRole},
		coreglib.TypeMarshaler{T: GTypeAccessibleSort, F: marshalAccessibleSort},
		coreglib.TypeMarshaler{T: GTypeAccessibleState, F: marshalAccessibleState},
		coreglib.TypeMarshaler{T: GTypeAccessibleTristate, F: marshalAccessibleTristate},
		coreglib.TypeMarshaler{T: GTypeAlign, F: marshalAlign},
		coreglib.TypeMarshaler{T: GTypeArrowType, F: marshalArrowType},
		coreglib.TypeMarshaler{T: GTypeAssistantPageType, F: marshalAssistantPageType},
		coreglib.TypeMarshaler{T: GTypeBaselinePosition, F: marshalBaselinePosition},
		coreglib.TypeMarshaler{T: GTypeBorderStyle, F: marshalBorderStyle},
		coreglib.TypeMarshaler{T: GTypeBuilderError, F: marshalBuilderError},
		coreglib.TypeMarshaler{T: GTypeButtonsType, F: marshalButtonsType},
		coreglib.TypeMarshaler{T: GTypeCellRendererAccelMode, F: marshalCellRendererAccelMode},
		coreglib.TypeMarshaler{T: GTypeCellRendererMode, F: marshalCellRendererMode},
		coreglib.TypeMarshaler{T: GTypeConstraintAttribute, F: marshalConstraintAttribute},
		coreglib.TypeMarshaler{T: GTypeConstraintRelation, F: marshalConstraintRelation},
		coreglib.TypeMarshaler{T: GTypeConstraintStrength, F: marshalConstraintStrength},
		coreglib.TypeMarshaler{T: GTypeConstraintVflParserError, F: marshalConstraintVflParserError},
		coreglib.TypeMarshaler{T: GTypeCornerType, F: marshalCornerType},
		coreglib.TypeMarshaler{T: GTypeDeleteType, F: marshalDeleteType},
		coreglib.TypeMarshaler{T: GTypeDirectionType, F: marshalDirectionType},
		coreglib.TypeMarshaler{T: GTypeEditableProperties, F: marshalEditableProperties},
		coreglib.TypeMarshaler{T: GTypeEntryIconPosition, F: marshalEntryIconPosition},
		coreglib.TypeMarshaler{T: GTypeEventSequenceState, F: marshalEventSequenceState},
		coreglib.TypeMarshaler{T: GTypeFileChooserAction, F: marshalFileChooserAction},
		coreglib.TypeMarshaler{T: GTypeFileChooserError, F: marshalFileChooserError},
		coreglib.TypeMarshaler{T: GTypeFilterChange, F: marshalFilterChange},
		coreglib.TypeMarshaler{T: GTypeFilterMatch, F: marshalFilterMatch},
		coreglib.TypeMarshaler{T: GTypeIconSize, F: marshalIconSize},
		coreglib.TypeMarshaler{T: GTypeIconThemeError, F: marshalIconThemeError},
		coreglib.TypeMarshaler{T: GTypeIconViewDropPosition, F: marshalIconViewDropPosition},
		coreglib.TypeMarshaler{T: GTypeImageType, F: marshalImageType},
		coreglib.TypeMarshaler{T: GTypeInputPurpose, F: marshalInputPurpose},
		coreglib.TypeMarshaler{T: GTypeJustification, F: marshalJustification},
		coreglib.TypeMarshaler{T: GTypeLevelBarMode, F: marshalLevelBarMode},
		coreglib.TypeMarshaler{T: GTypeLicense, F: marshalLicense},
		coreglib.TypeMarshaler{T: GTypeMessageType, F: marshalMessageType},
		coreglib.TypeMarshaler{T: GTypeMovementStep, F: marshalMovementStep},
		coreglib.TypeMarshaler{T: GTypeNotebookTab, F: marshalNotebookTab},
		coreglib.TypeMarshaler{T: GTypeNumberUpLayout, F: marshalNumberUpLayout},
		coreglib.TypeMarshaler{T: GTypeOrdering, F: marshalOrdering},
		coreglib.TypeMarshaler{T: GTypeOrientation, F: marshalOrientation},
		coreglib.TypeMarshaler{T: GTypeOverflow, F: marshalOverflow},
		coreglib.TypeMarshaler{T: GTypePackType, F: marshalPackType},
		coreglib.TypeMarshaler{T: GTypePadActionType, F: marshalPadActionType},
		coreglib.TypeMarshaler{T: GTypePageOrientation, F: marshalPageOrientation},
		coreglib.TypeMarshaler{T: GTypePageSet, F: marshalPageSet},
		coreglib.TypeMarshaler{T: GTypePanDirection, F: marshalPanDirection},
		coreglib.TypeMarshaler{T: GTypePolicyType, F: marshalPolicyType},
		coreglib.TypeMarshaler{T: GTypePositionType, F: marshalPositionType},
		coreglib.TypeMarshaler{T: GTypePrintDuplex, F: marshalPrintDuplex},
		coreglib.TypeMarshaler{T: GTypePrintError, F: marshalPrintError},
		coreglib.TypeMarshaler{T: GTypePrintOperationAction, F: marshalPrintOperationAction},
		coreglib.TypeMarshaler{T: GTypePrintOperationResult, F: marshalPrintOperationResult},
		coreglib.TypeMarshaler{T: GTypePrintPages, F: marshalPrintPages},
		coreglib.TypeMarshaler{T: GTypePrintQuality, F: marshalPrintQuality},
		coreglib.TypeMarshaler{T: GTypePrintStatus, F: marshalPrintStatus},
		coreglib.TypeMarshaler{T: GTypePropagationLimit, F: marshalPropagationLimit},
		coreglib.TypeMarshaler{T: GTypePropagationPhase, F: marshalPropagationPhase},
		coreglib.TypeMarshaler{T: GTypeRecentManagerError, F: marshalRecentManagerError},
		coreglib.TypeMarshaler{T: GTypeResponseType, F: marshalResponseType},
		coreglib.TypeMarshaler{T: GTypeRevealerTransitionType, F: marshalRevealerTransitionType},
		coreglib.TypeMarshaler{T: GTypeScrollStep, F: marshalScrollStep},
		coreglib.TypeMarshaler{T: GTypeScrollType, F: marshalScrollType},
		coreglib.TypeMarshaler{T: GTypeScrollablePolicy, F: marshalScrollablePolicy},
		coreglib.TypeMarshaler{T: GTypeSelectionMode, F: marshalSelectionMode},
		coreglib.TypeMarshaler{T: GTypeSensitivityType, F: marshalSensitivityType},
		coreglib.TypeMarshaler{T: GTypeShortcutScope, F: marshalShortcutScope},
		coreglib.TypeMarshaler{T: GTypeShortcutType, F: marshalShortcutType},
		coreglib.TypeMarshaler{T: GTypeSizeGroupMode, F: marshalSizeGroupMode},
		coreglib.TypeMarshaler{T: GTypeSizeRequestMode, F: marshalSizeRequestMode},
		coreglib.TypeMarshaler{T: GTypeSortType, F: marshalSortType},
		coreglib.TypeMarshaler{T: GTypeSorterChange, F: marshalSorterChange},
		coreglib.TypeMarshaler{T: GTypeSorterOrder, F: marshalSorterOrder},
		coreglib.TypeMarshaler{T: GTypeSpinButtonUpdatePolicy, F: marshalSpinButtonUpdatePolicy},
		coreglib.TypeMarshaler{T: GTypeSpinType, F: marshalSpinType},
		coreglib.TypeMarshaler{T: GTypeStackTransitionType, F: marshalStackTransitionType},
		coreglib.TypeMarshaler{T: GTypeStringFilterMatchMode, F: marshalStringFilterMatchMode},
		coreglib.TypeMarshaler{T: GTypeSystemSetting, F: marshalSystemSetting},
		coreglib.TypeMarshaler{T: GTypeTextDirection, F: marshalTextDirection},
		coreglib.TypeMarshaler{T: GTypeTextExtendSelection, F: marshalTextExtendSelection},
		coreglib.TypeMarshaler{T: GTypeTextViewLayer, F: marshalTextViewLayer},
		coreglib.TypeMarshaler{T: GTypeTextWindowType, F: marshalTextWindowType},
		coreglib.TypeMarshaler{T: GTypeTreeViewColumnSizing, F: marshalTreeViewColumnSizing},
		coreglib.TypeMarshaler{T: GTypeTreeViewDropPosition, F: marshalTreeViewDropPosition},
		coreglib.TypeMarshaler{T: GTypeTreeViewGridLines, F: marshalTreeViewGridLines},
		coreglib.TypeMarshaler{T: GTypeUnit, F: marshalUnit},
		coreglib.TypeMarshaler{T: GTypeWrapMode, F: marshalWrapMode},
		coreglib.TypeMarshaler{T: GTypeApplicationInhibitFlags, F: marshalApplicationInhibitFlags},
		coreglib.TypeMarshaler{T: GTypeBuilderClosureFlags, F: marshalBuilderClosureFlags},
		coreglib.TypeMarshaler{T: GTypeCellRendererState, F: marshalCellRendererState},
		coreglib.TypeMarshaler{T: GTypeDebugFlags, F: marshalDebugFlags},
		coreglib.TypeMarshaler{T: GTypeDialogFlags, F: marshalDialogFlags},
		coreglib.TypeMarshaler{T: GTypeEventControllerScrollFlags, F: marshalEventControllerScrollFlags},
		coreglib.TypeMarshaler{T: GTypeFontChooserLevel, F: marshalFontChooserLevel},
		coreglib.TypeMarshaler{T: GTypeIconLookupFlags, F: marshalIconLookupFlags},
		coreglib.TypeMarshaler{T: GTypeInputHints, F: marshalInputHints},
		coreglib.TypeMarshaler{T: GTypePickFlags, F: marshalPickFlags},
		coreglib.TypeMarshaler{T: GTypePopoverMenuFlags, F: marshalPopoverMenuFlags},
		coreglib.TypeMarshaler{T: GTypeShortcutActionFlags, F: marshalShortcutActionFlags},
		coreglib.TypeMarshaler{T: GTypeStateFlags, F: marshalStateFlags},
		coreglib.TypeMarshaler{T: GTypeStyleContextPrintFlags, F: marshalStyleContextPrintFlags},
		coreglib.TypeMarshaler{T: GTypeTextSearchFlags, F: marshalTextSearchFlags},
		coreglib.TypeMarshaler{T: GTypeTreeModelFlags, F: marshalTreeModelFlags},
		coreglib.TypeMarshaler{T: GTypeAccessible, F: marshalAccessible},
		coreglib.TypeMarshaler{T: GTypeActionable, F: marshalActionable},
		coreglib.TypeMarshaler{T: GTypeAppChooser, F: marshalAppChooser},
		coreglib.TypeMarshaler{T: GTypeBuildable, F: marshalBuildable},
		coreglib.TypeMarshaler{T: GTypeBuilderScope, F: marshalBuilderScope},
		coreglib.TypeMarshaler{T: GTypeCellEditable, F: marshalCellEditable},
		coreglib.TypeMarshaler{T: GTypeCellLayout, F: marshalCellLayout},
		coreglib.TypeMarshaler{T: GTypeColorChooser, F: marshalColorChooser},
		coreglib.TypeMarshaler{T: GTypeConstraintTarget, F: marshalConstraintTarget},
		coreglib.TypeMarshaler{T: GTypeEditableTextWidget, F: marshalEditableTextWidget},
		coreglib.TypeMarshaler{T: GTypeFileChooser, F: marshalFileChooser},
		coreglib.TypeMarshaler{T: GTypeFontChooser, F: marshalFontChooser},
		coreglib.TypeMarshaler{T: GTypeNativeSurface, F: marshalNativeSurface},
		coreglib.TypeMarshaler{T: GTypeOrientable, F: marshalOrientable},
		coreglib.TypeMarshaler{T: GTypePrintOperationPreview, F: marshalPrintOperationPreview},
		coreglib.TypeMarshaler{T: GTypeRoot, F: marshalRoot},
		coreglib.TypeMarshaler{T: GTypeScrollable, F: marshalScrollable},
		coreglib.TypeMarshaler{T: GTypeSelectionModel, F: marshalSelectionModel},
		coreglib.TypeMarshaler{T: GTypeShortcutManager, F: marshalShortcutManager},
		coreglib.TypeMarshaler{T: GTypeStyleProvider, F: marshalStyleProvider},
		coreglib.TypeMarshaler{T: GTypeTreeDragDest, F: marshalTreeDragDest},
		coreglib.TypeMarshaler{T: GTypeTreeDragSource, F: marshalTreeDragSource},
		coreglib.TypeMarshaler{T: GTypeTreeModel, F: marshalTreeModel},
		coreglib.TypeMarshaler{T: GTypeTreeSortable, F: marshalTreeSortable},
		coreglib.TypeMarshaler{T: GTypeATContext, F: marshalATContext},
		coreglib.TypeMarshaler{T: GTypeAboutDialog, F: marshalAboutDialog},
		coreglib.TypeMarshaler{T: GTypeActionBar, F: marshalActionBar},
		coreglib.TypeMarshaler{T: GTypeActivateAction, F: marshalActivateAction},
		coreglib.TypeMarshaler{T: GTypeAdjustment, F: marshalAdjustment},
		coreglib.TypeMarshaler{T: GTypeAlternativeTrigger, F: marshalAlternativeTrigger},
		coreglib.TypeMarshaler{T: GTypeAnyFilter, F: marshalAnyFilter},
		coreglib.TypeMarshaler{T: GTypeAppChooserButton, F: marshalAppChooserButton},
		coreglib.TypeMarshaler{T: GTypeAppChooserDialog, F: marshalAppChooserDialog},
		coreglib.TypeMarshaler{T: GTypeAppChooserWidget, F: marshalAppChooserWidget},
		coreglib.TypeMarshaler{T: GTypeApplication, F: marshalApplication},
		coreglib.TypeMarshaler{T: GTypeApplicationWindow, F: marshalApplicationWindow},
		coreglib.TypeMarshaler{T: GTypeAspectFrame, F: marshalAspectFrame},
		coreglib.TypeMarshaler{T: GTypeAssistant, F: marshalAssistant},
		coreglib.TypeMarshaler{T: GTypeAssistantPage, F: marshalAssistantPage},
		coreglib.TypeMarshaler{T: GTypeBinLayout, F: marshalBinLayout},
		coreglib.TypeMarshaler{T: GTypeBookmarkList, F: marshalBookmarkList},
		coreglib.TypeMarshaler{T: GTypeBoolFilter, F: marshalBoolFilter},
		coreglib.TypeMarshaler{T: GTypeBox, F: marshalBox},
		coreglib.TypeMarshaler{T: GTypeBoxLayout, F: marshalBoxLayout},
		coreglib.TypeMarshaler{T: GTypeBuilder, F: marshalBuilder},
		coreglib.TypeMarshaler{T: GTypeBuilderCScope, F: marshalBuilderCScope},
		coreglib.TypeMarshaler{T: GTypeBuilderListItemFactory, F: marshalBuilderListItemFactory},
		coreglib.TypeMarshaler{T: GTypeButton, F: marshalButton},
		coreglib.TypeMarshaler{T: GTypeCClosureExpression, F: marshalCClosureExpression},
		coreglib.TypeMarshaler{T: GTypeCalendar, F: marshalCalendar},
		coreglib.TypeMarshaler{T: GTypeCallbackAction, F: marshalCallbackAction},
		coreglib.TypeMarshaler{T: GTypeCellArea, F: marshalCellArea},
		coreglib.TypeMarshaler{T: GTypeCellAreaBox, F: marshalCellAreaBox},
		coreglib.TypeMarshaler{T: GTypeCellAreaContext, F: marshalCellAreaContext},
		coreglib.TypeMarshaler{T: GTypeCellRenderer, F: marshalCellRenderer},
		coreglib.TypeMarshaler{T: GTypeCellRendererAccel, F: marshalCellRendererAccel},
		coreglib.TypeMarshaler{T: GTypeCellRendererCombo, F: marshalCellRendererCombo},
		coreglib.TypeMarshaler{T: GTypeCellRendererPixbuf, F: marshalCellRendererPixbuf},
		coreglib.TypeMarshaler{T: GTypeCellRendererProgress, F: marshalCellRendererProgress},
		coreglib.TypeMarshaler{T: GTypeCellRendererSpin, F: marshalCellRendererSpin},
		coreglib.TypeMarshaler{T: GTypeCellRendererSpinner, F: marshalCellRendererSpinner},
		coreglib.TypeMarshaler{T: GTypeCellRendererText, F: marshalCellRendererText},
		coreglib.TypeMarshaler{T: GTypeCellRendererToggle, F: marshalCellRendererToggle},
		coreglib.TypeMarshaler{T: GTypeCellView, F: marshalCellView},
		coreglib.TypeMarshaler{T: GTypeCenterBox, F: marshalCenterBox},
		coreglib.TypeMarshaler{T: GTypeCenterLayout, F: marshalCenterLayout},
		coreglib.TypeMarshaler{T: GTypeCheckButton, F: marshalCheckButton},
		coreglib.TypeMarshaler{T: GTypeClosureExpression, F: marshalClosureExpression},
		coreglib.TypeMarshaler{T: GTypeColorButton, F: marshalColorButton},
		coreglib.TypeMarshaler{T: GTypeColorChooserDialog, F: marshalColorChooserDialog},
		coreglib.TypeMarshaler{T: GTypeColorChooserWidget, F: marshalColorChooserWidget},
		coreglib.TypeMarshaler{T: GTypeColumnView, F: marshalColumnView},
		coreglib.TypeMarshaler{T: GTypeColumnViewColumn, F: marshalColumnViewColumn},
		coreglib.TypeMarshaler{T: GTypeComboBox, F: marshalComboBox},
		coreglib.TypeMarshaler{T: GTypeComboBoxText, F: marshalComboBoxText},
		coreglib.TypeMarshaler{T: GTypeConstantExpression, F: marshalConstantExpression},
		coreglib.TypeMarshaler{T: GTypeConstraint, F: marshalConstraint},
		coreglib.TypeMarshaler{T: GTypeConstraintGuide, F: marshalConstraintGuide},
		coreglib.TypeMarshaler{T: GTypeConstraintLayout, F: marshalConstraintLayout},
		coreglib.TypeMarshaler{T: GTypeConstraintLayoutChild, F: marshalConstraintLayoutChild},
		coreglib.TypeMarshaler{T: GTypeCSSProvider, F: marshalCSSProvider},
		coreglib.TypeMarshaler{T: GTypeCustomFilter, F: marshalCustomFilter},
		coreglib.TypeMarshaler{T: GTypeCustomLayout, F: marshalCustomLayout},
		coreglib.TypeMarshaler{T: GTypeCustomSorter, F: marshalCustomSorter},
		coreglib.TypeMarshaler{T: GTypeDialog, F: marshalDialog},
		coreglib.TypeMarshaler{T: GTypeDirectoryList, F: marshalDirectoryList},
		coreglib.TypeMarshaler{T: GTypeDragIcon, F: marshalDragIcon},
		coreglib.TypeMarshaler{T: GTypeDragSource, F: marshalDragSource},
		coreglib.TypeMarshaler{T: GTypeDrawingArea, F: marshalDrawingArea},
		coreglib.TypeMarshaler{T: GTypeDropControllerMotion, F: marshalDropControllerMotion},
		coreglib.TypeMarshaler{T: GTypeDropDown, F: marshalDropDown},
		coreglib.TypeMarshaler{T: GTypeDropTarget, F: marshalDropTarget},
		coreglib.TypeMarshaler{T: GTypeDropTargetAsync, F: marshalDropTargetAsync},
		coreglib.TypeMarshaler{T: GTypeEditableLabel, F: marshalEditableLabel},
		coreglib.TypeMarshaler{T: GTypeEmojiChooser, F: marshalEmojiChooser},
		coreglib.TypeMarshaler{T: GTypeEntry, F: marshalEntry},
		coreglib.TypeMarshaler{T: GTypeEntryBuffer, F: marshalEntryBuffer},
		coreglib.TypeMarshaler{T: GTypeEntryCompletion, F: marshalEntryCompletion},
		coreglib.TypeMarshaler{T: GTypeEventController, F: marshalEventController},
		coreglib.TypeMarshaler{T: GTypeEventControllerFocus, F: marshalEventControllerFocus},
		coreglib.TypeMarshaler{T: GTypeEventControllerKey, F: marshalEventControllerKey},
		coreglib.TypeMarshaler{T: GTypeEventControllerLegacy, F: marshalEventControllerLegacy},
		coreglib.TypeMarshaler{T: GTypeEventControllerMotion, F: marshalEventControllerMotion},
		coreglib.TypeMarshaler{T: GTypeEventControllerScroll, F: marshalEventControllerScroll},
		coreglib.TypeMarshaler{T: GTypeEveryFilter, F: marshalEveryFilter},
		coreglib.TypeMarshaler{T: GTypeExpander, F: marshalExpander},
		coreglib.TypeMarshaler{T: GTypeExpression, F: marshalExpression},
		coreglib.TypeMarshaler{T: GTypeFileChooserDialog, F: marshalFileChooserDialog},
		coreglib.TypeMarshaler{T: GTypeFileChooserNative, F: marshalFileChooserNative},
		coreglib.TypeMarshaler{T: GTypeFileChooserWidget, F: marshalFileChooserWidget},
		coreglib.TypeMarshaler{T: GTypeFileFilter, F: marshalFileFilter},
		coreglib.TypeMarshaler{T: GTypeFilter, F: marshalFilter},
		coreglib.TypeMarshaler{T: GTypeFilterListModel, F: marshalFilterListModel},
		coreglib.TypeMarshaler{T: GTypeFixed, F: marshalFixed},
		coreglib.TypeMarshaler{T: GTypeFixedLayout, F: marshalFixedLayout},
		coreglib.TypeMarshaler{T: GTypeFixedLayoutChild, F: marshalFixedLayoutChild},
		coreglib.TypeMarshaler{T: GTypeFlattenListModel, F: marshalFlattenListModel},
		coreglib.TypeMarshaler{T: GTypeFlowBox, F: marshalFlowBox},
		coreglib.TypeMarshaler{T: GTypeFlowBoxChild, F: marshalFlowBoxChild},
		coreglib.TypeMarshaler{T: GTypeFontButton, F: marshalFontButton},
		coreglib.TypeMarshaler{T: GTypeFontChooserDialog, F: marshalFontChooserDialog},
		coreglib.TypeMarshaler{T: GTypeFontChooserWidget, F: marshalFontChooserWidget},
		coreglib.TypeMarshaler{T: GTypeFrame, F: marshalFrame},
		coreglib.TypeMarshaler{T: GTypeGLArea, F: marshalGLArea},
		coreglib.TypeMarshaler{T: GTypeGesture, F: marshalGesture},
		coreglib.TypeMarshaler{T: GTypeGestureClick, F: marshalGestureClick},
		coreglib.TypeMarshaler{T: GTypeGestureDrag, F: marshalGestureDrag},
		coreglib.TypeMarshaler{T: GTypeGestureLongPress, F: marshalGestureLongPress},
		coreglib.TypeMarshaler{T: GTypeGesturePan, F: marshalGesturePan},
		coreglib.TypeMarshaler{T: GTypeGestureRotate, F: marshalGestureRotate},
		coreglib.TypeMarshaler{T: GTypeGestureSingle, F: marshalGestureSingle},
		coreglib.TypeMarshaler{T: GTypeGestureStylus, F: marshalGestureStylus},
		coreglib.TypeMarshaler{T: GTypeGestureSwipe, F: marshalGestureSwipe},
		coreglib.TypeMarshaler{T: GTypeGestureZoom, F: marshalGestureZoom},
		coreglib.TypeMarshaler{T: GTypeGrid, F: marshalGrid},
		coreglib.TypeMarshaler{T: GTypeGridLayout, F: marshalGridLayout},
		coreglib.TypeMarshaler{T: GTypeGridLayoutChild, F: marshalGridLayoutChild},
		coreglib.TypeMarshaler{T: GTypeGridView, F: marshalGridView},
		coreglib.TypeMarshaler{T: GTypeHeaderBar, F: marshalHeaderBar},
		coreglib.TypeMarshaler{T: GTypeIMContext, F: marshalIMContext},
		coreglib.TypeMarshaler{T: GTypeIMContextSimple, F: marshalIMContextSimple},
		coreglib.TypeMarshaler{T: GTypeIMMulticontext, F: marshalIMMulticontext},
		coreglib.TypeMarshaler{T: GTypeIconPaintable, F: marshalIconPaintable},
		coreglib.TypeMarshaler{T: GTypeIconTheme, F: marshalIconTheme},
		coreglib.TypeMarshaler{T: GTypeIconView, F: marshalIconView},
		coreglib.TypeMarshaler{T: GTypeImage, F: marshalImage},
		coreglib.TypeMarshaler{T: GTypeInfoBar, F: marshalInfoBar},
		coreglib.TypeMarshaler{T: GTypeKeyvalTrigger, F: marshalKeyvalTrigger},
		coreglib.TypeMarshaler{T: GTypeLabel, F: marshalLabel},
		coreglib.TypeMarshaler{T: GTypeLayoutChild, F: marshalLayoutChild},
		coreglib.TypeMarshaler{T: GTypeLayoutManager, F: marshalLayoutManager},
		coreglib.TypeMarshaler{T: GTypeLevelBar, F: marshalLevelBar},
		coreglib.TypeMarshaler{T: GTypeLinkButton, F: marshalLinkButton},
		coreglib.TypeMarshaler{T: GTypeListBase, F: marshalListBase},
		coreglib.TypeMarshaler{T: GTypeListBox, F: marshalListBox},
		coreglib.TypeMarshaler{T: GTypeListBoxRow, F: marshalListBoxRow},
		coreglib.TypeMarshaler{T: GTypeListItem, F: marshalListItem},
		coreglib.TypeMarshaler{T: GTypeListItemFactory, F: marshalListItemFactory},
		coreglib.TypeMarshaler{T: GTypeListStore, F: marshalListStore},
		coreglib.TypeMarshaler{T: GTypeListView, F: marshalListView},
		coreglib.TypeMarshaler{T: GTypeLockButton, F: marshalLockButton},
		coreglib.TypeMarshaler{T: GTypeMapListModel, F: marshalMapListModel},
		coreglib.TypeMarshaler{T: GTypeMediaControls, F: marshalMediaControls},
		coreglib.TypeMarshaler{T: GTypeMediaFile, F: marshalMediaFile},
		coreglib.TypeMarshaler{T: GTypeMediaStream, F: marshalMediaStream},
		coreglib.TypeMarshaler{T: GTypeMenuButton, F: marshalMenuButton},
		coreglib.TypeMarshaler{T: GTypeMessageDialog, F: marshalMessageDialog},
		coreglib.TypeMarshaler{T: GTypeMnemonicAction, F: marshalMnemonicAction},
		coreglib.TypeMarshaler{T: GTypeMnemonicTrigger, F: marshalMnemonicTrigger},
		coreglib.TypeMarshaler{T: GTypeMountOperation, F: marshalMountOperation},
		coreglib.TypeMarshaler{T: GTypeMultiFilter, F: marshalMultiFilter},
		coreglib.TypeMarshaler{T: GTypeMultiSelection, F: marshalMultiSelection},
		coreglib.TypeMarshaler{T: GTypeMultiSorter, F: marshalMultiSorter},
		coreglib.TypeMarshaler{T: GTypeNamedAction, F: marshalNamedAction},
		coreglib.TypeMarshaler{T: GTypeNativeDialog, F: marshalNativeDialog},
		coreglib.TypeMarshaler{T: GTypeNeverTrigger, F: marshalNeverTrigger},
		coreglib.TypeMarshaler{T: GTypeNoSelection, F: marshalNoSelection},
		coreglib.TypeMarshaler{T: GTypeNotebook, F: marshalNotebook},
		coreglib.TypeMarshaler{T: GTypeNotebookPage, F: marshalNotebookPage},
		coreglib.TypeMarshaler{T: GTypeNothingAction, F: marshalNothingAction},
		coreglib.TypeMarshaler{T: GTypeNumericSorter, F: marshalNumericSorter},
		coreglib.TypeMarshaler{T: GTypeObjectExpression, F: marshalObjectExpression},
		coreglib.TypeMarshaler{T: GTypeOverlay, F: marshalOverlay},
		coreglib.TypeMarshaler{T: GTypeOverlayLayout, F: marshalOverlayLayout},
		coreglib.TypeMarshaler{T: GTypeOverlayLayoutChild, F: marshalOverlayLayoutChild},
		coreglib.TypeMarshaler{T: GTypePadController, F: marshalPadController},
		coreglib.TypeMarshaler{T: GTypePageSetup, F: marshalPageSetup},
		coreglib.TypeMarshaler{T: GTypePaned, F: marshalPaned},
		coreglib.TypeMarshaler{T: GTypePasswordEntry, F: marshalPasswordEntry},
		coreglib.TypeMarshaler{T: GTypePicture, F: marshalPicture},
		coreglib.TypeMarshaler{T: GTypePopover, F: marshalPopover},
		coreglib.TypeMarshaler{T: GTypePopoverMenu, F: marshalPopoverMenu},
		coreglib.TypeMarshaler{T: GTypePopoverMenuBar, F: marshalPopoverMenuBar},
		coreglib.TypeMarshaler{T: GTypePrintContext, F: marshalPrintContext},
		coreglib.TypeMarshaler{T: GTypePrintOperation, F: marshalPrintOperation},
		coreglib.TypeMarshaler{T: GTypePrintSettings, F: marshalPrintSettings},
		coreglib.TypeMarshaler{T: GTypeProgressBar, F: marshalProgressBar},
		coreglib.TypeMarshaler{T: GTypePropertyExpression, F: marshalPropertyExpression},
		coreglib.TypeMarshaler{T: GTypeRange, F: marshalRange},
		coreglib.TypeMarshaler{T: GTypeRecentManager, F: marshalRecentManager},
		coreglib.TypeMarshaler{T: GTypeRevealer, F: marshalRevealer},
		coreglib.TypeMarshaler{T: GTypeScale, F: marshalScale},
		coreglib.TypeMarshaler{T: GTypeScaleButton, F: marshalScaleButton},
		coreglib.TypeMarshaler{T: GTypeScrollbar, F: marshalScrollbar},
		coreglib.TypeMarshaler{T: GTypeScrolledWindow, F: marshalScrolledWindow},
		coreglib.TypeMarshaler{T: GTypeSearchBar, F: marshalSearchBar},
		coreglib.TypeMarshaler{T: GTypeSearchEntry, F: marshalSearchEntry},
		coreglib.TypeMarshaler{T: GTypeSelectionFilterModel, F: marshalSelectionFilterModel},
		coreglib.TypeMarshaler{T: GTypeSeparator, F: marshalSeparator},
		coreglib.TypeMarshaler{T: GTypeSettings, F: marshalSettings},
		coreglib.TypeMarshaler{T: GTypeShortcut, F: marshalShortcut},
		coreglib.TypeMarshaler{T: GTypeShortcutAction, F: marshalShortcutAction},
		coreglib.TypeMarshaler{T: GTypeShortcutController, F: marshalShortcutController},
		coreglib.TypeMarshaler{T: GTypeShortcutLabel, F: marshalShortcutLabel},
		coreglib.TypeMarshaler{T: GTypeShortcutTrigger, F: marshalShortcutTrigger},
		coreglib.TypeMarshaler{T: GTypeShortcutsGroup, F: marshalShortcutsGroup},
		coreglib.TypeMarshaler{T: GTypeShortcutsSection, F: marshalShortcutsSection},
		coreglib.TypeMarshaler{T: GTypeShortcutsShortcut, F: marshalShortcutsShortcut},
		coreglib.TypeMarshaler{T: GTypeShortcutsWindow, F: marshalShortcutsWindow},
		coreglib.TypeMarshaler{T: GTypeSignalAction, F: marshalSignalAction},
		coreglib.TypeMarshaler{T: GTypeSignalListItemFactory, F: marshalSignalListItemFactory},
		coreglib.TypeMarshaler{T: GTypeSingleSelection, F: marshalSingleSelection},
		coreglib.TypeMarshaler{T: GTypeSizeGroup, F: marshalSizeGroup},
		coreglib.TypeMarshaler{T: GTypeSliceListModel, F: marshalSliceListModel},
		coreglib.TypeMarshaler{T: GTypeSnapshot, F: marshalSnapshot},
		coreglib.TypeMarshaler{T: GTypeSortListModel, F: marshalSortListModel},
		coreglib.TypeMarshaler{T: GTypeSorter, F: marshalSorter},
		coreglib.TypeMarshaler{T: GTypeSpinButton, F: marshalSpinButton},
		coreglib.TypeMarshaler{T: GTypeSpinner, F: marshalSpinner},
		coreglib.TypeMarshaler{T: GTypeStack, F: marshalStack},
		coreglib.TypeMarshaler{T: GTypeStackPage, F: marshalStackPage},
		coreglib.TypeMarshaler{T: GTypeStackSidebar, F: marshalStackSidebar},
		coreglib.TypeMarshaler{T: GTypeStackSwitcher, F: marshalStackSwitcher},
		coreglib.TypeMarshaler{T: GTypeStatusbar, F: marshalStatusbar},
		coreglib.TypeMarshaler{T: GTypeStringFilter, F: marshalStringFilter},
		coreglib.TypeMarshaler{T: GTypeStringList, F: marshalStringList},
		coreglib.TypeMarshaler{T: GTypeStringObject, F: marshalStringObject},
		coreglib.TypeMarshaler{T: GTypeStringSorter, F: marshalStringSorter},
		coreglib.TypeMarshaler{T: GTypeStyleContext, F: marshalStyleContext},
		coreglib.TypeMarshaler{T: GTypeSwitch, F: marshalSwitch},
		coreglib.TypeMarshaler{T: GTypeText, F: marshalText},
		coreglib.TypeMarshaler{T: GTypeTextBuffer, F: marshalTextBuffer},
		coreglib.TypeMarshaler{T: GTypeTextChildAnchor, F: marshalTextChildAnchor},
		coreglib.TypeMarshaler{T: GTypeTextMark, F: marshalTextMark},
		coreglib.TypeMarshaler{T: GTypeTextTag, F: marshalTextTag},
		coreglib.TypeMarshaler{T: GTypeTextTagTable, F: marshalTextTagTable},
		coreglib.TypeMarshaler{T: GTypeTextView, F: marshalTextView},
		coreglib.TypeMarshaler{T: GTypeToggleButton, F: marshalToggleButton},
		coreglib.TypeMarshaler{T: GTypeTooltip, F: marshalTooltip},
		coreglib.TypeMarshaler{T: GTypeTreeExpander, F: marshalTreeExpander},
		coreglib.TypeMarshaler{T: GTypeTreeListModel, F: marshalTreeListModel},
		coreglib.TypeMarshaler{T: GTypeTreeListRow, F: marshalTreeListRow},
		coreglib.TypeMarshaler{T: GTypeTreeListRowSorter, F: marshalTreeListRowSorter},
		coreglib.TypeMarshaler{T: GTypeTreeModelFilter, F: marshalTreeModelFilter},
		coreglib.TypeMarshaler{T: GTypeTreeModelSort, F: marshalTreeModelSort},
		coreglib.TypeMarshaler{T: GTypeTreeSelection, F: marshalTreeSelection},
		coreglib.TypeMarshaler{T: GTypeTreeStore, F: marshalTreeStore},
		coreglib.TypeMarshaler{T: GTypeTreeView, F: marshalTreeView},
		coreglib.TypeMarshaler{T: GTypeTreeViewColumn, F: marshalTreeViewColumn},
		coreglib.TypeMarshaler{T: GTypeVideo, F: marshalVideo},
		coreglib.TypeMarshaler{T: GTypeViewport, F: marshalViewport},
		coreglib.TypeMarshaler{T: GTypeVolumeButton, F: marshalVolumeButton},
		coreglib.TypeMarshaler{T: GTypeWidget, F: marshalWidget},
		coreglib.TypeMarshaler{T: GTypeWidgetPaintable, F: marshalWidgetPaintable},
		coreglib.TypeMarshaler{T: GTypeWindow, F: marshalWindow},
		coreglib.TypeMarshaler{T: GTypeWindowControls, F: marshalWindowControls},
		coreglib.TypeMarshaler{T: GTypeWindowGroup, F: marshalWindowGroup},
		coreglib.TypeMarshaler{T: GTypeWindowHandle, F: marshalWindowHandle},
		coreglib.TypeMarshaler{T: GTypeBitset, F: marshalBitset},
		coreglib.TypeMarshaler{T: GTypeBorder, F: marshalBorder},
		coreglib.TypeMarshaler{T: GTypeCSSSection, F: marshalCSSSection},
		coreglib.TypeMarshaler{T: GTypeExpressionWatch, F: marshalExpressionWatch},
		coreglib.TypeMarshaler{T: GTypePaperSize, F: marshalPaperSize},
		coreglib.TypeMarshaler{T: GTypeRecentInfo, F: marshalRecentInfo},
		coreglib.TypeMarshaler{T: GTypeRequisition, F: marshalRequisition},
		coreglib.TypeMarshaler{T: GTypeTextIter, F: marshalTextIter},
		coreglib.TypeMarshaler{T: GTypeTreeIter, F: marshalTreeIter},
		coreglib.TypeMarshaler{T: GTypeTreePath, F: marshalTreePath},
		coreglib.TypeMarshaler{T: GTypeTreeRowReference, F: marshalTreeRowReference},
	})
}

// ACCESSIBLE_VALUE_UNDEFINED: undefined value. The accessible attribute is
// either unset, or its value is undefined.
const ACCESSIBLE_VALUE_UNDEFINED = -1

// BINARY_AGE: like gtk_get_binary_age(), but from the headers used at
// application compile time, rather than from the library linked against at
// application run time.
const BINARY_AGE = 201
const IM_MODULE_EXTENSION_POINT_NAME = "gtk-im-module"

// INPUT_ERROR: constant to return from a signal handler for the ::input signal
// in case of conversion failure.
//
// See gtk.SpinButton::input.
const INPUT_ERROR = -1

// INTERFACE_AGE: like gtk_get_interface_age(), but from the headers used at
// application compile time, rather than from the library linked against at
// application run time.
const INTERFACE_AGE = 1

// LEVEL_BAR_OFFSET_FULL: name used for the stock full offset included by
// LevelBar.
const LEVEL_BAR_OFFSET_FULL = "full"

// LEVEL_BAR_OFFSET_HIGH: name used for the stock high offset included by
// LevelBar.
const LEVEL_BAR_OFFSET_HIGH = "high"

// LEVEL_BAR_OFFSET_LOW: name used for the stock low offset included by
// LevelBar.
const LEVEL_BAR_OFFSET_LOW = "low"

// MAJOR_VERSION: like gtk_get_major_version(), but from the headers used at
// application compile time, rather than from the library linked against at
// application run time.
const MAJOR_VERSION = 4
const MAX_COMPOSE_LEN = 7
const MEDIA_FILE_EXTENSION_POINT_NAME = "gtk-media-file"

// MICRO_VERSION: like gtk_get_micro_version(), but from the headers used at
// application compile time, rather than from the library linked against at
// application run time.
const MICRO_VERSION = 1

// MINOR_VERSION: like gtk_get_minor_version(), but from the headers used at
// application compile time, rather than from the library linked against at
// application run time.
const MINOR_VERSION = 2

// PAPER_NAME_A3: name for the A3 paper size.
const PAPER_NAME_A3 = "iso_a3"

// PAPER_NAME_A4: name for the A4 paper size.
const PAPER_NAME_A4 = "iso_a4"

// PAPER_NAME_A5: name for the A5 paper size.
const PAPER_NAME_A5 = "iso_a5"

// PAPER_NAME_B5: name for the B5 paper size.
const PAPER_NAME_B5 = "iso_b5"

// PAPER_NAME_EXECUTIVE: name for the Executive paper size.
const PAPER_NAME_EXECUTIVE = "na_executive"

// PAPER_NAME_LEGAL: name for the Legal paper size.
const PAPER_NAME_LEGAL = "na_legal"

// PAPER_NAME_LETTER: name for the Letter paper size.
const PAPER_NAME_LETTER = "na_letter"
const PRINT_SETTINGS_COLLATE = "collate"
const PRINT_SETTINGS_DEFAULT_SOURCE = "default-source"
const PRINT_SETTINGS_DITHER = "dither"
const PRINT_SETTINGS_DUPLEX = "duplex"
const PRINT_SETTINGS_FINISHINGS = "finishings"
const PRINT_SETTINGS_MEDIA_TYPE = "media-type"
const PRINT_SETTINGS_NUMBER_UP = "number-up"
const PRINT_SETTINGS_NUMBER_UP_LAYOUT = "number-up-layout"
const PRINT_SETTINGS_N_COPIES = "n-copies"
const PRINT_SETTINGS_ORIENTATION = "orientation"

// PRINT_SETTINGS_OUTPUT_BASENAME: key used by the “Print to file” printer to
// store the file name of the output without the path to the directory and the
// file extension.
const PRINT_SETTINGS_OUTPUT_BASENAME = "output-basename"
const PRINT_SETTINGS_OUTPUT_BIN = "output-bin"

// PRINT_SETTINGS_OUTPUT_DIR: key used by the “Print to file” printer to store
// the directory to which the output should be written.
const PRINT_SETTINGS_OUTPUT_DIR = "output-dir"

// PRINT_SETTINGS_OUTPUT_FILE_FORMAT: key used by the “Print to file” printer to
// store the format of the output. The supported values are “PS” and “PDF”.
const PRINT_SETTINGS_OUTPUT_FILE_FORMAT = "output-file-format"

// PRINT_SETTINGS_OUTPUT_URI: key used by the “Print to file” printer to store
// the URI to which the output should be written. GTK itself supports only
// “file://” URIs.
const PRINT_SETTINGS_OUTPUT_URI = "output-uri"
const PRINT_SETTINGS_PAGE_RANGES = "page-ranges"
const PRINT_SETTINGS_PAGE_SET = "page-set"
const PRINT_SETTINGS_PAPER_FORMAT = "paper-format"
const PRINT_SETTINGS_PAPER_HEIGHT = "paper-height"
const PRINT_SETTINGS_PAPER_WIDTH = "paper-width"
const PRINT_SETTINGS_PRINTER = "printer"
const PRINT_SETTINGS_PRINTER_LPI = "printer-lpi"
const PRINT_SETTINGS_PRINT_PAGES = "print-pages"
const PRINT_SETTINGS_QUALITY = "quality"
const PRINT_SETTINGS_RESOLUTION = "resolution"
const PRINT_SETTINGS_RESOLUTION_X = "resolution-x"
const PRINT_SETTINGS_RESOLUTION_Y = "resolution-y"
const PRINT_SETTINGS_REVERSE = "reverse"
const PRINT_SETTINGS_SCALE = "scale"
const PRINT_SETTINGS_USE_COLOR = "use-color"
const PRINT_SETTINGS_WIN32_DRIVER_EXTRA = "win32-driver-extra"
const PRINT_SETTINGS_WIN32_DRIVER_VERSION = "win32-driver-version"

// PRIORITY_RESIZE: use this priority for functionality related to size
// allocation.
//
// It is used internally by GTK+ to compute the sizes of widgets. This priority
// is higher than GDK_PRIORITY_REDRAW to avoid resizing a widget which was just
// redrawn.
const PRIORITY_RESIZE = 110

// STYLE_PROVIDER_PRIORITY_APPLICATION: priority that can be used when adding a
// GtkStyleProvider for application-specific style information.
const STYLE_PROVIDER_PRIORITY_APPLICATION = 600

// STYLE_PROVIDER_PRIORITY_FALLBACK: priority used for default style information
// that is used in the absence of themes.
//
// Note that this is not very useful for providing default styling for custom
// style classes - themes are likely to override styling provided at this
// priority with catch-all * {...} rules.
const STYLE_PROVIDER_PRIORITY_FALLBACK = 1

// STYLE_PROVIDER_PRIORITY_SETTINGS: priority used for style information
// provided via GtkSettings.
//
// This priority is higher than K_STYLE_PROVIDER_PRIORITY_THEME to let settings
// override themes.
const STYLE_PROVIDER_PRIORITY_SETTINGS = 400

// STYLE_PROVIDER_PRIORITY_THEME: priority used for style information provided
// by themes.
const STYLE_PROVIDER_PRIORITY_THEME = 200

// STYLE_PROVIDER_PRIORITY_USER: priority used for the style information from
// $XDG_CONFIG_HOME/gtk-4.0/gtk.css.
//
// You should not use priorities higher than this, to give the user the last
// word.
const STYLE_PROVIDER_PRIORITY_USER = 800

// TEXT_VIEW_PRIORITY_VALIDATE: priority at which the text view validates
// onscreen lines in an idle job in the background.
const TEXT_VIEW_PRIORITY_VALIDATE = 125

// TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID uses the default sort function in a
// gtk.TreeSortable.
//
// See also: gtk.TreeSortable.SetSortColumnID().
const TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -1

// TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID disables sorting in a gtk.TreeSortable.
//
// See also: gtk.TreeSortable.SetSortColumnID().
const TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID = -2

// Allocation: rectangle representing the area allocated for a widget by its
// parent.
type Allocation = gdk.Rectangle

// AccessibleAutocomplete: possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
type AccessibleAutocomplete C.gint

const (
	// AccessibleAutocompleteNone: automatic suggestions are not displayed.
	AccessibleAutocompleteNone AccessibleAutocomplete = iota
	// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
	AccessibleAutocompleteInline
	// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
	AccessibleAutocompleteList
	// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided
	// input may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
	AccessibleAutocompleteBoth
)

func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
	return AccessibleAutocomplete(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleAutocomplete.
func (a AccessibleAutocomplete) String() string {
	switch a {
	case AccessibleAutocompleteNone:
		return "None"
	case AccessibleAutocompleteInline:
		return "Inline"
	case AccessibleAutocompleteList:
		return "List"
	case AccessibleAutocompleteBoth:
		return "Both"
	default:
		return fmt.Sprintf("AccessibleAutocomplete(%d)", a)
	}
}

// AccessibleInvalidState: possible values for the GTK_ACCESSIBLE_STATE_INVALID
// accessible state.
//
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as FALSE and TRUE.
type AccessibleInvalidState C.gint

const (
	// AccessibleInvalidFalse: there are no detected errors in the value.
	AccessibleInvalidFalse AccessibleInvalidState = iota
	// AccessibleInvalidTrue: value entered by the user has failed validation.
	AccessibleInvalidTrue
	// AccessibleInvalidGrammar: grammatical error was detected.
	AccessibleInvalidGrammar
	// AccessibleInvalidSpelling: spelling error was detected.
	AccessibleInvalidSpelling
)

func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
	return AccessibleInvalidState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleInvalidState.
func (a AccessibleInvalidState) String() string {
	switch a {
	case AccessibleInvalidFalse:
		return "False"
	case AccessibleInvalidTrue:
		return "True"
	case AccessibleInvalidGrammar:
		return "Grammar"
	case AccessibleInvalidSpelling:
		return "Spelling"
	default:
		return fmt.Sprintf("AccessibleInvalidState(%d)", a)
	}
}

// AccessibleProperty: possible accessible properties of a GtkAccessible.
type AccessibleProperty C.gint

const (
	// AccessiblePropertyAutocomplete indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete.
	AccessiblePropertyAutocomplete AccessibleProperty = iota
	// AccessiblePropertyDescription defines a string value that describes or
	// annotates the current element. Value type: string.
	AccessiblePropertyDescription
	// AccessiblePropertyHasPopup indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
	AccessiblePropertyHasPopup
	// AccessiblePropertyKeyShortcuts indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string.
	AccessiblePropertyKeyShortcuts
	// AccessiblePropertyLabel defines a string value that labels the current
	// element. Value type: string.
	AccessiblePropertyLabel
	// AccessiblePropertyLevel defines the hierarchical level of an element
	// within a structure. Value type: integer.
	AccessiblePropertyLevel
	// AccessiblePropertyModal indicates whether an element is modal when
	// displayed. Value type: boolean.
	AccessiblePropertyModal
	// AccessiblePropertyMultiLine indicates whether a text box accepts multiple
	// lines of input or only a single line. Value type: boolean.
	AccessiblePropertyMultiLine
	// AccessiblePropertyMultiSelectable indicates that the user may select
	// more than one item from the current selectable descendants. Value type:
	// boolean.
	AccessiblePropertyMultiSelectable
	// AccessiblePropertyOrientation indicates whether the element's orientation
	// is horizontal, vertical, or unknown/ambiguous. Value type: Orientation.
	AccessiblePropertyOrientation
	// AccessiblePropertyPlaceholder defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has
	// no value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string.
	AccessiblePropertyPlaceholder
	// AccessiblePropertyReadOnly indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean.
	AccessiblePropertyReadOnly
	// AccessiblePropertyRequired indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean.
	AccessiblePropertyRequired
	// AccessiblePropertyRoleDescription defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string.
	AccessiblePropertyRoleDescription
	// AccessiblePropertySort indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort.
	AccessiblePropertySort
	// AccessiblePropertyValueMax defines the maximum allowed value for a range
	// widget. Value type: double.
	AccessiblePropertyValueMax
	// AccessiblePropertyValueMin defines the minimum allowed value for a range
	// widget. Value type: double.
	AccessiblePropertyValueMin
	// AccessiblePropertyValueNow defines the current value for a range widget.
	// Value type: double.
	AccessiblePropertyValueNow
	// AccessiblePropertyValueText defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string.
	AccessiblePropertyValueText
)

func marshalAccessibleProperty(p uintptr) (interface{}, error) {
	return AccessibleProperty(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleProperty.
func (a AccessibleProperty) String() string {
	switch a {
	case AccessiblePropertyAutocomplete:
		return "Autocomplete"
	case AccessiblePropertyDescription:
		return "Description"
	case AccessiblePropertyHasPopup:
		return "HasPopup"
	case AccessiblePropertyKeyShortcuts:
		return "KeyShortcuts"
	case AccessiblePropertyLabel:
		return "Label"
	case AccessiblePropertyLevel:
		return "Level"
	case AccessiblePropertyModal:
		return "Modal"
	case AccessiblePropertyMultiLine:
		return "MultiLine"
	case AccessiblePropertyMultiSelectable:
		return "MultiSelectable"
	case AccessiblePropertyOrientation:
		return "Orientation"
	case AccessiblePropertyPlaceholder:
		return "Placeholder"
	case AccessiblePropertyReadOnly:
		return "ReadOnly"
	case AccessiblePropertyRequired:
		return "Required"
	case AccessiblePropertyRoleDescription:
		return "RoleDescription"
	case AccessiblePropertySort:
		return "Sort"
	case AccessiblePropertyValueMax:
		return "ValueMax"
	case AccessiblePropertyValueMin:
		return "ValueMin"
	case AccessiblePropertyValueNow:
		return "ValueNow"
	case AccessiblePropertyValueText:
		return "ValueText"
	default:
		return fmt.Sprintf("AccessibleProperty(%d)", a)
	}
}

// The function takes the following parameters:
//
//   - property
//   - value
func AccessiblePropertyInitValue(property AccessibleProperty, value *coreglib.Value) {
	var _arg1 C.GtkAccessibleProperty // out
	var _arg2 *C.GValue               // out

	_arg1 = C.GtkAccessibleProperty(property)
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_accessible_property_init_value(_arg1, _arg2)
	runtime.KeepAlive(property)
	runtime.KeepAlive(value)
}

// AccessibleRelation: possible accessible relations of a GtkAccessible.
//
// Accessible relations can be references to other widgets, integers or strings.
type AccessibleRelation C.gint

const (
	// AccessibleRelationActiveDescendant identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group,
	// or application. Value type: reference.
	AccessibleRelationActiveDescendant AccessibleRelation = iota
	// AccessibleRelationColCount defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer.
	AccessibleRelationColCount
	// AccessibleRelationColIndex defines an element's column index or position
	// with respect to the total number of columns within a table, grid,
	// or treegrid. Value type: integer.
	AccessibleRelationColIndex
	// AccessibleRelationColIndexText defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string.
	AccessibleRelationColIndexText
	// AccessibleRelationColSpan defines the number of columns spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer.
	AccessibleRelationColSpan
	// AccessibleRelationControls identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference.
	AccessibleRelationControls
	// AccessibleRelationDescribedBy identifies the element (or elements) that
	// describes the object. Value type: reference.
	AccessibleRelationDescribedBy
	// AccessibleRelationDetails identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference.
	AccessibleRelationDetails
	// AccessibleRelationErrorMessage identifies the element that provides an
	// error message for an object. Value type: reference.
	AccessibleRelationErrorMessage
	// AccessibleRelationFlowTo identifies the next element (or elements) in
	// an alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference.
	AccessibleRelationFlowTo
	// AccessibleRelationLabelledBy identifies the element (or elements) that
	// labels the current element. Value type: reference.
	AccessibleRelationLabelledBy
	// AccessibleRelationOwns identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference.
	AccessibleRelationOwns
	// AccessibleRelationPosInSet defines an element's number or position in the
	// current set of listitems or treeitems. Value type: integer.
	AccessibleRelationPosInSet
	// AccessibleRelationRowCount defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer.
	AccessibleRelationRowCount
	// AccessibleRelationRowIndex defines an element's row index or position
	// with respect to the total number of rows within a table, grid,
	// or treegrid. Value type: integer.
	AccessibleRelationRowIndex
	// AccessibleRelationRowIndexText defines a human readable text alternative
	// of aria-rowindex. Value type: string.
	AccessibleRelationRowIndexText
	// AccessibleRelationRowSpan defines the number of rows spanned by a cell or
	// gridcell within a table, grid, or treegrid. Value type: integer.
	AccessibleRelationRowSpan
	// AccessibleRelationSetSize defines the number of items in the current set
	// of listitems or treeitems. Value type: integer.
	AccessibleRelationSetSize
)

func marshalAccessibleRelation(p uintptr) (interface{}, error) {
	return AccessibleRelation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleRelation.
func (a AccessibleRelation) String() string {
	switch a {
	case AccessibleRelationActiveDescendant:
		return "ActiveDescendant"
	case AccessibleRelationColCount:
		return "ColCount"
	case AccessibleRelationColIndex:
		return "ColIndex"
	case AccessibleRelationColIndexText:
		return "ColIndexText"
	case AccessibleRelationColSpan:
		return "ColSpan"
	case AccessibleRelationControls:
		return "Controls"
	case AccessibleRelationDescribedBy:
		return "DescribedBy"
	case AccessibleRelationDetails:
		return "Details"
	case AccessibleRelationErrorMessage:
		return "ErrorMessage"
	case AccessibleRelationFlowTo:
		return "FlowTo"
	case AccessibleRelationLabelledBy:
		return "LabelledBy"
	case AccessibleRelationOwns:
		return "Owns"
	case AccessibleRelationPosInSet:
		return "PosInSet"
	case AccessibleRelationRowCount:
		return "RowCount"
	case AccessibleRelationRowIndex:
		return "RowIndex"
	case AccessibleRelationRowIndexText:
		return "RowIndexText"
	case AccessibleRelationRowSpan:
		return "RowSpan"
	case AccessibleRelationSetSize:
		return "SetSize"
	default:
		return fmt.Sprintf("AccessibleRelation(%d)", a)
	}
}

// The function takes the following parameters:
//
//   - relation
//   - value
func AccessibleRelationInitValue(relation AccessibleRelation, value *coreglib.Value) {
	var _arg1 C.GtkAccessibleRelation // out
	var _arg2 *C.GValue               // out

	_arg1 = C.GtkAccessibleRelation(relation)
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_accessible_relation_init_value(_arg1, _arg2)
	runtime.KeepAlive(relation)
	runtime.KeepAlive(value)
}

// AccessibleRole: accessible role for a GtkAccessible implementation.
//
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
type AccessibleRole C.gint

const (
	// AccessibleRoleAlert: element with important, and usually time-sensitive,
	// information.
	AccessibleRoleAlert AccessibleRole = iota
	// AccessibleRoleAlertDialog: type of dialog that contains an alert message.
	AccessibleRoleAlertDialog
	// AccessibleRoleBanner: unused.
	AccessibleRoleBanner
	// AccessibleRoleButton: input element that allows for user-triggered
	// actions when clicked or pressed.
	AccessibleRoleButton
	// AccessibleRoleCaption: unused.
	AccessibleRoleCaption
	// AccessibleRoleCell: unused.
	AccessibleRoleCell
	// AccessibleRoleCheckbox: checkable input element that has three possible
	// values: true, false, or mixed.
	AccessibleRoleCheckbox
	// AccessibleRoleColumnHeader: header in a columned list.
	AccessibleRoleColumnHeader
	// AccessibleRoleComboBox: input that controls another element, such as
	// a list or a grid, that can dynamically pop up to help the user set the
	// value of the input.
	AccessibleRoleComboBox
	// AccessibleRoleCommand: abstract role.
	AccessibleRoleCommand
	// AccessibleRoleComposite: abstract role.
	AccessibleRoleComposite
	// AccessibleRoleDialog: dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
	AccessibleRoleDialog
	// AccessibleRoleDocument: unused.
	AccessibleRoleDocument
	// AccessibleRoleFeed: unused.
	AccessibleRoleFeed
	// AccessibleRoleForm: unused.
	AccessibleRoleForm
	// AccessibleRoleGeneric: unused.
	AccessibleRoleGeneric
	// AccessibleRoleGrid: grid of items.
	AccessibleRoleGrid
	// AccessibleRoleGridCell: item in a grid or tree grid.
	AccessibleRoleGridCell
	// AccessibleRoleGroup: element that groups multiple widgets. GTK uses this
	// role for various containers, like Box, Viewport, and HeaderBar.
	AccessibleRoleGroup
	// AccessibleRoleHeading: unused.
	AccessibleRoleHeading
	// AccessibleRoleImg: image.
	AccessibleRoleImg
	// AccessibleRoleInput: abstract role.
	AccessibleRoleInput
	// AccessibleRoleLabel: visible name or caption for a user interface
	// component.
	AccessibleRoleLabel
	// AccessibleRoleLandmark: abstract role.
	AccessibleRoleLandmark
	// AccessibleRoleLegend: unused.
	AccessibleRoleLegend
	// AccessibleRoleLink: clickable link.
	AccessibleRoleLink
	// AccessibleRoleList: list of items.
	AccessibleRoleList
	// AccessibleRoleListBox: unused.
	AccessibleRoleListBox
	// AccessibleRoleListItem: item in a list.
	AccessibleRoleListItem
	// AccessibleRoleLog: unused.
	AccessibleRoleLog
	// AccessibleRoleMain: unused.
	AccessibleRoleMain
	// AccessibleRoleMarquee: unused.
	AccessibleRoleMarquee
	// AccessibleRoleMath: unused.
	AccessibleRoleMath
	// AccessibleRoleMeter: element that represents a value within a known
	// range.
	AccessibleRoleMeter
	// AccessibleRoleMenu: menu.
	AccessibleRoleMenu
	// AccessibleRoleMenuBar: menubar.
	AccessibleRoleMenuBar
	// AccessibleRoleMenuItem: item in a menu.
	AccessibleRoleMenuItem
	// AccessibleRoleMenuItemCheckbox: check item in a menu.
	AccessibleRoleMenuItemCheckbox
	// AccessibleRoleMenuItemRadio: radio item in a menu.
	AccessibleRoleMenuItemRadio
	// AccessibleRoleNavigation: unused.
	AccessibleRoleNavigation
	// AccessibleRoleNone: element that is not represented to accessibility
	// technologies.
	AccessibleRoleNone
	// AccessibleRoleNote: unused.
	AccessibleRoleNote
	// AccessibleRoleOption: unused.
	AccessibleRoleOption
	// AccessibleRolePresentation: element that is not represented to
	// accessibility technologies.
	AccessibleRolePresentation
	// AccessibleRoleProgressBar: element that displays the progress status for
	// tasks that take a long time.
	AccessibleRoleProgressBar
	// AccessibleRoleRadio: checkable input in a group of radio roles, only one
	// of which can be checked at a time.
	AccessibleRoleRadio
	// AccessibleRoleRadioGroup: unused.
	AccessibleRoleRadioGroup
	// AccessibleRoleRange: abstract role.
	AccessibleRoleRange
	// AccessibleRoleRegion: unused.
	AccessibleRoleRegion
	// AccessibleRoleRow: row in a columned list.
	AccessibleRoleRow
	// AccessibleRoleRowGroup: unused.
	AccessibleRoleRowGroup
	// AccessibleRoleRowHeader: unused.
	AccessibleRoleRowHeader
	// AccessibleRoleScrollbar: graphical object that controls the scrolling of
	// content within a viewing area, regardless of whether the content is fully
	// displayed within the viewing area.
	AccessibleRoleScrollbar
	// AccessibleRoleSearch: unused.
	AccessibleRoleSearch
	// AccessibleRoleSearchBox: type of textbox intended for specifying search
	// criteria.
	AccessibleRoleSearchBox
	// AccessibleRoleSection: abstract role.
	AccessibleRoleSection
	// AccessibleRoleSectionHead: abstract role.
	AccessibleRoleSectionHead
	// AccessibleRoleSelect: abstract role.
	AccessibleRoleSelect
	// AccessibleRoleSeparator: divider that separates and distinguishes
	// sections of content or groups of menuitems.
	AccessibleRoleSeparator
	// AccessibleRoleSlider: user input where the user selects a value from
	// within a given range.
	AccessibleRoleSlider
	// AccessibleRoleSpinButton: form of range that expects the user to select
	// from among discrete choices.
	AccessibleRoleSpinButton
	// AccessibleRoleStatus: unused.
	AccessibleRoleStatus
	// AccessibleRoleStructure: abstract role.
	AccessibleRoleStructure
	// AccessibleRoleSwitch: type of checkbox that represents on/off values,
	// as opposed to checked/unchecked values.
	AccessibleRoleSwitch
	// AccessibleRoleTab: item in a list of tab used for switching pages.
	AccessibleRoleTab
	// AccessibleRoleTable: unused.
	AccessibleRoleTable
	// AccessibleRoleTabList: list of tabs for switching pages.
	AccessibleRoleTabList
	// AccessibleRoleTabPanel: page in a notebook or stack.
	AccessibleRoleTabPanel
	// AccessibleRoleTextBox: type of input that allows free-form text as its
	// value.
	AccessibleRoleTextBox
	// AccessibleRoleTime: unused.
	AccessibleRoleTime
	// AccessibleRoleTimer: unused.
	AccessibleRoleTimer
	// AccessibleRoleToolbar: unused.
	AccessibleRoleToolbar
	// AccessibleRoleTooltip: unused.
	AccessibleRoleTooltip
	// AccessibleRoleTree: unused.
	AccessibleRoleTree
	// AccessibleRoleTreeGrid: treeview-like, columned list.
	AccessibleRoleTreeGrid
	// AccessibleRoleTreeItem: unused.
	AccessibleRoleTreeItem
	// AccessibleRoleWidget: interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
	AccessibleRoleWidget
	// AccessibleRoleWindow: application window.
	AccessibleRoleWindow
)

func marshalAccessibleRole(p uintptr) (interface{}, error) {
	return AccessibleRole(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleRole.
func (a AccessibleRole) String() string {
	switch a {
	case AccessibleRoleAlert:
		return "Alert"
	case AccessibleRoleAlertDialog:
		return "AlertDialog"
	case AccessibleRoleBanner:
		return "Banner"
	case AccessibleRoleButton:
		return "Button"
	case AccessibleRoleCaption:
		return "Caption"
	case AccessibleRoleCell:
		return "Cell"
	case AccessibleRoleCheckbox:
		return "Checkbox"
	case AccessibleRoleColumnHeader:
		return "ColumnHeader"
	case AccessibleRoleComboBox:
		return "ComboBox"
	case AccessibleRoleCommand:
		return "Command"
	case AccessibleRoleComposite:
		return "Composite"
	case AccessibleRoleDialog:
		return "Dialog"
	case AccessibleRoleDocument:
		return "Document"
	case AccessibleRoleFeed:
		return "Feed"
	case AccessibleRoleForm:
		return "Form"
	case AccessibleRoleGeneric:
		return "Generic"
	case AccessibleRoleGrid:
		return "Grid"
	case AccessibleRoleGridCell:
		return "GridCell"
	case AccessibleRoleGroup:
		return "Group"
	case AccessibleRoleHeading:
		return "Heading"
	case AccessibleRoleImg:
		return "Img"
	case AccessibleRoleInput:
		return "Input"
	case AccessibleRoleLabel:
		return "Label"
	case AccessibleRoleLandmark:
		return "Landmark"
	case AccessibleRoleLegend:
		return "Legend"
	case AccessibleRoleLink:
		return "Link"
	case AccessibleRoleList:
		return "List"
	case AccessibleRoleListBox:
		return "ListBox"
	case AccessibleRoleListItem:
		return "ListItem"
	case AccessibleRoleLog:
		return "Log"
	case AccessibleRoleMain:
		return "Main"
	case AccessibleRoleMarquee:
		return "Marquee"
	case AccessibleRoleMath:
		return "Math"
	case AccessibleRoleMeter:
		return "Meter"
	case AccessibleRoleMenu:
		return "Menu"
	case AccessibleRoleMenuBar:
		return "MenuBar"
	case AccessibleRoleMenuItem:
		return "MenuItem"
	case AccessibleRoleMenuItemCheckbox:
		return "MenuItemCheckbox"
	case AccessibleRoleMenuItemRadio:
		return "MenuItemRadio"
	case AccessibleRoleNavigation:
		return "Navigation"
	case AccessibleRoleNone:
		return "None"
	case AccessibleRoleNote:
		return "Note"
	case AccessibleRoleOption:
		return "Option"
	case AccessibleRolePresentation:
		return "Presentation"
	case AccessibleRoleProgressBar:
		return "ProgressBar"
	case AccessibleRoleRadio:
		return "Radio"
	case AccessibleRoleRadioGroup:
		return "RadioGroup"
	case AccessibleRoleRange:
		return "Range"
	case AccessibleRoleRegion:
		return "Region"
	case AccessibleRoleRow:
		return "Row"
	case AccessibleRoleRowGroup:
		return "RowGroup"
	case AccessibleRoleRowHeader:
		return "RowHeader"
	case AccessibleRoleScrollbar:
		return "Scrollbar"
	case AccessibleRoleSearch:
		return "Search"
	case AccessibleRoleSearchBox:
		return "SearchBox"
	case AccessibleRoleSection:
		return "Section"
	case AccessibleRoleSectionHead:
		return "SectionHead"
	case AccessibleRoleSelect:
		return "Select"
	case AccessibleRoleSeparator:
		return "Separator"
	case AccessibleRoleSlider:
		return "Slider"
	case AccessibleRoleSpinButton:
		return "SpinButton"
	case AccessibleRoleStatus:
		return "Status"
	case AccessibleRoleStructure:
		return "Structure"
	case AccessibleRoleSwitch:
		return "Switch"
	case AccessibleRoleTab:
		return "Tab"
	case AccessibleRoleTable:
		return "Table"
	case AccessibleRoleTabList:
		return "TabList"
	case AccessibleRoleTabPanel:
		return "TabPanel"
	case AccessibleRoleTextBox:
		return "TextBox"
	case AccessibleRoleTime:
		return "Time"
	case AccessibleRoleTimer:
		return "Timer"
	case AccessibleRoleToolbar:
		return "Toolbar"
	case AccessibleRoleTooltip:
		return "Tooltip"
	case AccessibleRoleTree:
		return "Tree"
	case AccessibleRoleTreeGrid:
		return "TreeGrid"
	case AccessibleRoleTreeItem:
		return "TreeItem"
	case AccessibleRoleWidget:
		return "Widget"
	case AccessibleRoleWindow:
		return "Window"
	default:
		return fmt.Sprintf("AccessibleRole(%d)", a)
	}
}

// AccessibleSort: possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
type AccessibleSort C.gint

const (
	// AccessibleSortNone: there is no defined sort applied to the column.
	AccessibleSortNone AccessibleSort = iota
	// AccessibleSortAscending items are sorted in ascending order by this
	// column.
	AccessibleSortAscending
	// AccessibleSortDescending items are sorted in descending order by this
	// column.
	AccessibleSortDescending
	// AccessibleSortOther: sort algorithm other than ascending or descending
	// has been applied.
	AccessibleSortOther
)

func marshalAccessibleSort(p uintptr) (interface{}, error) {
	return AccessibleSort(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleSort.
func (a AccessibleSort) String() string {
	switch a {
	case AccessibleSortNone:
		return "None"
	case AccessibleSortAscending:
		return "Ascending"
	case AccessibleSortDescending:
		return "Descending"
	case AccessibleSortOther:
		return "Other"
	default:
		return fmt.Sprintf("AccessibleSort(%d)", a)
	}
}

// AccessibleState: possible accessible states of a GtkAccessible.
type AccessibleState C.gint

const (
	// AccessibleStateBusy: “busy” state. This state has boolean values.
	AccessibleStateBusy AccessibleState = iota
	// AccessibleStateChecked: “checked” state; indicates the current state of a
	// CheckButton. Value type: AccessibleTristate.
	AccessibleStateChecked
	// AccessibleStateDisabled: “disabled” state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean.
	AccessibleStateDisabled
	// AccessibleStateExpanded: “expanded” state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined.
	AccessibleStateExpanded
	// AccessibleStateHidden: “hidden” state; corresponds to the Widget:visible
	// property on Widget. You can use this state explicitly on UI elements that
	// should not be exposed to an assistive technology. Value type: boolean See
	// also: GTK_ACCESSIBLE_STATE_DISABLED.
	AccessibleStateHidden
	// AccessibleStateInvalid: “invalid” state; set when a widget is showing an
	// error. Value type: AccessibleInvalidState.
	AccessibleStateInvalid
	// AccessibleStatePressed: “pressed” state; indicates the current state of a
	// ToggleButton. Value type: AccessibleTristate enumeration.
	AccessibleStatePressed
	// AccessibleStateSelected: “selected” state; set when a widget is selected.
	// Value type: boolean or undefined.
	AccessibleStateSelected
)

func marshalAccessibleState(p uintptr) (interface{}, error) {
	return AccessibleState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleState.
func (a AccessibleState) String() string {
	switch a {
	case AccessibleStateBusy:
		return "Busy"
	case AccessibleStateChecked:
		return "Checked"
	case AccessibleStateDisabled:
		return "Disabled"
	case AccessibleStateExpanded:
		return "Expanded"
	case AccessibleStateHidden:
		return "Hidden"
	case AccessibleStateInvalid:
		return "Invalid"
	case AccessibleStatePressed:
		return "Pressed"
	case AccessibleStateSelected:
		return "Selected"
	default:
		return fmt.Sprintf("AccessibleState(%d)", a)
	}
}

// The function takes the following parameters:
//
//   - state
//   - value
func AccessibleStateInitValue(state AccessibleState, value *coreglib.Value) {
	var _arg1 C.GtkAccessibleState // out
	var _arg2 *C.GValue            // out

	_arg1 = C.GtkAccessibleState(state)
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_accessible_state_init_value(_arg1, _arg2)
	runtime.KeepAlive(state)
	runtime.KeepAlive(value)
}

// AccessibleTristate: possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
//
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as FALSE and TRUE.
type AccessibleTristate C.gint

const (
	// AccessibleTristateFalse: state is false.
	AccessibleTristateFalse AccessibleTristate = iota
	// AccessibleTristateTrue: state is true.
	AccessibleTristateTrue
	// AccessibleTristateMixed: state is mixed.
	AccessibleTristateMixed
)

func marshalAccessibleTristate(p uintptr) (interface{}, error) {
	return AccessibleTristate(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleTristate.
func (a AccessibleTristate) String() string {
	switch a {
	case AccessibleTristateFalse:
		return "False"
	case AccessibleTristateTrue:
		return "True"
	case AccessibleTristateMixed:
		return "Mixed"
	default:
		return fmt.Sprintf("AccessibleTristate(%d)", a)
	}
}

// Align controls how a widget deals with extra space in a single dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the gtk.Widget:hexpand property inside
// a GtkBox, then the widget might get extra space. If you have for example a
// 16x16 icon inside a 32x32 space, the icon could be scaled and stretched,
// it could be centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
type Align C.gint

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch.
	AlignFill Align = iota
	// AlignStart: snap to left or top side, leaving space on right or bottom.
	AlignStart
	// AlignEnd: snap to right or bottom side, leaving space on left or top.
	AlignEnd
	// AlignCenter: center natural width of widget inside the allocation.
	AlignCenter
	// AlignBaseline: align the widget according to the baseline. See Widget.
	AlignBaseline
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Align.
func (a Align) String() string {
	switch a {
	case AlignFill:
		return "Fill"
	case AlignStart:
		return "Start"
	case AlignEnd:
		return "End"
	case AlignCenter:
		return "Center"
	case AlignBaseline:
		return "Baseline"
	default:
		return fmt.Sprintf("Align(%d)", a)
	}
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType C.gint

const (
	// ArrowUp represents an upward pointing arrow.
	ArrowUp ArrowType = iota
	// ArrowDown represents a downward pointing arrow.
	ArrowDown
	// ArrowLeft represents a left pointing arrow.
	ArrowLeft
	// ArrowRight represents a right pointing arrow.
	ArrowRight
	// ArrowNone: no arrow.
	ArrowNone
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ArrowType.
func (a ArrowType) String() string {
	switch a {
	case ArrowUp:
		return "Up"
	case ArrowDown:
		return "Down"
	case ArrowLeft:
		return "Left"
	case ArrowRight:
		return "Right"
	case ArrowNone:
		return "None"
	default:
		return fmt.Sprintf("ArrowType(%d)", a)
	}
}

// AssistantPageType determines the page role inside a GtkAssistant.
//
// The role is used to handle buttons sensitivity and visibility.
//
// Note that an assistant needs to end its page flow with a page of
// type GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
//
// The Cancel button will only be shown if the page isn’t “committed”. See
// gtk_assistant_commit() for details.
type AssistantPageType C.gint

const (
	// AssistantPageContent: page has regular contents. Both the Back and
	// forward buttons will be shown.
	AssistantPageContent AssistantPageType = iota
	// AssistantPageIntro: page contains an introduction to the assistant task.
	// Only the Forward button will be shown if there is a next page.
	AssistantPageIntro
	// AssistantPageConfirm: page lets the user confirm or deny the changes.
	// The Back and Apply buttons will be shown.
	AssistantPageConfirm
	// AssistantPageSummary: page informs the user of the changes done. Only the
	// Close button will be shown.
	AssistantPageSummary
	// AssistantPageProgress: used for tasks that take a long time to complete,
	// blocks the assistant until the page is marked as complete. Only the back
	// button will be shown.
	AssistantPageProgress
	// AssistantPageCustom: used for when other page types are not appropriate.
	// No buttons will be shown, and the application must add its own buttons
	// through gtk_assistant_add_action_widget().
	AssistantPageCustom
)

func marshalAssistantPageType(p uintptr) (interface{}, error) {
	return AssistantPageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AssistantPageType.
func (a AssistantPageType) String() string {
	switch a {
	case AssistantPageContent:
		return "Content"
	case AssistantPageIntro:
		return "Intro"
	case AssistantPageConfirm:
		return "Confirm"
	case AssistantPageSummary:
		return "Summary"
	case AssistantPageProgress:
		return "Progress"
	case AssistantPageCustom:
		return "Custom"
	default:
		return fmt.Sprintf("AssistantPageType(%d)", a)
	}
}

// BaselinePosition: baseline position in a row of widgets.
//
// Whenever a container has some form of natural row it may align children
// in that row along a common typographical baseline. If the amount of
// vertical space in the row is taller than the total requested height of the
// baseline-aligned children then it can use a GtkBaselinePosition to select
// where to put the baseline inside the extra available space.
type BaselinePosition C.gint

const (
	// BaselinePositionTop: align the baseline at the top.
	BaselinePositionTop BaselinePosition = iota
	// BaselinePositionCenter: center the baseline.
	BaselinePositionCenter
	// BaselinePositionBottom: align the baseline at the bottom.
	BaselinePositionBottom
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BaselinePosition.
func (b BaselinePosition) String() string {
	switch b {
	case BaselinePositionTop:
		return "Top"
	case BaselinePositionCenter:
		return "Center"
	case BaselinePositionBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("BaselinePosition(%d)", b)
	}
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle C.gint

const (
	// BorderStyleNone: no visible border.
	BorderStyleNone BorderStyle = iota
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE.
	BorderStyleHidden
	// BorderStyleSolid: single line segment.
	BorderStyleSolid
	// BorderStyleInset looks as if the content is sunken into the canvas.
	BorderStyleInset
	// BorderStyleOutset looks as if the content is coming out of the canvas.
	BorderStyleOutset
	// BorderStyleDotted series of round dots.
	BorderStyleDotted
	// BorderStyleDashed series of square-ended dashes.
	BorderStyleDashed
	// BorderStyleDouble: two parallel lines with some space between them.
	BorderStyleDouble
	// BorderStyleGroove looks as if it were carved in the canvas.
	BorderStyleGroove
	// BorderStyleRidge looks as if it were coming out of the canvas.
	BorderStyleRidge
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BorderStyle.
func (b BorderStyle) String() string {
	switch b {
	case BorderStyleNone:
		return "None"
	case BorderStyleHidden:
		return "Hidden"
	case BorderStyleSolid:
		return "Solid"
	case BorderStyleInset:
		return "Inset"
	case BorderStyleOutset:
		return "Outset"
	case BorderStyleDotted:
		return "Dotted"
	case BorderStyleDashed:
		return "Dashed"
	case BorderStyleDouble:
		return "Double"
	case BorderStyleGroove:
		return "Groove"
	case BorderStyleRidge:
		return "Ridge"
	default:
		return fmt.Sprintf("BorderStyle(%d)", b)
	}
}

// BuilderError: error codes that identify various errors that can occur while
// using Builder.
type BuilderError C.gint

const (
	// BuilderErrorInvalidTypeFunction: type-func attribute didn’t name a
	// function that returns a #GType.
	BuilderErrorInvalidTypeFunction BuilderError = iota
	// BuilderErrorUnhandledTag: input contained a tag that Builder can’t
	// handle.
	BuilderErrorUnhandledTag
	// BuilderErrorMissingAttribute: attribute that is required by Builder was
	// missing.
	BuilderErrorMissingAttribute
	// BuilderErrorInvalidAttribute found an attribute that it doesn’t
	// understand.
	BuilderErrorInvalidAttribute
	// BuilderErrorInvalidTag found a tag that it doesn’t understand.
	BuilderErrorInvalidTag
	// BuilderErrorMissingPropertyValue: required property value was missing.
	BuilderErrorMissingPropertyValue
	// BuilderErrorInvalidValue couldn’t parse some attribute value.
	BuilderErrorInvalidValue
	// BuilderErrorVersionMismatch: input file requires a newer version of GTK.
	BuilderErrorVersionMismatch
	// BuilderErrorDuplicateID: object id occurred twice.
	BuilderErrorDuplicateID
	// BuilderErrorObjectTypeRefused: specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
	BuilderErrorObjectTypeRefused
	// BuilderErrorTemplateMismatch: wrong type was specified in a composite
	// class’s template XML.
	BuilderErrorTemplateMismatch
	// BuilderErrorInvalidProperty: specified property is unknown for the object
	// class.
	BuilderErrorInvalidProperty
	// BuilderErrorInvalidSignal: specified signal is unknown for the object
	// class.
	BuilderErrorInvalidSignal
	// BuilderErrorInvalidID: object id is unknown.
	BuilderErrorInvalidID
	// BuilderErrorInvalidFunction: function could not be found. This often
	// happens when symbols are set to be kept private. Compiling code with
	// -rdynamic or using the gmodule-export-2.0 pkgconfig module can fix this
	// problem.
	BuilderErrorInvalidFunction
)

func marshalBuilderError(p uintptr) (interface{}, error) {
	return BuilderError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BuilderError.
func (b BuilderError) String() string {
	switch b {
	case BuilderErrorInvalidTypeFunction:
		return "InvalidTypeFunction"
	case BuilderErrorUnhandledTag:
		return "UnhandledTag"
	case BuilderErrorMissingAttribute:
		return "MissingAttribute"
	case BuilderErrorInvalidAttribute:
		return "InvalidAttribute"
	case BuilderErrorInvalidTag:
		return "InvalidTag"
	case BuilderErrorMissingPropertyValue:
		return "MissingPropertyValue"
	case BuilderErrorInvalidValue:
		return "InvalidValue"
	case BuilderErrorVersionMismatch:
		return "VersionMismatch"
	case BuilderErrorDuplicateID:
		return "DuplicateID"
	case BuilderErrorObjectTypeRefused:
		return "ObjectTypeRefused"
	case BuilderErrorTemplateMismatch:
		return "TemplateMismatch"
	case BuilderErrorInvalidProperty:
		return "InvalidProperty"
	case BuilderErrorInvalidSignal:
		return "InvalidSignal"
	case BuilderErrorInvalidID:
		return "InvalidID"
	case BuilderErrorInvalidFunction:
		return "InvalidFunction"
	default:
		return fmt.Sprintf("BuilderError(%d)", b)
	}
}

func BuilderErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_builder_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// ButtonsType: prebuilt sets of buttons for GtkDialog.
//
// If none of these choices are appropriate, simply use GTK_BUTTONS_NONE and
// call gtk.Dialog.AddButtons().
//
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
type ButtonsType C.gint

const (
	// ButtonsNone: no buttons at all.
	ButtonsNone ButtonsType = iota
	// ButtonsOK: OK button.
	ButtonsOK
	// ButtonsClose: close button.
	ButtonsClose
	// ButtonsCancel: cancel button.
	ButtonsCancel
	// ButtonsYesNo yes and No buttons.
	ButtonsYesNo
	// ButtonsOKCancel: OK and Cancel buttons.
	ButtonsOKCancel
)

func marshalButtonsType(p uintptr) (interface{}, error) {
	return ButtonsType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ButtonsType.
func (b ButtonsType) String() string {
	switch b {
	case ButtonsNone:
		return "None"
	case ButtonsOK:
		return "OK"
	case ButtonsClose:
		return "Close"
	case ButtonsCancel:
		return "Cancel"
	case ButtonsYesNo:
		return "YesNo"
	case ButtonsOKCancel:
		return "OKCancel"
	default:
		return fmt.Sprintf("ButtonsType(%d)", b)
	}
}

// CellRendererAccelMode determines if the edited accelerators are GTK
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK are allowed, and the accelerators are rendered
// in the same way as they are in menus.
type CellRendererAccelMode C.gint

const (
	// CellRendererAccelModeGTK: GTK accelerators mode.
	CellRendererAccelModeGTK CellRendererAccelMode = iota
	// CellRendererAccelModeOther: other accelerator mode.
	CellRendererAccelModeOther
)

func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
	return CellRendererAccelMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CellRendererAccelMode.
func (c CellRendererAccelMode) String() string {
	switch c {
	case CellRendererAccelModeGTK:
		return "GTK"
	case CellRendererAccelModeOther:
		return "Other"
	default:
		return fmt.Sprintf("CellRendererAccelMode(%d)", c)
	}
}

// CellRendererMode identifies how the user can interact with a particular cell.
type CellRendererMode C.gint

const (
	// CellRendererModeInert: cell is just for display and cannot be interacted
	// with. Note that this doesn’t mean that eg. the row being drawn can’t be
	// selected -- just that a particular element of it cannot be individually
	// modified.
	CellRendererModeInert CellRendererMode = iota
	// CellRendererModeActivatable: cell can be clicked.
	CellRendererModeActivatable
	// CellRendererModeEditable: cell can be edited or otherwise modified.
	CellRendererModeEditable
)

func marshalCellRendererMode(p uintptr) (interface{}, error) {
	return CellRendererMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CellRendererMode.
func (c CellRendererMode) String() string {
	switch c {
	case CellRendererModeInert:
		return "Inert"
	case CellRendererModeActivatable:
		return "Activatable"
	case CellRendererModeEditable:
		return "Editable"
	default:
		return fmt.Sprintf("CellRendererMode(%d)", c)
	}
}

// ConstraintAttribute: widget attributes that can be used when creating a
// GtkConstraint.
type ConstraintAttribute C.gint

const (
	// ConstraintAttributeNone: no attribute, used for constant relations.
	ConstraintAttributeNone ConstraintAttribute = iota
	// ConstraintAttributeLeft: left edge of a widget, regardless of text
	// direction.
	ConstraintAttributeLeft
	// ConstraintAttributeRight: right edge of a widget, regardless of text
	// direction.
	ConstraintAttributeRight
	// ConstraintAttributeTop: top edge of a widget.
	ConstraintAttributeTop
	// ConstraintAttributeBottom: bottom edge of a widget.
	ConstraintAttributeBottom
	// ConstraintAttributeStart: leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones.
	ConstraintAttributeStart
	// ConstraintAttributeEnd: trailing edge of a widget, depending on
	// text direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones.
	ConstraintAttributeEnd
	// ConstraintAttributeWidth: width of a widget.
	ConstraintAttributeWidth
	// ConstraintAttributeHeight: height of a widget.
	ConstraintAttributeHeight
	// ConstraintAttributeCenterX: center of a widget, on the horizontal axis.
	ConstraintAttributeCenterX
	// ConstraintAttributeCenterY: center of a widget, on the vertical axis.
	ConstraintAttributeCenterY
	// ConstraintAttributeBaseline: baseline of a widget.
	ConstraintAttributeBaseline
)

func marshalConstraintAttribute(p uintptr) (interface{}, error) {
	return ConstraintAttribute(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintAttribute.
func (c ConstraintAttribute) String() string {
	switch c {
	case ConstraintAttributeNone:
		return "None"
	case ConstraintAttributeLeft:
		return "Left"
	case ConstraintAttributeRight:
		return "Right"
	case ConstraintAttributeTop:
		return "Top"
	case ConstraintAttributeBottom:
		return "Bottom"
	case ConstraintAttributeStart:
		return "Start"
	case ConstraintAttributeEnd:
		return "End"
	case ConstraintAttributeWidth:
		return "Width"
	case ConstraintAttributeHeight:
		return "Height"
	case ConstraintAttributeCenterX:
		return "CenterX"
	case ConstraintAttributeCenterY:
		return "CenterY"
	case ConstraintAttributeBaseline:
		return "Baseline"
	default:
		return fmt.Sprintf("ConstraintAttribute(%d)", c)
	}
}

// ConstraintRelation: relation between two terms of a constraint.
type ConstraintRelation C.gint

const (
	// ConstraintRelationLE less than, or equal.
	ConstraintRelationLE ConstraintRelation = -1
	// ConstraintRelationEq: equal.
	ConstraintRelationEq ConstraintRelation = 0
	// ConstraintRelationGE: greater than, or equal.
	ConstraintRelationGE ConstraintRelation = 1
)

func marshalConstraintRelation(p uintptr) (interface{}, error) {
	return ConstraintRelation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintRelation.
func (c ConstraintRelation) String() string {
	switch c {
	case ConstraintRelationLE:
		return "LE"
	case ConstraintRelationEq:
		return "Eq"
	case ConstraintRelationGE:
		return "GE"
	default:
		return fmt.Sprintf("ConstraintRelation(%d)", c)
	}
}

// ConstraintStrength: strength of a constraint, expressed as a symbolic
// constant.
//
// The strength of a Constraint can be expressed with any positive integer;
// the values of this enumeration can be used for readability.
type ConstraintStrength C.gint

const (
	// ConstraintStrengthRequired: constraint is required towards solving the
	// layout.
	ConstraintStrengthRequired ConstraintStrength = 1001001000
	// ConstraintStrengthStrong: strong constraint.
	ConstraintStrengthStrong ConstraintStrength = 1000000000
	// ConstraintStrengthMedium: medium constraint.
	ConstraintStrengthMedium ConstraintStrength = 1000
	// ConstraintStrengthWeak: weak constraint.
	ConstraintStrengthWeak ConstraintStrength = 1
)

func marshalConstraintStrength(p uintptr) (interface{}, error) {
	return ConstraintStrength(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintStrength.
func (c ConstraintStrength) String() string {
	switch c {
	case ConstraintStrengthRequired:
		return "Required"
	case ConstraintStrengthStrong:
		return "Strong"
	case ConstraintStrengthMedium:
		return "Medium"
	case ConstraintStrengthWeak:
		return "Weak"
	default:
		return fmt.Sprintf("ConstraintStrength(%d)", c)
	}
}

// ConstraintVflParserError: domain for VFL parsing errors.
type ConstraintVflParserError C.gint

const (
	// ConstraintVflParserErrorInvalidSymbol: invalid or unknown symbol.
	ConstraintVflParserErrorInvalidSymbol ConstraintVflParserError = iota
	// ConstraintVflParserErrorInvalidAttribute: invalid or unknown attribute.
	ConstraintVflParserErrorInvalidAttribute
	// ConstraintVflParserErrorInvalidView: invalid or unknown view.
	ConstraintVflParserErrorInvalidView
	// ConstraintVflParserErrorInvalidMetric: invalid or unknown metric.
	ConstraintVflParserErrorInvalidMetric
	// ConstraintVflParserErrorInvalidPriority: invalid or unknown priority.
	ConstraintVflParserErrorInvalidPriority
	// ConstraintVflParserErrorInvalidRelation: invalid or unknown relation.
	ConstraintVflParserErrorInvalidRelation
)

func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
	return ConstraintVflParserError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintVflParserError.
func (c ConstraintVflParserError) String() string {
	switch c {
	case ConstraintVflParserErrorInvalidSymbol:
		return "Symbol"
	case ConstraintVflParserErrorInvalidAttribute:
		return "Attribute"
	case ConstraintVflParserErrorInvalidView:
		return "View"
	case ConstraintVflParserErrorInvalidMetric:
		return "Metric"
	case ConstraintVflParserErrorInvalidPriority:
		return "Priority"
	case ConstraintVflParserErrorInvalidRelation:
		return "Relation"
	default:
		return fmt.Sprintf("ConstraintVflParserError(%d)", c)
	}
}

func ConstraintVflParserErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_constraint_vfl_parser_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// CornerType specifies which corner a child widget should be placed in when
// packed into a GtkScrolledWindow.
//
// This is effectively the opposite of where the scroll bars are placed.
type CornerType C.gint

const (
	// CornerTopLeft: place the scrollbars on the right and bottom of the widget
	// (default behaviour).
	CornerTopLeft CornerType = iota
	// CornerBottomLeft: place the scrollbars on the top and right of the
	// widget.
	CornerBottomLeft
	// CornerTopRight: place the scrollbars on the left and bottom of the
	// widget.
	CornerTopRight
	// CornerBottomRight: place the scrollbars on the top and left of the
	// widget.
	CornerBottomRight
)

func marshalCornerType(p uintptr) (interface{}, error) {
	return CornerType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for CornerType.
func (c CornerType) String() string {
	switch c {
	case CornerTopLeft:
		return "TopLeft"
	case CornerBottomLeft:
		return "BottomLeft"
	case CornerTopRight:
		return "TopRight"
	case CornerBottomRight:
		return "BottomRight"
	default:
		return fmt.Sprintf("CornerType(%d)", c)
	}
}

// CSSParserError errors that can occur while parsing CSS.
//
// These errors are unexpected and will cause parts of the given CSS to be
// ignored.
type CSSParserError C.gint

const (
	// CSSParserErrorFailed: unknown failure.
	CSSParserErrorFailed CSSParserError = iota
	// CSSParserErrorSyntax: given text does not form valid syntax.
	CSSParserErrorSyntax
	// CSSParserErrorImport: failed to import a resource.
	CSSParserErrorImport
	// CSSParserErrorName: given name has not been defined.
	CSSParserErrorName
	// CSSParserErrorUnknownValue: given value is not correct.
	CSSParserErrorUnknownValue
)

// String returns the name in string for CSSParserError.
func (c CSSParserError) String() string {
	switch c {
	case CSSParserErrorFailed:
		return "Failed"
	case CSSParserErrorSyntax:
		return "Syntax"
	case CSSParserErrorImport:
		return "Import"
	case CSSParserErrorName:
		return "Name"
	case CSSParserErrorUnknownValue:
		return "UnknownValue"
	default:
		return fmt.Sprintf("CSSParserError(%d)", c)
	}
}

// CSSParserWarning warnings that can occur while parsing CSS.
//
// Unlike CssParserErrors, warnings do not cause the parser to skip any input,
// but they indicate issues that should be fixed.
type CSSParserWarning C.gint

const (
	// CSSParserWarningDeprecated: given construct is deprecated and will be
	// removed in a future version.
	CSSParserWarningDeprecated CSSParserWarning = iota
	// CSSParserWarningSyntax: syntax construct was used that should be avoided.
	CSSParserWarningSyntax
	// CSSParserWarningUnimplemented: feature is not implemented.
	CSSParserWarningUnimplemented
)

// String returns the name in string for CSSParserWarning.
func (c CSSParserWarning) String() string {
	switch c {
	case CSSParserWarningDeprecated:
		return "Deprecated"
	case CSSParserWarningSyntax:
		return "Syntax"
	case CSSParserWarningUnimplemented:
		return "Unimplemented"
	default:
		return fmt.Sprintf("CSSParserWarning(%d)", c)
	}
}

// DeleteType: passed to various keybinding signals for deleting text.
type DeleteType C.gint

const (
	// DeleteChars: delete characters.
	DeleteChars DeleteType = iota
	// DeleteWordEnds: delete only the portion of the word to the left/right of
	// cursor if we’re in the middle of a word.
	DeleteWordEnds
	// DeleteWords: delete words.
	DeleteWords
	// DeleteDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteDisplayLines
	// DeleteDisplayLineEnds: delete only the portion of the display-line to the
	// left/right of cursor.
	DeleteDisplayLineEnds
	// DeleteParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteParagraphEnds
	// DeleteParagraphs: delete entire line. Like C-k in pico.
	DeleteParagraphs
	// DeleteWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteWhitespace
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DeleteType.
func (d DeleteType) String() string {
	switch d {
	case DeleteChars:
		return "Chars"
	case DeleteWordEnds:
		return "WordEnds"
	case DeleteWords:
		return "Words"
	case DeleteDisplayLines:
		return "DisplayLines"
	case DeleteDisplayLineEnds:
		return "DisplayLineEnds"
	case DeleteParagraphEnds:
		return "ParagraphEnds"
	case DeleteParagraphs:
		return "Paragraphs"
	case DeleteWhitespace:
		return "Whitespace"
	default:
		return fmt.Sprintf("DeleteType(%d)", d)
	}
}

// DirectionType focus movement types.
type DirectionType C.gint

const (
	// DirTabForward: move forward.
	DirTabForward DirectionType = iota
	// DirTabBackward: move backward.
	DirTabBackward
	// DirUp: move up.
	DirUp
	// DirDown: move down.
	DirDown
	// DirLeft: move left.
	DirLeft
	// DirRight: move right.
	DirRight
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DirectionType.
func (d DirectionType) String() string {
	switch d {
	case DirTabForward:
		return "TabForward"
	case DirTabBackward:
		return "TabBackward"
	case DirUp:
		return "Up"
	case DirDown:
		return "Down"
	case DirLeft:
		return "Left"
	case DirRight:
		return "Right"
	default:
		return fmt.Sprintf("DirectionType(%d)", d)
	}
}

type EditableProperties C.gint

const (
	EditablePropText EditableProperties = iota
	EditablePropCursorPosition
	EditablePropSelectionBound
	EditablePropEditable
	EditablePropWidthChars
	EditablePropMaxWidthChars
	EditablePropXAlign
	EditablePropEnableUndo
	EditableNumProperties
)

func marshalEditableProperties(p uintptr) (interface{}, error) {
	return EditableProperties(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EditableProperties.
func (e EditableProperties) String() string {
	switch e {
	case EditablePropText:
		return "PropText"
	case EditablePropCursorPosition:
		return "PropCursorPosition"
	case EditablePropSelectionBound:
		return "PropSelectionBound"
	case EditablePropEditable:
		return "PropEditable"
	case EditablePropWidthChars:
		return "PropWidthChars"
	case EditablePropMaxWidthChars:
		return "PropMaxWidthChars"
	case EditablePropXAlign:
		return "PropXAlign"
	case EditablePropEnableUndo:
		return "PropEnableUndo"
	case EditableNumProperties:
		return "NumProperties"
	default:
		return fmt.Sprintf("EditableProperties(%d)", e)
	}
}

// EntryIconPosition specifies the side of the entry at which an icon is placed.
type EntryIconPosition C.gint

const (
	// EntryIconPrimary: at the beginning of the entry (depending on the text
	// direction).
	EntryIconPrimary EntryIconPosition = iota
	// EntryIconSecondary: at the end of the entry (depending on the text
	// direction).
	EntryIconSecondary
)

func marshalEntryIconPosition(p uintptr) (interface{}, error) {
	return EntryIconPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EntryIconPosition.
func (e EntryIconPosition) String() string {
	switch e {
	case EntryIconPrimary:
		return "Primary"
	case EntryIconSecondary:
		return "Secondary"
	default:
		return fmt.Sprintf("EntryIconPosition(%d)", e)
	}
}

// EventSequenceState describes the state of a GdkEventSequence in a GtkGesture.
type EventSequenceState C.gint

const (
	// EventSequenceNone: sequence is handled, but not grabbed.
	EventSequenceNone EventSequenceState = iota
	// EventSequenceClaimed: sequence is handled and grabbed.
	EventSequenceClaimed
	// EventSequenceDenied: sequence is denied.
	EventSequenceDenied
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EventSequenceState.
func (e EventSequenceState) String() string {
	switch e {
	case EventSequenceNone:
		return "None"
	case EventSequenceClaimed:
		return "Claimed"
	case EventSequenceDenied:
		return "Denied"
	default:
		return fmt.Sprintf("EventSequenceState(%d)", e)
	}
}

// FileChooserAction describes whether a GtkFileChooser is being used to open
// existing files or to save to a possibly new file.
type FileChooserAction C.gint

const (
	// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
	FileChooserActionOpen FileChooserAction = iota
	// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
	FileChooserActionSave
	// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
	FileChooserActionSelectFolder
)

func marshalFileChooserAction(p uintptr) (interface{}, error) {
	return FileChooserAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileChooserAction.
func (f FileChooserAction) String() string {
	switch f {
	case FileChooserActionOpen:
		return "Open"
	case FileChooserActionSave:
		return "Save"
	case FileChooserActionSelectFolder:
		return "SelectFolder"
	default:
		return fmt.Sprintf("FileChooserAction(%d)", f)
	}
}

// FileChooserError: these identify the various errors that can occur while
// calling GtkFileChooser functions.
type FileChooserError C.gint

const (
	// FileChooserErrorNonexistent indicates that a file does not exist.
	FileChooserErrorNonexistent FileChooserError = iota
	// FileChooserErrorBadFilename indicates a malformed filename.
	FileChooserErrorBadFilename
	// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
	FileChooserErrorAlreadyExists
	// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
	FileChooserErrorIncompleteHostname
)

func marshalFileChooserError(p uintptr) (interface{}, error) {
	return FileChooserError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FileChooserError.
func (f FileChooserError) String() string {
	switch f {
	case FileChooserErrorNonexistent:
		return "Nonexistent"
	case FileChooserErrorBadFilename:
		return "BadFilename"
	case FileChooserErrorAlreadyExists:
		return "AlreadyExists"
	case FileChooserErrorIncompleteHostname:
		return "IncompleteHostname"
	default:
		return fmt.Sprintf("FileChooserError(%d)", f)
	}
}

// FileChooserErrorQuark registers an error quark for GtkFileChooser errors.
//
// The function returns the following values:
//
//   - quark: error quark used for GtkFileChooser errors.
func FileChooserErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_file_chooser_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// FilterChange describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
//
// If you are writing an implementation and are not sure which value to pass,
// GTK_FILTER_CHANGE_DIFFERENT is always a correct choice.
type FilterChange C.gint

const (
	// FilterChangeDifferent: filter change cannot be described with any of the
	// other enumeration values.
	FilterChangeDifferent FilterChange = iota
	// FilterChangeLessStrict: filter is less strict than it was before: All
	// items that it used to return TRUE for still return TRUE, others now may,
	// too.
	FilterChangeLessStrict
	// FilterChangeMoreStrict: filter is more strict than it was before:
	// All items that it used to return FALSE for still return FALSE, others now
	// may, too.
	FilterChangeMoreStrict
)

func marshalFilterChange(p uintptr) (interface{}, error) {
	return FilterChange(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FilterChange.
func (f FilterChange) String() string {
	switch f {
	case FilterChangeDifferent:
		return "Different"
	case FilterChangeLessStrict:
		return "LessStrict"
	case FilterChangeMoreStrict:
		return "MoreStrict"
	default:
		return fmt.Sprintf("FilterChange(%d)", f)
	}
}

// FilterMatch describes the known strictness of a filter.
//
// Note that for filters where the strictness is not known,
// GTK_FILTER_MATCH_SOME is always an acceptable value, even if a filter does
// match all or no items.
type FilterMatch C.gint

const (
	// FilterMatchSome: filter matches some items, gtk_filter_match() may return
	// TRUE or FALSE.
	FilterMatchSome FilterMatch = iota
	// FilterMatchNone: filter does not match any item, gtk_filter_match() will
	// always return FALSE.
	FilterMatchNone
	// FilterMatchAll: filter matches all items, gtk_filter_match() will alays
	// return TRUE.
	FilterMatchAll
)

func marshalFilterMatch(p uintptr) (interface{}, error) {
	return FilterMatch(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for FilterMatch.
func (f FilterMatch) String() string {
	switch f {
	case FilterMatchSome:
		return "Some"
	case FilterMatchNone:
		return "None"
	case FilterMatchAll:
		return "All"
	default:
		return fmt.Sprintf("FilterMatch(%d)", f)
	}
}

// IconSize: built-in icon sizes.
//
// Icon sizes default to being inherited. Where they cannot be inherited,
// text size is the default.
//
// All widgets which use GtkIconSize set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the -gtk-icon-size CSS property.
type IconSize C.gint

const (
	// IconSizeInherit: keep the size of the parent element.
	IconSizeInherit IconSize = iota
	// IconSizeNormal: size similar to text size.
	IconSizeNormal
	// IconSizeLarge: large size, for example in an icon view.
	IconSizeLarge
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconSize.
func (i IconSize) String() string {
	switch i {
	case IconSizeInherit:
		return "Inherit"
	case IconSizeNormal:
		return "Normal"
	case IconSizeLarge:
		return "Large"
	default:
		return fmt.Sprintf("IconSize(%d)", i)
	}
}

// IconThemeError: error codes for GtkIconTheme operations.
type IconThemeError C.gint

const (
	// IconThemeNotFound: icon specified does not exist in the theme.
	IconThemeNotFound IconThemeError = iota
	// IconThemeFailed: unspecified error occurred.
	IconThemeFailed
)

func marshalIconThemeError(p uintptr) (interface{}, error) {
	return IconThemeError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconThemeError.
func (i IconThemeError) String() string {
	switch i {
	case IconThemeNotFound:
		return "NotFound"
	case IconThemeFailed:
		return "Failed"
	default:
		return fmt.Sprintf("IconThemeError(%d)", i)
	}
}

func IconThemeErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_icon_theme_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// IconViewDropPosition: enum for determining where a dropped item goes.
type IconViewDropPosition C.gint

const (
	// IconViewNoDrop: no drop possible.
	IconViewNoDrop IconViewDropPosition = iota
	// IconViewDropInto: dropped item replaces the item.
	IconViewDropInto
	// IconViewDropLeft: dropped item is inserted to the left.
	IconViewDropLeft
	// IconViewDropRight: dropped item is inserted to the right.
	IconViewDropRight
	// IconViewDropAbove: dropped item is inserted above.
	IconViewDropAbove
	// IconViewDropBelow: dropped item is inserted below.
	IconViewDropBelow
)

func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
	return IconViewDropPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconViewDropPosition.
func (i IconViewDropPosition) String() string {
	switch i {
	case IconViewNoDrop:
		return "NoDrop"
	case IconViewDropInto:
		return "DropInto"
	case IconViewDropLeft:
		return "DropLeft"
	case IconViewDropRight:
		return "DropRight"
	case IconViewDropAbove:
		return "DropAbove"
	case IconViewDropBelow:
		return "DropBelow"
	default:
		return fmt.Sprintf("IconViewDropPosition(%d)", i)
	}
}

// ImageType describes the image data representation used by a gtk.Image.
//
// If you want to get the image from the widget, you can only
// get the currently-stored representation; for instance, if the
// gtk_image_get_storage_type() returns GTK_IMAGE_PAINTABLE, then you can call
// gtk_image_get_paintable().
//
// For empty images, you can request any storage type (call any of the "get"
// functions), but they will all return NULL values.
type ImageType C.gint

const (
	// ImageEmpty: there is no image displayed by the widget.
	ImageEmpty ImageType = iota
	// ImageIconName: widget contains a named icon.
	ImageIconName
	// ImageGIcon: widget contains a #GIcon.
	ImageGIcon
	// ImagePaintable: widget contains a Paintable.
	ImagePaintable
)

func marshalImageType(p uintptr) (interface{}, error) {
	return ImageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ImageType.
func (i ImageType) String() string {
	switch i {
	case ImageEmpty:
		return "Empty"
	case ImageIconName:
		return "IconName"
	case ImageGIcon:
		return "GIcon"
	case ImagePaintable:
		return "Paintable"
	default:
		return fmt.Sprintf("ImageType(%d)", i)
	}
}

// InputPurpose describes primary purpose of the input widget.
//
// This information is useful for on-screen keyboards and similar input methods
// to decide which keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and “e” or “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose C.gint

const (
	// InputPurposeFreeForm: allow any character.
	InputPurposeFreeForm InputPurpose = iota
	// InputPurposeAlpha: allow only alphabetic characters.
	InputPurposeAlpha
	// InputPurposeDigits: allow only digits.
	InputPurposeDigits
	// InputPurposeNumber: edited field expects numbers.
	InputPurposeNumber
	// InputPurposePhone: edited field expects phone number.
	InputPurposePhone
	// InputPurposeURL: edited field expects URL.
	InputPurposeURL
	// InputPurposeEmail: edited field expects email address.
	InputPurposeEmail
	// InputPurposeName: edited field expects the name of a person.
	InputPurposeName
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden.
	InputPurposePassword
	// InputPurposePIN: like GTK_INPUT_PURPOSE_DIGITS, but characters are
	// hidden.
	InputPurposePIN
	// InputPurposeTerminal: allow any character, in addition to control codes.
	InputPurposeTerminal
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InputPurpose.
func (i InputPurpose) String() string {
	switch i {
	case InputPurposeFreeForm:
		return "FreeForm"
	case InputPurposeAlpha:
		return "Alpha"
	case InputPurposeDigits:
		return "Digits"
	case InputPurposeNumber:
		return "Number"
	case InputPurposePhone:
		return "Phone"
	case InputPurposeURL:
		return "URL"
	case InputPurposeEmail:
		return "Email"
	case InputPurposeName:
		return "Name"
	case InputPurposePassword:
		return "Password"
	case InputPurposePIN:
		return "PIN"
	case InputPurposeTerminal:
		return "Terminal"
	default:
		return fmt.Sprintf("InputPurpose(%d)", i)
	}
}

// Justification: used for justifying the text inside a GtkLabel widget.
type Justification C.gint

const (
	// JustifyLeft: text is placed at the left edge of the label.
	JustifyLeft Justification = iota
	// JustifyRight: text is placed at the right edge of the label.
	JustifyRight
	// JustifyCenter: text is placed in the center of the label.
	JustifyCenter
	// JustifyFill: text is placed is distributed across the label.
	JustifyFill
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Justification.
func (j Justification) String() string {
	switch j {
	case JustifyLeft:
		return "Left"
	case JustifyRight:
		return "Right"
	case JustifyCenter:
		return "Center"
	case JustifyFill:
		return "Fill"
	default:
		return fmt.Sprintf("Justification(%d)", j)
	}
}

// LevelBarMode describes how GtkLevelBar contents should be rendered.
//
// Note that this enumeration could be extended with additional modes in the
// future.
type LevelBarMode C.gint

const (
	// LevelBarModeContinuous: bar has a continuous mode.
	LevelBarModeContinuous LevelBarMode = iota
	// LevelBarModeDiscrete: bar has a discrete mode.
	LevelBarModeDiscrete
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LevelBarMode.
func (l LevelBarMode) String() string {
	switch l {
	case LevelBarModeContinuous:
		return "Continuous"
	case LevelBarModeDiscrete:
		return "Discrete"
	default:
		return fmt.Sprintf("LevelBarMode(%d)", l)
	}
}

// License: type of license for an application.
//
// This enumeration can be expanded at later date.
type License C.gint

const (
	// LicenseUnknown: no license specified.
	LicenseUnknown License = iota
	// LicenseCustom: license text is going to be specified by the developer.
	LicenseCustom
	// LicenseGPL20: GNU General Public License, version 2.0 or later.
	LicenseGPL20
	// LicenseGPL30: GNU General Public License, version 3.0 or later.
	LicenseGPL30
	// LicenseLGPL21: GNU Lesser General Public License, version 2.1 or later.
	LicenseLGPL21
	// LicenseLGPL30: GNU Lesser General Public License, version 3.0 or later.
	LicenseLGPL30
	// LicenseBSD: BSD standard license.
	LicenseBSD
	// LicenseMITX11: MIT/X11 standard license.
	LicenseMITX11
	// LicenseArtistic: artistic License, version 2.0.
	LicenseArtistic
	// LicenseGPL20_Only: GNU General Public License, version 2.0 only.
	LicenseGPL20_Only
	// LicenseGPL30_Only: GNU General Public License, version 3.0 only.
	LicenseGPL30_Only
	// LicenseLGPL21_Only: GNU Lesser General Public License, version 2.1 only.
	LicenseLGPL21_Only
	// LicenseLGPL30_Only: GNU Lesser General Public License, version 3.0 only.
	LicenseLGPL30_Only
	// LicenseAGPL30: GNU Affero General Public License, version 3.0 or later.
	LicenseAGPL30
	// LicenseAGPL30_Only: GNU Affero General Public License, version 3.0 only.
	LicenseAGPL30_Only
	// LicenseBSD3: 3-clause BSD licence.
	LicenseBSD3
	// LicenseApache20: apache License, version 2.0.
	LicenseApache20
	// LicenseMPL20: mozilla Public License, version 2.0.
	LicenseMPL20
)

func marshalLicense(p uintptr) (interface{}, error) {
	return License(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for License.
func (l License) String() string {
	switch l {
	case LicenseUnknown:
		return "Unknown"
	case LicenseCustom:
		return "Custom"
	case LicenseGPL20:
		return "GPL20"
	case LicenseGPL30:
		return "GPL30"
	case LicenseLGPL21:
		return "LGPL21"
	case LicenseLGPL30:
		return "LGPL30"
	case LicenseBSD:
		return "BSD"
	case LicenseMITX11:
		return "MITX11"
	case LicenseArtistic:
		return "Artistic"
	case LicenseGPL20_Only:
		return "GPL20_Only"
	case LicenseGPL30_Only:
		return "GPL30_Only"
	case LicenseLGPL21_Only:
		return "LGPL21_Only"
	case LicenseLGPL30_Only:
		return "LGPL30_Only"
	case LicenseAGPL30:
		return "AGPL30"
	case LicenseAGPL30_Only:
		return "AGPL30_Only"
	case LicenseBSD3:
		return "BSD3"
	case LicenseApache20:
		return "Apache20"
	case LicenseMPL20:
		return "MPL20"
	default:
		return fmt.Sprintf("License(%d)", l)
	}
}

// MessageType: type of message being displayed in a GtkMessageDialog.
type MessageType C.gint

const (
	// MessageInfo: informational message.
	MessageInfo MessageType = iota
	// MessageWarning: non-fatal warning message.
	MessageWarning
	// MessageQuestion: question requiring a choice.
	MessageQuestion
	// MessageError: fatal error message.
	MessageError
	// MessageOther: none of the above.
	MessageOther
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MessageType.
func (m MessageType) String() string {
	switch m {
	case MessageInfo:
		return "Info"
	case MessageWarning:
		return "Warning"
	case MessageQuestion:
		return "Question"
	case MessageError:
		return "Error"
	case MessageOther:
		return "Other"
	default:
		return fmt.Sprintf("MessageType(%d)", m)
	}
}

// MovementStep: passed as argument to various keybinding signals for moving the
// cursor position.
type MovementStep C.gint

const (
	// MovementLogicalPositions: move forward or back by graphemes.
	MovementLogicalPositions MovementStep = iota
	// MovementVisualPositions: move left or right by graphemes.
	MovementVisualPositions
	// MovementWords: move forward or back by words.
	MovementWords
	// MovementDisplayLines: move up or down lines (wrapped lines).
	MovementDisplayLines
	// MovementDisplayLineEnds: move to either end of a line.
	MovementDisplayLineEnds
	// MovementParagraphs: move up or down paragraphs (newline-ended lines).
	MovementParagraphs
	// MovementParagraphEnds: move to either end of a paragraph.
	MovementParagraphEnds
	// MovementPages: move by pages.
	MovementPages
	// MovementBufferEnds: move to ends of the buffer.
	MovementBufferEnds
	// MovementHorizontalPages: move horizontally by pages.
	MovementHorizontalPages
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MovementStep.
func (m MovementStep) String() string {
	switch m {
	case MovementLogicalPositions:
		return "LogicalPositions"
	case MovementVisualPositions:
		return "VisualPositions"
	case MovementWords:
		return "Words"
	case MovementDisplayLines:
		return "DisplayLines"
	case MovementDisplayLineEnds:
		return "DisplayLineEnds"
	case MovementParagraphs:
		return "Paragraphs"
	case MovementParagraphEnds:
		return "ParagraphEnds"
	case MovementPages:
		return "Pages"
	case MovementBufferEnds:
		return "BufferEnds"
	case MovementHorizontalPages:
		return "HorizontalPages"
	default:
		return fmt.Sprintf("MovementStep(%d)", m)
	}
}

// NotebookTab: parameter used in the action signals of GtkNotebook.
type NotebookTab C.gint

const (
	// NotebookTabFirst: first tab in the notebook.
	NotebookTabFirst NotebookTab = iota
	// NotebookTabLast: last tab in the notebook.
	NotebookTabLast
)

func marshalNotebookTab(p uintptr) (interface{}, error) {
	return NotebookTab(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NotebookTab.
func (n NotebookTab) String() string {
	switch n {
	case NotebookTabFirst:
		return "First"
	case NotebookTabLast:
		return "Last"
	default:
		return fmt.Sprintf("NotebookTab(%d)", n)
	}
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout C.gint

const (
	// NumberUpLayoutLeftToRightTopToBottom: ! (layout-lrtb.png).
	NumberUpLayoutLeftToRightTopToBottom NumberUpLayout = iota
	// NumberUpLayoutLeftToRightBottomToTop: ! (layout-lrbt.png).
	NumberUpLayoutLeftToRightBottomToTop
	// NumberUpLayoutRightToLeftTopToBottom: ! (layout-rltb.png).
	NumberUpLayoutRightToLeftTopToBottom
	// NumberUpLayoutRightToLeftBottomToTop: ! (layout-rlbt.png).
	NumberUpLayoutRightToLeftBottomToTop
	// NumberUpLayoutTopToBottomLeftToRight: ! (layout-tblr.png).
	NumberUpLayoutTopToBottomLeftToRight
	// NumberUpLayoutTopToBottomRightToLeft: ! (layout-tbrl.png).
	NumberUpLayoutTopToBottomRightToLeft
	// NumberUpLayoutBottomToTopLeftToRight: ! (layout-btlr.png).
	NumberUpLayoutBottomToTopLeftToRight
	// NumberUpLayoutBottomToTopRightToLeft: ! (layout-btrl.png).
	NumberUpLayoutBottomToTopRightToLeft
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NumberUpLayout.
func (n NumberUpLayout) String() string {
	switch n {
	case NumberUpLayoutLeftToRightTopToBottom:
		return "Lrtb"
	case NumberUpLayoutLeftToRightBottomToTop:
		return "Lrbt"
	case NumberUpLayoutRightToLeftTopToBottom:
		return "Rltb"
	case NumberUpLayoutRightToLeftBottomToTop:
		return "Rlbt"
	case NumberUpLayoutTopToBottomLeftToRight:
		return "Tblr"
	case NumberUpLayoutTopToBottomRightToLeft:
		return "Tbrl"
	case NumberUpLayoutBottomToTopLeftToRight:
		return "Btlr"
	case NumberUpLayoutBottomToTopRightToLeft:
		return "Btrl"
	default:
		return fmt.Sprintf("NumberUpLayout(%d)", n)
	}
}

// Ordering describes the way two values can be compared.
//
// These values can be used with a GCompareFunc. However, a GCompareFunc is
// allowed to return any integer values. For converting such a value to a
// GtkOrdering value, use gtk.Ordering().FromCmpfunc.
type Ordering C.gint

const (
	// OrderingSmaller: first value is smaller than the second.
	OrderingSmaller Ordering = -1
	// OrderingEqual: two values are equal.
	OrderingEqual Ordering = 0
	// OrderingLarger: first value is larger than the second.
	OrderingLarger Ordering = 1
)

func marshalOrdering(p uintptr) (interface{}, error) {
	return Ordering(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Ordering.
func (o Ordering) String() string {
	switch o {
	case OrderingSmaller:
		return "Smaller"
	case OrderingEqual:
		return "Equal"
	case OrderingLarger:
		return "Larger"
	default:
		return fmt.Sprintf("Ordering(%d)", o)
	}
}

// OrderingFromCmpfunc converts the result of a GCompareFunc like strcmp() to a
// GtkOrdering value.
//
// The function takes the following parameters:
//
//   - cmpfuncResult: result of a comparison function.
//
// The function returns the following values:
//
//   - ordering: corresponding GtkOrdering.
func OrderingFromCmpfunc(cmpfuncResult int) Ordering {
	var _arg1 C.int         // out
	var _cret C.GtkOrdering // in

	_arg1 = C.int(cmpfuncResult)

	_cret = C.gtk_ordering_from_cmpfunc(_arg1)
	runtime.KeepAlive(cmpfuncResult)

	var _ordering Ordering // out

	_ordering = Ordering(_cret)

	return _ordering
}

// Orientation represents the orientation of widgets and other objects.
//
// Typical examples are GtkBox or GtkGesturePan`.
type Orientation C.gint

const (
	// OrientationHorizontal: element is in horizontal orientation.
	OrientationHorizontal Orientation = iota
	// OrientationVertical: element is in vertical orientation.
	OrientationVertical
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Orientation.
func (o Orientation) String() string {
	switch o {
	case OrientationHorizontal:
		return "Horizontal"
	case OrientationVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("Orientation(%d)", o)
	}
}

// Overflow defines how content overflowing a given area should be handled.
//
// This is used in gtk.Widget.SetOverflow(). The gtk.Widget:overflow property is
// modeled after the CSS overflow property, but implements it only partially.
type Overflow C.gint

const (
	// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
	OverflowVisible Overflow = iota
	// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
	OverflowHidden
)

func marshalOverflow(p uintptr) (interface{}, error) {
	return Overflow(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Overflow.
func (o Overflow) String() string {
	switch o {
	case OverflowVisible:
		return "Visible"
	case OverflowHidden:
		return "Hidden"
	default:
		return fmt.Sprintf("Overflow(%d)", o)
	}
}

// PackType represents the packing location of a children in its parent.
//
// See GtkWindowControls for example.
type PackType C.gint

const (
	// PackStart: child is packed into the start of the widget.
	PackStart PackType = iota
	// PackEnd: child is packed into the end of the widget.
	PackEnd
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PackType.
func (p PackType) String() string {
	switch p {
	case PackStart:
		return "Start"
	case PackEnd:
		return "End"
	default:
		return fmt.Sprintf("PackType(%d)", p)
	}
}

// PadActionType: type of a pad action.
type PadActionType C.gint

const (
	// PadActionButton: action is triggered by a pad button.
	PadActionButton PadActionType = iota
	// PadActionRing: action is triggered by a pad ring.
	PadActionRing
	// PadActionStrip: action is triggered by a pad strip.
	PadActionStrip
)

func marshalPadActionType(p uintptr) (interface{}, error) {
	return PadActionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PadActionType.
func (p PadActionType) String() string {
	switch p {
	case PadActionButton:
		return "Button"
	case PadActionRing:
		return "Ring"
	case PadActionStrip:
		return "Strip"
	default:
		return fmt.Sprintf("PadActionType(%d)", p)
	}
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation C.gint

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = iota
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PageOrientation.
func (p PageOrientation) String() string {
	switch p {
	case PageOrientationPortrait:
		return "Portrait"
	case PageOrientationLandscape:
		return "Landscape"
	case PageOrientationReversePortrait:
		return "ReversePortrait"
	case PageOrientationReverseLandscape:
		return "ReverseLandscape"
	default:
		return fmt.Sprintf("PageOrientation(%d)", p)
	}
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet C.gint

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = iota
	// PageSetEven: even pages.
	PageSetEven
	// PageSetOdd: odd pages.
	PageSetOdd
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PageSet.
func (p PageSet) String() string {
	switch p {
	case PageSetAll:
		return "All"
	case PageSetEven:
		return "Even"
	case PageSetOdd:
		return "Odd"
	default:
		return fmt.Sprintf("PageSet(%d)", p)
	}
}

// PanDirection describes the panning direction of a GtkGesturePan.
type PanDirection C.gint

const (
	// PanDirectionLeft: panned towards the left.
	PanDirectionLeft PanDirection = iota
	// PanDirectionRight: panned towards the right.
	PanDirectionRight
	// PanDirectionUp: panned upwards.
	PanDirectionUp
	// PanDirectionDown: panned downwards.
	PanDirectionDown
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PanDirection.
func (p PanDirection) String() string {
	switch p {
	case PanDirectionLeft:
		return "Left"
	case PanDirectionRight:
		return "Right"
	case PanDirectionUp:
		return "Up"
	case PanDirectionDown:
		return "Down"
	default:
		return fmt.Sprintf("PanDirection(%d)", p)
	}
}

// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
type PolicyType C.gint

const (
	// PolicyAlways: scrollbar is always visible. The view size is independent
	// of the content.
	PolicyAlways PolicyType = iota
	// PolicyAutomatic: scrollbar will appear and disappear as necessary.
	// For example, when all of a GtkTreeView can not be seen.
	PolicyAutomatic
	// PolicyNever: scrollbar should never appear. In this mode the content
	// determines the size.
	PolicyNever
	// PolicyExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar.
	PolicyExternal
)

func marshalPolicyType(p uintptr) (interface{}, error) {
	return PolicyType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PolicyType.
func (p PolicyType) String() string {
	switch p {
	case PolicyAlways:
		return "Always"
	case PolicyAutomatic:
		return "Automatic"
	case PolicyNever:
		return "Never"
	case PolicyExternal:
		return "External"
	default:
		return fmt.Sprintf("PolicyType(%d)", p)
	}
}

// PositionType describes which edge of a widget a certain feature is positioned
// at.
//
// For examples, see the tabs of a GtkNotebook, or the label of a GtkScale.
type PositionType C.gint

const (
	// PosLeft: feature is at the left edge.
	PosLeft PositionType = iota
	// PosRight: feature is at the right edge.
	PosRight
	// PosTop: feature is at the top edge.
	PosTop
	// PosBottom: feature is at the bottom edge.
	PosBottom
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PositionType.
func (p PositionType) String() string {
	switch p {
	case PosLeft:
		return "Left"
	case PosRight:
		return "Right"
	case PosTop:
		return "Top"
	case PosBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("PositionType(%d)", p)
	}
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex C.gint

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = iota
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintDuplex.
func (p PrintDuplex) String() string {
	switch p {
	case PrintDuplexSimplex:
		return "Simplex"
	case PrintDuplexHorizontal:
		return "Horizontal"
	case PrintDuplexVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("PrintDuplex(%d)", p)
	}
}

// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
type PrintError C.gint

const (
	// PrintErrorGeneral: unspecified error occurred.
	PrintErrorGeneral PrintError = iota
	// PrintErrorInternalError: internal error occurred.
	PrintErrorInternalError
	// PrintErrorNOMEM: memory allocation failed.
	PrintErrorNOMEM
	// PrintErrorInvalidFile: error occurred while loading a page setup or paper
	// size from a key file.
	PrintErrorInvalidFile
)

func marshalPrintError(p uintptr) (interface{}, error) {
	return PrintError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintError.
func (p PrintError) String() string {
	switch p {
	case PrintErrorGeneral:
		return "General"
	case PrintErrorInternalError:
		return "InternalError"
	case PrintErrorNOMEM:
		return "NOMEM"
	case PrintErrorInvalidFile:
		return "InvalidFile"
	default:
		return fmt.Sprintf("PrintError(%d)", p)
	}
}

// PrintErrorQuark registers an error quark for GtkPrintOperation if necessary.
//
// The function returns the following values:
//
//   - quark: error quark used for GtkPrintOperation errors.
func PrintErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_print_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// PrintOperationAction determines what action the print operation should
// perform.
//
// A parameter of this typs is passed to gtk.PrintOperation.Run().
type PrintOperationAction C.gint

const (
	// PrintOperationActionPrintDialog: show the print dialog.
	PrintOperationActionPrintDialog PrintOperationAction = iota
	// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
	PrintOperationActionPrint
	// PrintOperationActionPreview: show the print preview.
	PrintOperationActionPreview
	// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
	PrintOperationActionExport
)

func marshalPrintOperationAction(p uintptr) (interface{}, error) {
	return PrintOperationAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintOperationAction.
func (p PrintOperationAction) String() string {
	switch p {
	case PrintOperationActionPrintDialog:
		return "PrintDialog"
	case PrintOperationActionPrint:
		return "Print"
	case PrintOperationActionPreview:
		return "Preview"
	case PrintOperationActionExport:
		return "Export"
	default:
		return fmt.Sprintf("PrintOperationAction(%d)", p)
	}
}

// PrintOperationResult: result of a print operation.
//
// A value of this type is returned by gtk.PrintOperation.Run().
type PrintOperationResult C.gint

const (
	// PrintOperationResultError: error has occurred.
	PrintOperationResultError PrintOperationResult = iota
	// PrintOperationResultApply: print settings should be stored.
	PrintOperationResultApply
	// PrintOperationResultCancel: print operation has been canceled, the print
	// settings should not be stored.
	PrintOperationResultCancel
	// PrintOperationResultInProgress: print operation is not complete yet.
	// This value will only be returned when running asynchronously.
	PrintOperationResultInProgress
)

func marshalPrintOperationResult(p uintptr) (interface{}, error) {
	return PrintOperationResult(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintOperationResult.
func (p PrintOperationResult) String() string {
	switch p {
	case PrintOperationResultError:
		return "Error"
	case PrintOperationResultApply:
		return "Apply"
	case PrintOperationResultCancel:
		return "Cancel"
	case PrintOperationResultInProgress:
		return "InProgress"
	default:
		return fmt.Sprintf("PrintOperationResult(%d)", p)
	}
}

// PrintPages: see also gtk_print_job_set_pages().
type PrintPages C.gint

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = iota
	// PrintPagesCurrent: current page.
	PrintPagesCurrent
	// PrintPagesRanges: range of pages.
	PrintPagesRanges
	// PrintPagesSelection: selected pages.
	PrintPagesSelection
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintPages.
func (p PrintPages) String() string {
	switch p {
	case PrintPagesAll:
		return "All"
	case PrintPagesCurrent:
		return "Current"
	case PrintPagesRanges:
		return "Ranges"
	case PrintPagesSelection:
		return "Selection"
	default:
		return fmt.Sprintf("PrintPages(%d)", p)
	}
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality C.gint

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = iota
	// PrintQualityNormal: normal quality.
	PrintQualityNormal
	// PrintQualityHigh: high quality.
	PrintQualityHigh
	// PrintQualityDraft: draft quality.
	PrintQualityDraft
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintQuality.
func (p PrintQuality) String() string {
	switch p {
	case PrintQualityLow:
		return "Low"
	case PrintQualityNormal:
		return "Normal"
	case PrintQualityHigh:
		return "High"
	case PrintQualityDraft:
		return "Draft"
	default:
		return fmt.Sprintf("PrintQuality(%d)", p)
	}
}

// PrintStatus status gives a rough indication of the completion of a running
// print operation.
type PrintStatus C.gint

const (
	// PrintStatusInitial: printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
	PrintStatusInitial PrintStatus = iota
	// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
	PrintStatusPreparing
	// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
	PrintStatusGeneratingData
	// PrintStatusSendingData: print job is being sent off to the printer.
	PrintStatusSendingData
	// PrintStatusPending: print job has been sent to the printer, but is not
	// printed for some reason, e.g. the printer may be stopped.
	PrintStatusPending
	// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
	PrintStatusPendingIssue
	// PrintStatusPrinting: printer is processing the print job.
	PrintStatusPrinting
	// PrintStatusFinished: printing has been completed successfully.
	PrintStatusFinished
	// PrintStatusFinishedAborted: printing has been aborted.
	PrintStatusFinishedAborted
)

func marshalPrintStatus(p uintptr) (interface{}, error) {
	return PrintStatus(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintStatus.
func (p PrintStatus) String() string {
	switch p {
	case PrintStatusInitial:
		return "Initial"
	case PrintStatusPreparing:
		return "Preparing"
	case PrintStatusGeneratingData:
		return "GeneratingData"
	case PrintStatusSendingData:
		return "SendingData"
	case PrintStatusPending:
		return "Pending"
	case PrintStatusPendingIssue:
		return "PendingIssue"
	case PrintStatusPrinting:
		return "Printing"
	case PrintStatusFinished:
		return "Finished"
	case PrintStatusFinishedAborted:
		return "FinishedAborted"
	default:
		return fmt.Sprintf("PrintStatus(%d)", p)
	}
}

// PropagationLimit describes limits of a GtkEventController for handling events
// targeting other widgets.
type PropagationLimit C.gint

const (
	// LimitNone events are handled regardless of what their target is.
	LimitNone PropagationLimit = iota
	// LimitSameNative events are only handled if their target is in the same
	// Native as the event controllers widget. Note that some event types have
	// two targets (origin and destination).
	LimitSameNative
)

func marshalPropagationLimit(p uintptr) (interface{}, error) {
	return PropagationLimit(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PropagationLimit.
func (p PropagationLimit) String() string {
	switch p {
	case LimitNone:
		return "None"
	case LimitSameNative:
		return "SameNative"
	default:
		return fmt.Sprintf("PropagationLimit(%d)", p)
	}
}

// PropagationPhase describes the stage at which events are fed into a
// GtkEventController.
type PropagationPhase C.gint

const (
	// PhaseNone events are not delivered.
	PhaseNone PropagationPhase = iota
	// PhaseCapture events are delivered in the capture phase. The capture phase
	// happens before the bubble phase, runs from the toplevel down to the event
	// widget. This option should only be used on containers that might possibly
	// handle events before their children do.
	PhaseCapture
	// PhaseBubble events are delivered in the bubble phase. The bubble phase
	// happens after the capture phase, and before the default handlers are run.
	// This phase runs from the event widget, up to the toplevel.
	PhaseBubble
	// PhaseTarget events are delivered in the default widget event handlers,
	// note that widget implementations must chain up on button, motion,
	// touch and grab broken handlers for controllers in this phase to be run.
	PhaseTarget
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PropagationPhase.
func (p PropagationPhase) String() string {
	switch p {
	case PhaseNone:
		return "None"
	case PhaseCapture:
		return "Capture"
	case PhaseBubble:
		return "Bubble"
	case PhaseTarget:
		return "Target"
	default:
		return fmt.Sprintf("PropagationPhase(%d)", p)
	}
}

// RecentManagerError: error codes for RecentManager operations.
type RecentManagerError C.gint

const (
	// RecentManagerErrorNotFound: URI specified does not exists in the recently
	// used resources list.
	RecentManagerErrorNotFound RecentManagerError = iota
	// RecentManagerErrorInvalidURI: URI specified is not valid.
	RecentManagerErrorInvalidURI
	// RecentManagerErrorInvalidEncoding: supplied string is not UTF-8 encoded.
	RecentManagerErrorInvalidEncoding
	// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
	RecentManagerErrorNotRegistered
	// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
	RecentManagerErrorRead
	// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
	RecentManagerErrorWrite
	// RecentManagerErrorUnknown: unspecified error.
	RecentManagerErrorUnknown
)

func marshalRecentManagerError(p uintptr) (interface{}, error) {
	return RecentManagerError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RecentManagerError.
func (r RecentManagerError) String() string {
	switch r {
	case RecentManagerErrorNotFound:
		return "NotFound"
	case RecentManagerErrorInvalidURI:
		return "InvalidURI"
	case RecentManagerErrorInvalidEncoding:
		return "InvalidEncoding"
	case RecentManagerErrorNotRegistered:
		return "NotRegistered"
	case RecentManagerErrorRead:
		return "Read"
	case RecentManagerErrorWrite:
		return "Write"
	case RecentManagerErrorUnknown:
		return "Unknown"
	default:
		return fmt.Sprintf("RecentManagerError(%d)", r)
	}
}

func RecentManagerErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_recent_manager_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button().
//
// All predefined values are negative; GTK leaves values of 0 or greater for
// application-defined response ids.
type ResponseType C.gint

const (
	// ResponseNone: returned if an action widget has no response id, or if the
	// dialog gets programmatically hidden or destroyed.
	ResponseNone ResponseType = -1
	// ResponseReject: generic response id, not used by GTK dialogs.
	ResponseReject ResponseType = -2
	// ResponseAccept: generic response id, not used by GTK dialogs.
	ResponseAccept ResponseType = -3
	// ResponseDeleteEvent: returned if the dialog is deleted.
	ResponseDeleteEvent ResponseType = -4
	// ResponseOK: returned by OK buttons in GTK dialogs.
	ResponseOK ResponseType = -5
	// ResponseCancel: returned by Cancel buttons in GTK dialogs.
	ResponseCancel ResponseType = -6
	// ResponseClose: returned by Close buttons in GTK dialogs.
	ResponseClose ResponseType = -7
	// ResponseYes: returned by Yes buttons in GTK dialogs.
	ResponseYes ResponseType = -8
	// ResponseNo: returned by No buttons in GTK dialogs.
	ResponseNo ResponseType = -9
	// ResponseApply: returned by Apply buttons in GTK dialogs.
	ResponseApply ResponseType = -10
	// ResponseHelp: returned by Help buttons in GTK dialogs.
	ResponseHelp ResponseType = -11
)

func marshalResponseType(p uintptr) (interface{}, error) {
	return ResponseType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ResponseType.
func (r ResponseType) String() string {
	switch r {
	case ResponseNone:
		return "None"
	case ResponseReject:
		return "Reject"
	case ResponseAccept:
		return "Accept"
	case ResponseDeleteEvent:
		return "DeleteEvent"
	case ResponseOK:
		return "OK"
	case ResponseCancel:
		return "Cancel"
	case ResponseClose:
		return "Close"
	case ResponseYes:
		return "Yes"
	case ResponseNo:
		return "No"
	case ResponseApply:
		return "Apply"
	case ResponseHelp:
		return "Help"
	default:
		return fmt.Sprintf("ResponseType(%d)", r)
	}
}

// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a GtkRevealer widget is shown or hidden.
type RevealerTransitionType C.gint

const (
	// RevealerTransitionTypeNone: no transition.
	RevealerTransitionTypeNone RevealerTransitionType = iota
	// RevealerTransitionTypeCrossfade: fade in.
	RevealerTransitionTypeCrossfade
	// RevealerTransitionTypeSlideRight: slide in from the left.
	RevealerTransitionTypeSlideRight
	// RevealerTransitionTypeSlideLeft: slide in from the right.
	RevealerTransitionTypeSlideLeft
	// RevealerTransitionTypeSlideUp: slide in from the bottom.
	RevealerTransitionTypeSlideUp
	// RevealerTransitionTypeSlideDown: slide in from the top.
	RevealerTransitionTypeSlideDown
	// RevealerTransitionTypeSwingRight: floop in from the left.
	RevealerTransitionTypeSwingRight
	// RevealerTransitionTypeSwingLeft: floop in from the right.
	RevealerTransitionTypeSwingLeft
	// RevealerTransitionTypeSwingUp: floop in from the bottom.
	RevealerTransitionTypeSwingUp
	// RevealerTransitionTypeSwingDown: floop in from the top.
	RevealerTransitionTypeSwingDown
)

func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
	return RevealerTransitionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for RevealerTransitionType.
func (r RevealerTransitionType) String() string {
	switch r {
	case RevealerTransitionTypeNone:
		return "None"
	case RevealerTransitionTypeCrossfade:
		return "Crossfade"
	case RevealerTransitionTypeSlideRight:
		return "SlideRight"
	case RevealerTransitionTypeSlideLeft:
		return "SlideLeft"
	case RevealerTransitionTypeSlideUp:
		return "SlideUp"
	case RevealerTransitionTypeSlideDown:
		return "SlideDown"
	case RevealerTransitionTypeSwingRight:
		return "SwingRight"
	case RevealerTransitionTypeSwingLeft:
		return "SwingLeft"
	case RevealerTransitionTypeSwingUp:
		return "SwingUp"
	case RevealerTransitionTypeSwingDown:
		return "SwingDown"
	default:
		return fmt.Sprintf("RevealerTransitionType(%d)", r)
	}
}

// ScrollStep: passed as argument to various keybinding signals.
type ScrollStep C.gint

const (
	// ScrollSteps: scroll in steps.
	ScrollSteps ScrollStep = iota
	// ScrollPages: scroll by pages.
	ScrollPages
	// ScrollEnds: scroll to ends.
	ScrollEnds
	// ScrollHorizontalSteps: scroll in horizontal steps.
	ScrollHorizontalSteps
	// ScrollHorizontalPages: scroll by horizontal pages.
	ScrollHorizontalPages
	// ScrollHorizontalEnds: scroll to the horizontal ends.
	ScrollHorizontalEnds
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollStep.
func (s ScrollStep) String() string {
	switch s {
	case ScrollSteps:
		return "Steps"
	case ScrollPages:
		return "Pages"
	case ScrollEnds:
		return "Ends"
	case ScrollHorizontalSteps:
		return "HorizontalSteps"
	case ScrollHorizontalPages:
		return "HorizontalPages"
	case ScrollHorizontalEnds:
		return "HorizontalEnds"
	default:
		return fmt.Sprintf("ScrollStep(%d)", s)
	}
}

// ScrollType: scrolling types.
type ScrollType C.gint

const (
	// ScrollNone: no scrolling.
	ScrollNone ScrollType = iota
	// ScrollJump: jump to new location.
	ScrollJump
	// ScrollStepBackward: step backward.
	ScrollStepBackward
	// ScrollStepForward: step forward.
	ScrollStepForward
	// ScrollPageBackward: page backward.
	ScrollPageBackward
	// ScrollPageForward: page forward.
	ScrollPageForward
	// ScrollStepUp: step up.
	ScrollStepUp
	// ScrollStepDown: step down.
	ScrollStepDown
	// ScrollPageUp: page up.
	ScrollPageUp
	// ScrollPageDown: page down.
	ScrollPageDown
	// ScrollStepLeft: step to the left.
	ScrollStepLeft
	// ScrollStepRight: step to the right.
	ScrollStepRight
	// ScrollPageLeft: page to the left.
	ScrollPageLeft
	// ScrollPageRight: page to the right.
	ScrollPageRight
	// ScrollStart: scroll to start.
	ScrollStart
	// ScrollEnd: scroll to end.
	ScrollEnd
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollType.
func (s ScrollType) String() string {
	switch s {
	case ScrollNone:
		return "None"
	case ScrollJump:
		return "Jump"
	case ScrollStepBackward:
		return "StepBackward"
	case ScrollStepForward:
		return "StepForward"
	case ScrollPageBackward:
		return "PageBackward"
	case ScrollPageForward:
		return "PageForward"
	case ScrollStepUp:
		return "StepUp"
	case ScrollStepDown:
		return "StepDown"
	case ScrollPageUp:
		return "PageUp"
	case ScrollPageDown:
		return "PageDown"
	case ScrollStepLeft:
		return "StepLeft"
	case ScrollStepRight:
		return "StepRight"
	case ScrollPageLeft:
		return "PageLeft"
	case ScrollPageRight:
		return "PageRight"
	case ScrollStart:
		return "Start"
	case ScrollEnd:
		return "End"
	default:
		return fmt.Sprintf("ScrollType(%d)", s)
	}
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy C.gint

const (
	// ScrollMinimum: scrollable adjustments are based on the minimum size.
	ScrollMinimum ScrollablePolicy = iota
	// ScrollNatural: scrollable adjustments are based on the natural size.
	ScrollNatural
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollablePolicy.
func (s ScrollablePolicy) String() string {
	switch s {
	case ScrollMinimum:
		return "Minimum"
	case ScrollNatural:
		return "Natural"
	default:
		return fmt.Sprintf("ScrollablePolicy(%d)", s)
	}
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode C.gint

const (
	// SelectionNone: no selection is possible.
	SelectionNone SelectionMode = iota
	// SelectionSingle: zero or one element may be selected.
	SelectionSingle
	// SelectionBrowse: exactly one element is selected. In some circumstances,
	// such as initially or during a search operation, it’s possible for no
	// element to be selected with GTK_SELECTION_BROWSE. What is really enforced
	// is that the user can’t deselect a currently selected element except by
	// selecting another element.
	SelectionBrowse
	// SelectionMultiple: any number of elements may be selected. The Ctrl key
	// may be used to enlarge the selection, and Shift key to select between the
	// focus and the child pointed to. Some widgets may also allow Click-drag to
	// select a range of elements.
	SelectionMultiple
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SelectionMode.
func (s SelectionMode) String() string {
	switch s {
	case SelectionNone:
		return "None"
	case SelectionSingle:
		return "Single"
	case SelectionBrowse:
		return "Browse"
	case SelectionMultiple:
		return "Multiple"
	default:
		return fmt.Sprintf("SelectionMode(%d)", s)
	}
}

// SensitivityType determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
type SensitivityType C.gint

const (
	// SensitivityAuto: control is made insensitive if no action can be
	// triggered.
	SensitivityAuto SensitivityType = iota
	// SensitivityOn: control is always sensitive.
	SensitivityOn
	// SensitivityOff: control is always insensitive.
	SensitivityOff
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SensitivityType.
func (s SensitivityType) String() string {
	switch s {
	case SensitivityAuto:
		return "Auto"
	case SensitivityOn:
		return "On"
	case SensitivityOff:
		return "Off"
	default:
		return fmt.Sprintf("SensitivityType(%d)", s)
	}
}

// ShortcutScope describes where GtkShortcuts added to a GtkShortcutController
// get handled.
type ShortcutScope C.gint

const (
	// ShortcutScopeLocal shortcuts are handled inside the widget the controller
	// belongs to.
	ShortcutScopeLocal ShortcutScope = iota
	// ShortcutScopeManaged shortcuts are handled by the first ancestor that is
	// a ShortcutManager.
	ShortcutScopeManaged
	// ShortcutScopeGlobal shortcuts are handled by the root widget.
	ShortcutScopeGlobal
)

func marshalShortcutScope(p uintptr) (interface{}, error) {
	return ShortcutScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ShortcutScope.
func (s ShortcutScope) String() string {
	switch s {
	case ShortcutScopeLocal:
		return "Local"
	case ShortcutScopeManaged:
		return "Managed"
	case ShortcutScopeGlobal:
		return "Global"
	default:
		return fmt.Sprintf("ShortcutScope(%d)", s)
	}
}

// ShortcutType specifies the kind of shortcut that is being described.
//
// More values may be added to this enumeration over time.
type ShortcutType C.gint

const (
	// ShortcutAccelerator: shortcut is a keyboard accelerator. The
	// GtkShortcutsShortcut:accelerator property will be used.
	ShortcutAccelerator ShortcutType = iota
	// ShortcutGesturePinch: shortcut is a pinch gesture. GTK provides an icon
	// and subtitle.
	ShortcutGesturePinch
	// ShortcutGestureStretch: shortcut is a stretch gesture. GTK provides an
	// icon and subtitle.
	ShortcutGestureStretch
	// ShortcutGestureRotateClockwise: shortcut is a clockwise rotation gesture.
	// GTK provides an icon and subtitle.
	ShortcutGestureRotateClockwise
	// ShortcutGestureRotateCounterclockwise: shortcut is a counterclockwise
	// rotation gesture. GTK provides an icon and subtitle.
	ShortcutGestureRotateCounterclockwise
	// ShortcutGestureTwoFingerSwipeLeft: shortcut is a two-finger swipe
	// gesture. GTK provides an icon and subtitle.
	ShortcutGestureTwoFingerSwipeLeft
	// ShortcutGestureTwoFingerSwipeRight: shortcut is a two-finger swipe
	// gesture. GTK provides an icon and subtitle.
	ShortcutGestureTwoFingerSwipeRight
	// ShortcutGesture: shortcut is a gesture. The GtkShortcutsShortcut:icon
	// property will be used.
	ShortcutGesture
	// ShortcutGestureSwipeLeft: shortcut is a swipe gesture. GTK provides an
	// icon and subtitle.
	ShortcutGestureSwipeLeft
	// ShortcutGestureSwipeRight: shortcut is a swipe gesture. GTK provides an
	// icon and subtitle.
	ShortcutGestureSwipeRight
)

func marshalShortcutType(p uintptr) (interface{}, error) {
	return ShortcutType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ShortcutType.
func (s ShortcutType) String() string {
	switch s {
	case ShortcutAccelerator:
		return "Accelerator"
	case ShortcutGesturePinch:
		return "GesturePinch"
	case ShortcutGestureStretch:
		return "GestureStretch"
	case ShortcutGestureRotateClockwise:
		return "GestureRotateClockwise"
	case ShortcutGestureRotateCounterclockwise:
		return "GestureRotateCounterclockwise"
	case ShortcutGestureTwoFingerSwipeLeft:
		return "GestureTwoFingerSwipeLeft"
	case ShortcutGestureTwoFingerSwipeRight:
		return "GestureTwoFingerSwipeRight"
	case ShortcutGesture:
		return "Gesture"
	case ShortcutGestureSwipeLeft:
		return "GestureSwipeLeft"
	case ShortcutGestureSwipeRight:
		return "GestureSwipeRight"
	default:
		return fmt.Sprintf("ShortcutType(%d)", s)
	}
}

// SizeGroupMode: mode of the size group determines the directions in which the
// size group affects the requested sizes of its component widgets.
type SizeGroupMode C.gint

const (
	// SizeGroupNone: group has no effect.
	SizeGroupNone SizeGroupMode = iota
	// SizeGroupHorizontal: group affects horizontal requisition.
	SizeGroupHorizontal
	// SizeGroupVertical: group affects vertical requisition.
	SizeGroupVertical
	// SizeGroupBoth: group affects both horizontal and vertical requisition.
	SizeGroupBoth
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SizeGroupMode.
func (s SizeGroupMode) String() string {
	switch s {
	case SizeGroupNone:
		return "None"
	case SizeGroupHorizontal:
		return "Horizontal"
	case SizeGroupVertical:
		return "Vertical"
	case SizeGroupBoth:
		return "Both"
	default:
		return fmt.Sprintf("SizeGroupMode(%d)", s)
	}
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode C.gint

const (
	// SizeRequestHeightForWidth: prefer height-for-width geometry management.
	SizeRequestHeightForWidth SizeRequestMode = iota
	// SizeRequestWidthForHeight: prefer width-for-height geometry management.
	SizeRequestWidthForHeight
	// SizeRequestConstantSize: don’t trade height-for-width or
	// width-for-height.
	SizeRequestConstantSize
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SizeRequestMode.
func (s SizeRequestMode) String() string {
	switch s {
	case SizeRequestHeightForWidth:
		return "HeightForWidth"
	case SizeRequestWidthForHeight:
		return "WidthForHeight"
	case SizeRequestConstantSize:
		return "ConstantSize"
	default:
		return fmt.Sprintf("SizeRequestMode(%d)", s)
	}
}

// SortType determines the direction of a sort.
type SortType C.gint

const (
	// SortAscending: sorting is in ascending order.
	SortAscending SortType = iota
	// SortDescending: sorting is in descending order.
	SortDescending
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SortType.
func (s SortType) String() string {
	switch s {
	case SortAscending:
		return "Ascending"
	case SortDescending:
		return "Descending"
	default:
		return fmt.Sprintf("SortType(%d)", s)
	}
}

// SorterChange describes changes in a sorter in more detail and allows users to
// optimize resorting.
type SorterChange C.gint

const (
	// SorterChangeDifferent: sorter change cannot be described by any of the
	// other enumeration values.
	SorterChangeDifferent SorterChange = iota
	// SorterChangeInverted: sort order was inverted. Comparisons that returned
	// GTK_ORDERING_SMALLER now return GTK_ORDERING_LARGER and vice versa.
	// Other comparisons return the same values as before.
	SorterChangeInverted
	// SorterChangeLessStrict: sorter is less strict: Comparisons may now return
	// GTK_ORDERING_EQUAL that did not do so before.
	SorterChangeLessStrict
	// SorterChangeMoreStrict: sorter is more strict: Comparisons that did
	// return GTK_ORDERING_EQUAL may not do so anymore.
	SorterChangeMoreStrict
)

func marshalSorterChange(p uintptr) (interface{}, error) {
	return SorterChange(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SorterChange.
func (s SorterChange) String() string {
	switch s {
	case SorterChangeDifferent:
		return "Different"
	case SorterChangeInverted:
		return "Inverted"
	case SorterChangeLessStrict:
		return "LessStrict"
	case SorterChangeMoreStrict:
		return "MoreStrict"
	default:
		return fmt.Sprintf("SorterChange(%d)", s)
	}
}

// SorterOrder describes the type of order that a GtkSorter may produce.
type SorterOrder C.gint

const (
	// SorterOrderPartial: partial order. Any Ordering is possible.
	SorterOrderPartial SorterOrder = iota
	// SorterOrderNone: no order, all elements are considered equal.
	// gtk_sorter_compare() will only return GTK_ORDERING_EQUAL.
	SorterOrderNone
	// SorterOrderTotal: total order. gtk_sorter_compare() will only return
	// GTK_ORDERING_EQUAL if an item is compared with itself. Two different
	// items will never cause this value to be returned.
	SorterOrderTotal
)

func marshalSorterOrder(p uintptr) (interface{}, error) {
	return SorterOrder(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SorterOrder.
func (s SorterOrder) String() string {
	switch s {
	case SorterOrderPartial:
		return "Partial"
	case SorterOrderNone:
		return "None"
	case SorterOrderTotal:
		return "Total"
	default:
		return fmt.Sprintf("SorterOrder(%d)", s)
	}
}

// SpinButtonUpdatePolicy determines whether the spin button displays values
// outside the adjustment bounds.
//
// See gtk.SpinButton.SetUpdatePolicy().
type SpinButtonUpdatePolicy C.gint

const (
	// UpdateAlways: when refreshing your SpinButton, the value is always
	// displayed.
	UpdateAlways SpinButtonUpdatePolicy = iota
	// UpdateIfValid: when refreshing your SpinButton, the value is only
	// displayed if it is valid within the bounds of the spin button's
	// adjustment.
	UpdateIfValid
)

func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
	return SpinButtonUpdatePolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SpinButtonUpdatePolicy.
func (s SpinButtonUpdatePolicy) String() string {
	switch s {
	case UpdateAlways:
		return "Always"
	case UpdateIfValid:
		return "IfValid"
	default:
		return fmt.Sprintf("SpinButtonUpdatePolicy(%d)", s)
	}
}

// SpinType values of the GtkSpinType enumeration are used to specify the change
// to make in gtk_spin_button_spin().
type SpinType C.gint

const (
	// SpinStepForward: increment by the adjustments step increment.
	SpinStepForward SpinType = iota
	// SpinStepBackward: decrement by the adjustments step increment.
	SpinStepBackward
	// SpinPageForward: increment by the adjustments page increment.
	SpinPageForward
	// SpinPageBackward: decrement by the adjustments page increment.
	SpinPageBackward
	// SpinHome: go to the adjustments lower bound.
	SpinHome
	// SpinEnd: go to the adjustments upper bound.
	SpinEnd
	// SpinUserDefined: change by a specified amount.
	SpinUserDefined
)

func marshalSpinType(p uintptr) (interface{}, error) {
	return SpinType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SpinType.
func (s SpinType) String() string {
	switch s {
	case SpinStepForward:
		return "StepForward"
	case SpinStepBackward:
		return "StepBackward"
	case SpinPageForward:
		return "PageForward"
	case SpinPageBackward:
		return "PageBackward"
	case SpinHome:
		return "Home"
	case SpinEnd:
		return "End"
	case SpinUserDefined:
		return "UserDefined"
	default:
		return fmt.Sprintf("SpinType(%d)", s)
	}
}

// StackTransitionType: possible transitions between pages in a GtkStack widget.
//
// New values may be added to this enumeration over time.
type StackTransitionType C.gint

const (
	// StackTransitionTypeNone: no transition.
	StackTransitionTypeNone StackTransitionType = iota
	// StackTransitionTypeCrossfade: cross-fade.
	StackTransitionTypeCrossfade
	// StackTransitionTypeSlideRight: slide from left to right.
	StackTransitionTypeSlideRight
	// StackTransitionTypeSlideLeft: slide from right to left.
	StackTransitionTypeSlideLeft
	// StackTransitionTypeSlideUp: slide from bottom up.
	StackTransitionTypeSlideUp
	// StackTransitionTypeSlideDown: slide from top down.
	StackTransitionTypeSlideDown
	// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order.
	StackTransitionTypeSlideLeftRight
	// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order.
	StackTransitionTypeSlideUpDown
	// StackTransitionTypeOverUp: cover the old page by sliding up.
	StackTransitionTypeOverUp
	// StackTransitionTypeOverDown: cover the old page by sliding down.
	StackTransitionTypeOverDown
	// StackTransitionTypeOverLeft: cover the old page by sliding to the left.
	StackTransitionTypeOverLeft
	// StackTransitionTypeOverRight: cover the old page by sliding to the right.
	StackTransitionTypeOverRight
	// StackTransitionTypeUnderUp: uncover the new page by sliding up.
	StackTransitionTypeUnderUp
	// StackTransitionTypeUnderDown: uncover the new page by sliding down.
	StackTransitionTypeUnderDown
	// StackTransitionTypeUnderLeft: uncover the new page by sliding to the
	// left.
	StackTransitionTypeUnderLeft
	// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right.
	StackTransitionTypeUnderRight
	// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order.
	StackTransitionTypeOverUpDown
	// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order.
	StackTransitionTypeOverDownUp
	// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order.
	StackTransitionTypeOverLeftRight
	// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order.
	StackTransitionTypeOverRightLeft
	// StackTransitionTypeRotateLeft: pretend the pages are sides of a cube and
	// rotate that cube to the left.
	StackTransitionTypeRotateLeft
	// StackTransitionTypeRotateRight: pretend the pages are sides of a cube and
	// rotate that cube to the right.
	StackTransitionTypeRotateRight
	// StackTransitionTypeRotateLeftRight: pretend the pages are sides of a
	// cube and rotate that cube to the left or right according to the children
	// order.
	StackTransitionTypeRotateLeftRight
)

func marshalStackTransitionType(p uintptr) (interface{}, error) {
	return StackTransitionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StackTransitionType.
func (s StackTransitionType) String() string {
	switch s {
	case StackTransitionTypeNone:
		return "None"
	case StackTransitionTypeCrossfade:
		return "Crossfade"
	case StackTransitionTypeSlideRight:
		return "SlideRight"
	case StackTransitionTypeSlideLeft:
		return "SlideLeft"
	case StackTransitionTypeSlideUp:
		return "SlideUp"
	case StackTransitionTypeSlideDown:
		return "SlideDown"
	case StackTransitionTypeSlideLeftRight:
		return "SlideLeftRight"
	case StackTransitionTypeSlideUpDown:
		return "SlideUpDown"
	case StackTransitionTypeOverUp:
		return "OverUp"
	case StackTransitionTypeOverDown:
		return "OverDown"
	case StackTransitionTypeOverLeft:
		return "OverLeft"
	case StackTransitionTypeOverRight:
		return "OverRight"
	case StackTransitionTypeUnderUp:
		return "UnderUp"
	case StackTransitionTypeUnderDown:
		return "UnderDown"
	case StackTransitionTypeUnderLeft:
		return "UnderLeft"
	case StackTransitionTypeUnderRight:
		return "UnderRight"
	case StackTransitionTypeOverUpDown:
		return "OverUpDown"
	case StackTransitionTypeOverDownUp:
		return "OverDownUp"
	case StackTransitionTypeOverLeftRight:
		return "OverLeftRight"
	case StackTransitionTypeOverRightLeft:
		return "OverRightLeft"
	case StackTransitionTypeRotateLeft:
		return "RotateLeft"
	case StackTransitionTypeRotateRight:
		return "RotateRight"
	case StackTransitionTypeRotateLeftRight:
		return "RotateLeftRight"
	default:
		return fmt.Sprintf("StackTransitionType(%d)", s)
	}
}

// StringFilterMatchMode specifies how search strings are matched inside text.
type StringFilterMatchMode C.gint

const (
	// StringFilterMatchModeExact: search string and text must match exactly.
	StringFilterMatchModeExact StringFilterMatchMode = iota
	// StringFilterMatchModeSubstring: search string must be contained as a
	// substring inside the text.
	StringFilterMatchModeSubstring
	// StringFilterMatchModePrefix: text must begin with the search string.
	StringFilterMatchModePrefix
)

func marshalStringFilterMatchMode(p uintptr) (interface{}, error) {
	return StringFilterMatchMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StringFilterMatchMode.
func (s StringFilterMatchMode) String() string {
	switch s {
	case StringFilterMatchModeExact:
		return "Exact"
	case StringFilterMatchModeSubstring:
		return "Substring"
	case StringFilterMatchModePrefix:
		return "Prefix"
	default:
		return fmt.Sprintf("StringFilterMatchMode(%d)", s)
	}
}

// SystemSetting values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc.
//
// The values indicate which system setting has changed. Widgets may need to
// drop caches, or react otherwise.
//
// Most of the values correspond to GtkSettings properties.
//
// More values may be added over time.
type SystemSetting C.gint

const (
	// SystemSettingDPI setting has changed.
	SystemSettingDPI SystemSetting = iota
	// SystemSettingFontName setting has changed.
	SystemSettingFontName
	// SystemSettingFontConfig: font configuration has changed in
	// a way that requires text to be redrawn. This can be any of
	// the Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings.
	SystemSettingFontConfig
	// SystemSettingDisplay: display has changed.
	SystemSettingDisplay
	// SystemSettingIconTheme: icon theme has changed in a way that requires
	// icons to be looked up again.
	SystemSettingIconTheme
)

func marshalSystemSetting(p uintptr) (interface{}, error) {
	return SystemSetting(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SystemSetting.
func (s SystemSetting) String() string {
	switch s {
	case SystemSettingDPI:
		return "DPI"
	case SystemSettingFontName:
		return "FontName"
	case SystemSettingFontConfig:
		return "FontConfig"
	case SystemSettingDisplay:
		return "Display"
	case SystemSettingIconTheme:
		return "IconTheme"
	default:
		return fmt.Sprintf("SystemSetting(%d)", s)
	}
}

// TextDirection: reading directions for text.
type TextDirection C.gint

const (
	// TextDirNone: no direction.
	TextDirNone TextDirection = iota
	// TextDirLTR: left to right text direction.
	TextDirLTR
	// TextDirRTL: right to left text direction.
	TextDirRTL
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextDirection.
func (t TextDirection) String() string {
	switch t {
	case TextDirNone:
		return "None"
	case TextDirLTR:
		return "LTR"
	case TextDirRTL:
		return "RTL"
	default:
		return fmt.Sprintf("TextDirection(%d)", t)
	}
}

// TextExtendSelection: granularity types that extend the text selection.
// Use the TextView::extend-selection signal to customize the selection.
type TextExtendSelection C.gint

const (
	// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
	TextExtendSelectionWord TextExtendSelection = iota
	// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
	TextExtendSelectionLine
)

func marshalTextExtendSelection(p uintptr) (interface{}, error) {
	return TextExtendSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextExtendSelection.
func (t TextExtendSelection) String() string {
	switch t {
	case TextExtendSelectionWord:
		return "Word"
	case TextExtendSelectionLine:
		return "Line"
	default:
		return fmt.Sprintf("TextExtendSelection(%d)", t)
	}
}

// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
type TextViewLayer C.gint

const (
	// TextViewLayerBelowText: layer rendered below the text (but above the
	// background).
	TextViewLayerBelowText TextViewLayer = iota
	// TextViewLayerAboveText: layer rendered above the text.
	TextViewLayerAboveText
)

func marshalTextViewLayer(p uintptr) (interface{}, error) {
	return TextViewLayer(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextViewLayer.
func (t TextViewLayer) String() string {
	switch t {
	case TextViewLayerBelowText:
		return "BelowText"
	case TextViewLayerAboveText:
		return "AboveText"
	default:
		return fmt.Sprintf("TextViewLayer(%d)", t)
	}
}

// TextWindowType: used to reference the parts of TextView.
type TextWindowType C.gint

const (
	// TextWindowWidget: window that floats over scrolling areas.
	TextWindowWidget TextWindowType = 1
	// TextWindowText: scrollable text window.
	TextWindowText TextWindowType = 2
	// TextWindowLeft: left side border window.
	TextWindowLeft TextWindowType = 3
	// TextWindowRight: right side border window.
	TextWindowRight TextWindowType = 4
	// TextWindowTop: top border window.
	TextWindowTop TextWindowType = 5
	// TextWindowBottom: bottom border window.
	TextWindowBottom TextWindowType = 6
)

func marshalTextWindowType(p uintptr) (interface{}, error) {
	return TextWindowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextWindowType.
func (t TextWindowType) String() string {
	switch t {
	case TextWindowWidget:
		return "Widget"
	case TextWindowText:
		return "Text"
	case TextWindowLeft:
		return "Left"
	case TextWindowRight:
		return "Right"
	case TextWindowTop:
		return "Top"
	case TextWindowBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("TextWindowType(%d)", t)
	}
}

// TreeViewColumnSizing: sizing method the column uses to determine its width.
// Please note that GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for large
// views, and can make columns appear choppy.
type TreeViewColumnSizing C.gint

const (
	// TreeViewColumnGrowOnly columns only get bigger in reaction to changes in
	// the model.
	TreeViewColumnGrowOnly TreeViewColumnSizing = iota
	// TreeViewColumnAutosize columns resize to be the optimal size every time
	// the model changes.
	TreeViewColumnAutosize
	// TreeViewColumnFixed columns are a fixed numbers of pixels wide.
	TreeViewColumnFixed
)

func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
	return TreeViewColumnSizing(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TreeViewColumnSizing.
func (t TreeViewColumnSizing) String() string {
	switch t {
	case TreeViewColumnGrowOnly:
		return "GrowOnly"
	case TreeViewColumnAutosize:
		return "Autosize"
	case TreeViewColumnFixed:
		return "Fixed"
	default:
		return fmt.Sprintf("TreeViewColumnSizing(%d)", t)
	}
}

// TreeViewDropPosition: enum for determining where a dropped row goes.
type TreeViewDropPosition C.gint

const (
	// TreeViewDropBefore: dropped row is inserted before.
	TreeViewDropBefore TreeViewDropPosition = iota
	// TreeViewDropAfter: dropped row is inserted after.
	TreeViewDropAfter
	// TreeViewDropIntoOrBefore: dropped row becomes a child or is inserted
	// before.
	TreeViewDropIntoOrBefore
	// TreeViewDropIntoOrAfter: dropped row becomes a child or is inserted
	// after.
	TreeViewDropIntoOrAfter
)

func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
	return TreeViewDropPosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TreeViewDropPosition.
func (t TreeViewDropPosition) String() string {
	switch t {
	case TreeViewDropBefore:
		return "Before"
	case TreeViewDropAfter:
		return "After"
	case TreeViewDropIntoOrBefore:
		return "IntoOrBefore"
	case TreeViewDropIntoOrAfter:
		return "IntoOrAfter"
	default:
		return fmt.Sprintf("TreeViewDropPosition(%d)", t)
	}
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines C.gint

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = iota
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TreeViewGridLines.
func (t TreeViewGridLines) String() string {
	switch t {
	case TreeViewGridLinesNone:
		return "None"
	case TreeViewGridLinesHorizontal:
		return "Horizontal"
	case TreeViewGridLinesVertical:
		return "Vertical"
	case TreeViewGridLinesBoth:
		return "Both"
	default:
		return fmt.Sprintf("TreeViewGridLines(%d)", t)
	}
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit C.gint

const (
	// UnitNone: no units.
	UnitNone Unit = iota
	// UnitPoints dimensions in points.
	UnitPoints
	// UnitInch dimensions in inches.
	UnitInch
	// UnitMm dimensions in millimeters.
	UnitMm
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Unit.
func (u Unit) String() string {
	switch u {
	case UnitNone:
		return "None"
	case UnitPoints:
		return "Points"
	case UnitInch:
		return "Inch"
	case UnitMm:
		return "Mm"
	default:
		return fmt.Sprintf("Unit(%d)", u)
	}
}

// WrapMode describes a type of line wrapping.
type WrapMode C.gint

const (
	// WrapNone: do not wrap lines; just make the text area wider.
	WrapNone WrapMode = iota
	// WrapChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs()).
	WrapChar
	// WrapWord: wrap text, breaking lines in between words.
	WrapWord
	// WrapWordChar: wrap text, breaking lines in between words, or if that is
	// not enough, also between graphemes.
	WrapWordChar
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WrapMode.
func (w WrapMode) String() string {
	switch w {
	case WrapNone:
		return "None"
	case WrapChar:
		return "Char"
	case WrapWord:
		return "Word"
	case WrapWordChar:
		return "WordChar"
	default:
		return fmt.Sprintf("WrapMode(%d)", w)
	}
}

// ApplicationInhibitFlags types of user actions that may be blocked by
// GtkApplication.
//
// See gtk.Application.Inhibit().
type ApplicationInhibitFlags C.guint

const (
	// ApplicationInhibitLogout: inhibit ending the user session by logging out
	// or by shutting down the computer.
	ApplicationInhibitLogout ApplicationInhibitFlags = 0b1
	// ApplicationInhibitSwitch: inhibit user switching.
	ApplicationInhibitSwitch ApplicationInhibitFlags = 0b10
	// ApplicationInhibitSuspend: inhibit suspending the session or computer.
	ApplicationInhibitSuspend ApplicationInhibitFlags = 0b100
	// ApplicationInhibitIdle: inhibit the session being marked as idle (and
	// possibly locked).
	ApplicationInhibitIdle ApplicationInhibitFlags = 0b1000
)

func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
	return ApplicationInhibitFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ApplicationInhibitFlags.
func (a ApplicationInhibitFlags) String() string {
	if a == 0 {
		return "ApplicationInhibitFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(98)

	for a != 0 {
		next := a & (a - 1)
		bit := a - next

		switch bit {
		case ApplicationInhibitLogout:
			builder.WriteString("Logout|")
		case ApplicationInhibitSwitch:
			builder.WriteString("Switch|")
		case ApplicationInhibitSuspend:
			builder.WriteString("Suspend|")
		case ApplicationInhibitIdle:
			builder.WriteString("Idle|")
		default:
			builder.WriteString(fmt.Sprintf("ApplicationInhibitFlags(0b%b)|", bit))
		}

		a = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if a contains other.
func (a ApplicationInhibitFlags) Has(other ApplicationInhibitFlags) bool {
	return (a & other) == other
}

// BuilderClosureFlags: list of flags that can be passed to
// gtk_builder_create_closure().
//
// New values may be added in the future for new features, so external
// implementations of gtk.BuilderScope should test the flags for unknown values
// and raise a GTK_BUILDER_ERROR_INVALID_ATTRIBUTE error when they encounter
// one.
type BuilderClosureFlags C.guint

const (
	// BuilderClosureSwapped: closure should be created swapped. See
	// g_cclosure_new_swap() for details.
	BuilderClosureSwapped BuilderClosureFlags = 0b1
)

func marshalBuilderClosureFlags(p uintptr) (interface{}, error) {
	return BuilderClosureFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for BuilderClosureFlags.
func (b BuilderClosureFlags) String() string {
	if b == 0 {
		return "BuilderClosureFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(21)

	for b != 0 {
		next := b & (b - 1)
		bit := b - next

		switch bit {
		case BuilderClosureSwapped:
			builder.WriteString("Swapped|")
		default:
			builder.WriteString(fmt.Sprintf("BuilderClosureFlags(0b%b)|", bit))
		}

		b = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if b contains other.
func (b BuilderClosureFlags) Has(other BuilderClosureFlags) bool {
	return (b & other) == other
}

// CellRendererState tells how a cell is to be rendered.
type CellRendererState C.guint

const (
	// CellRendererSelected: cell is currently selected, and probably has a
	// selection colored background to render to.
	CellRendererSelected CellRendererState = 0b1
	// CellRendererPrelit: mouse is hovering over the cell.
	CellRendererPrelit CellRendererState = 0b10
	// CellRendererInsensitive: cell is drawn in an insensitive manner.
	CellRendererInsensitive CellRendererState = 0b100
	// CellRendererSorted: cell is in a sorted row.
	CellRendererSorted CellRendererState = 0b1000
	// CellRendererFocused: cell is in the focus row.
	CellRendererFocused CellRendererState = 0b10000
	// CellRendererExpandable: cell is in a row that can be expanded.
	CellRendererExpandable CellRendererState = 0b100000
	// CellRendererExpanded: cell is in a row that is expanded.
	CellRendererExpanded CellRendererState = 0b1000000
)

func marshalCellRendererState(p uintptr) (interface{}, error) {
	return CellRendererState(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for CellRendererState.
func (c CellRendererState) String() string {
	if c == 0 {
		return "CellRendererState(0)"
	}

	var builder strings.Builder
	builder.Grow(146)

	for c != 0 {
		next := c & (c - 1)
		bit := c - next

		switch bit {
		case CellRendererSelected:
			builder.WriteString("Selected|")
		case CellRendererPrelit:
			builder.WriteString("Prelit|")
		case CellRendererInsensitive:
			builder.WriteString("Insensitive|")
		case CellRendererSorted:
			builder.WriteString("Sorted|")
		case CellRendererFocused:
			builder.WriteString("Focused|")
		case CellRendererExpandable:
			builder.WriteString("Expandable|")
		case CellRendererExpanded:
			builder.WriteString("Expanded|")
		default:
			builder.WriteString(fmt.Sprintf("CellRendererState(0b%b)|", bit))
		}

		c = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if c contains other.
func (c CellRendererState) Has(other CellRendererState) bool {
	return (c & other) == other
}

type DebugFlags C.guint

const (
	DebugText           DebugFlags = 0b1
	DebugTree           DebugFlags = 0b10
	DebugKeybindings    DebugFlags = 0b100
	DebugModules        DebugFlags = 0b1000
	DebugGeometry       DebugFlags = 0b10000
	DebugIcontheme      DebugFlags = 0b100000
	DebugPrinting       DebugFlags = 0b1000000
	DebugBuilder        DebugFlags = 0b10000000
	DebugSizeRequest    DebugFlags = 0b100000000
	DebugNoCSSCache     DebugFlags = 0b1000000000
	DebugInteractive    DebugFlags = 0b10000000000
	DebugTouchscreen    DebugFlags = 0b100000000000
	DebugActions        DebugFlags = 0b1000000000000
	DebugLayout         DebugFlags = 0b10000000000000
	DebugSnapshot       DebugFlags = 0b100000000000000
	DebugConstraints    DebugFlags = 0b1000000000000000
	DebugBuilderObjects DebugFlags = 0b10000000000000000
	DebugA11Y           DebugFlags = 0b100000000000000000
	DebugIconfallback   DebugFlags = 0b1000000000000000000
)

func marshalDebugFlags(p uintptr) (interface{}, error) {
	return DebugFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DebugFlags.
func (d DebugFlags) String() string {
	if d == 0 {
		return "DebugFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DebugText:
			builder.WriteString("Text|")
		case DebugTree:
			builder.WriteString("Tree|")
		case DebugKeybindings:
			builder.WriteString("Keybindings|")
		case DebugModules:
			builder.WriteString("Modules|")
		case DebugGeometry:
			builder.WriteString("Geometry|")
		case DebugIcontheme:
			builder.WriteString("Icontheme|")
		case DebugPrinting:
			builder.WriteString("Printing|")
		case DebugBuilder:
			builder.WriteString("Builder|")
		case DebugSizeRequest:
			builder.WriteString("SizeRequest|")
		case DebugNoCSSCache:
			builder.WriteString("NoCSSCache|")
		case DebugInteractive:
			builder.WriteString("Interactive|")
		case DebugTouchscreen:
			builder.WriteString("Touchscreen|")
		case DebugActions:
			builder.WriteString("Actions|")
		case DebugLayout:
			builder.WriteString("Layout|")
		case DebugSnapshot:
			builder.WriteString("Snapshot|")
		case DebugConstraints:
			builder.WriteString("Constraints|")
		case DebugBuilderObjects:
			builder.WriteString("BuilderObjects|")
		case DebugA11Y:
			builder.WriteString("A11Y|")
		case DebugIconfallback:
			builder.WriteString("Iconfallback|")
		default:
			builder.WriteString(fmt.Sprintf("DebugFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DebugFlags) Has(other DebugFlags) bool {
	return (d & other) == other
}

// DialogFlags flags used to influence dialog construction.
type DialogFlags C.guint

const (
	// DialogModal: make the constructed dialog modal.
	DialogModal DialogFlags = 0b1
	// DialogDestroyWithParent: destroy the dialog when its parent is destroyed.
	DialogDestroyWithParent DialogFlags = 0b10
	// DialogUseHeaderBar: create dialog with actions in header bar instead of
	// action area.
	DialogUseHeaderBar DialogFlags = 0b100
)

func marshalDialogFlags(p uintptr) (interface{}, error) {
	return DialogFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for DialogFlags.
func (d DialogFlags) String() string {
	if d == 0 {
		return "DialogFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(54)

	for d != 0 {
		next := d & (d - 1)
		bit := d - next

		switch bit {
		case DialogModal:
			builder.WriteString("Modal|")
		case DialogDestroyWithParent:
			builder.WriteString("DestroyWithParent|")
		case DialogUseHeaderBar:
			builder.WriteString("UseHeaderBar|")
		default:
			builder.WriteString(fmt.Sprintf("DialogFlags(0b%b)|", bit))
		}

		d = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if d contains other.
func (d DialogFlags) Has(other DialogFlags) bool {
	return (d & other) == other
}

// EventControllerScrollFlags describes the behavior of a
// GtkEventControllerScroll.
type EventControllerScrollFlags C.guint

const (
	// EventControllerScrollNone: don't emit scroll.
	EventControllerScrollNone EventControllerScrollFlags = 0b0
	// EventControllerScrollVertical: emit scroll with vertical deltas.
	EventControllerScrollVertical EventControllerScrollFlags = 0b1
	// EventControllerScrollHorizontal: emit scroll with horizontal deltas.
	EventControllerScrollHorizontal EventControllerScrollFlags = 0b10
	// EventControllerScrollDiscrete: only emit deltas that are multiples of 1.
	EventControllerScrollDiscrete EventControllerScrollFlags = 0b100
	// EventControllerScrollKinetic: emit ::decelerate after continuous scroll
	// finishes.
	EventControllerScrollKinetic EventControllerScrollFlags = 0b1000
	// EventControllerScrollBothAxes: emit scroll on both axes.
	EventControllerScrollBothAxes EventControllerScrollFlags = 0b11
)

func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
	return EventControllerScrollFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for EventControllerScrollFlags.
func (e EventControllerScrollFlags) String() string {
	if e == 0 {
		return "EventControllerScrollFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(176)

	for e != 0 {
		next := e & (e - 1)
		bit := e - next

		switch bit {
		case EventControllerScrollNone:
			builder.WriteString("None|")
		case EventControllerScrollVertical:
			builder.WriteString("Vertical|")
		case EventControllerScrollHorizontal:
			builder.WriteString("Horizontal|")
		case EventControllerScrollDiscrete:
			builder.WriteString("Discrete|")
		case EventControllerScrollKinetic:
			builder.WriteString("Kinetic|")
		case EventControllerScrollBothAxes:
			builder.WriteString("BothAxes|")
		default:
			builder.WriteString(fmt.Sprintf("EventControllerScrollFlags(0b%b)|", bit))
		}

		e = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if e contains other.
func (e EventControllerScrollFlags) Has(other EventControllerScrollFlags) bool {
	return (e & other) == other
}

// FontChooserLevel specifies the granularity of font selection that is desired
// in a GtkFontChooser.
//
// This enumeration may be extended in the future; applications should ignore
// unknown values.
type FontChooserLevel C.guint

const (
	// FontChooserLevelFamily: allow selecting a font family.
	FontChooserLevelFamily FontChooserLevel = 0b0
	// FontChooserLevelStyle: allow selecting a specific font face.
	FontChooserLevelStyle FontChooserLevel = 0b1
	// FontChooserLevelSize: allow selecting a specific font size.
	FontChooserLevelSize FontChooserLevel = 0b10
	// FontChooserLevelVariations: allow changing OpenType font variation axes.
	FontChooserLevelVariations FontChooserLevel = 0b100
	// FontChooserLevelFeatures: allow selecting specific OpenType font
	// features.
	FontChooserLevelFeatures FontChooserLevel = 0b1000
)

func marshalFontChooserLevel(p uintptr) (interface{}, error) {
	return FontChooserLevel(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for FontChooserLevel.
func (f FontChooserLevel) String() string {
	if f == 0 {
		return "FontChooserLevel(0)"
	}

	var builder strings.Builder
	builder.Grow(117)

	for f != 0 {
		next := f & (f - 1)
		bit := f - next

		switch bit {
		case FontChooserLevelFamily:
			builder.WriteString("Family|")
		case FontChooserLevelStyle:
			builder.WriteString("Style|")
		case FontChooserLevelSize:
			builder.WriteString("Size|")
		case FontChooserLevelVariations:
			builder.WriteString("Variations|")
		case FontChooserLevelFeatures:
			builder.WriteString("Features|")
		default:
			builder.WriteString(fmt.Sprintf("FontChooserLevel(0b%b)|", bit))
		}

		f = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if f contains other.
func (f FontChooserLevel) Has(other FontChooserLevel) bool {
	return (f & other) == other
}

// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon().
type IconLookupFlags C.guint

const (
	// IconLookupForceRegular: try to always load regular icons, even when
	// symbolic icon names are given.
	IconLookupForceRegular IconLookupFlags = 0b1
	// IconLookupForceSymbolic: try to always load symbolic icons, even when
	// regular icon names are given.
	IconLookupForceSymbolic IconLookupFlags = 0b10
	// IconLookupPreload starts loading the texture in the background so it is
	// ready when later needed.
	IconLookupPreload IconLookupFlags = 0b100
)

func marshalIconLookupFlags(p uintptr) (interface{}, error) {
	return IconLookupFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for IconLookupFlags.
func (i IconLookupFlags) String() string {
	if i == 0 {
		return "IconLookupFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(64)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case IconLookupForceRegular:
			builder.WriteString("ForceRegular|")
		case IconLookupForceSymbolic:
			builder.WriteString("ForceSymbolic|")
		case IconLookupPreload:
			builder.WriteString("Preload|")
		default:
			builder.WriteString(fmt.Sprintf("IconLookupFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i IconLookupFlags) Has(other IconLookupFlags) bool {
	return (i & other) == other
}

// InputHints describes hints that might be taken into account by input methods
// or applications.
//
// Note that input methods may already tailor their behaviour according to the
// GtkInputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints C.guint

const (
	// InputHintNone: no special behaviour suggested.
	InputHintNone InputHints = 0b0
	// InputHintSpellcheck: suggest checking for typos.
	InputHintSpellcheck InputHints = 0b1
	// InputHintNoSpellcheck: suggest not checking for typos.
	InputHintNoSpellcheck InputHints = 0b10
	// InputHintWordCompletion: suggest word completion.
	InputHintWordCompletion InputHints = 0b100
	// InputHintLowercase: suggest to convert all text to lowercase.
	InputHintLowercase InputHints = 0b1000
	// InputHintUppercaseChars: suggest to capitalize all text.
	InputHintUppercaseChars InputHints = 0b10000
	// InputHintUppercaseWords: suggest to capitalize the first character of
	// each word.
	InputHintUppercaseWords InputHints = 0b100000
	// InputHintUppercaseSentences: suggest to capitalize the first word of each
	// sentence.
	InputHintUppercaseSentences InputHints = 0b1000000
	// InputHintInhibitOSK: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintInhibitOSK InputHints = 0b10000000
	// InputHintVerticalWriting: text is vertical.
	InputHintVerticalWriting InputHints = 0b100000000
	// InputHintEmoji: suggest offering Emoji support.
	InputHintEmoji InputHints = 0b1000000000
	// InputHintNoEmoji: suggest not offering Emoji support.
	InputHintNoEmoji InputHints = 0b10000000000
	// InputHintPrivate: request that the input method should not update
	// personalized data (like typing history).
	InputHintPrivate InputHints = 0b100000000000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for InputHints.
func (i InputHints) String() string {
	if i == 0 {
		return "InputHints(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case InputHintNone:
			builder.WriteString("None|")
		case InputHintSpellcheck:
			builder.WriteString("Spellcheck|")
		case InputHintNoSpellcheck:
			builder.WriteString("NoSpellcheck|")
		case InputHintWordCompletion:
			builder.WriteString("WordCompletion|")
		case InputHintLowercase:
			builder.WriteString("Lowercase|")
		case InputHintUppercaseChars:
			builder.WriteString("UppercaseChars|")
		case InputHintUppercaseWords:
			builder.WriteString("UppercaseWords|")
		case InputHintUppercaseSentences:
			builder.WriteString("UppercaseSentences|")
		case InputHintInhibitOSK:
			builder.WriteString("InhibitOSK|")
		case InputHintVerticalWriting:
			builder.WriteString("VerticalWriting|")
		case InputHintEmoji:
			builder.WriteString("Emoji|")
		case InputHintNoEmoji:
			builder.WriteString("NoEmoji|")
		case InputHintPrivate:
			builder.WriteString("Private|")
		default:
			builder.WriteString(fmt.Sprintf("InputHints(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i InputHints) Has(other InputHints) bool {
	return (i & other) == other
}

// PickFlags flags that influence the behavior of gtk_widget_pick().
type PickFlags C.guint

const (
	// PickDefault: default behavior, include widgets that are receiving events.
	PickDefault PickFlags = 0b0
	// PickInsensitive: include widgets that are insensitive.
	PickInsensitive PickFlags = 0b1
	// PickNonTargetable: include widgets that are marked as non-targetable.
	// See Widget:can-target.
	PickNonTargetable PickFlags = 0b10
)

func marshalPickFlags(p uintptr) (interface{}, error) {
	return PickFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PickFlags.
func (p PickFlags) String() string {
	if p == 0 {
		return "PickFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(45)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PickDefault:
			builder.WriteString("Default|")
		case PickInsensitive:
			builder.WriteString("Insensitive|")
		case PickNonTargetable:
			builder.WriteString("NonTargetable|")
		default:
			builder.WriteString(fmt.Sprintf("PickFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PickFlags) Has(other PickFlags) bool {
	return (p & other) == other
}

// PopoverMenuFlags flags that affect how popover menus are created from a menu
// model.
type PopoverMenuFlags C.guint

const (
	// PopoverMenuNested: create submenus as nested popovers. Without this flag,
	// submenus are created as sliding pages that replace the main menu.
	PopoverMenuNested PopoverMenuFlags = 0b1
)

func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
	return PopoverMenuFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PopoverMenuFlags.
func (p PopoverMenuFlags) String() string {
	if p == 0 {
		return "PopoverMenuFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(17)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PopoverMenuNested:
			builder.WriteString("Nested|")
		default:
			builder.WriteString(fmt.Sprintf("PopoverMenuFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PopoverMenuFlags) Has(other PopoverMenuFlags) bool {
	return (p & other) == other
}

// ShortcutActionFlags: list of flags that can be passed to action activation.
//
// More flags may be added in the future.
type ShortcutActionFlags C.guint

const (
	// ShortcutActionExclusive: action is the only action that can be activated.
	// If this flag is not set, a future activation may select a different
	// action.
	ShortcutActionExclusive ShortcutActionFlags = 0b1
)

func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
	return ShortcutActionFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for ShortcutActionFlags.
func (s ShortcutActionFlags) String() string {
	if s == 0 {
		return "ShortcutActionFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(23)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case ShortcutActionExclusive:
			builder.WriteString("Exclusive|")
		default:
			builder.WriteString(fmt.Sprintf("ShortcutActionFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s ShortcutActionFlags) Has(other ShortcutActionFlags) bool {
	return (s & other) == other
}

// StateFlags describes a widget state.
//
// Widget states are used to match the widget against CSS pseudo-classes. Note
// that GTK extends the regular CSS classes and sometimes uses different names.
type StateFlags C.guint

const (
	// StateFlagNormal: state during normal operation.
	StateFlagNormal StateFlags = 0b0
	// StateFlagActive: widget is active.
	StateFlagActive StateFlags = 0b1
	// StateFlagPrelight: widget has a mouse pointer over it.
	StateFlagPrelight StateFlags = 0b10
	// StateFlagSelected: widget is selected.
	StateFlagSelected StateFlags = 0b100
	// StateFlagInsensitive: widget is insensitive.
	StateFlagInsensitive StateFlags = 0b1000
	// StateFlagInconsistent: widget is inconsistent.
	StateFlagInconsistent StateFlags = 0b10000
	// StateFlagFocused: widget has the keyboard focus.
	StateFlagFocused StateFlags = 0b100000
	// StateFlagBackdrop: widget is in a background toplevel window.
	StateFlagBackdrop StateFlags = 0b1000000
	// StateFlagDirLTR: widget is in left-to-right text direction.
	StateFlagDirLTR StateFlags = 0b10000000
	// StateFlagDirRTL: widget is in right-to-left text direction.
	StateFlagDirRTL StateFlags = 0b100000000
	// StateFlagLink: widget is a link.
	StateFlagLink StateFlags = 0b1000000000
	// StateFlagVisited: location the widget points to has already been visited.
	StateFlagVisited StateFlags = 0b10000000000
	// StateFlagChecked: widget is checked.
	StateFlagChecked StateFlags = 0b100000000000
	// StateFlagDropActive: widget is highlighted as a drop target for DND.
	StateFlagDropActive StateFlags = 0b1000000000000
	// StateFlagFocusVisible: widget has the visible focus.
	StateFlagFocusVisible StateFlags = 0b10000000000000
	// StateFlagFocusWithin: widget contains the keyboard focus.
	StateFlagFocusWithin StateFlags = 0b100000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StateFlags.
func (s StateFlags) String() string {
	if s == 0 {
		return "StateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StateFlagNormal:
			builder.WriteString("Normal|")
		case StateFlagActive:
			builder.WriteString("Active|")
		case StateFlagPrelight:
			builder.WriteString("Prelight|")
		case StateFlagSelected:
			builder.WriteString("Selected|")
		case StateFlagInsensitive:
			builder.WriteString("Insensitive|")
		case StateFlagInconsistent:
			builder.WriteString("Inconsistent|")
		case StateFlagFocused:
			builder.WriteString("Focused|")
		case StateFlagBackdrop:
			builder.WriteString("Backdrop|")
		case StateFlagDirLTR:
			builder.WriteString("DirLTR|")
		case StateFlagDirRTL:
			builder.WriteString("DirRTL|")
		case StateFlagLink:
			builder.WriteString("Link|")
		case StateFlagVisited:
			builder.WriteString("Visited|")
		case StateFlagChecked:
			builder.WriteString("Checked|")
		case StateFlagDropActive:
			builder.WriteString("DropActive|")
		case StateFlagFocusVisible:
			builder.WriteString("FocusVisible|")
		case StateFlagFocusWithin:
			builder.WriteString("FocusWithin|")
		default:
			builder.WriteString(fmt.Sprintf("StateFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StateFlags) Has(other StateFlags) bool {
	return (s & other) == other
}

// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string().
//
// New values may be added to this enumeration.
type StyleContextPrintFlags C.guint

const (
	// StyleContextPrintNone: default value.
	StyleContextPrintNone StyleContextPrintFlags = 0b0
	// StyleContextPrintRecurse: print the entire tree of CSS nodes starting at
	// the style context's node.
	StyleContextPrintRecurse StyleContextPrintFlags = 0b1
	// StyleContextPrintShowStyle: show the values of the CSS properties for
	// each node.
	StyleContextPrintShowStyle StyleContextPrintFlags = 0b10
	// StyleContextPrintShowChange: show information about what changes affect
	// the styles.
	StyleContextPrintShowChange StyleContextPrintFlags = 0b100
)

func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
	return StyleContextPrintFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StyleContextPrintFlags.
func (s StyleContextPrintFlags) String() string {
	if s == 0 {
		return "StyleContextPrintFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(101)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StyleContextPrintNone:
			builder.WriteString("None|")
		case StyleContextPrintRecurse:
			builder.WriteString("Recurse|")
		case StyleContextPrintShowStyle:
			builder.WriteString("ShowStyle|")
		case StyleContextPrintShowChange:
			builder.WriteString("ShowChange|")
		default:
			builder.WriteString(fmt.Sprintf("StyleContextPrintFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StyleContextPrintFlags) Has(other StyleContextPrintFlags) bool {
	return (s & other) == other
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither GTK_TEXT_SEARCH_VISIBLE_ONLY nor GTK_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags C.guint

const (
	// TextSearchVisibleOnly: search only visible data. A search match may have
	// invisible text interspersed.
	TextSearchVisibleOnly TextSearchFlags = 0b1
	// TextSearchTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchTextOnly TextSearchFlags = 0b10
	// TextSearchCaseInsensitive: text will be matched regardless of what case
	// it is in.
	TextSearchCaseInsensitive TextSearchFlags = 0b100
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TextSearchFlags.
func (t TextSearchFlags) String() string {
	if t == 0 {
		return "TextSearchFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(66)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TextSearchVisibleOnly:
			builder.WriteString("VisibleOnly|")
		case TextSearchTextOnly:
			builder.WriteString("TextOnly|")
		case TextSearchCaseInsensitive:
			builder.WriteString("CaseInsensitive|")
		default:
			builder.WriteString(fmt.Sprintf("TextSearchFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TextSearchFlags) Has(other TextSearchFlags) bool {
	return (t & other) == other
}

// TreeModelFlags: these flags indicate various properties of a TreeModel.
//
// They are returned by gtk_tree_model_get_flags(), and must be static
// for the lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
type TreeModelFlags C.guint

const (
	// TreeModelItersPersist iterators survive all signals emitted by the tree.
	TreeModelItersPersist TreeModelFlags = 0b1
	// TreeModelListOnly: model is a list only, and never has children.
	TreeModelListOnly TreeModelFlags = 0b10
)

func marshalTreeModelFlags(p uintptr) (interface{}, error) {
	return TreeModelFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TreeModelFlags.
func (t TreeModelFlags) String() string {
	if t == 0 {
		return "TreeModelFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(39)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TreeModelItersPersist:
			builder.WriteString("ItersPersist|")
		case TreeModelListOnly:
			builder.WriteString("ListOnly|")
		default:
			builder.WriteString(fmt.Sprintf("TreeModelFlags(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TreeModelFlags) Has(other TreeModelFlags) bool {
	return (t & other) == other
}

// AssistantPageFunc: type of callback used to calculate the next page in a
// GtkAssistant.
//
// It’s called both for computing the next page when the user presses the
// “forward” button and for handling the behavior of the “last” button.
//
// See gtk.Assistant.SetForwardPageFunc().
type AssistantPageFunc func(currentPage int) (gint int)

// CellAllocCallback: type of the callback functions used for iterating
// over the cell renderers and their allocated areas inside a CellArea,
// see gtk_cell_area_foreach_alloc().
type CellAllocCallback func(renderer CellRendererer, cellArea, cellBackground *gdk.Rectangle) (ok bool)

// CellCallback: type of the callback functions used for iterating over the cell
// renderers of a CellArea, see gtk_cell_area_foreach().
type CellCallback func(renderer CellRendererer) (ok bool)

// CellLayoutDataFunc: function which should set the value of cell_layout’s cell
// renderer(s) as appropriate.
type CellLayoutDataFunc func(cellLayout CellLayouter, cell CellRendererer, treeModel TreeModeller, iter *TreeIter)

// CustomFilterFunc: user function that is called to determine if the item
// should be matched.
//
// If the filter matches the item, this function must return TRUE. If the item
// should be filtered out, FALSE must be returned.
type CustomFilterFunc func(item *coreglib.Object) (ok bool)

// DrawingAreaDrawFunc: whenever drawing_area needs to redraw, this function
// will be called.
//
// This function should exclusively redraw the contents of the drawing area and
// must not call any widget functions that cause changes.
type DrawingAreaDrawFunc func(drawingArea *DrawingArea, cr *cairo.Context, width, height int)

// EntryCompletionMatchFunc: function which decides whether the row indicated
// by iter matches a given key, and should be displayed as a possible completion
// for key.
//
// Note that key is normalized and case-folded (see g_utf8_normalize() and
// g_utf8_casefold()). If this is not appropriate, match functions have
// access to the unmodified key via gtk_editable_get_text (GTK_EDITABLE
// (gtk_entry_completion_get_entry ())).
type EntryCompletionMatchFunc func(completion *EntryCompletion, key string, iter *TreeIter) (ok bool)

// ExpressionNotify: callback called by gtk_expression_watch() when the
// expression value changes.
type ExpressionNotify func()

// FlowBoxCreateWidgetFunc: called for flow boxes that are bound to a
// GListModel.
//
// This function is called for each item that gets added to the model.
type FlowBoxCreateWidgetFunc func(item *coreglib.Object) (widget Widgetter)

// FlowBoxFilterFunc: function that will be called whenever a child changes or
// is added.
//
// It lets you control if the child should be visible or not.
type FlowBoxFilterFunc func(child *FlowBoxChild) (ok bool)

// FlowBoxForEachFunc: function used by gtk_flow_box_selected_foreach().
//
// It will be called on every selected child of the box.
type FlowBoxForEachFunc func(box *FlowBox, child *FlowBoxChild)

// FlowBoxSortFunc: function to compare two children to determine which should
// come first.
type FlowBoxSortFunc func(child1, child2 *FlowBoxChild) (gint int)

// FontFilterFunc: type of function that is used for deciding what fonts get
// shown in a GtkFontChooser.
//
// See gtk.FontChooser.SetFilterFunc().
type FontFilterFunc func(family pango.FontFamilier, face pango.FontFacer) (ok bool)

// IconViewForEachFunc: function used by gtk_icon_view_selected_foreach() to map
// all selected rows.
//
// It will be called on every selected row in the view.
type IconViewForEachFunc func(iconView *IconView, path *TreePath)

// ListBoxCreateWidgetFunc: called for list boxes that are bound to a GListModel
// with gtk_list_box_bind_model() for each item that gets added to the model.
type ListBoxCreateWidgetFunc func(item *coreglib.Object) (widget Widgetter)

// ListBoxFilterFunc will be called whenever the row changes or is added and
// lets you control if the row should be visible or not.
type ListBoxFilterFunc func(row *ListBoxRow) (ok bool)

// ListBoxForEachFunc: function used by gtk_list_box_selected_foreach().
//
// It will be called on every selected child of the box.
type ListBoxForEachFunc func(box *ListBox, row *ListBoxRow)

// ListBoxSortFunc: compare two rows to determine which should be first.
type ListBoxSortFunc func(row1, row2 *ListBoxRow) (gint int)

// ListBoxUpdateHeaderFunc: whenever row changes or which row is before row
// changes this is called, which lets you update the header on row.
//
// You may remove or set a new one via gtk.ListBoxRow.SetHeader() or just change
// the state of the current header widget.
type ListBoxUpdateHeaderFunc func(row, before *ListBoxRow)

// MapListModelMapFunc: user function that is called to map an item of the
// original model to an item expected by the map model.
//
// The returned items must conform to the item type of the model they are used
// with.
type MapListModelMapFunc func(item *coreglib.Object) (object *coreglib.Object)

// MenuButtonCreatePopupFunc: user-provided callback function to create a popup
// for a GtkMenuButton on demand.
//
// This function is called when the popup of menu_button is shown,
// but none has been provided via gtk.MenuButton.SetPopover() or
// gtk.MenuButton.SetMenuModel().
type MenuButtonCreatePopupFunc func(menuButton *MenuButton)

// PageSetupDoneFunc: type of function that is passed to
// gtk_print_run_page_setup_dialog_async().
//
// This function will be called when the page setup dialog is dismissed,
// and also serves as destroy notify for data.
type PageSetupDoneFunc func(pageSetup *PageSetup)

type PrintSettingsFunc func(key, value string)

type ScaleFormatValueFunc func(scale *Scale, value float64) (utf8 string)

// ShortcutFunc: prototype for shortcuts based on user callbacks.
type ShortcutFunc func(widget Widgetter, args *glib.Variant) (ok bool)

// TextCharPredicate: predicate function used by
// gtk_text_iter_forward_find_char() and gtk_text_iter_backward_find_char().
type TextCharPredicate func(ch uint32) (ok bool)

// TextTagTableForEach: function used with gtk_text_tag_table_foreach(),
// to iterate over every GtkTextTag inside a GtkTextTagTable.
type TextTagTableForEach func(tag *TextTag)

// TickCallback: callback type for adding a function to update animations.
// See gtk_widget_add_tick_callback().
type TickCallback func(widget Widgetter, frameClock gdk.FrameClocker) (ok bool)

// TreeCellDataFunc: function to set the properties of a cell instead of just
// using the straight mapping between the cell and the model.
//
// This function is useful for customizing the cell renderer. For example,
// a function might get an* integer from the tree_model, and render it to the
// “text” attribute of “cell” by converting it to its written equivalent.
//
// See also: gtk_tree_view_column_set_cell_data_func().
type TreeCellDataFunc func(treeColumn *TreeViewColumn, cell CellRendererer, treeModel TreeModeller, iter *TreeIter)

// TreeIterCompareFunc should return a negative integer, zero, or a positive
// integer if a sorts before b, a sorts with b, or a sorts after b respectively.
//
// If two iters compare as equal, their order in the sorted model is
// undefined. In order to ensure that the TreeSortable behaves as expected,
// the GtkTreeIterCompareFunc must define a partial order on the model, i.e.
// it must be reflexive, antisymmetric and transitive.
//
// For example, if model is a product catalogue, then a compare function for the
// “price” column could be one which returns price_of(a) - price_of(b).
type TreeIterCompareFunc func(model TreeModeller, a, b *TreeIter) (gint int)

// TreeListModelCreateModelFunc: prototype of the function called to create new
// child models when gtk_tree_list_row_set_expanded() is called.
//
// This function can return NULL to indicate that item is guaranteed to be a
// leaf node and will never have children. If it does not have children but
// may get children later, it should return an empty model that is filled once
// children arrive.
type TreeListModelCreateModelFunc func(item *coreglib.Object) (listModel *gio.ListModel)

// TreeModelFilterModifyFunc: function which calculates display values from raw
// values in the model. It must fill value with the display value for the column
// column in the row indicated by iter.
//
// Since this function is called for each data access, it’s not a particularly
// efficient operation.
type TreeModelFilterModifyFunc func(model TreeModeller, iter *TreeIter, column int) (value coreglib.Value)

// TreeModelFilterVisibleFunc: function which decides whether the row indicated
// by iter is visible.
type TreeModelFilterVisibleFunc func(model TreeModeller, iter *TreeIter) (ok bool)

// TreeModelForEachFunc: type of the callback passed to gtk_tree_model_foreach()
// to iterate over the rows in a tree model.
type TreeModelForEachFunc func(model TreeModeller, path *TreePath, iter *TreeIter) (ok bool)

// TreeSelectionForEachFunc: function used by
// gtk_tree_selection_selected_foreach() to map all selected rows. It will be
// called on every selected row in the view.
type TreeSelectionForEachFunc func(model TreeModeller, path *TreePath, iter *TreeIter)

// TreeSelectionFunc: function used by gtk_tree_selection_set_select_function()
// to filter whether or not a row may be selected. It is called whenever a row's
// state might change.
//
// A return value of TRUE indicates to selection that it is okay to change the
// selection.
type TreeSelectionFunc func(selection *TreeSelection, model TreeModeller, path *TreePath, pathCurrentlySelected bool) (ok bool)

// TreeViewColumnDropFunc: function type for determining whether column can be
// dropped in a particular spot (as determined by prev_column and next_column).
// In left to right locales, prev_column is on the left of the potential
// drop spot, and next_column is on the right. In right to left mode, this is
// reversed. This function should return TRUE if the spot is a valid drop spot.
// Please note that returning TRUE does not actually indicate that the column
// drop was made, but is meant only to indicate a possible drop spot to the
// user.
type TreeViewColumnDropFunc func(treeView *TreeView, column, prevColumn, nextColumn *TreeViewColumn) (ok bool)

// TreeViewMappingFunc: function used for gtk_tree_view_map_expanded_rows().
type TreeViewMappingFunc func(treeView *TreeView, path *TreePath)

// TreeViewRowSeparatorFunc: function type for determining whether the row
// pointed to by iter should be rendered as a separator. A common way to
// implement this is to have a boolean column in the model, whose values the
// TreeViewRowSeparatorFunc returns.
type TreeViewRowSeparatorFunc func(model TreeModeller, iter *TreeIter) (ok bool)

// TreeViewSearchEqualFunc: function used for checking whether a row in model
// matches a search key string entered by the user. Note the return value is
// reversed from what you would normally expect, though it has some similarity
// to strcmp() returning 0 for equal strings.
type TreeViewSearchEqualFunc func(model TreeModeller, column int, key string, iter *TreeIter) (ok bool)

// AcceleratorGetDefaultModMask gets the modifier mask.
//
// The modifier mask determines which modifiers are considered significant
// for keyboard accelerators. This includes all keyboard modifiers except for
// GDK_LOCK_MASK.
//
// The function returns the following values:
//
//   - modifierType: modifier mask for accelerators.
func AcceleratorGetDefaultModMask() gdk.ModifierType {
	var _cret C.GdkModifierType // in

	_cret = C.gtk_accelerator_get_default_mod_mask()

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// AcceleratorGetLabel converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
//
// The function takes the following parameters:
//
//   - acceleratorKey: accelerator keyval.
//   - acceleratorMods: accelerator modifier mask.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string representing the accelerator.
func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret *C.char           // in

	_arg1 = C.guint(acceleratorKey)
	_arg2 = C.GdkModifierType(acceleratorMods)

	_cret = C.gtk_accelerator_get_label(_arg1, _arg2)
	runtime.KeepAlive(acceleratorKey)
	runtime.KeepAlive(acceleratorMods)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorGetLabelWithKeycode converts an accelerator keyval and modifier
// mask into a string that can be displayed to the user.
//
// The string may be translated.
//
// This function is similar to gtk.AcceleratorGetLabel(), but handling keycodes.
//
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// The function takes the following parameters:
//
//   - display (optional) or NULL to use the default display.
//   - acceleratorKey: accelerator keyval.
//   - keycode: accelerator keycode.
//   - acceleratorMods: accelerator modifier mask.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string representing the accelerator.
func AcceleratorGetLabelWithKeycode(display *gdk.Display, acceleratorKey, keycode uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 *C.GdkDisplay     // out
	var _arg2 C.guint           // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _cret *C.char           // in

	if display != nil {
		_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	}
	_arg2 = C.guint(acceleratorKey)
	_arg3 = C.guint(keycode)
	_arg4 = C.GdkModifierType(acceleratorMods)

	_cret = C.gtk_accelerator_get_label_with_keycode(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(display)
	runtime.KeepAlive(acceleratorKey)
	runtime.KeepAlive(keycode)
	runtime.KeepAlive(acceleratorMods)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorName converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse().
//
// For example, if you pass in GDK_KEY_q and GDK_CONTROL_MASK, this function
// returns <Control>q.
//
// If you need to display accelerators in the user interface, see
// gtk.AcceleratorGetLabel().
//
// The function takes the following parameters:
//
//   - acceleratorKey: accelerator keyval.
//   - acceleratorMods: accelerator modifier mask.
//
// The function returns the following values:
//
//   - utf8: newly-allocated accelerator name.
func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret *C.char           // in

	_arg1 = C.guint(acceleratorKey)
	_arg2 = C.GdkModifierType(acceleratorMods)

	_cret = C.gtk_accelerator_name(_arg1, _arg2)
	runtime.KeepAlive(acceleratorKey)
	runtime.KeepAlive(acceleratorMods)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorNameWithKeycode converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode().
//
// This is similar to gtk.AcceleratorName() but handling keycodes.
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// The function takes the following parameters:
//
//   - display (optional) or NULL to use the default display.
//   - acceleratorKey: accelerator keyval.
//   - keycode: accelerator keycode.
//   - acceleratorMods: accelerator modifier mask.
//
// The function returns the following values:
//
//   - utf8: newly allocated accelerator name.
func AcceleratorNameWithKeycode(display *gdk.Display, acceleratorKey, keycode uint, acceleratorMods gdk.ModifierType) string {
	var _arg1 *C.GdkDisplay     // out
	var _arg2 C.guint           // out
	var _arg3 C.guint           // out
	var _arg4 C.GdkModifierType // out
	var _cret *C.char           // in

	if display != nil {
		_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	}
	_arg2 = C.guint(acceleratorKey)
	_arg3 = C.guint(keycode)
	_arg4 = C.GdkModifierType(acceleratorMods)

	_cret = C.gtk_accelerator_name_with_keycode(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(display)
	runtime.KeepAlive(acceleratorKey)
	runtime.KeepAlive(keycode)
	runtime.KeepAlive(acceleratorMods)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// AcceleratorParse parses a string representing an accelerator.
//
// The format looks like “<Control>a” or “<Shift><Alt>F1”.
//
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as “<Ctl>” and “<Ctrl>”. Key names are parsed using
// gdk.KeyvalFromName(). For character keys the name is not the symbol, but the
// lowercase name, e.g. one would use “<Ctrl>minus” instead of “<Ctrl>-”.
//
// If the parse fails, accelerator_key and accelerator_mods will be set to 0
// (zero).
//
// The function takes the following parameters:
//
//   - accelerator: string representing an accelerator.
//
// The function returns the following values:
//
//   - acceleratorKey (optional): return location for accelerator keyval,
//     or NULL.
//   - acceleratorMods (optional): return location for accelerator modifier
//     mask, NULL.
//   - ok
func AcceleratorParse(accelerator string) (uint, gdk.ModifierType, bool) {
	var _arg1 *C.char           // out
	var _arg2 C.guint           // in
	var _arg3 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_accelerator_parse(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(accelerator)

	var _acceleratorKey uint              // out
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = uint(_arg2)
	_acceleratorMods = gdk.ModifierType(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorMods, _ok
}

// AcceleratorParseWithKeycode parses a string representing an accelerator.
//
// This is similar to gtk.AcceleratorParse() but handles keycodes as well.
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
//
// If accelerator_codes is given and the result stored in it is non-NULL,
// the result must be freed with g_free().
//
// If a keycode is present in the accelerator and no accelerator_codes is given,
// the parse will fail.
//
// If the parse fails, accelerator_key, accelerator_mods and accelerator_codes
// will be set to 0 (zero).
//
// The function takes the following parameters:
//
//   - accelerator: string representing an accelerator.
//   - display (optional) to look up accelerator_codes in.
//
// The function returns the following values:
//
//   - acceleratorKey (optional): return location for accelerator keyval,
//     or NULL.
//   - acceleratorCodes (optional): return location for accelerator keycodes,
//     or NULL.
//   - acceleratorMods (optional): return location for accelerator modifier
//     mask, NULL.
//   - ok: TRUE if parsing succeeded.
func AcceleratorParseWithKeycode(accelerator string, display *gdk.Display) (uint, []uint, gdk.ModifierType, bool) {
	var _arg1 *C.char           // out
	var _arg2 *C.GdkDisplay     // out
	var _arg3 C.guint           // in
	var _arg4 *C.guint          // in
	var _arg5 C.GdkModifierType // in
	var _cret C.gboolean        // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_arg1))
	if display != nil {
		_arg2 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	}

	_cret = C.gtk_accelerator_parse_with_keycode(_arg1, _arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(accelerator)
	runtime.KeepAlive(display)

	var _acceleratorKey uint              // out
	var _acceleratorCodes []uint          // out
	var _acceleratorMods gdk.ModifierType // out
	var _ok bool                          // out

	_acceleratorKey = uint(_arg3)
	if _arg4 != nil {
		defer C.free(unsafe.Pointer(_arg4))
		{
			var i int
			var z C.guint
			for p := _arg4; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_arg4, i)
			_acceleratorCodes = make([]uint, i)
			for i := range src {
				_acceleratorCodes[i] = uint(src[i])
			}
		}
	}
	_acceleratorMods = gdk.ModifierType(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _acceleratorKey, _acceleratorCodes, _acceleratorMods, _ok
}

// AcceleratorValid determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator.
//
// For example, the GDK_KEY_a keyval plus GDK_CONTROL_MASK mark is valid,
// and matches the “Ctrl+a” accelerator. But, you can't, for instance, use the
// GDK_KEY_Control_L keyval as an accelerator.
//
// The function takes the following parameters:
//
//   - keyval: GDK keyval.
//   - modifiers: modifier mask.
//
// The function returns the following values:
//
//   - ok: TRUE if the accelerator is valid.
func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
	var _arg1 C.guint           // out
	var _arg2 C.GdkModifierType // out
	var _cret C.gboolean        // in

	_arg1 = C.guint(keyval)
	_arg2 = C.GdkModifierType(modifiers)

	_cret = C.gtk_accelerator_valid(_arg1, _arg2)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(modifiers)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CheckVersion checks that the GTK library in use is compatible with the given
// version.
//
// Generally you would pass in the constants GTK_MAJOR_VERSION,
// GTK_MINOR_VERSION, GTK_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK the application or module was compiled against.
//
// Compatibility is defined by two things: first the
// version of the running library is newer than the version
// required_major.required_minor.required_micro. Second the
// running library must be binary compatible with the version
// required_major.required_minor.required_micro (same major version.)
//
// This function is primarily for GTK modules; the module can call this
// function to check that it wasn’t loaded into an incompatible version of GTK.
// However, such a check isn’t completely reliable, since the module may
// be linked against an old version of GTK and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK.
//
// The function takes the following parameters:
//
//   - requiredMajor: required major version.
//   - requiredMinor: required minor version.
//   - requiredMicro: required micro version.
//
// The function returns the following values:
//
//   - utf8 (optional): NULL if the GTK library is compatible with the given
//     version, or a string describing the version mismatch. The returned string
//     is owned by GTK and should not be modified or freed.
func CheckVersion(requiredMajor, requiredMinor, requiredMicro uint) string {
	var _arg1 C.guint // out
	var _arg2 C.guint // out
	var _arg3 C.guint // out
	var _cret *C.char // in

	_arg1 = C.guint(requiredMajor)
	_arg2 = C.guint(requiredMinor)
	_arg3 = C.guint(requiredMicro)

	_cret = C.gtk_check_version(_arg1, _arg2, _arg3)
	runtime.KeepAlive(requiredMajor)
	runtime.KeepAlive(requiredMinor)
	runtime.KeepAlive(requiredMicro)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

func CSSParserErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_css_parser_error_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

func CSSParserWarningQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.gtk_css_parser_warning_quark()

	var _quark glib.Quark // out

	_quark = glib.Quark(_cret)

	return _quark
}

// DisableSetlocale prevents gtk_init and gtk_init_check from automatically
// calling setlocale (LC_ALL, "").
//
// You would want to use this function if you wanted to set the locale for your
// program to something other than the user’s locale, or if you wanted to set
// different values for different locale categories.
//
// Most programs should not need to call this function.
func DisableSetlocale() {
	C.gtk_disable_setlocale()
}

// DistributeNaturalAllocation distributes extra_space to child sizes by
// bringing smaller children up to natural size first.
//
// The remaining space will be added to the minimum_size member of the
// GtkRequestedSize struct. If all sizes reach their natural size then the
// remaining space is returned.
//
// The function takes the following parameters:
//
//   - extraSpace: extra space to redistribute among children after subtracting
//     minimum sizes and any child padding from the overall allocation.
//   - sizes: array of structs with a client pointer and a minimum/natural size
//     in the orientation of the allocation.
//
// The function returns the following values:
//
//   - gint: remainder of extra_space after redistributing space to sizes.
func DistributeNaturalAllocation(extraSpace int, sizes []RequestedSize) int {
	var _arg1 C.int               // out
	var _arg3 *C.GtkRequestedSize // out
	var _arg2 C.guint
	var _cret C.int // in

	_arg1 = C.int(extraSpace)
	_arg2 = (C.guint)(len(sizes))
	_arg3 = (*C.GtkRequestedSize)(C.calloc(C.size_t(len(sizes)), C.size_t(C.sizeof_GtkRequestedSize)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GtkRequestedSize)(_arg3), len(sizes))
		for i := range sizes {
			out[i] = *(*C.GtkRequestedSize)(gextras.StructNative(unsafe.Pointer((&sizes[i]))))
		}
	}

	_cret = C.gtk_distribute_natural_allocation(_arg1, _arg2, _arg3)
	runtime.KeepAlive(extraSpace)
	runtime.KeepAlive(sizes)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// GetBinaryAge returns the binary age as passed to libtool.
//
// If libtool means nothing to you, don't worry about it.
//
// The function returns the following values:
//
//   - guint: binary age of the GTK library.
func GetBinaryAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_binary_age()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetDebugFlags returns the GTK debug flags that are currently active.
//
// This function is intended for GTK modules that want to adjust their debug
// output based on GTK debug flags.
//
// The function returns the following values:
//
//   - debugFlags: GTK debug flags.
func GetDebugFlags() DebugFlags {
	var _cret C.GtkDebugFlags // in

	_cret = C.gtk_get_debug_flags()

	var _debugFlags DebugFlags // out

	_debugFlags = DebugFlags(_cret)

	return _debugFlags
}

// GetDefaultLanguage returns the Language for the default language currently
// in effect. (Note that this can change over the life of an application.)
// The default language is derived from the current locale. It determines, for
// example, whether GTK uses the right-to-left or left-to-right text direction.
//
// This function is equivalent to pango_language_get_default(). See that
// function for details.
//
// The function returns the following values:
//
//   - language: default language as a Language, must not be freed.
func GetDefaultLanguage() *pango.Language {
	var _cret *C.PangoLanguage // in

	_cret = C.gtk_get_default_language()

	var _language *pango.Language // out

	_language = (*pango.Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _language
}

// GetInterfaceAge returns the interface age as passed to libtool.
//
// If libtool means nothing to you, don't worry about it.
//
// The function returns the following values:
//
//   - guint: interface age of the GTK library.
func GetInterfaceAge() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_interface_age()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
//
// This function depends on the current locale being set with setlocale()
// and will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
//
// GTK sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direction.
//
// This function is only needed rare cases when the locale is changed after
// GTK has already been initialized. In this case, you can use it to update the
// default text direction as follows:
//
//	setlocale (LC_ALL, new_locale);
//	direction = gtk_get_locale_direction ();
//	gtk_widget_set_default_direction (direction);.
//
// The function returns the following values:
//
//   - textDirection of the current locale.
func GetLocaleDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_get_locale_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// GetMajorVersion returns the major version number of the GTK library.
//
// For example, in GTK version 3.1.5 this is 3.
//
// This function is in the library, so it represents the GTK library your
// code is running against. Contrast with the GTK_MAJOR_VERSION macro,
// which represents the major version of the GTK headers you have included when
// compiling your code.
//
// The function returns the following values:
//
//   - guint: major version number of the GTK library.
func GetMajorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_major_version()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetMicroVersion returns the micro version number of the GTK library.
//
// For example, in GTK version 3.1.5 this is 5.
//
// This function is in the library, so it represents the GTK library your
// code is are running against. Contrast with the GTK_MICRO_VERSION macro,
// which represents the micro version of the GTK headers you have included when
// compiling your code.
//
// The function returns the following values:
//
//   - guint: micro version number of the GTK library.
func GetMicroVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_micro_version()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// GetMinorVersion returns the minor version number of the GTK library.
//
// For example, in GTK version 3.1.5 this is 1.
//
// This function is in the library, so it represents the GTK library your
// code is are running against. Contrast with the GTK_MINOR_VERSION macro,
// which represents the minor version of the GTK headers you have included when
// compiling your code.
//
// The function returns the following values:
//
//   - guint: minor version number of the GTK library.
func GetMinorVersion() uint {
	var _cret C.guint // in

	_cret = C.gtk_get_minor_version()

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// HSVToRGB converts a color from HSV space to RGB.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
//
// The function takes the following parameters:
//
//   - h: hue.
//   - s: saturation.
//   - v: value.
//
// The function returns the following values:
//
//   - r: return value for the red component.
//   - g: return value for the green component.
//   - b: return value for the blue component.
func HSVToRGB(h, s, v float32) (r, g, b float32) {
	var _arg1 C.float // out
	var _arg2 C.float // out
	var _arg3 C.float // out
	var _arg4 C.float // in
	var _arg5 C.float // in
	var _arg6 C.float // in

	_arg1 = C.float(h)
	_arg2 = C.float(s)
	_arg3 = C.float(v)

	C.gtk_hsv_to_rgb(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(h)
	runtime.KeepAlive(s)
	runtime.KeepAlive(v)

	var _r float32 // out
	var _g float32 // out
	var _b float32 // out

	_r = float32(_arg4)
	_g = float32(_arg5)
	_b = float32(_arg6)

	return _r, _g, _b
}

// Init: call this function before using any other GTK functions in your GUI
// applications. It will initialize everything needed to operate the toolkit and
// parses some standard command line options.
//
// If you are using Application, you don't have to call gtk_init() or
// gtk_init_check(); the #GApplication::startup handler does it for you.
//
// This function will terminate your program if it was unable to initialize the
// windowing system for some reason. If you want your program to fall back to a
// textual interface you want to call gtk_init_check() instead.
//
// GTK calls signal (SIGPIPE, SIG_IGN) during initialization, to ignore SIGPIPE
// signals, since these are almost never wanted in graphical applications.
// If you do need to handle SIGPIPE for some reason, reset the handler after
// gtk_init(), but notice that other libraries (e.g. libdbus or gvfs) might do
// similar things.
func Init() {
	C.gtk_init()
}

// InitCheck: this function does the same work as gtk_init() with only a single
// change: It does not terminate the program if the windowing system can’t be
// initialized. Instead it returns FALSE on failure.
//
// This way the application can fall back to some other means of communication
// with the user - for example a curses or command line interface.
//
// The function returns the following values:
//
//   - ok: TRUE if the windowing system has been successfully initialized,
//     FALSE otherwise.
func InitCheck() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_init_check()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsInitialized: use this function to check if GTK has been initialized with
// gtk_init() or gtk_init_check().
//
// The function returns the following values:
//
//   - ok: initialization status.
func IsInitialized() bool {
	var _cret C.gboolean // in

	_cret = C.gtk_is_initialized()

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify
// the values from page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in page_setup, otherwise it contains the
// modifications done in the dialog.
//
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
//
// The function takes the following parameters:
//
//   - parent (optional): transient parent.
//   - pageSetup (optional): existing PageSetup.
//   - settings: PrintSettings.
//
// The function returns the following values:
//
//   - pageSetup: new PageSetup.
func PrintRunPageSetupDialog(parent *Window, pageSetup *PageSetup, settings *PrintSettings) *PageSetup {
	var _arg1 *C.GtkWindow        // out
	var _arg2 *C.GtkPageSetup     // out
	var _arg3 *C.GtkPrintSettings // out
	var _cret *C.GtkPageSetup     // in

	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	if pageSetup != nil {
		_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(pageSetup).Native()))
	}
	_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_run_page_setup_dialog(_arg1, _arg2, _arg3)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(pageSetup)
	runtime.KeepAlive(settings)

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// PrintRunPageSetupDialogAsync runs a page setup dialog, letting the user
// modify the values from page_setup.
//
// In contrast to gtk_print_run_page_setup_dialog(), this function returns
// after showing the page setup dialog on platforms that support this, and calls
// done_cb from a signal handler for the ::response signal of the dialog.
//
// The function takes the following parameters:
//
//   - parent (optional): transient parent, or NULL.
//   - pageSetup (optional): existing PageSetup, or NULL.
//   - settings: PrintSettings.
//   - doneCb: function to call when the user saves the modified page setup.
func PrintRunPageSetupDialogAsync(parent *Window, pageSetup *PageSetup, settings *PrintSettings, doneCb PageSetupDoneFunc) {
	var _arg1 *C.GtkWindow           // out
	var _arg2 *C.GtkPageSetup        // out
	var _arg3 *C.GtkPrintSettings    // out
	var _arg4 C.GtkPageSetupDoneFunc // out
	var _arg5 C.gpointer

	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	if pageSetup != nil {
		_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(pageSetup).Native()))
	}
	_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg4 = (*[0]byte)(C._gotk4_gtk4_PageSetupDoneFunc)
	_arg5 = C.gpointer(gbox.AssignOnce(doneCb))

	C.gtk_print_run_page_setup_dialog_async(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(pageSetup)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(doneCb)
}

// RenderActivity renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderActivity(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_activity(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderArrow renders an arrow pointing to angle.
//
// Typical arrow rendering at 0, 1⁄2 π;, π; and 3⁄2 π:
//
// ! (arrows.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - angle: arrow angle from 0 to 2 * G_PI, being 0 the arrow pointing to the
//     north.
//   - x: x origin of the render area.
//   - y: y origin of the render area.
//   - size: square side for render area.
func RenderArrow(context *StyleContext, cr *cairo.Context, angle, x, y, size float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(angle)
	_arg4 = C.double(x)
	_arg5 = C.double(y)
	_arg6 = C.double(size)

	C.gtk_render_arrow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(angle)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(size)
}

// RenderBackground renders the background of an element.
//
// Typical background rendering, showing the effect of background-image,
// border-width and border-radius:
//
// ! (background.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderBackground(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_background(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderCheck renders a checkmark (as in a CheckButton).
//
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
//
// Typical checkmark rendering:
//
// ! (checks.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderCheck(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_check(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderExpander renders an expander (as used in TreeView and Expander) in
// the area defined by x, y, width, height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
//
// Typical expander rendering:
//
// ! (expanders.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderExpander(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_expander(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderFocus renders a focus indicator on the rectangle determined by x, y,
// width, height.
//
// Typical focus rendering:
//
// ! (focus.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderFocus(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_focus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderFrame renders a frame around the rectangle defined by x, y, width,
// height.
//
// Examples of frame rendering, showing the effect of border-image,
// border-color, border-width, border-radius and junctions:
//
// ! (frames.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderFrame(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_frame(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderHandle renders a handle (as in Paned and Window’s resize grip),
// in the rectangle determined by x, y, width, height.
//
// Handles rendered for the paned and grip classes:
//
// ! (handles.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderHandle(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_handle(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderIcon renders the icon in texture at the specified x and y coordinates.
//
// This function will render the icon in texture at exactly its size, regardless
// of scaling factors, which may not be appropriate when drawing on displays
// with high pixel densities.
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - texture containing the icon to draw.
//   - x: x position for the texture.
//   - y: y position for the texture.
func RenderIcon(context *StyleContext, cr *cairo.Context, texture gdk.Texturer, x, y float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 *C.GdkTexture      // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	_arg4 = C.double(x)
	_arg5 = C.double(y)

	C.gtk_render_icon(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// RenderLayout renders layout on the coordinates x, y.
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin.
//   - y: y origin.
//   - layout to render.
func RenderLayout(context *StyleContext, cr *cairo.Context, x, y float64, layout *pango.Layout) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 *C.PangoLayout     // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.gtk_render_layout(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(layout)
}

// RenderLine renders a line from (x0, y0) to (x1, y1).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x0: x coordinate for the origin of the line.
//   - y0: y coordinate for the origin of the line.
//   - x1: x coordinate for the end of the line.
//   - y1: y coordinate for the end of the line.
func RenderLine(context *StyleContext, cr *cairo.Context, x0, y0, x1, y1 float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x0)
	_arg4 = C.double(y0)
	_arg5 = C.double(x1)
	_arg6 = C.double(y1)

	C.gtk_render_line(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x0)
	runtime.KeepAlive(y0)
	runtime.KeepAlive(x1)
	runtime.KeepAlive(y1)
}

// RenderOption renders an option mark (as in a radio button), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
//
// Typical option mark rendering:
//
// ! (options.png).
//
// The function takes the following parameters:
//
//   - context: StyleContext.
//   - cr: #cairo_t.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func RenderOption(context *StyleContext, cr *cairo.Context, x, y, width, height float64) {
	var _arg1 *C.GtkStyleContext // out
	var _arg2 *C.cairo_t         // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out
	var _arg6 C.double           // out

	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg3 = C.double(x)
	_arg4 = C.double(y)
	_arg5 = C.double(width)
	_arg6 = C.double(height)

	C.gtk_render_option(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RGBToHSV converts a color from RGB space to HSV.
//
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
//
// The function takes the following parameters:
//
//   - r: red.
//   - g: green.
//   - b: blue.
//
// The function returns the following values:
//
//   - h: return value for the hue component.
//   - s: return value for the saturation component.
//   - v: return value for the value component.
func RGBToHSV(r, g, b float32) (h, s, v float32) {
	var _arg1 C.float // out
	var _arg2 C.float // out
	var _arg3 C.float // out
	var _arg4 C.float // in
	var _arg5 C.float // in
	var _arg6 C.float // in

	_arg1 = C.float(r)
	_arg2 = C.float(g)
	_arg3 = C.float(b)

	C.gtk_rgb_to_hsv(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(r)
	runtime.KeepAlive(g)
	runtime.KeepAlive(b)

	var _h float32 // out
	var _s float32 // out
	var _v float32 // out

	_h = float32(_arg4)
	_s = float32(_arg5)
	_v = float32(_arg6)

	return _h, _s, _v
}

// SetDebugFlags sets the GTK debug flags.
//
// The function takes the following parameters:
//
//   - flags: debug flags to set.
func SetDebugFlags(flags DebugFlags) {
	var _arg1 C.GtkDebugFlags // out

	_arg1 = C.GtkDebugFlags(flags)

	C.gtk_set_debug_flags(_arg1)
	runtime.KeepAlive(flags)
}

// ShowURI: this function launches the default application for showing a given
// uri, or shows an error dialog if that fails.
//
// The function takes the following parameters:
//
//   - parent (optional) window.
//   - uri to show.
//   - timestamp from the event that triggered this call, or GDK_CURRENT_TIME.
func ShowURI(parent *Window, uri string, timestamp uint32) {
	var _arg1 *C.GtkWindow // out
	var _arg2 *C.char      // out
	var _arg3 C.guint32    // out

	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint32(timestamp)

	C.gtk_show_uri(_arg1, _arg2, _arg3)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(timestamp)
}

// ShowURIFull: this function launches the default application for showing a
// given uri.
//
// The callback will be called when the launch is completed. It should call
// gtk_show_uri_full_finish() to obtain the result.
//
// This is the recommended call to be used as it passes information necessary
// for sandbox helpers to parent their dialogs properly.
//
// The function takes the following parameters:
//
//   - ctx (optional) to cancel the launch.
//   - parent (optional) window.
//   - uri to show.
//   - timestamp from the event that triggered this call, or GDK_CURRENT_TIME.
//   - callback (optional) to call when the action is complete.
func ShowURIFull(ctx context.Context, parent *Window, uri string, timestamp uint32, callback gio.AsyncReadyCallback) {
	var _arg4 *C.GCancellable       // out
	var _arg1 *C.GtkWindow          // out
	var _arg2 *C.char               // out
	var _arg3 C.guint32             // out
	var _arg5 C.GAsyncReadyCallback // out
	var _arg6 C.gpointer

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint32(timestamp)
	if callback != nil {
		_arg5 = (*[0]byte)(C._gotk4_gio2_AsyncReadyCallback)
		_arg6 = C.gpointer(gbox.AssignOnce(callback))
	}

	C.gtk_show_uri_full(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(timestamp)
	runtime.KeepAlive(callback)
}

// ShowURIFullFinish finishes the gtk_show_uri() call and returns the result of
// the operation.
//
// The function takes the following parameters:
//
//   - parent passed to gtk_show_uri().
//   - result that was passed to callback.
func ShowURIFullFinish(parent *Window, result gio.AsyncResulter) error {
	var _arg1 *C.GtkWindow    // out
	var _arg2 *C.GAsyncResult // out
	var _cerr *C.GError       // in

	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	_arg2 = (*C.GAsyncResult)(unsafe.Pointer(coreglib.InternObject(result).Native()))

	C.gtk_show_uri_full_finish(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(result)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// The function takes the following parameters:
//
//   - domain
//   - file
//   - line
//   - fn
//   - expr
//   - accessible
//   - expectedRole
//   - actualRole
func TestAccessibleAssertionMessageRole(domain, file string, line int, fn, expr string, accessible Accessibler, expectedRole, actualRole AccessibleRole) {
	var _arg1 *C.char             // out
	var _arg2 *C.char             // out
	var _arg3 C.int               // out
	var _arg4 *C.char             // out
	var _arg5 *C.char             // out
	var _arg6 *C.GtkAccessible    // out
	var _arg7 C.GtkAccessibleRole // out
	var _arg8 C.GtkAccessibleRole // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(file)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(line)
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(fn)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.char)(unsafe.Pointer(C.CString(expr)))
	defer C.free(unsafe.Pointer(_arg5))
	_arg6 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	_arg7 = C.GtkAccessibleRole(expectedRole)
	_arg8 = C.GtkAccessibleRole(actualRole)

	C.gtk_test_accessible_assertion_message_role(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(domain)
	runtime.KeepAlive(file)
	runtime.KeepAlive(line)
	runtime.KeepAlive(fn)
	runtime.KeepAlive(expr)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(expectedRole)
	runtime.KeepAlive(actualRole)
}

// TestAccessibleHasProperty checks whether the Accessible has property set.
//
// The function takes the following parameters:
//
//   - accessible: Accessible.
//   - property: AccessibleProperty.
//
// The function returns the following values:
//
//   - ok: TRUE if the property is set in the accessible.
func TestAccessibleHasProperty(accessible Accessibler, property AccessibleProperty) bool {
	var _arg1 *C.GtkAccessible        // out
	var _arg2 C.GtkAccessibleProperty // out
	var _cret C.gboolean              // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	_arg2 = C.GtkAccessibleProperty(property)

	_cret = C.gtk_test_accessible_has_property(_arg1, _arg2)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(property)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestAccessibleHasRelation checks whether the Accessible has relation set.
//
// The function takes the following parameters:
//
//   - accessible: Accessible.
//   - relation: AccessibleRelation.
//
// The function returns the following values:
//
//   - ok: TRUE if the relation is set in the accessible.
func TestAccessibleHasRelation(accessible Accessibler, relation AccessibleRelation) bool {
	var _arg1 *C.GtkAccessible        // out
	var _arg2 C.GtkAccessibleRelation // out
	var _cret C.gboolean              // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	_arg2 = C.GtkAccessibleRelation(relation)

	_cret = C.gtk_test_accessible_has_relation(_arg1, _arg2)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(relation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestAccessibleHasRole checks whether the Accessible:accessible-role of the
// accessible is role.
//
// The function takes the following parameters:
//
//   - accessible: Accessible.
//   - role: AccessibleRole.
//
// The function returns the following values:
//
//   - ok: TRUE if the role matches.
func TestAccessibleHasRole(accessible Accessibler, role AccessibleRole) bool {
	var _arg1 *C.GtkAccessible    // out
	var _arg2 C.GtkAccessibleRole // out
	var _cret C.gboolean          // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	_arg2 = C.GtkAccessibleRole(role)

	_cret = C.gtk_test_accessible_has_role(_arg1, _arg2)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(role)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestAccessibleHasState checks whether the Accessible has state set.
//
// The function takes the following parameters:
//
//   - accessible: Accessible.
//   - state: AccessibleState.
//
// The function returns the following values:
//
//   - ok: TRUE if the state is set in the accessible.
func TestAccessibleHasState(accessible Accessibler, state AccessibleState) bool {
	var _arg1 *C.GtkAccessible     // out
	var _arg2 C.GtkAccessibleState // out
	var _cret C.gboolean           // in

	_arg1 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	_arg2 = C.GtkAccessibleState(state)

	_cret = C.gtk_test_accessible_has_state(_arg1, _arg2)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TestListAllTypes: return the type ids that have been registered after calling
// gtk_test_register_all_types().
//
// The function returns the following values:
//
//   - gTypes: 0-terminated array of type ids.
func TestListAllTypes() []coreglib.Type {
	var _cret *C.GType // in
	var _arg1 C.guint  // in

	_cret = C.gtk_test_list_all_types(&_arg1)

	var _gTypes []coreglib.Type // out

	{
		src := unsafe.Slice((*C.GType)(_cret), _arg1)
		_gTypes = make([]coreglib.Type, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_gTypes[i] = coreglib.Type(src[i])
		}
	}

	return _gTypes
}

// TestRegisterAllTypes: force registration of all core GTK object types.
//
// This allowes to refer to any of those object types via g_type_from_name()
// after calling this function.
func TestRegisterAllTypes() {
	C.gtk_test_register_all_types()
}

// TestWidgetWaitForDraw enters the main loop and waits for widget to be
// “drawn”.
//
// In this context that means it waits for the frame clock of widget to have run
// a full styling, layout and drawing cycle.
//
// This function is intended to be used for syncing with actions that depend on
// widget relayouting or on interaction with the display server.
//
// The function takes the following parameters:
//
//   - widget to wait for.
func TestWidgetWaitForDraw(widget Widgetter) {
	var _arg1 *C.GtkWidget // out

	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_test_widget_wait_for_draw(_arg1)
	runtime.KeepAlive(widget)
}

// TreeCreateRowDragContent creates a content provider for dragging path from
// tree_model.
//
// The function takes the following parameters:
//
//   - treeModel: TreeModel.
//   - path: row in tree_model.
//
// The function returns the following values:
//
//   - contentProvider: new ContentProvider.
func TreeCreateRowDragContent(treeModel TreeModeller, path *TreePath) *gdk.ContentProvider {
	var _arg1 *C.GtkTreeModel       // out
	var _arg2 *C.GtkTreePath        // out
	var _cret *C.GdkContentProvider // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_create_row_drag_content(_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)

	var _contentProvider *gdk.ContentProvider // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_contentProvider = &gdk.ContentProvider{
			Object: obj,
		}
	}

	return _contentProvider
}

// TreeGetRowDragData obtains a tree_model and path from value of target type
// GTK_TYPE_TREE_ROW_DATA.
//
// The returned path must be freed with gtk_tree_path_free().
//
// The function takes the following parameters:
//
//   - value: #GValue.
//
// The function returns the following values:
//
//   - treeModel (optional): TreeModel.
//   - path (optional): row in tree_model.
//   - ok: TRUE if selection_data had target type GTK_TYPE_TREE_ROW_DATA is
//     otherwise valid.
func TreeGetRowDragData(value *coreglib.Value) (*TreeModel, *TreePath, bool) {
	var _arg1 *C.GValue       // out
	var _arg2 *C.GtkTreeModel // in
	var _arg3 *C.GtkTreePath  // in
	var _cret C.gboolean      // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_tree_get_row_drag_data(_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(value)

	var _treeModel *TreeModel // out
	var _path *TreePath       // out
	var _ok bool              // out

	if _arg2 != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_arg2)))
	}
	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _treeModel, _path, _ok
}

// ValueDupExpression retrieves the GtkExpression stored inside the given value,
// and acquires a reference to it.
//
// The function takes the following parameters:
//
//   - value: GValue initialized with type GTK_TYPE_EXPRESSION.
//
// The function returns the following values:
//
//   - expression (optional): GtkExpression.
func ValueDupExpression(value *coreglib.Value) Expressioner {
	var _arg1 *C.GValue        // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_value_dup_expression(_arg1)
	runtime.KeepAlive(value)

	var _expression Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// ValueGetExpression retrieves the GtkExpression stored inside the given value.
//
// The function takes the following parameters:
//
//   - value: GValue initialized with type GTK_TYPE_EXPRESSION.
//
// The function returns the following values:
//
//   - expression (optional): GtkExpression.
func ValueGetExpression(value *coreglib.Value) Expressioner {
	var _arg1 *C.GValue        // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_value_get_expression(_arg1)
	runtime.KeepAlive(value)

	var _expression Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// ValueSetExpression stores the given GtkExpression inside value.
//
// The GValue will acquire a reference to the expression.
//
// The function takes the following parameters:
//
//   - value: GValue initialized with type GTK_TYPE_EXPRESSION.
//   - expression: GtkExpression.
func ValueSetExpression(value *coreglib.Value, expression Expressioner) {
	var _arg1 *C.GValue        // out
	var _arg2 *C.GtkExpression // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg2 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))

	C.gtk_value_set_expression(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(expression)
}

// ValueTakeExpression stores the given GtkExpression inside value.
//
// This function transfers the ownership of the expression to the GValue.
//
// The function takes the following parameters:
//
//   - value: GValue initialized with type GTK_TYPE_EXPRESSION.
//   - expression (optional): GtkExpression.
func ValueTakeExpression(value *coreglib.Value, expression Expressioner) {
	var _arg1 *C.GValue        // out
	var _arg2 *C.GtkExpression // out

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))
	if expression != nil {
		_arg2 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}

	C.gtk_value_take_expression(_arg1, _arg2)
	runtime.KeepAlive(value)
	runtime.KeepAlive(expression)
}

// Accessible: GtkAccessible is an interface for describing UI elements for
// Assistive Technologies.
//
// Every accessible implementation has:
//
//   - a “role”, represented by a value of the gtk.AccessibleRole enumeration
//   - an “attribute”, represented by a set of gtk.AccessibleState,
//     gtk.AccessibleProperty and gtk.AccessibleRelation values
//
// The role cannot be changed after instantiating a GtkAccessible
// implementation.
//
// The attributes are updated every time a UI element's state changes in a
// way that should be reflected by assistive technologies. For instance,
// if a GtkWidget visibility changes, the GTK_ACCESSIBLE_STATE_HIDDEN state will
// also change to reflect the gtk.Widget:visible property.
//
// Accessible wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Accessible struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Accessible)(nil)
)

// Accessibler describes Accessible's interface methods.
type Accessibler interface {
	coreglib.Objector

	// AccessibleRole retrieves the GtkAccessibleRole for the given
	// GtkAccessible.
	AccessibleRole() AccessibleRole
	// ResetProperty resets the accessible property to its default value.
	ResetProperty(property AccessibleProperty)
	// ResetRelation resets the accessible relation to its default value.
	ResetRelation(relation AccessibleRelation)
	// ResetState resets the accessible state to its default value.
	ResetState(state AccessibleState)
	// UpdateProperty updates an array of accessible properties.
	UpdateProperty(properties []AccessibleProperty, values []coreglib.Value)
	// UpdateRelation updates an array of accessible relations.
	UpdateRelation(relations []AccessibleRelation, values []coreglib.Value)
	// UpdateState updates an array of accessible states.
	UpdateState(states []AccessibleState, values []coreglib.Value)
}

var _ Accessibler = (*Accessible)(nil)

func wrapAccessible(obj *coreglib.Object) *Accessible {
	return &Accessible{
		Object: obj,
	}
}

func marshalAccessible(p uintptr) (interface{}, error) {
	return wrapAccessible(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AccessibleRole retrieves the GtkAccessibleRole for the given GtkAccessible.
//
// The function returns the following values:
//
//   - accessibleRole: GtkAccessibleRole.
func (self *Accessible) AccessibleRole() AccessibleRole {
	var _arg0 *C.GtkAccessible    // out
	var _cret C.GtkAccessibleRole // in

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_accessible_get_accessible_role(_arg0)
	runtime.KeepAlive(self)

	var _accessibleRole AccessibleRole // out

	_accessibleRole = AccessibleRole(_cret)

	return _accessibleRole
}

// ResetProperty resets the accessible property to its default value.
//
// The function takes the following parameters:
//
//   - property: GtkAccessibleProperty.
func (self *Accessible) ResetProperty(property AccessibleProperty) {
	var _arg0 *C.GtkAccessible        // out
	var _arg1 C.GtkAccessibleProperty // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkAccessibleProperty(property)

	C.gtk_accessible_reset_property(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(property)
}

// ResetRelation resets the accessible relation to its default value.
//
// The function takes the following parameters:
//
//   - relation: GtkAccessibleRelation.
func (self *Accessible) ResetRelation(relation AccessibleRelation) {
	var _arg0 *C.GtkAccessible        // out
	var _arg1 C.GtkAccessibleRelation // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkAccessibleRelation(relation)

	C.gtk_accessible_reset_relation(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(relation)
}

// ResetState resets the accessible state to its default value.
//
// The function takes the following parameters:
//
//   - state: GtkAccessibleState.
func (self *Accessible) ResetState(state AccessibleState) {
	var _arg0 *C.GtkAccessible     // out
	var _arg1 C.GtkAccessibleState // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkAccessibleState(state)

	C.gtk_accessible_reset_state(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(state)
}

// UpdateProperty updates an array of accessible properties.
//
// This function should be called by GtkWidget types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
//
// The function takes the following parameters:
//
//   - properties: array of GtkAccessibleProperty.
//   - values: array of GValues, one for each property.
func (self *Accessible) UpdateProperty(properties []AccessibleProperty, values []coreglib.Value) {
	var _arg0 *C.GtkAccessible         // out
	var _arg2 *C.GtkAccessibleProperty // out
	var _arg1 C.int
	var _arg3 *C.GValue // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (C.int)(len(properties))
	if len(properties) > 0 {
		_arg2 = (*C.GtkAccessibleProperty)(unsafe.Pointer(&properties[0]))
	}
	_arg1 = (C.int)(len(values))
	_arg3 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GValue)(_arg3), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	C.gtk_accessible_update_property_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(properties)
	runtime.KeepAlive(values)
}

// UpdateRelation updates an array of accessible relations.
//
// This function should be called by GtkWidget types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
//
// The function takes the following parameters:
//
//   - relations: array of GtkAccessibleRelation.
//   - values: array of GValues, one for each relation.
func (self *Accessible) UpdateRelation(relations []AccessibleRelation, values []coreglib.Value) {
	var _arg0 *C.GtkAccessible         // out
	var _arg2 *C.GtkAccessibleRelation // out
	var _arg1 C.int
	var _arg3 *C.GValue // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (C.int)(len(relations))
	if len(relations) > 0 {
		_arg2 = (*C.GtkAccessibleRelation)(unsafe.Pointer(&relations[0]))
	}
	_arg1 = (C.int)(len(values))
	_arg3 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GValue)(_arg3), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	C.gtk_accessible_update_relation_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(relations)
	runtime.KeepAlive(values)
}

// UpdateState updates an array of accessible states.
//
// This function should be called by GtkWidget types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
//
// The function takes the following parameters:
//
//   - states: array of GtkAccessibleState.
//   - values: array of GValues, one for each state.
func (self *Accessible) UpdateState(states []AccessibleState, values []coreglib.Value) {
	var _arg0 *C.GtkAccessible      // out
	var _arg2 *C.GtkAccessibleState // out
	var _arg1 C.int
	var _arg3 *C.GValue // out

	_arg0 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (C.int)(len(states))
	if len(states) > 0 {
		_arg2 = (*C.GtkAccessibleState)(unsafe.Pointer(&states[0]))
	}
	_arg1 = (C.int)(len(values))
	_arg3 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GValue)(_arg3), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	C.gtk_accessible_update_state_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(states)
	runtime.KeepAlive(values)
}

// Actionable: GtkActionable interface provides a convenient way of asscociating
// widgets with actions.
//
// It primarily consists of two properties: gtk.Actionable:action-name and
// gtk.Actionable:action-target. There are also some convenience APIs for
// setting these properties.
//
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the
// “win.” or “app.” prefix that are associated with the GtkApplicationWindow
// or GtkApplication, but other action groups that are added with
// gtk.Widget.InsertActionGroup() will be consulted as well.
//
// Actionable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Actionable struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Actionable)(nil)
)

// Actionabler describes Actionable's interface methods.
type Actionabler interface {
	coreglib.Objector

	// ActionName gets the action name for actionable.
	ActionName() string
	// ActionTargetValue gets the current target value of actionable.
	ActionTargetValue() *glib.Variant
	// SetActionName specifies the name of the action with which this widget
	// should be associated.
	SetActionName(actionName string)
	// SetActionTargetValue sets the target value of an actionable widget.
	SetActionTargetValue(targetValue *glib.Variant)
	// SetDetailedActionName sets the action-name and associated string target
	// value of an actionable widget.
	SetDetailedActionName(detailedActionName string)
}

var _ Actionabler = (*Actionable)(nil)

func wrapActionable(obj *coreglib.Object) *Actionable {
	return &Actionable{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalActionable(p uintptr) (interface{}, error) {
	return wrapActionable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ActionName gets the action name for actionable.
//
// The function returns the following values:
//
//   - utf8 (optional): action name, or NULL if none is set.
func (actionable *Actionable) ActionName() string {
	var _arg0 *C.GtkActionable // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))

	_cret = C.gtk_actionable_get_action_name(_arg0)
	runtime.KeepAlive(actionable)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ActionTargetValue gets the current target value of actionable.
//
// The function returns the following values:
//
//   - variant (optional): current target value.
func (actionable *Actionable) ActionTargetValue() *glib.Variant {
	var _arg0 *C.GtkActionable // out
	var _cret *C.GVariant      // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))

	_cret = C.gtk_actionable_get_action_target_value(_arg0)
	runtime.KeepAlive(actionable)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_variant_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// SetActionName specifies the name of the action with which this widget should
// be associated.
//
// If action_name is NULL then the widget will be unassociated from any previous
// action.
//
// Usually this function is used when the widget is located (or will be located)
// within the hierarchy of a GtkApplicationWindow.
//
// Names are of the form “win.save” or “app.quit” for actions on the containing
// GtkApplicationWindow or its associated GtkApplication, respectively. This is
// the same form used for actions in the GMenu associated with the window.
//
// The function takes the following parameters:
//
//   - actionName (optional): action name, or NULL.
func (actionable *Actionable) SetActionName(actionName string) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	if actionName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(actionName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_actionable_set_action_name(_arg0, _arg1)
	runtime.KeepAlive(actionable)
	runtime.KeepAlive(actionName)
}

// SetActionTargetValue sets the target value of an actionable widget.
//
// If target_value is NULL then the target value is unset.
//
// The target value has two purposes. First, it is used as the parameter to
// activation of the action associated with the GtkActionable widget. Second,
// it is used to determine if the widget should be rendered as “active” — the
// widget is active if the state is equal to the given target.
//
// Consider the example of associating a set of buttons with a GAction with
// string state in a typical “radio button” situation. Each button will be
// associated with the same action, but with a different target value for that
// action. Clicking on a particular button will activate the action with the
// target of that button, which will typically cause the action’s state to
// change to that value. Since the action’s state is now equal to the target
// value of the button, the button will now be rendered as active (and the other
// buttons, with different targets, rendered inactive).
//
// The function takes the following parameters:
//
//   - targetValue (optional) to set as the target value, or NULL.
func (actionable *Actionable) SetActionTargetValue(targetValue *glib.Variant) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	if targetValue != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(targetValue)))
	}

	C.gtk_actionable_set_action_target_value(_arg0, _arg1)
	runtime.KeepAlive(actionable)
	runtime.KeepAlive(targetValue)
}

// SetDetailedActionName sets the action-name and associated string target value
// of an actionable widget.
//
// detailed_action_name is a string in the format accepted by
// g_action_parse_detailed_name().
//
// The function takes the following parameters:
//
//   - detailedActionName: detailed action name.
func (actionable *Actionable) SetDetailedActionName(detailedActionName string) {
	var _arg0 *C.GtkActionable // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(detailedActionName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_actionable_set_detailed_action_name(_arg0, _arg1)
	runtime.KeepAlive(actionable)
	runtime.KeepAlive(detailedActionName)
}

// actionName gets the action name for actionable.
//
// The function returns the following values:
//
//   - utf8 (optional): action name, or NULL if none is set.
func (actionable *Actionable) actionName() string {
	gclass := (*C.GtkActionableInterface)(coreglib.PeekParentClass(actionable))
	fnarg := gclass.get_action_name

	var _arg0 *C.GtkActionable // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))

	_cret = C._gotk4_gtk4_Actionable_virtual_get_action_name(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(actionable)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// actionTargetValue gets the current target value of actionable.
//
// The function returns the following values:
//
//   - variant (optional): current target value.
func (actionable *Actionable) actionTargetValue() *glib.Variant {
	gclass := (*C.GtkActionableInterface)(coreglib.PeekParentClass(actionable))
	fnarg := gclass.get_action_target_value

	var _arg0 *C.GtkActionable // out
	var _cret *C.GVariant      // in

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))

	_cret = C._gotk4_gtk4_Actionable_virtual_get_action_target_value(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(actionable)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_variant_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// setActionName specifies the name of the action with which this widget should
// be associated.
//
// If action_name is NULL then the widget will be unassociated from any previous
// action.
//
// Usually this function is used when the widget is located (or will be located)
// within the hierarchy of a GtkApplicationWindow.
//
// Names are of the form “win.save” or “app.quit” for actions on the containing
// GtkApplicationWindow or its associated GtkApplication, respectively. This is
// the same form used for actions in the GMenu associated with the window.
//
// The function takes the following parameters:
//
//   - actionName (optional): action name, or NULL.
func (actionable *Actionable) setActionName(actionName string) {
	gclass := (*C.GtkActionableInterface)(coreglib.PeekParentClass(actionable))
	fnarg := gclass.set_action_name

	var _arg0 *C.GtkActionable // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	if actionName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(actionName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C._gotk4_gtk4_Actionable_virtual_set_action_name(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionable)
	runtime.KeepAlive(actionName)
}

// setActionTargetValue sets the target value of an actionable widget.
//
// If target_value is NULL then the target value is unset.
//
// The target value has two purposes. First, it is used as the parameter to
// activation of the action associated with the GtkActionable widget. Second,
// it is used to determine if the widget should be rendered as “active” — the
// widget is active if the state is equal to the given target.
//
// Consider the example of associating a set of buttons with a GAction with
// string state in a typical “radio button” situation. Each button will be
// associated with the same action, but with a different target value for that
// action. Clicking on a particular button will activate the action with the
// target of that button, which will typically cause the action’s state to
// change to that value. Since the action’s state is now equal to the target
// value of the button, the button will now be rendered as active (and the other
// buttons, with different targets, rendered inactive).
//
// The function takes the following parameters:
//
//   - targetValue (optional) to set as the target value, or NULL.
func (actionable *Actionable) setActionTargetValue(targetValue *glib.Variant) {
	gclass := (*C.GtkActionableInterface)(coreglib.PeekParentClass(actionable))
	fnarg := gclass.set_action_target_value

	var _arg0 *C.GtkActionable // out
	var _arg1 *C.GVariant      // out

	_arg0 = (*C.GtkActionable)(unsafe.Pointer(coreglib.InternObject(actionable).Native()))
	if targetValue != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(targetValue)))
	}

	C._gotk4_gtk4_Actionable_virtual_set_action_target_value(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(actionable)
	runtime.KeepAlive(targetValue)
}

// AppChooser: GtkAppChooser is an interface for widgets which allow the user to
// choose an application.
//
// The main objects that implement this interface are gtk.AppChooserWidget,
// gtk.AppChooserDialog and gtk.AppChooserButton.
//
// Applications are represented by GIO GAppInfo objects here. GIO has a
// concept of recommended and fallback applications for a given content type.
// Recommended applications are those that claim to handle the content type
// itself, while fallback also includes applications that handle a more generic
// content type. GIO also knows the default and last-used application for a
// given content type. The GtkAppChooserWidget provides detailed control over
// whether the shown list of applications should include default, recommended or
// fallback applications.
//
// To obtain the application that has been selected in a GtkAppChooser,
// use gtk.AppChooser.GetAppInfo().
//
// AppChooser wraps an interface. This means the user can get the
// underlying type by calling Cast().
type AppChooser struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*AppChooser)(nil)
)

// AppChooserer describes AppChooser's interface methods.
type AppChooserer interface {
	coreglib.Objector

	// AppInfo returns the currently selected application.
	AppInfo() *gio.AppInfo
	// ContentType returns the content type for which the GtkAppChooser shows
	// applications.
	ContentType() string
	// Refresh reloads the list of applications.
	Refresh()
}

var _ AppChooserer = (*AppChooser)(nil)

func wrapAppChooser(obj *coreglib.Object) *AppChooser {
	return &AppChooser{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalAppChooser(p uintptr) (interface{}, error) {
	return wrapAppChooser(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AppInfo returns the currently selected application.
//
// The function returns the following values:
//
//   - appInfo (optional): GAppInfo for the currently selected application,
//     or NULL if none is selected. Free with g_object_unref().
func (self *AppChooser) AppInfo() *gio.AppInfo {
	var _arg0 *C.GtkAppChooser // out
	var _cret *C.GAppInfo      // in

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_get_app_info(_arg0)
	runtime.KeepAlive(self)

	var _appInfo *gio.AppInfo // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_appInfo = &gio.AppInfo{
				Object: obj,
			}
		}
	}

	return _appInfo
}

// ContentType returns the content type for which the GtkAppChooser shows
// applications.
//
// The function returns the following values:
//
//   - utf8: content type of self. Free with g_free().
func (self *AppChooser) ContentType() string {
	var _arg0 *C.GtkAppChooser // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_get_content_type(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Refresh reloads the list of applications.
func (self *AppChooser) Refresh() {
	var _arg0 *C.GtkAppChooser // out

	_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_app_chooser_refresh(_arg0)
	runtime.KeepAlive(self)
}

// Buildable: GtkBuildable allows objects to extend and customize their
// deserialization from ui files.
//
// The interface includes methods for setting names and properties of objects,
// parsing custom tags and constructing child objects.
//
// The GtkBuildable interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK. The main user of this interface
// is gtk.Builder. There should be very little need for applications to call any
// of these functions directly.
//
// An object only needs to implement this interface if it needs to extend the
// GtkBuilder XML format or run any extra routines at deserialization time.
//
// Buildable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Buildable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Buildable)(nil)
)

// Buildabler describes Buildable's interface methods.
type Buildabler interface {
	coreglib.Objector

	// BuildableID gets the ID of the buildable object.
	BuildableID() string
}

var _ Buildabler = (*Buildable)(nil)

func wrapBuildable(obj *coreglib.Object) *Buildable {
	return &Buildable{
		Object: obj,
	}
}

func marshalBuildable(p uintptr) (interface{}, error) {
	return wrapBuildable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// BuildableID gets the ID of the buildable object.
//
// GtkBuilder sets the name based on the ID attribute of the <object> tag used
// to construct the buildable.
//
// The function returns the following values:
//
//   - utf8: ID of the buildable object.
func (buildable *Buildable) BuildableID() string {
	var _arg0 *C.GtkBuildable // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))

	_cret = C.gtk_buildable_get_buildable_id(_arg0)
	runtime.KeepAlive(buildable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// addChild adds a child to buildable. type is an optional string describing how
// the child should be added.
//
// The function takes the following parameters:
//
//   - builder: Builder.
//   - child to add.
//   - typ (optional): kind of child or NULL.
func (buildable *Buildable) addChild(builder *Builder, child *coreglib.Object, typ string) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.add_child

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.GObject      // out
	var _arg3 *C.char         // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	if typ != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(typ)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C._gotk4_gtk4_Buildable_virtual_add_child(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(typ)
}

// customFinished: similar to gtk_buildable_parser_finished() but is called once
// for each custom tag handled by the buildable.
//
// The function takes the following parameters:
//
//   - builder: Builder.
//   - child (optional) object or NULL for non-child tags.
//   - tagname: name of the tag.
//   - data (optional): user data created in custom_tag_start.
func (buildable *Buildable) customFinished(builder *Builder, child *coreglib.Object, tagname string, data unsafe.Pointer) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.custom_finished

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.GObject      // out
	var _arg3 *C.char         // out
	var _arg4 C.gpointer      // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if child != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(tagname)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gpointer)(unsafe.Pointer(data))

	C._gotk4_gtk4_Buildable_virtual_custom_finished(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tagname)
	runtime.KeepAlive(data)
}

// customTagEnd: called at the end of each custom element handled by the
// buildable.
//
// The function takes the following parameters:
//
//   - builder used to construct this object.
//   - child (optional) object or NULL for non-child tags.
//   - tagname: name of tag.
//   - data (optional): user data that will be passed in to parser functions.
func (buildable *Buildable) customTagEnd(builder *Builder, child *coreglib.Object, tagname string, data unsafe.Pointer) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.custom_tag_end

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.GObject      // out
	var _arg3 *C.char         // out
	var _arg4 C.gpointer      // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if child != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(tagname)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (C.gpointer)(unsafe.Pointer(data))

	C._gotk4_gtk4_Buildable_virtual_custom_tag_end(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tagname)
	runtime.KeepAlive(data)
}

// customTagStart: called for each unknown element under <child>.
//
// The function takes the following parameters:
//
//   - builder used to construct this object.
//   - child (optional) object or NULL for non-child tags.
//   - tagname: name of tag.
//
// The function returns the following values:
//
//   - parser to fill in.
//   - data (optional): return location for user data that will be passed in to
//     parser functions.
//   - ok: TRUE if an object has a custom implementation, FALSE if it doesn't.
func (buildable *Buildable) customTagStart(builder *Builder, child *coreglib.Object, tagname string) (*BuildableParser, unsafe.Pointer, bool) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.custom_tag_start

	var _arg0 *C.GtkBuildable      // out
	var _arg1 *C.GtkBuilder        // out
	var _arg2 *C.GObject           // out
	var _arg3 *C.char              // out
	var _arg4 C.GtkBuildableParser // in
	var _arg5 C.gpointer           // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if child != nil {
		_arg2 = (*C.GObject)(unsafe.Pointer(child.Native()))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(tagname)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C._gotk4_gtk4_Buildable_virtual_custom_tag_start(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tagname)

	var _parser *BuildableParser // out
	var _data unsafe.Pointer     // out
	var _ok bool                 // out

	_parser = (*BuildableParser)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))
	_data = (unsafe.Pointer)(unsafe.Pointer(_arg5))
	if _cret != 0 {
		_ok = true
	}

	return _parser, _data, _ok
}

func (buildable *Buildable) iD() string {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.get_id

	var _arg0 *C.GtkBuildable // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))

	_cret = C._gotk4_gtk4_Buildable_virtual_get_id(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buildable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// internalChild retrieves the internal child called childname of the buildable
// object.
//
// The function takes the following parameters:
//
//   - builder: Builder.
//   - childname: name of child.
//
// The function returns the following values:
//
//   - object: internal child of the buildable object.
func (buildable *Buildable) internalChild(builder *Builder, childname string) *coreglib.Object {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.get_internal_child

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.char         // out
	var _cret *C.GObject      // in

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(childname)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gtk4_Buildable_virtual_get_internal_child(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(childname)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

func (buildable *Buildable) parserFinished(builder *Builder) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.parser_finished

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	C._gotk4_gtk4_Buildable_virtual_parser_finished(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
}

// The function takes the following parameters:
//
//   - builder
//   - name
//   - value
func (buildable *Buildable) setBuildableProperty(builder *Builder, name string, value *coreglib.Value) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.set_buildable_property

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.GtkBuilder   // out
	var _arg2 *C.char         // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C._gotk4_gtk4_Buildable_virtual_set_buildable_property(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

func (buildable *Buildable) setID(id string) {
	gclass := (*C.GtkBuildableIface)(coreglib.PeekParentClass(buildable))
	fnarg := gclass.set_id

	var _arg0 *C.GtkBuildable // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkBuildable)(unsafe.Pointer(coreglib.InternObject(buildable).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gtk4_Buildable_virtual_set_id(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buildable)
	runtime.KeepAlive(id)
}

// BuilderScope: GtkBuilderScope is an interface to provide language binding
// support to GtkBuilder.
//
// The goal of GtkBuilderScope is to look up programming-language-specific
// values for strings that are given in a GtkBuilder UI file.
//
// The primary intended audience is bindings that want to provide deeper
// integration of GtkBuilder into the language.
//
// A GtkBuilderScope instance may be used with multiple GtkBuilder objects,
// even at once.
//
// By default, GTK will use its own implementation of GtkBuilderScope for the C
// language which can be created via gtk.BuilderCScope.New.
//
// BuilderScope wraps an interface. This means the user can get the
// underlying type by calling Cast().
type BuilderScope struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*BuilderScope)(nil)
)

// BuilderScoper describes BuilderScope's interface methods.
type BuilderScoper interface {
	coreglib.Objector

	baseBuilderScope() *BuilderScope
}

var _ BuilderScoper = (*BuilderScope)(nil)

func wrapBuilderScope(obj *coreglib.Object) *BuilderScope {
	return &BuilderScope{
		Object: obj,
	}
}

func marshalBuilderScope(p uintptr) (interface{}, error) {
	return wrapBuilderScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *BuilderScope) baseBuilderScope() *BuilderScope {
	return v
}

// BaseBuilderScope returns the underlying base object.
func BaseBuilderScope(obj BuilderScoper) *BuilderScope {
	return obj.baseBuilderScope()
}

// The function takes the following parameters:
//
//   - builder
//   - functionName
func (self *BuilderScope) typeFromFunction(builder *Builder, functionName string) coreglib.Type {
	gclass := (*C.GtkBuilderScopeInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_type_from_function

	var _arg0 *C.GtkBuilderScope // out
	var _arg1 *C.GtkBuilder      // out
	var _arg2 *C.char            // out
	var _cret C.GType            // in

	_arg0 = (*C.GtkBuilderScope)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(functionName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gtk4_BuilderScope_virtual_get_type_from_function(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(functionName)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// The function takes the following parameters:
//
//   - builder
//   - typeName
func (self *BuilderScope) typeFromName(builder *Builder, typeName string) coreglib.Type {
	gclass := (*C.GtkBuilderScopeInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_type_from_name

	var _arg0 *C.GtkBuilderScope // out
	var _arg1 *C.GtkBuilder      // out
	var _arg2 *C.char            // out
	var _cret C.GType            // in

	_arg0 = (*C.GtkBuilderScope)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(typeName)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C._gotk4_gtk4_BuilderScope_virtual_get_type_from_name(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typeName)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// CellEditable: interface for widgets that can be used for editing cells
//
// The CellEditable interface must be implemented for widgets to be usable
// to edit the contents of a TreeView cell. It provides a way to specify how
// temporary widgets should be configured for editing, get the new value, etc.
//
// CellEditable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type CellEditable struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*CellEditable)(nil)
)

// CellEditabler describes CellEditable's interface methods.
type CellEditabler interface {
	coreglib.Objector

	// EditingDone emits the CellEditable::editing-done signal.
	EditingDone()
	// RemoveWidget emits the CellEditable::remove-widget signal.
	RemoveWidget()
	// StartEditing begins editing on a cell_editable.
	StartEditing(event gdk.Eventer)

	// Editing-done: this signal is a sign for the cell renderer to update its
	// value from the cell_editable.
	ConnectEditingDone(func()) coreglib.SignalHandle
	// Remove-widget: this signal is meant to indicate that the cell is
	// finished editing, and the cell_editable widget is being removed and may
	// subsequently be destroyed.
	ConnectRemoveWidget(func()) coreglib.SignalHandle
}

var _ CellEditabler = (*CellEditable)(nil)

func wrapCellEditable(obj *coreglib.Object) *CellEditable {
	return &CellEditable{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalCellEditable(p uintptr) (interface{}, error) {
	return wrapCellEditable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEditingDone: this signal is a sign for the cell renderer to update its
// value from the cell_editable.
//
// Implementations of CellEditable are responsible for emitting this signal
// when they are done editing, e.g. Entry emits this signal when the user
// presses Enter. Typical things to do in a handler for ::editing-done are to
// capture the edited value, disconnect the cell_editable from signals on the
// CellRenderer, etc.
//
// gtk_cell_editable_editing_done() is a convenience method for emitting
// CellEditable::editing-done.
func (cellEditable *CellEditable) ConnectEditingDone(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cellEditable, "editing-done", false, unsafe.Pointer(C._gotk4_gtk4_CellEditable_ConnectEditingDone), f)
}

// ConnectRemoveWidget: this signal is meant to indicate that the cell is
// finished editing, and the cell_editable widget is being removed and may
// subsequently be destroyed.
//
// Implementations of CellEditable are responsible for emitting this
// signal when they are done editing. It must be emitted after the
// CellEditable::editing-done signal, to give the cell renderer a chance to
// update the cell's value before the widget is removed.
//
// gtk_cell_editable_remove_widget() is a convenience method for emitting
// CellEditable::remove-widget.
func (cellEditable *CellEditable) ConnectRemoveWidget(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cellEditable, "remove-widget", false, unsafe.Pointer(C._gotk4_gtk4_CellEditable_ConnectRemoveWidget), f)
}

// EditingDone emits the CellEditable::editing-done signal.
func (cellEditable *CellEditable) EditingDone() {
	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))

	C.gtk_cell_editable_editing_done(_arg0)
	runtime.KeepAlive(cellEditable)
}

// RemoveWidget emits the CellEditable::remove-widget signal.
func (cellEditable *CellEditable) RemoveWidget() {
	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))

	C.gtk_cell_editable_remove_widget(_arg0)
	runtime.KeepAlive(cellEditable)
}

// StartEditing begins editing on a cell_editable.
//
// The CellRenderer for the cell creates and returns a CellEditable from
// gtk_cell_renderer_start_editing(), configured for the CellRenderer type.
//
// gtk_cell_editable_start_editing() can then set up cell_editable suitably for
// editing a cell, e.g. making the Esc key emit CellEditable::editing-done.
//
// Note that the cell_editable is created on-demand for the current edit; its
// lifetime is temporary and does not persist across other edits and/or cells.
//
// The function takes the following parameters:
//
//   - event (optional) that began the editing process, or NULL if editing was
//     initiated programmatically.
func (cellEditable *CellEditable) StartEditing(event gdk.Eventer) {
	var _arg0 *C.GtkCellEditable // out
	var _arg1 *C.GdkEvent        // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))
	if event != nil {
		_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	}

	C.gtk_cell_editable_start_editing(_arg0, _arg1)
	runtime.KeepAlive(cellEditable)
	runtime.KeepAlive(event)
}

// editingDone emits the CellEditable::editing-done signal.
func (cellEditable *CellEditable) editingDone() {
	gclass := (*C.GtkCellEditableIface)(coreglib.PeekParentClass(cellEditable))
	fnarg := gclass.editing_done

	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))

	C._gotk4_gtk4_CellEditable_virtual_editing_done(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cellEditable)
}

// removeWidget emits the CellEditable::remove-widget signal.
func (cellEditable *CellEditable) removeWidget() {
	gclass := (*C.GtkCellEditableIface)(coreglib.PeekParentClass(cellEditable))
	fnarg := gclass.remove_widget

	var _arg0 *C.GtkCellEditable // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))

	C._gotk4_gtk4_CellEditable_virtual_remove_widget(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cellEditable)
}

// startEditing begins editing on a cell_editable.
//
// The CellRenderer for the cell creates and returns a CellEditable from
// gtk_cell_renderer_start_editing(), configured for the CellRenderer type.
//
// gtk_cell_editable_start_editing() can then set up cell_editable suitably for
// editing a cell, e.g. making the Esc key emit CellEditable::editing-done.
//
// Note that the cell_editable is created on-demand for the current edit; its
// lifetime is temporary and does not persist across other edits and/or cells.
//
// The function takes the following parameters:
//
//   - event (optional) that began the editing process, or NULL if editing was
//     initiated programmatically.
func (cellEditable *CellEditable) startEditing(event gdk.Eventer) {
	gclass := (*C.GtkCellEditableIface)(coreglib.PeekParentClass(cellEditable))
	fnarg := gclass.start_editing

	var _arg0 *C.GtkCellEditable // out
	var _arg1 *C.GdkEvent        // out

	_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(cellEditable).Native()))
	if event != nil {
		_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	}

	C._gotk4_gtk4_CellEditable_virtual_start_editing(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(cellEditable)
	runtime.KeepAlive(event)
}

// CellLayout: interface for packing cells
//
// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
//
// One of the notable features provided by implementations of GtkCellLayout
// are attributes. Attributes let you set the properties in flexible ways.
// They can just be set to constant values like regular properties.
// But they can also be mapped to a column of the underlying tree model
// with gtk_cell_layout_set_attributes(), which means that the value of
// the attribute can change from cell to cell as they are rendered by
// the cell renderer. Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
//
// # GtkCellLayouts as GtkBuildable
//
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
//
// This is an example of a UI definition fragment specifying attributes:
//
//	<object class="GtkCellView">
//	  <child>
//	    <object class="GtkCellRendererText"/>
//	    <attributes>
//	      <attribute name="text">0</attribute>
//	    </attributes>
//	  </child>"
//	</object>
//
// Furthermore for implementations of GtkCellLayout that use a CellArea
// to lay out cells (all GtkCellLayouts in GTK use a GtkCellArea) [cell
// properties][cell-properties] can also be defined in the format by specifying
// the custom <cell-packing> attribute which can contain multiple <property>
// elements defined in the normal way.
//
// Here is a UI definition fragment specifying cell properties:
//
//	<object class="GtkTreeViewColumn">
//	  <child>
//	    <object class="GtkCellRendererText"/>
//	    <cell-packing>
//	      <property name="align">True</property>
//	      <property name="expand">False</property>
//	    </cell-packing>
//	  </child>"
//	</object>
//
// # Subclassing GtkCellLayout implementations
//
// When subclassing a widget that implements CellLayout like IconView
// or ComboBox, there are some considerations related to the fact that
// these widgets internally use a CellArea. The cell area is exposed as a
// construct-only property by these widgets. This means that it is possible to
// e.g. do
//
//	static void
//	my_combo_box_init (MyComboBox *b)
//	{
//	  GtkCellRenderer *cell;
//
//	  cell = gtk_cell_renderer_pixbuf_new ();
//	  // The following call causes the default cell area for combo boxes,
//	  // a GtkCellAreaBox, to be instantiated
//	  gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//	  ...
//	}
//
//	GtkWidget *
//	my_combo_box_new (GtkCellArea *area)
//	{
//	  // This call is going to cause a warning about area being ignored
//	  return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//	}
//
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
//
// CellLayout wraps an interface. This means the user can get the
// underlying type by calling Cast().
type CellLayout struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*CellLayout)(nil)
)

// CellLayouter describes CellLayout's interface methods.
type CellLayouter interface {
	coreglib.Objector

	// AddAttribute adds an attribute mapping to the list in cell_layout.
	AddAttribute(cell CellRendererer, attribute string, column int)
	// Clear unsets all the mappings on all renderers on cell_layout and removes
	// all renderers from cell_layout.
	Clear()
	// ClearAttributes clears all existing attributes previously set with
	// gtk_cell_layout_set_attributes().
	ClearAttributes(cell CellRendererer)
	// Area returns the underlying CellArea which might be cell_layout if called
	// on a CellArea or might be NULL if no CellArea is used by cell_layout.
	Area() CellAreaer
	// Cells returns the cell renderers which have been added to cell_layout.
	Cells() []CellRendererer
	// PackEnd adds the cell to the end of cell_layout.
	PackEnd(cell CellRendererer, expand bool)
	// PackStart packs the cell into the beginning of cell_layout.
	PackStart(cell CellRendererer, expand bool)
	// Reorder re-inserts cell at position.
	Reorder(cell CellRendererer, position int)
	// SetCellDataFunc sets the CellLayoutDataFunc to use for cell_layout.
	SetCellDataFunc(cell CellRendererer, fn CellLayoutDataFunc)
}

var _ CellLayouter = (*CellLayout)(nil)

func wrapCellLayout(obj *coreglib.Object) *CellLayout {
	return &CellLayout{
		Object: obj,
	}
}

func marshalCellLayout(p uintptr) (interface{}, error) {
	return wrapCellLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddAttribute adds an attribute mapping to the list in cell_layout.
//
// The column is the column of the model to get a value from, and the attribute
// is the parameter on cell to be set from the value. So for example if column
// 2 of the model contains strings, you could have the “text” attribute of a
// CellRendererText get its values from column 2.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - attribute on the renderer.
//   - column position on the model to get the attribute from.
func (cellLayout *CellLayout) AddAttribute(cell CellRendererer, attribute string, column int) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 C.int              // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(column)

	C.gtk_cell_layout_add_attribute(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(column)
}

// Clear unsets all the mappings on all renderers on cell_layout and removes all
// renderers from cell_layout.
func (cellLayout *CellLayout) Clear() {
	var _arg0 *C.GtkCellLayout // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))

	C.gtk_cell_layout_clear(_arg0)
	runtime.KeepAlive(cellLayout)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
//
// The function takes the following parameters:
//
//   - cell to clear the attribute mapping on.
func (cellLayout *CellLayout) ClearAttributes(cell CellRendererer) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	C.gtk_cell_layout_clear_attributes(_arg0, _arg1)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
}

// Area returns the underlying CellArea which might be cell_layout if called on
// a CellArea or might be NULL if no CellArea is used by cell_layout.
//
// The function returns the following values:
//
//   - cellArea (optional): cell area used by cell_layout, or NULL in case no
//     cell area is used.
func (cellLayout *CellLayout) Area() CellAreaer {
	var _arg0 *C.GtkCellLayout // out
	var _cret *C.GtkCellArea   // in

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))

	_cret = C.gtk_cell_layout_get_area(_arg0)
	runtime.KeepAlive(cellLayout)

	var _cellArea CellAreaer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellAreaer)
				return ok
			})
			rv, ok := casted.(CellAreaer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellAreaer")
			}
			_cellArea = rv
		}
	}

	return _cellArea
}

// Cells returns the cell renderers which have been added to cell_layout.
//
// The function returns the following values:
//
//   - list: a list of cell renderers. The list, but not the renderers has been
//     newly allocated and should be freed with g_list_free() when no longer
//     needed.
func (cellLayout *CellLayout) Cells() []CellRendererer {
	var _arg0 *C.GtkCellLayout // out
	var _cret *C.GList         // in

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))

	_cret = C.gtk_cell_layout_get_cells(_arg0)
	runtime.KeepAlive(cellLayout)

	var _list []CellRendererer // out

	_list = make([]CellRendererer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkCellRenderer)(v)
		var dst CellRendererer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.CellRendererer is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// PackEnd adds the cell to the end of cell_layout. If expand is FALSE, then the
// cell is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which expand is TRUE.
//
// Note that reusing the same cell renderer is not supported.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - expand: TRUE if cell is to be given extra space allocated to cell_layout.
func (cellLayout *CellLayout) PackEnd(cell CellRendererer, expand bool) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_end(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(expand)
}

// PackStart packs the cell into the beginning of cell_layout. If expand is
// FALSE, then the cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which expand is TRUE.
//
// Note that reusing the same cell renderer is not supported.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - expand: TRUE if cell is to be given extra space allocated to cell_layout.
func (cellLayout *CellLayout) PackStart(cell CellRendererer, expand bool) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_cell_layout_pack_start(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(expand)
}

// Reorder re-inserts cell at position.
//
// Note that cell has already to be packed into cell_layout for this to function
// properly.
//
// The function takes the following parameters:
//
//   - cell to reorder.
//   - position: new position to insert cell at.
func (cellLayout *CellLayout) Reorder(cell CellRendererer, position int) {
	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.int              // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg2 = C.int(position)

	C.gtk_cell_layout_reorder(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(position)
}

// SetCellDataFunc sets the CellLayoutDataFunc to use for cell_layout.
//
// This function is used instead of the standard attributes mapping for setting
// the column value, and should set the value of cell_layout’s cell renderer(s)
// as appropriate.
//
// func may be NULL to remove a previously set function.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - fn (optional) to use, or NULL.
func (cellLayout *CellLayout) SetCellDataFunc(cell CellRendererer, fn CellLayoutDataFunc) {
	var _arg0 *C.GtkCellLayout        // out
	var _arg1 *C.GtkCellRenderer      // out
	var _arg2 C.GtkCellLayoutDataFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if fn != nil {
		_arg2 = (*[0]byte)(C._gotk4_gtk4_CellLayoutDataFunc)
		_arg3 = C.gpointer(gbox.Assign(fn))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_cell_layout_set_cell_data_func(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(fn)
}

// addAttribute adds an attribute mapping to the list in cell_layout.
//
// The column is the column of the model to get a value from, and the attribute
// is the parameter on cell to be set from the value. So for example if column
// 2 of the model contains strings, you could have the “text” attribute of a
// CellRendererText get its values from column 2.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - attribute on the renderer.
//   - column position on the model to get the attribute from.
func (cellLayout *CellLayout) addAttribute(cell CellRendererer, attribute string, column int) {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.add_attribute

	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 C.int              // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(column)

	C._gotk4_gtk4_CellLayout_virtual_add_attribute(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(column)
}

// Clear unsets all the mappings on all renderers on cell_layout and removes all
// renderers from cell_layout.
func (cellLayout *CellLayout) clear() {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.clear

	var _arg0 *C.GtkCellLayout // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))

	C._gotk4_gtk4_CellLayout_virtual_clear(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cellLayout)
}

// clearAttributes clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
//
// The function takes the following parameters:
//
//   - cell to clear the attribute mapping on.
func (cellLayout *CellLayout) clearAttributes(cell CellRendererer) {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.clear_attributes

	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	C._gotk4_gtk4_CellLayout_virtual_clear_attributes(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
}

// Area returns the underlying CellArea which might be cell_layout if called on
// a CellArea or might be NULL if no CellArea is used by cell_layout.
//
// The function returns the following values:
//
//   - cellArea (optional): cell area used by cell_layout, or NULL in case no
//     cell area is used.
func (cellLayout *CellLayout) area() CellAreaer {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.get_area

	var _arg0 *C.GtkCellLayout // out
	var _cret *C.GtkCellArea   // in

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))

	_cret = C._gotk4_gtk4_CellLayout_virtual_get_area(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cellLayout)

	var _cellArea CellAreaer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellAreaer)
				return ok
			})
			rv, ok := casted.(CellAreaer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellAreaer")
			}
			_cellArea = rv
		}
	}

	return _cellArea
}

// Cells returns the cell renderers which have been added to cell_layout.
//
// The function returns the following values:
//
//   - list: a list of cell renderers. The list, but not the renderers has been
//     newly allocated and should be freed with g_list_free() when no longer
//     needed.
func (cellLayout *CellLayout) cells() []CellRendererer {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.get_cells

	var _arg0 *C.GtkCellLayout // out
	var _cret *C.GList         // in

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))

	_cret = C._gotk4_gtk4_CellLayout_virtual_get_cells(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cellLayout)

	var _list []CellRendererer // out

	_list = make([]CellRendererer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkCellRenderer)(v)
		var dst CellRendererer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.CellRendererer is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// packEnd adds the cell to the end of cell_layout. If expand is FALSE, then the
// cell is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which expand is TRUE.
//
// Note that reusing the same cell renderer is not supported.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - expand: TRUE if cell is to be given extra space allocated to cell_layout.
func (cellLayout *CellLayout) packEnd(cell CellRendererer, expand bool) {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.pack_end

	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C._gotk4_gtk4_CellLayout_virtual_pack_end(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(expand)
}

// packStart packs the cell into the beginning of cell_layout. If expand is
// FALSE, then the cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which expand is TRUE.
//
// Note that reusing the same cell renderer is not supported.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - expand: TRUE if cell is to be given extra space allocated to cell_layout.
func (cellLayout *CellLayout) packStart(cell CellRendererer, expand bool) {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.pack_start

	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C._gotk4_gtk4_CellLayout_virtual_pack_start(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(expand)
}

// Reorder re-inserts cell at position.
//
// Note that cell has already to be packed into cell_layout for this to function
// properly.
//
// The function takes the following parameters:
//
//   - cell to reorder.
//   - position: new position to insert cell at.
func (cellLayout *CellLayout) reorder(cell CellRendererer, position int) {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.reorder

	var _arg0 *C.GtkCellLayout   // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.int              // out

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg2 = C.int(position)

	C._gotk4_gtk4_CellLayout_virtual_reorder(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(position)
}

// setCellDataFunc sets the CellLayoutDataFunc to use for cell_layout.
//
// This function is used instead of the standard attributes mapping for setting
// the column value, and should set the value of cell_layout’s cell renderer(s)
// as appropriate.
//
// func may be NULL to remove a previously set function.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - fn (optional) to use, or NULL.
func (cellLayout *CellLayout) setCellDataFunc(cell CellRendererer, fn CellLayoutDataFunc) {
	gclass := (*C.GtkCellLayoutIface)(coreglib.PeekParentClass(cellLayout))
	fnarg := gclass.set_cell_data_func

	var _arg0 *C.GtkCellLayout        // out
	var _arg1 *C.GtkCellRenderer      // out
	var _arg2 C.GtkCellLayoutDataFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(coreglib.InternObject(cellLayout).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if fn != nil {
		_arg2 = (*[0]byte)(C._gotk4_gtk4_CellLayoutDataFunc)
		_arg3 = C.gpointer(gbox.Assign(fn))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C._gotk4_gtk4_CellLayout_virtual_set_cell_data_func(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(cellLayout)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(fn)
}

// ColorChooser: GtkColorChooser is an interface that is implemented by widgets
// for choosing colors.
//
// Depending on the situation, colors may be allowed to have alpha
// (translucency).
//
// In GTK, the main widgets that implement this interface are
// gtk.ColorChooserWidget, gtk.ColorChooserDialog and gtk.ColorButton.
//
// ColorChooser wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ColorChooser struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ColorChooser)(nil)
)

// ColorChooserer describes ColorChooser's interface methods.
type ColorChooserer interface {
	coreglib.Objector

	// AddPalette adds a palette to the color chooser.
	AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA)
	// RGBA gets the currently-selected color.
	RGBA() *gdk.RGBA
	// UseAlpha returns whether the color chooser shows the alpha channel.
	UseAlpha() bool
	// SetRGBA sets the color.
	SetRGBA(color *gdk.RGBA)
	// SetUseAlpha sets whether or not the color chooser should use the alpha
	// channel.
	SetUseAlpha(useAlpha bool)

	// Color-activated is emitted when a color is activated from the color
	// chooser.
	ConnectColorActivated(func(color *gdk.RGBA)) coreglib.SignalHandle
}

var _ ColorChooserer = (*ColorChooser)(nil)

func wrapColorChooser(obj *coreglib.Object) *ColorChooser {
	return &ColorChooser{
		Object: obj,
	}
}

func marshalColorChooser(p uintptr) (interface{}, error) {
	return wrapColorChooser(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectColorActivated is emitted when a color is activated from the color
// chooser.
//
// This usually happens when the user clicks a color swatch, or a color is
// selected and the user presses one of the keys Space, Shift+Space, Return or
// Enter.
func (chooser *ColorChooser) ConnectColorActivated(f func(color *gdk.RGBA)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(chooser, "color-activated", false, unsafe.Pointer(C._gotk4_gtk4_ColorChooser_ConnectColorActivated), f)
}

// AddPalette adds a palette to the color chooser.
//
// If orientation is horizontal, the colors are grouped in rows, with
// colors_per_line colors in each row. If horizontal is FALSE, the colors are
// grouped in columns instead.
//
// The default color palette of gtk.ColorChooserWidget has 45 colors, organized
// in columns of 5 colors (this includes some grays).
//
// The layout of the color chooser widget works best when the palettes have 9-10
// columns.
//
// Calling this function for the first time has the side effect of removing the
// default color palette from the color chooser.
//
// If colors is NULL, removes all previously added palettes.
//
// The function takes the following parameters:
//
//   - orientation: GTK_ORIENTATION_HORIZONTAL if the palette should be
//     displayed in rows, GTK_ORIENTATION_VERTICAL for columns.
//   - colorsPerLine: number of colors to show in each row/column.
//   - colors (optional) of the palette, or NULL.
func (chooser *ColorChooser) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.GtkOrientation   // out
	var _arg2 C.int              // out
	var _arg4 *C.GdkRGBA         // out
	var _arg3 C.int

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.int(colorsPerLine)
	_arg3 = (C.int)(len(colors))
	_arg4 = (*C.GdkRGBA)(C.calloc(C.size_t(len(colors)), C.size_t(C.sizeof_GdkRGBA)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GdkRGBA)(_arg4), len(colors))
		for i := range colors {
			out[i] = *(*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer((&colors[i]))))
		}
	}

	C.gtk_color_chooser_add_palette(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(colorsPerLine)
	runtime.KeepAlive(colors)
}

// RGBA gets the currently-selected color.
//
// The function returns the following values:
//
//   - color: GdkRGBA to fill in with the current color.
func (chooser *ColorChooser) RGBA() *gdk.RGBA {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.GdkRGBA          // in

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	C.gtk_color_chooser_get_rgba(_arg0, &_arg1)
	runtime.KeepAlive(chooser)

	var _color *gdk.RGBA // out

	_color = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _color
}

// UseAlpha returns whether the color chooser shows the alpha channel.
//
// The function returns the following values:
//
//   - ok: TRUE if the color chooser uses the alpha channel, FALSE if not.
func (chooser *ColorChooser) UseAlpha() bool {
	var _arg0 *C.GtkColorChooser // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_color_chooser_get_use_alpha(_arg0)
	runtime.KeepAlive(chooser)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetRGBA sets the color.
//
// The function takes the following parameters:
//
//   - color: new color.
func (chooser *ColorChooser) SetRGBA(color *gdk.RGBA) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 *C.GdkRGBA         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))

	C.gtk_color_chooser_set_rgba(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(color)
}

// SetUseAlpha sets whether or not the color chooser should use the alpha
// channel.
//
// The function takes the following parameters:
//
//   - useAlpha: TRUE if color chooser should use alpha channel, FALSE if not.
func (chooser *ColorChooser) SetUseAlpha(useAlpha bool) {
	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	if useAlpha {
		_arg1 = C.TRUE
	}

	C.gtk_color_chooser_set_use_alpha(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(useAlpha)
}

// addPalette adds a palette to the color chooser.
//
// If orientation is horizontal, the colors are grouped in rows, with
// colors_per_line colors in each row. If horizontal is FALSE, the colors are
// grouped in columns instead.
//
// The default color palette of gtk.ColorChooserWidget has 45 colors, organized
// in columns of 5 colors (this includes some grays).
//
// The layout of the color chooser widget works best when the palettes have 9-10
// columns.
//
// Calling this function for the first time has the side effect of removing the
// default color palette from the color chooser.
//
// If colors is NULL, removes all previously added palettes.
//
// The function takes the following parameters:
//
//   - orientation: GTK_ORIENTATION_HORIZONTAL if the palette should be
//     displayed in rows, GTK_ORIENTATION_VERTICAL for columns.
//   - colorsPerLine: number of colors to show in each row/column.
//   - colors (optional) of the palette, or NULL.
func (chooser *ColorChooser) addPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) {
	gclass := (*C.GtkColorChooserInterface)(coreglib.PeekParentClass(chooser))
	fnarg := gclass.add_palette

	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.GtkOrientation   // out
	var _arg2 C.int              // out
	var _arg4 *C.GdkRGBA         // out
	var _arg3 C.int

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.int(colorsPerLine)
	_arg3 = (C.int)(len(colors))
	_arg4 = (*C.GdkRGBA)(C.calloc(C.size_t(len(colors)), C.size_t(C.sizeof_GdkRGBA)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GdkRGBA)(_arg4), len(colors))
		for i := range colors {
			out[i] = *(*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer((&colors[i]))))
		}
	}

	C._gotk4_gtk4_ColorChooser_virtual_add_palette(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(colorsPerLine)
	runtime.KeepAlive(colors)
}

func (chooser *ColorChooser) colorActivated(color *gdk.RGBA) {
	gclass := (*C.GtkColorChooserInterface)(coreglib.PeekParentClass(chooser))
	fnarg := gclass.color_activated

	var _arg0 *C.GtkColorChooser // out
	var _arg1 *C.GdkRGBA         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))

	C._gotk4_gtk4_ColorChooser_virtual_color_activated(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(color)
}

// rgbA gets the currently-selected color.
//
// The function returns the following values:
//
//   - color: GdkRGBA to fill in with the current color.
func (chooser *ColorChooser) rgbA() *gdk.RGBA {
	gclass := (*C.GtkColorChooserInterface)(coreglib.PeekParentClass(chooser))
	fnarg := gclass.get_rgba

	var _arg0 *C.GtkColorChooser // out
	var _arg1 C.GdkRGBA          // in

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	C._gotk4_gtk4_ColorChooser_virtual_get_rgba(unsafe.Pointer(fnarg), _arg0, &_arg1)
	runtime.KeepAlive(chooser)

	var _color *gdk.RGBA // out

	_color = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _color
}

// setRGBA sets the color.
//
// The function takes the following parameters:
//
//   - color: new color.
func (chooser *ColorChooser) setRGBA(color *gdk.RGBA) {
	gclass := (*C.GtkColorChooserInterface)(coreglib.PeekParentClass(chooser))
	fnarg := gclass.set_rgba

	var _arg0 *C.GtkColorChooser // out
	var _arg1 *C.GdkRGBA         // out

	_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))

	C._gotk4_gtk4_ColorChooser_virtual_set_rgba(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(color)
}

// ConstraintTarget: GtkConstraintTarget interface is implemented by objects
// that can be used as source or target in GtkConstraints.
//
// Besides GtkWidget, it is also implemented by GtkConstraintGuide.
//
// ConstraintTarget wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ConstraintTarget struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ConstraintTarget)(nil)
)

// ConstraintTargetter describes ConstraintTarget's interface methods.
type ConstraintTargetter interface {
	coreglib.Objector

	baseConstraintTarget() *ConstraintTarget
}

var _ ConstraintTargetter = (*ConstraintTarget)(nil)

func wrapConstraintTarget(obj *coreglib.Object) *ConstraintTarget {
	return &ConstraintTarget{
		Object: obj,
	}
}

func marshalConstraintTarget(p uintptr) (interface{}, error) {
	return wrapConstraintTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *ConstraintTarget) baseConstraintTarget() *ConstraintTarget {
	return v
}

// BaseConstraintTarget returns the underlying base object.
func BaseConstraintTarget(obj ConstraintTargetter) *ConstraintTarget {
	return obj.baseConstraintTarget()
}

// EditableTextWidget: GtkEditable is an interface for text editing widgets.
//
// Typical examples of editable widgets are gtk.Entry and gtk.SpinButton.
// It contains functions for generically manipulating an editable widget,
// a large number of action signals used for key bindings, and several signals
// that an application can connect to modify the behavior of a widget.
//
// As an example of the latter usage, by connecting the following handler to
// gtk.Editable::insert-text, an application can convert all entry into a widget
// into uppercase.
//
// Forcing entry to uppercase.
//
//	#include <ctype.h>
//
//	void
//	insert_text_handler (GtkEditable *editable,
//	                     const char  *text,
//	                     int          length,
//	                     int         *position,
//	                     gpointer     data)
//	{
//	  char *result = g_utf8_strup (text, length);
//
//	  g_signal_handlers_block_by_func (editable,
//	                               (gpointer) insert_text_handler, data);
//	  gtk_editable_insert_text (editable, result, length, position);
//	  g_signal_handlers_unblock_by_func (editable,
//	                                     (gpointer) insert_text_handler, data);
//
//	  g_signal_stop_emission_by_name (editable, "insert_text");
//
//	  g_free (result);
//	}
//
// # Implementing GtkEditable
//
// The most likely scenario for implementing GtkEditable on your own widget is
// that you will embed a Text inside a complex widget, and want to delegate the
// editable functionality to that text widget. GtkEditable provides some utility
// functions to make this easy.
//
// In your class_init function, call gtk.Editable().InstallProperties, passing
// the first available property ID:
//
//	static void
//	my_class_init (MyClass *class)
//	{
//	  ...
//	  g_object_class_install_properties (object_class, NUM_PROPERTIES, props);
//	  gtk_editable_install_properties (object_clas, NUM_PROPERTIES);
//	  ...
//	}
//
// In your interface_init function for the GtkEditable interface, provide an
// implementation for the get_delegate vfunc that returns your text widget:
//
//	GtkEditable *
//	get_editable_delegate (GtkEditable *editable)
//	{
//	  return GTK_EDITABLE (MY_WIDGET (editable)->text_widget);
//	}
//
//	static void
//	my_editable_init (GtkEditableInterface *iface)
//	{
//	  iface->get_delegate = get_editable_delegate;
//	}
//
// You don't need to provide any other vfuncs. The default implementations work
// by forwarding to the delegate that the GtkEditableInterface.get_delegate()
// vfunc returns.
//
// In your instance_init function, create your text widget, and then call
// gtk.Editable.InitDelegate():
//
//	static void
//	my_widget_init (MyWidget *self)
//	{
//	  ...
//	  self->text_widget = gtk_text_new ();
//	  gtk_editable_init_delegate (GTK_EDITABLE (self));
//	  ...
//	}
//
// In your dispose function, call gtk.Editable.FinishDelegate() before
// destroying your text widget:
//
//	static void
//	my_widget_dispose (GObject *object)
//	{
//	  ...
//	  gtk_editable_finish_delegate (GTK_EDITABLE (self));
//	  g_clear_pointer (&self->text_widget, gtk_widget_unparent);
//	  ...
//	}
//
// Finally, use gtk.Editable().DelegateSetProperty in your set_property function
// (and similar for get_property), to set the editable properties:
//
//	...
//	if (gtk_editable_delegate_set_property (object, prop_id, value, pspec))
//	  return;
//
//	switch (prop_id)
//	...
//
// It is important to note that if you create a GtkEditable that
// uses a delegate, the low level gtk.Editable::insert-text and
// gtk.Editable::delete-text signals will be propagated from the "wrapper"
// editable to the delegate, but they will not be propagated from the
// delegate to the "wrapper" editable, as they would cause an infinite
// recursion. If you wish to connect to the gtk.Editable::insert-text and
// gtk.Editable::delete-text signals, you will need to connect to them on the
// delegate obtained via gtk.Editable.GetDelegate().
//
// This type has been renamed from Editable.
//
// EditableTextWidget wraps an interface. This means the user can get the
// underlying type by calling Cast().
type EditableTextWidget struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*EditableTextWidget)(nil)
)

// EditableTextWidgetter describes EditableTextWidget's interface methods.
type EditableTextWidgetter interface {
	coreglib.Objector

	// DeleteSelection deletes the currently selected text of the editable.
	DeleteSelection()
	// DeleteText deletes a sequence of characters.
	DeleteText(startPos, endPos int)
	// FinishDelegate undoes the setup done by gtk.Editable.InitDelegate().
	FinishDelegate()
	// Alignment gets the alignment of the editable.
	Alignment() float32
	// Chars retrieves a sequence of characters.
	Chars(startPos, endPos int) string
	// Delegate gets the GtkEditable that editable is delegating its
	// implementation to.
	Delegate() *EditableTextWidget
	// Editable retrieves whether editable is editable.
	Editable() bool
	// EnableUndo gets if undo/redo actions are enabled for editable.
	EnableUndo() bool
	// MaxWidthChars retrieves the desired maximum width of editable,
	// in characters.
	MaxWidthChars() int
	// Position retrieves the current position of the cursor relative to the
	// start of the content of the editable.
	Position() int
	// SelectionBounds retrieves the selection bound of the editable.
	SelectionBounds() (startPos, endPos int, ok bool)
	// Text retrieves the contents of editable.
	Text() string
	// WidthChars gets the number of characters of space reserved for the
	// contents of the editable.
	WidthChars() int
	// InitDelegate sets up a delegate for GtkEditable.
	InitDelegate()
	// SelectRegion selects a region of text.
	SelectRegion(startPos, endPos int)
	// SetAlignment sets the alignment for the contents of the editable.
	SetAlignment(xalign float32)
	// SetEditable determines if the user can edit the text in the editable
	// widget.
	SetEditable(isEditable bool)
	// SetEnableUndo: if enabled, changes to editable will be saved for
	// undo/redo actions.
	SetEnableUndo(enableUndo bool)
	// SetMaxWidthChars sets the desired maximum width in characters of
	// editable.
	SetMaxWidthChars(nChars int)
	// SetPosition sets the cursor position in the editable to the given value.
	SetPosition(position int)
	// SetText sets the text in the editable to the given value.
	SetText(text string)
	// SetWidthChars changes the size request of the editable to be about the
	// right size for n_chars characters.
	SetWidthChars(nChars int)

	// Changed is emitted at the end of a single user-visible operation on the
	// contents.
	ConnectChanged(func()) coreglib.SignalHandle
	// Delete-text is emitted when text is deleted from the widget by the user.
	ConnectDeleteText(func(startPos, endPos int)) coreglib.SignalHandle
}

var _ EditableTextWidgetter = (*EditableTextWidget)(nil)

func wrapEditableTextWidget(obj *coreglib.Object) *EditableTextWidget {
	return &EditableTextWidget{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalEditableTextWidget(p uintptr) (interface{}, error) {
	return wrapEditableTextWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted at the end of a single user-visible operation on
// the contents.
//
// E.g., a paste operation that replaces the contents of the selection will
// cause only one signal emission (even though it is implemented by first
// deleting the selection, then inserting the new content, and may cause
// multiple ::notify::text signals to be emitted).
func (editable *EditableTextWidget) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(editable, "changed", false, unsafe.Pointer(C._gotk4_gtk4_EditableTextWidget_ConnectChanged), f)
}

// ConnectDeleteText is emitted when text is deleted from the widget by the
// user.
//
// The default handler for this signal will normally be responsible for deleting
// the text, so by connecting to this signal and then stopping the signal with
// g_signal_stop_emission(), it is possible to modify the range of deleted text,
// or prevent it from being deleted entirely.
//
// The start_pos and end_pos parameters are interpreted as for
// gtk.Editable.DeleteText().
func (editable *EditableTextWidget) ConnectDeleteText(f func(startPos, endPos int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(editable, "delete-text", false, unsafe.Pointer(C._gotk4_gtk4_EditableTextWidget_ConnectDeleteText), f)
}

// DeleteSelection deletes the currently selected text of the editable.
//
// This call doesn’t do anything if there is no selected text.
func (editable *EditableTextWidget) DeleteSelection() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	C.gtk_editable_delete_selection(_arg0)
	runtime.KeepAlive(editable)
}

// DeleteText deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions from
// start_pos up to, but not including end_pos. If end_pos is negative, then the
// characters deleted are those from start_pos to the end of the text.
//
// Note that the positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - startPos: start position.
//   - endPos: end position.
func (editable *EditableTextWidget) DeleteText(startPos, endPos int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(startPos)
	_arg2 = C.int(endPos)

	C.gtk_editable_delete_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)
}

// FinishDelegate undoes the setup done by gtk.Editable.InitDelegate().
//
// This is a helper function that should be called from dispose, before removing
// the delegate object.
func (editable *EditableTextWidget) FinishDelegate() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	C.gtk_editable_finish_delegate(_arg0)
	runtime.KeepAlive(editable)
}

// Alignment gets the alignment of the editable.
//
// The function returns the following values:
//
//   - gfloat: alignment.
func (editable *EditableTextWidget) Alignment() float32 {
	var _arg0 *C.GtkEditable // out
	var _cret C.float        // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_alignment(_arg0)
	runtime.KeepAlive(editable)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Chars retrieves a sequence of characters.
//
// The characters that are retrieved are those characters at positions from
// start_pos up to, but not including end_pos. If end_pos is negative, then the
// characters retrieved are those characters from start_pos to the end of the
// text.
//
// Note that positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - startPos: start of text.
//   - endPos: end of text.
//
// The function returns the following values:
//
//   - utf8: pointer to the contents of the widget as a string. This string is
//     allocated by the GtkEditable implementation and should be freed by the
//     caller.
func (editable *EditableTextWidget) Chars(startPos, endPos int) string {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(startPos)
	_arg2 = C.int(endPos)

	_cret = C.gtk_editable_get_chars(_arg0, _arg1, _arg2)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Delegate gets the GtkEditable that editable is delegating its implementation
// to.
//
// Typically, the delegate is a gtk.Text widget.
//
// The function returns the following values:
//
//   - ret (optional): delegate GtkEditable.
func (editable *EditableTextWidget) Delegate() *EditableTextWidget {
	var _arg0 *C.GtkEditable // out
	var _cret *C.GtkEditable // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_delegate(_arg0)
	runtime.KeepAlive(editable)

	var _ret *EditableTextWidget // out

	if _cret != nil {
		_ret = wrapEditableTextWidget(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ret
}

// Editable retrieves whether editable is editable.
//
// The function returns the following values:
//
//   - ok: TRUE if editable is editable.
func (editable *EditableTextWidget) Editable() bool {
	var _arg0 *C.GtkEditable // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_editable(_arg0)
	runtime.KeepAlive(editable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnableUndo gets if undo/redo actions are enabled for editable.
//
// The function returns the following values:
//
//   - ok: TRUE if undo is enabled.
func (editable *EditableTextWidget) EnableUndo() bool {
	var _arg0 *C.GtkEditable // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_enable_undo(_arg0)
	runtime.KeepAlive(editable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxWidthChars retrieves the desired maximum width of editable, in characters.
//
// The function returns the following values:
//
//   - gint: maximum width of the entry, in characters.
func (editable *EditableTextWidget) MaxWidthChars() int {
	var _arg0 *C.GtkEditable // out
	var _cret C.int          // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_max_width_chars(_arg0)
	runtime.KeepAlive(editable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Position retrieves the current position of the cursor relative to the start
// of the content of the editable.
//
// Note that this position is in characters, not in bytes.
//
// The function returns the following values:
//
//   - gint: cursor position.
func (editable *EditableTextWidget) Position() int {
	var _arg0 *C.GtkEditable // out
	var _cret C.int          // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_position(_arg0)
	runtime.KeepAlive(editable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SelectionBounds retrieves the selection bound of the editable.
//
// start_pos will be filled with the start of the selection and end_pos with
// end. If no text was selected both will be identical and FALSE will be
// returned.
//
// Note that positions are specified in characters, not bytes.
//
// The function returns the following values:
//
//   - startPos (optional): location to store the starting position, or NULL.
//   - endPos (optional): location to store the end position, or NULL.
//   - ok: TRUE if there is a non-empty selection, FALSE otherwise.
func (editable *EditableTextWidget) SelectionBounds() (startPos, endPos int, ok bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_selection_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(editable)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg1)
	_endPos = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// Text retrieves the contents of editable.
//
// The returned string is owned by GTK and must not be modified or freed.
//
// The function returns the following values:
//
//   - utf8: pointer to the contents of the editable.
func (editable *EditableTextWidget) Text() string {
	var _arg0 *C.GtkEditable // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_text(_arg0)
	runtime.KeepAlive(editable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// WidthChars gets the number of characters of space reserved for the contents
// of the editable.
//
// The function returns the following values:
//
//   - gint: number of chars to request space for, or negative if unset.
func (editable *EditableTextWidget) WidthChars() int {
	var _arg0 *C.GtkEditable // out
	var _cret C.int          // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C.gtk_editable_get_width_chars(_arg0)
	runtime.KeepAlive(editable)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InitDelegate sets up a delegate for GtkEditable.
//
// This is assuming that the get_delegate vfunc in the GtkEditable interface has
// been set up for the editable's type.
//
// This is a helper function that should be called in instance init, after
// creating the delegate object.
func (editable *EditableTextWidget) InitDelegate() {
	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	C.gtk_editable_init_delegate(_arg0)
	runtime.KeepAlive(editable)
}

// SelectRegion selects a region of text.
//
// The characters that are selected are those characters at positions from
// start_pos up to, but not including end_pos. If end_pos is negative, then the
// characters selected are those characters from start_pos to the end of the
// text.
//
// Note that positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - startPos: start of region.
//   - endPos: end of region.
func (editable *EditableTextWidget) SelectRegion(startPos, endPos int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(startPos)
	_arg2 = C.int(endPos)

	C.gtk_editable_select_region(_arg0, _arg1, _arg2)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)
}

// SetAlignment sets the alignment for the contents of the editable.
//
// This controls the horizontal positioning of the contents when the displayed
// text is shorter than the width of the editable.
//
// The function takes the following parameters:
//
//   - xalign: horizontal alignment, from 0 (left) to 1 (right). Reversed for
//     RTL layouts.
func (editable *EditableTextWidget) SetAlignment(xalign float32) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.float        // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.float(xalign)

	C.gtk_editable_set_alignment(_arg0, _arg1)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(xalign)
}

// SetEditable determines if the user can edit the text in the editable widget.
//
// The function takes the following parameters:
//
//   - isEditable: TRUE if the user is allowed to edit the text in the widget.
func (editable *EditableTextWidget) SetEditable(isEditable bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	if isEditable {
		_arg1 = C.TRUE
	}

	C.gtk_editable_set_editable(_arg0, _arg1)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(isEditable)
}

// SetEnableUndo: if enabled, changes to editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not stored in
// secure memory. As such, undo is forcefully disabled when gtk.Text:visibility
// is set to FALSE.
//
// The function takes the following parameters:
//
//   - enableUndo: if undo/redo should be enabled.
func (editable *EditableTextWidget) SetEnableUndo(enableUndo bool) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}

	C.gtk_editable_set_enable_undo(_arg0, _arg1)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(enableUndo)
}

// SetMaxWidthChars sets the desired maximum width in characters of editable.
//
// The function takes the following parameters:
//
//   - nChars: new desired maximum width, in characters.
func (editable *EditableTextWidget) SetMaxWidthChars(nChars int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(nChars)

	C.gtk_editable_set_max_width_chars(_arg0, _arg1)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(nChars)
}

// SetPosition sets the cursor position in the editable to the given value.
//
// The cursor is displayed before the character with the given (base 0) index
// in the contents of the editable. The value must be less than or equal to
// the number of characters in the editable. A value of -1 indicates that the
// position should be set after the last character of the editable. Note that
// position is in characters, not in bytes.
//
// The function takes the following parameters:
//
//   - position of the cursor.
func (editable *EditableTextWidget) SetPosition(position int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(position)

	C.gtk_editable_set_position(_arg0, _arg1)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(position)
}

// SetText sets the text in the editable to the given value.
//
// This is replacing the current contents.
//
// The function takes the following parameters:
//
//   - text to set.
func (editable *EditableTextWidget) SetText(text string) {
	var _arg0 *C.GtkEditable // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_editable_set_text(_arg0, _arg1)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(text)
}

// SetWidthChars changes the size request of the editable to be about the right
// size for n_chars characters.
//
// Note that it changes the size request, the size can still be affected by how
// you pack the widget into containers. If n_chars is -1, the size reverts to
// the default size.
//
// The function takes the following parameters:
//
//   - nChars: width in chars.
func (editable *EditableTextWidget) SetWidthChars(nChars int) {
	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(nChars)

	C.gtk_editable_set_width_chars(_arg0, _arg1)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(nChars)
}

func (editable *EditableTextWidget) changed() {
	gclass := (*C.GtkEditableInterface)(coreglib.PeekParentClass(editable))
	fnarg := gclass.changed

	var _arg0 *C.GtkEditable // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	C._gotk4_gtk4_EditableTextWidget_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(editable)
}

// deleteText deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions from
// start_pos up to, but not including end_pos. If end_pos is negative, then the
// characters deleted are those from start_pos to the end of the text.
//
// Note that the positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - startPos: start position.
//   - endPos: end position.
func (editable *EditableTextWidget) deleteText(startPos, endPos int) {
	gclass := (*C.GtkEditableInterface)(coreglib.PeekParentClass(editable))
	fnarg := gclass.delete_text

	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(startPos)
	_arg2 = C.int(endPos)

	C._gotk4_gtk4_EditableTextWidget_virtual_delete_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)
}

// doDeleteText deletes a sequence of characters.
//
// The characters that are deleted are those characters at positions from
// start_pos up to, but not including end_pos. If end_pos is negative, then the
// characters deleted are those from start_pos to the end of the text.
//
// Note that the positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - startPos: start position.
//   - endPos: end position.
func (editable *EditableTextWidget) doDeleteText(startPos, endPos int) {
	gclass := (*C.GtkEditableInterface)(coreglib.PeekParentClass(editable))
	fnarg := gclass.do_delete_text

	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(startPos)
	_arg2 = C.int(endPos)

	C._gotk4_gtk4_EditableTextWidget_virtual_do_delete_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)
}

// Delegate gets the GtkEditable that editable is delegating its implementation
// to.
//
// Typically, the delegate is a gtk.Text widget.
//
// The function returns the following values:
//
//   - ret (optional): delegate GtkEditable.
func (editable *EditableTextWidget) delegate() *EditableTextWidget {
	gclass := (*C.GtkEditableInterface)(coreglib.PeekParentClass(editable))
	fnarg := gclass.get_delegate

	var _arg0 *C.GtkEditable // out
	var _cret *C.GtkEditable // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C._gotk4_gtk4_EditableTextWidget_virtual_get_delegate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(editable)

	var _ret *EditableTextWidget // out

	if _cret != nil {
		_ret = wrapEditableTextWidget(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ret
}

// selectionBounds retrieves the selection bound of the editable.
//
// start_pos will be filled with the start of the selection and end_pos with
// end. If no text was selected both will be identical and FALSE will be
// returned.
//
// Note that positions are specified in characters, not bytes.
//
// The function returns the following values:
//
//   - startPos (optional): location to store the starting position, or NULL.
//   - endPos (optional): location to store the end position, or NULL.
//   - ok: TRUE if there is a non-empty selection, FALSE otherwise.
func (editable *EditableTextWidget) selectionBounds() (startPos, endPos int, ok bool) {
	gclass := (*C.GtkEditableInterface)(coreglib.PeekParentClass(editable))
	fnarg := gclass.get_selection_bounds

	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C._gotk4_gtk4_EditableTextWidget_virtual_get_selection_bounds(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(editable)

	var _startPos int // out
	var _endPos int   // out
	var _ok bool      // out

	_startPos = int(_arg1)
	_endPos = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _startPos, _endPos, _ok
}

// Text retrieves the contents of editable.
//
// The returned string is owned by GTK and must not be modified or freed.
//
// The function returns the following values:
//
//   - utf8: pointer to the contents of the editable.
func (editable *EditableTextWidget) text() string {
	gclass := (*C.GtkEditableInterface)(coreglib.PeekParentClass(editable))
	fnarg := gclass.get_text

	var _arg0 *C.GtkEditable // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))

	_cret = C._gotk4_gtk4_EditableTextWidget_virtual_get_text(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(editable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// setSelectionBounds selects a region of text.
//
// The characters that are selected are those characters at positions from
// start_pos up to, but not including end_pos. If end_pos is negative, then the
// characters selected are those characters from start_pos to the end of the
// text.
//
// Note that positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - startPos: start of region.
//   - endPos: end of region.
func (editable *EditableTextWidget) setSelectionBounds(startPos, endPos int) {
	gclass := (*C.GtkEditableInterface)(coreglib.PeekParentClass(editable))
	fnarg := gclass.set_selection_bounds

	var _arg0 *C.GtkEditable // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = C.int(startPos)
	_arg2 = C.int(endPos)

	C._gotk4_gtk4_EditableTextWidget_virtual_set_selection_bounds(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(startPos)
	runtime.KeepAlive(endPos)
}

// FileChooser: GtkFileChooser is an interface that can be implemented by file
// selection widgets.
//
// In GTK, the main objects that implement this interface are
// gtk.FileChooserWidget and gtk.FileChooserDialog.
//
// You do not need to write an object that implements the GtkFileChooser
// interface unless you are trying to adapt an existing file selector to expose
// a standard programming interface.
//
// GtkFileChooser allows for shortcuts to various places in the filesystem.
// In the default implementation these are displayed in the left pane. It may be
// a bit confusing at first that these shortcuts come from various sources and
// in various flavours, so lets explain the terminology here:
//
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the “Add”. Bookmarks can be renamed and deleted
// by the user.
//
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
//
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the “roots” of the filesystem.
//
// # File Names and Encodings
//
// When the user is finished selecting files in a GtkFileChooser, your program
// can get the selected filenames as GFiles.
//
// # Adding options
//
// You can add extra widgets to a file chooser to provide options that are
// not present in the default design, by using gtk.FileChooser.AddChoice().
// Each choice has an identifier and a user visible label; additionally,
// each choice can have multiple options. If a choice has no option, it will be
// rendered as a check button with the given label; if a choice has options,
// it will be rendered as a combo box.
//
// FileChooser wraps an interface. This means the user can get the
// underlying type by calling Cast().
type FileChooser struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FileChooser)(nil)
)

// FileChooserer describes FileChooser's interface methods.
type FileChooserer interface {
	coreglib.Objector

	// AddChoice adds a 'choice' to the file chooser.
	AddChoice(id, label string, options, optionLabels []string)
	// AddFilter adds filter to the list of filters that the user can select
	// between.
	AddFilter(filter *FileFilter)
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders
	// in a file chooser.
	AddShortcutFolder(folder gio.Filer) error
	// Action gets the type of operation that the file chooser is performing.
	Action() FileChooserAction
	// Choice gets the currently selected option in the 'choice' with the given
	// ID.
	Choice(id string) string
	// CreateFolders gets whether file chooser will offer to create new folders.
	CreateFolders() bool
	// CurrentFolder gets the current folder of chooser as #GFile.
	CurrentFolder() *gio.File
	// CurrentName gets the current name in the file selector, as entered by the
	// user.
	CurrentName() string
	// File gets the GFile for the currently selected file in the file selector.
	File() *gio.File
	// Files lists all the selected files and subfolders in the current folder
	// of chooser as #GFile.
	Files() *gio.ListModel
	// Filter gets the current filter.
	Filter() *FileFilter
	// Filters gets the current set of user-selectable filters, as a list model.
	Filters() *gio.ListModel
	// SelectMultiple gets whether multiple files can be selected in the file
	// chooser.
	SelectMultiple() bool
	// ShortcutFolders queries the list of shortcut folders in the file chooser.
	ShortcutFolders() *gio.ListModel
	// RemoveChoice removes a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	RemoveChoice(id string)
	// RemoveFilter removes filter from the list of filters that the user can
	// select between.
	RemoveFilter(filter *FileFilter)
	// RemoveShortcutFolder removes a folder from the shortcut folders in a file
	// chooser.
	RemoveShortcutFolder(folder gio.Filer) error
	// SetAction sets the type of operation that the chooser is performing.
	SetAction(action FileChooserAction)
	// SetChoice selects an option in a 'choice' that has been added with
	// gtk_file_chooser_add_choice().
	SetChoice(id, option string)
	// SetCreateFolders sets whether file chooser will offer to create new
	// folders.
	SetCreateFolders(createFolders bool)
	// SetCurrentFolder sets the current folder for chooser from a #GFile.
	SetCurrentFolder(file gio.Filer) error
	// SetCurrentName sets the current name in the file selector, as if entered
	// by the user.
	SetCurrentName(name string)
	// SetFile sets file as the current filename for the file chooser.
	SetFile(file gio.Filer) error
	// SetFilter sets the current filter.
	SetFilter(filter *FileFilter)
	// SetSelectMultiple sets whether multiple files can be selected in the file
	// chooser.
	SetSelectMultiple(selectMultiple bool)
}

var _ FileChooserer = (*FileChooser)(nil)

func wrapFileChooser(obj *coreglib.Object) *FileChooser {
	return &FileChooser{
		Object: obj,
	}
}

func marshalFileChooser(p uintptr) (interface{}, error) {
	return wrapFileChooser(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddChoice adds a 'choice' to the file chooser.
//
// This is typically implemented as a combobox or, for boolean choices,
// as a checkbutton. You can select a value using gtk.FileChooser.SetChoice()
// before the dialog is shown, and you can obtain the user-selected value in the
// gtk.Dialog::response signal handler using gtk.FileChooser.GetChoice().
//
// The function takes the following parameters:
//
//   - id for the added choice.
//   - label: user-visible label for the added choice.
//   - options (optional) ids for the options of the choice, or NULL for a
//     boolean choice.
//   - optionLabels (optional): user-visible labels for the options, must be the
//     same length as options.
func (chooser *FileChooser) AddChoice(id, label string, options, optionLabels []string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out
	var _arg3 **C.char          // out
	var _arg4 **C.char          // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(options) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(options)+1)
			var zero *C.char
			out[len(options)] = zero
			for i := range options {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(options[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	{
		_arg4 = (**C.char)(C.calloc(C.size_t((len(optionLabels) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(optionLabels)+1)
			var zero *C.char
			out[len(optionLabels)] = zero
			for i := range optionLabels {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(optionLabels[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_file_chooser_add_choice(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(id)
	runtime.KeepAlive(label)
	runtime.KeepAlive(options)
	runtime.KeepAlive(optionLabels)
}

// AddFilter adds filter to the list of filters that the user can select
// between.
//
// When a filter is selected, only files that are passed by that filter are
// displayed.
//
// Note that the chooser takes ownership of the filter if it is floating,
// so you have to ref and sink it if you want to keep a reference.
//
// The function takes the following parameters:
//
//   - filter: GtkFileFilter.
func (chooser *FileChooser) AddFilter(filter *FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gtk_file_chooser_add_filter(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(filter)
}

// AddShortcutFolder adds a folder to be displayed with the shortcut folders in
// a file chooser.
//
// The function takes the following parameters:
//
//   - folder: GFile for the folder to add.
func (chooser *FileChooser) AddShortcutFolder(folder gio.Filer) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(folder).Native()))

	C.gtk_file_chooser_add_shortcut_folder(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(folder)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Action gets the type of operation that the file chooser is performing.
//
// The function returns the following values:
//
//   - fileChooserAction: action that the file selector is performing.
func (chooser *FileChooser) Action() FileChooserAction {
	var _arg0 *C.GtkFileChooser      // out
	var _cret C.GtkFileChooserAction // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_action(_arg0)
	runtime.KeepAlive(chooser)

	var _fileChooserAction FileChooserAction // out

	_fileChooserAction = FileChooserAction(_cret)

	return _fileChooserAction
}

// Choice gets the currently selected option in the 'choice' with the given ID.
//
// The function takes the following parameters:
//
//   - id: ID of the choice to get.
//
// The function returns the following values:
//
//   - utf8: ID of the currently selected option.
func (chooser *FileChooser) Choice(id string) string {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_file_chooser_get_choice(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(id)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// CreateFolders gets whether file chooser will offer to create new folders.
//
// The function returns the following values:
//
//   - ok: TRUE if the Create Folder button should be displayed.
func (chooser *FileChooser) CreateFolders() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_create_folders(_arg0)
	runtime.KeepAlive(chooser)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CurrentFolder gets the current folder of chooser as #GFile.
//
// The function returns the following values:
//
//   - file: GFile for the current folder.
func (chooser *FileChooser) CurrentFolder() *gio.File {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GFile          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_current_folder(_arg0)
	runtime.KeepAlive(chooser)

	var _file *gio.File // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_file = &gio.File{
			Object: obj,
		}
	}

	return _file
}

// CurrentName gets the current name in the file selector, as entered by the
// user.
//
// This is meant to be used in save dialogs, to get the currently typed filename
// when the file itself does not exist yet.
//
// The function returns the following values:
//
//   - utf8: raw text from the file chooser’s “Name” entry. Free with g_free().
//     Note that this string is not a full pathname or URI; it is whatever
//     the contents of the entry are. Note also that this string is in UTF-8
//     encoding, which is not necessarily the system’s encoding for filenames.
func (chooser *FileChooser) CurrentName() string {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_current_name(_arg0)
	runtime.KeepAlive(chooser)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// File gets the GFile for the currently selected file in the file selector.
//
// If multiple files are selected, one of the files will be returned at random.
//
// If the file chooser is in folder mode, this function returns the selected
// folder.
//
// The function returns the following values:
//
//   - file: selected GFile. You own the returned file; use g_object_unref() to
//     release it.
func (chooser *FileChooser) File() *gio.File {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GFile          // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_file(_arg0)
	runtime.KeepAlive(chooser)

	var _file *gio.File // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_file = &gio.File{
			Object: obj,
		}
	}

	return _file
}

// Files lists all the selected files and subfolders in the current folder of
// chooser as #GFile.
//
// The function returns the following values:
//
//   - listModel: list model containing a GFile for each selected file
//     and subfolder in the current folder. Free the returned list with
//     g_object_unref().
func (chooser *FileChooser) Files() *gio.ListModel {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_files(_arg0)
	runtime.KeepAlive(chooser)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// Filter gets the current filter.
//
// The function returns the following values:
//
//   - fileFilter (optional): current filter, or NULL.
func (chooser *FileChooser) Filter() *FileFilter {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GtkFileFilter  // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_filter(_arg0)
	runtime.KeepAlive(chooser)

	var _fileFilter *FileFilter // out

	if _cret != nil {
		_fileFilter = wrapFileFilter(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _fileFilter
}

// Filters gets the current set of user-selectable filters, as a list model.
//
// See gtk.FileChooser.AddFilter() and gtk.FileChooser.RemoveFilter() for
// changing individual filters.
//
// You should not modify the returned list model. Future changes to chooser may
// or may not affect the returned model.
//
// The function returns the following values:
//
//   - listModel: GListModel containing the current set of user-selectable
//     filters.
func (chooser *FileChooser) Filters() *gio.ListModel {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_filters(_arg0)
	runtime.KeepAlive(chooser)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// SelectMultiple gets whether multiple files can be selected in the file
// chooser.
//
// The function returns the following values:
//
//   - ok: TRUE if multiple files can be selected.
func (chooser *FileChooser) SelectMultiple() bool {
	var _arg0 *C.GtkFileChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_select_multiple(_arg0)
	runtime.KeepAlive(chooser)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShortcutFolders queries the list of shortcut folders in the file chooser.
//
// You should not modify the returned list model. Future changes to chooser may
// or may not affect the returned model.
//
// The function returns the following values:
//
//   - listModel: list model of GFiles.
func (chooser *FileChooser) ShortcutFolders() *gio.ListModel {
	var _arg0 *C.GtkFileChooser // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))

	_cret = C.gtk_file_chooser_get_shortcut_folders(_arg0)
	runtime.KeepAlive(chooser)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
//
// The function takes the following parameters:
//
//   - id: ID of the choice to remove.
func (chooser *FileChooser) RemoveChoice(id string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_remove_choice(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(id)
}

// RemoveFilter removes filter from the list of filters that the user can select
// between.
//
// The function takes the following parameters:
//
//   - filter: GtkFileFilter.
func (chooser *FileChooser) RemoveFilter(filter *FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gtk_file_chooser_remove_filter(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(filter)
}

// RemoveShortcutFolder removes a folder from the shortcut folders in a file
// chooser.
//
// The function takes the following parameters:
//
//   - folder: GFile for the folder to remove.
func (chooser *FileChooser) RemoveShortcutFolder(folder gio.Filer) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(folder).Native()))

	C.gtk_file_chooser_remove_shortcut_folder(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(folder)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetAction sets the type of operation that the chooser is performing.
//
// The user interface is adapted to suit the selected action.
//
// For example, an option to create a new folder might be shown if
// the action is GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
//
// The function takes the following parameters:
//
//   - action that the file selector is performing.
func (chooser *FileChooser) SetAction(action FileChooserAction) {
	var _arg0 *C.GtkFileChooser      // out
	var _arg1 C.GtkFileChooserAction // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = C.GtkFileChooserAction(action)

	C.gtk_file_chooser_set_action(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(action)
}

// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice().
//
// For a boolean choice, the possible options are "true" and "false".
//
// The function takes the following parameters:
//
//   - id: ID of the choice to set.
//   - option: ID of the option to select.
func (chooser *FileChooser) SetChoice(id, option string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(option)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_file_chooser_set_choice(_arg0, _arg1, _arg2)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(id)
	runtime.KeepAlive(option)
}

// SetCreateFolders sets whether file chooser will offer to create new folders.
//
// This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
//
// The function takes the following parameters:
//
//   - createFolders: TRUE if the Create Folder button should be displayed.
func (chooser *FileChooser) SetCreateFolders(createFolders bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	if createFolders {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_create_folders(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(createFolders)
}

// SetCurrentFolder sets the current folder for chooser from a #GFile.
//
// The function takes the following parameters:
//
//   - file: GFile for the new folder.
func (chooser *FileChooser) SetCurrentFolder(file gio.Filer) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	C.gtk_file_chooser_set_current_folder(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(file)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetCurrentName sets the current name in the file selector, as if entered by
// the user.
//
// Note that the name passed in here is a UTF-8 string rather than a filename.
// This function is meant for such uses as a suggested name in a “Save As...”
// dialog. You can pass “Untitled.doc” or a similarly suitable suggestion for
// the name.
//
// If you want to preselect a particular existing file, you should use
// gtk.FileChooser.SetFile() instead.
//
// Please see the documentation for those functions for an example of using
// gtk.FileChooser.SetCurrentName() as well.
//
// The function takes the following parameters:
//
//   - name to use, as a UTF-8 string.
func (chooser *FileChooser) SetCurrentName(name string) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_chooser_set_current_name(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(name)
}

// SetFile sets file as the current filename for the file chooser.
//
// This includes changing to the file’s parent folder and actually selecting
// the file in list. If the chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode,
// the file’s base name will also appear in the dialog’s file name entry.
//
// If the file name isn’t in the current folder of chooser, then the current
// folder of chooser will be changed to the folder containing filename.
//
// Note that the file must exist, or nothing will be done except for the
// directory change.
//
// If you are implementing a save dialog, you should use this function if you
// already have a file name to which the user may save; for example, when the
// user opens an existing file and then does “Save As…”. If you don’t have a
// file name already — for example, if the user just created a new file and is
// saving it for the first time, do not call this function.
//
// Instead, use something similar to this:
//
//	static void
//	prepare_file_chooser (GtkFileChooser *chooser,
//	                      GFile          *existing_file)
//	{
//	  gboolean document_is_new = (existing_file == NULL);
//
//	  if (document_is_new)
//	    {
//	      GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//	      // the user just created a new document
//	      gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//	      gtk_file_chooser_set_current_name (chooser, "Untitled document");
//	      g_object_unref (default_file_for_saving);
//	    }
//	  else
//	    {
//	      // the user edited an existing document
//	      gtk_file_chooser_set_file (chooser, existing_file, NULL);
//	    }
//	}.
//
// The function takes the following parameters:
//
//   - file: GFile to set as current.
func (chooser *FileChooser) SetFile(file gio.Filer) error {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GFile          // out
	var _cerr *C.GError         // in

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	C.gtk_file_chooser_set_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(file)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetFilter sets the current filter.
//
// Only the files that pass the filter will be displayed. If the user-selectable
// list of filters is non-empty, then the filter should be one of the filters in
// that list.
//
// Setting the current filter when the list of filters is empty is useful if you
// want to restrict the displayed set of files without letting the user change
// it.
//
// The function takes the following parameters:
//
//   - filter: GtkFileFilter.
func (chooser *FileChooser) SetFilter(filter *FileFilter) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 *C.GtkFileFilter  // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gtk_file_chooser_set_filter(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(filter)
}

// SetSelectMultiple sets whether multiple files can be selected in the file
// chooser.
//
// This is only relevant if the action is set to be GTK_FILE_CHOOSER_ACTION_OPEN
// or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// The function takes the following parameters:
//
//   - selectMultiple: TRUE if multiple files can be selected.
func (chooser *FileChooser) SetSelectMultiple(selectMultiple bool) {
	var _arg0 *C.GtkFileChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	if selectMultiple {
		_arg1 = C.TRUE
	}

	C.gtk_file_chooser_set_select_multiple(_arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(selectMultiple)
}

// FontChooser: GtkFontChooser is an interface that can be implemented by
// widgets for choosing fonts.
//
// In GTK, the main objects that implement this interface are
// gtk.FontChooserWidget, gtk.FontChooserDialog and gtk.FontButton.
//
// FontChooser wraps an interface. This means the user can get the
// underlying type by calling Cast().
type FontChooser struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*FontChooser)(nil)
)

// FontChooserer describes FontChooser's interface methods.
type FontChooserer interface {
	coreglib.Objector

	// Font gets the currently-selected font name.
	Font() string
	// FontDesc gets the currently-selected font.
	FontDesc() *pango.FontDescription
	// FontFace gets the PangoFontFace representing the selected font group
	// details (i.e.
	FontFace() pango.FontFacer
	// FontFamily gets the PangoFontFamily representing the selected font
	// family.
	FontFamily() pango.FontFamilier
	// FontFeatures gets the currently-selected font features.
	FontFeatures() string
	// FontMap gets the custom font map of this font chooser widget, or NULL if
	// it does not have one.
	FontMap() pango.FontMapper
	// FontSize: selected font size.
	FontSize() int
	// Language gets the language that is used for font features.
	Language() string
	// Level returns the current level of granularity for selecting fonts.
	Level() FontChooserLevel
	// PreviewText gets the text displayed in the preview area.
	PreviewText() string
	// ShowPreviewEntry returns whether the preview entry is shown or not.
	ShowPreviewEntry() bool
	// SetFilterFunc adds a filter function that decides which fonts to display
	// in the font chooser.
	SetFilterFunc(filter FontFilterFunc)
	// SetFont sets the currently-selected font.
	SetFont(fontname string)
	// SetFontDesc sets the currently-selected font from font_desc.
	SetFontDesc(fontDesc *pango.FontDescription)
	// SetFontMap sets a custom font map to use for this font chooser widget.
	SetFontMap(fontmap pango.FontMapper)
	// SetLanguage sets the language to use for font features.
	SetLanguage(language string)
	// SetLevel sets the desired level of granularity for selecting fonts.
	SetLevel(level FontChooserLevel)
	// SetPreviewText sets the text displayed in the preview area.
	SetPreviewText(text string)
	// SetShowPreviewEntry shows or hides the editable preview entry.
	SetShowPreviewEntry(showPreviewEntry bool)

	// Font-activated is emitted when a font is activated.
	ConnectFontActivated(func(fontname string)) coreglib.SignalHandle
}

var _ FontChooserer = (*FontChooser)(nil)

func wrapFontChooser(obj *coreglib.Object) *FontChooser {
	return &FontChooser{
		Object: obj,
	}
}

func marshalFontChooser(p uintptr) (interface{}, error) {
	return wrapFontChooser(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectFontActivated is emitted when a font is activated.
//
// This usually happens when the user double clicks an item, or an item is
// selected and the user presses one of the keys Space, Shift+Space, Return or
// Enter.
func (fontchooser *FontChooser) ConnectFontActivated(f func(fontname string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(fontchooser, "font-activated", false, unsafe.Pointer(C._gotk4_gtk4_FontChooser_ConnectFontActivated), f)
}

// Font gets the currently-selected font name.
//
// Note that this can be a different string than what you set with
// gtk.FontChooser.SetFont(), as the font chooser widget may normalize font
// names and thus return a string with a different structure. For example,
// “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold Italic 12”.
//
// Use pango.FontDescription.Equal() if you want to compare two font
// descriptions.
//
// The function returns the following values:
//
//   - utf8 (optional): string with the name of the current font, or NULL if no
//     font is selected. You must free this string with g_free().
func (fontchooser *FontChooser) Font() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_font(_arg0)
	runtime.KeepAlive(fontchooser)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// FontDesc gets the currently-selected font.
//
// Note that this can be a different string than what you set with
// gtk.FontChooser.SetFont(), as the font chooser widget may normalize font
// names and thus return a string with a different structure. For example,
// “Helvetica Italic Bold 12” could be normalized to “Helvetica Bold Italic 12”.
//
// Use pango.FontDescription.Equal() if you want to compare two font
// descriptions.
//
// The function returns the following values:
//
//   - fontDescription (optional): PangoFontDescription for the current font,
//     or NULL if no font is selected.
func (fontchooser *FontChooser) FontDesc() *pango.FontDescription {
	var _arg0 *C.GtkFontChooser       // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_font_desc(_arg0)
	runtime.KeepAlive(fontchooser)

	var _fontDescription *pango.FontDescription // out

	if _cret != nil {
		_fontDescription = (*pango.FontDescription)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_fontDescription)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_font_description_free((*C.PangoFontDescription)(intern.C))
			},
		)
	}

	return _fontDescription
}

// FontFace gets the PangoFontFace representing the selected font group details
// (i.e. family, slant, weight, width, etc).
//
// If the selected font is not installed, returns NULL.
//
// The function returns the following values:
//
//   - fontFace (optional): PangoFontFace representing the selected font group
//     details, or NULL. The returned object is owned by fontchooser and must
//     not be modified or freed.
func (fontchooser *FontChooser) FontFace() pango.FontFacer {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontFace  // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_font_face(_arg0)
	runtime.KeepAlive(fontchooser)

	var _fontFace pango.FontFacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontFacer)
				return ok
			})
			rv, ok := casted.(pango.FontFacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
			}
			_fontFace = rv
		}
	}

	return _fontFace
}

// FontFamily gets the PangoFontFamily representing the selected font family.
//
// Font families are a collection of font faces.
//
// If the selected font is not installed, returns NULL.
//
// The function returns the following values:
//
//   - fontFamily (optional): PangoFontFamily representing the selected font
//     family, or NULL. The returned object is owned by fontchooser and must not
//     be modified or freed.
func (fontchooser *FontChooser) FontFamily() pango.FontFamilier {
	var _arg0 *C.GtkFontChooser  // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_font_family(_arg0)
	runtime.KeepAlive(fontchooser)

	var _fontFamily pango.FontFamilier // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontFamilier)
				return ok
			})
			rv, ok := casted.(pango.FontFamilier)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
			}
			_fontFamily = rv
		}
	}

	return _fontFamily
}

// FontFeatures gets the currently-selected font features.
//
// The function returns the following values:
//
//   - utf8: currently selected font features.
func (fontchooser *FontChooser) FontFeatures() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_font_features(_arg0)
	runtime.KeepAlive(fontchooser)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FontMap gets the custom font map of this font chooser widget, or NULL if it
// does not have one.
//
// The function returns the following values:
//
//   - fontMap (optional): PangoFontMap, or NULL.
func (fontchooser *FontChooser) FontMap() pango.FontMapper {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontMap   // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_font_map(_arg0)
	runtime.KeepAlive(fontchooser)

	var _fontMap pango.FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontMapper)
				return ok
			})
			rv, ok := casted.(pango.FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// FontSize: selected font size.
//
// The function returns the following values:
//
//   - gint: n integer representing the selected font size, or -1 if no font
//     size is selected.
func (fontchooser *FontChooser) FontSize() int {
	var _arg0 *C.GtkFontChooser // out
	var _cret C.int             // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_font_size(_arg0)
	runtime.KeepAlive(fontchooser)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Language gets the language that is used for font features.
//
// The function returns the following values:
//
//   - utf8: currently selected language.
func (fontchooser *FontChooser) Language() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_language(_arg0)
	runtime.KeepAlive(fontchooser)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Level returns the current level of granularity for selecting fonts.
//
// The function returns the following values:
//
//   - fontChooserLevel: current granularity level.
func (fontchooser *FontChooser) Level() FontChooserLevel {
	var _arg0 *C.GtkFontChooser     // out
	var _cret C.GtkFontChooserLevel // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_level(_arg0)
	runtime.KeepAlive(fontchooser)

	var _fontChooserLevel FontChooserLevel // out

	_fontChooserLevel = FontChooserLevel(_cret)

	return _fontChooserLevel
}

// PreviewText gets the text displayed in the preview area.
//
// The function returns the following values:
//
//   - utf8: text displayed in the preview area.
func (fontchooser *FontChooser) PreviewText() string {
	var _arg0 *C.GtkFontChooser // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_preview_text(_arg0)
	runtime.KeepAlive(fontchooser)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ShowPreviewEntry returns whether the preview entry is shown or not.
//
// The function returns the following values:
//
//   - ok: TRUE if the preview entry is shown or FALSE if it is hidden.
func (fontchooser *FontChooser) ShowPreviewEntry() bool {
	var _arg0 *C.GtkFontChooser // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C.gtk_font_chooser_get_show_preview_entry(_arg0)
	runtime.KeepAlive(fontchooser)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetFilterFunc adds a filter function that decides which fonts to display in
// the font chooser.
//
// The function takes the following parameters:
//
//   - filter (optional): GtkFontFilterFunc, or NULL.
func (fontchooser *FontChooser) SetFilterFunc(filter FontFilterFunc) {
	var _arg0 *C.GtkFontChooser   // out
	var _arg1 C.GtkFontFilterFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	if filter != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_FontFilterFunc)
		_arg2 = C.gpointer(gbox.Assign(filter))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_font_chooser_set_filter_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(filter)
}

// SetFont sets the currently-selected font.
//
// The function takes the following parameters:
//
//   - fontname: font name like “Helvetica 12” or “Times Bold 18”.
func (fontchooser *FontChooser) SetFont(fontname string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fontname)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_font(_arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(fontname)
}

// SetFontDesc sets the currently-selected font from font_desc.
//
// The function takes the following parameters:
//
//   - fontDesc: PangoFontDescription.
func (fontchooser *FontChooser) SetFontDesc(fontDesc *pango.FontDescription) {
	var _arg0 *C.GtkFontChooser       // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	_arg1 = (*C.PangoFontDescription)(gextras.StructNative(unsafe.Pointer(fontDesc)))

	C.gtk_font_chooser_set_font_desc(_arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(fontDesc)
}

// SetFontMap sets a custom font map to use for this font chooser widget.
//
// A custom font map can be used to present application-specific fonts instead
// of or in addition to the normal system fonts.
//
//	FcConfig *config;
//	PangoFontMap *fontmap;
//
//	config = FcInitLoadConfigAndFonts ();
//	FcConfigAppFontAddFile (config, my_app_font_file);
//
//	fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
//	pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
//
//	gtk_font_chooser_set_font_map (font_chooser, fontmap);
//
// Note that other GTK widgets will only be able to use the application-specific
// font if it is present in the font map they use:
//
//	context = gtk_widget_get_pango_context (label);
//	pango_context_set_font_map (context, fontmap);.
//
// The function takes the following parameters:
//
//   - fontmap (optional): PangoFontMap.
func (fontchooser *FontChooser) SetFontMap(fontmap pango.FontMapper) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.PangoFontMap   // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	if fontmap != nil {
		_arg1 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	}

	C.gtk_font_chooser_set_font_map(_arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(fontmap)
}

// SetLanguage sets the language to use for font features.
//
// The function takes the following parameters:
//
//   - language: language.
func (fontchooser *FontChooser) SetLanguage(language string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(language)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_language(_arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(language)
}

// SetLevel sets the desired level of granularity for selecting fonts.
//
// The function takes the following parameters:
//
//   - level: desired level of granularity.
func (fontchooser *FontChooser) SetLevel(level FontChooserLevel) {
	var _arg0 *C.GtkFontChooser     // out
	var _arg1 C.GtkFontChooserLevel // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	_arg1 = C.GtkFontChooserLevel(level)

	C.gtk_font_chooser_set_level(_arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(level)
}

// SetPreviewText sets the text displayed in the preview area.
//
// The text is used to show how the selected font looks.
//
// The function takes the following parameters:
//
//   - text to display in the preview area.
func (fontchooser *FontChooser) SetPreviewText(text string) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_chooser_set_preview_text(_arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(text)
}

// SetShowPreviewEntry shows or hides the editable preview entry.
//
// The function takes the following parameters:
//
//   - showPreviewEntry: whether to show the editable preview entry or not.
func (fontchooser *FontChooser) SetShowPreviewEntry(showPreviewEntry bool) {
	var _arg0 *C.GtkFontChooser // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	if showPreviewEntry {
		_arg1 = C.TRUE
	}

	C.gtk_font_chooser_set_show_preview_entry(_arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(showPreviewEntry)
}

func (chooser *FontChooser) fontActivated(fontname string) {
	gclass := (*C.GtkFontChooserIface)(coreglib.PeekParentClass(chooser))
	fnarg := gclass.font_activated

	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(chooser).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fontname)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gtk4_FontChooser_virtual_font_activated(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(chooser)
	runtime.KeepAlive(fontname)
}

// fontFace gets the PangoFontFace representing the selected font group details
// (i.e. family, slant, weight, width, etc).
//
// If the selected font is not installed, returns NULL.
//
// The function returns the following values:
//
//   - fontFace (optional): PangoFontFace representing the selected font group
//     details, or NULL. The returned object is owned by fontchooser and must
//     not be modified or freed.
func (fontchooser *FontChooser) fontFace() pango.FontFacer {
	gclass := (*C.GtkFontChooserIface)(coreglib.PeekParentClass(fontchooser))
	fnarg := gclass.get_font_face

	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontFace  // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C._gotk4_gtk4_FontChooser_virtual_get_font_face(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontchooser)

	var _fontFace pango.FontFacer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontFacer)
				return ok
			})
			rv, ok := casted.(pango.FontFacer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFacer")
			}
			_fontFace = rv
		}
	}

	return _fontFace
}

// fontFamily gets the PangoFontFamily representing the selected font family.
//
// Font families are a collection of font faces.
//
// If the selected font is not installed, returns NULL.
//
// The function returns the following values:
//
//   - fontFamily (optional): PangoFontFamily representing the selected font
//     family, or NULL. The returned object is owned by fontchooser and must not
//     be modified or freed.
func (fontchooser *FontChooser) fontFamily() pango.FontFamilier {
	gclass := (*C.GtkFontChooserIface)(coreglib.PeekParentClass(fontchooser))
	fnarg := gclass.get_font_family

	var _arg0 *C.GtkFontChooser  // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C._gotk4_gtk4_FontChooser_virtual_get_font_family(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontchooser)

	var _fontFamily pango.FontFamilier // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontFamilier)
				return ok
			})
			rv, ok := casted.(pango.FontFamilier)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontFamilier")
			}
			_fontFamily = rv
		}
	}

	return _fontFamily
}

// fontMap gets the custom font map of this font chooser widget, or NULL if it
// does not have one.
//
// The function returns the following values:
//
//   - fontMap (optional): PangoFontMap, or NULL.
func (fontchooser *FontChooser) fontMap() pango.FontMapper {
	gclass := (*C.GtkFontChooserIface)(coreglib.PeekParentClass(fontchooser))
	fnarg := gclass.get_font_map

	var _arg0 *C.GtkFontChooser // out
	var _cret *C.PangoFontMap   // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C._gotk4_gtk4_FontChooser_virtual_get_font_map(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontchooser)

	var _fontMap pango.FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontMapper)
				return ok
			})
			rv, ok := casted.(pango.FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// fontSize: selected font size.
//
// The function returns the following values:
//
//   - gint: n integer representing the selected font size, or -1 if no font
//     size is selected.
func (fontchooser *FontChooser) fontSize() int {
	gclass := (*C.GtkFontChooserIface)(coreglib.PeekParentClass(fontchooser))
	fnarg := gclass.get_font_size

	var _arg0 *C.GtkFontChooser // out
	var _cret C.int             // in

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))

	_cret = C._gotk4_gtk4_FontChooser_virtual_get_font_size(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(fontchooser)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// setFilterFunc adds a filter function that decides which fonts to display in
// the font chooser.
//
// The function takes the following parameters:
//
//   - filter (optional): GtkFontFilterFunc, or NULL.
func (fontchooser *FontChooser) setFilterFunc(filter FontFilterFunc) {
	gclass := (*C.GtkFontChooserIface)(coreglib.PeekParentClass(fontchooser))
	fnarg := gclass.set_filter_func

	var _arg0 *C.GtkFontChooser   // out
	var _arg1 C.GtkFontFilterFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	if filter != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_FontFilterFunc)
		_arg2 = C.gpointer(gbox.Assign(filter))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C._gotk4_gtk4_FontChooser_virtual_set_filter_func(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(filter)
}

// setFontMap sets a custom font map to use for this font chooser widget.
//
// A custom font map can be used to present application-specific fonts instead
// of or in addition to the normal system fonts.
//
//	FcConfig *config;
//	PangoFontMap *fontmap;
//
//	config = FcInitLoadConfigAndFonts ();
//	FcConfigAppFontAddFile (config, my_app_font_file);
//
//	fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
//	pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
//
//	gtk_font_chooser_set_font_map (font_chooser, fontmap);
//
// Note that other GTK widgets will only be able to use the application-specific
// font if it is present in the font map they use:
//
//	context = gtk_widget_get_pango_context (label);
//	pango_context_set_font_map (context, fontmap);.
//
// The function takes the following parameters:
//
//   - fontmap (optional): PangoFontMap.
func (fontchooser *FontChooser) setFontMap(fontmap pango.FontMapper) {
	gclass := (*C.GtkFontChooserIface)(coreglib.PeekParentClass(fontchooser))
	fnarg := gclass.set_font_map

	var _arg0 *C.GtkFontChooser // out
	var _arg1 *C.PangoFontMap   // out

	_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(coreglib.InternObject(fontchooser).Native()))
	if fontmap != nil {
		_arg1 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontmap).Native()))
	}

	C._gotk4_gtk4_FontChooser_virtual_set_font_map(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(fontchooser)
	runtime.KeepAlive(fontmap)
}

// NativeSurface: GtkNative is the interface implemented by all widgets that
// have their own GdkSurface.
//
// The obvious example of a GtkNative is GtkWindow.
//
// Every widget that is not itself a GtkNative is contained in one, and you can
// get it with gtk.Widget.GetNative().
//
// To get the surface of a GtkNative, use gtk.Native.GetSurface().
// It is also possible to find the GtkNative to which a surface belongs,
// with gtk.Native().GetForSurface.
//
// In addition to a gdk.Surface, a GtkNative also provides a gsk.Renderer for
// rendering on that surface. To get the renderer, use gtk.Native.GetRenderer().
//
// This type has been renamed from Native.
//
// NativeSurface wraps an interface. This means the user can get the
// underlying type by calling Cast().
type NativeSurface struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*NativeSurface)(nil)
)

// NativeSurfacer describes NativeSurface's interface methods.
type NativeSurfacer interface {
	coreglib.Objector

	// Renderer returns the renderer that is used for this GtkNative.
	Renderer() gsk.Rendererer
	// Surface returns the surface of this GtkNative.
	Surface() gdk.Surfacer
	// SurfaceTransform retrieves the surface transform of self.
	SurfaceTransform() (x, y float64)
	// Realize realizes a GtkNative.
	Realize()
	// Unrealize unrealizes a GtkNative.
	Unrealize()
}

var _ NativeSurfacer = (*NativeSurface)(nil)

func wrapNativeSurface(obj *coreglib.Object) *NativeSurface {
	return &NativeSurface{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalNativeSurface(p uintptr) (interface{}, error) {
	return wrapNativeSurface(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Renderer returns the renderer that is used for this GtkNative.
//
// The function returns the following values:
//
//   - renderer for self.
func (self *NativeSurface) Renderer() gsk.Rendererer {
	var _arg0 *C.GtkNative   // out
	var _cret *C.GskRenderer // in

	_arg0 = (*C.GtkNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_native_get_renderer(_arg0)
	runtime.KeepAlive(self)

	var _renderer gsk.Rendererer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.Rendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gsk.Rendererer)
			return ok
		})
		rv, ok := casted.(gsk.Rendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.Rendererer")
		}
		_renderer = rv
	}

	return _renderer
}

// Surface returns the surface of this GtkNative.
//
// The function returns the following values:
//
//   - surface of self.
func (self *NativeSurface) Surface() gdk.Surfacer {
	var _arg0 *C.GtkNative  // out
	var _cret *C.GdkSurface // in

	_arg0 = (*C.GtkNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_native_get_surface(_arg0)
	runtime.KeepAlive(self)

	var _surface gdk.Surfacer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.Surfacer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.Surfacer)
			return ok
		})
		rv, ok := casted.(gdk.Surfacer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Surfacer")
		}
		_surface = rv
	}

	return _surface
}

// SurfaceTransform retrieves the surface transform of self.
//
// This is the translation from self's surface coordinates into self's widget
// coordinates.
//
// The function returns the following values:
//
//   - x: return location for the x coordinate.
//   - y: return location for the y coordinate.
func (self *NativeSurface) SurfaceTransform() (x, y float64) {
	var _arg0 *C.GtkNative // out
	var _arg1 C.double     // in
	var _arg2 C.double     // in

	_arg0 = (*C.GtkNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_native_get_surface_transform(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(self)

	var _x float64 // out
	var _y float64 // out

	_x = float64(_arg1)
	_y = float64(_arg2)

	return _x, _y
}

// Realize realizes a GtkNative.
//
// This should only be used by subclasses.
func (self *NativeSurface) Realize() {
	var _arg0 *C.GtkNative // out

	_arg0 = (*C.GtkNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_native_realize(_arg0)
	runtime.KeepAlive(self)
}

// Unrealize unrealizes a GtkNative.
//
// This should only be used by subclasses.
func (self *NativeSurface) Unrealize() {
	var _arg0 *C.GtkNative // out

	_arg0 = (*C.GtkNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_native_unrealize(_arg0)
	runtime.KeepAlive(self)
}

// NativeSurfaceGetForSurface finds the GtkNative associated with the surface.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface.
//
// The function returns the following values:
//
//   - native: GtkNative that is associated with surface.
func NativeSurfaceGetForSurface(surface gdk.Surfacer) *NativeSurface {
	var _arg1 *C.GdkSurface // out
	var _cret *C.GtkNative  // in

	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	_cret = C.gtk_native_get_for_surface(_arg1)
	runtime.KeepAlive(surface)

	var _native *NativeSurface // out

	_native = wrapNativeSurface(coreglib.Take(unsafe.Pointer(_cret)))

	return _native
}

// OrientableOverrider contains methods that are overridable.
type OrientableOverrider interface {
}

// Orientable: GtkOrientable interface is implemented by all widgets that can be
// oriented horizontally or vertically.
//
// GtkOrientable is more flexible in that it allows the orientation to be
// changed at runtime, allowing the widgets to “flip”.
//
// Orientable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Orientable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Orientable)(nil)
)

// Orientabler describes Orientable's interface methods.
type Orientabler interface {
	coreglib.Objector

	// Orientation retrieves the orientation of the orientable.
	Orientation() Orientation
	// SetOrientation sets the orientation of the orientable.
	SetOrientation(orientation Orientation)
}

var _ Orientabler = (*Orientable)(nil)

func ifaceInitOrientabler(gifacePtr, data C.gpointer) {
}

func wrapOrientable(obj *coreglib.Object) *Orientable {
	return &Orientable{
		Object: obj,
	}
}

func marshalOrientable(p uintptr) (interface{}, error) {
	return wrapOrientable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Orientation retrieves the orientation of the orientable.
//
// The function returns the following values:
//
//   - orientation of the orientable.
func (orientable *Orientable) Orientation() Orientation {
	var _arg0 *C.GtkOrientable // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkOrientable)(unsafe.Pointer(coreglib.InternObject(orientable).Native()))

	_cret = C.gtk_orientable_get_orientation(_arg0)
	runtime.KeepAlive(orientable)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// SetOrientation sets the orientation of the orientable.
//
// The function takes the following parameters:
//
//   - orientation orientable’s new orientation.
func (orientable *Orientable) SetOrientation(orientation Orientation) {
	var _arg0 *C.GtkOrientable // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkOrientable)(unsafe.Pointer(coreglib.InternObject(orientable).Native()))
	_arg1 = C.GtkOrientation(orientation)

	C.gtk_orientable_set_orientation(_arg0, _arg1)
	runtime.KeepAlive(orientable)
	runtime.KeepAlive(orientation)
}

// PrintOperationPreview: GtkPrintOperationPreview is the interface that is used
// to implement print preview.
//
// A GtkPrintOperationPreview object is passed to the
// gtk.PrintOperation::preview signal by gtk.PrintOperation.
//
// PrintOperationPreview wraps an interface. This means the user can get the
// underlying type by calling Cast().
type PrintOperationPreview struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PrintOperationPreview)(nil)
)

// PrintOperationPreviewer describes PrintOperationPreview's interface methods.
type PrintOperationPreviewer interface {
	coreglib.Objector

	// EndPreview ends a preview.
	EndPreview()
	// IsSelected returns whether the given page is included in the set of pages
	// that have been selected for printing.
	IsSelected(pageNr int) bool
	// RenderPage renders a page to the preview.
	RenderPage(pageNr int)

	// Got-page-size is emitted once for each page that gets rendered to the
	// preview.
	ConnectGotPageSize(func(context *PrintContext, pageSetup *PageSetup)) coreglib.SignalHandle
	// Ready signal gets emitted once per preview operation, before the first
	// page is rendered.
	ConnectReady(func(context *PrintContext)) coreglib.SignalHandle
}

var _ PrintOperationPreviewer = (*PrintOperationPreview)(nil)

func wrapPrintOperationPreview(obj *coreglib.Object) *PrintOperationPreview {
	return &PrintOperationPreview{
		Object: obj,
	}
}

func marshalPrintOperationPreview(p uintptr) (interface{}, error) {
	return wrapPrintOperationPreview(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectGotPageSize is emitted once for each page that gets rendered to the
// preview.
//
// A handler for this signal should update the context according
// to page_setup and set up a suitable cairo context, using
// gtk.PrintContext.SetCairoContext().
func (preview *PrintOperationPreview) ConnectGotPageSize(f func(context *PrintContext, pageSetup *PageSetup)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(preview, "got-page-size", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperationPreview_ConnectGotPageSize), f)
}

// ConnectReady signal gets emitted once per preview operation, before the first
// page is rendered.
//
// A handler for this signal can be used for setup tasks.
func (preview *PrintOperationPreview) ConnectReady(f func(context *PrintContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(preview, "ready", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperationPreview_ConnectReady), f)
}

// EndPreview ends a preview.
//
// This function must be called to finish a custom print preview.
func (preview *PrintOperationPreview) EndPreview() {
	var _arg0 *C.GtkPrintOperationPreview // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))

	C.gtk_print_operation_preview_end_preview(_arg0)
	runtime.KeepAlive(preview)
}

// IsSelected returns whether the given page is included in the set of pages
// that have been selected for printing.
//
// The function takes the following parameters:
//
//   - pageNr: page number.
//
// The function returns the following values:
//
//   - ok: TRUE if the page has been selected for printing.
func (preview *PrintOperationPreview) IsSelected(pageNr int) bool {
	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.int                       // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))
	_arg1 = C.int(pageNr)

	_cret = C.gtk_print_operation_preview_is_selected(_arg0, _arg1)
	runtime.KeepAlive(preview)
	runtime.KeepAlive(pageNr)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RenderPage renders a page to the preview.
//
// This is using the print context that was passed to the
// gtk.PrintOperation::preview handler together with preview.
//
// A custom print preview should use this function to render the currently
// selected page.
//
// Note that this function requires a suitable cairo context to be associated
// with the print context.
//
// The function takes the following parameters:
//
//   - pageNr: page to render.
func (preview *PrintOperationPreview) RenderPage(pageNr int) {
	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.int                       // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))
	_arg1 = C.int(pageNr)

	C.gtk_print_operation_preview_render_page(_arg0, _arg1)
	runtime.KeepAlive(preview)
	runtime.KeepAlive(pageNr)
}

// endPreview ends a preview.
//
// This function must be called to finish a custom print preview.
func (preview *PrintOperationPreview) endPreview() {
	gclass := (*C.GtkPrintOperationPreviewIface)(coreglib.PeekParentClass(preview))
	fnarg := gclass.end_preview

	var _arg0 *C.GtkPrintOperationPreview // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))

	C._gotk4_gtk4_PrintOperationPreview_virtual_end_preview(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(preview)
}

// The function takes the following parameters:
//
//   - context
//   - pageSetup
func (preview *PrintOperationPreview) gotPageSize(context *PrintContext, pageSetup *PageSetup) {
	gclass := (*C.GtkPrintOperationPreviewIface)(coreglib.PeekParentClass(preview))
	fnarg := gclass.got_page_size

	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 *C.GtkPrintContext          // out
	var _arg2 *C.GtkPageSetup             // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))
	_arg1 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(pageSetup).Native()))

	C._gotk4_gtk4_PrintOperationPreview_virtual_got_page_size(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(preview)
	runtime.KeepAlive(context)
	runtime.KeepAlive(pageSetup)
}

// isSelected returns whether the given page is included in the set of pages
// that have been selected for printing.
//
// The function takes the following parameters:
//
//   - pageNr: page number.
//
// The function returns the following values:
//
//   - ok: TRUE if the page has been selected for printing.
func (preview *PrintOperationPreview) isSelected(pageNr int) bool {
	gclass := (*C.GtkPrintOperationPreviewIface)(coreglib.PeekParentClass(preview))
	fnarg := gclass.is_selected

	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.int                       // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))
	_arg1 = C.int(pageNr)

	_cret = C._gotk4_gtk4_PrintOperationPreview_virtual_is_selected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(preview)
	runtime.KeepAlive(pageNr)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (preview *PrintOperationPreview) ready(context *PrintContext) {
	gclass := (*C.GtkPrintOperationPreviewIface)(coreglib.PeekParentClass(preview))
	fnarg := gclass.ready

	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 *C.GtkPrintContext          // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))
	_arg1 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_PrintOperationPreview_virtual_ready(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(preview)
	runtime.KeepAlive(context)
}

// renderPage renders a page to the preview.
//
// This is using the print context that was passed to the
// gtk.PrintOperation::preview handler together with preview.
//
// A custom print preview should use this function to render the currently
// selected page.
//
// Note that this function requires a suitable cairo context to be associated
// with the print context.
//
// The function takes the following parameters:
//
//   - pageNr: page to render.
func (preview *PrintOperationPreview) renderPage(pageNr int) {
	gclass := (*C.GtkPrintOperationPreviewIface)(coreglib.PeekParentClass(preview))
	fnarg := gclass.render_page

	var _arg0 *C.GtkPrintOperationPreview // out
	var _arg1 C.int                       // out

	_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))
	_arg1 = C.int(pageNr)

	C._gotk4_gtk4_PrintOperationPreview_virtual_render_page(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(preview)
	runtime.KeepAlive(pageNr)
}

// Root: GtkRoot is the interface implemented by all widgets that can act as a
// toplevel widget.
//
// The root widget takes care of providing the connection to the windowing
// system and manages layout, drawing and event delivery for its widget
// hierarchy.
//
// The obvious example of a GtkRoot is GtkWindow.
//
// To get the display to which a GtkRoot belongs, use gtk.Root.GetDisplay().
//
// GtkRoot also maintains the location of keyboard focus inside its widget
// hierarchy, with gtk.Root.SetFocus() and gtk.Root.GetFocus().
//
// Root wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Root struct {
	_ [0]func() // equal guard
	NativeSurface
}

var ()

// Rooter describes Root's interface methods.
type Rooter interface {
	coreglib.Objector

	// Display returns the display that this GtkRoot is on.
	Display() *gdk.Display
	// Focus retrieves the current focused widget within the root.
	Focus() Widgetter
	// SetFocus: if focus is not the current focus widget, and is focusable,
	// sets it as the focus widget for the root.
	SetFocus(focus Widgetter)
}

var _ Rooter = (*Root)(nil)

func wrapRoot(obj *coreglib.Object) *Root {
	return &Root{
		NativeSurface: NativeSurface{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalRoot(p uintptr) (interface{}, error) {
	return wrapRoot(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Display returns the display that this GtkRoot is on.
//
// The function returns the following values:
//
//   - display of root.
func (self *Root) Display() *gdk.Display {
	var _arg0 *C.GtkRoot    // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GtkRoot)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_root_get_display(_arg0)
	runtime.KeepAlive(self)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// Focus retrieves the current focused widget within the root.
//
// Note that this is the widget that would have the focus if the root is active;
// if the root is not focused then gtk_widget_has_focus (widget) will be FALSE
// for the widget.
//
// The function returns the following values:
//
//   - widget (optional): currently focused widget, or NULL if there is none.
func (self *Root) Focus() Widgetter {
	var _arg0 *C.GtkRoot   // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkRoot)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_root_get_focus(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SetFocus: if focus is not the current focus widget, and is focusable, sets it
// as the focus widget for the root.
//
// If focus is NULL, unsets the focus widget for the root.
//
// To set the focus to a particular widget in the root, it is usually more
// convenient to use gtk.Widget.GrabFocus() instead of this function.
//
// The function takes the following parameters:
//
//   - focus (optional): widget to be the new focus widget, or NULL to unset the
//     focus widget.
func (self *Root) SetFocus(focus Widgetter) {
	var _arg0 *C.GtkRoot   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkRoot)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if focus != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(focus).Native()))
	}

	C.gtk_root_set_focus(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(focus)
}

// Scrollable: GtkScrollable is an interface for widgets with native scrolling
// ability.
//
// To implement this interface you should override the
// gtk.Scrollable:hadjustment and gtk.Scrollable:vadjustment properties.
//
// # Creating a scrollable widget
//
// All scrollable widgets should do the following.
//
// - When a parent widget sets the scrollable child widget’s adjustments,
// the widget should populate the adjustments’ gtk.Adjustment:lower,
// gtk.Adjustment:upper, gtk.Adjustment:step-increment,
// gtk.Adjustment:page-increment and gtk.Adjustment:page-size properties and
// connect to the gtk.Adjustment::value-changed signal.
//
// - Because its preferred size is the size for a fully expanded widget,
// the scrollable widget must be able to cope with underallocations. This means
// that it must accept any value passed to its GtkWidgetClass.size_allocate()
// function.
//
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments’ properties with new values.
//
// - When any of the adjustments emits the gtk.Adjustment::value-changed signal,
// the scrollable widget should scroll its contents.
//
// Scrollable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Scrollable struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Scrollable)(nil)
)

// Scrollabler describes Scrollable's interface methods.
type Scrollabler interface {
	coreglib.Objector

	// Border returns the size of a non-scrolling border around the outside of
	// the scrollable.
	Border() (*Border, bool)
	// HAdjustment retrieves the GtkAdjustment used for horizontal scrolling.
	HAdjustment() *Adjustment
	// HScrollPolicy gets the horizontal GtkScrollablePolicy.
	HScrollPolicy() ScrollablePolicy
	// VAdjustment retrieves the GtkAdjustment used for vertical scrolling.
	VAdjustment() *Adjustment
	// VScrollPolicy gets the vertical GtkScrollablePolicy.
	VScrollPolicy() ScrollablePolicy
	// SetHAdjustment sets the horizontal adjustment of the GtkScrollable.
	SetHAdjustment(hadjustment *Adjustment)
	// SetHScrollPolicy sets the GtkScrollablePolicy.
	SetHScrollPolicy(policy ScrollablePolicy)
	// SetVAdjustment sets the vertical adjustment of the GtkScrollable.
	SetVAdjustment(vadjustment *Adjustment)
	// SetVScrollPolicy sets the GtkScrollablePolicy.
	SetVScrollPolicy(policy ScrollablePolicy)
}

var _ Scrollabler = (*Scrollable)(nil)

func wrapScrollable(obj *coreglib.Object) *Scrollable {
	return &Scrollable{
		Object: obj,
	}
}

func marshalScrollable(p uintptr) (interface{}, error) {
	return wrapScrollable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Border returns the size of a non-scrolling border around the outside of the
// scrollable.
//
// An example for this would be treeview headers. GTK can use this information
// to display overlaid graphics, like the overshoot indication, at the right
// position.
//
// The function returns the following values:
//
//   - border: return location for the results.
//   - ok: TRUE if border has been set.
func (scrollable *Scrollable) Border() (*Border, bool) {
	var _arg0 *C.GtkScrollable // out
	var _arg1 C.GtkBorder      // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))

	_cret = C.gtk_scrollable_get_border(_arg0, &_arg1)
	runtime.KeepAlive(scrollable)

	var _border *Border // out
	var _ok bool        // out

	_border = (*Border)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _border, _ok
}

// HAdjustment retrieves the GtkAdjustment used for horizontal scrolling.
//
// The function returns the following values:
//
//   - adjustment: horizontal GtkAdjustment.
func (scrollable *Scrollable) HAdjustment() *Adjustment {
	var _arg0 *C.GtkScrollable // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))

	_cret = C.gtk_scrollable_get_hadjustment(_arg0)
	runtime.KeepAlive(scrollable)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// HScrollPolicy gets the horizontal GtkScrollablePolicy.
//
// The function returns the following values:
//
//   - scrollablePolicy: horizontal GtkScrollablePolicy.
func (scrollable *Scrollable) HScrollPolicy() ScrollablePolicy {
	var _arg0 *C.GtkScrollable      // out
	var _cret C.GtkScrollablePolicy // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))

	_cret = C.gtk_scrollable_get_hscroll_policy(_arg0)
	runtime.KeepAlive(scrollable)

	var _scrollablePolicy ScrollablePolicy // out

	_scrollablePolicy = ScrollablePolicy(_cret)

	return _scrollablePolicy
}

// VAdjustment retrieves the GtkAdjustment used for vertical scrolling.
//
// The function returns the following values:
//
//   - adjustment: vertical GtkAdjustment.
func (scrollable *Scrollable) VAdjustment() *Adjustment {
	var _arg0 *C.GtkScrollable // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))

	_cret = C.gtk_scrollable_get_vadjustment(_arg0)
	runtime.KeepAlive(scrollable)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// VScrollPolicy gets the vertical GtkScrollablePolicy.
//
// The function returns the following values:
//
//   - scrollablePolicy: vertical GtkScrollablePolicy.
func (scrollable *Scrollable) VScrollPolicy() ScrollablePolicy {
	var _arg0 *C.GtkScrollable      // out
	var _cret C.GtkScrollablePolicy // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))

	_cret = C.gtk_scrollable_get_vscroll_policy(_arg0)
	runtime.KeepAlive(scrollable)

	var _scrollablePolicy ScrollablePolicy // out

	_scrollablePolicy = ScrollablePolicy(_cret)

	return _scrollablePolicy
}

// SetHAdjustment sets the horizontal adjustment of the GtkScrollable.
//
// The function takes the following parameters:
//
//   - hadjustment (optional): GtkAdjustment.
func (scrollable *Scrollable) SetHAdjustment(hadjustment *Adjustment) {
	var _arg0 *C.GtkScrollable // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))
	if hadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(hadjustment).Native()))
	}

	C.gtk_scrollable_set_hadjustment(_arg0, _arg1)
	runtime.KeepAlive(scrollable)
	runtime.KeepAlive(hadjustment)
}

// SetHScrollPolicy sets the GtkScrollablePolicy.
//
// The policy determines whether horizontal scrolling should start below the
// minimum width or below the natural width.
//
// The function takes the following parameters:
//
//   - policy: horizontal GtkScrollablePolicy.
func (scrollable *Scrollable) SetHScrollPolicy(policy ScrollablePolicy) {
	var _arg0 *C.GtkScrollable      // out
	var _arg1 C.GtkScrollablePolicy // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))
	_arg1 = C.GtkScrollablePolicy(policy)

	C.gtk_scrollable_set_hscroll_policy(_arg0, _arg1)
	runtime.KeepAlive(scrollable)
	runtime.KeepAlive(policy)
}

// SetVAdjustment sets the vertical adjustment of the GtkScrollable.
//
// The function takes the following parameters:
//
//   - vadjustment (optional): GtkAdjustment.
func (scrollable *Scrollable) SetVAdjustment(vadjustment *Adjustment) {
	var _arg0 *C.GtkScrollable // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))
	if vadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(vadjustment).Native()))
	}

	C.gtk_scrollable_set_vadjustment(_arg0, _arg1)
	runtime.KeepAlive(scrollable)
	runtime.KeepAlive(vadjustment)
}

// SetVScrollPolicy sets the GtkScrollablePolicy.
//
// The policy determines whether vertical scrolling should start below the
// minimum height or below the natural height.
//
// The function takes the following parameters:
//
//   - policy: vertical GtkScrollablePolicy.
func (scrollable *Scrollable) SetVScrollPolicy(policy ScrollablePolicy) {
	var _arg0 *C.GtkScrollable      // out
	var _arg1 C.GtkScrollablePolicy // out

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))
	_arg1 = C.GtkScrollablePolicy(policy)

	C.gtk_scrollable_set_vscroll_policy(_arg0, _arg1)
	runtime.KeepAlive(scrollable)
	runtime.KeepAlive(policy)
}

// Border returns the size of a non-scrolling border around the outside of the
// scrollable.
//
// An example for this would be treeview headers. GTK can use this information
// to display overlaid graphics, like the overshoot indication, at the right
// position.
//
// The function returns the following values:
//
//   - border: return location for the results.
//   - ok: TRUE if border has been set.
func (scrollable *Scrollable) border() (*Border, bool) {
	gclass := (*C.GtkScrollableInterface)(coreglib.PeekParentClass(scrollable))
	fnarg := gclass.get_border

	var _arg0 *C.GtkScrollable // out
	var _arg1 C.GtkBorder      // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkScrollable)(unsafe.Pointer(coreglib.InternObject(scrollable).Native()))

	_cret = C._gotk4_gtk4_Scrollable_virtual_get_border(unsafe.Pointer(fnarg), _arg0, &_arg1)
	runtime.KeepAlive(scrollable)

	var _border *Border // out
	var _ok bool        // out

	_border = (*Border)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _border, _ok
}

// SelectionModel: GtkSelectionModel is an interface that add support for
// selection to list models.
//
// This support is then used by widgets using list models to add the ability to
// select and unselect various items.
//
// GTK provides default implementations of the most common selection modes such
// as gtk.SingleSelection, so you will only need to implement this interface if
// you want detailed control about how selections should be handled.
//
// A GtkSelectionModel supports a single boolean per item indicating if an item
// is selected or not. This can be queried via gtk.SelectionModel.IsSelected().
// When the selected state of one or more items changes, the model will
// emit the gtk.SelectionModel::selection-changed signal by calling the
// gtk.SelectionModel.SelectionChanged() function. The positions given in
// that signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the ::items-changed signal
// are selected or not is up to the implementation.
//
// Note that items added via ::items-changed may already be selected and no
// [Gtk.SelectionModel::selection-changed] will be emitted for them. So to track
// which items are selected, it is necessary to listen to both signals.
//
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow
// users to select and unselect items. However, GtkSelectionModels are free to
// only implement them partially or not at all. In that case the widgets will
// not support the unimplemented operations.
//
// When selecting or unselecting is supported by a model, the return values
// of the selection functions do *not* indicate if selection or unselection
// happened. They are only meant to indicate complete failure, like when this
// mode of selecting is not supported by the model.
//
// Selections may happen asynchronously, so the only reliable way to find
// out when an item was selected is to listen to the signals that indicate
// selection.
//
// SelectionModel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type SelectionModel struct {
	_ [0]func() // equal guard
	gio.ListModel
}

var ()

// SelectionModeller describes SelectionModel's interface methods.
type SelectionModeller interface {
	coreglib.Objector

	// Selection gets the set containing all currently selected items in the
	// model.
	Selection() *Bitset
	// SelectionInRange gets the set of selected items in a range.
	SelectionInRange(position, nItems uint) *Bitset
	// IsSelected checks if the given item is selected.
	IsSelected(position uint) bool
	// SelectAll requests to select all items in the model.
	SelectAll() bool
	// SelectItem requests to select an item in the model.
	SelectItem(position uint, unselectRest bool) bool
	// SelectRange requests to select a range of items in the model.
	SelectRange(position, nItems uint, unselectRest bool) bool
	// SelectionChanged: helper function for implementations of
	// GtkSelectionModel.
	SelectionChanged(position, nItems uint)
	// SetSelection: make selection changes.
	SetSelection(selected, mask *Bitset) bool
	// UnselectAll requests to unselect all items in the model.
	UnselectAll() bool
	// UnselectItem requests to unselect an item in the model.
	UnselectItem(position uint) bool
	// UnselectRange requests to unselect a range of items in the model.
	UnselectRange(position, nItems uint) bool

	// Selection-changed is emitted when the selection state of some of the
	// items in model changes.
	ConnectSelectionChanged(func(position, nItems uint)) coreglib.SignalHandle
}

var _ SelectionModeller = (*SelectionModel)(nil)

func wrapSelectionModel(obj *coreglib.Object) *SelectionModel {
	return &SelectionModel{
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalSelectionModel(p uintptr) (interface{}, error) {
	return wrapSelectionModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectSelectionChanged is emitted when the selection state of some of the
// items in model changes.
//
// Note that this signal does not specify the new selection state of the items,
// they need to be queried manually. It is also not necessary for a model to
// change the selection state of any of the items in the selection model,
// though it would be rather useless to emit such a signal.
func (model *SelectionModel) ConnectSelectionChanged(f func(position, nItems uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(model, "selection-changed", false, unsafe.Pointer(C._gotk4_gtk4_SelectionModel_ConnectSelectionChanged), f)
}

// Selection gets the set containing all currently selected items in the model.
//
// This function may be slow, so if you are only interested in single item,
// consider using gtk.SelectionModel.IsSelected() or if you are only interested
// in a few, consider gtk.SelectionModel.GetSelectionInRange().
//
// The function returns the following values:
//
//   - bitset: GtkBitset containing all the values currently selected in model.
//     If no items are selected, the bitset is empty. The bitset must not be
//     modified.
func (model *SelectionModel) Selection() *Bitset {
	var _arg0 *C.GtkSelectionModel // out
	var _cret *C.GtkBitset         // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_selection_model_get_selection(_arg0)
	runtime.KeepAlive(model)

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_bitset_unref((*C.GtkBitset)(intern.C))
		},
	)

	return _bitset
}

// SelectionInRange gets the set of selected items in a range.
//
// This function is an optimization for gtk.SelectionModel.GetSelection() when
// you are only interested in part of the model's selected state. A common use
// case is in response to the gtk.SelectionModel::selection-changed signal.
//
// The function takes the following parameters:
//
//   - position: start of the queired range.
//   - nItems: number of items in the queried range.
//
// The function returns the following values:
//
//   - bitset: GtkBitset that matches the selection state for the given range
//     with all other values being undefined. The bitset must not be modified.
func (model *SelectionModel) SelectionInRange(position, nItems uint) *Bitset {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _cret *C.GtkBitset         // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nItems)

	_cret = C.gtk_selection_model_get_selection_in_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_bitset_unref((*C.GtkBitset)(intern.C))
		},
	)

	return _bitset
}

// IsSelected checks if the given item is selected.
//
// The function takes the following parameters:
//
//   - position of the item to query.
//
// The function returns the following values:
//
//   - ok: TRUE if the item is selected.
func (model *SelectionModel) IsSelected(position uint) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)

	_cret = C.gtk_selection_model_is_selected(_arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectAll requests to select all items in the model.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean that all items are now selected.
func (model *SelectionModel) SelectAll() bool {
	var _arg0 *C.GtkSelectionModel // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_selection_model_select_all(_arg0)
	runtime.KeepAlive(model)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectItem requests to select an item in the model.
//
// The function takes the following parameters:
//
//   - position of the item to select.
//   - unselectRest: whether previously selected items should be unselected.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the item was selected.
func (model *SelectionModel) SelectItem(position uint, unselectRest bool) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	if unselectRest {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_selection_model_select_item(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(unselectRest)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectRange requests to select a range of items in the model.
//
// The function takes the following parameters:
//
//   - position: first item to select.
//   - nItems: number of items to select.
//   - unselectRest: whether previously selected items should be unselected.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the range was selected.
func (model *SelectionModel) SelectRange(position, nItems uint, unselectRest bool) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _arg3 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nItems)
	if unselectRest {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_selection_model_select_range(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)
	runtime.KeepAlive(unselectRest)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionChanged: helper function for implementations of GtkSelectionModel.
//
// Call this when a the selection changes to emit the
// gtk.SelectionModel::selection-changed signal.
//
// The function takes the following parameters:
//
//   - position: first changed item.
//   - nItems: number of changed items.
func (model *SelectionModel) SelectionChanged(position, nItems uint) {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nItems)

	C.gtk_selection_model_selection_changed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)
}

// SetSelection: make selection changes.
//
// This is the most advanced selection updating method that allows the most
// fine-grained control over selection changes. If you can, you should try the
// simpler versions, as implementations are more likely to implement support for
// those.
//
// Requests that the selection state of all positions set in mask be updated to
// the respective value in the selected bitmask.
//
// In pseudocode, it would look something like this:
//
//	for (i = 0; i < n_items; i++)
//	  {
//	    // don't change values not in the mask
//	    if (!gtk_bitset_contains (mask, i))
//	      continue;
//
//	    if (gtk_bitset_contains (selected, i))
//	      select_item (i);
//	    else
//	      unselect_item (i);
//	  }
//
//	gtk_selection_model_selection_changed (model,
//	                                       first_changed_item,
//	                                       n_changed_items);
//
// mask and selected must not be modified. They may refer to the same bitset,
// which would mean that every item in the set should be selected.
//
// The function takes the following parameters:
//
//   - selected: bitmask specifying if items should be selected or unselected.
//   - mask specifying which items should be updated.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean that all items were updated according to the inputs.
func (model *SelectionModel) SetSelection(selected, mask *Bitset) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 *C.GtkBitset         // out
	var _arg2 *C.GtkBitset         // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(selected)))
	_arg2 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(mask)))

	_cret = C.gtk_selection_model_set_selection(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(selected)
	runtime.KeepAlive(mask)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnselectAll requests to unselect all items in the model.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean that all items are now unselected.
func (model *SelectionModel) UnselectAll() bool {
	var _arg0 *C.GtkSelectionModel // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_selection_model_unselect_all(_arg0)
	runtime.KeepAlive(model)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnselectItem requests to unselect an item in the model.
//
// The function takes the following parameters:
//
//   - position of the item to unselect.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the item was unselected.
func (model *SelectionModel) UnselectItem(position uint) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)

	_cret = C.gtk_selection_model_unselect_item(_arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UnselectRange requests to unselect a range of items in the model.
//
// The function takes the following parameters:
//
//   - position: first item to unselect.
//   - nItems: number of items to unselect.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the range was unselected.
func (model *SelectionModel) UnselectRange(position, nItems uint) bool {
	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nItems)

	_cret = C.gtk_selection_model_unselect_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// selectionInRange gets the set of selected items in a range.
//
// This function is an optimization for gtk.SelectionModel.GetSelection() when
// you are only interested in part of the model's selected state. A common use
// case is in response to the gtk.SelectionModel::selection-changed signal.
//
// The function takes the following parameters:
//
//   - position: start of the queired range.
//   - nItems: number of items in the queried range.
//
// The function returns the following values:
//
//   - bitset: GtkBitset that matches the selection state for the given range
//     with all other values being undefined. The bitset must not be modified.
func (model *SelectionModel) selectionInRange(position, nItems uint) *Bitset {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.get_selection_in_range

	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _cret *C.GtkBitset         // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nItems)

	_cret = C._gotk4_gtk4_SelectionModel_virtual_get_selection_in_range(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_bitset_unref((*C.GtkBitset)(intern.C))
		},
	)

	return _bitset
}

// isSelected checks if the given item is selected.
//
// The function takes the following parameters:
//
//   - position of the item to query.
//
// The function returns the following values:
//
//   - ok: TRUE if the item is selected.
func (model *SelectionModel) isSelected(position uint) bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.is_selected

	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)

	_cret = C._gotk4_gtk4_SelectionModel_virtual_is_selected(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// selectAll requests to select all items in the model.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean that all items are now selected.
func (model *SelectionModel) selectAll() bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.select_all

	var _arg0 *C.GtkSelectionModel // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C._gotk4_gtk4_SelectionModel_virtual_select_all(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(model)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// selectItem requests to select an item in the model.
//
// The function takes the following parameters:
//
//   - position of the item to select.
//   - unselectRest: whether previously selected items should be unselected.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the item was selected.
func (model *SelectionModel) selectItem(position uint, unselectRest bool) bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.select_item

	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	if unselectRest {
		_arg2 = C.TRUE
	}

	_cret = C._gotk4_gtk4_SelectionModel_virtual_select_item(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(unselectRest)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// selectRange requests to select a range of items in the model.
//
// The function takes the following parameters:
//
//   - position: first item to select.
//   - nItems: number of items to select.
//   - unselectRest: whether previously selected items should be unselected.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the range was selected.
func (model *SelectionModel) selectRange(position, nItems uint, unselectRest bool) bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.select_range

	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _arg3 C.gboolean           // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nItems)
	if unselectRest {
		_arg3 = C.TRUE
	}

	_cret = C._gotk4_gtk4_SelectionModel_virtual_select_range(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)
	runtime.KeepAlive(unselectRest)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setSelection: make selection changes.
//
// This is the most advanced selection updating method that allows the most
// fine-grained control over selection changes. If you can, you should try the
// simpler versions, as implementations are more likely to implement support for
// those.
//
// Requests that the selection state of all positions set in mask be updated to
// the respective value in the selected bitmask.
//
// In pseudocode, it would look something like this:
//
//	for (i = 0; i < n_items; i++)
//	  {
//	    // don't change values not in the mask
//	    if (!gtk_bitset_contains (mask, i))
//	      continue;
//
//	    if (gtk_bitset_contains (selected, i))
//	      select_item (i);
//	    else
//	      unselect_item (i);
//	  }
//
//	gtk_selection_model_selection_changed (model,
//	                                       first_changed_item,
//	                                       n_changed_items);
//
// mask and selected must not be modified. They may refer to the same bitset,
// which would mean that every item in the set should be selected.
//
// The function takes the following parameters:
//
//   - selected: bitmask specifying if items should be selected or unselected.
//   - mask specifying which items should be updated.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean that all items were updated according to the inputs.
func (model *SelectionModel) setSelection(selected, mask *Bitset) bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.set_selection

	var _arg0 *C.GtkSelectionModel // out
	var _arg1 *C.GtkBitset         // out
	var _arg2 *C.GtkBitset         // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(selected)))
	_arg2 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(mask)))

	_cret = C._gotk4_gtk4_SelectionModel_virtual_set_selection(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(selected)
	runtime.KeepAlive(mask)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// unselectAll requests to unselect all items in the model.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean that all items are now unselected.
func (model *SelectionModel) unselectAll() bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.unselect_all

	var _arg0 *C.GtkSelectionModel // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C._gotk4_gtk4_SelectionModel_virtual_unselect_all(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(model)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// unselectItem requests to unselect an item in the model.
//
// The function takes the following parameters:
//
//   - position of the item to unselect.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the item was unselected.
func (model *SelectionModel) unselectItem(position uint) bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.unselect_item

	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)

	_cret = C._gotk4_gtk4_SelectionModel_virtual_unselect_item(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// unselectRange requests to unselect a range of items in the model.
//
// The function takes the following parameters:
//
//   - position: first item to unselect.
//   - nItems: number of items to unselect.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was supported and no fallback should be tried.
//     This does not mean the range was unselected.
func (model *SelectionModel) unselectRange(position, nItems uint) bool {
	gclass := (*C.GtkSelectionModelInterface)(coreglib.PeekParentClass(model))
	fnarg := gclass.unselect_range

	var _arg0 *C.GtkSelectionModel // out
	var _arg1 C.guint              // out
	var _arg2 C.guint              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nItems)

	_cret = C._gotk4_gtk4_SelectionModel_virtual_unselect_range(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nItems)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShortcutManager: GtkShortcutManager interface is used to implement shortcut
// scopes.
//
// This is important for gtk.Native widgets that have their own surface, since
// the event controllers that are used to implement managed and global scopes
// are limited to the same native.
//
// Examples for widgets implementing GtkShortcutManager are gtk.Window and
// gtk.Popover.
//
// Every widget that implements GtkShortcutManager will be used as a
// GTK_SHORTCUT_SCOPE_MANAGED.
//
// ShortcutManager wraps an interface. This means the user can get the
// underlying type by calling Cast().
type ShortcutManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ShortcutManager)(nil)
)

// ShortcutManagerer describes ShortcutManager's interface methods.
type ShortcutManagerer interface {
	coreglib.Objector

	baseShortcutManager() *ShortcutManager
}

var _ ShortcutManagerer = (*ShortcutManager)(nil)

func wrapShortcutManager(obj *coreglib.Object) *ShortcutManager {
	return &ShortcutManager{
		Object: obj,
	}
}

func marshalShortcutManager(p uintptr) (interface{}, error) {
	return wrapShortcutManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *ShortcutManager) baseShortcutManager() *ShortcutManager {
	return v
}

// BaseShortcutManager returns the underlying base object.
func BaseShortcutManager(obj ShortcutManagerer) *ShortcutManager {
	return obj.baseShortcutManager()
}

func (self *ShortcutManager) addController(controller *ShortcutController) {
	gclass := (*C.GtkShortcutManagerInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.add_controller

	var _arg0 *C.GtkShortcutManager    // out
	var _arg1 *C.GtkShortcutController // out

	_arg0 = (*C.GtkShortcutManager)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	C._gotk4_gtk4_ShortcutManager_virtual_add_controller(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(controller)
}

func (self *ShortcutManager) removeController(controller *ShortcutController) {
	gclass := (*C.GtkShortcutManagerInterface)(coreglib.PeekParentClass(self))
	fnarg := gclass.remove_controller

	var _arg0 *C.GtkShortcutManager    // out
	var _arg1 *C.GtkShortcutController // out

	_arg0 = (*C.GtkShortcutManager)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	C._gotk4_gtk4_ShortcutManager_virtual_remove_controller(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(controller)
}

// StyleProvider: GtkStyleProvider is an interface for style information used by
// GtkStyleContext.
//
// See gtk.StyleContext.AddProvider() and
// gtk.StyleContext().AddProviderForDisplay for adding GtkStyleProviders.
//
// GTK uses the GtkStyleProvider implementation for CSS in gtk.CSSProvider.
//
// StyleProvider wraps an interface. This means the user can get the
// underlying type by calling Cast().
type StyleProvider struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StyleProvider)(nil)
)

// StyleProviderer describes StyleProvider's interface methods.
type StyleProviderer interface {
	coreglib.Objector

	baseStyleProvider() *StyleProvider
}

var _ StyleProviderer = (*StyleProvider)(nil)

func wrapStyleProvider(obj *coreglib.Object) *StyleProvider {
	return &StyleProvider{
		Object: obj,
	}
}

func marshalStyleProvider(p uintptr) (interface{}, error) {
	return wrapStyleProvider(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *StyleProvider) baseStyleProvider() *StyleProvider {
	return v
}

// BaseStyleProvider returns the underlying base object.
func BaseStyleProvider(obj StyleProviderer) *StyleProvider {
	return obj.baseStyleProvider()
}

func (v *StyleProvider) ConnectGTKPrivateChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "gtk-private-changed", false, unsafe.Pointer(C._gotk4_gtk4_StyleProvider_ConnectGTKPrivateChanged), f)
}

// TreeDragDest: interface for Drag-and-Drop destinations in GtkTreeView.
//
// TreeDragDest wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TreeDragDest struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TreeDragDest)(nil)
)

// TreeDragDester describes TreeDragDest's interface methods.
type TreeDragDester interface {
	coreglib.Objector

	// DragDataReceived asks the TreeDragDest to insert a row before the path
	// dest, deriving the contents of the row from value.
	DragDataReceived(dest *TreePath, value *coreglib.Value) bool
	// RowDropPossible determines whether a drop is possible before the given
	// dest_path, at the same depth as dest_path.
	RowDropPossible(destPath *TreePath, value *coreglib.Value) bool
}

var _ TreeDragDester = (*TreeDragDest)(nil)

func wrapTreeDragDest(obj *coreglib.Object) *TreeDragDest {
	return &TreeDragDest{
		Object: obj,
	}
}

func marshalTreeDragDest(p uintptr) (interface{}, error) {
	return wrapTreeDragDest(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DragDataReceived asks the TreeDragDest to insert a row before the path dest,
// deriving the contents of the row from value. If dest is outside the tree so
// that inserting before it is impossible, FALSE will be returned. Also, FALSE
// may be returned if the new row is not created for some model-specific reason.
// Should robustly handle a dest no longer found in the model!.
//
// The function takes the following parameters:
//
//   - dest: row to drop in front of.
//   - value: data to drop.
//
// The function returns the following values:
//
//   - ok: whether a new row was created before position dest.
func (dragDest *TreeDragDest) DragDataReceived(dest *TreePath, value *coreglib.Value) bool {
	var _arg0 *C.GtkTreeDragDest // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GValue          // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(coreglib.InternObject(dragDest).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_tree_drag_dest_drag_data_received(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dragDest)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowDropPossible determines whether a drop is possible before the given
// dest_path, at the same depth as dest_path. i.e., can we drop the data in
// value at that location. dest_path does not have to exist; the return value
// will almost certainly be FALSE if the parent of dest_path doesn’t exist,
// though.
//
// The function takes the following parameters:
//
//   - destPath: destination row.
//   - value: data being dropped.
//
// The function returns the following values:
//
//   - ok: TRUE if a drop is possible before dest_path.
func (dragDest *TreeDragDest) RowDropPossible(destPath *TreePath, value *coreglib.Value) bool {
	var _arg0 *C.GtkTreeDragDest // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GValue          // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(coreglib.InternObject(dragDest).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(destPath)))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_tree_drag_dest_row_drop_possible(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dragDest)
	runtime.KeepAlive(destPath)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// dragDataReceived asks the TreeDragDest to insert a row before the path dest,
// deriving the contents of the row from value. If dest is outside the tree so
// that inserting before it is impossible, FALSE will be returned. Also, FALSE
// may be returned if the new row is not created for some model-specific reason.
// Should robustly handle a dest no longer found in the model!.
//
// The function takes the following parameters:
//
//   - dest: row to drop in front of.
//   - value: data to drop.
//
// The function returns the following values:
//
//   - ok: whether a new row was created before position dest.
func (dragDest *TreeDragDest) dragDataReceived(dest *TreePath, value *coreglib.Value) bool {
	gclass := (*C.GtkTreeDragDestIface)(coreglib.PeekParentClass(dragDest))
	fnarg := gclass.drag_data_received

	var _arg0 *C.GtkTreeDragDest // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GValue          // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(coreglib.InternObject(dragDest).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(dest)))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C._gotk4_gtk4_TreeDragDest_virtual_drag_data_received(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(dragDest)
	runtime.KeepAlive(dest)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// rowDropPossible determines whether a drop is possible before the given
// dest_path, at the same depth as dest_path. i.e., can we drop the data in
// value at that location. dest_path does not have to exist; the return value
// will almost certainly be FALSE if the parent of dest_path doesn’t exist,
// though.
//
// The function takes the following parameters:
//
//   - destPath: destination row.
//   - value: data being dropped.
//
// The function returns the following values:
//
//   - ok: TRUE if a drop is possible before dest_path.
func (dragDest *TreeDragDest) rowDropPossible(destPath *TreePath, value *coreglib.Value) bool {
	gclass := (*C.GtkTreeDragDestIface)(coreglib.PeekParentClass(dragDest))
	fnarg := gclass.row_drop_possible

	var _arg0 *C.GtkTreeDragDest // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GValue          // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(coreglib.InternObject(dragDest).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(destPath)))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C._gotk4_gtk4_TreeDragDest_virtual_row_drop_possible(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(dragDest)
	runtime.KeepAlive(destPath)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeDragSource: interface for Drag-and-Drop destinations in GtkTreeView.
//
// TreeDragSource wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TreeDragSource struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TreeDragSource)(nil)
)

// TreeDragSourcer describes TreeDragSource's interface methods.
type TreeDragSourcer interface {
	coreglib.Objector

	// DragDataDelete asks the TreeDragSource to delete the row at path, because
	// it was moved somewhere else via drag-and-drop.
	DragDataDelete(path *TreePath) bool
	// DragDataGet asks the TreeDragSource to return a ContentProvider
	// representing the row at path.
	DragDataGet(path *TreePath) *gdk.ContentProvider
	// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation.
	RowDraggable(path *TreePath) bool
}

var _ TreeDragSourcer = (*TreeDragSource)(nil)

func wrapTreeDragSource(obj *coreglib.Object) *TreeDragSource {
	return &TreeDragSource{
		Object: obj,
	}
}

func marshalTreeDragSource(p uintptr) (interface{}, error) {
	return wrapTreeDragSource(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// DragDataDelete asks the TreeDragSource to delete the row at path, because it
// was moved somewhere else via drag-and-drop. Returns FALSE if the deletion
// fails because path no longer exists, or for some model-specific reason.
// Should robustly handle a path no longer found in the model!.
//
// The function takes the following parameters:
//
//   - path: row that was being dragged.
//
// The function returns the following values:
//
//   - ok: TRUE if the row was successfully deleted.
func (dragSource *TreeDragSource) DragDataDelete(path *TreePath) bool {
	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(coreglib.InternObject(dragSource).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_drag_source_drag_data_delete(_arg0, _arg1)
	runtime.KeepAlive(dragSource)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DragDataGet asks the TreeDragSource to return a ContentProvider representing
// the row at path. Should robustly handle a path no longer found in the model!.
//
// The function takes the following parameters:
//
//   - path: row that was dragged.
//
// The function returns the following values:
//
//   - contentProvider (optional) for the given path or NULL if none exists.
func (dragSource *TreeDragSource) DragDataGet(path *TreePath) *gdk.ContentProvider {
	var _arg0 *C.GtkTreeDragSource  // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(coreglib.InternObject(dragSource).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_drag_source_drag_data_get(_arg0, _arg1)
	runtime.KeepAlive(dragSource)
	runtime.KeepAlive(path)

	var _contentProvider *gdk.ContentProvider // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_contentProvider = &gdk.ContentProvider{
				Object: obj,
			}
		}
	}

	return _contentProvider
}

// RowDraggable asks the TreeDragSource whether a particular row can be used
// as the source of a DND operation. If the source doesn’t implement this
// interface, the row is assumed draggable.
//
// The function takes the following parameters:
//
//   - path: row on which user is initiating a drag.
//
// The function returns the following values:
//
//   - ok: TRUE if the row can be dragged.
func (dragSource *TreeDragSource) RowDraggable(path *TreePath) bool {
	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(coreglib.InternObject(dragSource).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_drag_source_row_draggable(_arg0, _arg1)
	runtime.KeepAlive(dragSource)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// dragDataDelete asks the TreeDragSource to delete the row at path, because it
// was moved somewhere else via drag-and-drop. Returns FALSE if the deletion
// fails because path no longer exists, or for some model-specific reason.
// Should robustly handle a path no longer found in the model!.
//
// The function takes the following parameters:
//
//   - path: row that was being dragged.
//
// The function returns the following values:
//
//   - ok: TRUE if the row was successfully deleted.
func (dragSource *TreeDragSource) dragDataDelete(path *TreePath) bool {
	gclass := (*C.GtkTreeDragSourceIface)(coreglib.PeekParentClass(dragSource))
	fnarg := gclass.drag_data_delete

	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(coreglib.InternObject(dragSource).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C._gotk4_gtk4_TreeDragSource_virtual_drag_data_delete(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dragSource)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// dragDataGet asks the TreeDragSource to return a ContentProvider representing
// the row at path. Should robustly handle a path no longer found in the model!.
//
// The function takes the following parameters:
//
//   - path: row that was dragged.
//
// The function returns the following values:
//
//   - contentProvider (optional) for the given path or NULL if none exists.
func (dragSource *TreeDragSource) dragDataGet(path *TreePath) *gdk.ContentProvider {
	gclass := (*C.GtkTreeDragSourceIface)(coreglib.PeekParentClass(dragSource))
	fnarg := gclass.drag_data_get

	var _arg0 *C.GtkTreeDragSource  // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(coreglib.InternObject(dragSource).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C._gotk4_gtk4_TreeDragSource_virtual_drag_data_get(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dragSource)
	runtime.KeepAlive(path)

	var _contentProvider *gdk.ContentProvider // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_contentProvider = &gdk.ContentProvider{
				Object: obj,
			}
		}
	}

	return _contentProvider
}

// rowDraggable asks the TreeDragSource whether a particular row can be used
// as the source of a DND operation. If the source doesn’t implement this
// interface, the row is assumed draggable.
//
// The function takes the following parameters:
//
//   - path: row on which user is initiating a drag.
//
// The function returns the following values:
//
//   - ok: TRUE if the row can be dragged.
func (dragSource *TreeDragSource) rowDraggable(path *TreePath) bool {
	gclass := (*C.GtkTreeDragSourceIface)(coreglib.PeekParentClass(dragSource))
	fnarg := gclass.row_draggable

	var _arg0 *C.GtkTreeDragSource // out
	var _arg1 *C.GtkTreePath       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(coreglib.InternObject(dragSource).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C._gotk4_gtk4_TreeDragSource_virtual_row_draggable(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dragSource)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeModel: tree interface used by GtkTreeView
//
// The TreeModel interface defines a generic tree interface for use by the
// TreeView widget. It is an abstract interface, and is designed to be usable
// with any appropriate data structure. The programmer just has to implement
// this interface on their own data type for it to be viewable by a TreeView
// widget.
//
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides
// a way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
//
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided — the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as
// all appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
//
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the gtk.TreePath and the gtk.TreeIter (“iter” is short for iterator).
// Most of the interface consists of operations on a gtk.TreeIter.
//
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. A gtk.TreePath
// can be converted into either an array of unsigned integers or a string.
// The string form is a list of numbers separated by a colon. Each number refers
// to the offset at that level. Thus, the path 0 refers to the root node and the
// path 2:4 refers to the fifth child of the third node.
//
// By contrast, a gtk.TreeIter is a reference to a specific node on a specific
// model. It is a generic struct with an integer and three generic pointers.
// These are filled in by the model in a model-specific way. One can convert a
// path to an iterator by calling gtk_tree_model_get_iter(). These iterators are
// the primary way of accessing a model and are similar to the iterators used
// by TextBuffer. They are generally statically allocated on the stack and only
// used for a short time. The model interface defines a set of operations using
// them for navigating the model.
//
// It is expected that models fill in the iterator with private data.
// For example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an
// array and an offset in two of the pointers. Additionally, there is an
// integer field. This field is generally filled with a unique stamp per model.
// This stamp is for catching errors resulting from using invalid iterators with
// a model.
//
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesn’t emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the user’s point
// of view. Additionally, some models guarantee that an iterator is valid for
// as long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow
// for the case where iterators do not persist beyond a signal, some very
// important performance enhancements were made in the sort model. As a result,
// the K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
//
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location 3:2:5.
// While the first method shown is easier, the second is much more common,
// as you often get paths from callbacks.
//
// Acquiring a GtkTreeIter
//
//	// Three ways of getting the iter pointing to the location
//	GtkTreePath *path;
//	GtkTreeIter iter;
//	GtkTreeIter parent_iter;
//
//	// get the iterator from a string
//	gtk_tree_model_get_iter_from_string (model,
//	                                     &iter,
//	                                     "3:2:5");
//
//	// get the iterator from a path
//	path = gtk_tree_path_new_from_string ("3:2:5");
//	gtk_tree_model_get_iter (model, &iter, path);
//	gtk_tree_path_free (path);
//
//	// walk the tree to find the iterator
//	gtk_tree_model_iter_nth_child (model, &iter,
//	                               NULL, 3);
//	parent_iter = iter;
//	gtk_tree_model_iter_nth_child (model, &iter,
//	                               &parent_iter, 2);
//	parent_iter = iter;
//	gtk_tree_model_iter_nth_child (model, &iter,
//	                               &parent_iter, 5);
//
// This second example shows a quick way of iterating through a list and getting
// a string and an integer from each row. The populate_model() function used
// below is not shown, as it is specific to the ListStore. For information on
// how to write such a function, see the ListStore documentation.
//
// Reading data from a GtkTreeModel
//
//	enum
//	{
//	  STRING_COLUMN,
//	  INT_COLUMN,
//	  N_COLUMNS
//	};
//
//	...
//
//	GtkTreeModel *list_store;
//	GtkTreeIter iter;
//	gboolean valid;
//	int row_count = 0;
//
//	// make a new list_store
//	list_store = gtk_list_store_new (N_COLUMNS,
//	                                 G_TYPE_STRING,
//	                                 G_TYPE_INT);
//
//	// Fill the list store with data
//	populate_model (list_store);
//
//	// Get the first iter in the list, check it is valid and walk
//	// through the list, reading each row.
//
//	valid = gtk_tree_model_get_iter_first (list_store,
//	                                       &iter);
//	while (valid)
//	 {
//	   char *str_data;
//	   int    int_data;
//
//	   // Make sure you terminate calls to gtk_tree_model_get() with a “-1” value
//	   gtk_tree_model_get (list_store, &iter,
//	                       STRING_COLUMN, &str_data,
//	                       INT_COLUMN, &int_data,
//	                       -1);
//
//	   // Do something with the data
//	   g_print ("Row d: (s,d)\n",
//	            row_count, str_data, int_data);
//	   g_free (str_data);
//
//	   valid = gtk_tree_model_iter_next (list_store,
//	                                     &iter);
//	   row_count++;
//	 }
//
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for
// views to let models know when nodes are being displayed. TreeView will take
// a reference on a node when it is visible, which means the node is either
// in the toplevel or expanded. Being displayed does not mean that the node
// is currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
//
// When working with reference counting, the following rules must be taken into
// account:
//
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
//
// - Outstanding references on a deleted node are not released. This is
// not possible because the node has already been deleted by the time the
// row-deleted signal is received.
//
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
//
// TreeModel wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TreeModel struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TreeModel)(nil)
)

// TreeModeller describes TreeModel's interface methods.
type TreeModeller interface {
	coreglib.Objector

	// ForEach calls func on each node in model in a depth-first fashion.
	ForEach(fn TreeModelForEachFunc)
	// ColumnType returns the type of the column.
	ColumnType(index_ int) coreglib.Type
	// Flags returns a set of flags supported by this interface.
	Flags() TreeModelFlags
	// Iter sets iter to a valid iterator pointing to path.
	Iter(path *TreePath) (*TreeIter, bool)
	// IterFirst initializes iter with the first iterator in the tree (the one
	// at the path "0") and returns TRUE.
	IterFirst() (*TreeIter, bool)
	// IterFromString sets iter to a valid iterator pointing to path_string,
	// if it exists.
	IterFromString(pathString string) (*TreeIter, bool)
	// NColumns returns the number of columns supported by tree_model.
	NColumns() int
	// Path returns a newly-created TreePath-struct referenced by iter.
	Path(iter *TreeIter) *TreePath
	// StringFromIter generates a string representation of the iter.
	StringFromIter(iter *TreeIter) string
	// Value initializes and sets value to that at column.
	Value(iter *TreeIter, column int) coreglib.Value
	// IterChildren sets iter to point to the first child of parent.
	IterChildren(parent *TreeIter) (*TreeIter, bool)
	// IterHasChild returns TRUE if iter has children, FALSE otherwise.
	IterHasChild(iter *TreeIter) bool
	// IterNChildren returns the number of children that iter has.
	IterNChildren(iter *TreeIter) int
	// IterNext sets iter to point to the node following it at the current
	// level.
	IterNext(iter *TreeIter) bool
	// IterNthChild sets iter to be the child of parent, using the given index.
	IterNthChild(parent *TreeIter, n int) (*TreeIter, bool)
	// IterParent sets iter to be the parent of child.
	IterParent(child *TreeIter) (*TreeIter, bool)
	// IterPrevious sets iter to point to the previous node at the current
	// level.
	IterPrevious(iter *TreeIter) bool
	// RefNode lets the tree ref the node.
	RefNode(iter *TreeIter)
	// RowChanged emits the TreeModel::row-changed signal on tree_model.
	RowChanged(path *TreePath, iter *TreeIter)
	// RowDeleted emits the TreeModel::row-deleted signal on tree_model.
	RowDeleted(path *TreePath)
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// tree_model.
	RowHasChildToggled(path *TreePath, iter *TreeIter)
	// RowInserted emits the TreeModel::row-inserted signal on tree_model.
	RowInserted(path *TreePath, iter *TreeIter)
	// RowsReordered emits the TreeModel::rows-reordered signal on tree_model.
	RowsReordered(path *TreePath, iter *TreeIter, newOrder []int)
	// UnrefNode lets the tree unref the node.
	UnrefNode(iter *TreeIter)

	// Row-changed: this signal is emitted when a row in the model has changed.
	ConnectRowChanged(func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle
	// Row-deleted: this signal is emitted when a row has been deleted.
	ConnectRowDeleted(func(path *TreePath)) coreglib.SignalHandle
	// Row-has-child-toggled: this signal is emitted when a row has gotten the
	// first child row or lost its last child row.
	ConnectRowHasChildToggled(func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle
	// Row-inserted: this signal is emitted when a new row has been inserted in
	// the model.
	ConnectRowInserted(func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle
	// Rows-reordered: this signal is emitted when the children of a node in the
	// TreeModel have been reordered.
	ConnectRowsReordered(func(path *TreePath, iter *TreeIter, newOrder unsafe.Pointer)) coreglib.SignalHandle
}

var _ TreeModeller = (*TreeModel)(nil)

func wrapTreeModel(obj *coreglib.Object) *TreeModel {
	return &TreeModel{
		Object: obj,
	}
}

func marshalTreeModel(p uintptr) (interface{}, error) {
	return wrapTreeModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectRowChanged: this signal is emitted when a row in the model has
// changed.
func (childModel *TreeModel) ConnectRowChanged(f func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(childModel, "row-changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowChanged), f)
}

// ConnectRowDeleted: this signal is emitted when a row has been deleted.
//
// Note that no iterator is passed to the signal handler, since the row is
// already deleted.
//
// This should be called by models after a row has been removed. The location
// pointed to by path should be the location that the row previously was at.
// It may not be a valid location anymore.
func (childModel *TreeModel) ConnectRowDeleted(f func(path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(childModel, "row-deleted", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowDeleted), f)
}

// ConnectRowHasChildToggled: this signal is emitted when a row has gotten the
// first child row or lost its last child row.
func (childModel *TreeModel) ConnectRowHasChildToggled(f func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(childModel, "row-has-child-toggled", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowHasChildToggled), f)
}

// ConnectRowInserted: this signal is emitted when a new row has been inserted
// in the model.
//
// Note that the row may still be empty at this point, since it is a common
// pattern to first insert an empty row, and then fill it with the desired
// values.
func (childModel *TreeModel) ConnectRowInserted(f func(path *TreePath, iter *TreeIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(childModel, "row-inserted", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowInserted), f)
}

// ConnectRowsReordered: this signal is emitted when the children of a node in
// the TreeModel have been reordered.
//
// Note that this signal is not emitted when rows are reordered by DND, since
// this is implemented by removing and then reinserting the row.
func (childModel *TreeModel) ConnectRowsReordered(f func(path *TreePath, iter *TreeIter, newOrder unsafe.Pointer)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(childModel, "rows-reordered", false, unsafe.Pointer(C._gotk4_gtk4_TreeModel_ConnectRowsReordered), f)
}

// NewFilter creates a new TreeModel, with child_model as the child_model and
// root as the virtual root.
//
// The function takes the following parameters:
//
//   - root (optional) or NULL.
//
// The function returns the following values:
//
//   - treeModel: new TreeModel.
func (childModel *TreeModel) NewFilter(root *TreePath) *TreeModel {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(childModel).Native()))
	if root != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(root)))
	}

	_cret = C.gtk_tree_model_filter_new(_arg0, _arg1)
	runtime.KeepAlive(childModel)
	runtime.KeepAlive(root)

	var _treeModel *TreeModel // out

	_treeModel = wrapTreeModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeModel
}

// ForEach calls func on each node in model in a depth-first fashion.
//
// If func returns TRUE, then the tree ceases to be walked, and
// gtk_tree_model_foreach() returns.
//
// The function takes the following parameters:
//
//   - fn: function to be called on each row.
func (model *TreeModel) ForEach(fn TreeModelForEachFunc) {
	var _arg0 *C.GtkTreeModel           // out
	var _arg1 C.GtkTreeModelForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeModelForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_tree_model_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(fn)
}

// ColumnType returns the type of the column.
//
// The function takes the following parameters:
//
//   - index_: column index.
//
// The function returns the following values:
//
//   - gType: type of the column.
func (treeModel *TreeModel) ColumnType(index_ int) coreglib.Type {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.int           // out
	var _cret C.GType         // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = C.int(index_)

	_cret = C.gtk_tree_model_get_column_type(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(index_)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Flags returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of TreeModelFlags. The flags supported
// should not change during the lifetime of the tree_model.
//
// The function returns the following values:
//
//   - treeModelFlags flags supported by this interface.
func (treeModel *TreeModel) Flags() TreeModelFlags {
	var _arg0 *C.GtkTreeModel     // out
	var _cret C.GtkTreeModelFlags // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))

	_cret = C.gtk_tree_model_get_flags(_arg0)
	runtime.KeepAlive(treeModel)

	var _treeModelFlags TreeModelFlags // out

	_treeModelFlags = TreeModelFlags(_cret)

	return _treeModelFlags
}

// Iter sets iter to a valid iterator pointing to path. If path does not exist,
// iter is set to an invalid iterator and FALSE is returned.
//
// The function takes the following parameters:
//
//   - path: TreePath-struct.
//
// The function returns the following values:
//
//   - iter: uninitialized TreeIter-struct.
//   - ok: TRUE, if iter was set.
func (treeModel *TreeModel) Iter(path *TreePath) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreePath  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_model_get_iter(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFirst initializes iter with the first iterator in the tree (the one at
// the path "0") and returns TRUE. Returns FALSE if the tree is empty.
//
// The function returns the following values:
//
//   - iter: uninitialized TreeIter-struct.
//   - ok: TRUE, if iter was set.
func (treeModel *TreeModel) IterFirst() (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))

	_cret = C.gtk_tree_model_get_iter_first(_arg0, &_arg1)
	runtime.KeepAlive(treeModel)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterFromString sets iter to a valid iterator pointing to path_string,
// if it exists. Otherwise, iter is left invalid and FALSE is returned.
//
// The function takes the following parameters:
//
//   - pathString: string representation of a TreePath-struct.
//
// The function returns the following values:
//
//   - iter: uninitialized TreeIter-struct.
//   - ok: TRUE, if iter was set.
func (treeModel *TreeModel) IterFromString(pathString string) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.char         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(pathString)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_tree_model_get_iter_from_string(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(pathString)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// NColumns returns the number of columns supported by tree_model.
//
// The function returns the following values:
//
//   - gint: number of columns.
func (treeModel *TreeModel) NColumns() int {
	var _arg0 *C.GtkTreeModel // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))

	_cret = C.gtk_tree_model_get_n_columns(_arg0)
	runtime.KeepAlive(treeModel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Path returns a newly-created TreePath-struct referenced by iter.
//
// This path should be freed with gtk_tree_path_free().
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//
// The function returns the following values:
//
//   - treePath: newly-created TreePath-struct.
func (treeModel *TreeModel) Path(iter *TreeIter) *TreePath {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.GtkTreePath  // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_get_path(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// StringFromIter generates a string representation of the iter.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated string. Must be freed with g_free().
func (treeModel *TreeModel) StringFromIter(iter *TreeIter) string {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_get_string_from_iter(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Value initializes and sets value to that at column.
//
// When done with value, g_value_unset() needs to be called to free any
// allocated memory.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//   - column to lookup the value at.
//
// The function returns the following values:
//
//   - value: empty #GValue to set.
func (treeModel *TreeModel) Value(iter *TreeIter, column int) coreglib.Value {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.int           // out
	var _arg3 C.GValue        // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.int(column)

	C.gtk_tree_model_get_value(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(column)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg3)))

	return _value
}

// IterChildren sets iter to point to the first child of parent.
//
// If parent has no children, FALSE is returned and iter is set to be invalid.
// parent will remain a valid node after this function has been called.
//
// If parent is NULL returns the first node, equivalent to
// gtk_tree_model_get_iter_first (tree_model, iter);.
//
// The function takes the following parameters:
//
//   - parent (optional) or NULL.
//
// The function returns the following values:
//
//   - iter: new TreeIter-struct to be set to the child.
//   - ok: TRUE, if iter has been set to the first child.
func (treeModel *TreeModel) IterChildren(parent *TreeIter) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}

	_cret = C.gtk_tree_model_iter_children(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(parent)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterHasChild returns TRUE if iter has children, FALSE otherwise.
//
// The function takes the following parameters:
//
//   - iter to test for children.
//
// The function returns the following values:
//
//   - ok: TRUE if iter has children.
func (treeModel *TreeModel) IterHasChild(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_iter_has_child(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNChildren returns the number of children that iter has.
//
// As a special case, if iter is NULL, then the number of toplevel nodes is
// returned.
//
// The function takes the following parameters:
//
//   - iter (optional) or NULL.
//
// The function returns the following values:
//
//   - gint: number of children of iter.
func (treeModel *TreeModel) IterNChildren(iter *TreeIter) int {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	if iter != nil {
		_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	_cret = C.gtk_tree_model_iter_n_children(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IterNext sets iter to point to the node following it at the current level.
//
// If there is no next iter, FALSE is returned and iter is set to be invalid.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//
// The function returns the following values:
//
//   - ok: TRUE if iter has been changed to the next node.
func (treeModel *TreeModel) IterNext(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_iter_next(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterNthChild sets iter to be the child of parent, using the given index.
//
// The first index is 0. If n is too big, or parent has no children, iter is set
// to an invalid iterator and FALSE is returned. parent will remain a valid node
// after this function has been called. As a special case, if parent is NULL,
// then the n-th root node is set.
//
// The function takes the following parameters:
//
//   - parent (optional) to get the child from, or NULL.
//   - n: index of the desired child.
//
// The function returns the following values:
//
//   - iter to set to the nth child.
//   - ok: TRUE, if parent has an n-th child.
func (treeModel *TreeModel) IterNthChild(parent *TreeIter, n int) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	_arg3 = C.int(n)

	_cret = C.gtk_tree_model_iter_nth_child(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(n)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterParent sets iter to be the parent of child.
//
// If child is at the toplevel, and doesn’t have a parent, then iter is set to
// an invalid iterator and FALSE is returned. child will remain a valid node
// after this function has been called.
//
// iter will be initialized before the lookup is performed, so child and iter
// cannot point to the same memory location.
//
// The function takes the following parameters:
//
//   - child: TreeIter-struct.
//
// The function returns the following values:
//
//   - iter: new TreeIter-struct to set to the parent.
//   - ok: TRUE, if iter is set to the parent of child.
func (treeModel *TreeModel) IterParent(child *TreeIter) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(child)))

	_cret = C.gtk_tree_model_iter_parent(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(child)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterPrevious sets iter to point to the previous node at the current level.
//
// If there is no previous iter, FALSE is returned and iter is set to be
// invalid.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//
// The function returns the following values:
//
//   - ok: TRUE if iter has been changed to the previous node.
func (treeModel *TreeModel) IterPrevious(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_iter_previous(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RefNode lets the tree ref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
//
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache that
// node). Being displayed means a node is in an expanded branch, regardless
// of whether the node is currently visible in the viewport. For example,
// a file-system based model would not want to keep the entire file-hierarchy in
// memory, just the sections that are currently being displayed by every current
// view.
//
// A model should be expected to be able to get an iter independent of its
// reffed state.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
func (treeModel *TreeModel) RefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_ref_node(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
}

// RowChanged emits the TreeModel::row-changed signal on tree_model.
//
// The function takes the following parameters:
//
//   - path pointing to the changed row.
//   - iter: valid TreeIter-struct pointing to the changed row.
func (treeModel *TreeModel) RowChanged(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_row_changed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// RowDeleted emits the TreeModel::row-deleted signal on tree_model.
//
// This should be called by models after a row has been removed. The location
// pointed to by path should be the location that the row previously was at.
// It may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
//
// The function takes the following parameters:
//
//   - path pointing to the previous location of the deleted row.
func (treeModel *TreeModel) RowDeleted(path *TreePath) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_model_row_deleted(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
}

// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// tree_model. This should be called by models after the child state of a node
// changes.
//
// The function takes the following parameters:
//
//   - path pointing to the changed row.
//   - iter: valid TreeIter-struct pointing to the changed row.
func (treeModel *TreeModel) RowHasChildToggled(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_row_has_child_toggled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// RowInserted emits the TreeModel::row-inserted signal on tree_model.
//
// The function takes the following parameters:
//
//   - path pointing to the inserted row.
//   - iter: valid TreeIter-struct pointing to the inserted row.
func (treeModel *TreeModel) RowInserted(path *TreePath, iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_row_inserted(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// RowsReordered emits the TreeModel::rows-reordered signal on tree_model.
//
// This should be called by models when their rows have been reordered.
//
// The function takes the following parameters:
//
//   - path pointing to the tree node whose children have been reordered.
//   - iter (optional): valid TreeIter-struct pointing to the node whose
//     children have been reordered, or NULL if the depth of path is 0.
//   - newOrder: array of integers mapping the current position of each child to
//     its old position before the re-ordering, i.e. new_order[newpos] = oldpos.
func (treeModel *TreeModel) RowsReordered(path *TreePath, iter *TreeIter, newOrder []int) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 *C.int          // out
	var _arg4 C.int

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if iter != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}
	_arg4 = (C.int)(len(newOrder))
	_arg3 = (*C.int)(C.calloc(C.size_t(len(newOrder)), C.size_t(C.sizeof_int)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.int)(_arg3), len(newOrder))
		for i := range newOrder {
			out[i] = C.int(newOrder[i])
		}
	}

	C.gtk_tree_model_rows_reordered_with_length(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(newOrder)
}

// UnrefNode lets the tree unref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// For more information on what this means, see gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
func (treeModel *TreeModel) UnrefNode(iter *TreeIter) {
	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_model_unref_node(_arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
}

// columnType returns the type of the column.
//
// The function takes the following parameters:
//
//   - index_: column index.
//
// The function returns the following values:
//
//   - gType: type of the column.
func (treeModel *TreeModel) columnType(index_ int) coreglib.Type {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.get_column_type

	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.int           // out
	var _cret C.GType         // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = C.int(index_)

	_cret = C._gotk4_gtk4_TreeModel_virtual_get_column_type(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(index_)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// Flags returns a set of flags supported by this interface.
//
// The flags are a bitwise combination of TreeModelFlags. The flags supported
// should not change during the lifetime of the tree_model.
//
// The function returns the following values:
//
//   - treeModelFlags flags supported by this interface.
func (treeModel *TreeModel) flags() TreeModelFlags {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.get_flags

	var _arg0 *C.GtkTreeModel     // out
	var _cret C.GtkTreeModelFlags // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))

	_cret = C._gotk4_gtk4_TreeModel_virtual_get_flags(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeModel)

	var _treeModelFlags TreeModelFlags // out

	_treeModelFlags = TreeModelFlags(_cret)

	return _treeModelFlags
}

// Iter sets iter to a valid iterator pointing to path. If path does not exist,
// iter is set to an invalid iterator and FALSE is returned.
//
// The function takes the following parameters:
//
//   - path: TreePath-struct.
//
// The function returns the following values:
//
//   - iter: uninitialized TreeIter-struct.
//   - ok: TRUE, if iter was set.
func (treeModel *TreeModel) iter(path *TreePath) (*TreeIter, bool) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.get_iter

	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreePath  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C._gotk4_gtk4_TreeModel_virtual_get_iter(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// nColumns returns the number of columns supported by tree_model.
//
// The function returns the following values:
//
//   - gint: number of columns.
func (treeModel *TreeModel) nColumns() int {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.get_n_columns

	var _arg0 *C.GtkTreeModel // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))

	_cret = C._gotk4_gtk4_TreeModel_virtual_get_n_columns(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeModel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Path returns a newly-created TreePath-struct referenced by iter.
//
// This path should be freed with gtk_tree_path_free().
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//
// The function returns the following values:
//
//   - treePath: newly-created TreePath-struct.
func (treeModel *TreeModel) path(iter *TreeIter) *TreePath {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.get_path

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret *C.GtkTreePath  // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C._gotk4_gtk4_TreeModel_virtual_get_path(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// Value initializes and sets value to that at column.
//
// When done with value, g_value_unset() needs to be called to free any
// allocated memory.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//   - column to lookup the value at.
//
// The function returns the following values:
//
//   - value: empty #GValue to set.
func (treeModel *TreeModel) value(iter *TreeIter, column int) coreglib.Value {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.get_value

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.int           // out
	var _arg3 C.GValue        // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.int(column)

	C._gotk4_gtk4_TreeModel_virtual_get_value(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(column)

	var _value coreglib.Value // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg3)))

	return _value
}

// iterChildren sets iter to point to the first child of parent.
//
// If parent has no children, FALSE is returned and iter is set to be invalid.
// parent will remain a valid node after this function has been called.
//
// If parent is NULL returns the first node, equivalent to
// gtk_tree_model_get_iter_first (tree_model, iter);.
//
// The function takes the following parameters:
//
//   - parent (optional) or NULL.
//
// The function returns the following values:
//
//   - iter: new TreeIter-struct to be set to the child.
//   - ok: TRUE, if iter has been set to the first child.
func (treeModel *TreeModel) iterChildren(parent *TreeIter) (*TreeIter, bool) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.iter_children

	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}

	_cret = C._gotk4_gtk4_TreeModel_virtual_iter_children(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(parent)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// iterHasChild returns TRUE if iter has children, FALSE otherwise.
//
// The function takes the following parameters:
//
//   - iter to test for children.
//
// The function returns the following values:
//
//   - ok: TRUE if iter has children.
func (treeModel *TreeModel) iterHasChild(iter *TreeIter) bool {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.iter_has_child

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C._gotk4_gtk4_TreeModel_virtual_iter_has_child(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// iterNChildren returns the number of children that iter has.
//
// As a special case, if iter is NULL, then the number of toplevel nodes is
// returned.
//
// The function takes the following parameters:
//
//   - iter (optional) or NULL.
//
// The function returns the following values:
//
//   - gint: number of children of iter.
func (treeModel *TreeModel) iterNChildren(iter *TreeIter) int {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.iter_n_children

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	if iter != nil {
		_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	_cret = C._gotk4_gtk4_TreeModel_virtual_iter_n_children(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// iterNext sets iter to point to the node following it at the current level.
//
// If there is no next iter, FALSE is returned and iter is set to be invalid.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//
// The function returns the following values:
//
//   - ok: TRUE if iter has been changed to the next node.
func (treeModel *TreeModel) iterNext(iter *TreeIter) bool {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.iter_next

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C._gotk4_gtk4_TreeModel_virtual_iter_next(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// iterNthChild sets iter to be the child of parent, using the given index.
//
// The first index is 0. If n is too big, or parent has no children, iter is set
// to an invalid iterator and FALSE is returned. parent will remain a valid node
// after this function has been called. As a special case, if parent is NULL,
// then the n-th root node is set.
//
// The function takes the following parameters:
//
//   - parent (optional) to get the child from, or NULL.
//   - n: index of the desired child.
//
// The function returns the following values:
//
//   - iter to set to the nth child.
//   - ok: TRUE, if parent has an n-th child.
func (treeModel *TreeModel) iterNthChild(parent *TreeIter, n int) (*TreeIter, bool) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.iter_nth_child

	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	_arg3 = C.int(n)

	_cret = C._gotk4_gtk4_TreeModel_virtual_iter_nth_child(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(n)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// iterParent sets iter to be the parent of child.
//
// If child is at the toplevel, and doesn’t have a parent, then iter is set to
// an invalid iterator and FALSE is returned. child will remain a valid node
// after this function has been called.
//
// iter will be initialized before the lookup is performed, so child and iter
// cannot point to the same memory location.
//
// The function takes the following parameters:
//
//   - child: TreeIter-struct.
//
// The function returns the following values:
//
//   - iter: new TreeIter-struct to set to the parent.
//   - ok: TRUE, if iter is set to the parent of child.
func (treeModel *TreeModel) iterParent(child *TreeIter) (*TreeIter, bool) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.iter_parent

	var _arg0 *C.GtkTreeModel // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(child)))

	_cret = C._gotk4_gtk4_TreeModel_virtual_iter_parent(unsafe.Pointer(fnarg), _arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(child)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// iterPrevious sets iter to point to the previous node at the current level.
//
// If there is no previous iter, FALSE is returned and iter is set to be
// invalid.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
//
// The function returns the following values:
//
//   - ok: TRUE if iter has been changed to the previous node.
func (treeModel *TreeModel) iterPrevious(iter *TreeIter) bool {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.iter_previous

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C._gotk4_gtk4_TreeModel_virtual_iter_previous(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// refNode lets the tree ref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
//
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache that
// node). Being displayed means a node is in an expanded branch, regardless
// of whether the node is currently visible in the viewport. For example,
// a file-system based model would not want to keep the entire file-hierarchy in
// memory, just the sections that are currently being displayed by every current
// view.
//
// A model should be expected to be able to get an iter independent of its
// reffed state.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
func (treeModel *TreeModel) refNode(iter *TreeIter) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.ref_node

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C._gotk4_gtk4_TreeModel_virtual_ref_node(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
}

// rowChanged emits the TreeModel::row-changed signal on tree_model.
//
// The function takes the following parameters:
//
//   - path pointing to the changed row.
//   - iter: valid TreeIter-struct pointing to the changed row.
func (treeModel *TreeModel) rowChanged(path *TreePath, iter *TreeIter) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.row_changed

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C._gotk4_gtk4_TreeModel_virtual_row_changed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// rowDeleted emits the TreeModel::row-deleted signal on tree_model.
//
// This should be called by models after a row has been removed. The location
// pointed to by path should be the location that the row previously was at.
// It may not be a valid location anymore.
//
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
//
// The function takes the following parameters:
//
//   - path pointing to the previous location of the deleted row.
func (treeModel *TreeModel) rowDeleted(path *TreePath) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.row_deleted

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C._gotk4_gtk4_TreeModel_virtual_row_deleted(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
}

// rowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// tree_model. This should be called by models after the child state of a node
// changes.
//
// The function takes the following parameters:
//
//   - path pointing to the changed row.
//   - iter: valid TreeIter-struct pointing to the changed row.
func (treeModel *TreeModel) rowHasChildToggled(path *TreePath, iter *TreeIter) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.row_has_child_toggled

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C._gotk4_gtk4_TreeModel_virtual_row_has_child_toggled(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// rowInserted emits the TreeModel::row-inserted signal on tree_model.
//
// The function takes the following parameters:
//
//   - path pointing to the inserted row.
//   - iter: valid TreeIter-struct pointing to the inserted row.
func (treeModel *TreeModel) rowInserted(path *TreePath, iter *TreeIter) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.row_inserted

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreePath  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C._gotk4_gtk4_TreeModel_virtual_row_inserted(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(path)
	runtime.KeepAlive(iter)
}

// unrefNode lets the tree unref the node.
//
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// For more information on what this means, see gtk_tree_model_ref_node().
//
// Please note that nodes that are deleted are not unreffed.
//
// The function takes the following parameters:
//
//   - iter: TreeIter-struct.
func (treeModel *TreeModel) unrefNode(iter *TreeIter) {
	gclass := (*C.GtkTreeModelIface)(coreglib.PeekParentClass(treeModel))
	fnarg := gclass.unref_node

	var _arg0 *C.GtkTreeModel // out
	var _arg1 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C._gotk4_gtk4_TreeModel_virtual_unref_node(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
}

// TreeSortable: interface for sortable models used by GtkTreeView
//
// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
//
// TreeSortable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type TreeSortable struct {
	_ [0]func() // equal guard
	TreeModel
}

var ()

// TreeSortabler describes TreeSortable's interface methods.
type TreeSortabler interface {
	coreglib.Objector

	// SortColumnID fills in sort_column_id and order with the current sort
	// column and the order.
	SortColumnID() (int, SortType, bool)
	// HasDefaultSortFunc returns TRUE if the model has a default sort function.
	HasDefaultSortFunc() bool
	// SetDefaultSortFunc sets the default comparison function used when sorting
	// to be sort_func.
	SetDefaultSortFunc(sortFunc TreeIterCompareFunc)
	// SetSortColumnID sets the current sort column to be sort_column_id.
	SetSortColumnID(sortColumnId int, order SortType)
	// SetSortFunc sets the comparison function used when sorting to be
	// sort_func.
	SetSortFunc(sortColumnId int, sortFunc TreeIterCompareFunc)
	// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
	// sortable.
	SortColumnChanged()

	// Sort-column-changed signal is emitted when the sort column or sort order
	// of sortable is changed.
	ConnectSortColumnChanged(func()) coreglib.SignalHandle
}

var _ TreeSortabler = (*TreeSortable)(nil)

func wrapTreeSortable(obj *coreglib.Object) *TreeSortable {
	return &TreeSortable{
		TreeModel: TreeModel{
			Object: obj,
		},
	}
}

func marshalTreeSortable(p uintptr) (interface{}, error) {
	return wrapTreeSortable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectSortColumnChanged signal is emitted when the sort column or sort order
// of sortable is changed. The signal is emitted before the contents of sortable
// are resorted.
func (sortable *TreeSortable) ConnectSortColumnChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(sortable, "sort-column-changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeSortable_ConnectSortColumnChanged), f)
}

// SortColumnID fills in sort_column_id and order with the
// current sort column and the order. It returns TRUE unless the
// sort_column_id is GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
//
// The function returns the following values:
//
//   - sortColumnId: sort column id to be filled in.
//   - order to be filled in.
//   - ok: TRUE if the sort column is not one of the special sort column ids.
func (sortable *TreeSortable) SortColumnID() (int, SortType, bool) {
	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.int              // in
	var _arg2 C.GtkSortType      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))

	_cret = C.gtk_tree_sortable_get_sort_column_id(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(sortable)

	var _sortColumnId int // out
	var _order SortType   // out
	var _ok bool          // out

	_sortColumnId = int(_arg1)
	_order = SortType(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _sortColumnId, _order, _ok
}

// HasDefaultSortFunc returns TRUE if the model has a default sort function.
// This is used primarily by GtkTreeViewColumns in order to determine if a model
// can go back to the default state, or not.
//
// The function returns the following values:
//
//   - ok: TRUE, if the model has a default sort function.
func (sortable *TreeSortable) HasDefaultSortFunc() bool {
	var _arg0 *C.GtkTreeSortable // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))

	_cret = C.gtk_tree_sortable_has_default_sort_func(_arg0)
	runtime.KeepAlive(sortable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDefaultSortFunc sets the default comparison function used when
// sorting to be sort_func. If the current sort column id of sortable is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, then the model will sort using this
// function.
//
// If sort_func is NULL, then there will be no default comparison function.
// This means that once the model has been sorted, it can’t go back to the
// default state. In this case, when the current sort column id of sortable is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, the model will be unsorted.
//
// The function takes the following parameters:
//
//   - sortFunc: comparison function.
func (sortable *TreeSortable) SetDefaultSortFunc(sortFunc TreeIterCompareFunc) {
	var _arg0 *C.GtkTreeSortable       // out
	var _arg1 C.GtkTreeIterCompareFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeIterCompareFunc)
	_arg2 = C.gpointer(gbox.Assign(sortFunc))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_tree_sortable_set_default_sort_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(sortable)
	runtime.KeepAlive(sortFunc)
}

// SetSortColumnID sets the current sort column to be sort_column_id.
// The sortable will resort itself to reflect this change, after emitting a
// TreeSortable::sort-column-changed signal. sort_column_id may either be a
// regular column id, or one of the following special values:
//
// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function will be
// used, if it is set
//
// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur.
//
// The function takes the following parameters:
//
//   - sortColumnId: sort column id to set.
//   - order: sort order of the column.
func (sortable *TreeSortable) SetSortColumnID(sortColumnId int, order SortType) {
	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.int              // out
	var _arg2 C.GtkSortType      // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))
	_arg1 = C.int(sortColumnId)
	_arg2 = C.GtkSortType(order)

	C.gtk_tree_sortable_set_sort_column_id(_arg0, _arg1, _arg2)
	runtime.KeepAlive(sortable)
	runtime.KeepAlive(sortColumnId)
	runtime.KeepAlive(order)
}

// SetSortFunc sets the comparison function used when sorting to be sort_func.
// If the current sort column id of sortable is the same as sort_column_id,
// then the model will sort using this function.
//
// The function takes the following parameters:
//
//   - sortColumnId: sort column id to set the function for.
//   - sortFunc: comparison function.
func (sortable *TreeSortable) SetSortFunc(sortColumnId int, sortFunc TreeIterCompareFunc) {
	var _arg0 *C.GtkTreeSortable       // out
	var _arg1 C.int                    // out
	var _arg2 C.GtkTreeIterCompareFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))
	_arg1 = C.int(sortColumnId)
	_arg2 = (*[0]byte)(C._gotk4_gtk4_TreeIterCompareFunc)
	_arg3 = C.gpointer(gbox.Assign(sortFunc))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_tree_sortable_set_sort_func(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(sortable)
	runtime.KeepAlive(sortColumnId)
	runtime.KeepAlive(sortFunc)
}

// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
// sortable.
func (sortable *TreeSortable) SortColumnChanged() {
	var _arg0 *C.GtkTreeSortable // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))

	C.gtk_tree_sortable_sort_column_changed(_arg0)
	runtime.KeepAlive(sortable)
}

// sortColumnID fills in sort_column_id and order with the
// current sort column and the order. It returns TRUE unless the
// sort_column_id is GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
//
// The function returns the following values:
//
//   - sortColumnId: sort column id to be filled in.
//   - order to be filled in.
//   - ok: TRUE if the sort column is not one of the special sort column ids.
func (sortable *TreeSortable) sortColumnID() (int, SortType, bool) {
	gclass := (*C.GtkTreeSortableIface)(coreglib.PeekParentClass(sortable))
	fnarg := gclass.get_sort_column_id

	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.int              // in
	var _arg2 C.GtkSortType      // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))

	_cret = C._gotk4_gtk4_TreeSortable_virtual_get_sort_column_id(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(sortable)

	var _sortColumnId int // out
	var _order SortType   // out
	var _ok bool          // out

	_sortColumnId = int(_arg1)
	_order = SortType(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _sortColumnId, _order, _ok
}

// hasDefaultSortFunc returns TRUE if the model has a default sort function.
// This is used primarily by GtkTreeViewColumns in order to determine if a model
// can go back to the default state, or not.
//
// The function returns the following values:
//
//   - ok: TRUE, if the model has a default sort function.
func (sortable *TreeSortable) hasDefaultSortFunc() bool {
	gclass := (*C.GtkTreeSortableIface)(coreglib.PeekParentClass(sortable))
	fnarg := gclass.has_default_sort_func

	var _arg0 *C.GtkTreeSortable // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))

	_cret = C._gotk4_gtk4_TreeSortable_virtual_has_default_sort_func(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sortable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setDefaultSortFunc sets the default comparison function used when
// sorting to be sort_func. If the current sort column id of sortable is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, then the model will sort using this
// function.
//
// If sort_func is NULL, then there will be no default comparison function.
// This means that once the model has been sorted, it can’t go back to the
// default state. In this case, when the current sort column id of sortable is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID, the model will be unsorted.
//
// The function takes the following parameters:
//
//   - sortFunc: comparison function.
func (sortable *TreeSortable) setDefaultSortFunc(sortFunc TreeIterCompareFunc) {
	gclass := (*C.GtkTreeSortableIface)(coreglib.PeekParentClass(sortable))
	fnarg := gclass.set_default_sort_func

	var _arg0 *C.GtkTreeSortable       // out
	var _arg1 C.GtkTreeIterCompareFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeIterCompareFunc)
	_arg2 = C.gpointer(gbox.Assign(sortFunc))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C._gotk4_gtk4_TreeSortable_virtual_set_default_sort_func(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(sortable)
	runtime.KeepAlive(sortFunc)
}

// setSortColumnID sets the current sort column to be sort_column_id.
// The sortable will resort itself to reflect this change, after emitting a
// TreeSortable::sort-column-changed signal. sort_column_id may either be a
// regular column id, or one of the following special values:
//
// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function will be
// used, if it is set
//
// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur.
//
// The function takes the following parameters:
//
//   - sortColumnId: sort column id to set.
//   - order: sort order of the column.
func (sortable *TreeSortable) setSortColumnID(sortColumnId int, order SortType) {
	gclass := (*C.GtkTreeSortableIface)(coreglib.PeekParentClass(sortable))
	fnarg := gclass.set_sort_column_id

	var _arg0 *C.GtkTreeSortable // out
	var _arg1 C.int              // out
	var _arg2 C.GtkSortType      // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))
	_arg1 = C.int(sortColumnId)
	_arg2 = C.GtkSortType(order)

	C._gotk4_gtk4_TreeSortable_virtual_set_sort_column_id(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(sortable)
	runtime.KeepAlive(sortColumnId)
	runtime.KeepAlive(order)
}

// setSortFunc sets the comparison function used when sorting to be sort_func.
// If the current sort column id of sortable is the same as sort_column_id,
// then the model will sort using this function.
//
// The function takes the following parameters:
//
//   - sortColumnId: sort column id to set the function for.
//   - sortFunc: comparison function.
func (sortable *TreeSortable) setSortFunc(sortColumnId int, sortFunc TreeIterCompareFunc) {
	gclass := (*C.GtkTreeSortableIface)(coreglib.PeekParentClass(sortable))
	fnarg := gclass.set_sort_func

	var _arg0 *C.GtkTreeSortable       // out
	var _arg1 C.int                    // out
	var _arg2 C.GtkTreeIterCompareFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))
	_arg1 = C.int(sortColumnId)
	_arg2 = (*[0]byte)(C._gotk4_gtk4_TreeIterCompareFunc)
	_arg3 = C.gpointer(gbox.Assign(sortFunc))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C._gotk4_gtk4_TreeSortable_virtual_set_sort_func(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(sortable)
	runtime.KeepAlive(sortColumnId)
	runtime.KeepAlive(sortFunc)
}

// sortColumnChanged emits a TreeSortable::sort-column-changed signal on
// sortable.
func (sortable *TreeSortable) sortColumnChanged() {
	gclass := (*C.GtkTreeSortableIface)(coreglib.PeekParentClass(sortable))
	fnarg := gclass.sort_column_changed

	var _arg0 *C.GtkTreeSortable // out

	_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(coreglib.InternObject(sortable).Native()))

	C._gotk4_gtk4_TreeSortable_virtual_sort_column_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(sortable)
}

// ATContext: GtkATContext is an abstract class provided by GTK to communicate
// to platform-specific assistive technologies API.
//
// Each platform supported by GTK implements a GtkATContext subclass, and is
// responsible for updating the accessible state in response to state changes in
// GtkAccessible.
type ATContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ATContext)(nil)
)

// ATContexter describes types inherited from class ATContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type ATContexter interface {
	coreglib.Objector
	baseATContext() *ATContext
}

var _ ATContexter = (*ATContext)(nil)

func wrapATContext(obj *coreglib.Object) *ATContext {
	return &ATContext{
		Object: obj,
	}
}

func marshalATContext(p uintptr) (interface{}, error) {
	return wrapATContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *ATContext) baseATContext() *ATContext {
	return self
}

// BaseATContext returns the underlying base object.
func BaseATContext(obj ATContexter) *ATContext {
	return obj.baseATContext()
}

// ConnectStateChange is emitted when the attributes of the accessible for the
// GtkATContext instance change.
func (self *ATContext) ConnectStateChange(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "state-change", false, unsafe.Pointer(C._gotk4_gtk4_ATContext_ConnectStateChange), f)
}

// NewATContextCreate creates a new GtkATContext instance for the given
// accessible role, accessible instance, and display connection.
//
// The GtkATContext implementation being instantiated will depend on the
// platform.
//
// The function takes the following parameters:
//
//   - accessibleRole: accessible role used by the GtkATContext.
//   - accessible: GtkAccessible implementation using the GtkATContext.
//   - display: GdkDisplay used by the GtkATContext.
//
// The function returns the following values:
//
//   - atContext (optional): GtkATContext.
func NewATContextCreate(accessibleRole AccessibleRole, accessible Accessibler, display *gdk.Display) *ATContext {
	var _arg1 C.GtkAccessibleRole // out
	var _arg2 *C.GtkAccessible    // out
	var _arg3 *C.GdkDisplay       // out
	var _cret *C.GtkATContext     // in

	_arg1 = C.GtkAccessibleRole(accessibleRole)
	_arg2 = (*C.GtkAccessible)(unsafe.Pointer(coreglib.InternObject(accessible).Native()))
	_arg3 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gtk_at_context_create(_arg1, _arg2, _arg3)
	runtime.KeepAlive(accessibleRole)
	runtime.KeepAlive(accessible)
	runtime.KeepAlive(display)

	var _atContext *ATContext // out

	if _cret != nil {
		_atContext = wrapATContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _atContext
}

// Accessible retrieves the GtkAccessible using this context.
//
// The function returns the following values:
//
//   - accessible: GtkAccessible.
func (self *ATContext) Accessible() *Accessible {
	var _arg0 *C.GtkATContext  // out
	var _cret *C.GtkAccessible // in

	_arg0 = (*C.GtkATContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_at_context_get_accessible(_arg0)
	runtime.KeepAlive(self)

	var _accessible *Accessible // out

	_accessible = wrapAccessible(coreglib.Take(unsafe.Pointer(_cret)))

	return _accessible
}

// AccessibleRole retrieves the accessible role of this context.
//
// The function returns the following values:
//
//   - accessibleRole: GtkAccessibleRole.
func (self *ATContext) AccessibleRole() AccessibleRole {
	var _arg0 *C.GtkATContext     // out
	var _cret C.GtkAccessibleRole // in

	_arg0 = (*C.GtkATContext)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_at_context_get_accessible_role(_arg0)
	runtime.KeepAlive(self)

	var _accessibleRole AccessibleRole // out

	_accessibleRole = AccessibleRole(_cret)

	return _accessibleRole
}

// AboutDialog: GtkAboutDialog offers a simple way to display information about
// a program.
//
// The shown information includes the programs' logo, name, copyright, website
// and license. It is also possible to give credits to the authors, documenters,
// translators and artists who have worked on the program.
//
// An about dialog is typically opened when the user selects the About option
// from the Help menu. All parts of the dialog are optional.
//
// !An example GtkAboutDialog (aboutdialog.png)
//
// About dialogs often contain links and email addresses. GtkAboutDialog
// displays these as clickable links. By default, it calls gtk.ShowURI()
// when a user clicks one. The behaviour can be overridden with the
// gtk.AboutDialog::activate-link signal.
//
// To specify a person with an email address, use a string like Edgar Allan Poe
// <edgarpoe.com>. To specify a website with a title, use a string like GTK team
// https://www.gtk.org.
//
// To make constructing a GtkAboutDialog as convenient as possible, you can use
// the function gtk.ShowAboutDialog() which constructs and shows a dialog and
// keeps it around so that it can be shown again.
//
// Note that GTK sets a default title of _("About s") on the dialog window
// (where s is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a GtkAboutDialog, as shown in the following
// example:
//
//	GFile *logo_file = g_file_new_for_path ("./logo.png");
//	GdkTexture *example_logo = gdk_texture_new_from_file (logo_file, NULL);
//	g_object_unref (logo_file);
//
//	gtk_show_about_dialog (NULL,
//	                       "program-name", "ExampleCode",
//	                       "logo", example_logo,
//	                       "title", _("About ExampleCode"),
//	                       NULL);
//
// # CSS nodes
//
// GtkAboutDialog has a single CSS node with the name window and style class
// .aboutdialog.
type AboutDialog struct {
	_ [0]func() // equal guard
	Window
}

var (
	_ Widgetter         = (*AboutDialog)(nil)
	_ coreglib.Objector = (*AboutDialog)(nil)
)

func wrapAboutDialog(obj *coreglib.Object) *AboutDialog {
	return &AboutDialog{
		Window: Window{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Root: Root{
				NativeSurface: NativeSurface{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						Accessible: Accessible{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
						ConstraintTarget: ConstraintTarget{
							Object: obj,
						},
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
	}
}

func marshalAboutDialog(p uintptr) (interface{}, error) {
	return wrapAboutDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateLink is emitted every time a URL is activated.
//
// Applications may connect to it to override the default behaviour, which is to
// call gtk.ShowURI().
func (about *AboutDialog) ConnectActivateLink(f func(uri string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(about, "activate-link", false, unsafe.Pointer(C._gotk4_gtk4_AboutDialog_ConnectActivateLink), f)
}

// NewAboutDialog creates a new GtkAboutDialog.
//
// The function returns the following values:
//
//   - aboutDialog: newly created GtkAboutDialog.
func NewAboutDialog() *AboutDialog {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_about_dialog_new()

	var _aboutDialog *AboutDialog // out

	_aboutDialog = wrapAboutDialog(coreglib.Take(unsafe.Pointer(_cret)))

	return _aboutDialog
}

// AddCreditSection creates a new section in the "Credits" page.
//
// The function takes the following parameters:
//
//   - sectionName: name of the section.
//   - people who belong to that section.
func (about *AboutDialog) AddCreditSection(sectionName string, people []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out
	var _arg2 **C.char          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(sectionName)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(people) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(people)+1)
			var zero *C.char
			out[len(people)] = zero
			for i := range people {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(people[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_about_dialog_add_credit_section(_arg0, _arg1, _arg2)
	runtime.KeepAlive(about)
	runtime.KeepAlive(sectionName)
	runtime.KeepAlive(people)
}

// Artists returns the string which are displayed in the "Artists" tab of the
// secondary credits dialog.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated string array containing the artists. The array
//     is owned by the about dialog and must not be modified.
func (about *AboutDialog) Artists() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.char          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_artists(_arg0)
	runtime.KeepAlive(about)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Authors returns the string which are displayed in the authors tab of the
// secondary credits dialog.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated string array containing the authors. The array
//     is owned by the about dialog and must not be modified.
func (about *AboutDialog) Authors() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.char          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_authors(_arg0)
	runtime.KeepAlive(about)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Comments returns the comments string.
//
// The function returns the following values:
//
//   - utf8 (optional): comments. The string is owned by the about dialog and
//     must not be modified.
func (about *AboutDialog) Comments() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_comments(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Copyright returns the copyright string.
//
// The function returns the following values:
//
//   - utf8 (optional): copyright string. The string is owned by the about
//     dialog and must not be modified.
func (about *AboutDialog) Copyright() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_copyright(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Documenters returns the string which are displayed in the "Documenters" tab
// of the secondary credits dialog.
//
// The function returns the following values:
//
//   - utf8s: a NULL-terminated string array containing the documenters.
//     The array is owned by the about dialog and must not be modified.
func (about *AboutDialog) Documenters() []string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret **C.char          // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_documenters(_arg0)
	runtime.KeepAlive(about)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// License returns the license information.
//
// The function returns the following values:
//
//   - utf8 (optional): license information. The string is owned by the about
//     dialog and must not be modified.
func (about *AboutDialog) License() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_license(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// LicenseType retrieves the license type.
//
// The function returns the following values:
//
//   - license: gtk.License value.
func (about *AboutDialog) LicenseType() License {
	var _arg0 *C.GtkAboutDialog // out
	var _cret C.GtkLicense      // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_license_type(_arg0)
	runtime.KeepAlive(about)

	var _license License // out

	_license = License(_cret)

	return _license
}

// Logo returns the paintable displayed as logo in the about dialog.
//
// The function returns the following values:
//
//   - paintable (optional) displayed as logo or NULL if the logo is unset or
//     has been set via gtk.AboutDialog.SetLogoIconName(). The paintable is
//     owned by the about dialog.
func (about *AboutDialog) Logo() *gdk.Paintable {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.GdkPaintable   // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_logo(_arg0)
	runtime.KeepAlive(about)

	var _paintable *gdk.Paintable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_paintable = &gdk.Paintable{
				Object: obj,
			}
		}
	}

	return _paintable
}

// LogoIconName returns the icon name displayed as logo in the about dialog.
//
// The function returns the following values:
//
//   - utf8 (optional): icon name displayed as logo, or NULL if the logo has
//     been set via gtk.AboutDialog.SetLogo(). The string is owned by the
//     dialog.
func (about *AboutDialog) LogoIconName() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_logo_icon_name(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ProgramName returns the program name displayed in the about dialog.
//
// The function returns the following values:
//
//   - utf8 (optional): program name. The string is owned by the about dialog
//     and must not be modified.
func (about *AboutDialog) ProgramName() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_program_name(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SystemInformation returns the system information that is shown in the about
// dialog.
//
// The function returns the following values:
//
//   - utf8 (optional): system information.
func (about *AboutDialog) SystemInformation() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_system_information(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TranslatorCredits returns the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
//
// The function returns the following values:
//
//   - utf8 (optional): translator credits string.
func (about *AboutDialog) TranslatorCredits() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_translator_credits(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Version returns the version string.
//
// The function returns the following values:
//
//   - utf8 (optional): version string. The string is owned by the about dialog
//     and must not be modified.
func (about *AboutDialog) Version() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_version(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Website returns the website URL.
//
// The function returns the following values:
//
//   - utf8 (optional): website URL.
func (about *AboutDialog) Website() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_website(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// WebsiteLabel returns the label used for the website link.
//
// The function returns the following values:
//
//   - utf8 (optional): label used for the website link.
func (about *AboutDialog) WebsiteLabel() string {
	var _arg0 *C.GtkAboutDialog // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_website_label(_arg0)
	runtime.KeepAlive(about)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// WrapLicense returns whether the license text in the about dialog is
// automatically wrapped.
//
// The function returns the following values:
//
//   - ok: TRUE if the license text is wrapped.
func (about *AboutDialog) WrapLicense() bool {
	var _arg0 *C.GtkAboutDialog // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))

	_cret = C.gtk_about_dialog_get_wrap_license(_arg0)
	runtime.KeepAlive(about)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetArtists sets the strings which are displayed in the "Artists" tab of the
// secondary credits dialog.
//
// The function takes the following parameters:
//
//   - artists authors of the artwork of the application.
func (about *AboutDialog) SetArtists(artists []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.char          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(artists) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(artists)+1)
			var zero *C.char
			out[len(artists)] = zero
			for i := range artists {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(artists[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_about_dialog_set_artists(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(artists)
}

// SetAuthors sets the strings which are displayed in the "Authors" tab of the
// secondary credits dialog.
//
// The function takes the following parameters:
//
//   - authors of the application.
func (about *AboutDialog) SetAuthors(authors []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.char          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(authors) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(authors)+1)
			var zero *C.char
			out[len(authors)] = zero
			for i := range authors {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(authors[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_about_dialog_set_authors(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(authors)
}

// SetComments sets the comments string to display in the about dialog.
//
// This should be a short string of one or two lines.
//
// The function takes the following parameters:
//
//   - comments (optional) string.
func (about *AboutDialog) SetComments(comments string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if comments != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(comments)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_comments(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(comments)
}

// SetCopyright sets the copyright string to display in the about dialog.
//
// This should be a short string of one or two lines.
//
// The function takes the following parameters:
//
//   - copyright (optional) string.
func (about *AboutDialog) SetCopyright(copyright string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if copyright != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(copyright)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_copyright(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(copyright)
}

// SetDocumenters sets the strings which are displayed in the "Documenters" tab
// of the credits dialog.
//
// The function takes the following parameters:
//
//   - documenters authors of the documentation of the application.
func (about *AboutDialog) SetDocumenters(documenters []string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 **C.char          // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(documenters) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(documenters)+1)
			var zero *C.char
			out[len(documenters)] = zero
			for i := range documenters {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(documenters[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_about_dialog_set_documenters(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(documenters)
}

// SetLicense sets the license information to be displayed in the secondary
// license dialog.
//
// If license is NULL, the license button is hidden.
//
// The function takes the following parameters:
//
//   - license (optional) information.
func (about *AboutDialog) SetLicense(license string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if license != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(license)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_license(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(license)
}

// SetLicenseType sets the license of the application showing the about dialog
// from a list of known licenses.
//
// This function overrides the license set using gtk.AboutDialog.SetLicense().
//
// The function takes the following parameters:
//
//   - licenseType: type of license.
func (about *AboutDialog) SetLicenseType(licenseType License) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 C.GtkLicense      // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	_arg1 = C.GtkLicense(licenseType)

	C.gtk_about_dialog_set_license_type(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(licenseType)
}

// SetLogo sets the logo in the about dialog.
//
// The function takes the following parameters:
//
//   - logo (optional): GdkPaintable.
func (about *AboutDialog) SetLogo(logo gdk.Paintabler) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.GdkPaintable   // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if logo != nil {
		_arg1 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(logo).Native()))
	}

	C.gtk_about_dialog_set_logo(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(logo)
}

// SetLogoIconName sets the icon name to be displayed as logo in the about
// dialog.
//
// The function takes the following parameters:
//
//   - iconName (optional): icon name.
func (about *AboutDialog) SetLogoIconName(iconName string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if iconName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_logo_icon_name(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(iconName)
}

// SetProgramName sets the name to display in the about dialog.
//
// If name is not set, it defaults to g_get_application_name().
//
// The function takes the following parameters:
//
//   - name (optional): program name.
func (about *AboutDialog) SetProgramName(name string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_program_name(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(name)
}

// SetSystemInformation sets the system information to be displayed in the about
// dialog.
//
// If system_information is NULL, the system information tab is hidden.
//
// See gtk.AboutDialog:system-information.
//
// The function takes the following parameters:
//
//   - systemInformation (optional): system information.
func (about *AboutDialog) SetSystemInformation(systemInformation string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if systemInformation != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(systemInformation)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_system_information(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(systemInformation)
}

// SetTranslatorCredits sets the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
//
// The intended use for this string is to display the translator of the language
// which is currently used in the user interface. Using gettext(), a simple way
// to achieve that is to mark the string for translation:
//
//	GtkWidget *about = gtk_about_dialog_new ();
//	 gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
//	                                          _("translator-credits"));
//
// It is a good idea to use the customary msgid “translator-credits” for this
// purpose, since translators will already know the purpose of that msgid,
// and since GtkAboutDialog will detect if “translator-credits” is untranslated
// and hide the tab.
//
// The function takes the following parameters:
//
//   - translatorCredits (optional): translator credits.
func (about *AboutDialog) SetTranslatorCredits(translatorCredits string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if translatorCredits != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(translatorCredits)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_translator_credits(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(translatorCredits)
}

// SetVersion sets the version string to display in the about dialog.
//
// The function takes the following parameters:
//
//   - version (optional) string.
func (about *AboutDialog) SetVersion(version string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if version != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(version)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_version(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(version)
}

// SetWebsite sets the URL to use for the website link.
//
// The function takes the following parameters:
//
//   - website (optional): URL string starting with http://.
func (about *AboutDialog) SetWebsite(website string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if website != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(website)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_about_dialog_set_website(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(website)
}

// SetWebsiteLabel sets the label to be used for the website link.
//
// The function takes the following parameters:
//
//   - websiteLabel: label used for the website link.
func (about *AboutDialog) SetWebsiteLabel(websiteLabel string) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(websiteLabel)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_about_dialog_set_website_label(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(websiteLabel)
}

// SetWrapLicense sets whether the license text in the about dialog should be
// automatically wrapped.
//
// The function takes the following parameters:
//
//   - wrapLicense: whether to wrap the license.
func (about *AboutDialog) SetWrapLicense(wrapLicense bool) {
	var _arg0 *C.GtkAboutDialog // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(coreglib.InternObject(about).Native()))
	if wrapLicense {
		_arg1 = C.TRUE
	}

	C.gtk_about_dialog_set_wrap_license(_arg0, _arg1)
	runtime.KeepAlive(about)
	runtime.KeepAlive(wrapLicense)
}

// ActionBar: GtkActionBar is designed to present contextual actions.
//
// !An example GtkActionBar (action-bar.png)
//
// It is expected to be displayed below the content and expand horizontally to
// fill the area.
//
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width
// of the box, even if the children at either side take up different amounts of
// space.
//
// # CSS nodes
//
// GtkActionBar has a single CSS node with name actionbar.
type ActionBar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*ActionBar)(nil)
)

func wrapActionBar(obj *coreglib.Object) *ActionBar {
	return &ActionBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalActionBar(p uintptr) (interface{}, error) {
	return wrapActionBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewActionBar creates a new GtkActionBar widget.
//
// The function returns the following values:
//
//   - actionBar: new GtkActionBar.
func NewActionBar() *ActionBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_action_bar_new()

	var _actionBar *ActionBar // out

	_actionBar = wrapActionBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _actionBar
}

// CenterWidget retrieves the center bar widget of the bar.
//
// The function returns the following values:
//
//   - widget (optional): center GtkWidget or NULL.
func (actionBar *ActionBar) CenterWidget() Widgetter {
	var _arg0 *C.GtkActionBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(coreglib.InternObject(actionBar).Native()))

	_cret = C.gtk_action_bar_get_center_widget(_arg0)
	runtime.KeepAlive(actionBar)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Revealed gets whether the contents of the action bar are revealed.
//
// The function returns the following values:
//
//   - ok: current value of the gtk.ActionBar:revealed property.
func (actionBar *ActionBar) Revealed() bool {
	var _arg0 *C.GtkActionBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(coreglib.InternObject(actionBar).Native()))

	_cret = C.gtk_action_bar_get_revealed(_arg0)
	runtime.KeepAlive(actionBar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PackEnd adds child to action_bar, packed with reference to the end of the
// action_bar.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to be added to action_bar.
func (actionBar *ActionBar) PackEnd(child Widgetter) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(coreglib.InternObject(actionBar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_action_bar_pack_end(_arg0, _arg1)
	runtime.KeepAlive(actionBar)
	runtime.KeepAlive(child)
}

// PackStart adds child to action_bar, packed with reference to the start of the
// action_bar.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to be added to action_bar.
func (actionBar *ActionBar) PackStart(child Widgetter) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(coreglib.InternObject(actionBar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_action_bar_pack_start(_arg0, _arg1)
	runtime.KeepAlive(actionBar)
	runtime.KeepAlive(child)
}

// Remove removes a child from action_bar.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to be removed.
func (actionBar *ActionBar) Remove(child Widgetter) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(coreglib.InternObject(actionBar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_action_bar_remove(_arg0, _arg1)
	runtime.KeepAlive(actionBar)
	runtime.KeepAlive(child)
}

// SetCenterWidget sets the center widget for the GtkActionBar.
//
// The function takes the following parameters:
//
//   - centerWidget (optional): widget to use for the center.
func (actionBar *ActionBar) SetCenterWidget(centerWidget Widgetter) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(coreglib.InternObject(actionBar).Native()))
	if centerWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(centerWidget).Native()))
	}

	C.gtk_action_bar_set_center_widget(_arg0, _arg1)
	runtime.KeepAlive(actionBar)
	runtime.KeepAlive(centerWidget)
}

// SetRevealed reveals or conceals the content of the action bar.
//
// Note: this does not show or hide action_bar in the gtk.Widget:visible sense,
// so revealing has no effect if the action bar is hidden.
//
// The function takes the following parameters:
//
//   - revealed: new value of the property.
func (actionBar *ActionBar) SetRevealed(revealed bool) {
	var _arg0 *C.GtkActionBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkActionBar)(unsafe.Pointer(coreglib.InternObject(actionBar).Native()))
	if revealed {
		_arg1 = C.TRUE
	}

	C.gtk_action_bar_set_revealed(_arg0, _arg1)
	runtime.KeepAlive(actionBar)
	runtime.KeepAlive(revealed)
}

// ActivateAction: GtkShortcutAction that calls gtk_widget_activate().
type ActivateAction struct {
	_ [0]func() // equal guard
	ShortcutAction
}

var (
	_ ShortcutActioner = (*ActivateAction)(nil)
)

func wrapActivateAction(obj *coreglib.Object) *ActivateAction {
	return &ActivateAction{
		ShortcutAction: ShortcutAction{
			Object: obj,
		},
	}
}

func marshalActivateAction(p uintptr) (interface{}, error) {
	return wrapActivateAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ActivateActionGet gets the activate action.
//
// This is an action that calls gtk_widget_activate() on the given widget upon
// activation.
//
// The function returns the following values:
//
//   - activateAction: activate action.
func ActivateActionGet() *ActivateAction {
	var _cret *C.GtkShortcutAction // in

	_cret = C.gtk_activate_action_get()

	var _activateAction *ActivateAction // out

	_activateAction = wrapActivateAction(coreglib.Take(unsafe.Pointer(_cret)))

	return _activateAction
}

// AdjustmentOverrides contains methods that are overridable.
type AdjustmentOverrides struct {
	Changed      func()
	ValueChanged func()
}

func defaultAdjustmentOverrides(v *Adjustment) AdjustmentOverrides {
	return AdjustmentOverrides{
		Changed:      v.changed,
		ValueChanged: v.valueChanged,
	}
}

// Adjustment: GtkAdjustment is a model for a numeric value.
//
// The `GtkAdjustment has an associated lower and upper bound. It also contains
// step and page increments, and a page size.
//
// Adjustments are used within several GTK widgets, including gtk.SpinButton,
// gtk.Viewport, gtk.Scrollbar and gtk.Scale.
//
// The GtkAdjustment object does not update the value itself. Instead it is left
// up to the owner of the GtkAdjustment to control the value.
type Adjustment struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned
}

var ()

func init() {
	coreglib.RegisterClassInfo[*Adjustment, *AdjustmentClass, AdjustmentOverrides](
		GTypeAdjustment,
		initAdjustmentClass,
		wrapAdjustment,
		defaultAdjustmentOverrides,
	)
}

func initAdjustmentClass(gclass unsafe.Pointer, overrides AdjustmentOverrides, classInitFunc func(*AdjustmentClass)) {
	pclass := (*C.GtkAdjustmentClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeAdjustment))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gtk4_AdjustmentClass_changed)
	}

	if overrides.ValueChanged != nil {
		pclass.value_changed = (*[0]byte)(C._gotk4_gtk4_AdjustmentClass_value_changed)
	}

	if classInitFunc != nil {
		class := (*AdjustmentClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapAdjustment(obj *coreglib.Object) *Adjustment {
	return &Adjustment{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalAdjustment(p uintptr) (interface{}, error) {
	return wrapAdjustment(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when one or more of the GtkAdjustment properties
// have been changed.
//
// Note that the gtk.Adjustment:value property is covered by the
// gtk.Adjustment::value-changed signal.
func (adjustment *Adjustment) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adjustment, "changed", false, unsafe.Pointer(C._gotk4_gtk4_Adjustment_ConnectChanged), f)
}

// ConnectValueChanged is emitted when the value has been changed.
func (adjustment *Adjustment) ConnectValueChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(adjustment, "value-changed", false, unsafe.Pointer(C._gotk4_gtk4_Adjustment_ConnectValueChanged), f)
}

// NewAdjustment creates a new GtkAdjustment.
//
// The function takes the following parameters:
//
//   - value: initial value.
//   - lower: minimum value.
//   - upper: maximum value.
//   - stepIncrement: step increment.
//   - pageIncrement: page increment.
//   - pageSize: page size.
//
// The function returns the following values:
//
//   - adjustment: new GtkAdjustment.
func NewAdjustment(value, lower, upper, stepIncrement, pageIncrement, pageSize float64) *Adjustment {
	var _arg1 C.double         // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out
	var _arg5 C.double         // out
	var _arg6 C.double         // out
	var _cret *C.GtkAdjustment // in

	_arg1 = C.double(value)
	_arg2 = C.double(lower)
	_arg3 = C.double(upper)
	_arg4 = C.double(stepIncrement)
	_arg5 = C.double(pageIncrement)
	_arg6 = C.double(pageSize)

	_cret = C.gtk_adjustment_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(value)
	runtime.KeepAlive(lower)
	runtime.KeepAlive(upper)
	runtime.KeepAlive(stepIncrement)
	runtime.KeepAlive(pageIncrement)
	runtime.KeepAlive(pageSize)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// ClampPage updates the value property to ensure that the range between lower
// and upper is in the current page.
//
// The current page goes from value to value + page-size. If the range is larger
// than the page size, then only the start of it will be in the current page.
//
// A gtk.Adjustment::value-changed signal will be emitted if the value is
// changed.
//
// The function takes the following parameters:
//
//   - lower value.
//   - upper value.
func (adjustment *Adjustment) ClampPage(lower, upper float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(lower)
	_arg2 = C.double(upper)

	C.gtk_adjustment_clamp_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(lower)
	runtime.KeepAlive(upper)
}

// Configure sets all properties of the adjustment at once.
//
// Use this function to avoid multiple emissions of the gtk.Adjustment::changed
// signal. See gtk.Adjustment.SetLower() for an alternative way of compressing
// multiple emissions of gtk.Adjustment::changed into one.
//
// The function takes the following parameters:
//
//   - value: new value.
//   - lower: new minimum value.
//   - upper: new maximum value.
//   - stepIncrement: new step increment.
//   - pageIncrement: new page increment.
//   - pageSize: new page size.
func (adjustment *Adjustment) Configure(value, lower, upper, stepIncrement, pageIncrement, pageSize float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out
	var _arg5 C.double         // out
	var _arg6 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(value)
	_arg2 = C.double(lower)
	_arg3 = C.double(upper)
	_arg4 = C.double(stepIncrement)
	_arg5 = C.double(pageIncrement)
	_arg6 = C.double(pageSize)

	C.gtk_adjustment_configure(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(value)
	runtime.KeepAlive(lower)
	runtime.KeepAlive(upper)
	runtime.KeepAlive(stepIncrement)
	runtime.KeepAlive(pageIncrement)
	runtime.KeepAlive(pageSize)
}

// Lower retrieves the minimum value of the adjustment.
//
// The function returns the following values:
//
//   - gdouble: current minimum value of the adjustment.
func (adjustment *Adjustment) Lower() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_cret = C.gtk_adjustment_get_lower(_arg0)
	runtime.KeepAlive(adjustment)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// MinimumIncrement gets the smaller of step increment and page increment.
//
// The function returns the following values:
//
//   - gdouble: minimum increment of adjustment.
func (adjustment *Adjustment) MinimumIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_cret = C.gtk_adjustment_get_minimum_increment(_arg0)
	runtime.KeepAlive(adjustment)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PageIncrement retrieves the page increment of the adjustment.
//
// The function returns the following values:
//
//   - gdouble: current page increment of the adjustment.
func (adjustment *Adjustment) PageIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_cret = C.gtk_adjustment_get_page_increment(_arg0)
	runtime.KeepAlive(adjustment)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PageSize retrieves the page size of the adjustment.
//
// The function returns the following values:
//
//   - gdouble: current page size of the adjustment.
func (adjustment *Adjustment) PageSize() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_cret = C.gtk_adjustment_get_page_size(_arg0)
	runtime.KeepAlive(adjustment)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// StepIncrement retrieves the step increment of the adjustment.
//
// The function returns the following values:
//
//   - gdouble: current step increment of the adjustment.
func (adjustment *Adjustment) StepIncrement() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_cret = C.gtk_adjustment_get_step_increment(_arg0)
	runtime.KeepAlive(adjustment)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Upper retrieves the maximum value of the adjustment.
//
// The function returns the following values:
//
//   - gdouble: current maximum value of the adjustment.
func (adjustment *Adjustment) Upper() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_cret = C.gtk_adjustment_get_upper(_arg0)
	runtime.KeepAlive(adjustment)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Value gets the current value of the adjustment.
//
// The function returns the following values:
//
//   - gdouble: current value of the adjustment.
func (adjustment *Adjustment) Value() float64 {
	var _arg0 *C.GtkAdjustment // out
	var _cret C.double         // in

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	_cret = C.gtk_adjustment_get_value(_arg0)
	runtime.KeepAlive(adjustment)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SetLower sets the minimum value of the adjustment.
//
// When setting multiple adjustment properties via their individual setters,
// multiple gtk.Adjustment::changed signals will be emitted. However, since the
// emission of the gtk.Adjustment::changed signal is tied to the emission of
// the ::notify signals of the changed properties, it’s possible to compress the
// gtk.Adjustment::changed signals into one by calling g_object_freeze_notify()
// and g_object_thaw_notify() around the calls to the individual setters.
//
// Alternatively, using a single g_object_set() for all the properties to
// change, or using gtk.Adjustment.Configure() has the same effect.
//
// The function takes the following parameters:
//
//   - lower: new minimum value.
func (adjustment *Adjustment) SetLower(lower float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(lower)

	C.gtk_adjustment_set_lower(_arg0, _arg1)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(lower)
}

// SetPageIncrement sets the page increment of the adjustment.
//
// See gtk.Adjustment.SetLower() about how to compress multiple emissions of the
// gtk.Adjustment::changed signal when setting multiple adjustment properties.
//
// The function takes the following parameters:
//
//   - pageIncrement: new page increment.
func (adjustment *Adjustment) SetPageIncrement(pageIncrement float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(pageIncrement)

	C.gtk_adjustment_set_page_increment(_arg0, _arg1)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(pageIncrement)
}

// SetPageSize sets the page size of the adjustment.
//
// See gtk.Adjustment.SetLower() about how to compress multiple emissions of the
// gtk.Adjustment::changed signal when setting multiple adjustment properties.
//
// The function takes the following parameters:
//
//   - pageSize: new page size.
func (adjustment *Adjustment) SetPageSize(pageSize float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(pageSize)

	C.gtk_adjustment_set_page_size(_arg0, _arg1)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(pageSize)
}

// SetStepIncrement sets the step increment of the adjustment.
//
// See gtk.Adjustment.SetLower() about how to compress multiple emissions of the
// gtk.Adjustment::changed signal when setting multiple adjustment properties.
//
// The function takes the following parameters:
//
//   - stepIncrement: new step increment.
func (adjustment *Adjustment) SetStepIncrement(stepIncrement float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(stepIncrement)

	C.gtk_adjustment_set_step_increment(_arg0, _arg1)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(stepIncrement)
}

// SetUpper sets the maximum value of the adjustment.
//
// Note that values will be restricted by upper - page-size if the page-size
// property is nonzero.
//
// See gtk.Adjustment.SetLower() about how to compress multiple emissions of the
// gtk.Adjustment::changed signal when setting multiple adjustment properties.
//
// The function takes the following parameters:
//
//   - upper: new maximum value.
func (adjustment *Adjustment) SetUpper(upper float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(upper)

	C.gtk_adjustment_set_upper(_arg0, _arg1)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(upper)
}

// SetValue sets the GtkAdjustment value.
//
// The value is clamped to lie between gtk.Adjustment:lower and
// gtk.Adjustment:upper.
//
// Note that for adjustments which are used in a GtkScrollbar,
// the effective range of allowed values goes from gtk.Adjustment:lower to
// gtk.Adjustment:upper - gtk.Adjustment:page-size.
//
// The function takes the following parameters:
//
//   - value: new value.
func (adjustment *Adjustment) SetValue(value float64) {
	var _arg0 *C.GtkAdjustment // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	_arg1 = C.double(value)

	C.gtk_adjustment_set_value(_arg0, _arg1)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(value)
}

func (adjustment *Adjustment) changed() {
	gclass := (*C.GtkAdjustmentClass)(coreglib.PeekParentClass(adjustment))
	fnarg := gclass.changed

	var _arg0 *C.GtkAdjustment // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	C._gotk4_gtk4_Adjustment_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(adjustment)
}

func (adjustment *Adjustment) valueChanged() {
	gclass := (*C.GtkAdjustmentClass)(coreglib.PeekParentClass(adjustment))
	fnarg := gclass.value_changed

	var _arg0 *C.GtkAdjustment // out

	_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	C._gotk4_gtk4_Adjustment_virtual_value_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(adjustment)
}

// AlternativeTrigger: GtkShortcutTrigger that combines two triggers.
//
// The GtkAlternativeTrigger triggers when either of two trigger.
//
// This can be cascaded to combine more than two triggers.
type AlternativeTrigger struct {
	_ [0]func() // equal guard
	ShortcutTrigger
}

var (
	_ ShortcutTriggerer = (*AlternativeTrigger)(nil)
)

func wrapAlternativeTrigger(obj *coreglib.Object) *AlternativeTrigger {
	return &AlternativeTrigger{
		ShortcutTrigger: ShortcutTrigger{
			Object: obj,
		},
	}
}

func marshalAlternativeTrigger(p uintptr) (interface{}, error) {
	return wrapAlternativeTrigger(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAlternativeTrigger creates a GtkShortcutTrigger that will trigger whenever
// either of the two given triggers gets triggered.
//
// Note that nesting is allowed, so if you want more than two alternative,
// create a new alternative trigger for each option.
//
// The function takes the following parameters:
//
//   - first trigger that may trigger.
//   - second trigger that may trigger.
//
// The function returns the following values:
//
//   - alternativeTrigger: new GtkShortcutTrigger.
func NewAlternativeTrigger(first, second ShortcutTriggerer) *AlternativeTrigger {
	var _arg1 *C.GtkShortcutTrigger // out
	var _arg2 *C.GtkShortcutTrigger // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(coreglib.InternObject(first).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(first).Native()))
	_arg2 = (*C.GtkShortcutTrigger)(unsafe.Pointer(coreglib.InternObject(second).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(second).Native()))

	_cret = C.gtk_alternative_trigger_new(_arg1, _arg2)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)

	var _alternativeTrigger *AlternativeTrigger // out

	_alternativeTrigger = wrapAlternativeTrigger(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _alternativeTrigger
}

// First gets the first of the two alternative triggers that may trigger self.
//
// gtk.AlternativeTrigger.GetSecond() will return the other one.
//
// The function returns the following values:
//
//   - shortcutTrigger: first alternative trigger.
func (self *AlternativeTrigger) First() ShortcutTriggerer {
	var _arg0 *C.GtkAlternativeTrigger // out
	var _cret *C.GtkShortcutTrigger    // in

	_arg0 = (*C.GtkAlternativeTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_alternative_trigger_get_first(_arg0)
	runtime.KeepAlive(self)

	var _shortcutTrigger ShortcutTriggerer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.ShortcutTriggerer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(ShortcutTriggerer)
			return ok
		})
		rv, ok := casted.(ShortcutTriggerer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.ShortcutTriggerer")
		}
		_shortcutTrigger = rv
	}

	return _shortcutTrigger
}

// Second gets the second of the two alternative triggers that may trigger self.
//
// gtk.AlternativeTrigger.GetFirst() will return the other one.
//
// The function returns the following values:
//
//   - shortcutTrigger: second alternative trigger.
func (self *AlternativeTrigger) Second() ShortcutTriggerer {
	var _arg0 *C.GtkAlternativeTrigger // out
	var _cret *C.GtkShortcutTrigger    // in

	_arg0 = (*C.GtkAlternativeTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_alternative_trigger_get_second(_arg0)
	runtime.KeepAlive(self)

	var _shortcutTrigger ShortcutTriggerer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.ShortcutTriggerer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(ShortcutTriggerer)
			return ok
		})
		rv, ok := casted.(ShortcutTriggerer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.ShortcutTriggerer")
		}
		_shortcutTrigger = rv
	}

	return _shortcutTrigger
}

// AnyFilter: GtkAnyFilter matches an item when at least one of its filters
// matches.
//
// To add filters to a GtkAnyFilter, use gtk.MultiFilter.Append().
type AnyFilter struct {
	_ [0]func() // equal guard
	MultiFilter
}

var (
	_ MultiFilterer = (*AnyFilter)(nil)
)

func wrapAnyFilter(obj *coreglib.Object) *AnyFilter {
	return &AnyFilter{
		MultiFilter: MultiFilter{
			Filter: Filter{
				Object: obj,
			},
			Object: obj,
			ListModel: gio.ListModel{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
	}
}

func marshalAnyFilter(p uintptr) (interface{}, error) {
	return wrapAnyFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAnyFilter creates a new empty "any" filter.
//
// Use gtk.MultiFilter.Append() to add filters to it.
//
// This filter matches an item if any of the filters added to it matches the
// item. In particular, this means that if no filter has been added to it,
// the filter matches no item.
//
// The function returns the following values:
//
//   - anyFilter: new GtkAnyFilter.
func NewAnyFilter() *AnyFilter {
	var _cret *C.GtkAnyFilter // in

	_cret = C.gtk_any_filter_new()

	var _anyFilter *AnyFilter // out

	_anyFilter = wrapAnyFilter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _anyFilter
}

// AppChooserButton: GtkAppChooserButton lets the user select an application.
//
// !An example GtkAppChooserButton (appchooserbutton.png)
//
// Initially, a GtkAppChooserButton selects the first application in its
// list, which will either be the most-recently used application or,
// if gtk.AppChooserButton:show-default-item is TRUE, the default application.
//
// The list of applications shown in a GtkAppChooserButton includes
// the recommended applications for the given content type. When
// gtk.AppChooserButton:show-default-item is set, the default application is
// also included. To let the user chooser other applications, you can set the
// gtk.AppChooserButton:show-dialog-item property, which allows to open a full
// gtk.AppChooserDialog.
//
// It is possible to add custom items to the list, using
// gtk.AppChooserButton.AppendCustomItem(). These items cause the
// gtk.AppChooserButton::custom-item-activated signal to be emitted when they
// are selected.
//
// To track changes in the selected application, use the
// gtk.AppChooserButton::changed signal.
//
// # CSS nodes
//
// GtkAppChooserButton has a single CSS node with the name “appchooserbutton”.
type AppChooserButton struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	AppChooser
}

var (
	_ Widgetter         = (*AppChooserButton)(nil)
	_ coreglib.Objector = (*AppChooserButton)(nil)
)

func wrapAppChooserButton(obj *coreglib.Object) *AppChooserButton {
	return &AppChooserButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		AppChooser: AppChooser{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalAppChooserButton(p uintptr) (interface{}, error) {
	return wrapAppChooserButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the active application changes.
func (self *AppChooserButton) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "changed", false, unsafe.Pointer(C._gotk4_gtk4_AppChooserButton_ConnectChanged), f)
}

// ConnectCustomItemActivated is emitted when a custom item is activated.
//
// Use gtk.AppChooserButton.AppendCustomItem(), to add custom items.
func (self *AppChooserButton) ConnectCustomItemActivated(f func(itemName string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "custom-item-activated", false, unsafe.Pointer(C._gotk4_gtk4_AppChooserButton_ConnectCustomItemActivated), f)
}

// NewAppChooserButton creates a new GtkAppChooserButton for applications that
// can handle content of the given type.
//
// The function takes the following parameters:
//
//   - contentType: content type to show applications for.
//
// The function returns the following values:
//
//   - appChooserButton: newly created GtkAppChooserButton.
func NewAppChooserButton(contentType string) *AppChooserButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_app_chooser_button_new(_arg1)
	runtime.KeepAlive(contentType)

	var _appChooserButton *AppChooserButton // out

	_appChooserButton = wrapAppChooserButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _appChooserButton
}

// AppendCustomItem appends a custom item to the list of applications that is
// shown in the popup.
//
// The item name must be unique per-widget. Clients can use the provided name
// as a detail for the gtk.AppChooserButton::custom-item-activated signal,
// to add a callback for the activation of a particular custom item in the list.
//
// See also gtk.AppChooserButton.AppendSeparator().
//
// The function takes the following parameters:
//
//   - name of the custom item.
//   - label for the custom item.
//   - icon for the custom item.
func (self *AppChooserButton) AppendCustomItem(name, label string, icon gio.Iconner) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.char                // out
	var _arg2 *C.char                // out
	var _arg3 *C.GIcon               // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.gtk_app_chooser_button_append_custom_item(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
	runtime.KeepAlive(label)
	runtime.KeepAlive(icon)
}

// AppendSeparator appends a separator to the list of applications that is shown
// in the popup.
func (self *AppChooserButton) AppendSeparator() {
	var _arg0 *C.GtkAppChooserButton // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_app_chooser_button_append_separator(_arg0)
	runtime.KeepAlive(self)
}

// Heading returns the text to display at the top of the dialog.
//
// The function returns the following values:
//
//   - utf8 (optional): text to display at the top of the dialog, or NULL,
//     in which case a default text is displayed.
func (self *AppChooserButton) Heading() string {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_button_get_heading(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Modal gets whether the dialog is modal.
//
// The function returns the following values:
//
//   - ok: TRUE if the dialog is modal.
func (self *AppChooserButton) Modal() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_button_get_modal(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowDefaultItem returns whether the dropdown menu should show the default
// application at the top.
//
// The function returns the following values:
//
//   - ok: value of gtk.AppChooserButton:show-default-item.
func (self *AppChooserButton) ShowDefaultItem() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_button_get_show_default_item(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowDialogItem returns whether the dropdown menu shows an item for a
// GtkAppChooserDialog.
//
// The function returns the following values:
//
//   - ok: value of gtk.AppChooserButton:show-dialog-item.
func (self *AppChooserButton) ShowDialogItem() bool {
	var _arg0 *C.GtkAppChooserButton // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_button_get_show_dialog_item(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActiveCustomItem selects a custom item.
//
// See gtk.AppChooserButton.AppendCustomItem().
//
// Use gtk.AppChooser.Refresh() to bring the selection to its initial state.
//
// The function takes the following parameters:
//
//   - name of the custom item.
func (self *AppChooserButton) SetActiveCustomItem(name string) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_active_custom_item(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
}

// SetHeading sets the text to display at the top of the dialog.
//
// If the heading is not set, the dialog displays a default text.
//
// The function takes the following parameters:
//
//   - heading: string containing Pango markup.
func (self *AppChooserButton) SetHeading(heading string) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(heading)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_button_set_heading(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(heading)
}

// SetModal sets whether the dialog should be modal.
//
// The function takes the following parameters:
//
//   - modal: TRUE to make the dialog modal.
func (self *AppChooserButton) SetModal(modal bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_modal(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(modal)
}

// SetShowDefaultItem sets whether the dropdown menu of this button should show
// the default application for the given content type at top.
//
// The function takes the following parameters:
//
//   - setting: new value for gtk.AppChooserButton:show-default-item.
func (self *AppChooserButton) SetShowDefaultItem(setting bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_show_default_item(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetShowDialogItem sets whether the dropdown menu of this button should show
// an entry to trigger a GtkAppChooserDialog.
//
// The function takes the following parameters:
//
//   - setting: new value for gtk.AppChooserButton:show-dialog-item.
func (self *AppChooserButton) SetShowDialogItem(setting bool) {
	var _arg0 *C.GtkAppChooserButton // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_button_set_show_dialog_item(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// AppChooserDialog: GtkAppChooserDialog shows a GtkAppChooserWidget inside a
// GtkDialog.
//
// !An example GtkAppChooserDialog (appchooserdialog.png)
//
// Note that GtkAppChooserDialog does not have any interesting methods of
// its own. Instead, you should get the embedded GtkAppChooserWidget using
// gtk.AppChooserDialog.GetWidget() and call its methods if the generic
// gtk.AppChooser interface is not sufficient for your needs.
//
// To set the heading that is shown above the GtkAppChooserWidget, use
// gtk.AppChooserDialog.SetHeading().
type AppChooserDialog struct {
	_ [0]func() // equal guard
	Dialog

	*coreglib.Object
	AppChooser
}

var (
	_ coreglib.Objector = (*AppChooserDialog)(nil)
	_ Widgetter         = (*AppChooserDialog)(nil)
)

func wrapAppChooserDialog(obj *coreglib.Object) *AppChooserDialog {
	return &AppChooserDialog{
		Dialog: Dialog{
			Window: Window{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
				Object: obj,
				Root: Root{
					NativeSurface: NativeSurface{
						Widget: Widget{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
							Object: obj,
							Accessible: Accessible{
								Object: obj,
							},
							Buildable: Buildable{
								Object: obj,
							},
							ConstraintTarget: ConstraintTarget{
								Object: obj,
							},
						},
					},
				},
				ShortcutManager: ShortcutManager{
					Object: obj,
				},
			},
		},
		Object: obj,
		AppChooser: AppChooser{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalAppChooserDialog(p uintptr) (interface{}, error) {
	return wrapAppChooserDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAppChooserDialog creates a new GtkAppChooserDialog for the provided GFile.
//
// The dialog will show applications that can open the file.
//
// The function takes the following parameters:
//
//   - parent (optional): GtkWindow, or NULL.
//   - flags for this dialog.
//   - file: GFile.
//
// The function returns the following values:
//
//   - appChooserDialog: newly created GtkAppChooserDialog.
func NewAppChooserDialog(parent *Window, flags DialogFlags, file gio.Filer) *AppChooserDialog {
	var _arg1 *C.GtkWindow     // out
	var _arg2 C.GtkDialogFlags // out
	var _arg3 *C.GFile         // out
	var _cret *C.GtkWidget     // in

	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = C.GtkDialogFlags(flags)
	_arg3 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.gtk_app_chooser_dialog_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(file)

	var _appChooserDialog *AppChooserDialog // out

	_appChooserDialog = wrapAppChooserDialog(coreglib.Take(unsafe.Pointer(_cret)))

	return _appChooserDialog
}

// NewAppChooserDialogForContentType creates a new GtkAppChooserDialog for the
// provided content type.
//
// The dialog will show applications that can open the content type.
//
// The function takes the following parameters:
//
//   - parent (optional): GtkWindow, or NULL.
//   - flags for this dialog.
//   - contentType: content type string.
//
// The function returns the following values:
//
//   - appChooserDialog: newly created GtkAppChooserDialog.
func NewAppChooserDialogForContentType(parent *Window, flags DialogFlags, contentType string) *AppChooserDialog {
	var _arg1 *C.GtkWindow     // out
	var _arg2 C.GtkDialogFlags // out
	var _arg3 *C.char          // out
	var _cret *C.GtkWidget     // in

	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg2 = C.GtkDialogFlags(flags)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_app_chooser_dialog_new_for_content_type(_arg1, _arg2, _arg3)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(contentType)

	var _appChooserDialog *AppChooserDialog // out

	_appChooserDialog = wrapAppChooserDialog(coreglib.Take(unsafe.Pointer(_cret)))

	return _appChooserDialog
}

// Heading returns the text to display at the top of the dialog.
//
// The function returns the following values:
//
//   - utf8 (optional): text to display at the top of the dialog, or NULL,
//     in which case a default text is displayed.
func (self *AppChooserDialog) Heading() string {
	var _arg0 *C.GtkAppChooserDialog // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_dialog_get_heading(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Widget returns the GtkAppChooserWidget of this dialog.
//
// The function returns the following values:
//
//   - widget: GtkAppChooserWidget of self.
func (self *AppChooserDialog) Widget() Widgetter {
	var _arg0 *C.GtkAppChooserDialog // out
	var _cret *C.GtkWidget           // in

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_dialog_get_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// SetHeading sets the text to display at the top of the dialog.
//
// If the heading is not set, the dialog displays a default text.
//
// The function takes the following parameters:
//
//   - heading: string containing Pango markup.
func (self *AppChooserDialog) SetHeading(heading string) {
	var _arg0 *C.GtkAppChooserDialog // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(heading)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_dialog_set_heading(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(heading)
}

// AppChooserWidget: GtkAppChooserWidget is a widget for selecting applications.
//
// It is the main building block for gtk.AppChooserDialog. Most applications
// only need to use the latter; but you can use this widget as part of a larger
// widget if you have special needs.
//
// GtkAppChooserWidget offers detailed control over what applications
// are shown, using the gtk.AppChooserWidget:show-default,
// gtk.AppChooserWidget:show-recommended, gtk.AppChooserWidget:show-fallback,
// gtk.AppChooserWidget:show-other and gtk.AppChooserWidget:show-all properties.
// See the gtk.AppChooser documentation for more information about these groups
// of applications.
//
// To keep track of the selected application, use the
// gtk.AppChooserWidget::application-selected and
// gtk.AppChooserWidget::application-activated signals.
//
// # CSS nodes
//
// GtkAppChooserWidget has a single CSS node with name appchooser.
type AppChooserWidget struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	AppChooser
}

var (
	_ Widgetter         = (*AppChooserWidget)(nil)
	_ coreglib.Objector = (*AppChooserWidget)(nil)
)

func wrapAppChooserWidget(obj *coreglib.Object) *AppChooserWidget {
	return &AppChooserWidget{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		AppChooser: AppChooser{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalAppChooserWidget(p uintptr) (interface{}, error) {
	return wrapAppChooserWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectApplicationActivated is emitted when an application item is activated
// from the widget's list.
//
// This usually happens when the user double clicks an item, or an item is
// selected and the user presses one of the keys Space, Shift+Space, Return or
// Enter.
func (self *AppChooserWidget) ConnectApplicationActivated(f func(application gio.AppInfor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "application-activated", false, unsafe.Pointer(C._gotk4_gtk4_AppChooserWidget_ConnectApplicationActivated), f)
}

// ConnectApplicationSelected is emitted when an application item is selected
// from the widget's list.
func (self *AppChooserWidget) ConnectApplicationSelected(f func(application gio.AppInfor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "application-selected", false, unsafe.Pointer(C._gotk4_gtk4_AppChooserWidget_ConnectApplicationSelected), f)
}

// NewAppChooserWidget creates a new GtkAppChooserWidget for applications that
// can handle content of the given type.
//
// The function takes the following parameters:
//
//   - contentType: content type to show applications for.
//
// The function returns the following values:
//
//   - appChooserWidget: newly created GtkAppChooserWidget.
func NewAppChooserWidget(contentType string) *AppChooserWidget {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contentType)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_app_chooser_widget_new(_arg1)
	runtime.KeepAlive(contentType)

	var _appChooserWidget *AppChooserWidget // out

	_appChooserWidget = wrapAppChooserWidget(coreglib.Take(unsafe.Pointer(_cret)))

	return _appChooserWidget
}

// DefaultText returns the text that is shown if there are not applications that
// can handle the content type.
//
// The function returns the following values:
//
//   - utf8 (optional): value of gtk.AppChooserWidget:default-text.
func (self *AppChooserWidget) DefaultText() string {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_widget_get_default_text(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ShowAll gets whether the app chooser should show all applications in a flat
// list.
//
// The function returns the following values:
//
//   - ok: value of gtk.AppChooserWidget:show-all.
func (self *AppChooserWidget) ShowAll() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_widget_get_show_all(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowDefault gets whether the app chooser should show the default handler for
// the content type in a separate section.
//
// The function returns the following values:
//
//   - ok: value of gtk.AppChooserWidget:show-default.
func (self *AppChooserWidget) ShowDefault() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_widget_get_show_default(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowFallback gets whether the app chooser should show related applications
// for the content type in a separate section.
//
// The function returns the following values:
//
//   - ok: value of gtk.AppChooserWidget:show-fallback.
func (self *AppChooserWidget) ShowFallback() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_widget_get_show_fallback(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowOther gets whether the app chooser should show applications which are
// unrelated to the content type.
//
// The function returns the following values:
//
//   - ok: value of gtk.AppChooserWidget:show-other.
func (self *AppChooserWidget) ShowOther() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_widget_get_show_other(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowRecommended gets whether the app chooser should show recommended
// applications for the content type in a separate section.
//
// The function returns the following values:
//
//   - ok: value of gtk.AppChooserWidget:show-recommended.
func (self *AppChooserWidget) ShowRecommended() bool {
	var _arg0 *C.GtkAppChooserWidget // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_app_chooser_widget_get_show_recommended(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDefaultText sets the text that is shown if there are not applications that
// can handle the content type.
//
// The function takes the following parameters:
//
//   - text: new value for gtk.AppChooserWidget:default-text.
func (self *AppChooserWidget) SetDefaultText(text string) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_app_chooser_widget_set_default_text(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(text)
}

// SetShowAll sets whether the app chooser should show all applications in a
// flat list.
//
// The function takes the following parameters:
//
//   - setting: new value for gtk.AppChooserWidget:show-all.
func (self *AppChooserWidget) SetShowAll(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_all(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetShowDefault sets whether the app chooser should show the default handler
// for the content type in a separate section.
//
// The function takes the following parameters:
//
//   - setting: new value for gtk.AppChooserWidget:show-default.
func (self *AppChooserWidget) SetShowDefault(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_default(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetShowFallback sets whether the app chooser should show related applications
// for the content type in a separate section.
//
// The function takes the following parameters:
//
//   - setting: new value for gtk.AppChooserWidget:show-fallback.
func (self *AppChooserWidget) SetShowFallback(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_fallback(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetShowOther sets whether the app chooser should show applications which are
// unrelated to the content type.
//
// The function takes the following parameters:
//
//   - setting: new value for gtk.AppChooserWidget:show-other.
func (self *AppChooserWidget) SetShowOther(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_other(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetShowRecommended sets whether the app chooser should show recommended
// applications for the content type in a separate section.
//
// The function takes the following parameters:
//
//   - setting: new value for gtk.AppChooserWidget:show-recommended.
func (self *AppChooserWidget) SetShowRecommended(setting bool) {
	var _arg0 *C.GtkAppChooserWidget // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_app_chooser_widget_set_show_recommended(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// ApplicationOverrides contains methods that are overridable.
type ApplicationOverrides struct {
	WindowAdded   func(window *Window)
	WindowRemoved func(window *Window)
}

func defaultApplicationOverrides(v *Application) ApplicationOverrides {
	return ApplicationOverrides{
		WindowAdded:   v.windowAdded,
		WindowRemoved: v.windowRemoved,
	}
}

// Application: GtkApplication is a high-level API for writing applications.
//
// It supports many aspects of writing a GTK application in a convenient
// fashion, without enforcing a one-size-fits-all model.
//
// Currently, GtkApplication handles GTK initialization, application uniqueness,
// session management, provides some basic scriptability and desktop shell
// integration by exporting actions and menus and manages a list of toplevel
// windows whose life-cycle is automatically tied to the life-cycle of your
// application.
//
// While GtkApplication works fine with plain gtk.Windows, it is recommended to
// use it together with gtk.ApplicationWindow.
//
// # Automatic resources
//
// GtkApplication will automatically load menus from the GtkBuilder resource
// located at "gtk/menus.ui", relative to the application's resource base path
// (see g_application_set_resource_base_path()). The menu with the ID "menubar"
// is taken as the application's menubar. Additional menus (most interesting
// submenus) can be named and accessed via gtk.Application.GetMenuByID() which
// allows for dynamic population of a part of the menu structure.
//
// It is also possible to provide the menubar manually using
// gtk.Application.SetMenubar().
//
// GtkApplication will also automatically setup an icon search path for
// the default icon theme by appending "icons" to the resource base path.
// This allows your application to easily store its icons as resources.
// See gtk.IconTheme.AddResourcePath() for more information.
//
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// gtk.ShortcutsWindow with ID "help_overlay" then GtkApplication associates
// an instance of this shortcuts window with each gtk.ApplicationWindow and
// sets up the keyboard accelerator <kbd>Control</kbd>+<kbd>?</kbd> to open it.
// To create a menu item that displays the shortcuts window, associate the item
// with the action win.show-help-overlay.
//
// # A simple application
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/bp/bloatpad.c) is
// available in the GTK source code repository
//
// GtkApplication optionally registers with a session manager of the users
// session (if you set the gtk.Application:register-session property) and offers
// various functionality related to the session life-cycle.
//
// An application can block various ways to end the session with the
// gtk.Application.Inhibit() function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
//
// # See Also
//
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK: Basics (getting_started.html#basics).
type Application struct {
	_ [0]func() // equal guard
	gio.Application
}

var (
	_ coreglib.Objector = (*Application)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Application, *ApplicationClass, ApplicationOverrides](
		GTypeApplication,
		initApplicationClass,
		wrapApplication,
		defaultApplicationOverrides,
	)
}

func initApplicationClass(gclass unsafe.Pointer, overrides ApplicationOverrides, classInitFunc func(*ApplicationClass)) {
	pclass := (*C.GtkApplicationClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeApplication))))

	if overrides.WindowAdded != nil {
		pclass.window_added = (*[0]byte)(C._gotk4_gtk4_ApplicationClass_window_added)
	}

	if overrides.WindowRemoved != nil {
		pclass.window_removed = (*[0]byte)(C._gotk4_gtk4_ApplicationClass_window_removed)
	}

	if classInitFunc != nil {
		class := (*ApplicationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplication(obj *coreglib.Object) *Application {
	return &Application{
		Application: gio.Application{
			Object: obj,
			ActionGroup: gio.ActionGroup{
				Object: obj,
			},
			ActionMap: gio.ActionMap{
				Object: obj,
			},
		},
	}
}

func marshalApplication(p uintptr) (interface{}, error) {
	return wrapApplication(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectQueryEnd is emitted when the session manager is about to end the
// session.
//
// This signal is only emitted if gtk.Application:register-session is TRUE.
// Applications can connect to this signal and call gtk.Application.Inhibit()
// with GTK_APPLICATION_INHIBIT_LOGOUT to delay the end of the session until
// state has been saved.
func (application *Application) ConnectQueryEnd(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "query-end", false, unsafe.Pointer(C._gotk4_gtk4_Application_ConnectQueryEnd), f)
}

// ConnectWindowAdded is emitted when a gtk.Window is added to application
// through gtk.Application.AddWindow().
func (application *Application) ConnectWindowAdded(f func(window *Window)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "window-added", false, unsafe.Pointer(C._gotk4_gtk4_Application_ConnectWindowAdded), f)
}

// ConnectWindowRemoved is emitted when a gtk.Window is removed from
// application.
//
// This can happen as a side-effect of the window being destroyed or explicitly
// through gtk.Application.RemoveWindow().
func (application *Application) ConnectWindowRemoved(f func(window *Window)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(application, "window-removed", false, unsafe.Pointer(C._gotk4_gtk4_Application_ConnectWindowRemoved), f)
}

// NewApplication creates a new GtkApplication instance.
//
// When using GtkApplication, it is not necessary to call gtk.Init() manually.
// It is called as soon as the application gets registered as the primary
// instance.
//
// Concretely, gtk.Init() is called in the default handler for the
// GApplication::startup signal. Therefore, GtkApplication subclasses should
// always chain up in their GApplication::startup handler before using any GTK
// API.
//
// Note that commandline arguments are not passed to gtk.Init().
//
// If application_id is not NULL, then it must be valid. See
// g_application_id_is_valid().
//
// If no application ID is given then some features (most notably application
// uniqueness) will be disabled.
//
// The function takes the following parameters:
//
//   - applicationId (optional): application ID.
//   - flags: application flags.
//
// The function returns the following values:
//
//   - application: new GtkApplication instance.
func NewApplication(applicationId string, flags gio.ApplicationFlags) *Application {
	var _arg1 *C.char             // out
	var _arg2 C.GApplicationFlags // out
	var _cret *C.GtkApplication   // in

	if applicationId != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(applicationId)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.GApplicationFlags(flags)

	_cret = C.gtk_application_new(_arg1, _arg2)
	runtime.KeepAlive(applicationId)
	runtime.KeepAlive(flags)

	var _application *Application // out

	_application = wrapApplication(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _application
}

// AddWindow adds a window to application.
//
// This call can only happen after the application has started; typically,
// you should add new application windows in response to the emission of the
// GApplication::activate signal.
//
// This call is equivalent to setting the gtk.Window:application property of
// window to application.
//
// Normally, the connection between the application and the window will
// remain until the window is destroyed, but you can explicitly remove it with
// gtk.Application.RemoveWindow().
//
// GTK will keep the application running as long as it has any windows.
//
// The function takes the following parameters:
//
//   - window: GtkWindow.
func (application *Application) AddWindow(window *Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_application_add_window(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

// AccelsForAction gets the accelerators that are currently associated with the
// given action.
//
// The function takes the following parameters:
//
//   - detailedActionName: detailed action name, specifying an action and target
//     to obtain accelerators for.
//
// The function returns the following values:
//
//   - utf8s: accelerators for detailed_action_name.
func (application *Application) AccelsForAction(detailedActionName string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _cret **C.char          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(detailedActionName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_accels_for_action(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(detailedActionName)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ActionsForAccel returns the list of actions (possibly empty) that accel maps
// to.
//
// Each item in the list is a detailed action name in the usual form.
//
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator editor
// or a plugin system, for example). Note that having more than one action per
// accelerator may not be a bad thing and might make sense in cases where the
// actions never appear in the same context.
//
// In case there are no actions for a given accelerator, an empty array is
// returned. NULL is never returned.
//
// It is a programmer error to pass an invalid accelerator string.
//
// If you are unsure, check it with gtk.AcceleratorParse() first.
//
// The function takes the following parameters:
//
//   - accel: accelerator that can be parsed by gtk.AcceleratorParse().
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated array of actions for accel.
func (application *Application) ActionsForAccel(accel string) []string {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _cret **C.char          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(accel)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_actions_for_accel(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(accel)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// ActiveWindow gets the “active” window for the application.
//
// The active window is the one that was most recently focused (within the
// application). This window may not have the focus at the moment if another
// application has it — this is just the most recently-focused window within
// this application.
//
// The function returns the following values:
//
//   - window (optional): active window.
func (application *Application) ActiveWindow() *Window {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_get_active_window(_arg0)
	runtime.KeepAlive(application)

	var _window *Window // out

	if _cret != nil {
		_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _window
}

// MenuByID gets a menu from automatically loaded resources.
//
// See the section on Automatic resources
// (class.Application.html#automatic-resources) for more information.
//
// The function takes the following parameters:
//
//   - id of the menu to look up.
//
// The function returns the following values:
//
//   - menu (optional) gets the menu with the given id from the automatically
//     loaded resources.
func (application *Application) MenuByID(id string) *gio.Menu {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _cret *C.GMenu          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_application_get_menu_by_id(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)

	var _menu *gio.Menu // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_menu = &gio.Menu{
				MenuModel: gio.MenuModel{
					Object: obj,
				},
			}
		}
	}

	return _menu
}

// Menubar returns the menu model that has been set with
// gtk.Application.SetMenubar().
//
// The function returns the following values:
//
//   - menuModel (optional): menubar for windows of application.
func (application *Application) Menubar() gio.MenuModeller {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_get_menubar(_arg0)
	runtime.KeepAlive(application)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// WindowByID returns the gtk.ApplicationWindow with the given ID.
//
// The ID of a GtkApplicationWindow can be retrieved with
// gtk.ApplicationWindow.GetID().
//
// The function takes the following parameters:
//
//   - id: identifier number.
//
// The function returns the following values:
//
//   - window (optional) for the given id.
func (application *Application) WindowByID(id uint) *Window {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out
	var _cret *C.GtkWindow      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.guint(id)

	_cret = C.gtk_application_get_window_by_id(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(id)

	var _window *Window // out

	if _cret != nil {
		_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _window
}

// Windows gets a list of the gtk.Window instances associated with application.
//
// The list is sorted by most recently focused window, such that the first
// element is the currently focused window. (Useful for choosing a parent for a
// transient window.)
//
// The list that is returned should not be modified in any way. It will only
// remain valid until the next focus change or window creation or deletion.
//
// The function returns the following values:
//
//   - list: GList of GtkWindow instances.
func (application *Application) Windows() []*Window {
	var _arg0 *C.GtkApplication // out
	var _cret *C.GList          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_get_windows(_arg0)
	runtime.KeepAlive(application)

	var _list []*Window // out

	_list = make([]*Window, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkWindow)(v)
		var dst *Window // out
		dst = wrapWindow(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Inhibit: inform the session manager that certain types of actions should be
// inhibited.
//
// This is not guaranteed to work on all platforms and for all types of actions.
//
// Applications should invoke this method when they begin an operation
// that should not be interrupted, such as creating a CD or DVD.
// The types of actions that may be blocked are specified by the flags
// parameter. When the application completes the operation it should call
// gtk.Application.Uninhibit() to remove the inhibitor. Note that an application
// can have multiple inhibitors, and all of them must be individually removed.
// Inhibitors are also cleared when the application exits.
//
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action to
// take place.
//
// The reason message should be short and to the point.
//
// If window is given, the session manager may point the user to this window to
// find out more about why the action is inhibited.
//
// The function takes the following parameters:
//
//   - window (optional): GtkWindow.
//   - flags: what types of actions should be inhibited.
//   - reason (optional): short, human-readable string that explains why these
//     operations are inhibited.
//
// The function returns the following values:
//
//   - guint: non-zero cookie that is used to uniquely identify this request.
//     It should be used as an argument to gtk.Application.Uninhibit() in order
//     to remove the request. If the platform does not support inhibiting or the
//     request failed for some reason, 0 is returned.
func (application *Application) Inhibit(window *Window, flags ApplicationInhibitFlags, reason string) uint {
	var _arg0 *C.GtkApplication            // out
	var _arg1 *C.GtkWindow                 // out
	var _arg2 C.GtkApplicationInhibitFlags // out
	var _arg3 *C.char                      // out
	var _cret C.guint                      // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if window != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	}
	_arg2 = C.GtkApplicationInhibitFlags(flags)
	if reason != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(reason)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	_cret = C.gtk_application_inhibit(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(reason)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ListActionDescriptions lists the detailed action names which have associated
// accelerators.
//
// See gtk.Application.SetAccelsForAction().
//
// The function returns the following values:
//
//   - utf8s: detailed action names.
func (application *Application) ListActionDescriptions() []string {
	var _arg0 *C.GtkApplication // out
	var _cret **C.char          // in

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_list_action_descriptions(_arg0)
	runtime.KeepAlive(application)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// RemoveWindow: remove a window from application.
//
// If window belongs to application then this call is equivalent to setting the
// gtk.Window:application property of window to NULL.
//
// The application may stop running as a result of a call to this function,
// if window was the last window of the application.
//
// The function takes the following parameters:
//
//   - window: GtkWindow.
func (application *Application) RemoveWindow(window *Window) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_application_remove_window(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

// SetAccelsForAction sets zero or more keyboard accelerators that will trigger
// the given action.
//
// The first item in accels will be the primary accelerator, which may be
// displayed in the UI.
//
// To remove all accelerators for an action, use an empty, zero-terminated array
// for accels.
//
// For the detailed_action_name, see g_action_parse_detailed_name() and
// g_action_print_detailed_name().
//
// The function takes the following parameters:
//
//   - detailedActionName: detailed action name, specifying an action and target
//     to associate accelerators with.
//   - accels: list of accelerators in the format understood by
//     gtk.AcceleratorParse().
func (application *Application) SetAccelsForAction(detailedActionName string, accels []string) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.char           // out
	var _arg2 **C.char          // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(detailedActionName)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(accels) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(accels)+1)
			var zero *C.char
			out[len(accels)] = zero
			for i := range accels {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(accels[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_application_set_accels_for_action(_arg0, _arg1, _arg2)
	runtime.KeepAlive(application)
	runtime.KeepAlive(detailedActionName)
	runtime.KeepAlive(accels)
}

// SetMenubar sets or unsets the menubar for windows of application.
//
// This is a menubar in the traditional sense.
//
// This can only be done in the primary instance of the application, after it
// has been registered. GApplication::startup is a good place to call this.
//
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate — for example, the application menu may
// be rendered by the desktop shell while the menubar (if set) remains in each
// individual window.
//
// Use the base GActionMap interface to add actions, to respond to the user
// selecting these menu items.
//
// The function takes the following parameters:
//
//   - menubar (optional): GMenuModel.
func (application *Application) SetMenubar(menubar gio.MenuModeller) {
	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	if menubar != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(menubar).Native()))
	}

	C.gtk_application_set_menubar(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(menubar)
}

// Uninhibit removes an inhibitor that has been previously established.
//
// See gtk.Application.Inhibit().
//
// Inhibitors are also cleared when the application exits.
//
// The function takes the following parameters:
//
//   - cookie that was returned by gtk.Application.Inhibit().
func (application *Application) Uninhibit(cookie uint) {
	var _arg0 *C.GtkApplication // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = C.guint(cookie)

	C.gtk_application_uninhibit(_arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(cookie)
}

func (application *Application) windowAdded(window *Window) {
	gclass := (*C.GtkApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.window_added

	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gtk4_Application_virtual_window_added(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

func (application *Application) windowRemoved(window *Window) {
	gclass := (*C.GtkApplicationClass)(coreglib.PeekParentClass(application))
	fnarg := gclass.window_removed

	var _arg0 *C.GtkApplication // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gtk4_Application_virtual_window_removed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(application)
	runtime.KeepAlive(window)
}

// ApplicationWindowOverrides contains methods that are overridable.
type ApplicationWindowOverrides struct {
}

func defaultApplicationWindowOverrides(v *ApplicationWindow) ApplicationWindowOverrides {
	return ApplicationWindowOverrides{}
}

// ApplicationWindow: GtkApplicationWindow is a GtkWindow subclass that
// integrates with GtkApplication.
//
// Notably, GtkApplicationWindow can handle an application menubar.
//
// This class implements the GActionGroup and GActionMap interfaces, to let
// you add window-specific actions that will be exported by the associated
// gtk.Application, together with its application-wide actions. Window-specific
// actions are prefixed with the “win.” prefix and application-wide actions are
// prefixed with the “app.” prefix. Actions must be addressed with the prefixed
// name when referring to them from a GMenuModel.
//
// Note that widgets that are placed inside a GtkApplicationWindow can also
// activate these actions, if they implement the gtk.Actionable interface.
//
// The settings gtk.Settings:gtk-shell-shows-app-menu and
// gtk.Settings:gtk-shell-shows-menubar tell GTK whether the desktop environment
// is showing the application menu and menubar models outside the application
// as part of the desktop shell. For instance, on OS X, both menus will be
// displayed remotely; on Windows neither will be.
//
// If the desktop environment does not display the menubar, then
// GtkApplicationWindow will automatically show a menubar for it. This behaviour
// can be overridden with the gtk.ApplicationWindow:show-menubar property.
// If the desktop environment does not display the application menu, then it
// will automatically be included in the menubar or in the windows client-side
// decorations.
//
// See gtk.PopoverMenu for information about the XML language used by GtkBuilder
// for menu models.
//
// See also: gtk.Application.SetMenubar().
//
// # A GtkApplicationWindow with a menubar
//
// The code sample below shows how to set up a GtkApplicationWindow with a menu
// bar defined on the gtk.Application:
//
//	GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
//
//	GtkBuilder *builder = gtk_builder_new_from_string (
//	    "<interface>"
//	    "  <menu id='menubar'>"
//	    "    <submenu>"
//	    "      <attribute name='label' translatable='yes'>_Edit</attribute>"
//	    "      <item>"
//	    "        <attribute name='label' translatable='yes'>_Copy</attribute>"
//	    "        <attribute name='action'>win.copy</attribute>"
//	    "      </item>"
//	    "      <item>"
//	    "        <attribute name='label' translatable='yes'>_Paste</attribute>"
//	    "        <attribute name='action'>win.paste</attribute>"
//	    "      </item>"
//	    "    </submenu>"
//	    "  </menu>"
//	    "</interface>",
//	    -1);
//
//	GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder, "menubar"));
//	gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
//	g_object_unref (builder);
//
//	// ...
//
//	GtkWidget *window = gtk_application_window_new (app);.
type ApplicationWindow struct {
	_ [0]func() // equal guard
	Window

	*coreglib.Object
	gio.ActionGroup
	gio.ActionMap
}

var (
	_ coreglib.Objector = (*ApplicationWindow)(nil)
	_ Widgetter         = (*ApplicationWindow)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ApplicationWindow, *ApplicationWindowClass, ApplicationWindowOverrides](
		GTypeApplicationWindow,
		initApplicationWindowClass,
		wrapApplicationWindow,
		defaultApplicationWindowOverrides,
	)
}

func initApplicationWindowClass(gclass unsafe.Pointer, overrides ApplicationWindowOverrides, classInitFunc func(*ApplicationWindowClass)) {
	if classInitFunc != nil {
		class := (*ApplicationWindowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapApplicationWindow(obj *coreglib.Object) *ApplicationWindow {
	return &ApplicationWindow{
		Window: Window{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Root: Root{
				NativeSurface: NativeSurface{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						Accessible: Accessible{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
						ConstraintTarget: ConstraintTarget{
							Object: obj,
						},
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
		Object: obj,
		ActionGroup: gio.ActionGroup{
			Object: obj,
		},
		ActionMap: gio.ActionMap{
			Object: obj,
		},
	}
}

func marshalApplicationWindow(p uintptr) (interface{}, error) {
	return wrapApplicationWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewApplicationWindow creates a new GtkApplicationWindow.
//
// The function takes the following parameters:
//
//   - application: GtkApplication.
//
// The function returns the following values:
//
//   - applicationWindow: newly created GtkApplicationWindow.
func NewApplicationWindow(application *Application) *ApplicationWindow {
	var _arg1 *C.GtkApplication // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))

	_cret = C.gtk_application_window_new(_arg1)
	runtime.KeepAlive(application)

	var _applicationWindow *ApplicationWindow // out

	_applicationWindow = wrapApplicationWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _applicationWindow
}

// HelpOverlay gets the GtkShortcutsWindow that is associated with window.
//
// See gtk.ApplicationWindow.SetHelpOverlay().
//
// The function returns the following values:
//
//   - shortcutsWindow (optional): help overlay associated with window, or NULL.
func (window *ApplicationWindow) HelpOverlay() *ShortcutsWindow {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret *C.GtkShortcutsWindow   // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_application_window_get_help_overlay(_arg0)
	runtime.KeepAlive(window)

	var _shortcutsWindow *ShortcutsWindow // out

	if _cret != nil {
		_shortcutsWindow = wrapShortcutsWindow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _shortcutsWindow
}

// ID returns the unique ID of the window.
//
//	If the window has not yet been added to a GtkApplication, returns 0.
//
// The function returns the following values:
//
//   - guint: unique ID for window, or 0 if the window has not yet been added to
//     a GtkApplication.
func (window *ApplicationWindow) ID() uint {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.guint                 // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_application_window_get_id(_arg0)
	runtime.KeepAlive(window)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ShowMenubar returns whether the window will display a menubar for the app
// menu and menubar as needed.
//
// The function returns the following values:
//
//   - ok: TRUE if window will display a menubar when needed.
func (window *ApplicationWindow) ShowMenubar() bool {
	var _arg0 *C.GtkApplicationWindow // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_application_window_get_show_menubar(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetHelpOverlay associates a shortcuts window with the application window.
//
// Additionally, sets up an action with the name win.show-help-overlay to
// present it.
//
// window takes responsibility for destroying help_overlay.
//
// The function takes the following parameters:
//
//   - helpOverlay (optional): GtkShortcutsWindow.
func (window *ApplicationWindow) SetHelpOverlay(helpOverlay *ShortcutsWindow) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 *C.GtkShortcutsWindow   // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if helpOverlay != nil {
		_arg1 = (*C.GtkShortcutsWindow)(unsafe.Pointer(coreglib.InternObject(helpOverlay).Native()))
	}

	C.gtk_application_window_set_help_overlay(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(helpOverlay)
}

// SetShowMenubar sets whether the window will display a menubar for the app
// menu and menubar as needed.
//
// The function takes the following parameters:
//
//   - showMenubar: whether to show a menubar when needed.
func (window *ApplicationWindow) SetShowMenubar(showMenubar bool) {
	var _arg0 *C.GtkApplicationWindow // out
	var _arg1 C.gboolean              // out

	_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if showMenubar {
		_arg1 = C.TRUE
	}

	C.gtk_application_window_set_show_menubar(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(showMenubar)
}

// AspectFrame: GtkAspectFrame preserves the aspect ratio of its child.
//
// The frame can respect the aspect ratio of the child widget, or use its own
// aspect ratio.
//
// # CSS nodes
//
// GtkAspectFrame uses a CSS node with name frame.
type AspectFrame struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*AspectFrame)(nil)
)

func wrapAspectFrame(obj *coreglib.Object) *AspectFrame {
	return &AspectFrame{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalAspectFrame(p uintptr) (interface{}, error) {
	return wrapAspectFrame(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewAspectFrame: create a new GtkAspectFrame.
//
// The function takes the following parameters:
//
//   - xalign: horizontal alignment of the child within the parent. Ranges from
//     0.0 (left aligned) to 1.0 (right aligned).
//   - yalign: vertical alignment of the child within the parent. Ranges from
//     0.0 (top aligned) to 1.0 (bottom aligned).
//   - ratio: desired aspect ratio.
//   - obeyChild: if TRUE, ratio is ignored, and the aspect ratio is taken from
//     the requistion of the child.
//
// The function returns the following values:
//
//   - aspectFrame: new GtkAspectFrame.
func NewAspectFrame(xalign, yalign, ratio float32, obeyChild bool) *AspectFrame {
	var _arg1 C.float      // out
	var _arg2 C.float      // out
	var _arg3 C.float      // out
	var _arg4 C.gboolean   // out
	var _cret *C.GtkWidget // in

	_arg1 = C.float(xalign)
	_arg2 = C.float(yalign)
	_arg3 = C.float(ratio)
	if obeyChild {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_aspect_frame_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
	runtime.KeepAlive(ratio)
	runtime.KeepAlive(obeyChild)

	var _aspectFrame *AspectFrame // out

	_aspectFrame = wrapAspectFrame(coreglib.Take(unsafe.Pointer(_cret)))

	return _aspectFrame
}

// Child gets the child widget of self.
//
// The function returns the following values:
//
//   - widget (optional): child widget of self@.
func (self *AspectFrame) Child() Widgetter {
	var _arg0 *C.GtkAspectFrame // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_aspect_frame_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ObeyChild returns whether the child's size request should override the set
// aspect ratio of the GtkAspectFrame.
//
// The function returns the following values:
//
//   - ok: whether to obey the child's size request.
func (self *AspectFrame) ObeyChild() bool {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_aspect_frame_get_obey_child(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ratio returns the desired aspect ratio of the child.
//
// The function returns the following values:
//
//   - gfloat: desired aspect ratio.
func (self *AspectFrame) Ratio() float32 {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.float           // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_aspect_frame_get_ratio(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// XAlign returns the horizontal alignment of the child within the allocation of
// the GtkAspectFrame.
//
// The function returns the following values:
//
//   - gfloat: horizontal alignment.
func (self *AspectFrame) XAlign() float32 {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.float           // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_aspect_frame_get_xalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// YAlign returns the vertical alignment of the child within the allocation of
// the GtkAspectFrame.
//
// The function returns the following values:
//
//   - gfloat: vertical alignment.
func (self *AspectFrame) YAlign() float32 {
	var _arg0 *C.GtkAspectFrame // out
	var _cret C.float           // in

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_aspect_frame_get_yalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// SetChild sets the child widget of self.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (self *AspectFrame) SetChild(child Widgetter) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_aspect_frame_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// SetObeyChild sets whether the aspect ratio of the child's size request should
// override the set aspect ratio of the GtkAspectFrame.
//
// The function takes the following parameters:
//
//   - obeyChild: if TRUE, ratio is ignored, and the aspect ratio is taken from
//     the requistion of the child.
func (self *AspectFrame) SetObeyChild(obeyChild bool) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if obeyChild {
		_arg1 = C.TRUE
	}

	C.gtk_aspect_frame_set_obey_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(obeyChild)
}

// SetRatio sets the desired aspect ratio of the child.
//
// The function takes the following parameters:
//
//   - ratio: aspect ratio of the child.
func (self *AspectFrame) SetRatio(ratio float32) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.float           // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(ratio)

	C.gtk_aspect_frame_set_ratio(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ratio)
}

// SetXAlign sets the horizontal alignment of the child within the allocation of
// the GtkAspectFrame.
//
// The function takes the following parameters:
//
//   - xalign: horizontal alignment, from 0.0 (left aligned) to 1.0 (right
//     aligned).
func (self *AspectFrame) SetXAlign(xalign float32) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.float           // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(xalign)

	C.gtk_aspect_frame_set_xalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(xalign)
}

// SetYAlign sets the vertical alignment of the child within the allocation of
// the GtkAspectFrame.
//
// The function takes the following parameters:
//
//   - yalign: horizontal alignment, from 0.0 (top aligned) to 1.0 (bottom
//     aligned).
func (self *AspectFrame) SetYAlign(yalign float32) {
	var _arg0 *C.GtkAspectFrame // out
	var _arg1 C.float           // out

	_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(yalign)

	C.gtk_aspect_frame_set_yalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(yalign)
}

// Assistant: GtkAssistant is used to represent a complex as a series of steps.
//
// !An example GtkAssistant (assistant.png)
//
// Each step consists of one or more pages. GtkAssistant guides the user through
// the pages, and controls the page flow to collect the data needed for the
// operation.
//
// GtkAssistant handles which buttons to show and to make sensitive based
// on page sequence knowledge and the gtk.AssistantPageType of each page in
// addition to state information like the *completed* and *committed* page
// statuses.
//
// If you have a case that doesn’t quite fit in GtkAssistants way of handling
// buttons, you can use the GTK_ASSISTANT_PAGE_CUSTOM page type and handle
// buttons yourself.
//
// GtkAssistant maintains a GtkAssistantPage object for each added child,
// which holds additional per-child properties. You obtain the GtkAssistantPage
// for a child with gtk.Assistant.GetPage().
//
// # GtkAssistant as GtkBuildable
//
// The GtkAssistant implementation of the GtkBuildable interface exposes the
// action_area as internal children with the name “action_area”.
//
// To add pages to an assistant in GtkBuilder, simply add it as a child to
// the GtkAssistant object. If you need to set per-object properties, create a
// GtkAssistantPage object explicitly, and set the child widget as a property on
// it.
//
// # CSS nodes
//
// GtkAssistant has a single CSS node with the name window and style class
// .assistant.
type Assistant struct {
	_ [0]func() // equal guard
	Window
}

var (
	_ Widgetter         = (*Assistant)(nil)
	_ coreglib.Objector = (*Assistant)(nil)
)

func wrapAssistant(obj *coreglib.Object) *Assistant {
	return &Assistant{
		Window: Window{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Root: Root{
				NativeSurface: NativeSurface{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						Accessible: Accessible{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
						ConstraintTarget: ConstraintTarget{
							Object: obj,
						},
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
	}
}

func marshalAssistant(p uintptr) (interface{}, error) {
	return wrapAssistant(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectApply is emitted when the apply button is clicked.
//
// The default behavior of the GtkAssistant is to switch to the page after the
// current page, unless the current page is the last one.
//
// A handler for the ::apply signal should carry out the actions for which the
// wizard has collected data. If the action takes a long time to complete, you
// might consider putting a page of type GTK_ASSISTANT_PAGE_PROGRESS after the
// confirmation page and handle this operation within the gtk.Assistant::prepare
// signal of the progress page.
func (assistant *Assistant) ConnectApply(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(assistant, "apply", false, unsafe.Pointer(C._gotk4_gtk4_Assistant_ConnectApply), f)
}

// ConnectCancel is emitted when then the cancel button is clicked.
func (assistant *Assistant) ConnectCancel(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(assistant, "cancel", false, unsafe.Pointer(C._gotk4_gtk4_Assistant_ConnectCancel), f)
}

// ConnectClose is emitted either when the close button of a summary page is
// clicked, or when the apply button in the last page in the flow (of type
// GTK_ASSISTANT_PAGE_CONFIRM) is clicked.
func (assistant *Assistant) ConnectClose(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(assistant, "close", false, unsafe.Pointer(C._gotk4_gtk4_Assistant_ConnectClose), f)
}

// ConnectEscape: action signal for the Escape binding.
func (assistant *Assistant) ConnectEscape(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(assistant, "escape", false, unsafe.Pointer(C._gotk4_gtk4_Assistant_ConnectEscape), f)
}

// ConnectPrepare is emitted when a new page is set as the assistant's current
// page, before making the new page visible.
//
// A handler for this signal can do any preparations which are necessary before
// showing page.
func (assistant *Assistant) ConnectPrepare(f func(page Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(assistant, "prepare", false, unsafe.Pointer(C._gotk4_gtk4_Assistant_ConnectPrepare), f)
}

// NewAssistant creates a new GtkAssistant.
//
// The function returns the following values:
//
//   - assistant: newly created GtkAssistant.
func NewAssistant() *Assistant {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_assistant_new()

	var _assistant *Assistant // out

	_assistant = wrapAssistant(coreglib.Take(unsafe.Pointer(_cret)))

	return _assistant
}

// AddActionWidget adds a widget to the action area of a GtkAssistant.
//
// The function takes the following parameters:
//
//   - child: GtkWidget.
func (assistant *Assistant) AddActionWidget(child Widgetter) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_assistant_add_action_widget(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(child)
}

// AppendPage appends a page to the assistant.
//
// The function takes the following parameters:
//
//   - page: GtkWidget.
//
// The function returns the following values:
//
//   - gint: index (starting at 0) of the inserted page.
func (assistant *Assistant) AppendPage(page Widgetter) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.gtk_assistant_append_page(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Commit erases the visited page history.
//
// GTK will then hide the back button on the current page, and removes the
// cancel button from subsequent pages.
//
// Use this when the information provided up to the current page is hereafter
// deemed permanent and cannot be modified or undone. For example, showing a
// progress page to track a long-running, unreversible operation after the user
// has clicked apply on a confirmation page.
func (assistant *Assistant) Commit() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))

	C.gtk_assistant_commit(_arg0)
	runtime.KeepAlive(assistant)
}

// CurrentPage returns the page number of the current page.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the current page in the assistant,
//     or -1 if the assistant has no pages, or no current page.
func (assistant *Assistant) CurrentPage() int {
	var _arg0 *C.GtkAssistant // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))

	_cret = C.gtk_assistant_get_current_page(_arg0)
	runtime.KeepAlive(assistant)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NPages returns the number of pages in the assistant.
//
// The function returns the following values:
//
//   - gint: number of pages in the assistant.
func (assistant *Assistant) NPages() int {
	var _arg0 *C.GtkAssistant // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))

	_cret = C.gtk_assistant_get_n_pages(_arg0)
	runtime.KeepAlive(assistant)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthPage returns the child widget contained in page number page_num.
//
// The function takes the following parameters:
//
//   - pageNum: index of a page in the assistant, or -1 to get the last page.
//
// The function returns the following values:
//
//   - widget (optional): child widget, or NULL if page_num is out of bounds.
func (assistant *Assistant) NthPage(pageNum int) Widgetter {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.int           // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = C.int(pageNum)

	_cret = C.gtk_assistant_get_nth_page(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(pageNum)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Page returns the GtkAssistantPage object for child.
//
// The function takes the following parameters:
//
//   - child of assistant.
//
// The function returns the following values:
//
//   - assistantPage: GtkAssistantPage for child.
func (assistant *Assistant) Page(child Widgetter) *AssistantPage {
	var _arg0 *C.GtkAssistant     // out
	var _arg1 *C.GtkWidget        // out
	var _cret *C.GtkAssistantPage // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_assistant_get_page(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(child)

	var _assistantPage *AssistantPage // out

	_assistantPage = wrapAssistantPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _assistantPage
}

// PageComplete gets whether page is complete.
//
// The function takes the following parameters:
//
//   - page of assistant.
//
// The function returns the following values:
//
//   - ok: TRUE if page is complete.
func (assistant *Assistant) PageComplete(page Widgetter) bool {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.gtk_assistant_get_page_complete(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PageTitle gets the title for page.
//
// The function takes the following parameters:
//
//   - page of assistant.
//
// The function returns the following values:
//
//   - utf8: title for page.
func (assistant *Assistant) PageTitle(page Widgetter) string {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.gtk_assistant_get_page_title(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PageType gets the page type of page.
//
// The function takes the following parameters:
//
//   - page of assistant.
//
// The function returns the following values:
//
//   - assistantPageType: page type of page.
func (assistant *Assistant) PageType(page Widgetter) AssistantPageType {
	var _arg0 *C.GtkAssistant        // out
	var _arg1 *C.GtkWidget           // out
	var _cret C.GtkAssistantPageType // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.gtk_assistant_get_page_type(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)

	var _assistantPageType AssistantPageType // out

	_assistantPageType = AssistantPageType(_cret)

	return _assistantPageType
}

// Pages gets a list model of the assistant pages.
//
// The function returns the following values:
//
//   - listModel: list model of the pages.
func (assistant *Assistant) Pages() *gio.ListModel {
	var _arg0 *C.GtkAssistant // out
	var _cret *C.GListModel   // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))

	_cret = C.gtk_assistant_get_pages(_arg0)
	runtime.KeepAlive(assistant)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// InsertPage inserts a page in the assistant at a given position.
//
// The function takes the following parameters:
//
//   - page: GtkWidget.
//   - position: index (starting at 0) at which to insert the page, or -1 to
//     append the page to the assistant.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the inserted page.
func (assistant *Assistant) InsertPage(page Widgetter, position int) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.int           // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	_arg2 = C.int(position)

	_cret = C.gtk_assistant_insert_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NextPage: navigate to the next page.
//
// It is a programming error to call this function when there is no next page.
//
// This function is for use when creating pages of the GTK_ASSISTANT_PAGE_CUSTOM
// type.
func (assistant *Assistant) NextPage() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))

	C.gtk_assistant_next_page(_arg0)
	runtime.KeepAlive(assistant)
}

// PrependPage prepends a page to the assistant.
//
// The function takes the following parameters:
//
//   - page: GtkWidget.
//
// The function returns the following values:
//
//   - gint: index (starting at 0) of the inserted page.
func (assistant *Assistant) PrependPage(page Widgetter) int {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _cret C.int           // in

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.gtk_assistant_prepend_page(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PreviousPage: navigate to the previous visited page.
//
// It is a programming error to call this function when no previous page is
// available.
//
// This function is for use when creating pages of the GTK_ASSISTANT_PAGE_CUSTOM
// type.
func (assistant *Assistant) PreviousPage() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))

	C.gtk_assistant_previous_page(_arg0)
	runtime.KeepAlive(assistant)
}

// RemoveActionWidget removes a widget from the action area of a GtkAssistant.
//
// The function takes the following parameters:
//
//   - child: GtkWidget.
func (assistant *Assistant) RemoveActionWidget(child Widgetter) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_assistant_remove_action_widget(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(child)
}

// RemovePage removes the page_num’s page from assistant.
//
// The function takes the following parameters:
//
//   - pageNum: index of a page in the assistant, or -1 to remove the last page.
func (assistant *Assistant) RemovePage(pageNum int) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.int           // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = C.int(pageNum)

	C.gtk_assistant_remove_page(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(pageNum)
}

// SetCurrentPage switches the page to page_num.
//
// Note that this will only be necessary in custom buttons, as the assistant
// flow can be set with gtk_assistant_set_forward_page_func().
//
// The function takes the following parameters:
//
//   - pageNum: index of the page to switch to, starting from 0. If negative,
//     the last page will be used. If greater than the number of pages in the
//     assistant, nothing will be done.
func (assistant *Assistant) SetCurrentPage(pageNum int) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 C.int           // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = C.int(pageNum)

	C.gtk_assistant_set_current_page(_arg0, _arg1)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(pageNum)
}

// SetForwardPageFunc sets the page forwarding function to be page_func.
//
// This function will be used to determine what will be the next page when the
// user presses the forward button. Setting page_func to NULL will make the
// assistant to use the default forward function, which just goes to the next
// visible page.
//
// The function takes the following parameters:
//
//   - pageFunc (optional): GtkAssistantPageFunc, or NULL to use the default
//     one.
func (assistant *Assistant) SetForwardPageFunc(pageFunc AssistantPageFunc) {
	var _arg0 *C.GtkAssistant        // out
	var _arg1 C.GtkAssistantPageFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	if pageFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_AssistantPageFunc)
		_arg2 = C.gpointer(gbox.Assign(pageFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_assistant_set_forward_page_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(pageFunc)
}

// SetPageComplete sets whether page contents are complete.
//
// This will make assistant update the buttons state to be able to continue the
// task.
//
// The function takes the following parameters:
//
//   - page of assistant.
//   - complete completeness status of the page.
func (assistant *Assistant) SetPageComplete(page Widgetter, complete bool) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	if complete {
		_arg2 = C.TRUE
	}

	C.gtk_assistant_set_page_complete(_arg0, _arg1, _arg2)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)
	runtime.KeepAlive(complete)
}

// SetPageTitle sets a title for page.
//
// The title is displayed in the header area of the assistant when page is the
// current page.
//
// The function takes the following parameters:
//
//   - page of assistant.
//   - title: new title for page.
func (assistant *Assistant) SetPageTitle(page Widgetter, title string) {
	var _arg0 *C.GtkAssistant // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.char         // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_assistant_set_page_title(_arg0, _arg1, _arg2)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)
	runtime.KeepAlive(title)
}

// SetPageType sets the page type for page.
//
// The page type determines the page behavior in the assistant.
//
// The function takes the following parameters:
//
//   - page of assistant.
//   - typ: new type for page.
func (assistant *Assistant) SetPageType(page Widgetter, typ AssistantPageType) {
	var _arg0 *C.GtkAssistant        // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkAssistantPageType // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(page).Native()))
	_arg2 = C.GtkAssistantPageType(typ)

	C.gtk_assistant_set_page_type(_arg0, _arg1, _arg2)
	runtime.KeepAlive(assistant)
	runtime.KeepAlive(page)
	runtime.KeepAlive(typ)
}

// UpdateButtonsState forces assistant to recompute the buttons state.
//
// GTK automatically takes care of this in most situations, e.g. when the user
// goes to a different page, or when the visibility or completeness of a page
// changes.
//
// One situation where it can be necessary to call this function is when
// changing a value on the current page affects the future page flow of the
// assistant.
func (assistant *Assistant) UpdateButtonsState() {
	var _arg0 *C.GtkAssistant // out

	_arg0 = (*C.GtkAssistant)(unsafe.Pointer(coreglib.InternObject(assistant).Native()))

	C.gtk_assistant_update_buttons_state(_arg0)
	runtime.KeepAlive(assistant)
}

// AssistantPage: GtkAssistantPage is an auxiliary object used by `GtkAssistant.
type AssistantPage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*AssistantPage)(nil)
)

func wrapAssistantPage(obj *coreglib.Object) *AssistantPage {
	return &AssistantPage{
		Object: obj,
	}
}

func marshalAssistantPage(p uintptr) (interface{}, error) {
	return wrapAssistantPage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Child returns the child to which page belongs.
//
// The function returns the following values:
//
//   - widget: child to which page belongs.
func (page *AssistantPage) Child() Widgetter {
	var _arg0 *C.GtkAssistantPage // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkAssistantPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.gtk_assistant_page_get_child(_arg0)
	runtime.KeepAlive(page)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// BinLayoutOverrides contains methods that are overridable.
type BinLayoutOverrides struct {
}

func defaultBinLayoutOverrides(v *BinLayout) BinLayoutOverrides {
	return BinLayoutOverrides{}
}

// BinLayout: GtkBinLayout is a GtkLayoutManager subclass useful for create
// "bins" of widgets.
//
// GtkBinLayout will stack each child of a widget on top of each other,
// using the gtk.Widget:hexpand, gtk.Widget:vexpand, gtk.Widget:halign,
// and gtk.Widget:valign properties of each child to determine where they should
// be positioned.
type BinLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*BinLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BinLayout, *BinLayoutClass, BinLayoutOverrides](
		GTypeBinLayout,
		initBinLayoutClass,
		wrapBinLayout,
		defaultBinLayoutOverrides,
	)
}

func initBinLayoutClass(gclass unsafe.Pointer, overrides BinLayoutOverrides, classInitFunc func(*BinLayoutClass)) {
	if classInitFunc != nil {
		class := (*BinLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBinLayout(obj *coreglib.Object) *BinLayout {
	return &BinLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalBinLayout(p uintptr) (interface{}, error) {
	return wrapBinLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBinLayout creates a new GtkBinLayout instance.
//
// The function returns the following values:
//
//   - binLayout: newly created GtkBinLayout.
func NewBinLayout() *BinLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_bin_layout_new()

	var _binLayout *BinLayout // out

	_binLayout = wrapBinLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _binLayout
}

// BookmarkListOverrides contains methods that are overridable.
type BookmarkListOverrides struct {
}

func defaultBookmarkListOverrides(v *BookmarkList) BookmarkListOverrides {
	return BookmarkListOverrides{}
}

// BookmarkList: GtkBookmarkList is a list model that wraps GBookmarkFile.
//
// It presents a GListModel and fills it asynchronously with the GFileInfos
// returned from that function.
//
// The GFileInfos in the list have some attributes in the recent namespace
// added: recent::private (boolean) and recent:applications (stringv).
type BookmarkList struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*BookmarkList)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BookmarkList, *BookmarkListClass, BookmarkListOverrides](
		GTypeBookmarkList,
		initBookmarkListClass,
		wrapBookmarkList,
		defaultBookmarkListOverrides,
	)
}

func initBookmarkListClass(gclass unsafe.Pointer, overrides BookmarkListOverrides, classInitFunc func(*BookmarkListClass)) {
	if classInitFunc != nil {
		class := (*BookmarkListClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBookmarkList(obj *coreglib.Object) *BookmarkList {
	return &BookmarkList{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalBookmarkList(p uintptr) (interface{}, error) {
	return wrapBookmarkList(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBookmarkList creates a new GtkBookmarkList with the given attributes.
//
// The function takes the following parameters:
//
//   - filename (optional): bookmark file to load.
//   - attributes (optional) to query.
//
// The function returns the following values:
//
//   - bookmarkList: new GtkBookmarkList.
func NewBookmarkList(filename, attributes string) *BookmarkList {
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out
	var _cret *C.GtkBookmarkList // in

	if filename != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if attributes != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_bookmark_list_new(_arg1, _arg2)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(attributes)

	var _bookmarkList *BookmarkList // out

	_bookmarkList = wrapBookmarkList(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _bookmarkList
}

// Attributes gets the attributes queried on the children.
//
// The function returns the following values:
//
//   - utf8 (optional): queried attributes.
func (self *BookmarkList) Attributes() string {
	var _arg0 *C.GtkBookmarkList // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_bookmark_list_get_attributes(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Filename returns the filename of the bookmark file that this list is loading.
//
// The function returns the following values:
//
//   - utf8: filename of the .xbel file.
func (self *BookmarkList) Filename() string {
	var _arg0 *C.GtkBookmarkList // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_bookmark_list_get_filename(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IOPriority gets the IO priority to use while loading file.
//
// The function returns the following values:
//
//   - gint: IO priority.
func (self *BookmarkList) IOPriority() int {
	var _arg0 *C.GtkBookmarkList // out
	var _cret C.int              // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_bookmark_list_get_io_priority(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsLoading returns TRUE if the files are currently being loaded.
//
// Files will be added to self from time to time while loading is going on.
// The order in which are added is undefined and may change in between runs.
//
// The function returns the following values:
//
//   - ok: TRUE if self is loading.
func (self *BookmarkList) IsLoading() bool {
	var _arg0 *C.GtkBookmarkList // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_bookmark_list_is_loading(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributes sets the attributes to be enumerated and starts the
// enumeration.
//
// If attributes is NULL, no attributes will be queried, but a list of Infos
// will still be created.
//
// The function takes the following parameters:
//
//   - attributes (optional) to enumerate.
func (self *BookmarkList) SetAttributes(attributes string) {
	var _arg0 *C.GtkBookmarkList // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if attributes != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_bookmark_list_set_attributes(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(attributes)
}

// SetIOPriority sets the IO priority to use while loading files.
//
// The default IO priority is G_PRIORITY_DEFAULT.
//
// The function takes the following parameters:
//
//   - ioPriority: IO priority to use.
func (self *BookmarkList) SetIOPriority(ioPriority int) {
	var _arg0 *C.GtkBookmarkList // out
	var _arg1 C.int              // out

	_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(ioPriority)

	C.gtk_bookmark_list_set_io_priority(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ioPriority)
}

// BoolFilterOverrides contains methods that are overridable.
type BoolFilterOverrides struct {
}

func defaultBoolFilterOverrides(v *BoolFilter) BoolFilterOverrides {
	return BoolFilterOverrides{}
}

// BoolFilter: GtkBoolFilter evaluates a boolean GtkExpression to determine
// whether to include items.
type BoolFilter struct {
	_ [0]func() // equal guard
	Filter
}

var (
	_ coreglib.Objector = (*BoolFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BoolFilter, *BoolFilterClass, BoolFilterOverrides](
		GTypeBoolFilter,
		initBoolFilterClass,
		wrapBoolFilter,
		defaultBoolFilterOverrides,
	)
}

func initBoolFilterClass(gclass unsafe.Pointer, overrides BoolFilterOverrides, classInitFunc func(*BoolFilterClass)) {
	if classInitFunc != nil {
		class := (*BoolFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBoolFilter(obj *coreglib.Object) *BoolFilter {
	return &BoolFilter{
		Filter: Filter{
			Object: obj,
		},
	}
}

func marshalBoolFilter(p uintptr) (interface{}, error) {
	return wrapBoolFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBoolFilter creates a new bool filter.
//
// The function takes the following parameters:
//
//   - expression (optional) to evaluate or NULL for none.
//
// The function returns the following values:
//
//   - boolFilter: new GtkBoolFilter.
func NewBoolFilter(expression Expressioner) *BoolFilter {
	var _arg1 *C.GtkExpression // out
	var _cret *C.GtkBoolFilter // in

	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}

	_cret = C.gtk_bool_filter_new(_arg1)
	runtime.KeepAlive(expression)

	var _boolFilter *BoolFilter // out

	_boolFilter = wrapBoolFilter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _boolFilter
}

// Expression gets the expression that the filter uses to evaluate if an item
// should be filtered.
//
// The function returns the following values:
//
//   - expression (optional): GtkExpression.
func (self *BoolFilter) Expression() Expressioner {
	var _arg0 *C.GtkBoolFilter // out
	var _cret *C.GtkExpression // in

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_bool_filter_get_expression(_arg0)
	runtime.KeepAlive(self)

	var _expression Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// Invert returns whether the filter inverts the expression.
//
// The function returns the following values:
//
//   - ok: TRUE if the filter inverts.
func (self *BoolFilter) Invert() bool {
	var _arg0 *C.GtkBoolFilter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_bool_filter_get_invert(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetExpression sets the expression that the filter uses to check if items
// should be filtered.
//
// The expression must have a value type of G_TYPE_BOOLEAN.
//
// The function takes the following parameters:
//
//   - expression (optional): GtkExpression.
func (self *BoolFilter) SetExpression(expression Expressioner) {
	var _arg0 *C.GtkBoolFilter // out
	var _arg1 *C.GtkExpression // out

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
	}

	C.gtk_bool_filter_set_expression(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expression)
}

// SetInvert sets whether the filter should invert the expression.
//
// The function takes the following parameters:
//
//   - invert: TRUE to invert.
func (self *BoolFilter) SetInvert(invert bool) {
	var _arg0 *C.GtkBoolFilter // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if invert {
		_arg1 = C.TRUE
	}

	C.gtk_bool_filter_set_invert(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(invert)
}

// BoxOverrides contains methods that are overridable.
type BoxOverrides struct {
}

func defaultBoxOverrides(v *Box) BoxOverrides {
	return BoxOverrides{}
}

// Box: GtkBox widget arranges child widgets into a single row or column.
//
// !An example GtkBox (box.png)
//
// Whether it is a row or column depends on the value of its
// gtk.Orientable:orientation property. Within the other dimension, all
// children are allocated the same size. Of course, the gtk.Widget:halign and
// gtk.Widget:valign properties can be used on the children to influence their
// allocation.
//
// Use repeated calls to gtk.Box.Append() to pack widgets into a GtkBox from
// start to end. Use gtk.Box.Remove() to remove widgets from the GtkBox.
// gtk.Box.InsertChildAfter() can be used to add a child at a particular
// position.
//
// Use gtk.Box.SetHomogeneous() to specify whether or not all children of the
// GtkBox are forced to get the same amount of space.
//
// Use gtk.Box.SetSpacing() to determine how much space will be minimally placed
// between all children in the GtkBox. Note that spacing is added *between* the
// children.
//
// Use gtk.Box.ReorderChildAfter() to move a child to a different place in the
// box.
//
// # CSS nodes
//
// GtkBox uses a single CSS node with name box.
//
// # Accessibility
//
// GtkBox uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Box struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*Box)(nil)
	_ coreglib.Objector = (*Box)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Box, *BoxClass, BoxOverrides](
		GTypeBox,
		initBoxClass,
		wrapBox,
		defaultBoxOverrides,
	)
}

func initBoxClass(gclass unsafe.Pointer, overrides BoxOverrides, classInitFunc func(*BoxClass)) {
	if classInitFunc != nil {
		class := (*BoxClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBox(obj *coreglib.Object) *Box {
	return &Box{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalBox(p uintptr) (interface{}, error) {
	return wrapBox(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBox creates a new GtkBox.
//
// The function takes the following parameters:
//
//   - orientation box’s orientation.
//   - spacing: number of pixels to place by default between children.
//
// The function returns the following values:
//
//   - box: new GtkBox.
func NewBox(orientation Orientation, spacing int) *Box {
	var _arg1 C.GtkOrientation // out
	var _arg2 C.int            // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.int(spacing)

	_cret = C.gtk_box_new(_arg1, _arg2)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(spacing)

	var _box *Box // out

	_box = wrapBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _box
}

// Append adds child as the last child to box.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to append.
func (box *Box) Append(child Widgetter) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_box_append(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// BaselinePosition gets the value set by gtk_box_set_baseline_position().
//
// The function returns the following values:
//
//   - baselinePosition: baseline position.
func (box *Box) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkBox             // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_box_get_baseline_position(_arg0)
	runtime.KeepAlive(box)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// Homogeneous returns whether the box is homogeneous (all children are the same
// size).
//
// The function returns the following values:
//
//   - ok: TRUE if the box is homogeneous.
func (box *Box) Homogeneous() bool {
	var _arg0 *C.GtkBox  // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_box_get_homogeneous(_arg0)
	runtime.KeepAlive(box)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Spacing gets the value set by gtk_box_set_spacing().
//
// The function returns the following values:
//
//   - gint: spacing between children.
func (box *Box) Spacing() int {
	var _arg0 *C.GtkBox // out
	var _cret C.int     // in

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_box_get_spacing(_arg0)
	runtime.KeepAlive(box)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InsertChildAfter inserts child in the position after sibling in the list of
// box children.
//
// If sibling is NULL, insert child at the first position.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to insert.
//   - sibling (optional) after which to insert child.
func (box *Box) InsertChildAfter(child, sibling Widgetter) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	}

	C.gtk_box_insert_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// Prepend adds child as the first child to box.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to prepend.
func (box *Box) Prepend(child Widgetter) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_box_prepend(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// Remove removes a child widget from box.
//
// The child must have been added before with gtk.Box.Append(),
// gtk.Box.Prepend(), or gtk.Box.InsertChildAfter().
//
// The function takes the following parameters:
//
//   - child to remove.
func (box *Box) Remove(child Widgetter) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_box_remove(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// ReorderChildAfter moves child to the position after sibling in the list of
// box children.
//
// If sibling is NULL, move child to the first position.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to move, must be a child of box.
//   - sibling (optional) to move child after, or NULL.
func (box *Box) ReorderChildAfter(child, sibling Widgetter) {
	var _arg0 *C.GtkBox    // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	}

	C.gtk_box_reorder_child_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
}

// SetBaselinePosition sets the baseline position of a box.
//
// This affects only horizontal boxes with at least one baseline aligned child.
// If there is more vertical space available than requested, and the baseline
// is not allocated by the parent then position is used to allocate the baseline
// with respect to the extra space available.
//
// The function takes the following parameters:
//
//   - position: GtkBaselinePosition.
func (box *Box) SetBaselinePosition(position BaselinePosition) {
	var _arg0 *C.GtkBox             // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.GtkBaselinePosition(position)

	C.gtk_box_set_baseline_position(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(position)
}

// SetHomogeneous sets whether or not all children of box are given equal space
// in the box.
//
// The function takes the following parameters:
//
//   - homogeneous: boolean value, TRUE to create equal allotments, FALSE for
//     variable allotments.
func (box *Box) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkBox  // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_box_set_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(homogeneous)
}

// SetSpacing sets the number of pixels to place between children of box.
//
// The function takes the following parameters:
//
//   - spacing: number of pixels to put between children.
func (box *Box) SetSpacing(spacing int) {
	var _arg0 *C.GtkBox // out
	var _arg1 C.int     // out

	_arg0 = (*C.GtkBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.int(spacing)

	C.gtk_box_set_spacing(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(spacing)
}

// BoxLayoutOverrides contains methods that are overridable.
type BoxLayoutOverrides struct {
}

func defaultBoxLayoutOverrides(v *BoxLayout) BoxLayoutOverrides {
	return BoxLayoutOverrides{}
}

// BoxLayout: GtkBoxLayout is a layout manager that arranges children in a
// single row or column.
//
// Whether it is a row or column depends on the value of its
// gtk.Orientable:orientation property. Within the other dimension all
// children all allocated the same size. The GtkBoxLayout will respect the
// gtk.Widget:halign and gtk.Widget:valign properties of each child widget.
//
// If you want all children to be assigned the same size, you can use the
// gtk.BoxLayout:homogeneous property.
//
// If you want to specify the amount of space placed between each child, you can
// use the gtk.BoxLayout:spacing property.
type BoxLayout struct {
	_ [0]func() // equal guard
	LayoutManager

	*coreglib.Object
	Orientable
}

var (
	_ LayoutManagerer   = (*BoxLayout)(nil)
	_ coreglib.Objector = (*BoxLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BoxLayout, *BoxLayoutClass, BoxLayoutOverrides](
		GTypeBoxLayout,
		initBoxLayoutClass,
		wrapBoxLayout,
		defaultBoxLayoutOverrides,
	)
}

func initBoxLayoutClass(gclass unsafe.Pointer, overrides BoxLayoutOverrides, classInitFunc func(*BoxLayoutClass)) {
	if classInitFunc != nil {
		class := (*BoxLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBoxLayout(obj *coreglib.Object) *BoxLayout {
	return &BoxLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalBoxLayout(p uintptr) (interface{}, error) {
	return wrapBoxLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBoxLayout creates a new GtkBoxLayout.
//
// The function takes the following parameters:
//
//   - orientation for the new layout.
//
// The function returns the following values:
//
//   - boxLayout: new box layout.
func NewBoxLayout(orientation Orientation) *BoxLayout {
	var _arg1 C.GtkOrientation    // out
	var _cret *C.GtkLayoutManager // in

	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_box_layout_new(_arg1)
	runtime.KeepAlive(orientation)

	var _boxLayout *BoxLayout // out

	_boxLayout = wrapBoxLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _boxLayout
}

// BaselinePosition gets the value set by
// gtk_box_layout_set_baseline_position().
//
// The function returns the following values:
//
//   - baselinePosition: baseline position.
func (boxLayout *BoxLayout) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkBoxLayout       // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(coreglib.InternObject(boxLayout).Native()))

	_cret = C.gtk_box_layout_get_baseline_position(_arg0)
	runtime.KeepAlive(boxLayout)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// Homogeneous returns whether the layout is set to be homogeneous.
//
// The function returns the following values:
//
//   - ok: TRUE if the layout is homogeneous.
func (boxLayout *BoxLayout) Homogeneous() bool {
	var _arg0 *C.GtkBoxLayout // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(coreglib.InternObject(boxLayout).Native()))

	_cret = C.gtk_box_layout_get_homogeneous(_arg0)
	runtime.KeepAlive(boxLayout)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Spacing returns the space that box_layout puts between children.
//
// The function returns the following values:
//
//   - guint: spacing of the layout.
func (boxLayout *BoxLayout) Spacing() uint {
	var _arg0 *C.GtkBoxLayout // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(coreglib.InternObject(boxLayout).Native()))

	_cret = C.gtk_box_layout_get_spacing(_arg0)
	runtime.KeepAlive(boxLayout)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetBaselinePosition sets the baseline position of a box layout.
//
// The baseline position affects only horizontal boxes with at least one
// baseline aligned child. If there is more vertical space available than
// requested, and the baseline is not allocated by the parent then the given
// position is used to allocate the baseline within the extra space available.
//
// The function takes the following parameters:
//
//   - position: GtkBaselinePosition.
func (boxLayout *BoxLayout) SetBaselinePosition(position BaselinePosition) {
	var _arg0 *C.GtkBoxLayout       // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(coreglib.InternObject(boxLayout).Native()))
	_arg1 = C.GtkBaselinePosition(position)

	C.gtk_box_layout_set_baseline_position(_arg0, _arg1)
	runtime.KeepAlive(boxLayout)
	runtime.KeepAlive(position)
}

// SetHomogeneous sets whether the box layout will allocate the same size to all
// children.
//
// The function takes the following parameters:
//
//   - homogeneous: TRUE to set the box layout as homogeneous.
func (boxLayout *BoxLayout) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkBoxLayout // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(coreglib.InternObject(boxLayout).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_box_layout_set_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(boxLayout)
	runtime.KeepAlive(homogeneous)
}

// SetSpacing sets how much spacing to put between children.
//
// The function takes the following parameters:
//
//   - spacing to apply between children.
func (boxLayout *BoxLayout) SetSpacing(spacing uint) {
	var _arg0 *C.GtkBoxLayout // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(coreglib.InternObject(boxLayout).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_box_layout_set_spacing(_arg0, _arg1)
	runtime.KeepAlive(boxLayout)
	runtime.KeepAlive(spacing)
}

// Builder: GtkBuilder reads XML descriptions of a user interface and
// instantiates the described objects.
//
// To create a GtkBuilder from a user interface description,
// call gtk.Builder.NewFromFile, gtk.Builder.NewFromResource or
// gtk.Builder.NewFromString.
//
// In the (unusual) case that you want to add user interface descriptions
// from multiple sources to the same GtkBuilder you can call
// gtk.Builder.New to get an empty builder and populate it by (multiple)
// calls to gtk.Builder.AddFromFile(), gtk.Builder.AddFromResource() or
// gtk.Builder.AddFromString().
//
// A GtkBuilder holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call gtk.Window.Destroy() to get rid of them
// and all the widgets they contain.
//
// The functions gtk.Builder.GetObject() and gtk.Builder.GetObjects() can
// be used to access the widgets in the interface by the names assigned
// to them inside the UI description. Toplevel windows returned by these
// functions will stay around until the user explicitly destroys them with
// gtk.Window.Destroy(). Other widgets will either be part of a larger hierarchy
// constructed by the builder (in which case you should not have to worry about
// their lifecycle), or without a parent, in which case they have to be added to
// some container to make use of them. Non-widget objects need to be reffed with
// g_object_ref() to keep them beyond the lifespan of the builder.
//
// # GtkBuilder UI Definitions
//
// GtkBuilder parses textual descriptions of user interfaces which are specified
// in XML format. We refer to these descriptions as “GtkBuilder UI definitions”
// or just “UI definitions” if the context is clear.
//
// The toplevel element is <interface>. It optionally takes a “domain”
// attribute, which will make the builder look for translated strings using
// dgettext() in the domain specified. This can also be done by calling
// gtk.Builder.SetTranslationDomain() on the builder.
//
// Objects are described by <object> elements, which can contain <property>
// elements to set properties, <signal> elements which connect signals to
// handlers, and <child> elements, which describe child objects (most often
// widgets inside a container, but also e.g. actions in an action group,
// or columns in a tree model). A <child> element contains an <object> element
// which describes the child object.
//
// The target toolkit version(s) are described by <requires> elements,
// the “lib” attribute specifies the widget library in question (currently the
// only supported value is “gtk”) and the “version” attribute specifies the
// target version in the form “<major>.<minor>”. GtkBuilder will error out if
// the version requirements are not met.
//
// Typically, the specific kind of object represented by an <object> element
// is specified by the “class” attribute. If the type has not been loaded yet,
// GTK tries to find the get_type() function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the get_type() function explicitly with the "type-func"
// attribute.
//
// Objects may be given a name with the “id” attribute, which allows the
// application to retrieve them from the builder with gtk.Builder.GetObject().
// An id is also necessary to use the object as property value in other parts
// of the UI definition. GTK reserves ids starting and ending with ___ (three
// consecutive underscores) for its own purposes.
//
// Setting properties of objects is pretty straightforward with the <property>
// element: the “name” attribute specifies the name of the property, and the
// content of the element specifies the value. If the “translatable” attribute
// is set to a true value, GTK uses gettext() (or dgettext() if the builder has
// a translation domain set) to find a translation for the value. This happens
// before the value is parsed, so it can be used for properties of any type,
// but it is probably most useful for string properties. It is also possible to
// specify a context to disambiguate short strings, and comments which may help
// the translators.
//
// GtkBuilder can parse textual representations for the most common property
// types: characters, strings, integers, floating-point numbers, booleans
// (strings like “TRUE”, “t”, “yes”, “y”, “1” are interpreted as TRUE, strings
// like “FALSE”, “f”, “no”, “n”, “0” are interpreted as FALSE), enumerations
// (can be specified by their name, nick or integer value), flags (can be
// specified by their name, nick, integer value, optionally combined with “|”,
// e.g. “GTK_INPUT_HINT_EMOJI|GTK_INPUT_HINT_LOWERCASE”) and colors (in a format
// understood by gdk.RGBA.Parse()).
//
// GVariants can be specified in the format understood by g_variant_parse(),
// and pixbufs can be specified as a filename of an image file to load.
//
// Objects can be referred to by their name and by default refer to
// objects declared in the local XML fragment and objects exposed via
// gtk.Builder.ExposeObject(). In general, GtkBuilder allows forward references
// to objects — declared in the local XML; an object doesn’t have to be
// constructed before it can be referred to. The exception to this rule is
// that an object has to be constructed before it can be used as the value of a
// construct-only property.
//
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of
// the binding, and optionally, "bind-property" and "bind-flags" to specify
// the source property and source binding flags respectively. Internally,
// GtkBuilder implements this using GBinding objects. For more information see
// g_object_bind_property().
//
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK as part of a composite widget, to set properties on them
// or to add further children (e.g. the content area of a GtkDialog). This can
// be achieved by setting the “internal-child” property of the <child> element
// to a true value. Note that Builder still requires an <object> element for the
// internal child, even if it has already been constructed.
//
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the “type” attribute on a <child> The possible values for the
// “type” attribute are described in the sections describing the widget-specific
// portions of UI definitions.
//
// # Signal handlers and function pointers
//
// Signal handlers are set up with the <signal> element. The “name” attribute
// specifies the name of the signal, and the “handler” attribute specifies
// the function to connect to the signal. The remaining attributes, “after”,
// “swapped” and “object”, have the same meaning as the corresponding parameters
// of the g_signal_connect_object() or g_signal_connect_data() functions.
// A “last_modification_time” attribute is also allowed, but it does not have a
// meaning to the builder.
//
// If you rely on GModule support to lookup callbacks in the symbol table,
// the following details should be noted:
//
// When compiling applications for Windows, you must declare signal callbacks
// with G_MODULE_EXPORT, or they will not be put in the symbol table. On Linux
// and Unix, this is not necessary; applications should instead be compiled with
// the -Wl,--export-dynamic CFLAGS, and linked against gmodule-export-2.0.
//
// A GtkBuilder UI Definition
//
//	<interface>
//	  <object class="GtkDialog" id="dialog1">
//	    <child internal-child="vbox">
//	      <object class="GtkBox" id="vbox1">
//	        <child internal-child="action_area">
//	          <object class="GtkBox" id="hbuttonbox1">
//	            <child>
//	              <object class="GtkButton" id="ok_button">
//	                <property name="label">gtk-ok</property>
//	                <signal name="clicked" handler="ok_button_clicked"/>
//	              </object>
//	            </child>
//	          </object>
//	        </child>
//	      </object>
//	    </child>
//	  </object>
//	</interface>
//
// Beyond this general structure, several object classes define their own
// XML DTD fragments for filling in the ANY placeholders in the DTD above.
// Note that a custom element in a <child> element gets parsed by the custom tag
// handler of the parent object, while a custom element in an <object> element
// gets parsed by the custom tag handler of the object.
//
// These XML fragments are explained in the documentation of the respective
// objects.
//
// A <template> tag can be used to define a widget
// class’s components. See the GtkWidget documentation
// (class.Widget.html#building-composite-widgets-from-template-xml) for details.
type Builder struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Builder)(nil)
)

func wrapBuilder(obj *coreglib.Object) *Builder {
	return &Builder{
		Object: obj,
	}
}

func marshalBuilder(p uintptr) (interface{}, error) {
	return wrapBuilder(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBuilder creates a new empty builder object.
//
// This function is only useful if you intend to make multiple calls
// to gtk.Builder.AddFromFile(), gtk.Builder.AddFromResource() or
// gtk.Builder.AddFromString() in order to merge multiple UI descriptions into a
// single builder.
//
// The function returns the following values:
//
//   - builder: new (empty) GtkBuilder object.
func NewBuilder() *Builder {
	var _cret *C.GtkBuilder // in

	_cret = C.gtk_builder_new()

	var _builder *Builder // out

	_builder = wrapBuilder(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromFile parses the UI definition in the file filename.
//
// If there is an error opening the file or parsing the description then the
// program will be aborted. You should only ever attempt to parse user interface
// descriptions that are shipped as part of your program.
//
// The function takes the following parameters:
//
//   - filename of user interface description file.
//
// The function returns the following values:
//
//   - builder: GtkBuilder containing the described interface.
func NewBuilderFromFile(filename string) *Builder {
	var _arg1 *C.char       // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_new_from_file(_arg1)
	runtime.KeepAlive(filename)

	var _builder *Builder // out

	_builder = wrapBuilder(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromResource parses the UI definition at resource_path.
//
// If there is an error locating the resource or parsing the description,
// then the program will be aborted.
//
// The function takes the following parameters:
//
//   - resourcePath: GResource resource path.
//
// The function returns the following values:
//
//   - builder: GtkBuilder containing the described interface.
func NewBuilderFromResource(resourcePath string) *Builder {
	var _arg1 *C.char       // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_new_from_resource(_arg1)
	runtime.KeepAlive(resourcePath)

	var _builder *Builder // out

	_builder = wrapBuilder(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// NewBuilderFromString parses the UI definition in string.
//
// If string is NULL-terminated, then length should be -1. If length is not -1,
// then it is the length of string.
//
// If there is an error parsing string then the program will be aborted.
// You should not attempt to parse user interface description from untrusted
// sources.
//
// The function takes the following parameters:
//
//   - str: user interface (XML) description.
//   - length of string, or -1.
//
// The function returns the following values:
//
//   - builder: GtkBuilder containing the interface described by string.
func NewBuilderFromString(str string, length int) *Builder {
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _cret *C.GtkBuilder // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)

	_cret = C.gtk_builder_new_from_string(_arg1, _arg2)
	runtime.KeepAlive(str)
	runtime.KeepAlive(length)

	var _builder *Builder // out

	_builder = wrapBuilder(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builder
}

// AddFromFile parses a file containing a UI definition and merges it with the
// current contents of builder.
//
// This function is useful if you need to call gtk.Builder.SetCurrentObject())
// to add user data to callbacks before loading GtkBuilder UI. Otherwise,
// you probably want gtk.Builder.NewFromFile instead.
//
// If an error occurs, 0 will be returned and error will be assigned a GError
// from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_FILE_ERROR domains.
//
// It’s not really reasonable to attempt to handle failures of this call.
// You should not use this function with untrusted files (ie: files that are
// not part of your application). Broken GtkBuilder files can easily crash your
// program, and it’s possible that memory was leaked leading up to the reported
// failure. The only reasonable thing to do when an error is detected is to call
// g_error().
//
// The function takes the following parameters:
//
//   - filename: name of the file to parse.
func (builder *Builder) AddFromFile(filename string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_builder_add_from_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(filename)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddFromResource parses a resource file containing a UI definition and merges
// it with the current contents of builder.
//
// This function is useful if you need to call gtk.Builder.SetCurrentObject()
// to add user data to callbacks before loading GtkBuilder UI. Otherwise,
// you probably want gtk.Builder.NewFromResource instead.
//
// If an error occurs, 0 will be returned and error will be assigned a GError
// from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_RESOURCE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
//
// The function takes the following parameters:
//
//   - resourcePath: path of the resource file to parse.
func (builder *Builder) AddFromResource(resourcePath string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_builder_add_from_resource(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(resourcePath)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddFromString parses a string containing a UI definition and merges it with
// the current contents of builder.
//
// This function is useful if you need to call gtk.Builder.SetCurrentObject()
// to add user data to callbacks before loading GtkBuilder UI. Otherwise,
// you probably want gtk.Builder.NewFromString instead.
//
// Upon errors FALSE will be returned and error will be assigned a GError from
// the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_VARIANT_PARSE_ERROR domain.
//
// It’s not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
//
// The function takes the following parameters:
//
//   - buffer: string to parse.
//   - length of buffer (may be -1 if buffer is nul-terminated).
func (builder *Builder) AddFromString(buffer string, length int) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)

	C.gtk_builder_add_from_string(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(length)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddObjectsFromFile parses a file containing a UI definition building only the
// requested objects and merges them with the current contents of builder.
//
// Upon errors, 0 will be returned and error will be assigned a GError from the
// GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_FILE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its child
// (for instance a GtkTreeView that depends on its GtkTreeModel), you have to
// explicitly list all of them in object_ids.
//
// The function takes the following parameters:
//
//   - filename: name of the file to parse.
//   - objectIds: nul-terminated array of objects to build.
func (builder *Builder) AddObjectsFromFile(filename string, objectIds []string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 **C.char      // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(objectIds) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(objectIds)+1)
			var zero *C.char
			out[len(objectIds)] = zero
			for i := range objectIds {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(objectIds[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_builder_add_objects_from_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(filename)
	runtime.KeepAlive(objectIds)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddObjectsFromResource parses a resource file containing a UI definition,
// building only the requested objects and merges them with the current contents
// of builder.
//
// Upon errors, 0 will be returned and error will be assigned a GError from the
// GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_RESOURCE_ERROR domain.
//
// If you are adding an object that depends on an object that is not its child
// (for instance a GtkTreeView that depends on its GtkTreeModel), you have to
// explicitly list all of them in object_ids.
//
// The function takes the following parameters:
//
//   - resourcePath: path of the resource file to parse.
//   - objectIds: nul-terminated array of objects to build.
func (builder *Builder) AddObjectsFromResource(resourcePath string, objectIds []string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 **C.char      // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(objectIds) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(objectIds)+1)
			var zero *C.char
			out[len(objectIds)] = zero
			for i := range objectIds {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(objectIds[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_builder_add_objects_from_resource(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(resourcePath)
	runtime.KeepAlive(objectIds)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddObjectsFromString parses a string containing a UI definition, building
// only the requested objects and merges them with the current contents of
// builder.
//
// Upon errors FALSE will be returned and error will be assigned a GError from
// the GTK_BUILDER_ERROR or G_MARKUP_ERROR domain.
//
// If you are adding an object that depends on an object that is not its child
// (for instance a GtkTreeView that depends on its GtkTreeModel), you have to
// explicitly list all of them in object_ids.
//
// The function takes the following parameters:
//
//   - buffer: string to parse.
//   - length of buffer (may be -1 if buffer is nul-terminated).
//   - objectIds: nul-terminated array of objects to build.
func (builder *Builder) AddObjectsFromString(buffer string, length int, objectIds []string) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 C.gssize      // out
	var _arg3 **C.char      // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(length)
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(objectIds) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(objectIds)+1)
			var zero *C.char
			out[len(objectIds)] = zero
			for i := range objectIds {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(objectIds[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_builder_add_objects_from_string(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(length)
	runtime.KeepAlive(objectIds)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ExposeObject: add object to the builder object pool so it can be referenced
// just like any other object built by builder.
//
// The function takes the following parameters:
//
//   - name of the object exposed to the builder.
//   - object to expose.
func (builder *Builder) ExposeObject(name string, object *coreglib.Object) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _arg2 *C.GObject    // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))

	C.gtk_builder_expose_object(_arg0, _arg1, _arg2)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(name)
	runtime.KeepAlive(object)
}

// ExtendWithTemplate: main private entry point for building composite
// components from template XML.
//
// This is exported purely to let gtk-builder-tool validate templates,
// applications have no need to call this function.
//
// The function takes the following parameters:
//
//   - object that is being extended.
//   - templateType: type that the template is for.
//   - buffer: string to parse.
//   - length of buffer (may be -1 if buffer is nul-terminated).
func (builder *Builder) ExtendWithTemplate(object *coreglib.Object, templateType coreglib.Type, buffer string, length int) error {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.GObject    // out
	var _arg2 C.GType       // out
	var _arg3 *C.char       // out
	var _arg4 C.gssize      // out
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
	_arg2 = C.GType(templateType)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(buffer)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = C.gssize(length)

	C.gtk_builder_extend_with_template(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(object)
	runtime.KeepAlive(templateType)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(length)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CurrentObject gets the current object set via
// gtk_builder_set_current_object().
//
// The function returns the following values:
//
//   - object (optional): current object.
func (builder *Builder) CurrentObject() *coreglib.Object {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	_cret = C.gtk_builder_get_current_object(_arg0)
	runtime.KeepAlive(builder)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.Take(unsafe.Pointer(_cret))
	}

	return _object
}

// GetObject gets the object named name.
//
// Note that this function does not increment the reference count of the
// returned object.
//
// The function takes the following parameters:
//
//   - name of object to get.
//
// The function returns the following values:
//
//   - object (optional) named name or NULL if it could not be found in the
//     object tree.
func (builder *Builder) GetObject(name string) *coreglib.Object {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cret *C.GObject    // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_object(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.Take(unsafe.Pointer(_cret))
	}

	return _object
}

// Objects gets all objects that have been constructed by builder.
//
// Note that this function does not increment the reference counts of the
// returned objects.
//
// The function returns the following values:
//
//   - sList: a newly-allocated GSList containing all the objects constructed by
//     the GtkBuilder instance. It should be freed by g_slist_free().
func (builder *Builder) Objects() []*coreglib.Object {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.GSList     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	_cret = C.gtk_builder_get_objects(_arg0)
	runtime.KeepAlive(builder)

	var _sList []*coreglib.Object // out

	_sList = make([]*coreglib.Object, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GObject)(v)
		var dst *coreglib.Object // out
		dst = coreglib.Take(unsafe.Pointer(src))
		_sList = append(_sList, dst)
	})

	return _sList
}

// Scope gets the scope in use that was set via gtk_builder_set_scope().
//
// The function returns the following values:
//
//   - builderScope: current scope.
func (builder *Builder) Scope() *BuilderScope {
	var _arg0 *C.GtkBuilder      // out
	var _cret *C.GtkBuilderScope // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	_cret = C.gtk_builder_get_scope(_arg0)
	runtime.KeepAlive(builder)

	var _builderScope *BuilderScope // out

	_builderScope = wrapBuilderScope(coreglib.Take(unsafe.Pointer(_cret)))

	return _builderScope
}

// TranslationDomain gets the translation domain of builder.
//
// The function returns the following values:
//
//   - utf8 (optional): translation domain or NULL. This string is owned by the
//     builder object and must not be modified or freed.
func (builder *Builder) TranslationDomain() string {
	var _arg0 *C.GtkBuilder // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))

	_cret = C.gtk_builder_get_translation_domain(_arg0)
	runtime.KeepAlive(builder)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TypeFromName looks up a type by name.
//
// This is using the virtual function that GtkBuilder has for that purpose.
// This is mainly used when implementing the GtkBuildable interface on a type.
//
// The function takes the following parameters:
//
//   - typeName: type name to lookup.
//
// The function returns the following values:
//
//   - gType: GType found for type_name or G_TYPE_INVALID if no type was found.
func (builder *Builder) TypeFromName(typeName string) coreglib.Type {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out
	var _cret C.GType       // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(typeName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_builder_get_type_from_name(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typeName)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// SetCurrentObject sets the current object for the builder.
//
// The current object can be thought of as the this object that the builder is
// working for and will often be used as the default object when an object is
// optional.
//
// gtk.Widget.InitTemplate() for example will set the current object
// to the widget the template is inited for. For functions like
// gtk.Builder.NewFromResource, the current object will be NULL.
//
// The function takes the following parameters:
//
//   - currentObject (optional): new current object or NULL for none.
func (builder *Builder) SetCurrentObject(currentObject *coreglib.Object) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.GObject    // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if currentObject != nil {
		_arg1 = (*C.GObject)(unsafe.Pointer(currentObject.Native()))
	}

	C.gtk_builder_set_current_object(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(currentObject)
}

// SetScope sets the scope the builder should operate in.
//
// If scope is NULL a new gtk.BuilderCScope will be created.
//
// The function takes the following parameters:
//
//   - scope (optional) to use or NULL for the default.
func (builder *Builder) SetScope(scope BuilderScoper) {
	var _arg0 *C.GtkBuilder      // out
	var _arg1 *C.GtkBuilderScope // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if scope != nil {
		_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(coreglib.InternObject(scope).Native()))
	}

	C.gtk_builder_set_scope(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(scope)
}

// SetTranslationDomain sets the translation domain of builder.
//
// The function takes the following parameters:
//
//   - domain (optional): translation domain or NULL.
func (builder *Builder) SetTranslationDomain(domain string) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	if domain != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(domain)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_builder_set_translation_domain(_arg0, _arg1)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(domain)
}

// ValueFromStringType demarshals a value from a string.
//
// Unlike gtk.Builder.ValueFromString(), this function takes a GType instead of
// GParamSpec.
//
// Calls g_value_init() on the value argument, so it need not be initialised
// beforehand.
//
// Upon errors FALSE will be returned and error will be assigned a GError from
// the GTK_BUILDER_ERROR domain.
//
// The function takes the following parameters:
//
//   - typ: GType of the value.
//   - str: string representation of the value.
//
// The function returns the following values:
//
//   - value to store the result in.
func (builder *Builder) ValueFromStringType(typ coreglib.Type, str string) (coreglib.Value, error) {
	var _arg0 *C.GtkBuilder // out
	var _arg1 C.GType       // out
	var _arg2 *C.char       // out
	var _arg3 C.GValue      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkBuilder)(unsafe.Pointer(coreglib.InternObject(builder).Native()))
	_arg1 = C.GType(typ)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_builder_value_from_string_type(_arg0, _arg1, _arg2, &_arg3, &_cerr)
	runtime.KeepAlive(builder)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(str)

	var _value coreglib.Value // out
	var _goerr error          // out

	_value = *coreglib.ValueFromNative(unsafe.Pointer((&_arg3)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _value, _goerr
}

// BuilderCScopeOverrides contains methods that are overridable.
type BuilderCScopeOverrides struct {
}

func defaultBuilderCScopeOverrides(v *BuilderCScope) BuilderCScopeOverrides {
	return BuilderCScopeOverrides{}
}

// BuilderCScope: GtkBuilderScope implementation for the C language.
//
// GtkBuilderCScope instances use symbols explicitly added to builder with prior
// calls to gtk.BuilderCScope.AddCallbackSymbol(). If developers want to do
// that, they are encouraged to create their own scopes for that purpose.
//
// In the case that symbols are not explicitly added; GTK will uses GModule’s
// introspective features (by opening the module NULL) to look at the
// application’s symbol table. From here it tries to match the signal function
// names given in the interface description with symbols in the application.
//
// Note that unless gtk.BuilderCScope.AddCallbackSymbol() is called for all
// signal callbacks which are referenced by the loaded XML, this functionality
// will require that GModule be supported on the platform.
type BuilderCScope struct {
	_ [0]func() // equal guard
	*coreglib.Object

	BuilderScope
}

var (
	_ coreglib.Objector = (*BuilderCScope)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*BuilderCScope, *BuilderCScopeClass, BuilderCScopeOverrides](
		GTypeBuilderCScope,
		initBuilderCScopeClass,
		wrapBuilderCScope,
		defaultBuilderCScopeOverrides,
	)
}

func initBuilderCScopeClass(gclass unsafe.Pointer, overrides BuilderCScopeOverrides, classInitFunc func(*BuilderCScopeClass)) {
	if classInitFunc != nil {
		class := (*BuilderCScopeClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapBuilderCScope(obj *coreglib.Object) *BuilderCScope {
	return &BuilderCScope{
		Object: obj,
		BuilderScope: BuilderScope{
			Object: obj,
		},
	}
}

func marshalBuilderCScope(p uintptr) (interface{}, error) {
	return wrapBuilderCScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBuilderCScope creates a new GtkBuilderCScope object to use with future
// GtkBuilder instances.
//
// Calling this function is only necessary if you want to add custom callbacks
// via gtk.BuilderCScope.AddCallbackSymbol().
//
// The function returns the following values:
//
//   - builderCScope: new GtkBuilderCScope.
func NewBuilderCScope() *BuilderCScope {
	var _cret *C.GtkBuilderScope // in

	_cret = C.gtk_builder_cscope_new()

	var _builderCScope *BuilderCScope // out

	_builderCScope = wrapBuilderCScope(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builderCScope
}

// BuilderListItemFactory: GtkBuilderListItemFactory is a GtkListItemFactory
// that creates widgets by instantiating GtkBuilder UI templates.
//
// The templates must be extending GtkListItem, and typically use GtkExpressions
// to obtain data from the items in the model.
//
// Example:
//
//	<interface>
//	  <template class="GtkListItem">
//	    <property name="child">
//	      <object class="GtkLabel">
//	        <property name="xalign">0</property>
//	        <binding name="label">
//	          <lookup name="name" type="SettingsKey">
//	            <lookup name="item">GtkListItem</lookup>
//	          </lookup>
//	        </binding>
//	      </object>
//	    </property>
//	  </template>
//	</interface>.
type BuilderListItemFactory struct {
	_ [0]func() // equal guard
	ListItemFactory
}

var (
	_ coreglib.Objector = (*BuilderListItemFactory)(nil)
)

func wrapBuilderListItemFactory(obj *coreglib.Object) *BuilderListItemFactory {
	return &BuilderListItemFactory{
		ListItemFactory: ListItemFactory{
			Object: obj,
		},
	}
}

func marshalBuilderListItemFactory(p uintptr) (interface{}, error) {
	return wrapBuilderListItemFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBuilderListItemFactoryFromBytes creates a new GtkBuilderListItemFactory
// that instantiates widgets using bytes as the data to pass to GtkBuilder.
//
// The function takes the following parameters:
//
//   - scope (optional) to use when instantiating.
//   - bytes: GBytes containing the ui file to instantiate.
//
// The function returns the following values:
//
//   - builderListItemFactory: new GtkBuilderListItemFactory.
func NewBuilderListItemFactoryFromBytes(scope BuilderScoper, bytes *glib.Bytes) *BuilderListItemFactory {
	var _arg1 *C.GtkBuilderScope    // out
	var _arg2 *C.GBytes             // out
	var _cret *C.GtkListItemFactory // in

	if scope != nil {
		_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(coreglib.InternObject(scope).Native()))
	}
	_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(bytes)))

	_cret = C.gtk_builder_list_item_factory_new_from_bytes(_arg1, _arg2)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(bytes)

	var _builderListItemFactory *BuilderListItemFactory // out

	_builderListItemFactory = wrapBuilderListItemFactory(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builderListItemFactory
}

// NewBuilderListItemFactoryFromResource creates a new GtkBuilderListItemFactory
// that instantiates widgets using data read from the given resource_path to
// pass to GtkBuilder.
//
// The function takes the following parameters:
//
//   - scope (optional) to use when instantiating.
//   - resourcePath: valid path to a resource that contains the data.
//
// The function returns the following values:
//
//   - builderListItemFactory: new GtkBuilderListItemFactory.
func NewBuilderListItemFactoryFromResource(scope BuilderScoper, resourcePath string) *BuilderListItemFactory {
	var _arg1 *C.GtkBuilderScope    // out
	var _arg2 *C.char               // out
	var _cret *C.GtkListItemFactory // in

	if scope != nil {
		_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(coreglib.InternObject(scope).Native()))
	}
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_builder_list_item_factory_new_from_resource(_arg1, _arg2)
	runtime.KeepAlive(scope)
	runtime.KeepAlive(resourcePath)

	var _builderListItemFactory *BuilderListItemFactory // out

	_builderListItemFactory = wrapBuilderListItemFactory(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _builderListItemFactory
}

// Bytes gets the data used as the GtkBuilder UI template for constructing
// listitems.
//
// The function returns the following values:
//
//   - bytes: GtkBuilder data.
func (self *BuilderListItemFactory) Bytes() *glib.Bytes {
	var _arg0 *C.GtkBuilderListItemFactory // out
	var _cret *C.GBytes                    // in

	_arg0 = (*C.GtkBuilderListItemFactory)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_builder_list_item_factory_get_bytes(_arg0)
	runtime.KeepAlive(self)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_bytes_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Resource: if the data references a resource, gets the path of that resource.
//
// The function returns the following values:
//
//   - utf8 (optional): path to the resource or NULL if none.
func (self *BuilderListItemFactory) Resource() string {
	var _arg0 *C.GtkBuilderListItemFactory // out
	var _cret *C.char                      // in

	_arg0 = (*C.GtkBuilderListItemFactory)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_builder_list_item_factory_get_resource(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Scope gets the scope used when constructing listitems.
//
// The function returns the following values:
//
//   - builderScope (optional): scope used when constructing listitems.
func (self *BuilderListItemFactory) Scope() *BuilderScope {
	var _arg0 *C.GtkBuilderListItemFactory // out
	var _cret *C.GtkBuilderScope           // in

	_arg0 = (*C.GtkBuilderListItemFactory)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_builder_list_item_factory_get_scope(_arg0)
	runtime.KeepAlive(self)

	var _builderScope *BuilderScope // out

	if _cret != nil {
		_builderScope = wrapBuilderScope(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _builderScope
}

// ButtonOverrides contains methods that are overridable.
type ButtonOverrides struct {
	Activate func()
	Clicked  func()
}

func defaultButtonOverrides(v *Button) ButtonOverrides {
	return ButtonOverrides{
		Activate: v.activate,
		Clicked:  v.clicked,
	}
}

// Button: GtkButton widget is generally used to trigger a callback function
// that is called when the button is pressed.
//
// !An example GtkButton (button.png)
//
// The GtkButton widget can hold any valid child widget. That is, it can hold
// almost any other standard GtkWidget. The most commonly used child is the
// GtkLabel.
//
// # CSS nodes
//
// GtkButton has a single CSS node with name button. The node will get the
// style classes .image-button or .text-button, if the content is just an
// image or label, respectively. It may also receive the .flat style class.
// When activating a button via the keyboard, the button will temporarily gain
// the .keyboard-activating style class.
//
// Other style classes that are commonly used with GtkButton include
// .suggested-action and .destructive-action. In special cases, buttons can be
// made round by adding the .circular style class.
//
// Button-like widgets like gtk.ToggleButton, gtk.MenuButton, gtk.VolumeButton,
// gtk.LockButton, gtk.ColorButton or gtk.FontButton use style classes such as
// .toggle, .popup, .scale, .lock, .color on the button node to differentiate
// themselves from a plain GtkButton.
//
// # Accessibility
//
// GtkButton uses the GTK_ACCESSIBLE_ROLE_BUTTON role.
type Button struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Actionable
}

var (
	_ Widgetter         = (*Button)(nil)
	_ coreglib.Objector = (*Button)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Button, *ButtonClass, ButtonOverrides](
		GTypeButton,
		initButtonClass,
		wrapButton,
		defaultButtonOverrides,
	)
}

func initButtonClass(gclass unsafe.Pointer, overrides ButtonOverrides, classInitFunc func(*ButtonClass)) {
	pclass := (*C.GtkButtonClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeButton))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_ButtonClass_activate)
	}

	if overrides.Clicked != nil {
		pclass.clicked = (*[0]byte)(C._gotk4_gtk4_ButtonClass_clicked)
	}

	if classInitFunc != nil {
		class := (*ButtonClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapButton(obj *coreglib.Object) *Button {
	return &Button{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Actionable: Actionable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalButton(p uintptr) (interface{}, error) {
	return wrapButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted to animate press then release.
//
// This is an action signal. Applications should never connect to this signal,
// but use the gtk.Button::clicked signal.
func (button *Button) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(button, "activate", false, unsafe.Pointer(C._gotk4_gtk4_Button_ConnectActivate), f)
}

// ConnectClicked is emitted when the button has been activated (pressed and
// released).
func (button *Button) ConnectClicked(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(button, "clicked", false, unsafe.Pointer(C._gotk4_gtk4_Button_ConnectClicked), f)
}

// NewButton creates a new GtkButton widget.
//
// To add a child widget to the button, use gtk.Button.SetChild().
//
// The function returns the following values:
//
//   - button: newly created GtkButton widget.
func NewButton() *Button {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_button_new()

	var _button *Button // out

	_button = wrapButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonFromIconName creates a new button containing an icon from the
// current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
//
// The function takes the following parameters:
//
//   - iconName (optional): icon name or NULL.
//
// The function returns the following values:
//
//   - button: new GtkButton displaying the themed icon.
func NewButtonFromIconName(iconName string) *Button {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if iconName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_button_new_from_icon_name(_arg1)
	runtime.KeepAlive(iconName)

	var _button *Button // out

	_button = wrapButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonWithLabel creates a GtkButton widget with a GtkLabel child.
//
// The function takes the following parameters:
//
//   - label: text you want the GtkLabel to hold.
//
// The function returns the following values:
//
//   - button: newly created GtkButton widget.
func NewButtonWithLabel(label string) *Button {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_with_label(_arg1)
	runtime.KeepAlive(label)

	var _button *Button // out

	_button = wrapButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// NewButtonWithMnemonic creates a new GtkButton containing a label.
//
// If characters in label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
//
// The function takes the following parameters:
//
//   - label: text of the button, with an underscore in front of the mnemonic
//     character.
//
// The function returns the following values:
//
//   - button: new GtkButton.
func NewButtonWithMnemonic(label string) *Button {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_button_new_with_mnemonic(_arg1)
	runtime.KeepAlive(label)

	var _button *Button // out

	_button = wrapButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// Child gets the child widget of button.
//
// The function returns the following values:
//
//   - widget (optional): child widget of button.
func (button *Button) Child() Widgetter {
	var _arg0 *C.GtkButton // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_button_get_child(_arg0)
	runtime.KeepAlive(button)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// HasFrame returns whether the button has a frame.
//
// The function returns the following values:
//
//   - ok: TRUE if the button has a frame.
func (button *Button) HasFrame() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_button_get_has_frame(_arg0)
	runtime.KeepAlive(button)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconName returns the icon name of the button.
//
// If the icon name has not been set with gtk.Button.SetIconName() the return
// value will be NULL. This will be the case if you create an empty button with
// gtk.Button.New to use as a container.
//
// The function returns the following values:
//
//   - utf8 (optional): icon name set via gtk.Button.SetIconName().
func (button *Button) IconName() string {
	var _arg0 *C.GtkButton // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_button_get_icon_name(_arg0)
	runtime.KeepAlive(button)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Label fetches the text from the label of the button.
//
// If the label text has not been set with gtk.Button.SetLabel() the return
// value will be NULL. This will be the case if you create an empty button with
// gtk.Button.New to use as a container.
//
// The function returns the following values:
//
//   - utf8 (optional): text of the label widget. This string is owned by the
//     widget and must not be modified or freed.
func (button *Button) Label() string {
	var _arg0 *C.GtkButton // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_button_get_label(_arg0)
	runtime.KeepAlive(button)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UseUnderline gets whether underlines are interpreted as mnemonics.
//
// See gtk.Button.SetUseUnderline().
//
// The function returns the following values:
//
//   - ok: TRUE if an embedded underline in the button label indicates the
//     mnemonic accelerator keys.
func (button *Button) UseUnderline() bool {
	var _arg0 *C.GtkButton // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_button_get_use_underline(_arg0)
	runtime.KeepAlive(button)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of button.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (button *Button) SetChild(child Widgetter) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_button_set_child(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(child)
}

// SetHasFrame sets the style of the button.
//
// Buttons can has a flat appearance or have a frame drawn around them.
//
// The function takes the following parameters:
//
//   - hasFrame: whether the button should have a visible frame.
func (button *Button) SetHasFrame(hasFrame bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_has_frame(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(hasFrame)
}

// SetIconName adds a GtkImage with the given icon name as a child.
//
// If button already contains a child widget, that child widget will be removed
// and replaced with the image.
//
// The function takes the following parameters:
//
//   - iconName: icon name.
func (button *Button) SetIconName(iconName string) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_button_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(iconName)
}

// SetLabel sets the text of the label of the button to label.
//
// This will also clear any previously set labels.
//
// The function takes the following parameters:
//
//   - label: string.
func (button *Button) SetLabel(label string) {
	var _arg0 *C.GtkButton // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_button_set_label(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(label)
}

// SetUseUnderline sets whether to use underlines as mnemonics.
//
// If true, an underline in the text of the button label indicates the next
// character should be used for the mnemonic accelerator key.
//
// The function takes the following parameters:
//
//   - useUnderline: TRUE if underlines in the text indicate mnemonics.
func (button *Button) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkButton // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_button_set_use_underline(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(useUnderline)
}

func (button *Button) activate() {
	gclass := (*C.GtkButtonClass)(coreglib.PeekParentClass(button))
	fnarg := gclass.activate

	var _arg0 *C.GtkButton // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	C._gotk4_gtk4_Button_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(button)
}

func (button *Button) clicked() {
	gclass := (*C.GtkButtonClass)(coreglib.PeekParentClass(button))
	fnarg := gclass.clicked

	var _arg0 *C.GtkButton // out

	_arg0 = (*C.GtkButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	C._gotk4_gtk4_Button_virtual_clicked(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(button)
}

// CClosureExpression: variant of GtkClosureExpression using a C closure.
type CClosureExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*CClosureExpression)(nil)
)

func wrapCClosureExpression(obj *coreglib.Object) *CClosureExpression {
	return &CClosureExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalCClosureExpression(p uintptr) (interface{}, error) {
	return wrapCClosureExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Calendar: GtkCalendar is a widget that displays a Gregorian calendar,
// one month at a time.
//
// !An example GtkCalendar (calendar.png)
//
// A GtkCalendar can be created with gtk.Calendar.New.
//
// The date that is currently displayed can be altered with
// gtk.Calendar.SelectDay().
//
// To place a visual marker on a particular day, use gtk.Calendar.MarkDay() and
// to remove the marker, gtk.Calendar.UnmarkDay(). Alternative, all marks can be
// cleared with gtk.Calendar.ClearMarks().
//
// The selected date can be retrieved from a GtkCalendar using
// gtk.Calendar.GetDate().
//
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
//
// CSS nodes
//
//	calendar.view
//	├── header
//	│   ├── button
//	│   ├── stack.month
//	│   ├── button
//	│   ├── button
//	│   ├── label.year
//	│   ╰── button
//	╰── grid
//	    ╰── label[.day-name][.week-number][.day-number][.other-month][.today]
//
// GtkCalendar has a main node with name calendar. It contains a subnode called
// header containing the widgets for switching between years and months.
//
// The grid subnode contains all day labels, including week numbers on the left
// (marked with the .week-number css class) and day names on top (marked with
// the .day-name css class).
//
// Day labels that belong to the previous or next month get the .other-month
// style class. The label of the current day get the .today style class.
//
// Marked day labels get the :selected state assigned.
type Calendar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Calendar)(nil)
)

func wrapCalendar(obj *coreglib.Object) *Calendar {
	return &Calendar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalCalendar(p uintptr) (interface{}, error) {
	return wrapCalendar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDaySelected is emitted when the user selects a day.
func (calendar *Calendar) ConnectDaySelected(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(calendar, "day-selected", false, unsafe.Pointer(C._gotk4_gtk4_Calendar_ConnectDaySelected), f)
}

// ConnectNextMonth is emitted when the user switched to the next month.
func (calendar *Calendar) ConnectNextMonth(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(calendar, "next-month", false, unsafe.Pointer(C._gotk4_gtk4_Calendar_ConnectNextMonth), f)
}

// ConnectNextYear is emitted when user switched to the next year.
func (calendar *Calendar) ConnectNextYear(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(calendar, "next-year", false, unsafe.Pointer(C._gotk4_gtk4_Calendar_ConnectNextYear), f)
}

// ConnectPrevMonth is emitted when the user switched to the previous month.
func (calendar *Calendar) ConnectPrevMonth(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(calendar, "prev-month", false, unsafe.Pointer(C._gotk4_gtk4_Calendar_ConnectPrevMonth), f)
}

// ConnectPrevYear is emitted when user switched to the previous year.
func (calendar *Calendar) ConnectPrevYear(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(calendar, "prev-year", false, unsafe.Pointer(C._gotk4_gtk4_Calendar_ConnectPrevYear), f)
}

// NewCalendar creates a new calendar, with the current date being selected.
//
// The function returns the following values:
//
//   - calendar: newly GtkCalendar widget.
func NewCalendar() *Calendar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_calendar_new()

	var _calendar *Calendar // out

	_calendar = wrapCalendar(coreglib.Take(unsafe.Pointer(_cret)))

	return _calendar
}

// ClearMarks: remove all visual markers.
func (calendar *Calendar) ClearMarks() {
	var _arg0 *C.GtkCalendar // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(calendar).Native()))

	C.gtk_calendar_clear_marks(_arg0)
	runtime.KeepAlive(calendar)
}

// Date returns a Time representing the shown year, month and the selected day.
//
// The returned date is in the local time zone.
//
// The function returns the following values:
//
//   - dateTime: GDate representing the shown date.
func (self *Calendar) Date() *glib.DateTime {
	var _arg0 *C.GtkCalendar // out
	var _cret *C.GDateTime   // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_calendar_get_date(_arg0)
	runtime.KeepAlive(self)

	var _dateTime *glib.DateTime // out

	_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)

	return _dateTime
}

// DayIsMarked returns if the day of the calendar is already marked.
//
// The function takes the following parameters:
//
//   - day number between 1 and 31.
//
// The function returns the following values:
//
//   - ok: whether the day is marked.
func (calendar *Calendar) DayIsMarked(day uint) bool {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(calendar).Native()))
	_arg1 = C.guint(day)

	_cret = C.gtk_calendar_get_day_is_marked(_arg0, _arg1)
	runtime.KeepAlive(calendar)
	runtime.KeepAlive(day)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowDayNames returns whether self is currently showing the names of the week
// days.
//
// This is the value of the gtk.Calendar:show-day-names property.
//
// The function returns the following values:
//
//   - ok: whether the calendar shows day names.
func (self *Calendar) ShowDayNames() bool {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_calendar_get_show_day_names(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowHeading returns whether self is currently showing the heading.
//
// This is the value of the gtk.Calendar:show-heading property.
//
// The function returns the following values:
//
//   - ok: whether the calendar is showing a heading.
func (self *Calendar) ShowHeading() bool {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_calendar_get_show_heading(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowWeekNumbers returns whether self is showing week numbers right now.
//
// This is the value of the gtk.Calendar:show-week-numbers property.
//
// The function returns the following values:
//
//   - ok: whether the calendar is showing week numbers.
func (self *Calendar) ShowWeekNumbers() bool {
	var _arg0 *C.GtkCalendar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_calendar_get_show_week_numbers(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MarkDay places a visual marker on a particular day.
//
// The function takes the following parameters:
//
//   - day number to mark between 1 and 31.
func (calendar *Calendar) MarkDay(day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(calendar).Native()))
	_arg1 = C.guint(day)

	C.gtk_calendar_mark_day(_arg0, _arg1)
	runtime.KeepAlive(calendar)
	runtime.KeepAlive(day)
}

// SelectDay switches to date's year and month and select its day.
//
// The function takes the following parameters:
//
//   - date representing the day to select.
func (self *Calendar) SelectDay(date *glib.DateTime) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 *C.GDateTime   // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GDateTime)(gextras.StructNative(unsafe.Pointer(date)))

	C.gtk_calendar_select_day(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(date)
}

// SetShowDayNames sets whether the calendar shows day names.
//
// The function takes the following parameters:
//
//   - value: whether to show day names above the day numbers.
func (self *Calendar) SetShowDayNames(value bool) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_calendar_set_show_day_names(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)
}

// SetShowHeading sets whether the calendar should show a heading.
//
// The heading contains the current year and month as well as buttons for
// changing both.
//
// The function takes the following parameters:
//
//   - value: whether to show the heading in the calendar.
func (self *Calendar) SetShowHeading(value bool) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_calendar_set_show_heading(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)
}

// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
//
// The function takes the following parameters:
//
//   - value: whether to show week numbers on the left of the days.
func (self *Calendar) SetShowWeekNumbers(value bool) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if value {
		_arg1 = C.TRUE
	}

	C.gtk_calendar_set_show_week_numbers(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)
}

// UnmarkDay removes the visual marker from a particular day.
//
// The function takes the following parameters:
//
//   - day number to unmark between 1 and 31.
func (calendar *Calendar) UnmarkDay(day uint) {
	var _arg0 *C.GtkCalendar // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkCalendar)(unsafe.Pointer(coreglib.InternObject(calendar).Native()))
	_arg1 = C.guint(day)

	C.gtk_calendar_unmark_day(_arg0, _arg1)
	runtime.KeepAlive(calendar)
	runtime.KeepAlive(day)
}

// CallbackAction: GtkShortcutAction that invokes a callback.
type CallbackAction struct {
	_ [0]func() // equal guard
	ShortcutAction
}

var (
	_ ShortcutActioner = (*CallbackAction)(nil)
)

func wrapCallbackAction(obj *coreglib.Object) *CallbackAction {
	return &CallbackAction{
		ShortcutAction: ShortcutAction{
			Object: obj,
		},
	}
}

func marshalCallbackAction(p uintptr) (interface{}, error) {
	return wrapCallbackAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCallbackAction: create a custom action that calls the given callback when
// activated.
//
// The function takes the following parameters:
//
//   - callback (optional) to call.
//
// The function returns the following values:
//
//   - callbackAction: new shortcut action.
func NewCallbackAction(callback ShortcutFunc) *CallbackAction {
	var _arg1 C.GtkShortcutFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret *C.GtkShortcutAction // in

	if callback != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_ShortcutFunc)
		_arg2 = C.gpointer(gbox.Assign(callback))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.gtk_callback_action_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(callback)

	var _callbackAction *CallbackAction // out

	_callbackAction = wrapCallbackAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _callbackAction
}

// CellAreaOverrides contains methods that are overridable.
type CellAreaOverrides struct {
	// Activate activates area, usually by activating the currently focused
	// cell, however some subclasses which embed widgets in the area can also
	// activate a widget if it currently has the focus.
	//
	// The function takes the following parameters:
	//
	//   - context in context with the current row data.
	//   - widget that area is rendering on.
	//   - cellArea: size and location of area relative to widget’s allocation.
	//   - flags flags for area for this row of data.
	//   - editOnly: if TRUE then only cell renderers that are
	//     GTK_CELL_RENDERER_MODE_EDITABLE will be activated.
	//
	// The function returns the following values:
	//
	//   - ok: whether area was successfully activated.
	Activate func(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool
	// Add adds renderer to area with the default child cell properties.
	//
	// The function takes the following parameters:
	//
	//   - renderer to add to area.
	Add func(renderer CellRendererer)
	// ApplyAttributes applies any connected attributes to the renderers in area
	// by pulling the values from tree_model.
	//
	// The function takes the following parameters:
	//
	//   - treeModel to pull values from.
	//   - iter in tree_model to apply values for.
	//   - isExpander: whether iter has children.
	//   - isExpanded: whether iter is expanded in the view and children are
	//     visible.
	ApplyAttributes func(treeModel TreeModeller, iter *TreeIter, isExpander, isExpanded bool)
	// CopyContext: this is sometimes needed for cases where rows need to
	// share alignments in one orientation but may be separately grouped in the
	// opposing orientation.
	//
	// For instance, IconView creates all icons (rows) to have the same
	// width and the cells theirin to have the same horizontal alignments.
	// However each row of icons may have a separate collective height. IconView
	// uses this to request the heights of each row based on a context which was
	// already used to request all the row widths that are to be displayed.
	//
	// The function takes the following parameters:
	//
	//   - context to copy.
	//
	// The function returns the following values:
	//
	//   - cellAreaContext: newly created CellAreaContext copy of context.
	CopyContext func(context *CellAreaContext) *CellAreaContext
	// CreateContext creates a CellAreaContext to be used with area for all
	// purposes. CellAreaContext stores geometry information for rows for which
	// it was operated on, it is important to use the same context for the same
	// row of data at all times (i.e. one should render and handle events with
	// the same CellAreaContext which was used to request the size of those rows
	// of data).
	//
	// The function returns the following values:
	//
	//   - cellAreaContext: newly created CellAreaContext which can be used with
	//     area.
	CreateContext func() *CellAreaContext
	// Event delegates event handling to a CellArea.
	//
	// The function takes the following parameters:
	//
	//   - context for this row of data.
	//   - widget that area is rendering to.
	//   - event to handle.
	//   - cellArea: widget relative coordinates for area.
	//   - flags for area in this row.
	//
	// The function returns the following values:
	//
	//   - gint: TRUE if the event was handled by area.
	Event func(context *CellAreaContext, widget Widgetter, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) int
	// Focus: this should be called by the area’s owning layout widget when
	// focus is to be passed to area, or moved within area for a given direction
	// and row data.
	//
	// Implementing CellArea classes should implement this method to receive and
	// navigate focus in its own way particular to how it lays out cells.
	//
	// The function takes the following parameters:
	//
	//   - direction: DirectionType.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if focus remains inside area as a result of this call.
	Focus func(direction DirectionType) bool
	// PreferredHeight retrieves a cell area’s initial minimum and natural
	// height.
	//
	// area will store some geometrical information in context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the minimum_height and natural_height of this call but
	// rather to consult gtk_cell_area_context_get_preferred_height() after a
	// series of requests.
	//
	// The function takes the following parameters:
	//
	//   - context to perform this request with.
	//   - widget where area will be rendering.
	//
	// The function returns the following values:
	//
	//   - minimumHeight (optional): location to store the minimum height,
	//     or NULL.
	//   - naturalHeight (optional): location to store the natural height,
	//     or NULL.
	PreferredHeight func(context *CellAreaContext, widget Widgetter) (minimumHeight, naturalHeight int)
	// PreferredHeightForWidth retrieves a cell area’s minimum and natural
	// height if it would be given the specified width.
	//
	// area stores some geometrical information in context along the way while
	// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
	// series of gtk_cell_area_get_preferred_width() requests with context first
	// and then call gtk_cell_area_get_preferred_height_for_width() on each cell
	// area individually to get the height for width of each fully requested
	// row.
	//
	// If at some point, the width of a single row changes, it should
	// be requested with gtk_cell_area_get_preferred_width() again and
	// then the full width of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_width().
	//
	// The function takes the following parameters:
	//
	//   - context which has already been requested for widths.
	//   - widget where area will be rendering.
	//   - width for which to check the height of this area.
	//
	// The function returns the following values:
	//
	//   - minimumHeight (optional): location to store the minimum height,
	//     or NULL.
	//   - naturalHeight (optional): location to store the natural height,
	//     or NULL.
	PreferredHeightForWidth func(context *CellAreaContext, widget Widgetter, width int) (minimumHeight, naturalHeight int)
	// PreferredWidth retrieves a cell area’s initial minimum and natural width.
	//
	// area will store some geometrical information in context along the way;
	// when requesting sizes over an arbitrary number of rows, it’s not
	// important to check the minimum_width and natural_width of this call but
	// rather to consult gtk_cell_area_context_get_preferred_width() after a
	// series of requests.
	//
	// The function takes the following parameters:
	//
	//   - context to perform this request with.
	//   - widget where area will be rendering.
	//
	// The function returns the following values:
	//
	//   - minimumWidth (optional): location to store the minimum width,
	//     or NULL.
	//   - naturalWidth (optional): location to store the natural width,
	//     or NULL.
	PreferredWidth func(context *CellAreaContext, widget Widgetter) (minimumWidth, naturalWidth int)
	// PreferredWidthForHeight retrieves a cell area’s minimum and natural width
	// if it would be given the specified height.
	//
	// area stores some geometrical information in context along the way while
	// calling gtk_cell_area_get_preferred_height(). It’s important to perform
	// a series of gtk_cell_area_get_preferred_height() requests with context
	// first and then call gtk_cell_area_get_preferred_width_for_height() on
	// each cell area individually to get the height for width of each fully
	// requested row.
	//
	// If at some point, the height of a single row changes, it should
	// be requested with gtk_cell_area_get_preferred_height() again and
	// then the full height of the requested rows checked again with
	// gtk_cell_area_context_get_preferred_height().
	//
	// The function takes the following parameters:
	//
	//   - context which has already been requested for widths.
	//   - widget where area will be rendering.
	//   - height for which to check the width of this area.
	//
	// The function returns the following values:
	//
	//   - minimumWidth (optional): location to store the minimum width,
	//     or NULL.
	//   - naturalWidth (optional): location to store the natural width,
	//     or NULL.
	PreferredWidthForHeight func(context *CellAreaContext, widget Widgetter, height int) (minimumWidth, naturalWidth int)
	// RequestMode gets whether the area prefers a height-for-width layout or a
	// width-for-height layout.
	//
	// The function returns the following values:
	//
	//   - sizeRequestMode preferred by area.
	RequestMode func() SizeRequestMode
	// IsActivatable returns whether the area can do anything when activated,
	// after applying new attributes to area.
	//
	// The function returns the following values:
	//
	//   - ok: whether area can do anything when activated.
	IsActivatable func() bool
	// Remove removes renderer from area.
	//
	// The function takes the following parameters:
	//
	//   - renderer to remove from area.
	Remove func(renderer CellRendererer)
	// Snapshot snapshots area’s cells according to area’s layout onto at the
	// given coordinates.
	//
	// The function takes the following parameters:
	//
	//   - context for this row of data.
	//   - widget that area is rendering to.
	//   - snapshot to draw to.
	//   - backgroundArea: widget relative coordinates for area’s background.
	//   - cellArea: widget relative coordinates for area.
	//   - flags for area in this row.
	//   - paintFocus: whether area should paint focus on focused cells for
	//     focused rows or not.
	Snapshot func(context *CellAreaContext, widget Widgetter, snapshot *Snapshot, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)
}

func defaultCellAreaOverrides(v *CellArea) CellAreaOverrides {
	return CellAreaOverrides{
		Activate:                v.activate,
		Add:                     v.add,
		ApplyAttributes:         v.applyAttributes,
		CopyContext:             v.copyContext,
		CreateContext:           v.createContext,
		Event:                   v.event,
		Focus:                   v.focus,
		PreferredHeight:         v.preferredHeight,
		PreferredHeightForWidth: v.preferredHeightForWidth,
		PreferredWidth:          v.preferredWidth,
		PreferredWidthForHeight: v.preferredWidthForHeight,
		RequestMode:             v.requestMode,
		IsActivatable:           v.isActivatable,
		Remove:                  v.remove,
		Snapshot:                v.snapshot,
	}
}

// CellArea: abstract class for laying out GtkCellRenderers
//
// The CellArea is an abstract class for CellLayout widgets (also referred to as
// "layouting widgets") to interface with an arbitrary number of CellRenderers
// and interact with the user for a given TreeModel row.
//
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
//
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
//
// # Requesting area sizes
//
// As outlined in [GtkWidget’s geometry management
// section][geometry-management], GTK uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
//
// When requesting the size of a cell area one needs to calculate the size for
// a handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top
// to bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
//
// It’s also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear “columnized” inside an area
// even when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
//
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, it’s important that the same CellAreaContext
// which was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
//
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
//
//	static gboolean
//	foo_focus (GtkWidget       *widget,
//	           GtkDirectionType direction)
//	{
//	  Foo        *foo  = FOO (widget);
//	  FooPrivate *priv = foo->priv;
//	  int         focus_row;
//	  gboolean    have_focus = FALSE;
//
//	  focus_row = priv->focus_row;
//
//	  if (!gtk_widget_has_focus (widget))
//	    gtk_widget_grab_focus (widget);
//
//	  valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//	  while (valid)
//	    {
//	      gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
//
//	      if (gtk_cell_area_focus (priv->area, direction))
//	        {
//	           priv->focus_row = focus_row;
//	           have_focus = TRUE;
//	           break;
//	        }
//	      else
//	        {
//	          if (direction == GTK_DIR_RIGHT ||
//	              direction == GTK_DIR_LEFT)
//	            break;
//	          else if (direction == GTK_DIR_UP ||
//	                   direction == GTK_DIR_TAB_BACKWARD)
//	           {
//	              if (focus_row == 0)
//	                break;
//	              else
//	               {
//	                  focus_row--;
//	                  valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//	               }
//	            }
//	          else
//	            {
//	              if (focus_row == last_row)
//	                break;
//	              else
//	                {
//	                  focus_row++;
//	                  valid = gtk_tree_model_iter_next (priv->model, &iter);
//	                }
//	            }
//	        }
//	    }
//	    return have_focus;
//	}
//
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
//
// # Cell Properties
//
// The CellArea introduces cell properties for CellRenderers. This provides some
// general interfaces for defining the relationship cell areas have with their
// cells. For instance in a CellAreaBox a cell might “expand” and receive extra
// space when the area is allocated more than its full natural request, or a
// cell might be configured to “align” with adjacent rows which were requested
// and rendered with the same CellAreaContext.
//
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
//
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain
// the value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
type CellArea struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	Buildable
	CellLayout
}

var (
	_ coreglib.Objector = (*CellArea)(nil)
)

// CellAreaer describes types inherited from class CellArea.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type CellAreaer interface {
	coreglib.Objector
	baseCellArea() *CellArea
}

var _ CellAreaer = (*CellArea)(nil)

func init() {
	coreglib.RegisterClassInfo[*CellArea, *CellAreaClass, CellAreaOverrides](
		GTypeCellArea,
		initCellAreaClass,
		wrapCellArea,
		defaultCellAreaOverrides,
	)
}

func initCellAreaClass(gclass unsafe.Pointer, overrides CellAreaOverrides, classInitFunc func(*CellAreaClass)) {
	pclass := (*C.GtkCellAreaClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCellArea))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_activate)
	}

	if overrides.Add != nil {
		pclass.add = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_add)
	}

	if overrides.ApplyAttributes != nil {
		pclass.apply_attributes = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_apply_attributes)
	}

	if overrides.CopyContext != nil {
		pclass.copy_context = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_copy_context)
	}

	if overrides.CreateContext != nil {
		pclass.create_context = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_create_context)
	}

	if overrides.Event != nil {
		pclass.event = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_event)
	}

	if overrides.Focus != nil {
		pclass.focus = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_focus)
	}

	if overrides.PreferredHeight != nil {
		pclass.get_preferred_height = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_height)
	}

	if overrides.PreferredHeightForWidth != nil {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_height_for_width)
	}

	if overrides.PreferredWidth != nil {
		pclass.get_preferred_width = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_width)
	}

	if overrides.PreferredWidthForHeight != nil {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_preferred_width_for_height)
	}

	if overrides.RequestMode != nil {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_get_request_mode)
	}

	if overrides.IsActivatable != nil {
		pclass.is_activatable = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_is_activatable)
	}

	if overrides.Remove != nil {
		pclass.remove = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_remove)
	}

	if overrides.Snapshot != nil {
		pclass.snapshot = (*[0]byte)(C._gotk4_gtk4_CellAreaClass_snapshot)
	}

	if classInitFunc != nil {
		class := (*CellAreaClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCellArea(obj *coreglib.Object) *CellArea {
	return &CellArea{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		CellLayout: CellLayout{
			Object: obj,
		},
	}
}

func marshalCellArea(p uintptr) (interface{}, error) {
	return wrapCellArea(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (area *CellArea) baseCellArea() *CellArea {
	return area
}

// BaseCellArea returns the underlying base object.
func BaseCellArea(obj CellAreaer) *CellArea {
	return obj.baseCellArea()
}

// ConnectAddEditable indicates that editing has started on renderer and that
// editable should be added to the owning cell-layouting widget at cell_area.
func (area *CellArea) ConnectAddEditable(f func(renderer CellRendererer, editable CellEditabler, cellArea *gdk.Rectangle, path string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(area, "add-editable", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectAddEditable), f)
}

// ConnectApplyAttributes: this signal is emitted whenever applying attributes
// to area from model.
func (area *CellArea) ConnectApplyAttributes(f func(model TreeModeller, iter *TreeIter, isExpander, isExpanded bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(area, "apply-attributes", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectApplyAttributes), f)
}

// ConnectFocusChanged indicates that focus changed on this area. This signal is
// emitted either as a result of focus handling or event handling.
//
// It's possible that the signal is emitted even if the currently focused
// renderer did not change, this is because focus may change to the same
// renderer in the same cell area for a different row of data.
func (area *CellArea) ConnectFocusChanged(f func(renderer CellRendererer, path string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(area, "focus-changed", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectFocusChanged), f)
}

// ConnectRemoveEditable indicates that editing finished on renderer and that
// editable should be removed from the owning cell-layouting widget.
func (area *CellArea) ConnectRemoveEditable(f func(renderer CellRendererer, editable CellEditabler)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(area, "remove-editable", false, unsafe.Pointer(C._gotk4_gtk4_CellArea_ConnectRemoveEditable), f)
}

// Activate activates area, usually by activating the currently focused cell,
// however some subclasses which embed widgets in the area can also activate a
// widget if it currently has the focus.
//
// The function takes the following parameters:
//
//   - context in context with the current row data.
//   - widget that area is rendering on.
//   - cellArea: size and location of area relative to widget’s allocation.
//   - flags flags for area for this row of data.
//   - editOnly: if TRUE then only cell renderers that are
//     GTK_CELL_RENDERER_MODE_EDITABLE will be activated.
//
// The function returns the following values:
//
//   - ok: whether area was successfully activated.
func (area *CellArea) Activate(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 C.GtkCellRendererState // out
	var _arg5 C.gboolean             // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = C.GtkCellRendererState(flags)
	if editOnly {
		_arg5 = C.TRUE
	}

	_cret = C.gtk_cell_area_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(editOnly)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateCell: this is used by CellArea subclasses when handling events to
// activate cells, the base CellArea class activates cells for keyboard events
// for free in its own GtkCellArea->activate() implementation.
//
// The function takes the following parameters:
//
//   - widget that area is rendering onto.
//   - renderer in area to activate.
//   - event for which cell activation should occur.
//   - cellArea in widget relative coordinates of renderer for the current row.
//   - flags for renderer.
//
// The function returns the following values:
//
//   - ok: whether cell activation was successful.
func (area *CellArea) ActivateCell(widget Widgetter, renderer CellRendererer, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 *C.GtkCellRenderer     // out
	var _arg3 *C.GdkEvent            // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg3 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg5 = C.GtkCellRendererState(flags)

	_cret = C.gtk_cell_area_activate_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(event)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Add adds renderer to area with the default child cell properties.
//
// The function takes the following parameters:
//
//   - renderer to add to area.
func (area *CellArea) Add(renderer CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gtk_cell_area_add(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// AddFocusSibling adds sibling to renderer’s focusable area, focus will be
// drawn around renderer and all of its siblings if renderer can focus for a
// given row.
//
// Events handled by focus siblings can also activate the given focusable
// renderer.
//
// The function takes the following parameters:
//
//   - renderer expected to have focus.
//   - sibling to add to renderer’s focus area.
func (area *CellArea) AddFocusSibling(renderer, sibling CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))

	C.gtk_cell_area_add_focus_sibling(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(sibling)
}

// ApplyAttributes applies any connected attributes to the renderers in area by
// pulling the values from tree_model.
//
// The function takes the following parameters:
//
//   - treeModel to pull values from.
//   - iter in tree_model to apply values for.
//   - isExpander: whether iter has children.
//   - isExpanded: whether iter is expanded in the view and children are
//     visible.
func (area *CellArea) ApplyAttributes(treeModel TreeModeller, iter *TreeIter, isExpander, isExpanded bool) {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.gboolean      // out
	var _arg4 C.gboolean      // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_apply_attributes(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(isExpander)
	runtime.KeepAlive(isExpanded)
}

// AttributeConnect connects an attribute to apply values from column for the
// TreeModel in use.
//
// The function takes the following parameters:
//
//   - renderer to connect an attribute for.
//   - attribute name.
//   - column column to fetch attribute values from.
func (area *CellArea) AttributeConnect(renderer CellRendererer, attribute string, column int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 C.int              // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(column)

	C.gtk_cell_area_attribute_connect(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(column)
}

// AttributeDisconnect disconnects attribute for the renderer in area so that
// attribute will no longer be updated with values from the model.
//
// The function takes the following parameters:
//
//   - renderer to disconnect an attribute for.
//   - attribute name.
func (area *CellArea) AttributeDisconnect(renderer CellRendererer, attribute string) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_cell_area_attribute_disconnect(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(attribute)
}

// AttributeGetColumn returns the model column that an attribute has been mapped
// to, or -1 if the attribute is not mapped.
//
// The function takes the following parameters:
//
//   - renderer: CellRenderer.
//   - attribute on the renderer.
//
// The function returns the following values:
//
//   - gint: model column, or -1.
func (area *CellArea) AttributeGetColumn(renderer CellRendererer, attribute string) int {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _cret C.int              // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_cell_area_attribute_get_column(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(attribute)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CellGetProperty gets the value of a cell property for renderer in area.
//
// The function takes the following parameters:
//
//   - renderer inside area.
//   - propertyName: name of the property to get.
//   - value: location to return the value.
func (area *CellArea) CellGetProperty(renderer CellRendererer, propertyName string, value *coreglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_cell_area_cell_get_property(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// CellSetProperty sets a cell property for renderer in area.
//
// The function takes the following parameters:
//
//   - renderer inside area.
//   - propertyName: name of the cell property to set.
//   - value to set the cell property to.
func (area *CellArea) CellSetProperty(renderer CellRendererer, propertyName string, value *coreglib.Value) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.char            // out
	var _arg3 *C.GValue          // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_cell_area_cell_set_property(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(propertyName)
	runtime.KeepAlive(value)
}

// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the opposing
// orientation.
//
// For instance, IconView creates all icons (rows) to have the same width and
// the cells theirin to have the same horizontal alignments. However each row of
// icons may have a separate collective height. IconView uses this to request
// the heights of each row based on a context which was already used to request
// all the row widths that are to be displayed.
//
// The function takes the following parameters:
//
//   - context to copy.
//
// The function returns the following values:
//
//   - cellAreaContext: newly created CellAreaContext copy of context.
func (area *CellArea) CopyContext(context *CellAreaContext) *CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_cell_area_copy_context(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)

	var _cellAreaContext *CellAreaContext // out

	_cellAreaContext = wrapCellAreaContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cellAreaContext
}

// CreateContext creates a CellAreaContext to be used with area for all
// purposes. CellAreaContext stores geometry information for rows for which it
// was operated on, it is important to use the same context for the same row of
// data at all times (i.e. one should render and handle events with the same
// CellAreaContext which was used to request the size of those rows of data).
//
// The function returns the following values:
//
//   - cellAreaContext: newly created CellAreaContext which can be used with
//     area.
func (area *CellArea) CreateContext() *CellAreaContext {
	var _arg0 *C.GtkCellArea        // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_create_context(_arg0)
	runtime.KeepAlive(area)

	var _cellAreaContext *CellAreaContext // out

	_cellAreaContext = wrapCellAreaContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cellAreaContext
}

// Event delegates event handling to a CellArea.
//
// The function takes the following parameters:
//
//   - context for this row of data.
//   - widget that area is rendering to.
//   - event to handle.
//   - cellArea: widget relative coordinates for area.
//   - flags for area in this row.
//
// The function returns the following values:
//
//   - gint: TRUE if the event was handled by area.
func (area *CellArea) Event(context *CellAreaContext, widget Widgetter, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) int {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkEvent            // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out
	var _cret C.int                  // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg5 = C.GtkCellRendererState(flags)

	_cret = C.gtk_cell_area_event(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Focus: this should be called by the area’s owning layout widget when focus
// is to be passed to area, or moved within area for a given direction and row
// data.
//
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
//
// The function takes the following parameters:
//
//   - direction: DirectionType.
//
// The function returns the following values:
//
//   - ok: TRUE if focus remains inside area as a result of this call.
func (area *CellArea) Focus(direction DirectionType) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_cell_area_focus(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEach calls callback for every CellRenderer in area.
//
// The function takes the following parameters:
//
//   - callback to call.
func (area *CellArea) ForEach(callback CellCallback) {
	var _arg0 *C.GtkCellArea    // out
	var _arg1 C.GtkCellCallback // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_CellCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_cell_area_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(callback)
}

// ForEachAlloc calls callback for every CellRenderer in area with the allocated
// rectangle inside cell_area.
//
// The function takes the following parameters:
//
//   - context for this row of data.
//   - widget that area is rendering to.
//   - cellArea: widget relative coordinates and size for area.
//   - backgroundArea: widget relative coordinates of the background area.
//   - callback to call.
func (area *CellArea) ForEachAlloc(context *CellAreaContext, widget Widgetter, cellArea, backgroundArea *gdk.Rectangle, callback CellAllocCallback) {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellAllocCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*[0]byte)(C._gotk4_gtk4_CellAllocCallback)
	_arg6 = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_arg6))

	C.gtk_cell_area_foreach_alloc(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(callback)
}

// CellAllocation derives the allocation of renderer inside area if area were to
// be renderered in cell_area.
//
// The function takes the following parameters:
//
//   - context used to hold sizes for area.
//   - widget that area is rendering on.
//   - renderer to get the allocation for.
//   - cellArea: whole allocated area for area in widget for this row.
//
// The function returns the following values:
//
//   - allocation: where to store the allocation for renderer.
func (area *CellArea) CellAllocation(context *CellAreaContext, widget Widgetter, renderer CellRendererer, cellArea *gdk.Rectangle) *gdk.Rectangle {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GtkCellRenderer    // out
	var _arg4 *C.GdkRectangle       // out
	var _arg5 C.GdkRectangle        // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))

	C.gtk_cell_area_get_cell_allocation(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(cellArea)

	var _allocation *gdk.Rectangle // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg5))))

	return _allocation
}

// CellAtPosition gets the CellRenderer at x and y coordinates inside area and
// optionally returns the full cell allocation for it inside cell_area.
//
// The function takes the following parameters:
//
//   - context used to hold sizes for area.
//   - widget that area is rendering on.
//   - cellArea: whole allocated area for area in widget for this row.
//   - x position.
//   - y position.
//
// The function returns the following values:
//
//   - allocArea (optional): where to store the inner allocated area of the
//     returned cell renderer, or NULL.
//   - cellRenderer at x and y.
func (area *CellArea) CellAtPosition(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, x, y int) (*gdk.Rectangle, CellRendererer) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 *C.GdkRectangle       // out
	var _arg4 C.int                 // out
	var _arg5 C.int                 // out
	var _arg6 C.GdkRectangle        // in
	var _cret *C.GtkCellRenderer    // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = C.int(x)
	_arg5 = C.int(y)

	_cret = C.gtk_cell_area_get_cell_at_position(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_arg6)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _allocArea *gdk.Rectangle    // out
	var _cellRenderer CellRendererer // out

	_allocArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg6))))
	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cellRenderer = rv
	}

	return _allocArea, _cellRenderer
}

// CurrentPathString gets the current TreePath string for the currently applied
// TreeIter, this is implicitly updated when gtk_cell_area_apply_attributes() is
// called and can be used to interact with renderers from CellArea subclasses.
//
// The function returns the following values:
//
//   - utf8: current TreePath string for the current attributes applied to area.
//     This string belongs to the area and should not be freed.
func (area *CellArea) CurrentPathString() string {
	var _arg0 *C.GtkCellArea // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_current_path_string(_arg0)
	runtime.KeepAlive(area)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// EditWidget gets the CellEditable widget currently used to edit the currently
// edited cell.
//
// The function returns the following values:
//
//   - cellEditable: currently active CellEditable widget.
func (area *CellArea) EditWidget() *CellEditable {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellEditable // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_edit_widget(_arg0)
	runtime.KeepAlive(area)

	var _cellEditable *CellEditable // out

	_cellEditable = wrapCellEditable(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellEditable
}

// EditedCell gets the CellRenderer in area that is currently being edited.
//
// The function returns the following values:
//
//   - cellRenderer: currently edited CellRenderer.
func (area *CellArea) EditedCell() CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_edited_cell(_arg0)
	runtime.KeepAlive(area)

	var _cellRenderer CellRendererer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cellRenderer = rv
	}

	return _cellRenderer
}

// FocusCell retrieves the currently focused cell for area.
//
// The function returns the following values:
//
//   - cellRenderer: currently focused cell in area.
func (area *CellArea) FocusCell() CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_focus_cell(_arg0)
	runtime.KeepAlive(area)

	var _cellRenderer CellRendererer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellRendererer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellRendererer)
			return ok
		})
		rv, ok := casted.(CellRendererer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
		}
		_cellRenderer = rv
	}

	return _cellRenderer
}

// FocusFromSibling gets the CellRenderer which is expected to be focusable for
// which renderer is, or may be a sibling.
//
// This is handy for CellArea subclasses when handling events, after determining
// the renderer at the event location it can then chose to activate the focus
// cell for which the event cell may have been a sibling.
//
// The function takes the following parameters:
//
//   - renderer: CellRenderer.
//
// The function returns the following values:
//
//   - cellRenderer (optional) for which renderer is a sibling, or NULL.
func (area *CellArea) FocusFromSibling(renderer CellRendererer) CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret *C.GtkCellRenderer // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_cell_area_get_focus_from_sibling(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)

	var _cellRenderer CellRendererer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			_cellRenderer = rv
		}
	}

	return _cellRenderer
}

// FocusSiblings gets the focus sibling cell renderers for renderer.
//
// The function takes the following parameters:
//
//   - renderer expected to have focus.
//
// The function returns the following values:
//
//   - list of CellRenderers. The returned list is internal and should not be
//     freed.
func (area *CellArea) FocusSiblings(renderer CellRendererer) []CellRendererer {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret *C.GList           // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_cell_area_get_focus_siblings(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)

	var _list []CellRendererer // out

	_list = make([]CellRendererer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkCellRenderer)(v)
		var dst CellRendererer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.CellRendererer is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// PreferredHeight retrieves a cell area’s initial minimum and natural height.
//
// area will store some geometrical information in context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not important
// to check the minimum_height and natural_height of this call but rather
// to consult gtk_cell_area_context_get_preferred_height() after a series of
// requests.
//
// The function takes the following parameters:
//
//   - context to perform this request with.
//   - widget where area will be rendering.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location to store the minimum height, or NULL.
//   - naturalHeight (optional): location to store the natural height, or NULL.
func (area *CellArea) PreferredHeight(context *CellAreaContext, widget Widgetter) (minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_cell_area_get_preferred_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg3)
	_naturalHeight = int(_arg4)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightForWidth retrieves a cell area’s minimum and natural height if
// it would be given the specified width.
//
// area stores some geometrical information in context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with context first and
// then call gtk_cell_area_get_preferred_height_for_width() on each cell area
// individually to get the height for width of each fully requested row.
//
// If at some point, the width of a single row changes, it should
// be requested with gtk_cell_area_get_preferred_width() again and
// then the full width of the requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
//
// The function takes the following parameters:
//
//   - context which has already been requested for widths.
//   - widget where area will be rendering.
//   - width for which to check the height of this area.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location to store the minimum height, or NULL.
//   - naturalHeight (optional): location to store the natural height, or NULL.
func (area *CellArea) PreferredHeightForWidth(context *CellAreaContext, widget Widgetter, width int) (minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = C.int(width)

	C.gtk_cell_area_get_preferred_height_for_width(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg4)
	_naturalHeight = int(_arg5)

	return _minimumHeight, _naturalHeight
}

// PreferredWidth retrieves a cell area’s initial minimum and natural width.
//
// area will store some geometrical information in context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not important to
// check the minimum_width and natural_width of this call but rather to consult
// gtk_cell_area_context_get_preferred_width() after a series of requests.
//
// The function takes the following parameters:
//
//   - context to perform this request with.
//   - widget where area will be rendering.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location to store the minimum width, or NULL.
//   - naturalWidth (optional): location to store the natural width, or NULL.
func (area *CellArea) PreferredWidth(context *CellAreaContext, widget Widgetter) (minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_cell_area_get_preferred_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg3)
	_naturalWidth = int(_arg4)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight retrieves a cell area’s minimum and natural width if
// it would be given the specified height.
//
// area stores some geometrical information in context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with context first
// and then call gtk_cell_area_get_preferred_width_for_height() on each cell
// area individually to get the height for width of each fully requested row.
//
// If at some point, the height of a single row changes, it should
// be requested with gtk_cell_area_get_preferred_height() again and
// then the full height of the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
//
// The function takes the following parameters:
//
//   - context which has already been requested for widths.
//   - widget where area will be rendering.
//   - height for which to check the width of this area.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location to store the minimum width, or NULL.
//   - naturalWidth (optional): location to store the natural width, or NULL.
func (area *CellArea) PreferredWidthForHeight(context *CellAreaContext, widget Widgetter, height int) (minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = C.int(height)

	C.gtk_cell_area_get_preferred_width_for_height(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg4)
	_naturalWidth = int(_arg5)

	return _minimumWidth, _naturalWidth
}

// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
//
// The function returns the following values:
//
//   - sizeRequestMode preferred by area.
func (area *CellArea) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkCellArea       // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_get_request_mode(_arg0)
	runtime.KeepAlive(area)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// HasRenderer checks if area contains renderer.
//
// The function takes the following parameters:
//
//   - renderer to check.
//
// The function returns the following values:
//
//   - ok: TRUE if renderer is in the area.
func (area *CellArea) HasRenderer(renderer CellRendererer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	_cret = C.gtk_cell_area_has_renderer(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InnerCellArea: this is a convenience function for CellArea implementations
// to get the inner area where a given CellRenderer will be rendered. It removes
// any padding previously added by gtk_cell_area_request_renderer().
//
// The function takes the following parameters:
//
//   - widget that area is rendering onto.
//   - cellArea: widget relative coordinates where one of area’s cells is to be
//     placed.
//
// The function returns the following values:
//
//   - innerArea: return location for the inner cell area.
func (area *CellArea) InnerCellArea(widget Widgetter, cellArea *gdk.Rectangle) *gdk.Rectangle {
	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GdkRectangle // out
	var _arg3 C.GdkRectangle  // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))

	C.gtk_cell_area_inner_cell_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(area)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)

	var _innerArea *gdk.Rectangle // out

	_innerArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _innerArea
}

// IsActivatable returns whether the area can do anything when activated,
// after applying new attributes to area.
//
// The function returns the following values:
//
//   - ok: whether area can do anything when activated.
func (area *CellArea) IsActivatable() bool {
	var _arg0 *C.GtkCellArea // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_cell_area_is_activatable(_arg0)
	runtime.KeepAlive(area)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocusSibling returns whether sibling is one of renderer’s focus siblings
// (see gtk_cell_area_add_focus_sibling()).
//
// The function takes the following parameters:
//
//   - renderer expected to have focus.
//   - sibling to check against renderer’s sibling list.
//
// The function returns the following values:
//
//   - ok: TRUE if sibling is a focus sibling of renderer.
func (area *CellArea) IsFocusSibling(renderer, sibling CellRendererer) bool {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))

	_cret = C.gtk_cell_area_is_focus_sibling(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(sibling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes renderer from area.
//
// The function takes the following parameters:
//
//   - renderer to remove from area.
func (area *CellArea) Remove(renderer CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gtk_cell_area_remove(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// RemoveFocusSibling removes sibling from renderer’s focus sibling list (see
// gtk_cell_area_add_focus_sibling()).
//
// The function takes the following parameters:
//
//   - renderer expected to have focus.
//   - sibling to remove from renderer’s focus area.
func (area *CellArea) RemoveFocusSibling(renderer, sibling CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))

	C.gtk_cell_area_remove_focus_sibling(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(sibling)
}

// RequestRenderer: this is a convenience function for CellArea implementations
// to request size for cell renderers. It’s important to use this function to
// request size and then use gtk_cell_area_inner_cell_area() at render and event
// time since this function will add padding around the cell for focus painting.
//
// The function takes the following parameters:
//
//   - renderer to request size for.
//   - orientation in which to request size.
//   - widget that area is rendering onto.
//   - forSize: allocation contextual size to request for, or -1 if the base
//     request for the orientation is to be returned.
//
// The function returns the following values:
//
//   - minimumSize (optional): location to store the minimum size, or NULL.
//   - naturalSize (optional): location to store the natural size, or NULL.
func (area *CellArea) RequestRenderer(renderer CellRendererer, orientation Orientation, widget Widgetter, forSize int) (minimumSize, naturalSize int) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.GtkOrientation   // out
	var _arg3 *C.GtkWidget       // out
	var _arg4 C.int              // out
	var _arg5 C.int              // in
	var _arg6 C.int              // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg2 = C.GtkOrientation(orientation)
	_arg3 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg4 = C.int(forSize)

	C.gtk_cell_area_request_renderer(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(forSize)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = int(_arg5)
	_naturalSize = int(_arg6)

	return _minimumSize, _naturalSize
}

// SetFocusCell: explicitly sets the currently focused cell to renderer.
//
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
//
// The function takes the following parameters:
//
//   - renderer to give focus to.
func (area *CellArea) SetFocusCell(renderer CellRendererer) {
	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C.gtk_cell_area_set_focus_cell(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// Snapshot snapshots area’s cells according to area’s layout onto at the given
// coordinates.
//
// The function takes the following parameters:
//
//   - context for this row of data.
//   - widget that area is rendering to.
//   - snapshot to draw to.
//   - backgroundArea: widget relative coordinates for area’s background.
//   - cellArea: widget relative coordinates for area.
//   - flags for area in this row.
//   - paintFocus: whether area should paint focus on focused cells for focused
//     rows or not.
func (area *CellArea) Snapshot(context *CellAreaContext, widget Widgetter, snapshot *Snapshot, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GtkSnapshot         // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _arg7 C.gboolean             // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg6 = C.GtkCellRendererState(flags)
	if paintFocus {
		_arg7 = C.TRUE
	}

	C.gtk_cell_area_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(paintFocus)
}

// StopEditing: explicitly stops the editing of the currently edited cell.
//
// If canceled is TRUE, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will be
// emitted on the current edit widget.
//
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
//
// The function takes the following parameters:
//
//   - canceled: whether editing was canceled.
func (area *CellArea) StopEditing(canceled bool) {
	var _arg0 *C.GtkCellArea // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	C.gtk_cell_area_stop_editing(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(canceled)
}

// Activate activates area, usually by activating the currently focused cell,
// however some subclasses which embed widgets in the area can also activate a
// widget if it currently has the focus.
//
// The function takes the following parameters:
//
//   - context in context with the current row data.
//   - widget that area is rendering on.
//   - cellArea: size and location of area relative to widget’s allocation.
//   - flags flags for area for this row of data.
//   - editOnly: if TRUE then only cell renderers that are
//     GTK_CELL_RENDERER_MODE_EDITABLE will be activated.
//
// The function returns the following values:
//
//   - ok: whether area was successfully activated.
func (area *CellArea) activate(context *CellAreaContext, widget Widgetter, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.activate

	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 C.GtkCellRendererState // out
	var _arg5 C.gboolean             // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = C.GtkCellRendererState(flags)
	if editOnly {
		_arg5 = C.TRUE
	}

	_cret = C._gotk4_gtk4_CellArea_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(editOnly)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Add adds renderer to area with the default child cell properties.
//
// The function takes the following parameters:
//
//   - renderer to add to area.
func (area *CellArea) add(renderer CellRendererer) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.add

	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C._gotk4_gtk4_CellArea_virtual_add(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// applyAttributes applies any connected attributes to the renderers in area by
// pulling the values from tree_model.
//
// The function takes the following parameters:
//
//   - treeModel to pull values from.
//   - iter in tree_model to apply values for.
//   - isExpander: whether iter has children.
//   - isExpanded: whether iter is expanded in the view and children are
//     visible.
func (area *CellArea) applyAttributes(treeModel TreeModeller, iter *TreeIter, isExpander, isExpanded bool) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.apply_attributes

	var _arg0 *C.GtkCellArea  // out
	var _arg1 *C.GtkTreeModel // out
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.gboolean      // out
	var _arg4 C.gboolean      // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C._gotk4_gtk4_CellArea_virtual_apply_attributes(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(isExpander)
	runtime.KeepAlive(isExpanded)
}

// copyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the opposing
// orientation.
//
// For instance, IconView creates all icons (rows) to have the same width and
// the cells theirin to have the same horizontal alignments. However each row of
// icons may have a separate collective height. IconView uses this to request
// the heights of each row based on a context which was already used to request
// all the row widths that are to be displayed.
//
// The function takes the following parameters:
//
//   - context to copy.
//
// The function returns the following values:
//
//   - cellAreaContext: newly created CellAreaContext copy of context.
func (area *CellArea) copyContext(context *CellAreaContext) *CellAreaContext {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.copy_context

	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gtk4_CellArea_virtual_copy_context(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)

	var _cellAreaContext *CellAreaContext // out

	_cellAreaContext = wrapCellAreaContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cellAreaContext
}

// createContext creates a CellAreaContext to be used with area for all
// purposes. CellAreaContext stores geometry information for rows for which it
// was operated on, it is important to use the same context for the same row of
// data at all times (i.e. one should render and handle events with the same
// CellAreaContext which was used to request the size of those rows of data).
//
// The function returns the following values:
//
//   - cellAreaContext: newly created CellAreaContext which can be used with
//     area.
func (area *CellArea) createContext() *CellAreaContext {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.create_context

	var _arg0 *C.GtkCellArea        // out
	var _cret *C.GtkCellAreaContext // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C._gotk4_gtk4_CellArea_virtual_create_context(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(area)

	var _cellAreaContext *CellAreaContext // out

	_cellAreaContext = wrapCellAreaContext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cellAreaContext
}

// Event delegates event handling to a CellArea.
//
// The function takes the following parameters:
//
//   - context for this row of data.
//   - widget that area is rendering to.
//   - event to handle.
//   - cellArea: widget relative coordinates for area.
//   - flags for area in this row.
//
// The function returns the following values:
//
//   - gint: TRUE if the event was handled by area.
func (area *CellArea) event(context *CellAreaContext, widget Widgetter, event gdk.Eventer, cellArea *gdk.Rectangle, flags CellRendererState) int {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.event

	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkEvent            // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out
	var _cret C.int                  // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg5 = C.GtkCellRendererState(flags)

	_cret = C._gotk4_gtk4_CellArea_virtual_event(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(event)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Focus: this should be called by the area’s owning layout widget when focus
// is to be passed to area, or moved within area for a given direction and row
// data.
//
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
//
// The function takes the following parameters:
//
//   - direction: DirectionType.
//
// The function returns the following values:
//
//   - ok: TRUE if focus remains inside area as a result of this call.
func (area *CellArea) focus(direction DirectionType) bool {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.focus

	var _arg0 *C.GtkCellArea     // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C._gotk4_gtk4_CellArea_virtual_focus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// forEach calls callback for every CellRenderer in area.
//
// The function takes the following parameters:
//
//   - callback to call.
func (area *CellArea) forEach(callback CellCallback) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.foreach

	var _arg0 *C.GtkCellArea    // out
	var _arg1 C.GtkCellCallback // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_CellCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_arg2))

	C._gotk4_gtk4_CellArea_virtual_foreach(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(callback)
}

// forEachAlloc calls callback for every CellRenderer in area with the allocated
// rectangle inside cell_area.
//
// The function takes the following parameters:
//
//   - context for this row of data.
//   - widget that area is rendering to.
//   - cellArea: widget relative coordinates and size for area.
//   - backgroundArea: widget relative coordinates of the background area.
//   - callback to call.
func (area *CellArea) forEachAlloc(context *CellAreaContext, widget Widgetter, cellArea, backgroundArea *gdk.Rectangle, callback CellAllocCallback) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.foreach_alloc

	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellAllocCallback // out
	var _arg6 C.gpointer

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*[0]byte)(C._gotk4_gtk4_CellAllocCallback)
	_arg6 = C.gpointer(gbox.Assign(callback))
	defer gbox.Delete(uintptr(_arg6))

	C._gotk4_gtk4_CellArea_virtual_foreach_alloc(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(callback)
}

// preferredHeight retrieves a cell area’s initial minimum and natural height.
//
// area will store some geometrical information in context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not important
// to check the minimum_height and natural_height of this call but rather
// to consult gtk_cell_area_context_get_preferred_height() after a series of
// requests.
//
// The function takes the following parameters:
//
//   - context to perform this request with.
//   - widget where area will be rendering.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location to store the minimum height, or NULL.
//   - naturalHeight (optional): location to store the natural height, or NULL.
func (area *CellArea) preferredHeight(context *CellAreaContext, widget Widgetter) (minimumHeight, naturalHeight int) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.get_preferred_height

	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_CellArea_virtual_get_preferred_height(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg3)
	_naturalHeight = int(_arg4)

	return _minimumHeight, _naturalHeight
}

// preferredHeightForWidth retrieves a cell area’s minimum and natural height if
// it would be given the specified width.
//
// area stores some geometrical information in context along the way while
// calling gtk_cell_area_get_preferred_width(). It’s important to perform a
// series of gtk_cell_area_get_preferred_width() requests with context first and
// then call gtk_cell_area_get_preferred_height_for_width() on each cell area
// individually to get the height for width of each fully requested row.
//
// If at some point, the width of a single row changes, it should
// be requested with gtk_cell_area_get_preferred_width() again and
// then the full width of the requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
//
// The function takes the following parameters:
//
//   - context which has already been requested for widths.
//   - widget where area will be rendering.
//   - width for which to check the height of this area.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location to store the minimum height, or NULL.
//   - naturalHeight (optional): location to store the natural height, or NULL.
func (area *CellArea) preferredHeightForWidth(context *CellAreaContext, widget Widgetter, width int) (minimumHeight, naturalHeight int) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.get_preferred_height_for_width

	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = C.int(width)

	C._gotk4_gtk4_CellArea_virtual_get_preferred_height_for_width(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg4)
	_naturalHeight = int(_arg5)

	return _minimumHeight, _naturalHeight
}

// preferredWidth retrieves a cell area’s initial minimum and natural width.
//
// area will store some geometrical information in context along the way;
// when requesting sizes over an arbitrary number of rows, it’s not important to
// check the minimum_width and natural_width of this call but rather to consult
// gtk_cell_area_context_get_preferred_width() after a series of requests.
//
// The function takes the following parameters:
//
//   - context to perform this request with.
//   - widget where area will be rendering.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location to store the minimum width, or NULL.
//   - naturalWidth (optional): location to store the natural width, or NULL.
func (area *CellArea) preferredWidth(context *CellAreaContext, widget Widgetter) (minimumWidth, naturalWidth int) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.get_preferred_width

	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // in
	var _arg4 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_CellArea_virtual_get_preferred_width(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg3)
	_naturalWidth = int(_arg4)

	return _minimumWidth, _naturalWidth
}

// preferredWidthForHeight retrieves a cell area’s minimum and natural width if
// it would be given the specified height.
//
// area stores some geometrical information in context along the way while
// calling gtk_cell_area_get_preferred_height(). It’s important to perform a
// series of gtk_cell_area_get_preferred_height() requests with context first
// and then call gtk_cell_area_get_preferred_width_for_height() on each cell
// area individually to get the height for width of each fully requested row.
//
// If at some point, the height of a single row changes, it should
// be requested with gtk_cell_area_get_preferred_height() again and
// then the full height of the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
//
// The function takes the following parameters:
//
//   - context which has already been requested for widths.
//   - widget where area will be rendering.
//   - height for which to check the width of this area.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location to store the minimum width, or NULL.
//   - naturalWidth (optional): location to store the natural width, or NULL.
func (area *CellArea) preferredWidthForHeight(context *CellAreaContext, widget Widgetter, height int) (minimumWidth, naturalWidth int) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.get_preferred_width_for_height

	var _arg0 *C.GtkCellArea        // out
	var _arg1 *C.GtkCellAreaContext // out
	var _arg2 *C.GtkWidget          // out
	var _arg3 C.int                 // out
	var _arg4 C.int                 // in
	var _arg5 C.int                 // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = C.int(height)

	C._gotk4_gtk4_CellArea_virtual_get_preferred_width_for_height(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg4)
	_naturalWidth = int(_arg5)

	return _minimumWidth, _naturalWidth
}

// requestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
//
// The function returns the following values:
//
//   - sizeRequestMode preferred by area.
func (area *CellArea) requestMode() SizeRequestMode {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.get_request_mode

	var _arg0 *C.GtkCellArea       // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C._gotk4_gtk4_CellArea_virtual_get_request_mode(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(area)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// isActivatable returns whether the area can do anything when activated,
// after applying new attributes to area.
//
// The function returns the following values:
//
//   - ok: whether area can do anything when activated.
func (area *CellArea) isActivatable() bool {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.is_activatable

	var _arg0 *C.GtkCellArea // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C._gotk4_gtk4_CellArea_virtual_is_activatable(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(area)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes renderer from area.
//
// The function takes the following parameters:
//
//   - renderer to remove from area.
func (area *CellArea) remove(renderer CellRendererer) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.remove

	var _arg0 *C.GtkCellArea     // out
	var _arg1 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))

	C._gotk4_gtk4_CellArea_virtual_remove(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(renderer)
}

// Snapshot snapshots area’s cells according to area’s layout onto at the given
// coordinates.
//
// The function takes the following parameters:
//
//   - context for this row of data.
//   - widget that area is rendering to.
//   - snapshot to draw to.
//   - backgroundArea: widget relative coordinates for area’s background.
//   - cellArea: widget relative coordinates for area.
//   - flags for area in this row.
//   - paintFocus: whether area should paint focus on focused cells for focused
//     rows or not.
func (area *CellArea) snapshot(context *CellAreaContext, widget Widgetter, snapshot *Snapshot, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool) {
	gclass := (*C.GtkCellAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.snapshot

	var _arg0 *C.GtkCellArea         // out
	var _arg1 *C.GtkCellAreaContext  // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GtkSnapshot         // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _arg7 C.gboolean             // out

	_arg0 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg6 = C.GtkCellRendererState(flags)
	if paintFocus {
		_arg7 = C.TRUE
	}

	C._gotk4_gtk4_CellArea_virtual_snapshot(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(paintFocus)
}

// CellAreaBox: cell area that renders GtkCellRenderers into a row or a column
//
// The CellAreaBox renders cell renderers into a row or a column depending on
// its Orientation.
//
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox.
// There are two reference positions: the start and the end of the box. When
// the CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
//
// Alignments of CellRenderers rendered in adjacent rows can be configured
// by configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
type CellAreaBox struct {
	_ [0]func() // equal guard
	CellArea

	*coreglib.Object
	Orientable
}

var (
	_ CellAreaer        = (*CellAreaBox)(nil)
	_ coreglib.Objector = (*CellAreaBox)(nil)
)

func wrapCellAreaBox(obj *coreglib.Object) *CellAreaBox {
	return &CellAreaBox{
		CellArea: CellArea{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Buildable: Buildable{
				Object: obj,
			},
			CellLayout: CellLayout{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalCellAreaBox(p uintptr) (interface{}, error) {
	return wrapCellAreaBox(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCellAreaBox creates a new CellAreaBox.
//
// The function returns the following values:
//
//   - cellAreaBox: newly created CellAreaBox.
func NewCellAreaBox() *CellAreaBox {
	var _cret *C.GtkCellArea // in

	_cret = C.gtk_cell_area_box_new()

	var _cellAreaBox *CellAreaBox // out

	_cellAreaBox = wrapCellAreaBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellAreaBox
}

// Spacing gets the spacing added between cell renderers.
//
// The function returns the following values:
//
//   - gint: space added between cell renderers in box.
func (box *CellAreaBox) Spacing() int {
	var _arg0 *C.GtkCellAreaBox // out
	var _cret C.int             // in

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_cell_area_box_get_spacing(_arg0)
	runtime.KeepAlive(box)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PackEnd adds renderer to box, packed with reference to the end of box.
//
// The renderer is packed after (away from end of) any other CellRenderer packed
// with reference to the end of box.
//
// The function takes the following parameters:
//
//   - renderer to add.
//   - expand: whether renderer should receive extra space when the area
//     receives more than its natural size.
//   - align: whether renderer should be aligned in adjacent rows.
//   - fixed: whether renderer should have the same size in all rows.
func (box *CellAreaBox) PackEnd(renderer CellRendererer, expand, align, fixed bool) {
	var _arg0 *C.GtkCellAreaBox  // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out
	var _arg3 C.gboolean         // out
	var _arg4 C.gboolean         // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if align {
		_arg3 = C.TRUE
	}
	if fixed {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(box)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(expand)
	runtime.KeepAlive(align)
	runtime.KeepAlive(fixed)
}

// PackStart adds renderer to box, packed with reference to the start of box.
//
// The renderer is packed after any other CellRenderer packed with reference to
// the start of box.
//
// The function takes the following parameters:
//
//   - renderer to add.
//   - expand: whether renderer should receive extra space when the area
//     receives more than its natural size.
//   - align: whether renderer should be aligned in adjacent rows.
//   - fixed: whether renderer should have the same size in all rows.
func (box *CellAreaBox) PackStart(renderer CellRendererer, expand, align, fixed bool) {
	var _arg0 *C.GtkCellAreaBox  // out
	var _arg1 *C.GtkCellRenderer // out
	var _arg2 C.gboolean         // out
	var _arg3 C.gboolean         // out
	var _arg4 C.gboolean         // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	if expand {
		_arg2 = C.TRUE
	}
	if align {
		_arg3 = C.TRUE
	}
	if fixed {
		_arg4 = C.TRUE
	}

	C.gtk_cell_area_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(box)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(expand)
	runtime.KeepAlive(align)
	runtime.KeepAlive(fixed)
}

// SetSpacing sets the spacing to add between cell renderers in box.
//
// The function takes the following parameters:
//
//   - spacing: space to add between CellRenderers.
func (box *CellAreaBox) SetSpacing(spacing int) {
	var _arg0 *C.GtkCellAreaBox // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.int(spacing)

	C.gtk_cell_area_box_set_spacing(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(spacing)
}

// CellAreaContextOverrides contains methods that are overridable.
type CellAreaContextOverrides struct {
	// Allocate allocates a width and/or a height for all rows which are to be
	// rendered with context.
	//
	// Usually allocation is performed only horizontally or sometimes vertically
	// since a group of rows are usually rendered side by side vertically
	// or horizontally and share either the same width or the same height.
	// Sometimes they are allocated in both horizontal and vertical orientations
	// producing a homogeneous effect of the rows. This is generally the case
	// for TreeView when TreeView:fixed-height-mode is enabled.
	//
	// The function takes the following parameters:
	//
	//   - width: allocated width for all TreeModel rows rendered with context,
	//     or -1.
	//   - height: allocated height for all TreeModel rows rendered with
	//     context, or -1.
	Allocate func(width, height int)
	// PreferredHeightForWidth gets the accumulative preferred height for width
	// for all rows which have been requested for the same said width with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	//
	// The function takes the following parameters:
	//
	//   - width: proposed width for allocation.
	//
	// The function returns the following values:
	//
	//   - minimumHeight (optional): location to store the minimum height,
	//     or NULL.
	//   - naturalHeight (optional): location to store the natural height,
	//     or NULL.
	PreferredHeightForWidth func(width int) (minimumHeight, naturalHeight int)
	// PreferredWidthForHeight gets the accumulative preferred width for height
	// for all rows which have been requested for the same said height with this
	// context.
	//
	// After gtk_cell_area_context_reset() is called and/or before ever
	// requesting the size of a CellArea, the returned values are -1.
	//
	// The function takes the following parameters:
	//
	//   - height: proposed height for allocation.
	//
	// The function returns the following values:
	//
	//   - minimumWidth (optional): location to store the minimum width,
	//     or NULL.
	//   - naturalWidth (optional): location to store the natural width,
	//     or NULL.
	PreferredWidthForHeight func(height int) (minimumWidth, naturalWidth int)
	// Reset resets any previously cached request and allocation data.
	//
	// When underlying TreeModel data changes its important to reset the
	// context if the content size is allowed to shrink. If the content
	// size is only allowed to grow (this is usually an option for views
	// rendering large data stores as a measure of optimization), then only
	// the row that changed or was inserted needs to be (re)requested with
	// gtk_cell_area_get_preferred_width().
	//
	// When the new overall size of the context requires that the allocated size
	// changes (or whenever this allocation changes at all), the variable row
	// sizes need to be re-requested for every row.
	//
	// For instance, if the rows are displayed all with the same
	// width from top to bottom then a change in the allocated width
	// necessitates a recalculation of all the displayed row heights using
	// gtk_cell_area_get_preferred_height_for_width().
	Reset func()
}

func defaultCellAreaContextOverrides(v *CellAreaContext) CellAreaContextOverrides {
	return CellAreaContextOverrides{
		Allocate:                v.allocate,
		PreferredHeightForWidth: v.preferredHeightForWidth,
		PreferredWidthForHeight: v.preferredWidthForHeight,
		Reset:                   v.reset,
	}
}

// CellAreaContext stores geometrical information for a series of rows in a
// GtkCellArea
//
// The CellAreaContext object is created by a given CellArea implementation via
// its CellAreaClass.create_context() virtual method and is used to store cell
// sizes and alignments for a series of TreeModel rows that are requested and
// rendered in the same context.
//
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, it’s important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
type CellAreaContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*CellAreaContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CellAreaContext, *CellAreaContextClass, CellAreaContextOverrides](
		GTypeCellAreaContext,
		initCellAreaContextClass,
		wrapCellAreaContext,
		defaultCellAreaContextOverrides,
	)
}

func initCellAreaContextClass(gclass unsafe.Pointer, overrides CellAreaContextOverrides, classInitFunc func(*CellAreaContextClass)) {
	pclass := (*C.GtkCellAreaContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCellAreaContext))))

	if overrides.Allocate != nil {
		pclass.allocate = (*[0]byte)(C._gotk4_gtk4_CellAreaContextClass_allocate)
	}

	if overrides.PreferredHeightForWidth != nil {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk4_CellAreaContextClass_get_preferred_height_for_width)
	}

	if overrides.PreferredWidthForHeight != nil {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk4_CellAreaContextClass_get_preferred_width_for_height)
	}

	if overrides.Reset != nil {
		pclass.reset = (*[0]byte)(C._gotk4_gtk4_CellAreaContextClass_reset)
	}

	if classInitFunc != nil {
		class := (*CellAreaContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCellAreaContext(obj *coreglib.Object) *CellAreaContext {
	return &CellAreaContext{
		Object: obj,
	}
}

func marshalCellAreaContext(p uintptr) (interface{}, error) {
	return wrapCellAreaContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Allocate allocates a width and/or a height for all rows which are to be
// rendered with context.
//
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height. Sometimes
// they are allocated in both horizontal and vertical orientations producing a
// homogeneous effect of the rows. This is generally the case for TreeView when
// TreeView:fixed-height-mode is enabled.
//
// The function takes the following parameters:
//
//   - width: allocated width for all TreeModel rows rendered with context,
//     or -1.
//   - height: allocated height for all TreeModel rows rendered with context,
//     or -1.
func (context *CellAreaContext) Allocate(width, height int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_cell_area_context_allocate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Allocation fetches the current allocation size for context.
//
// If the context was not allocated in width or height, or if the context was
// recently reset with gtk_cell_area_context_reset(), the returned value will be
// -1.
//
// The function returns the following values:
//
//   - width (optional): location to store the allocated width, or NULL.
//   - height (optional): location to store the allocated height, or NULL.
func (context *CellAreaContext) Allocation() (width, height int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // in
	var _arg2 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_cell_area_context_get_allocation(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// Area fetches the CellArea this context was created by.
//
// This is generally unneeded by layouting widgets; however, it is important for
// the context implementation itself to fetch information about the area it is
// being used for.
//
// For instance at CellAreaContextClass.allocate() time it’s important to know
// details about any cell spacing that the CellArea is configured with in order
// to compute a proper allocation.
//
// The function returns the following values:
//
//   - cellArea this context was created by.
func (context *CellAreaContext) Area() CellAreaer {
	var _arg0 *C.GtkCellAreaContext // out
	var _cret *C.GtkCellArea        // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_cell_area_context_get_area(_arg0)
	runtime.KeepAlive(context)

	var _cellArea CellAreaer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.CellAreaer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(CellAreaer)
			return ok
		})
		rv, ok := casted.(CellAreaer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellAreaer")
		}
		_cellArea = rv
	}

	return _cellArea
}

// PreferredHeight gets the accumulative preferred height for all rows which
// have been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location to store the minimum height, or NULL.
//   - naturalHeight (optional): location to store the natural height, or NULL.
func (context *CellAreaContext) PreferredHeight() (minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // in
	var _arg2 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_cell_area_context_get_preferred_height(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg1)
	_naturalHeight = int(_arg2)

	return _minimumHeight, _naturalHeight
}

// PreferredHeightForWidth gets the accumulative preferred height for width for
// all rows which have been requested for the same said width with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
//
// The function takes the following parameters:
//
//   - width: proposed width for allocation.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location to store the minimum height, or NULL.
//   - naturalHeight (optional): location to store the natural height, or NULL.
func (context *CellAreaContext) PreferredHeightForWidth(width int) (minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // in
	var _arg3 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(width)

	C.gtk_cell_area_context_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg2)
	_naturalHeight = int(_arg3)

	return _minimumHeight, _naturalHeight
}

// PreferredWidth gets the accumulative preferred width for all rows which have
// been requested with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location to store the minimum width, or NULL.
//   - naturalWidth (optional): location to store the natural width, or NULL.
func (context *CellAreaContext) PreferredWidth() (minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // in
	var _arg2 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_cell_area_context_get_preferred_width(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg1)
	_naturalWidth = int(_arg2)

	return _minimumWidth, _naturalWidth
}

// PreferredWidthForHeight gets the accumulative preferred width for height
// for all rows which have been requested for the same said height with this
// context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
//
// The function takes the following parameters:
//
//   - height: proposed height for allocation.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location to store the minimum width, or NULL.
//   - naturalWidth (optional): location to store the natural width, or NULL.
func (context *CellAreaContext) PreferredWidthForHeight(height int) (minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // in
	var _arg3 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(height)

	C.gtk_cell_area_context_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg2)
	_naturalWidth = int(_arg3)

	return _minimumWidth, _naturalWidth
}

// PushPreferredHeight causes the minimum and/or natural height to grow if the
// new proposed sizes exceed the current minimum and natural height.
//
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested height
// over a series of gtk_cell_area_get_preferred_height() requests.
//
// The function takes the following parameters:
//
//   - minimumHeight: proposed new minimum height for context.
//   - naturalHeight: proposed new natural height for context.
func (context *CellAreaContext) PushPreferredHeight(minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(minimumHeight)
	_arg2 = C.int(naturalHeight)

	C.gtk_cell_area_context_push_preferred_height(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(minimumHeight)
	runtime.KeepAlive(naturalHeight)
}

// PushPreferredWidth causes the minimum and/or natural width to grow if the new
// proposed sizes exceed the current minimum and natural width.
//
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested width
// over a series of gtk_cell_area_get_preferred_width() requests.
//
// The function takes the following parameters:
//
//   - minimumWidth: proposed new minimum width for context.
//   - naturalWidth: proposed new natural width for context.
func (context *CellAreaContext) PushPreferredWidth(minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(minimumWidth)
	_arg2 = C.int(naturalWidth)

	C.gtk_cell_area_context_push_preferred_width(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(minimumWidth)
	runtime.KeepAlive(naturalWidth)
}

// Reset resets any previously cached request and allocation data.
//
// When underlying TreeModel data changes its important to reset the context if
// the content size is allowed to shrink. If the content size is only allowed
// to grow (this is usually an option for views rendering large data stores as
// a measure of optimization), then only the row that changed or was inserted
// needs to be (re)requested with gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row sizes
// need to be re-requested for every row.
//
// For instance, if the rows are displayed all with the same
// width from top to bottom then a change in the allocated width
// necessitates a recalculation of all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
func (context *CellAreaContext) Reset() {
	var _arg0 *C.GtkCellAreaContext // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_cell_area_context_reset(_arg0)
	runtime.KeepAlive(context)
}

// Allocate allocates a width and/or a height for all rows which are to be
// rendered with context.
//
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height. Sometimes
// they are allocated in both horizontal and vertical orientations producing a
// homogeneous effect of the rows. This is generally the case for TreeView when
// TreeView:fixed-height-mode is enabled.
//
// The function takes the following parameters:
//
//   - width: allocated width for all TreeModel rows rendered with context,
//     or -1.
//   - height: allocated height for all TreeModel rows rendered with context,
//     or -1.
func (context *CellAreaContext) allocate(width, height int) {
	gclass := (*C.GtkCellAreaContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.allocate

	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C._gotk4_gtk4_CellAreaContext_virtual_allocate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// preferredHeightForWidth gets the accumulative preferred height for width for
// all rows which have been requested for the same said width with this context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
//
// The function takes the following parameters:
//
//   - width: proposed width for allocation.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location to store the minimum height, or NULL.
//   - naturalHeight (optional): location to store the natural height, or NULL.
func (context *CellAreaContext) preferredHeightForWidth(width int) (minimumHeight, naturalHeight int) {
	gclass := (*C.GtkCellAreaContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_preferred_height_for_width

	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // in
	var _arg3 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(width)

	C._gotk4_gtk4_CellAreaContext_virtual_get_preferred_height_for_width(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg2)
	_naturalHeight = int(_arg3)

	return _minimumHeight, _naturalHeight
}

// preferredWidthForHeight gets the accumulative preferred width for height
// for all rows which have been requested for the same said height with this
// context.
//
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
//
// The function takes the following parameters:
//
//   - height: proposed height for allocation.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location to store the minimum width, or NULL.
//   - naturalWidth (optional): location to store the natural width, or NULL.
func (context *CellAreaContext) preferredWidthForHeight(height int) (minimumWidth, naturalWidth int) {
	gclass := (*C.GtkCellAreaContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_preferred_width_for_height

	var _arg0 *C.GtkCellAreaContext // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // in
	var _arg3 C.int                 // in

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(height)

	C._gotk4_gtk4_CellAreaContext_virtual_get_preferred_width_for_height(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg2)
	_naturalWidth = int(_arg3)

	return _minimumWidth, _naturalWidth
}

// Reset resets any previously cached request and allocation data.
//
// When underlying TreeModel data changes its important to reset the context if
// the content size is allowed to shrink. If the content size is only allowed
// to grow (this is usually an option for views rendering large data stores as
// a measure of optimization), then only the row that changed or was inserted
// needs to be (re)requested with gtk_cell_area_get_preferred_width().
//
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row sizes
// need to be re-requested for every row.
//
// For instance, if the rows are displayed all with the same
// width from top to bottom then a change in the allocated width
// necessitates a recalculation of all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
func (context *CellAreaContext) reset() {
	gclass := (*C.GtkCellAreaContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.reset

	var _arg0 *C.GtkCellAreaContext // out

	_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_CellAreaContext_virtual_reset(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// CellRendererOverrides contains methods that are overridable.
type CellRendererOverrides struct {
	// Activate passes an activate event to the cell renderer for possible
	// processing. Some cell renderers may use events; for example,
	// CellRendererToggle toggles when it gets a mouse click.
	//
	// The function takes the following parameters:
	//
	//   - event: Event.
	//   - widget that received the event.
	//   - path: widget-dependent string representation of the event location;
	//     e.g. for TreeView, a string representation of TreePath.
	//   - backgroundArea: background area as passed to
	//     gtk_cell_renderer_render().
	//   - cellArea: cell area as passed to gtk_cell_renderer_render().
	//   - flags: render flags.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the event was consumed/handled.
	Activate        func(event gdk.Eventer, widget Widgetter, path string, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) bool
	EditingCanceled func()
	// The function takes the following parameters:
	//
	//   - editable
	//   - path
	EditingStarted func(editable CellEditabler, path string)
	// AlignedArea gets the aligned area used by cell inside cell_area. Used for
	// finding the appropriate edit and focus rectangle.
	//
	// The function takes the following parameters:
	//
	//   - widget this cell will be rendering to.
	//   - flags: render flags.
	//   - cellArea: cell area which would be passed to
	//     gtk_cell_renderer_render().
	//
	// The function returns the following values:
	//
	//   - alignedArea: return location for the space inside cell_area that
	//     would actually be used to render.
	AlignedArea func(widget Widgetter, flags CellRendererState, cellArea *gdk.Rectangle) *gdk.Rectangle
	// PreferredHeight retrieves a renderer’s natural size when rendered to
	// widget.
	//
	// The function takes the following parameters:
	//
	//   - widget this cell will be rendering to.
	//
	// The function returns the following values:
	//
	//   - minimumSize (optional): location to store the minimum size, or NULL.
	//   - naturalSize (optional): location to store the natural size, or NULL.
	PreferredHeight func(widget Widgetter) (minimumSize, naturalSize int)
	// PreferredHeightForWidth retrieves a cell renderers’s minimum and natural
	// height if it were rendered to widget with the specified width.
	//
	// The function takes the following parameters:
	//
	//   - widget this cell will be rendering to.
	//   - width: size which is available for allocation.
	//
	// The function returns the following values:
	//
	//   - minimumHeight (optional): location for storing the minimum size,
	//     or NULL.
	//   - naturalHeight (optional): location for storing the preferred size,
	//     or NULL.
	PreferredHeightForWidth func(widget Widgetter, width int) (minimumHeight, naturalHeight int)
	// PreferredWidth retrieves a renderer’s natural size when rendered to
	// widget.
	//
	// The function takes the following parameters:
	//
	//   - widget this cell will be rendering to.
	//
	// The function returns the following values:
	//
	//   - minimumSize (optional): location to store the minimum size, or NULL.
	//   - naturalSize (optional): location to store the natural size, or NULL.
	PreferredWidth func(widget Widgetter) (minimumSize, naturalSize int)
	// PreferredWidthForHeight retrieves a cell renderers’s minimum and natural
	// width if it were rendered to widget with the specified height.
	//
	// The function takes the following parameters:
	//
	//   - widget this cell will be rendering to.
	//   - height: size which is available for allocation.
	//
	// The function returns the following values:
	//
	//   - minimumWidth (optional): location for storing the minimum size,
	//     or NULL.
	//   - naturalWidth (optional): location for storing the preferred size,
	//     or NULL.
	PreferredWidthForHeight func(widget Widgetter, height int) (minimumWidth, naturalWidth int)
	// RequestMode gets whether the cell renderer prefers a height-for-width
	// layout or a width-for-height layout.
	//
	// The function returns the following values:
	//
	//   - sizeRequestMode preferred by this renderer.
	RequestMode func() SizeRequestMode
	// Snapshot invokes the virtual render function of the CellRenderer.
	// The three passed-in rectangles are areas in cr. Most renderers will
	// draw within cell_area; the xalign, yalign, xpad, and ypad fields of the
	// CellRenderer should be honored with respect to cell_area. background_area
	// includes the blank space around the cell, and also the area containing
	// the tree expander; so the background_area rectangles for all cells tile
	// to cover the entire window.
	//
	// The function takes the following parameters:
	//
	//   - snapshot to draw to.
	//   - widget owning window.
	//   - backgroundArea: entire cell area (including tree expanders and maybe
	//     padding on the sides).
	//   - cellArea: area normally rendered by a cell renderer.
	//   - flags that affect rendering.
	Snapshot func(snapshot *Snapshot, widget Widgetter, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState)
	// StartEditing starts editing the contents of this cell, through a new
	// CellEditable widget created by the CellRendererClass.start_editing
	// virtual function.
	//
	// The function takes the following parameters:
	//
	//   - event (optional): Event.
	//   - widget that received the event.
	//   - path: widget-dependent string representation of the event location;
	//     e.g. for TreeView, a string representation of TreePath.
	//   - backgroundArea: background area as passed to
	//     gtk_cell_renderer_render().
	//   - cellArea: cell area as passed to gtk_cell_renderer_render().
	//   - flags: render flags.
	//
	// The function returns the following values:
	//
	//   - cellEditable (optional): new CellEditable for editing this cell,
	//     or NULL if editing is not possible.
	StartEditing func(event gdk.Eventer, widget Widgetter, path string, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) *CellEditable
}

func defaultCellRendererOverrides(v *CellRenderer) CellRendererOverrides {
	return CellRendererOverrides{
		Activate:                v.activate,
		EditingCanceled:         v.editingCanceled,
		EditingStarted:          v.editingStarted,
		AlignedArea:             v.alignedArea,
		PreferredHeight:         v.preferredHeight,
		PreferredHeightForWidth: v.preferredHeightForWidth,
		PreferredWidth:          v.preferredWidth,
		PreferredWidthForHeight: v.preferredWidthForHeight,
		RequestMode:             v.requestMode,
		Snapshot:                v.snapshot,
		StartEditing:            v.startEditing,
	}
}

// CellRenderer: object for rendering a single cell
//
// The CellRenderer is a base class of a set of objects used for rendering a
// cell to a #cairo_t. These objects are used primarily by the TreeView widget,
// though they aren’t tied to them in any specific way. It is worth noting that
// CellRenderer is not a Widget and cannot be treated as such.
//
// The primary use of a CellRenderer is for drawing a certain graphical
// elements on a #cairo_t. Typically, one cell renderer is used to draw many
// cells on the screen. To this extent, it isn’t expected that a CellRenderer
// keep any permanent state around. Instead, any state is set just prior
// to use using #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_preferred_size(). Finally, the cell is rendered in the
// correct location using gtk_cell_renderer_snapshot().
//
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, it’s important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
//
// Beyond merely rendering a cell, cell renderers can optionally provide
// active user interface elements. A cell renderer can be “activatable” like
// CellRendererToggle, which toggles when it gets activated by a mouse click,
// or it can be “editable” like CellRendererText, which allows the user to
// edit the text using a widget implementing the CellEditable interface, e.g.
// Entry. To make a cell renderer activatable or editable, you have to implement
// the CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
//
// Many properties of CellRenderer and its subclasses have a corresponding
// “set” property, e.g. “cell-background-set” corresponds to “cell-background”.
// These “set” properties reflect whether a property has been set or not.
// You should not set them independently.
type CellRenderer struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned
}

var ()

// CellRendererer describes types inherited from class CellRenderer.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type CellRendererer interface {
	coreglib.Objector
	baseCellRenderer() *CellRenderer
}

var _ CellRendererer = (*CellRenderer)(nil)

func init() {
	coreglib.RegisterClassInfo[*CellRenderer, *CellRendererClass, CellRendererOverrides](
		GTypeCellRenderer,
		initCellRendererClass,
		wrapCellRenderer,
		defaultCellRendererOverrides,
	)
}

func initCellRendererClass(gclass unsafe.Pointer, overrides CellRendererOverrides, classInitFunc func(*CellRendererClass)) {
	pclass := (*C.GtkCellRendererClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCellRenderer))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_activate)
	}

	if overrides.EditingCanceled != nil {
		pclass.editing_canceled = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_editing_canceled)
	}

	if overrides.EditingStarted != nil {
		pclass.editing_started = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_editing_started)
	}

	if overrides.AlignedArea != nil {
		pclass.get_aligned_area = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_get_aligned_area)
	}

	if overrides.PreferredHeight != nil {
		pclass.get_preferred_height = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_get_preferred_height)
	}

	if overrides.PreferredHeightForWidth != nil {
		pclass.get_preferred_height_for_width = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_get_preferred_height_for_width)
	}

	if overrides.PreferredWidth != nil {
		pclass.get_preferred_width = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_get_preferred_width)
	}

	if overrides.PreferredWidthForHeight != nil {
		pclass.get_preferred_width_for_height = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_get_preferred_width_for_height)
	}

	if overrides.RequestMode != nil {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_get_request_mode)
	}

	if overrides.Snapshot != nil {
		pclass.snapshot = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_snapshot)
	}

	if overrides.StartEditing != nil {
		pclass.start_editing = (*[0]byte)(C._gotk4_gtk4_CellRendererClass_start_editing)
	}

	if classInitFunc != nil {
		class := (*CellRendererClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCellRenderer(obj *coreglib.Object) *CellRenderer {
	return &CellRenderer{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
	}
}

func marshalCellRenderer(p uintptr) (interface{}, error) {
	return wrapCellRenderer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (cell *CellRenderer) baseCellRenderer() *CellRenderer {
	return cell
}

// BaseCellRenderer returns the underlying base object.
func BaseCellRenderer(obj CellRendererer) *CellRenderer {
	return obj.baseCellRenderer()
}

// ConnectEditingCanceled: this signal gets emitted when the user cancels the
// process of editing a cell. For example, an editable cell renderer could be
// written to cancel editing when the user presses Escape.
//
// See also: gtk_cell_renderer_stop_editing().
func (cell *CellRenderer) ConnectEditingCanceled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cell, "editing-canceled", false, unsafe.Pointer(C._gotk4_gtk4_CellRenderer_ConnectEditingCanceled), f)
}

// ConnectEditingStarted: this signal gets emitted when a cell starts to be
// edited. The intended use of this signal is to do special setup on editable,
// e.g. adding a EntryCompletion or setting up additional columns in a ComboBox.
//
// See gtk_cell_editable_start_editing() for information on the lifecycle of the
// editable and a way to do setup that doesn’t depend on the renderer.
//
// Note that GTK doesn't guarantee that cell renderers will continue to use
// the same kind of widget for editing in future releases, therefore you
// should check the type of editable before doing any specific setup, as in the
// following example:
//
//	static void
//	text_editing_started (GtkCellRenderer *cell,
//	                      GtkCellEditable *editable,
//	                      const char      *path,
//	                      gpointer         data)
//	{
//	  if (GTK_IS_ENTRY (editable))
//	    {
//	      GtkEntry *entry = GTK_ENTRY (editable);
//
//	      // ... create a GtkEntryCompletion
//
//	      gtk_entry_set_completion (entry, completion);
//	    }
//	}.
func (cell *CellRenderer) ConnectEditingStarted(f func(editable CellEditabler, path string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cell, "editing-started", false, unsafe.Pointer(C._gotk4_gtk4_CellRenderer_ConnectEditingStarted), f)
}

// Activate passes an activate event to the cell renderer for possible
// processing. Some cell renderers may use events; for example,
// CellRendererToggle toggles when it gets a mouse click.
//
// The function takes the following parameters:
//
//   - event: Event.
//   - widget that received the event.
//   - path: widget-dependent string representation of the event location; e.g.
//     for TreeView, a string representation of TreePath.
//   - backgroundArea: background area as passed to gtk_cell_renderer_render().
//   - cellArea: cell area as passed to gtk_cell_renderer_render().
//   - flags: render flags.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was consumed/handled.
func (cell *CellRenderer) Activate(event gdk.Eventer, widget Widgetter, path string, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GdkEvent            // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.char                // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg6 = C.GtkCellRendererState(flags)

	_cret = C.gtk_cell_renderer_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(event)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(path)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AlignedArea gets the aligned area used by cell inside cell_area. Used for
// finding the appropriate edit and focus rectangle.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//   - flags: render flags.
//   - cellArea: cell area which would be passed to gtk_cell_renderer_render().
//
// The function returns the following values:
//
//   - alignedArea: return location for the space inside cell_area that would
//     actually be used to render.
func (cell *CellRenderer) AlignedArea(widget Widgetter, flags CellRendererState, cellArea *gdk.Rectangle) *gdk.Rectangle {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkCellRendererState // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 C.GdkRectangle         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.GtkCellRendererState(flags)
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))

	C.gtk_cell_renderer_get_aligned_area(_arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cellArea)

	var _alignedArea *gdk.Rectangle // out

	_alignedArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))

	return _alignedArea
}

// Alignment fills in xalign and yalign with the appropriate values of cell.
//
// The function returns the following values:
//
//   - xalign (optional): location to fill in with the x alignment of the cell,
//     or NULL.
//   - yalign (optional): location to fill in with the y alignment of the cell,
//     or NULL.
func (cell *CellRenderer) Alignment() (xalign, yalign float32) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.float            // in
	var _arg2 C.float            // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	C.gtk_cell_renderer_get_alignment(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(cell)

	var _xalign float32 // out
	var _yalign float32 // out

	_xalign = float32(_arg1)
	_yalign = float32(_arg2)

	return _xalign, _yalign
}

// FixedSize fills in width and height with the appropriate size of cell.
//
// The function returns the following values:
//
//   - width (optional): location to fill in with the fixed width of the cell,
//     or NULL.
//   - height (optional): location to fill in with the fixed height of the cell,
//     or NULL.
func (cell *CellRenderer) FixedSize() (width, height int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	C.gtk_cell_renderer_get_fixed_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(cell)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// IsExpanded checks whether the given CellRenderer is expanded.
//
// The function returns the following values:
//
//   - ok: TRUE if the cell renderer is expanded.
func (cell *CellRenderer) IsExpanded() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_cret = C.gtk_cell_renderer_get_is_expanded(_arg0)
	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsExpander checks whether the given CellRenderer is an expander.
//
// The function returns the following values:
//
//   - ok: TRUE if cell is an expander, and FALSE otherwise.
func (cell *CellRenderer) IsExpander() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_cret = C.gtk_cell_renderer_get_is_expander(_arg0)
	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Padding fills in xpad and ypad with the appropriate values of cell.
//
// The function returns the following values:
//
//   - xpad (optional): location to fill in with the x padding of the cell,
//     or NULL.
//   - ypad (optional): location to fill in with the y padding of the cell,
//     or NULL.
func (cell *CellRenderer) Padding() (xpad, ypad int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	C.gtk_cell_renderer_get_padding(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(cell)

	var _xpad int // out
	var _ypad int // out

	_xpad = int(_arg1)
	_ypad = int(_arg2)

	return _xpad, _ypad
}

// PreferredHeight retrieves a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//
// The function returns the following values:
//
//   - minimumSize (optional): location to store the minimum size, or NULL.
//   - naturalSize (optional): location to store the natural size, or NULL.
func (cell *CellRenderer) PreferredHeight(widget Widgetter) (minimumSize, naturalSize int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_cell_renderer_get_preferred_height(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = int(_arg2)
	_naturalSize = int(_arg3)

	return _minimumSize, _naturalSize
}

// PreferredHeightForWidth retrieves a cell renderers’s minimum and natural
// height if it were rendered to widget with the specified width.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//   - width: size which is available for allocation.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location for storing the minimum size, or NULL.
//   - naturalHeight (optional): location for storing the preferred size,
//     or NULL.
func (cell *CellRenderer) PreferredHeightForWidth(widget Widgetter, width int) (minimumHeight, naturalHeight int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // out
	var _arg3 C.int              // in
	var _arg4 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.int(width)

	C.gtk_cell_renderer_get_preferred_height_for_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg3)
	_naturalHeight = int(_arg4)

	return _minimumHeight, _naturalHeight
}

// PreferredSize retrieves the minimum and natural size of a cell taking into
// account the widget’s preference for height-for-width management.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//
// The function returns the following values:
//
//   - minimumSize (optional): location for storing the minimum size, or NULL.
//   - naturalSize (optional): location for storing the natural size, or NULL.
func (cell *CellRenderer) PreferredSize(widget Widgetter) (minimumSize, naturalSize *Requisition) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.GtkRequisition   // in
	var _arg3 C.GtkRequisition   // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_cell_renderer_get_preferred_size(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize *Requisition // out
	var _naturalSize *Requisition // out

	_minimumSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_naturalSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _minimumSize, _naturalSize
}

// PreferredWidth retrieves a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//
// The function returns the following values:
//
//   - minimumSize (optional): location to store the minimum size, or NULL.
//   - naturalSize (optional): location to store the natural size, or NULL.
func (cell *CellRenderer) PreferredWidth(widget Widgetter) (minimumSize, naturalSize int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_cell_renderer_get_preferred_width(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = int(_arg2)
	_naturalSize = int(_arg3)

	return _minimumSize, _naturalSize
}

// PreferredWidthForHeight retrieves a cell renderers’s minimum and natural
// width if it were rendered to widget with the specified height.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//   - height: size which is available for allocation.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location for storing the minimum size, or NULL.
//   - naturalWidth (optional): location for storing the preferred size,
//     or NULL.
func (cell *CellRenderer) PreferredWidthForHeight(widget Widgetter, height int) (minimumWidth, naturalWidth int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // out
	var _arg3 C.int              // in
	var _arg4 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.int(height)

	C.gtk_cell_renderer_get_preferred_width_for_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg3)
	_naturalWidth = int(_arg4)

	return _minimumWidth, _naturalWidth
}

// RequestMode gets whether the cell renderer prefers a height-for-width layout
// or a width-for-height layout.
//
// The function returns the following values:
//
//   - sizeRequestMode preferred by this renderer.
func (cell *CellRenderer) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkCellRenderer   // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_cret = C.gtk_cell_renderer_get_request_mode(_arg0)
	runtime.KeepAlive(cell)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Sensitive returns the cell renderer’s sensitivity.
//
// The function returns the following values:
//
//   - ok: TRUE if the cell renderer is sensitive.
func (cell *CellRenderer) Sensitive() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_cret = C.gtk_cell_renderer_get_sensitive(_arg0)
	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// State translates the cell renderer state to StateFlags, based on the cell
// renderer and widget sensitivity, and the given CellRendererState.
//
// The function takes the following parameters:
//
//   - widget (optional) or NULL.
//   - cellState: cell renderer state.
//
// The function returns the following values:
//
//   - stateFlags: widget state flags applying to cell.
func (cell *CellRenderer) State(widget Widgetter, cellState CellRendererState) StateFlags {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkCellRendererState // out
	var _cret C.GtkStateFlags        // in

	if cell != nil {
		_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}
	_arg2 = C.GtkCellRendererState(cellState)

	_cret = C.gtk_cell_renderer_get_state(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cellState)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// Visible returns the cell renderer’s visibility.
//
// The function returns the following values:
//
//   - ok: TRUE if the cell renderer is visible.
func (cell *CellRenderer) Visible() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_cret = C.gtk_cell_renderer_get_visible(_arg0)
	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActivatable checks whether the cell renderer can do something when
// activated.
//
// The function returns the following values:
//
//   - ok: TRUE if the cell renderer can do anything when activated.
func (cell *CellRenderer) IsActivatable() bool {
	var _arg0 *C.GtkCellRenderer // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_cret = C.gtk_cell_renderer_is_activatable(_arg0)
	runtime.KeepAlive(cell)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAlignment sets the renderer’s alignment within its available space.
//
// The function takes the following parameters:
//
//   - xalign: x alignment of the cell renderer.
//   - yalign: y alignment of the cell renderer.
func (cell *CellRenderer) SetAlignment(xalign, yalign float32) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.float            // out
	var _arg2 C.float            // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = C.float(xalign)
	_arg2 = C.float(yalign)

	C.gtk_cell_renderer_set_alignment(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
//
// The function takes the following parameters:
//
//   - width of the cell renderer, or -1.
//   - height of the cell renderer, or -1.
func (cell *CellRenderer) SetFixedSize(width, height int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_cell_renderer_set_fixed_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetIsExpanded sets whether the given CellRenderer is expanded.
//
// The function takes the following parameters:
//
//   - isExpanded: whether cell should be expanded.
func (cell *CellRenderer) SetIsExpanded(isExpanded bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if isExpanded {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_is_expanded(_arg0, _arg1)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(isExpanded)
}

// SetIsExpander sets whether the given CellRenderer is an expander.
//
// The function takes the following parameters:
//
//   - isExpander: whether cell is an expander.
func (cell *CellRenderer) SetIsExpander(isExpander bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if isExpander {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_is_expander(_arg0, _arg1)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(isExpander)
}

// SetPadding sets the renderer’s padding.
//
// The function takes the following parameters:
//
//   - xpad: x padding of the cell renderer.
//   - ypad: y padding of the cell renderer.
func (cell *CellRenderer) SetPadding(xpad, ypad int) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = C.int(xpad)
	_arg2 = C.int(ypad)

	C.gtk_cell_renderer_set_padding(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(xpad)
	runtime.KeepAlive(ypad)
}

// SetSensitive sets the cell renderer’s sensitivity.
//
// The function takes the following parameters:
//
//   - sensitive: sensitivity of the cell.
func (cell *CellRenderer) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_sensitive(_arg0, _arg1)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(sensitive)
}

// SetVisible sets the cell renderer’s visibility.
//
// The function takes the following parameters:
//
//   - visible: visibility of the cell.
func (cell *CellRenderer) SetVisible(visible bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_set_visible(_arg0, _arg1)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(visible)
}

// Snapshot invokes the virtual render function of the CellRenderer. The three
// passed-in rectangles are areas in cr. Most renderers will draw within
// cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
// should be honored with respect to cell_area. background_area includes the
// blank space around the cell, and also the area containing the tree expander;
// so the background_area rectangles for all cells tile to cover the entire
// window.
//
// The function takes the following parameters:
//
//   - snapshot to draw to.
//   - widget owning window.
//   - backgroundArea: entire cell area (including tree expanders and maybe
//     padding on the sides).
//   - cellArea: area normally rendered by a cell renderer.
//   - flags that affect rendering.
func (cell *CellRenderer) Snapshot(snapshot *Snapshot, widget Widgetter, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkSnapshot         // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg5 = C.GtkCellRendererState(flags)

	C.gtk_cell_renderer_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
}

// StartEditing starts editing the contents of this cell, through a new
// CellEditable widget created by the CellRendererClass.start_editing virtual
// function.
//
// The function takes the following parameters:
//
//   - event (optional): Event.
//   - widget that received the event.
//   - path: widget-dependent string representation of the event location; e.g.
//     for TreeView, a string representation of TreePath.
//   - backgroundArea: background area as passed to gtk_cell_renderer_render().
//   - cellArea: cell area as passed to gtk_cell_renderer_render().
//   - flags: render flags.
//
// The function returns the following values:
//
//   - cellEditable (optional): new CellEditable for editing this cell, or NULL
//     if editing is not possible.
func (cell *CellRenderer) StartEditing(event gdk.Eventer, widget Widgetter, path string, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) *CellEditable {
	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GdkEvent            // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.char                // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _cret *C.GtkCellEditable     // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if event != nil {
		_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	}
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg6 = C.GtkCellRendererState(flags)

	_cret = C.gtk_cell_renderer_start_editing(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(event)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(path)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _cellEditable *CellEditable // out

	if _cret != nil {
		_cellEditable = wrapCellEditable(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _cellEditable
}

// StopEditing informs the cell renderer that the editing is
// stopped. If canceled is TRUE, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
//
// This function should be called by cell renderer implementations in response
// to the CellEditable::editing-done signal of CellEditable.
//
// The function takes the following parameters:
//
//   - canceled: TRUE if the editing has been canceled.
func (cell *CellRenderer) StopEditing(canceled bool) {
	var _arg0 *C.GtkCellRenderer // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if canceled {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_stop_editing(_arg0, _arg1)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(canceled)
}

// Activate passes an activate event to the cell renderer for possible
// processing. Some cell renderers may use events; for example,
// CellRendererToggle toggles when it gets a mouse click.
//
// The function takes the following parameters:
//
//   - event: Event.
//   - widget that received the event.
//   - path: widget-dependent string representation of the event location; e.g.
//     for TreeView, a string representation of TreePath.
//   - backgroundArea: background area as passed to gtk_cell_renderer_render().
//   - cellArea: cell area as passed to gtk_cell_renderer_render().
//   - flags: render flags.
//
// The function returns the following values:
//
//   - ok: TRUE if the event was consumed/handled.
func (cell *CellRenderer) activate(event gdk.Eventer, widget Widgetter, path string, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) bool {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.activate

	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GdkEvent            // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.char                // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg6 = C.GtkCellRendererState(flags)

	_cret = C._gotk4_gtk4_CellRenderer_virtual_activate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(event)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(path)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (cell *CellRenderer) editingCanceled() {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.editing_canceled

	var _arg0 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	C._gotk4_gtk4_CellRenderer_virtual_editing_canceled(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cell)
}

// The function takes the following parameters:
//
//   - editable
//   - path
func (cell *CellRenderer) editingStarted(editable CellEditabler, path string) {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.editing_started

	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkCellEditable // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkCellEditable)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gtk4_CellRenderer_virtual_editing_started(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(editable)
	runtime.KeepAlive(path)
}

// alignedArea gets the aligned area used by cell inside cell_area. Used for
// finding the appropriate edit and focus rectangle.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//   - flags: render flags.
//   - cellArea: cell area which would be passed to gtk_cell_renderer_render().
//
// The function returns the following values:
//
//   - alignedArea: return location for the space inside cell_area that would
//     actually be used to render.
func (cell *CellRenderer) alignedArea(widget Widgetter, flags CellRendererState, cellArea *gdk.Rectangle) *gdk.Rectangle {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.get_aligned_area

	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkWidget           // out
	var _arg2 C.GtkCellRendererState // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 C.GdkRectangle         // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.GtkCellRendererState(flags)
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))

	C._gotk4_gtk4_CellRenderer_virtual_get_aligned_area(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(cellArea)

	var _alignedArea *gdk.Rectangle // out

	_alignedArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))

	return _alignedArea
}

// preferredHeight retrieves a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//
// The function returns the following values:
//
//   - minimumSize (optional): location to store the minimum size, or NULL.
//   - naturalSize (optional): location to store the natural size, or NULL.
func (cell *CellRenderer) preferredHeight(widget Widgetter) (minimumSize, naturalSize int) {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.get_preferred_height

	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_CellRenderer_virtual_get_preferred_height(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = int(_arg2)
	_naturalSize = int(_arg3)

	return _minimumSize, _naturalSize
}

// preferredHeightForWidth retrieves a cell renderers’s minimum and natural
// height if it were rendered to widget with the specified width.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//   - width: size which is available for allocation.
//
// The function returns the following values:
//
//   - minimumHeight (optional): location for storing the minimum size, or NULL.
//   - naturalHeight (optional): location for storing the preferred size,
//     or NULL.
func (cell *CellRenderer) preferredHeightForWidth(widget Widgetter, width int) (minimumHeight, naturalHeight int) {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.get_preferred_height_for_width

	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // out
	var _arg3 C.int              // in
	var _arg4 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.int(width)

	C._gotk4_gtk4_CellRenderer_virtual_get_preferred_height_for_width(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)

	var _minimumHeight int // out
	var _naturalHeight int // out

	_minimumHeight = int(_arg3)
	_naturalHeight = int(_arg4)

	return _minimumHeight, _naturalHeight
}

// preferredWidth retrieves a renderer’s natural size when rendered to widget.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//
// The function returns the following values:
//
//   - minimumSize (optional): location to store the minimum size, or NULL.
//   - naturalSize (optional): location to store the natural size, or NULL.
func (cell *CellRenderer) preferredWidth(widget Widgetter) (minimumSize, naturalSize int) {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.get_preferred_width

	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // in
	var _arg3 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_CellRenderer_virtual_get_preferred_width(unsafe.Pointer(fnarg), _arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)

	var _minimumSize int // out
	var _naturalSize int // out

	_minimumSize = int(_arg2)
	_naturalSize = int(_arg3)

	return _minimumSize, _naturalSize
}

// preferredWidthForHeight retrieves a cell renderers’s minimum and natural
// width if it were rendered to widget with the specified height.
//
// The function takes the following parameters:
//
//   - widget this cell will be rendering to.
//   - height: size which is available for allocation.
//
// The function returns the following values:
//
//   - minimumWidth (optional): location for storing the minimum size, or NULL.
//   - naturalWidth (optional): location for storing the preferred size,
//     or NULL.
func (cell *CellRenderer) preferredWidthForHeight(widget Widgetter, height int) (minimumWidth, naturalWidth int) {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.get_preferred_width_for_height

	var _arg0 *C.GtkCellRenderer // out
	var _arg1 *C.GtkWidget       // out
	var _arg2 C.int              // out
	var _arg3 C.int              // in
	var _arg4 C.int              // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.int(height)

	C._gotk4_gtk4_CellRenderer_virtual_get_preferred_width_for_height(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(height)

	var _minimumWidth int // out
	var _naturalWidth int // out

	_minimumWidth = int(_arg3)
	_naturalWidth = int(_arg4)

	return _minimumWidth, _naturalWidth
}

// requestMode gets whether the cell renderer prefers a height-for-width layout
// or a width-for-height layout.
//
// The function returns the following values:
//
//   - sizeRequestMode preferred by this renderer.
func (cell *CellRenderer) requestMode() SizeRequestMode {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.get_request_mode

	var _arg0 *C.GtkCellRenderer   // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	_cret = C._gotk4_gtk4_CellRenderer_virtual_get_request_mode(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(cell)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Snapshot invokes the virtual render function of the CellRenderer. The three
// passed-in rectangles are areas in cr. Most renderers will draw within
// cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
// should be honored with respect to cell_area. background_area includes the
// blank space around the cell, and also the area containing the tree expander;
// so the background_area rectangles for all cells tile to cover the entire
// window.
//
// The function takes the following parameters:
//
//   - snapshot to draw to.
//   - widget owning window.
//   - backgroundArea: entire cell area (including tree expanders and maybe
//     padding on the sides).
//   - cellArea: area normally rendered by a cell renderer.
//   - flags that affect rendering.
func (cell *CellRenderer) snapshot(snapshot *Snapshot, widget Widgetter, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.snapshot

	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GtkSnapshot         // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.GdkRectangle        // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 C.GtkCellRendererState // out

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg1 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg5 = C.GtkCellRendererState(flags)

	C._gotk4_gtk4_CellRenderer_virtual_snapshot(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)
}

// startEditing starts editing the contents of this cell, through a new
// CellEditable widget created by the CellRendererClass.start_editing virtual
// function.
//
// The function takes the following parameters:
//
//   - event (optional): Event.
//   - widget that received the event.
//   - path: widget-dependent string representation of the event location; e.g.
//     for TreeView, a string representation of TreePath.
//   - backgroundArea: background area as passed to gtk_cell_renderer_render().
//   - cellArea: cell area as passed to gtk_cell_renderer_render().
//   - flags: render flags.
//
// The function returns the following values:
//
//   - cellEditable (optional): new CellEditable for editing this cell, or NULL
//     if editing is not possible.
func (cell *CellRenderer) startEditing(event gdk.Eventer, widget Widgetter, path string, backgroundArea, cellArea *gdk.Rectangle, flags CellRendererState) *CellEditable {
	gclass := (*C.GtkCellRendererClass)(coreglib.PeekParentClass(cell))
	fnarg := gclass.start_editing

	var _arg0 *C.GtkCellRenderer     // out
	var _arg1 *C.GdkEvent            // out
	var _arg2 *C.GtkWidget           // out
	var _arg3 *C.char                // out
	var _arg4 *C.GdkRectangle        // out
	var _arg5 *C.GdkRectangle        // out
	var _arg6 C.GtkCellRendererState // out
	var _cret *C.GtkCellEditable     // in

	_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if event != nil {
		_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	}
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(backgroundArea)))
	_arg5 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(cellArea)))
	_arg6 = C.GtkCellRendererState(flags)

	_cret = C._gotk4_gtk4_CellRenderer_virtual_start_editing(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(event)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(path)
	runtime.KeepAlive(backgroundArea)
	runtime.KeepAlive(cellArea)
	runtime.KeepAlive(flags)

	var _cellEditable *CellEditable // out

	if _cret != nil {
		_cellEditable = wrapCellEditable(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _cellEditable
}

// CellRendererAccel renders a keyboard accelerator in a cell
//
// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like Control + a). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
type CellRendererAccel struct {
	_ [0]func() // equal guard
	CellRendererText
}

var (
	_ CellRendererer = (*CellRendererAccel)(nil)
)

func wrapCellRendererAccel(obj *coreglib.Object) *CellRendererAccel {
	return &CellRendererAccel{
		CellRendererText: CellRendererText{
			CellRenderer: CellRenderer{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalCellRendererAccel(p uintptr) (interface{}, error) {
	return wrapCellRendererAccel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAccelCleared gets emitted when the user has removed the accelerator.
func (v *CellRendererAccel) ConnectAccelCleared(f func(pathString string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "accel-cleared", false, unsafe.Pointer(C._gotk4_gtk4_CellRendererAccel_ConnectAccelCleared), f)
}

// ConnectAccelEdited gets emitted when the user has selected a new accelerator.
func (v *CellRendererAccel) ConnectAccelEdited(f func(pathString string, accelKey uint, accelMods gdk.ModifierType, hardwareKeycode uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "accel-edited", false, unsafe.Pointer(C._gotk4_gtk4_CellRendererAccel_ConnectAccelEdited), f)
}

// NewCellRendererAccel creates a new CellRendererAccel.
//
// The function returns the following values:
//
//   - cellRendererAccel: new cell renderer.
func NewCellRendererAccel() *CellRendererAccel {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_accel_new()

	var _cellRendererAccel *CellRendererAccel // out

	_cellRendererAccel = wrapCellRendererAccel(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererAccel
}

// CellRendererCombo renders a combobox in a cell
//
// CellRendererCombo renders text in a cell like CellRendererText from which
// it is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
//
// The combo cell renderer takes care of adding a text cell renderer
// to the combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
type CellRendererCombo struct {
	_ [0]func() // equal guard
	CellRendererText
}

var (
	_ CellRendererer = (*CellRendererCombo)(nil)
)

func wrapCellRendererCombo(obj *coreglib.Object) *CellRendererCombo {
	return &CellRendererCombo{
		CellRendererText: CellRendererText{
			CellRenderer: CellRenderer{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalCellRendererCombo(p uintptr) (interface{}, error) {
	return wrapCellRendererCombo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged: this signal is emitted each time after the user selected an
// item in the combo box, either by using the mouse or the arrow keys. Contrary
// to GtkComboBox, GtkCellRendererCombo::changed is not emitted for changes made
// to a selected item in the entry. The argument new_iter corresponds to the
// newly selected item in the combo box and it is relative to the GtkTreeModel
// set via the model property on GtkCellRendererCombo.
//
// Note that as soon as you change the model displayed in the tree view,
// the tree view will immediately cease the editing operating. This means that
// you most probably want to refrain from changing the model until the combo
// cell renderer emits the edited or editing_canceled signal.
func (v *CellRendererCombo) ConnectChanged(f func(pathString string, newIter *TreeIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "changed", false, unsafe.Pointer(C._gotk4_gtk4_CellRendererCombo_ConnectChanged), f)
}

// NewCellRendererCombo creates a new CellRendererCombo. Adjust how text is
// drawn using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the “text” property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView.
//
// The function returns the following values:
//
//   - cellRendererCombo: new cell renderer.
func NewCellRendererCombo() *CellRendererCombo {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_combo_new()

	var _cellRendererCombo *CellRendererCombo // out

	_cellRendererCombo = wrapCellRendererCombo(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererCombo
}

// CellRendererPixbuf renders a pixbuf in a cell
//
// A CellRendererPixbuf can be used to render an image in a cell. It allows to
// render either a given Pixbuf (set via the CellRendererPixbuf:pixbuf property)
// or a named icon (set via the CellRendererPixbuf:icon-name property).
//
// To support the tree view, CellRendererPixbuf also supports rendering
// two alternative pixbufs, when the CellRenderer:is-expander property
// is TRUE. If the CellRenderer:is-expanded property is TRUE and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf,
// it renders that pixbuf, if the CellRenderer:is-expanded property is FALSE and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf,
// it renders that one.
type CellRendererPixbuf struct {
	_ [0]func() // equal guard
	CellRenderer
}

var (
	_ CellRendererer = (*CellRendererPixbuf)(nil)
)

func wrapCellRendererPixbuf(obj *coreglib.Object) *CellRendererPixbuf {
	return &CellRendererPixbuf{
		CellRenderer: CellRenderer{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
	return wrapCellRendererPixbuf(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCellRendererPixbuf creates a new CellRendererPixbuf. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the “pixbuf” property on
// the cell renderer to a pixbuf value in the model, thus rendering a different
// image in each row of the TreeView.
//
// The function returns the following values:
//
//   - cellRendererPixbuf: new cell renderer.
func NewCellRendererPixbuf() *CellRendererPixbuf {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_pixbuf_new()

	var _cellRendererPixbuf *CellRendererPixbuf // out

	_cellRendererPixbuf = wrapCellRendererPixbuf(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererPixbuf
}

// CellRendererProgress renders numbers as progress bars
//
// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
type CellRendererProgress struct {
	_ [0]func() // equal guard
	CellRenderer

	Orientable
}

var (
	_ CellRendererer = (*CellRendererProgress)(nil)
)

func wrapCellRendererProgress(obj *coreglib.Object) *CellRendererProgress {
	return &CellRendererProgress{
		CellRenderer: CellRenderer{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalCellRendererProgress(p uintptr) (interface{}, error) {
	return wrapCellRendererProgress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCellRendererProgress creates a new CellRendererProgress.
//
// The function returns the following values:
//
//   - cellRendererProgress: new cell renderer.
func NewCellRendererProgress() *CellRendererProgress {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_progress_new()

	var _cellRendererProgress *CellRendererProgress // out

	_cellRendererProgress = wrapCellRendererProgress(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererProgress
}

// CellRendererSpin renders a spin button in a cell
//
// CellRendererSpin renders text in a cell like CellRendererText from which
// it is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
//
// The range of the spinbutton is taken from the adjustment property of the
// cell renderer, which can be set explicitly or mapped to a column in the
// tree model, like all properties of cell renders. CellRendererSpin also
// has properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
//
// The CellRendererSpin cell renderer was added in GTK 2.10.
type CellRendererSpin struct {
	_ [0]func() // equal guard
	CellRendererText
}

var (
	_ CellRendererer = (*CellRendererSpin)(nil)
)

func wrapCellRendererSpin(obj *coreglib.Object) *CellRendererSpin {
	return &CellRendererSpin{
		CellRendererText: CellRendererText{
			CellRenderer: CellRenderer{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
			},
		},
	}
}

func marshalCellRendererSpin(p uintptr) (interface{}, error) {
	return wrapCellRendererSpin(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCellRendererSpin creates a new CellRendererSpin.
//
// The function returns the following values:
//
//   - cellRendererSpin: new CellRendererSpin.
func NewCellRendererSpin() *CellRendererSpin {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_spin_new()

	var _cellRendererSpin *CellRendererSpin // out

	_cellRendererSpin = wrapCellRendererSpin(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererSpin
}

// CellRendererSpinner renders a spinning animation in a cell
//
// GtkCellRendererSpinner renders a spinning animation in a cell, very similar
// to Spinner. It can often be used as an alternative to a CellRendererProgress
// for displaying indefinite activity, instead of actual progress.
//
// To start the animation in a cell, set the CellRendererSpinner:active
// property to TRUE and increment the CellRendererSpinner:pulse property
// at regular intervals. The usual way to set the cell renderer properties
// for each cell is to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
type CellRendererSpinner struct {
	_ [0]func() // equal guard
	CellRenderer
}

var (
	_ CellRendererer = (*CellRendererSpinner)(nil)
)

func wrapCellRendererSpinner(obj *coreglib.Object) *CellRendererSpinner {
	return &CellRendererSpinner{
		CellRenderer: CellRenderer{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
	return wrapCellRendererSpinner(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCellRendererSpinner returns a new cell renderer which will show a spinner
// to indicate activity.
//
// The function returns the following values:
//
//   - cellRendererSpinner: new CellRenderer.
func NewCellRendererSpinner() *CellRendererSpinner {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_spinner_new()

	var _cellRendererSpinner *CellRendererSpinner // out

	_cellRendererSpinner = wrapCellRendererSpinner(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererSpinner
}

// CellRendererTextOverrides contains methods that are overridable.
type CellRendererTextOverrides struct {
	// The function takes the following parameters:
	//
	//   - path
	//   - newText
	Edited func(path, newText string)
}

func defaultCellRendererTextOverrides(v *CellRendererText) CellRendererTextOverrides {
	return CellRendererTextOverrides{
		Edited: v.edited,
	}
}

// CellRendererText renders text in a cell
//
// A CellRendererText renders a given text in its cell, using the font, color
// and style information provided by its properties. The text will be ellipsized
// if it is too long and the CellRendererText:ellipsize property allows it.
//
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
type CellRendererText struct {
	_ [0]func() // equal guard
	CellRenderer
}

var (
	_ CellRendererer = (*CellRendererText)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CellRendererText, *CellRendererTextClass, CellRendererTextOverrides](
		GTypeCellRendererText,
		initCellRendererTextClass,
		wrapCellRendererText,
		defaultCellRendererTextOverrides,
	)
}

func initCellRendererTextClass(gclass unsafe.Pointer, overrides CellRendererTextOverrides, classInitFunc func(*CellRendererTextClass)) {
	pclass := (*C.GtkCellRendererTextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCellRendererText))))

	if overrides.Edited != nil {
		pclass.edited = (*[0]byte)(C._gotk4_gtk4_CellRendererTextClass_edited)
	}

	if classInitFunc != nil {
		class := (*CellRendererTextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCellRendererText(obj *coreglib.Object) *CellRendererText {
	return &CellRendererText{
		CellRenderer: CellRenderer{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalCellRendererText(p uintptr) (interface{}, error) {
	return wrapCellRendererText(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEdited: this signal is emitted after renderer has been edited.
//
// It is the responsibility of the application to update the model and store
// new_text at the position indicated by path.
func (renderer *CellRendererText) ConnectEdited(f func(path, newText string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(renderer, "edited", false, unsafe.Pointer(C._gotk4_gtk4_CellRendererText_ConnectEdited), f)
}

// NewCellRendererText creates a new CellRendererText. Adjust how text is
// drawn using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the “text” property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView.
//
// The function returns the following values:
//
//   - cellRendererText: new cell renderer.
func NewCellRendererText() *CellRendererText {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_text_new()

	var _cellRendererText *CellRendererText // out

	_cellRendererText = wrapCellRendererText(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererText
}

// SetFixedHeightFromFont sets the height of a renderer to explicitly be
// determined by the “font” and “y_pad” property set on it. Further changes in
// these properties do not affect the height, so they must be accompanied by
// a subsequent call to this function. Using this function is inflexible, and
// should really only be used if calculating the size of a cell is too slow (ie,
// a massive number of cells displayed). If number_of_rows is -1, then the fixed
// height is unset, and the height is determined by the properties again.
//
// The function takes the following parameters:
//
//   - numberOfRows: number of rows of text each cell renderer is allocated,
//     or -1.
func (renderer *CellRendererText) SetFixedHeightFromFont(numberOfRows int) {
	var _arg0 *C.GtkCellRendererText // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GtkCellRendererText)(unsafe.Pointer(coreglib.InternObject(renderer).Native()))
	_arg1 = C.int(numberOfRows)

	C.gtk_cell_renderer_text_set_fixed_height_from_font(_arg0, _arg1)
	runtime.KeepAlive(renderer)
	runtime.KeepAlive(numberOfRows)
}

// The function takes the following parameters:
//
//   - path
//   - newText
func (cellRendererText *CellRendererText) edited(path, newText string) {
	gclass := (*C.GtkCellRendererTextClass)(coreglib.PeekParentClass(cellRendererText))
	fnarg := gclass.edited

	var _arg0 *C.GtkCellRendererText // out
	var _arg1 *C.char                // out
	var _arg2 *C.char                // out

	_arg0 = (*C.GtkCellRendererText)(unsafe.Pointer(coreglib.InternObject(cellRendererText).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(newText)))
	defer C.free(unsafe.Pointer(_arg2))

	C._gotk4_gtk4_CellRendererText_virtual_edited(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(cellRendererText)
	runtime.KeepAlive(path)
	runtime.KeepAlive(newText)
}

// CellRendererToggle renders a toggle button in a cell
//
// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
type CellRendererToggle struct {
	_ [0]func() // equal guard
	CellRenderer
}

var (
	_ CellRendererer = (*CellRendererToggle)(nil)
)

func wrapCellRendererToggle(obj *coreglib.Object) *CellRendererToggle {
	return &CellRendererToggle{
		CellRenderer: CellRenderer{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
		},
	}
}

func marshalCellRendererToggle(p uintptr) (interface{}, error) {
	return wrapCellRendererToggle(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectToggled signal is emitted when the cell is toggled.
//
// It is the responsibility of the application to update the model with the
// correct value to store at path. Often this is simply the opposite of the
// value currently stored at path.
func (toggle *CellRendererToggle) ConnectToggled(f func(path string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(toggle, "toggled", false, unsafe.Pointer(C._gotk4_gtk4_CellRendererToggle_ConnectToggled), f)
}

// NewCellRendererToggle creates a new CellRendererToggle. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property
// to a value in a TreeModel. For example, you can bind the “active” property
// on the cell renderer to a boolean value in the model, thus causing the check
// button to reflect the state of the model.
//
// The function returns the following values:
//
//   - cellRendererToggle: new cell renderer.
func NewCellRendererToggle() *CellRendererToggle {
	var _cret *C.GtkCellRenderer // in

	_cret = C.gtk_cell_renderer_toggle_new()

	var _cellRendererToggle *CellRendererToggle // out

	_cellRendererToggle = wrapCellRendererToggle(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellRendererToggle
}

// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
//
// The function returns the following values:
//
//   - ok: TRUE if the cell renderer is activatable.
func (toggle *CellRendererToggle) Activatable() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))

	_cret = C.gtk_cell_renderer_toggle_get_activatable(_arg0)
	runtime.KeepAlive(toggle)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
//
// The function returns the following values:
//
//   - ok: TRUE if the cell renderer is active.
func (toggle *CellRendererToggle) Active() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))

	_cret = C.gtk_cell_renderer_toggle_get_active(_arg0)
	runtime.KeepAlive(toggle)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Radio returns whether we’re rendering radio toggles rather than checkboxes.
//
// The function returns the following values:
//
//   - ok: TRUE if we’re rendering radio toggles rather than checkboxes.
func (toggle *CellRendererToggle) Radio() bool {
	var _arg0 *C.GtkCellRendererToggle // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))

	_cret = C.gtk_cell_renderer_toggle_get_radio(_arg0)
	runtime.KeepAlive(toggle)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatable makes the cell renderer activatable.
//
// The function takes the following parameters:
//
//   - setting: value to set.
func (toggle *CellRendererToggle) SetActivatable(setting bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_activatable(_arg0, _arg1)
	runtime.KeepAlive(toggle)
	runtime.KeepAlive(setting)
}

// SetActive activates or deactivates a cell renderer.
//
// The function takes the following parameters:
//
//   - setting: value to set.
func (toggle *CellRendererToggle) SetActive(setting bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_active(_arg0, _arg1)
	runtime.KeepAlive(toggle)
	runtime.KeepAlive(setting)
}

// SetRadio: if radio is TRUE, the cell renderer renders a radio toggle (i.e.
// a toggle in a group of mutually-exclusive toggles). If FALSE, it renders a
// check toggle (a standalone boolean option). This can be set globally for the
// cell renderer, or changed just before rendering each cell in the model (for
// TreeView, you set up a per-row setting using TreeViewColumn to associate
// model columns with cell renderer properties).
//
// The function takes the following parameters:
//
//   - radio: TRUE to make the toggle look like a radio button.
func (toggle *CellRendererToggle) SetRadio(radio bool) {
	var _arg0 *C.GtkCellRendererToggle // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(coreglib.InternObject(toggle).Native()))
	if radio {
		_arg1 = C.TRUE
	}

	C.gtk_cell_renderer_toggle_set_radio(_arg0, _arg1)
	runtime.KeepAlive(toggle)
	runtime.KeepAlive(radio)
}

// CellView: widget displaying a single row of a GtkTreeModel
//
// A CellView displays a single row of a TreeModel using a CellArea and
// CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with each other (like the aligned cells in the menus of ComboBox).
//
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
//
// # CSS nodes
//
// GtkCellView has a single CSS node with name cellview.
type CellView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellLayout
	Orientable
}

var (
	_ Widgetter         = (*CellView)(nil)
	_ coreglib.Objector = (*CellView)(nil)
)

func wrapCellView(obj *coreglib.Object) *CellView {
	return &CellView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		CellLayout: CellLayout{
			Object: obj,
		},
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalCellView(p uintptr) (interface{}, error) {
	return wrapCellView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCellView creates a new CellView widget.
//
// The function returns the following values:
//
//   - cellView: newly created CellView widget.
func NewCellView() *CellView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_cell_view_new()

	var _cellView *CellView // out

	_cellView = wrapCellView(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithContext creates a new CellView widget with a specific CellArea
// to layout cells and a specific CellAreaContext.
//
// Specifying the same context for a handful of cells lets the underlying
// area synchronize the geometry for those cells, in this way alignments with
// cellviews for other rows are possible.
//
// The function takes the following parameters:
//
//   - area to layout cells.
//   - context in which to calculate cell geometry.
//
// The function returns the following values:
//
//   - cellView: newly created CellView widget.
func NewCellViewWithContext(area CellAreaer, context *CellAreaContext) *CellView {
	var _arg1 *C.GtkCellArea        // out
	var _arg2 *C.GtkCellAreaContext // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg2 = (*C.GtkCellAreaContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_cell_view_new_with_context(_arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)

	var _cellView *CellView // out

	_cellView = wrapCellView(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithMarkup creates a new CellView widget, adds a CellRendererText
// to it, and makes it show markup. The text can be marked up with the [Pango
// text markup language][PangoMarkupFormat].
//
// The function takes the following parameters:
//
//   - markup: text to display in the cell view.
//
// The function returns the following values:
//
//   - cellView: newly created CellView widget.
func NewCellViewWithMarkup(markup string) *CellView {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(markup)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_cell_view_new_with_markup(_arg1)
	runtime.KeepAlive(markup)

	var _cellView *CellView // out

	_cellView = wrapCellView(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithText creates a new CellView widget, adds a CellRendererText to
// it, and makes it show text.
//
// The function takes the following parameters:
//
//   - text to display in the cell view.
//
// The function returns the following values:
//
//   - cellView: newly created CellView widget.
func NewCellViewWithText(text string) *CellView {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_cell_view_new_with_text(_arg1)
	runtime.KeepAlive(text)

	var _cellView *CellView // out

	_cellView = wrapCellView(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// NewCellViewWithTexture creates a new CellView widget, adds a
// CellRendererPixbuf to it, and makes it show texture.
//
// The function takes the following parameters:
//
//   - texture: image to display in the cell view.
//
// The function returns the following values:
//
//   - cellView: newly created CellView widget.
func NewCellViewWithTexture(texture gdk.Texturer) *CellView {
	var _arg1 *C.GdkTexture // out
	var _cret *C.GtkWidget  // in

	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))

	_cret = C.gtk_cell_view_new_with_texture(_arg1)
	runtime.KeepAlive(texture)

	var _cellView *CellView // out

	_cellView = wrapCellView(coreglib.Take(unsafe.Pointer(_cret)))

	return _cellView
}

// DisplayedRow returns a TreePath referring to the currently displayed row.
// If no row is currently displayed, NULL is returned.
//
// The function returns the following values:
//
//   - treePath (optional): currently displayed row or NULL.
func (cellView *CellView) DisplayedRow() *TreePath {
	var _arg0 *C.GtkCellView // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))

	_cret = C.gtk_cell_view_get_displayed_row(_arg0)
	runtime.KeepAlive(cellView)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// DrawSensitive gets whether cell_view is configured to draw all of its cells
// in a sensitive state.
//
// The function returns the following values:
//
//   - ok: whether cell_view draws all of its cells in a sensitive state.
func (cellView *CellView) DrawSensitive() bool {
	var _arg0 *C.GtkCellView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))

	_cret = C.gtk_cell_view_get_draw_sensitive(_arg0)
	runtime.KeepAlive(cellView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FitModel gets whether cell_view is configured to request space to fit the
// entire TreeModel.
//
// The function returns the following values:
//
//   - ok: whether cell_view requests space to fit the entire TreeModel.
func (cellView *CellView) FitModel() bool {
	var _arg0 *C.GtkCellView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))

	_cret = C.gtk_cell_view_get_fit_model(_arg0)
	runtime.KeepAlive(cellView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Model returns the model for cell_view. If no model is used NULL is returned.
//
// The function returns the following values:
//
//   - treeModel (optional) used or NULL.
func (cellView *CellView) Model() *TreeModel {
	var _arg0 *C.GtkCellView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))

	_cret = C.gtk_cell_view_get_model(_arg0)
	runtime.KeepAlive(cellView)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// SetDisplayedRow sets the row of the model that is currently displayed by the
// CellView. If the path is unset, then the contents of the cellview “stick” at
// their last value; this is not normally a desired result, but may be a needed
// intermediate state if say, the model for the CellView becomes temporarily
// empty.
//
// The function takes the following parameters:
//
//   - path (optional) or NULL to unset.
func (cellView *CellView) SetDisplayedRow(path *TreePath) {
	var _arg0 *C.GtkCellView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}

	C.gtk_cell_view_set_displayed_row(_arg0, _arg1)
	runtime.KeepAlive(cellView)
	runtime.KeepAlive(path)
}

// SetDrawSensitive sets whether cell_view should draw all of its cells in a
// sensitive state, this is used by ComboBox menus to ensure that rows with
// insensitive cells that contain children appear sensitive in the parent menu
// item.
//
// The function takes the following parameters:
//
//   - drawSensitive: whether to draw all cells in a sensitive state.
func (cellView *CellView) SetDrawSensitive(drawSensitive bool) {
	var _arg0 *C.GtkCellView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))
	if drawSensitive {
		_arg1 = C.TRUE
	}

	C.gtk_cell_view_set_draw_sensitive(_arg0, _arg1)
	runtime.KeepAlive(cellView)
	runtime.KeepAlive(drawSensitive)
}

// SetFitModel sets whether cell_view should request space to fit the entire
// TreeModel.
//
// This is used by ComboBox to ensure that the cell view displayed on the combo
// box’s button always gets enough space and does not resize when selection
// changes.
//
// The function takes the following parameters:
//
//   - fitModel: whether cell_view should request space for the whole model.
func (cellView *CellView) SetFitModel(fitModel bool) {
	var _arg0 *C.GtkCellView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))
	if fitModel {
		_arg1 = C.TRUE
	}

	C.gtk_cell_view_set_fit_model(_arg0, _arg1)
	runtime.KeepAlive(cellView)
	runtime.KeepAlive(fitModel)
}

// SetModel sets the model for cell_view. If cell_view already has a model set,
// it will remove it before setting the new model. If model is NULL, then it
// will unset the old model.
//
// The function takes the following parameters:
//
//   - model (optional): TreeModel.
func (cellView *CellView) SetModel(model TreeModeller) {
	var _arg0 *C.GtkCellView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkCellView)(unsafe.Pointer(coreglib.InternObject(cellView).Native()))
	if model != nil {
		_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_cell_view_set_model(_arg0, _arg1)
	runtime.KeepAlive(cellView)
	runtime.KeepAlive(model)
}

// CenterBox: GtkCenterBox arranges three children in a row, keeping the middle
// child centered as well as possible.
//
// !An example GtkCenterBox (centerbox.png)
//
// To add children to GtkCenterBox, use gtk.CenterBox.SetStartWidget(),
// gtk.CenterBox.SetCenterWidget() and gtk.CenterBox.SetEndWidget().
//
// The sizing and positioning of children can be influenced with the align and
// expand properties of the children.
//
// # GtkCenterBox as GtkBuildable
//
// The GtkCenterBox implementation of the GtkBuildable interface supports
// placing children in the 3 positions by specifying “start”, “center” or “end”
// as the “type” attribute of a <child> element.
//
// # CSS nodes
//
// GtkCenterBox uses a single CSS node with the name “box”,
//
// The first child of the GtkCenterBox will be allocated depending on the text
// direction, i.e. in left-to-right layouts it will be allocated on the left and
// in right-to-left layouts on the right.
//
// In vertical orientation, the nodes of the children are arranged from top to
// bottom.
//
// # Accessibility
//
// GtkCenterBox uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type CenterBox struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*CenterBox)(nil)
	_ coreglib.Objector = (*CenterBox)(nil)
)

func wrapCenterBox(obj *coreglib.Object) *CenterBox {
	return &CenterBox{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalCenterBox(p uintptr) (interface{}, error) {
	return wrapCenterBox(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCenterBox creates a new GtkCenterBox.
//
// The function returns the following values:
//
//   - centerBox: new GtkCenterBox.
func NewCenterBox() *CenterBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_center_box_new()

	var _centerBox *CenterBox // out

	_centerBox = wrapCenterBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _centerBox
}

// BaselinePosition gets the value set by
// gtk_center_box_set_baseline_position().
//
// The function returns the following values:
//
//   - baselinePosition: baseline position.
func (self *CenterBox) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkCenterBox       // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_box_get_baseline_position(_arg0)
	runtime.KeepAlive(self)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// CenterWidget gets the center widget, or NULL if there is none.
//
// The function returns the following values:
//
//   - widget (optional): center widget.
func (self *CenterBox) CenterWidget() Widgetter {
	var _arg0 *C.GtkCenterBox // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_box_get_center_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// EndWidget gets the end widget, or NULL if there is none.
//
// The function returns the following values:
//
//   - widget (optional): end widget.
func (self *CenterBox) EndWidget() Widgetter {
	var _arg0 *C.GtkCenterBox // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_box_get_end_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// StartWidget gets the start widget, or NULL if there is none.
//
// The function returns the following values:
//
//   - widget (optional): start widget.
func (self *CenterBox) StartWidget() Widgetter {
	var _arg0 *C.GtkCenterBox // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_box_get_start_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SetBaselinePosition sets the baseline position of a center box.
//
// This affects only horizontal boxes with at least one baseline aligned child.
// If there is more vertical space available than requested, and the baseline
// is not allocated by the parent then position is used to allocate the baseline
// wrt. the extra space available.
//
// The function takes the following parameters:
//
//   - position: GtkBaselinePosition.
func (self *CenterBox) SetBaselinePosition(position BaselinePosition) {
	var _arg0 *C.GtkCenterBox       // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkBaselinePosition(position)

	C.gtk_center_box_set_baseline_position(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// SetCenterWidget sets the center widget.
//
// To remove the existing center widget, pas NULL.
//
// The function takes the following parameters:
//
//   - child (optional): new center widget, or NULL.
func (self *CenterBox) SetCenterWidget(child Widgetter) {
	var _arg0 *C.GtkCenterBox // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_center_box_set_center_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// SetEndWidget sets the end widget.
//
// To remove the existing end widget, pass NULL.
//
// The function takes the following parameters:
//
//   - child (optional): new end widget, or NULL.
func (self *CenterBox) SetEndWidget(child Widgetter) {
	var _arg0 *C.GtkCenterBox // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_center_box_set_end_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// SetStartWidget sets the start widget.
//
// To remove the existing start widget, pass NULL.
//
// The function takes the following parameters:
//
//   - child (optional): new start widget, or NULL.
func (self *CenterBox) SetStartWidget(child Widgetter) {
	var _arg0 *C.GtkCenterBox // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_center_box_set_start_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// CenterLayoutOverrides contains methods that are overridable.
type CenterLayoutOverrides struct {
}

func defaultCenterLayoutOverrides(v *CenterLayout) CenterLayoutOverrides {
	return CenterLayoutOverrides{}
}

// CenterLayout: GtkCenterLayout is a layout manager that manages up to three
// children.
//
// The start widget is allocated at the start of the layout (left in
// left-to-right locales and right in right-to-left ones), and the end widget at
// the end.
//
// The center widget is centered regarding the full width of the layout's.
type CenterLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*CenterLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CenterLayout, *CenterLayoutClass, CenterLayoutOverrides](
		GTypeCenterLayout,
		initCenterLayoutClass,
		wrapCenterLayout,
		defaultCenterLayoutOverrides,
	)
}

func initCenterLayoutClass(gclass unsafe.Pointer, overrides CenterLayoutOverrides, classInitFunc func(*CenterLayoutClass)) {
	if classInitFunc != nil {
		class := (*CenterLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCenterLayout(obj *coreglib.Object) *CenterLayout {
	return &CenterLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalCenterLayout(p uintptr) (interface{}, error) {
	return wrapCenterLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCenterLayout creates a new GtkCenterLayout.
//
// The function returns the following values:
//
//   - centerLayout: newly created GtkCenterLayout.
func NewCenterLayout() *CenterLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_center_layout_new()

	var _centerLayout *CenterLayout // out

	_centerLayout = wrapCenterLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _centerLayout
}

// BaselinePosition returns the baseline position of the layout.
//
// The function returns the following values:
//
//   - baselinePosition: current baseline position of self.
func (self *CenterLayout) BaselinePosition() BaselinePosition {
	var _arg0 *C.GtkCenterLayout    // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_layout_get_baseline_position(_arg0)
	runtime.KeepAlive(self)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// CenterWidget returns the center widget of the layout.
//
// The function returns the following values:
//
//   - widget (optional): current center widget of self.
func (self *CenterLayout) CenterWidget() Widgetter {
	var _arg0 *C.GtkCenterLayout // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_layout_get_center_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// EndWidget returns the end widget of the layout.
//
// The function returns the following values:
//
//   - widget (optional): current end widget of self.
func (self *CenterLayout) EndWidget() Widgetter {
	var _arg0 *C.GtkCenterLayout // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_layout_get_end_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Orientation gets the current orienration of the layout manager.
//
// The function returns the following values:
//
//   - orientation: current orientation of self.
func (self *CenterLayout) Orientation() Orientation {
	var _arg0 *C.GtkCenterLayout // out
	var _cret C.GtkOrientation   // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_layout_get_orientation(_arg0)
	runtime.KeepAlive(self)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// StartWidget returns the start widget fo the layout.
//
// The function returns the following values:
//
//   - widget (optional): current start widget of self.
func (self *CenterLayout) StartWidget() Widgetter {
	var _arg0 *C.GtkCenterLayout // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_center_layout_get_start_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SetBaselinePosition sets the new baseline position of self.
//
// The function takes the following parameters:
//
//   - baselinePosition: new baseline position.
func (self *CenterLayout) SetBaselinePosition(baselinePosition BaselinePosition) {
	var _arg0 *C.GtkCenterLayout    // out
	var _arg1 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkBaselinePosition(baselinePosition)

	C.gtk_center_layout_set_baseline_position(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(baselinePosition)
}

// SetCenterWidget sets the new center widget of self.
//
// To remove the existing center widget, pass NULL.
//
// The function takes the following parameters:
//
//   - widget (optional): new center widget.
func (self *CenterLayout) SetCenterWidget(widget Widgetter) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_center_layout_set_center_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(widget)
}

// SetEndWidget sets the new end widget of self.
//
// To remove the existing center widget, pass NULL.
//
// The function takes the following parameters:
//
//   - widget (optional): new end widget.
func (self *CenterLayout) SetEndWidget(widget Widgetter) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_center_layout_set_end_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(widget)
}

// SetOrientation sets the orientation of self.
//
// The function takes the following parameters:
//
//   - orientation: new orientation.
func (self *CenterLayout) SetOrientation(orientation Orientation) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 C.GtkOrientation   // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkOrientation(orientation)

	C.gtk_center_layout_set_orientation(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(orientation)
}

// SetStartWidget sets the new start widget of self.
//
// To remove the existing start widget, pass NULL.
//
// The function takes the following parameters:
//
//   - widget (optional): new start widget.
func (self *CenterLayout) SetStartWidget(widget Widgetter) {
	var _arg0 *C.GtkCenterLayout // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_center_layout_set_start_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(widget)
}

// CheckButtonOverrides contains methods that are overridable.
type CheckButtonOverrides struct {
	Activate func()
	Toggled  func()
}

func defaultCheckButtonOverrides(v *CheckButton) CheckButtonOverrides {
	return CheckButtonOverrides{
		Activate: v.activate,
		Toggled:  v.toggled,
	}
}

// CheckButton: GtkCheckButton places a label next to an indicator.
//
// !Example GtkCheckButtons (check-button.png)
//
// A GtkCheckButton is created by calling either gtk.CheckButton.New or
// gtk.CheckButton.NewWithLabel.
//
// The state of a GtkCheckButton can be set specifically using
// gtk.CheckButton.SetActive(), and retrieved using gtk.CheckButton.GetActive().
//
// # Inconsistent state
//
// In addition to "on" and "off", check buttons can be an "in between" state
// that is neither on nor off. This can be used e.g. when the user has
// selected a range of elements (such as some text or spreadsheet cells) that
// are affected by a check button, and the current values in that range are
// inconsistent.
//
// To set a GtkCheckButton to inconsistent state, use
// gtk.CheckButton.SetInconsistent().
//
// # Grouping
//
// Check buttons can be grouped together, to form mutually exclusive groups -
// only one of the buttons can be toggled at a time, and toggling another one
// will switch the currently toggled one off.
//
// Grouped check buttons use a different indicator, and are commonly referred to
// as *radio buttons*.
//
// !Example GtkCheckButtons (radio-button.png)
//
// To add a GtkCheckButton to a group, use gtk.CheckButton.SetGroup().
//
// CSS nodes
//
//	checkbutton[.text-button]
//	├── check
//	╰── [label]
//
// A GtkCheckButton has a main node with name checkbutton. If the
// gtk.CheckButton:label property is set, it contains a label child.
// The indicator node is named check when no group is set, and radio if the
// checkbutton is grouped together with other checkbuttons.
//
// # Accessibility
//
// GtkCheckButton uses the GTK_ACCESSIBLE_ROLE_CHECKBOX role.
type CheckButton struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Actionable
}

var (
	_ Widgetter         = (*CheckButton)(nil)
	_ coreglib.Objector = (*CheckButton)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CheckButton, *CheckButtonClass, CheckButtonOverrides](
		GTypeCheckButton,
		initCheckButtonClass,
		wrapCheckButton,
		defaultCheckButtonOverrides,
	)
}

func initCheckButtonClass(gclass unsafe.Pointer, overrides CheckButtonOverrides, classInitFunc func(*CheckButtonClass)) {
	pclass := (*C.GtkCheckButtonClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeCheckButton))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_CheckButtonClass_activate)
	}

	if overrides.Toggled != nil {
		pclass.toggled = (*[0]byte)(C._gotk4_gtk4_CheckButtonClass_toggled)
	}

	if classInitFunc != nil {
		class := (*CheckButtonClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCheckButton(obj *coreglib.Object) *CheckButton {
	return &CheckButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Actionable: Actionable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalCheckButton(p uintptr) (interface{}, error) {
	return wrapCheckButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted to when the check button is activated.
//
// The ::activate signal on GtkCheckButton is an action signal and emitting it
// causes the button to animate press then release.
//
// Applications should never connect to this signal, but use the
// gtk.CheckButton::toggled signal.
func (self *CheckButton) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate", false, unsafe.Pointer(C._gotk4_gtk4_CheckButton_ConnectActivate), f)
}

// ConnectToggled is emitted when the buttons's gtk.CheckButton:active property
// changes.
func (self *CheckButton) ConnectToggled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "toggled", false, unsafe.Pointer(C._gotk4_gtk4_CheckButton_ConnectToggled), f)
}

// NewCheckButton creates a new GtkCheckButton.
//
// The function returns the following values:
//
//   - checkButton: new GtkCheckButton.
func NewCheckButton() *CheckButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_check_button_new()

	var _checkButton *CheckButton // out

	_checkButton = wrapCheckButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// NewCheckButtonWithLabel creates a new GtkCheckButton with the given text.
//
// The function takes the following parameters:
//
//   - label (optional): text for the check button.
//
// The function returns the following values:
//
//   - checkButton: new GtkCheckButton.
func NewCheckButtonWithLabel(label string) *CheckButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_check_button_new_with_label(_arg1)
	runtime.KeepAlive(label)

	var _checkButton *CheckButton // out

	_checkButton = wrapCheckButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// NewCheckButtonWithMnemonic creates a new GtkCheckButton with the given text
// and a mnemonic.
//
// The function takes the following parameters:
//
//   - label (optional): text of the button, with an underscore in front of the
//     mnemonic character.
//
// The function returns the following values:
//
//   - checkButton: new GtkCheckButton.
func NewCheckButtonWithMnemonic(label string) *CheckButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_check_button_new_with_mnemonic(_arg1)
	runtime.KeepAlive(label)

	var _checkButton *CheckButton // out

	_checkButton = wrapCheckButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _checkButton
}

// Active returns whether the check button is active.
//
// The function returns the following values:
//
//   - ok: whether the check button is active.
func (self *CheckButton) Active() bool {
	var _arg0 *C.GtkCheckButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_check_button_get_active(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Inconsistent returns whether the check button is in an inconsistent state.
//
// The function returns the following values:
//
//   - ok: TRUE if check_button is currently in an inconsistent state.
func (checkButton *CheckButton) Inconsistent() bool {
	var _arg0 *C.GtkCheckButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(checkButton).Native()))

	_cret = C.gtk_check_button_get_inconsistent(_arg0)
	runtime.KeepAlive(checkButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Label returns the label of the check button.
//
// The function returns the following values:
//
//   - utf8 (optional): label self shows next to the indicator. If no label is
//     shown, NULL will be returned.
func (self *CheckButton) Label() string {
	var _arg0 *C.GtkCheckButton // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_check_button_get_label(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UseUnderline returns whether underlines in the label indicate mnemonics.
//
// The function returns the following values:
//
//   - ok: value of the gtk.CheckButton:use-underline property. See
//     gtk.CheckButton.SetUseUnderline() for details on how to set a new value.
func (self *CheckButton) UseUnderline() bool {
	var _arg0 *C.GtkCheckButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_check_button_get_use_underline(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive changes the check buttons active state.
//
// The function takes the following parameters:
//
//   - setting: new value to set.
func (self *CheckButton) SetActive(setting bool) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_check_button_set_active(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetGroup adds self to the group of group.
//
// In a group of multiple check buttons, only one button can be active at a
// time. The behavior of a checkbutton in a group is also commonly known as a
// *radio button*.
//
// Setting the group of a check button also changes the css name of the
// indicator widget's CSS node to 'radio'.
//
// Setting up groups in a cycle leads to undefined behavior.
//
// Note that the same effect can be achieved via the gtk.Actionable API, by
// using the same action with parameter type and state type 's' for all buttons
// in the group, and giving each button its own target value.
//
// The function takes the following parameters:
//
//   - group (optional): another GtkCheckButton to form a group with.
func (self *CheckButton) SetGroup(group *CheckButton) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 *C.GtkCheckButton // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if group != nil {
		_arg1 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	}

	C.gtk_check_button_set_group(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(group)
}

// SetInconsistent sets the GtkCheckButton to inconsistent state.
//
// You shoud turn off the inconsistent state again if the user checks the check
// button. This has to be done manually.
//
// The function takes the following parameters:
//
//   - inconsistent: TRUE if state is inconsistent.
func (checkButton *CheckButton) SetInconsistent(inconsistent bool) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(checkButton).Native()))
	if inconsistent {
		_arg1 = C.TRUE
	}

	C.gtk_check_button_set_inconsistent(_arg0, _arg1)
	runtime.KeepAlive(checkButton)
	runtime.KeepAlive(inconsistent)
}

// SetLabel sets the text of self.
//
// If gtk.CheckButton:use-underline is TRUE, an underscore in label is
// interpreted as mnemonic indicator, see gtk.CheckButton.SetUseUnderline() for
// details on this behavior.
//
// The function takes the following parameters:
//
//   - label (optional): text shown next to the indicator, or NULL to show no
//     text.
func (self *CheckButton) SetLabel(label string) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_check_button_set_label(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(label)
}

// SetUseUnderline sets whether underlines in the label indicate mnemonics.
//
// If setting is TRUE, an underscore character in self's label
// indicates a mnemonic accelerator key. This behavior is similar to
// gtk.Label:use-underline.
//
// The function takes the following parameters:
//
//   - setting: new value to set.
func (self *CheckButton) SetUseUnderline(setting bool) {
	var _arg0 *C.GtkCheckButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_check_button_set_use_underline(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

func (checkButton *CheckButton) activate() {
	gclass := (*C.GtkCheckButtonClass)(coreglib.PeekParentClass(checkButton))
	fnarg := gclass.activate

	var _arg0 *C.GtkCheckButton // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(checkButton).Native()))

	C._gotk4_gtk4_CheckButton_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(checkButton)
}

func (checkButton *CheckButton) toggled() {
	gclass := (*C.GtkCheckButtonClass)(coreglib.PeekParentClass(checkButton))
	fnarg := gclass.toggled

	var _arg0 *C.GtkCheckButton // out

	_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(coreglib.InternObject(checkButton).Native()))

	C._gotk4_gtk4_CheckButton_virtual_toggled(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(checkButton)
}

// ClosureExpression: expression using a custom GClosure to compute the value
// from its parameters.
type ClosureExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*ClosureExpression)(nil)
)

func wrapClosureExpression(obj *coreglib.Object) *ClosureExpression {
	return &ClosureExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalClosureExpression(p uintptr) (interface{}, error) {
	return wrapClosureExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ColorButton: GtkColorButton allows to open a color chooser dialog to change
// the color.
//
// !An example GtkColorButton (color-button.png)
//
// It is suitable widget for selecting a color in a preference dialog.
//
// CSS nodes
//
//	colorbutton
//	╰── button.color
//	    ╰── [content]
//
// GtkColorButton has a single CSS node with name colorbutton which contains a
// button node. To differentiate it from a plain GtkButton, it gets the .color
// style class.
type ColorButton struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	ColorChooser
}

var (
	_ Widgetter         = (*ColorButton)(nil)
	_ coreglib.Objector = (*ColorButton)(nil)
)

func wrapColorButton(obj *coreglib.Object) *ColorButton {
	return &ColorButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		ColorChooser: ColorChooser{
			Object: obj,
		},
	}
}

func marshalColorButton(p uintptr) (interface{}, error) {
	return wrapColorButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectColorSet is emitted when the user selects a color.
//
// When handling this signal, use gtk.ColorChooser.GetRGBA() to find out which
// color was just selected.
//
// Note that this signal is only emitted when the user changes the color. If you
// need to react to programmatic color changes as well, use the notify::color
// signal.
func (button *ColorButton) ConnectColorSet(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(button, "color-set", false, unsafe.Pointer(C._gotk4_gtk4_ColorButton_ConnectColorSet), f)
}

// NewColorButton creates a new color button.
//
// This returns a widget in the form of a small button containing a swatch
// representing the current selected color. When the button is clicked,
// a color chooser dialog will open, allowing the user to select a color.
// The swatch will be updated to reflect the new color when the user finishes.
//
// The function returns the following values:
//
//   - colorButton: new color button.
func NewColorButton() *ColorButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_color_button_new()

	var _colorButton *ColorButton // out

	_colorButton = wrapColorButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _colorButton
}

// NewColorButtonWithRGBA creates a new color button showing the given color.
//
// The function takes the following parameters:
//
//   - rgba: GdkRGBA to set the current color with.
//
// The function returns the following values:
//
//   - colorButton: new color button.
func NewColorButtonWithRGBA(rgba *gdk.RGBA) *ColorButton {
	var _arg1 *C.GdkRGBA   // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(rgba)))

	_cret = C.gtk_color_button_new_with_rgba(_arg1)
	runtime.KeepAlive(rgba)

	var _colorButton *ColorButton // out

	_colorButton = wrapColorButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _colorButton
}

// Modal gets whether the dialog is modal.
//
// The function returns the following values:
//
//   - ok: TRUE if the dialog is modal.
func (button *ColorButton) Modal() bool {
	var _arg0 *C.GtkColorButton // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_color_button_get_modal(_arg0)
	runtime.KeepAlive(button)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title gets the title of the color chooser dialog.
//
// The function returns the following values:
//
//   - utf8: internal string, do not free the return value.
func (button *ColorButton) Title() string {
	var _arg0 *C.GtkColorButton // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_color_button_get_title(_arg0)
	runtime.KeepAlive(button)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetModal sets whether the dialog should be modal.
//
// The function takes the following parameters:
//
//   - modal: TRUE to make the dialog modal.
func (button *ColorButton) SetModal(modal bool) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_color_button_set_modal(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(modal)
}

// SetTitle sets the title for the color chooser dialog.
//
// The function takes the following parameters:
//
//   - title: string containing new window title.
func (button *ColorButton) SetTitle(title string) {
	var _arg0 *C.GtkColorButton // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkColorButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_color_button_set_title(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(title)
}

// ColorChooserDialog: dialog for choosing a color.
//
// !An example GtkColorChooserDialog (colorchooser.png)
//
// GtkColorChooserDialog implements the gtk.ColorChooser interface and does not
// provide much API of its own.
//
// To create a GtkColorChooserDialog, use gtk.ColorChooserDialog.New.
//
// To change the initially selected color, use gtk.ColorChooser.SetRGBA().
// To get the selected color use gtk.ColorChooser.GetRGBA().
type ColorChooserDialog struct {
	_ [0]func() // equal guard
	Dialog

	*coreglib.Object
	ColorChooser
}

var (
	_ coreglib.Objector = (*ColorChooserDialog)(nil)
	_ Widgetter         = (*ColorChooserDialog)(nil)
)

func wrapColorChooserDialog(obj *coreglib.Object) *ColorChooserDialog {
	return &ColorChooserDialog{
		Dialog: Dialog{
			Window: Window{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
				Object: obj,
				Root: Root{
					NativeSurface: NativeSurface{
						Widget: Widget{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
							Object: obj,
							Accessible: Accessible{
								Object: obj,
							},
							Buildable: Buildable{
								Object: obj,
							},
							ConstraintTarget: ConstraintTarget{
								Object: obj,
							},
						},
					},
				},
				ShortcutManager: ShortcutManager{
					Object: obj,
				},
			},
		},
		Object: obj,
		ColorChooser: ColorChooser{
			Object: obj,
		},
	}
}

func marshalColorChooserDialog(p uintptr) (interface{}, error) {
	return wrapColorChooserDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewColorChooserDialog creates a new GtkColorChooserDialog.
//
// The function takes the following parameters:
//
//   - title (optional): title of the dialog, or NULL.
//   - parent (optional): transient parent of the dialog, or NULL.
//
// The function returns the following values:
//
//   - colorChooserDialog: new GtkColorChooserDialog.
func NewColorChooserDialog(title string, parent *Window) *ColorChooserDialog {
	var _arg1 *C.char      // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	if title != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if parent != nil {
		_arg2 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gtk_color_chooser_dialog_new(_arg1, _arg2)
	runtime.KeepAlive(title)
	runtime.KeepAlive(parent)

	var _colorChooserDialog *ColorChooserDialog // out

	_colorChooserDialog = wrapColorChooserDialog(coreglib.Take(unsafe.Pointer(_cret)))

	return _colorChooserDialog
}

// ColorChooserWidget: GtkColorChooserWidget widget lets the user select a
// color.
//
// By default, the chooser presents a predefined palette of colors, plus a small
// number of settable custom colors. It is also possible to select a different
// color with the single-color editor.
//
// To enter the single-color editing mode, use the context menu of any color of
// the palette, or use the '+' button to add a new custom color.
//
// The chooser automatically remembers the last selection, as well as custom
// colors.
//
// To create a GtkColorChooserWidget, use gtk.ColorChooserWidget.New.
//
// To change the initially selected color, use gtk.ColorChooser.SetRGBA().
// To get the selected color use gtk.ColorChooser.GetRGBA().
//
// The GtkColorChooserWidget is used in the gtk.ColorChooserDialog to provide a
// dialog for selecting colors.
//
// # CSS names
//
// GtkColorChooserWidget has a single CSS node with name colorchooser.
type ColorChooserWidget struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	ColorChooser
}

var (
	_ Widgetter         = (*ColorChooserWidget)(nil)
	_ coreglib.Objector = (*ColorChooserWidget)(nil)
)

func wrapColorChooserWidget(obj *coreglib.Object) *ColorChooserWidget {
	return &ColorChooserWidget{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		ColorChooser: ColorChooser{
			Object: obj,
		},
	}
}

func marshalColorChooserWidget(p uintptr) (interface{}, error) {
	return wrapColorChooserWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewColorChooserWidget creates a new GtkColorChooserWidget.
//
// The function returns the following values:
//
//   - colorChooserWidget: new GtkColorChooserWidget.
func NewColorChooserWidget() *ColorChooserWidget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_color_chooser_widget_new()

	var _colorChooserWidget *ColorChooserWidget // out

	_colorChooserWidget = wrapColorChooserWidget(coreglib.Take(unsafe.Pointer(_cret)))

	return _colorChooserWidget
}

// ColumnView: GtkColumnView presents a large dynamic list of items using
// multiple columns with headers.
//
// GtkColumnView uses the factories of its columns to generate a cell widget for
// each column, for each visible item and displays them together as the row for
// this item.
//
// The gtk.ColumnView:show-row-separators and
// [propertyGtk.ColumnView:show-column-separators] properties offer a simple way
// to display separators between the rows or columns.
//
// GtkColumnView allows the user to select items according to the
// selection characteristics of the model. For models that allow multiple
// selected items, it is possible to turn on *rubberband selection*, using
// gtk.ColumnView:enable-rubberband.
//
// The column view supports sorting that can be customized by the user by
// clicking on column headers. To set this up, the GtkSorter returned by
// gtk.ColumnView.GetSorter() must be attached to a sort model for the data that
// the view is showing, and the columns must have sorters attached to them by
// calling gtk.ColumnViewColumn.SetSorter(). The initial sort order can be set
// with gtk.ColumnView.SortByColumn().
//
// The column view also supports interactive resizing and reordering of columns,
// via Drag-and-Drop of the column headers. This can be enabled or disabled with
// the gtk.ColumnView:reorderable and gtk.ColumnViewColumn:resizable properties.
//
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
//
// CSS nodes
//
//	columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
//	├── header
//	│   ├── <column header>
//	┊   ┊
//	│   ╰── <column header>
//	│
//	├── listview
//	│
//	┊
//	╰── [rubberband]
//
// GtkColumnView uses a single CSS node named columnview. It may carry the
// .column-separators style class, when gtk.ColumnView:show-column-separators
// property is set. Header widgets appear below a node with name header.
// The rows are contained in a GtkListView widget, so there is a listview
// node with the same structure as for a standalone GtkListView widget.
// If gtk.ColumnView:show-row-separators is set, it will be passed on to the
// list view, causing its CSS node to carry the .separators style class.
// For rubberband selection, a node with name rubberband is used.
//
// The main columnview node may also carry style classes to select the style
// of list presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
// # Accessibility
//
// GtkColumnView uses the GTK_ACCESSIBLE_ROLE_TREE_GRID role, header title
// widgets are using the GTK_ACCESSIBLE_ROLE_COLUMN_HEADER role. The row widgets
// are using the GTK_ACCESSIBLE_ROLE_ROW role, and individual cells are using
// the GTK_ACCESSIBLE_ROLE_GRID_CELL role.
type ColumnView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*ColumnView)(nil)
	_ coreglib.Objector = (*ColumnView)(nil)
)

func wrapColumnView(obj *coreglib.Object) *ColumnView {
	return &ColumnView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalColumnView(p uintptr) (interface{}, error) {
	return wrapColumnView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when a row has been activated by the user, usually
// via activating the GtkListBase|list.activate-item action.
//
// This allows for a convenient way to handle activation in a columnview.
// See gtk.ListItem.SetActivatable() for details on how to use this signal.
func (self *ColumnView) ConnectActivate(f func(position uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate", false, unsafe.Pointer(C._gotk4_gtk4_ColumnView_ConnectActivate), f)
}

// NewColumnView creates a new GtkColumnView.
//
// You most likely want to call gtk.ColumnView.AppendColumn() to add columns
// next.
//
// The function takes the following parameters:
//
//   - model (optional): list model to use, or NULL.
//
// The function returns the following values:
//
//   - columnView: new GtkColumnView.
func NewColumnView(model SelectionModeller) *ColumnView {
	var _arg1 *C.GtkSelectionModel // out
	var _cret *C.GtkWidget         // in

	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_column_view_new(_arg1)
	runtime.KeepAlive(model)

	var _columnView *ColumnView // out

	_columnView = wrapColumnView(coreglib.Take(unsafe.Pointer(_cret)))

	return _columnView
}

// AppendColumn appends the column to the end of the columns in self.
//
// The function takes the following parameters:
//
//   - column: GtkColumnViewColumn that hasn't been added to a GtkColumnView
//     yet.
func (self *ColumnView) AppendColumn(column *ColumnViewColumn) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 *C.GtkColumnViewColumn // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))

	C.gtk_column_view_append_column(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(column)
}

// Columns gets the list of columns in this column view.
//
// This list is constant over the lifetime of self and can be used to monitor
// changes to the columns of self by connecting to the ::items-changed signal.
//
// The function returns the following values:
//
//   - listModel: list managing the columns.
func (self *ColumnView) Columns() *gio.ListModel {
	var _arg0 *C.GtkColumnView // out
	var _cret *C.GListModel    // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_columns(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// EnableRubberband returns whether rows can be selected by dragging with the
// mouse.
//
// The function returns the following values:
//
//   - ok: TRUE if rubberband selection is enabled.
func (self *ColumnView) EnableRubberband() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_enable_rubberband(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Model gets the model that's currently used to read the items displayed.
//
// The function returns the following values:
//
//   - selectionModel (optional): model in use.
func (self *ColumnView) Model() *SelectionModel {
	var _arg0 *C.GtkColumnView     // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_model(_arg0)
	runtime.KeepAlive(self)

	var _selectionModel *SelectionModel // out

	if _cret != nil {
		_selectionModel = wrapSelectionModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _selectionModel
}

// Reorderable returns whether columns are reorderable.
//
// The function returns the following values:
//
//   - ok: TRUE if columns are reorderable.
func (self *ColumnView) Reorderable() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_reorderable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowColumnSeparators returns whether the list should show separators between
// columns.
//
// The function returns the following values:
//
//   - ok: TRUE if the list shows column separators.
func (self *ColumnView) ShowColumnSeparators() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_show_column_separators(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowRowSeparators returns whether the list should show separators between
// rows.
//
// The function returns the following values:
//
//   - ok: TRUE if the list shows separators.
func (self *ColumnView) ShowRowSeparators() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_show_row_separators(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SingleClickActivate returns whether rows will be activated on single click
// and selected on hover.
//
// The function returns the following values:
//
//   - ok: TRUE if rows are activated on single click.
func (self *ColumnView) SingleClickActivate() bool {
	var _arg0 *C.GtkColumnView // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_single_click_activate(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Sorter returns a special sorter that reflects the users sorting choices in
// the column view.
//
// To allow users to customizable sorting by clicking on column headers,
// this sorter needs to be set on the sort model underneath the model that is
// displayed by the view.
//
// See gtk.ColumnViewColumn.SetSorter() for setting up per-column sorting.
//
// Here is an example:
//
//	gtk_column_view_column_set_sorter (column, sorter);
//	gtk_column_view_append_column (view, column);
//	sorter = g_object_ref (gtk_column_view_get_sorter (view)));
//	model = gtk_sort_list_model_new (store, sorter);
//	selection = gtk_no_selection_new (model);
//	gtk_column_view_set_model (view, selection);.
//
// The function returns the following values:
//
//   - sorter (optional): GtkSorter of self.
func (self *ColumnView) Sorter() *Sorter {
	var _arg0 *C.GtkColumnView // out
	var _cret *C.GtkSorter     // in

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_get_sorter(_arg0)
	runtime.KeepAlive(self)

	var _sorter *Sorter // out

	if _cret != nil {
		_sorter = wrapSorter(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sorter
}

// InsertColumn inserts a column at the given position in the columns of self.
//
// If column is already a column of self, it will be repositioned.
//
// The function takes the following parameters:
//
//   - position to insert column at.
//   - column: GtkColumnViewColumn to insert.
func (self *ColumnView) InsertColumn(position uint, column *ColumnViewColumn) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 C.guint                // out
	var _arg2 *C.GtkColumnViewColumn // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)
	_arg2 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))

	C.gtk_column_view_insert_column(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
	runtime.KeepAlive(column)
}

// RemoveColumn removes the column from the list of columns of self.
//
// The function takes the following parameters:
//
//   - column: GtkColumnViewColumn that's part of self.
func (self *ColumnView) RemoveColumn(column *ColumnViewColumn) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 *C.GtkColumnViewColumn // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))

	C.gtk_column_view_remove_column(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(column)
}

// SetEnableRubberband sets whether selections can be changed by dragging with
// the mouse.
//
// The function takes the following parameters:
//
//   - enableRubberband: TRUE to enable rubberband selection.
func (self *ColumnView) SetEnableRubberband(enableRubberband bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enableRubberband {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_enable_rubberband(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enableRubberband)
}

// SetModel sets the model to use.
//
// This must be a gtk.SelectionModel.
//
// The function takes the following parameters:
//
//   - model (optional) to use or NULL for none.
func (self *ColumnView) SetModel(model SelectionModeller) {
	var _arg0 *C.GtkColumnView     // out
	var _arg1 *C.GtkSelectionModel // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_column_view_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetReorderable sets whether columns should be reorderable by dragging.
//
// The function takes the following parameters:
//
//   - reorderable: whether columns should be reorderable.
func (self *ColumnView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_reorderable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(reorderable)
}

// SetShowColumnSeparators sets whether the list should show separators between
// columns.
//
// The function takes the following parameters:
//
//   - showColumnSeparators: TRUE to show column separators.
func (self *ColumnView) SetShowColumnSeparators(showColumnSeparators bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if showColumnSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_show_column_separators(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(showColumnSeparators)
}

// SetShowRowSeparators sets whether the list should show separators between
// rows.
//
// The function takes the following parameters:
//
//   - showRowSeparators: TRUE to show row separators.
func (self *ColumnView) SetShowRowSeparators(showRowSeparators bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if showRowSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_show_row_separators(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(showRowSeparators)
}

// SetSingleClickActivate sets whether rows should be activated on single click
// and selected on hover.
//
// The function takes the following parameters:
//
//   - singleClickActivate: TRUE to activate items on single click.
func (self *ColumnView) SetSingleClickActivate(singleClickActivate bool) {
	var _arg0 *C.GtkColumnView // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if singleClickActivate {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_set_single_click_activate(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(singleClickActivate)
}

// SortByColumn sets the sorting of the view.
//
// This function should be used to set up the initial sorting. At runtime, users
// can change the sorting of a column view by clicking on the list headers.
//
// This call only has an effect if the sorter returned by
// gtk.ColumnView.GetSorter() is set on a sort model, and
// gtk.ColumnViewColumn.SetSorter() has been called on column to associate a
// sorter with the column.
//
// If column is NULL, the view will be unsorted.
//
// The function takes the following parameters:
//
//   - column (optional): GtkColumnViewColumn to sort by, or NULL.
//   - direction to sort in.
func (self *ColumnView) SortByColumn(column *ColumnViewColumn, direction SortType) {
	var _arg0 *C.GtkColumnView       // out
	var _arg1 *C.GtkColumnViewColumn // out
	var _arg2 C.GtkSortType          // out

	_arg0 = (*C.GtkColumnView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if column != nil {
		_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}
	_arg2 = C.GtkSortType(direction)

	C.gtk_column_view_sort_by_column(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(column)
	runtime.KeepAlive(direction)
}

// ColumnViewColumn: GtkColumnViewColumn represents the columns being added to
// GtkColumnView.
//
// The main ingredient for a GtkColumnViewColumn is the GtkListItemFactory that
// tells the columnview how to create cells for this column from items in the
// model.
//
// Columns have a title, and can optionally have a header menu set with
// gtk.ColumnViewColumn.SetHeaderMenu().
//
// A sorter can be associated with a column using
// gtk.ColumnViewColumn.SetSorter(), to let users influence sorting by clicking
// on the column header.
type ColumnViewColumn struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ColumnViewColumn)(nil)
)

func wrapColumnViewColumn(obj *coreglib.Object) *ColumnViewColumn {
	return &ColumnViewColumn{
		Object: obj,
	}
}

func marshalColumnViewColumn(p uintptr) (interface{}, error) {
	return wrapColumnViewColumn(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewColumnViewColumn creates a new GtkColumnViewColumn that uses the given
// factory for mapping items to widgets.
//
// You most likely want to call gtk.ColumnView.AppendColumn() next.
//
// The function takes ownership of the argument, so you can write code like:
//
//	column = gtk_column_view_column_new (_("Name"),
//	  gtk_builder_list_item_factory_new_from_resource ("/name.ui"));.
//
// The function takes the following parameters:
//
//   - title (optional): title to use for this column.
//   - factory (optional) to populate items with.
//
// The function returns the following values:
//
//   - columnViewColumn: new GtkColumnViewColumn using the given factory.
func NewColumnViewColumn(title string, factory *ListItemFactory) *ColumnViewColumn {
	var _arg1 *C.char                // out
	var _arg2 *C.GtkListItemFactory  // out
	var _cret *C.GtkColumnViewColumn // in

	if title != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if factory != nil {
		_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(factory).Native()))
	}

	_cret = C.gtk_column_view_column_new(_arg1, _arg2)
	runtime.KeepAlive(title)
	runtime.KeepAlive(factory)

	var _columnViewColumn *ColumnViewColumn // out

	_columnViewColumn = wrapColumnViewColumn(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _columnViewColumn
}

// ColumnView gets the column view that's currently displaying this column.
//
// If self has not been added to a column view yet, NULL is returned.
//
// The function returns the following values:
//
//   - columnView (optional): column view displaying self.
func (self *ColumnViewColumn) ColumnView() *ColumnView {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GtkColumnView       // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_column_view(_arg0)
	runtime.KeepAlive(self)

	var _columnView *ColumnView // out

	if _cret != nil {
		_columnView = wrapColumnView(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _columnView
}

// Expand returns whether this column should expand.
//
// The function returns the following values:
//
//   - ok: TRUE if this column expands.
func (self *ColumnViewColumn) Expand() bool {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_expand(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Factory gets the factory that's currently used to populate list items for
// this column.
//
// The function returns the following values:
//
//   - listItemFactory (optional): factory in use.
func (self *ColumnViewColumn) Factory() *ListItemFactory {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GtkListItemFactory  // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_factory(_arg0)
	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if _cret != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// FixedWidth gets the fixed width of the column.
//
// The function returns the following values:
//
//   - gint: fixed with of the column.
func (self *ColumnViewColumn) FixedWidth() int {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.int                  // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_fixed_width(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// HeaderMenu gets the menu model that is used to create the context menu for
// the column header.
//
// The function returns the following values:
//
//   - menuModel (optional) or NULL.
func (self *ColumnViewColumn) HeaderMenu() gio.MenuModeller {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GMenuModel          // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_header_menu(_arg0)
	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// Resizable returns whether this column is resizable.
//
// The function returns the following values:
//
//   - ok: TRUE if this column is resizable.
func (self *ColumnViewColumn) Resizable() bool {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_resizable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Sorter returns the sorter that is associated with the column.
//
// The function returns the following values:
//
//   - sorter (optional): GtkSorter of self.
func (self *ColumnViewColumn) Sorter() *Sorter {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.GtkSorter           // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_sorter(_arg0)
	runtime.KeepAlive(self)

	var _sorter *Sorter // out

	if _cret != nil {
		_sorter = wrapSorter(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sorter
}

// Title returns the title set with gtk_column_view_column_set_title().
//
// The function returns the following values:
//
//   - utf8 (optional) column's title.
func (self *ColumnViewColumn) Title() string {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_title(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Visible returns whether this column is visible.
//
// The function returns the following values:
//
//   - ok: TRUE if this column is visible.
func (self *ColumnViewColumn) Visible() bool {
	var _arg0 *C.GtkColumnViewColumn // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_column_view_column_get_visible(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetExpand sets the column to take available extra space.
//
// The extra space is shared equally amongst all columns that have the expand
// set to TRUE.
//
// The function takes the following parameters:
//
//   - expand: TRUE if this column should expand to fill available sace.
func (self *ColumnViewColumn) SetExpand(expand bool) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_column_set_expand(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expand)
}

// SetFactory sets the GtkListItemFactory to use for populating list items for
// this column.
//
// The function takes the following parameters:
//
//   - factory (optional) to use or NULL for none.
func (self *ColumnViewColumn) SetFactory(factory *ListItemFactory) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.GtkListItemFactory  // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	C.gtk_column_view_column_set_factory(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetFixedWidth: if fixed_width is not -1, sets the fixed width of column;
// otherwise unsets it.
//
// Setting a fixed width overrides the automatically calculated width.
// Interactive resizing also sets the “fixed-width” property.
//
// The function takes the following parameters:
//
//   - fixedWidth: new fixed width, or -1.
func (self *ColumnViewColumn) SetFixedWidth(fixedWidth int) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.int                  // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(fixedWidth)

	C.gtk_column_view_column_set_fixed_width(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(fixedWidth)
}

// SetHeaderMenu sets the menu model that is used to create the context menu for
// the column header.
//
// The function takes the following parameters:
//
//   - menu (optional): GMenuModel, or NULL.
func (self *ColumnViewColumn) SetHeaderMenu(menu gio.MenuModeller) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.GMenuModel          // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if menu != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(menu).Native()))
	}

	C.gtk_column_view_column_set_header_menu(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(menu)
}

// SetResizable sets whether this column should be resizable by dragging.
//
// The function takes the following parameters:
//
//   - resizable: whether this column should be resizable.
func (self *ColumnViewColumn) SetResizable(resizable bool) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_column_set_resizable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(resizable)
}

// SetSorter associates a sorter with the column.
//
// If sorter is NULL, the column will not let users change the sorting by
// clicking on its header.
//
// This sorter can be made active by clicking on the column header, or by
// calling gtk.ColumnView.SortByColumn().
//
// See gtk.ColumnView.GetSorter() for the necessary steps for setting up
// customizable sorting for gtk.ColumnView.
//
// The function takes the following parameters:
//
//   - sorter (optional): GtkSorter to associate with column.
func (self *ColumnViewColumn) SetSorter(sorter *Sorter) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.GtkSorter           // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if sorter != nil {
		_arg1 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(sorter).Native()))
	}

	C.gtk_column_view_column_set_sorter(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sorter)
}

// SetTitle sets the title of this column.
//
// The title is displayed in the header of a GtkColumnView for this column and
// is therefore user-facing text that should be translated.
//
// The function takes the following parameters:
//
//   - title (optional): title to use for this column.
func (self *ColumnViewColumn) SetTitle(title string) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 *C.char                // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if title != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_column_view_column_set_title(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(title)
}

// SetVisible sets whether this column should be visible in views.
//
// The function takes the following parameters:
//
//   - visible: whether this column should be visible.
func (self *ColumnViewColumn) SetVisible(visible bool) {
	var _arg0 *C.GtkColumnViewColumn // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_column_view_column_set_visible(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(visible)
}

// ComboBoxOverrides contains methods that are overridable.
type ComboBoxOverrides struct {
	Changed         func()
	FormatEntryText func(path string) string
}

func defaultComboBoxOverrides(v *ComboBox) ComboBoxOverrides {
	return ComboBoxOverrides{
		Changed:         v.changed,
		FormatEntryText: v.formatEntryText,
	}
}

// ComboBox: GtkComboBox is a widget that allows the user to choose from a list
// of valid choices.
//
// !An example GtkComboBox (combo-box.png)
//
// The GtkComboBox displays the selected choice; when activated, the GtkComboBox
// displays a popup which allows the user to make a new choice.
//
// The GtkComboBox uses the model-view pattern; the list of valid choices is
// specified in the form of a tree model, and the display of the choices can be
// adapted to the data in the model by using cell renderers, as you would in a
// tree view. This is possible since GtkComboBox implements the gtk.CellLayout
// interface. The tree model holding the valid choices is not restricted to
// a flat list, it can be a real tree, and the popup will reflect the tree
// structure.
//
// To allow the user to enter values not in the model, the
// gtk.ComboBox:has-entry property allows the GtkComboBox to contain a
// gtk.Entry. This entry can be accessed by calling gtk.ComboBox.GetChild() on
// the combo box.
//
// For a simple list of textual choices, the model-view API of GtkComboBox
// can be a bit overwhelming. In this case, gtk.ComboBoxText offers a simple
// alternative. Both GtkComboBox and GtkComboBoxText can contain an entry.
//
// CSS nodes
//
//	combobox
//	├── box.linked
//	│   ╰── button.combo
//	│       ╰── box
//	│           ├── cellview
//	│           ╰── arrow
//	╰── window.popup
//
// A normal combobox contains a box with the .linked class, a button with the
// .combo class and inside those buttons, there are a cellview and an arrow.
//
//	combobox
//	├── box.linked
//	│   ├── entry.combo
//	│   ╰── button.combo
//	│       ╰── box
//	│           ╰── arrow
//	╰── window.popup
//
// A GtkComboBox with an entry has a single CSS node with name combobox.
// It contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added. The button also contains another
// node with name arrow.
//
// # Accessibility
//
// GtkComboBox uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
type ComboBox struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellEditable
	CellLayout
}

var (
	_ Widgetter         = (*ComboBox)(nil)
	_ coreglib.Objector = (*ComboBox)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ComboBox, *ComboBoxClass, ComboBoxOverrides](
		GTypeComboBox,
		initComboBoxClass,
		wrapComboBox,
		defaultComboBoxOverrides,
	)
}

func initComboBoxClass(gclass unsafe.Pointer, overrides ComboBoxOverrides, classInitFunc func(*ComboBoxClass)) {
	pclass := (*C.GtkComboBoxClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeComboBox))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gtk4_ComboBoxClass_changed)
	}

	if overrides.FormatEntryText != nil {
		pclass.format_entry_text = (*[0]byte)(C._gotk4_gtk4_ComboBoxClass_format_entry_text)
	}

	if classInitFunc != nil {
		class := (*ComboBoxClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapComboBox(obj *coreglib.Object) *ComboBox {
	return &ComboBox{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		CellEditable: CellEditable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
		CellLayout: CellLayout{
			Object: obj,
		},
	}
}

func marshalComboBox(p uintptr) (interface{}, error) {
	return wrapComboBox(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the active item is changed.
//
// The can be due to the user selecting a different item from the list, or due
// to a call to gtk.ComboBox.SetActiveIter(). It will also be emitted while
// typing into the entry of a combo box with an entry.
func (comboBox *ComboBox) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(comboBox, "changed", false, unsafe.Pointer(C._gotk4_gtk4_ComboBox_ConnectChanged), f)
}

// ConnectFormatEntryText is emitted to allow changing how the text in a combo
// box's entry is displayed.
//
// See gtk.ComboBox:has-entry.
//
// Connect a signal handler which returns an allocated string representing path.
// That string will then be used to set the text in the combo box's entry. The
// default signal handler uses the text from the gtk.ComboBox:entry-text-column
// model column.
//
// Here's an example signal handler which fetches data from the model and
// displays it in the entry.
//
//	static char *
//	format_entry_text_callback (GtkComboBox *combo,
//	                            const char *path,
//	                            gpointer     user_data)
//	{
//	  GtkTreeIter iter;
//	  GtkTreeModel model;
//	  double       value;
//
//	  model = gtk_combo_box_get_model (combo);
//
//	  gtk_tree_model_get_iter_from_string (model, &iter, path);
//	  gtk_tree_model_get (model, &iter,
//	                      THE_DOUBLE_VALUE_COLUMN, &value,
//	                      -1);
//
//	  return g_strdup_printf ("g", value);
//	}.
func (comboBox *ComboBox) ConnectFormatEntryText(f func(path string) (utf8 string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(comboBox, "format-entry-text", false, unsafe.Pointer(C._gotk4_gtk4_ComboBox_ConnectFormatEntryText), f)
}

// ConnectMoveActive is emitted to move the active selection.
//
// This is an keybinding signal (class.SignalAction.html).
func (comboBox *ComboBox) ConnectMoveActive(f func(scrollType ScrollType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(comboBox, "move-active", false, unsafe.Pointer(C._gotk4_gtk4_ComboBox_ConnectMoveActive), f)
}

// ConnectPopdown is emitted to popdown the combo box list.
//
// This is an keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are Alt+Up and Escape.
func (comboBox *ComboBox) ConnectPopdown(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(comboBox, "popdown", false, unsafe.Pointer(C._gotk4_gtk4_ComboBox_ConnectPopdown), f)
}

// ConnectPopup is emitted to popup the combo box list.
//
// This is an keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is Alt+Down.
func (comboBox *ComboBox) ConnectPopup(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(comboBox, "popup", false, unsafe.Pointer(C._gotk4_gtk4_ComboBox_ConnectPopup), f)
}

// NewComboBox creates a new empty GtkComboBox.
//
// The function returns the following values:
//
//   - comboBox: new GtkComboBox.
func NewComboBox() *ComboBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_new()

	var _comboBox *ComboBox // out

	_comboBox = wrapComboBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithEntry creates a new empty GtkComboBox with an entry.
//
// The function returns the following values:
//
//   - comboBox: new GtkComboBox.
func NewComboBoxWithEntry() *ComboBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_new_with_entry()

	var _comboBox *ComboBox // out

	_comboBox = wrapComboBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithModel creates a new GtkComboBox with a model.
//
// The function takes the following parameters:
//
//   - model: GtkTreeModel.
//
// The function returns the following values:
//
//   - comboBox: new GtkComboBox.
func NewComboBoxWithModel(model TreeModeller) *ComboBox {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_combo_box_new_with_model(_arg1)
	runtime.KeepAlive(model)

	var _comboBox *ComboBox // out

	_comboBox = wrapComboBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// NewComboBoxWithModelAndEntry creates a new empty GtkComboBox with an entry
// and a model.
//
// The function takes the following parameters:
//
//   - model: GtkTreeModel.
//
// The function returns the following values:
//
//   - comboBox: new GtkComboBox.
func NewComboBoxWithModelAndEntry(model TreeModeller) *ComboBox {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_combo_box_new_with_model_and_entry(_arg1)
	runtime.KeepAlive(model)

	var _comboBox *ComboBox // out

	_comboBox = wrapComboBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _comboBox
}

// Active returns the index of the currently active item.
//
// If the model is a non-flat treemodel, and the active item is not
// an immediate child of the root of the tree, this function returns
// gtk_tree_path_get_indices (path)[0], where path is the gtk.TreePath of the
// active item.
//
// The function returns the following values:
//
//   - gint: integer which is the index of the currently active item, or -1 if
//     there’s no active item.
func (comboBox *ComboBox) Active() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.int          // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_active(_arg0)
	runtime.KeepAlive(comboBox)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ActiveID returns the ID of the active row of combo_box.
//
// This value is taken from the active row and the column specified
// by the gtk.ComboBox:id-column property of combo_box (see
// gtk.ComboBox.SetIDColumn()).
//
// The returned value is an interned string which means that you can compare the
// pointer by value to other interned strings and that you must not free it.
//
// If the gtk.ComboBox:id-column property of combo_box is not set, or if no row
// is active, or if the active row has a NULL ID value, then NULL is returned.
//
// The function returns the following values:
//
//   - utf8 (optional): ID of the active row, or NULL.
func (comboBox *ComboBox) ActiveID() string {
	var _arg0 *C.GtkComboBox // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_active_id(_arg0)
	runtime.KeepAlive(comboBox)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ActiveIter sets iter to point to the currently active item.
//
// If no item is active, iter is left unchanged.
//
// The function returns the following values:
//
//   - iter: GtkTreeIter.
//   - ok: TRUE if iter was set, FALSE otherwise.
func (comboBox *ComboBox) ActiveIter() (*TreeIter, bool) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.GtkTreeIter  // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_active_iter(_arg0, &_arg1)
	runtime.KeepAlive(comboBox)

	var _iter *TreeIter // out
	var _ok bool        // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// ButtonSensitivity returns whether the combo box sets the dropdown button
// sensitive or not when there are no items in the model.
//
// The function returns the following values:
//
//   - sensitivityType: GTK_SENSITIVITY_ON if the dropdown button is sensitive
//     when the model is empty, GTK_SENSITIVITY_OFF if the button is always
//     insensitive or GTK_SENSITIVITY_AUTO if it is only sensitive as long as
//     the model has one item to be selected.
func (comboBox *ComboBox) ButtonSensitivity() SensitivityType {
	var _arg0 *C.GtkComboBox       // out
	var _cret C.GtkSensitivityType // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_button_sensitivity(_arg0)
	runtime.KeepAlive(comboBox)

	var _sensitivityType SensitivityType // out

	_sensitivityType = SensitivityType(_cret)

	return _sensitivityType
}

// Child gets the child widget of combo_box.
//
// The function returns the following values:
//
//   - widget (optional): child widget of combo_box.
func (comboBox *ComboBox) Child() Widgetter {
	var _arg0 *C.GtkComboBox // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_child(_arg0)
	runtime.KeepAlive(comboBox)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// EntryTextColumn returns the column which combo_box is using to get the
// strings from to display in the internal entry.
//
// The function returns the following values:
//
//   - gint: column in the data source model of combo_box.
func (comboBox *ComboBox) EntryTextColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.int          // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_entry_text_column(_arg0)
	runtime.KeepAlive(comboBox)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// HasEntry returns whether the combo box has an entry.
//
// The function returns the following values:
//
//   - ok: whether there is an entry in combo_box.
func (comboBox *ComboBox) HasEntry() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_has_entry(_arg0)
	runtime.KeepAlive(comboBox)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IDColumn returns the column which combo_box is using to get string IDs for
// values from.
//
// The function returns the following values:
//
//   - gint: column in the data source model of combo_box.
func (comboBox *ComboBox) IDColumn() int {
	var _arg0 *C.GtkComboBox // out
	var _cret C.int          // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_id_column(_arg0)
	runtime.KeepAlive(comboBox)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Model returns the GtkTreeModel of combo_box.
//
// The function returns the following values:
//
//   - treeModel (optional): GtkTreeModel which was passed during construction.
func (comboBox *ComboBox) Model() *TreeModel {
	var _arg0 *C.GtkComboBox  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_model(_arg0)
	runtime.KeepAlive(comboBox)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// PopupFixedWidth gets whether the popup uses a fixed width.
//
// The function returns the following values:
//
//   - ok: TRUE if the popup uses a fixed width.
func (comboBox *ComboBox) PopupFixedWidth() bool {
	var _arg0 *C.GtkComboBox // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_get_popup_fixed_width(_arg0)
	runtime.KeepAlive(comboBox)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Popdown hides the menu or dropdown list of combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
func (comboBox *ComboBox) Popdown() {
	var _arg0 *C.GtkComboBox // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	C.gtk_combo_box_popdown(_arg0)
	runtime.KeepAlive(comboBox)
}

// Popup pops up the menu or dropdown list of combo_box.
//
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
//
// Before calling this, combo_box must be mapped, or nothing will happen.
func (comboBox *ComboBox) Popup() {
	var _arg0 *C.GtkComboBox // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	C.gtk_combo_box_popup(_arg0)
	runtime.KeepAlive(comboBox)
}

// PopupForDevice pops up the menu of combo_box.
//
// Note that currently this does not do anything with the device, as it was
// previously only used for list-mode combo boxes, and those were removed in GTK
// 4. However, it is retained in case similar functionality is added back later.
//
// The function takes the following parameters:
//
//   - device: GdkDevice.
func (comboBox *ComboBox) PopupForDevice(device gdk.Devicer) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GdkDevice   // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))

	C.gtk_combo_box_popup_for_device(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(device)
}

// SetActive sets the active item of combo_box to be the item at index.
//
// The function takes the following parameters:
//
//   - index_: index in the model passed during construction, or -1 to have no
//     active item.
func (comboBox *ComboBox) SetActive(index_ int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = C.int(index_)

	C.gtk_combo_box_set_active(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(index_)
}

// SetActiveID changes the active row of combo_box to the one that has an ID
// equal to active_id.
//
// If active_id is NULL, the active row is unset. Rows having a NULL ID string
// cannot be made active by this function.
//
// If the gtk.ComboBox:id-column property of combo_box is unset or if no row has
// the given ID then the function does nothing and returns FALSE.
//
// The function takes the following parameters:
//
//   - activeId (optional): ID of the row to select, or NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if a row with a matching ID was found. If a NULL active_id was
//     given to unset the active row, the function always returns TRUE.
func (comboBox *ComboBox) SetActiveID(activeId string) bool {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.char        // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if activeId != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(activeId)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_combo_box_set_active_id(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(activeId)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActiveIter sets the current active item to be the one referenced by iter.
//
// If iter is NULL, the active item is unset.
//
// The function takes the following parameters:
//
//   - iter (optional): GtkTreeIter, or NULL.
func (comboBox *ComboBox) SetActiveIter(iter *TreeIter) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GtkTreeIter // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if iter != nil {
		_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	C.gtk_combo_box_set_active_iter(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(iter)
}

// SetButtonSensitivity sets whether the dropdown button of the combo box should
// update its sensitivity depending on the model contents.
//
// The function takes the following parameters:
//
//   - sensitivity: specify the sensitivity of the dropdown button.
func (comboBox *ComboBox) SetButtonSensitivity(sensitivity SensitivityType) {
	var _arg0 *C.GtkComboBox       // out
	var _arg1 C.GtkSensitivityType // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = C.GtkSensitivityType(sensitivity)

	C.gtk_combo_box_set_button_sensitivity(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(sensitivity)
}

// SetChild sets the child widget of combo_box.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (comboBox *ComboBox) SetChild(child Widgetter) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_combo_box_set_child(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(child)
}

// SetEntryTextColumn sets the model column which combo_box should use to get
// strings from to be text_column.
//
// The column text_column in the model of combo_box must be of type
// G_TYPE_STRING.
//
// This is only relevant if combo_box has been created with
// gtk.ComboBox:has-entry as TRUE.
//
// The function takes the following parameters:
//
//   - textColumn: column in model to get the strings from for the internal
//     entry.
func (comboBox *ComboBox) SetEntryTextColumn(textColumn int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = C.int(textColumn)

	C.gtk_combo_box_set_entry_text_column(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(textColumn)
}

// SetIDColumn sets the model column which combo_box should use to get string
// IDs for values from.
//
// The column id_column in the model of combo_box must be of type G_TYPE_STRING.
//
// The function takes the following parameters:
//
//   - idColumn: column in model to get string IDs for values from.
func (comboBox *ComboBox) SetIDColumn(idColumn int) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = C.int(idColumn)

	C.gtk_combo_box_set_id_column(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(idColumn)
}

// SetModel sets the model used by combo_box to be model.
//
// Will unset a previously set model (if applicable). If model is NULL, then it
// will unset the model.
//
// Note that this function does not clear the cell renderers, you have to
// call gtk.CellLayout.Clear() yourself if you need to set up different cell
// renderers for the new model.
//
// The function takes the following parameters:
//
//   - model (optional): GtkTreeModel.
func (comboBox *ComboBox) SetModel(model TreeModeller) {
	var _arg0 *C.GtkComboBox  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if model != nil {
		_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_combo_box_set_model(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(model)
}

// SetPopupFixedWidth specifies whether the popup’s width should be a fixed
// width.
//
// If fixed is TRUE, the popup's width is set to match the allocated width of
// the combo box.
//
// The function takes the following parameters:
//
//   - fixed: whether to use a fixed popup width.
func (comboBox *ComboBox) SetPopupFixedWidth(fixed bool) {
	var _arg0 *C.GtkComboBox // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if fixed {
		_arg1 = C.TRUE
	}

	C.gtk_combo_box_set_popup_fixed_width(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(fixed)
}

// SetRowSeparatorFunc sets the row separator function, which is used to
// determine whether a row should be drawn as a separator.
//
// If the row separator function is NULL, no separators are drawn. This is the
// default value.
//
// The function takes the following parameters:
//
//   - fn (optional): GtkTreeViewRowSeparatorFunc.
func (comboBox *ComboBox) SetRowSeparatorFunc(fn TreeViewRowSeparatorFunc) {
	var _arg0 *C.GtkComboBox                // out
	var _arg1 C.GtkTreeViewRowSeparatorFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewRowSeparatorFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_combo_box_set_row_separator_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(fn)
}

func (comboBox *ComboBox) changed() {
	gclass := (*C.GtkComboBoxClass)(coreglib.PeekParentClass(comboBox))
	fnarg := gclass.changed

	var _arg0 *C.GtkComboBox // out

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	C._gotk4_gtk4_ComboBox_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(comboBox)
}

func (comboBox *ComboBox) formatEntryText(path string) string {
	gclass := (*C.GtkComboBoxClass)(coreglib.PeekParentClass(comboBox))
	fnarg := gclass.format_entry_text

	var _arg0 *C.GtkComboBox // out
	var _arg1 *C.char        // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkComboBox)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C._gotk4_gtk4_ComboBox_virtual_format_entry_text(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(path)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ComboBoxText: GtkComboBoxText is a simple variant of GtkComboBox for
// text-only use cases.
//
// !An example GtkComboBoxText (combo-box-text.png)
//
// GtkComboBoxText hides the model-view complexity of GtkComboBox.
//
// To create a GtkComboBoxText, use gtk.ComboBoxText.New or
// gtk.ComboBoxText.NewWithEntry.
//
// You can add items to a GtkComboBoxText with gtk.ComboBoxText.AppendText(),
// gtk.ComboBoxText.InsertText() or gtk.ComboBoxText.PrependText() and remove
// options with gtk.ComboBoxText.Remove().
//
// If the GtkComboBoxText contains an entry (via the
// gtk.ComboBox:has-entry property), its contents can be retrieved using
// gtk.ComboBoxText.GetActiveText().
//
// You should not call gtk.ComboBox.SetModel() or attempt to pack more cells
// into this combo box via its gtk.CellLayout interface.
//
// # GtkComboBoxText as GtkBuildable
//
// The GtkComboBoxText implementation of the GtkBuildable interface
// supports adding items directly using the <items> element and specifying
// <item> elements for each item. Each <item> element can specify the “id”
// corresponding to the appended text and also supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying GtkComboBoxText items:
//
//	<object class="GtkComboBoxText">
//	  <items>
//	    <item translatable="yes" id="factory">Factory</item>
//	    <item translatable="yes" id="home">Home</item>
//	    <item translatable="yes" id="subway">Subway</item>
//	  </items>
//	</object>
//
// CSS nodes
//
//	combobox
//	╰── box.linked
//	    ├── entry.combo
//	    ├── button.combo
//	    ╰── window.popup
//
// GtkComboBoxText has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
type ComboBoxText struct {
	_ [0]func() // equal guard
	ComboBox
}

var (
	_ Widgetter         = (*ComboBoxText)(nil)
	_ coreglib.Objector = (*ComboBoxText)(nil)
)

func wrapComboBoxText(obj *coreglib.Object) *ComboBoxText {
	return &ComboBoxText{
		ComboBox: ComboBox{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			CellEditable: CellEditable{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
			CellLayout: CellLayout{
				Object: obj,
			},
		},
	}
}

func marshalComboBoxText(p uintptr) (interface{}, error) {
	return wrapComboBoxText(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewComboBoxText creates a new GtkComboBoxText.
//
// The function returns the following values:
//
//   - comboBoxText: new GtkComboBoxText.
func NewComboBoxText() *ComboBoxText {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_text_new()

	var _comboBoxText *ComboBoxText // out

	_comboBoxText = wrapComboBoxText(coreglib.Take(unsafe.Pointer(_cret)))

	return _comboBoxText
}

// NewComboBoxTextWithEntry creates a new GtkComboBoxText with an entry.
//
// The function returns the following values:
//
//   - comboBoxText: new GtkComboBoxText.
func NewComboBoxTextWithEntry() *ComboBoxText {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_combo_box_text_new_with_entry()

	var _comboBoxText *ComboBoxText // out

	_comboBoxText = wrapComboBoxText(coreglib.Take(unsafe.Pointer(_cret)))

	return _comboBoxText
}

// Append appends text to the list of strings stored in combo_box.
//
// If id is non-NULL then it is used as the ID of the row.
//
// This is the same as calling gtk.ComboBoxText.Insert() with a position of -1.
//
// The function takes the following parameters:
//
//   - id (optional): string ID for this value, or NULL.
//   - text: string.
func (comboBox *ComboBoxText) Append(id, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if id != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_append(_arg0, _arg1, _arg2)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(id)
	runtime.KeepAlive(text)
}

// AppendText appends text to the list of strings stored in combo_box.
//
// This is the same as calling gtk.ComboBoxText.InsertText() with a position of
// -1.
//
// The function takes the following parameters:
//
//   - text: string.
func (comboBox *ComboBoxText) AppendText(text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_append_text(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(text)
}

// ActiveText returns the currently active string in combo_box.
//
// If no row is currently selected, NULL is returned. If combo_box contains an
// entry, this function will return its contents (which will not necessarily be
// an item from the list).
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated string containing the currently active
//     text. Must be freed with g_free().
func (comboBox *ComboBoxText) ActiveText() string {
	var _arg0 *C.GtkComboBoxText // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	_cret = C.gtk_combo_box_text_get_active_text(_arg0)
	runtime.KeepAlive(comboBox)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Insert inserts text at position in the list of strings stored in combo_box.
//
// If id is non-NULL then it is used as the ID of the row. See
// gtk.ComboBox:id-column.
//
// If position is negative then text is appended.
//
// The function takes the following parameters:
//
//   - position: index to insert text.
//   - id (optional): string ID for this value, or NULL.
//   - text: string to display.
func (comboBox *ComboBoxText) Insert(position int, id, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.int              // out
	var _arg2 *C.char            // out
	var _arg3 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = C.int(position)
	if id != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg3))

	C.gtk_combo_box_text_insert(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(position)
	runtime.KeepAlive(id)
	runtime.KeepAlive(text)
}

// InsertText inserts text at position in the list of strings stored in
// combo_box.
//
// If position is negative then text is appended.
//
// This is the same as calling gtk.ComboBoxText.Insert() with a NULL ID string.
//
// The function takes the following parameters:
//
//   - position: index to insert text.
//   - text: string.
func (comboBox *ComboBoxText) InsertText(position int, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.int              // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = C.int(position)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_insert_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(position)
	runtime.KeepAlive(text)
}

// Prepend prepends text to the list of strings stored in combo_box.
//
// If id is non-NULL then it is used as the ID of the row.
//
// This is the same as calling gtk.ComboBoxText.Insert() with a position of 0.
//
// The function takes the following parameters:
//
//   - id (optional): string ID for this value, or NULL.
//   - text: string.
func (comboBox *ComboBoxText) Prepend(id, text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out
	var _arg2 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	if id != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_combo_box_text_prepend(_arg0, _arg1, _arg2)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(id)
	runtime.KeepAlive(text)
}

// PrependText prepends text to the list of strings stored in combo_box.
//
// This is the same as calling gtk.ComboBoxText.InsertText() with a position of
// 0.
//
// The function takes the following parameters:
//
//   - text: string.
func (comboBox *ComboBoxText) PrependText(text string) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_combo_box_text_prepend_text(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(text)
}

// Remove removes the string at position from combo_box.
//
// The function takes the following parameters:
//
//   - position: index of the item to remove.
func (comboBox *ComboBoxText) Remove(position int) {
	var _arg0 *C.GtkComboBoxText // out
	var _arg1 C.int              // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))
	_arg1 = C.int(position)

	C.gtk_combo_box_text_remove(_arg0, _arg1)
	runtime.KeepAlive(comboBox)
	runtime.KeepAlive(position)
}

// RemoveAll removes all the text entries from the combo box.
func (comboBox *ComboBoxText) RemoveAll() {
	var _arg0 *C.GtkComboBoxText // out

	_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(coreglib.InternObject(comboBox).Native()))

	C.gtk_combo_box_text_remove_all(_arg0)
	runtime.KeepAlive(comboBox)
}

// ConstantExpression: constant value in a GtkExpression.
type ConstantExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*ConstantExpression)(nil)
)

func wrapConstantExpression(obj *coreglib.Object) *ConstantExpression {
	return &ConstantExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalConstantExpression(p uintptr) (interface{}, error) {
	return wrapConstantExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewConstantExpressionForValue creates an expression that always evaluates to
// the given value.
//
// The function takes the following parameters:
//
//   - value: GValue.
//
// The function returns the following values:
//
//   - constantExpression: new GtkExpression.
func NewConstantExpressionForValue(value *coreglib.Value) *ConstantExpression {
	var _arg1 *C.GValue        // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_constant_expression_new_for_value(_arg1)
	runtime.KeepAlive(value)

	var _constantExpression *ConstantExpression // out

	_constantExpression = wrapConstantExpression(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constantExpression
}

// Value gets the value that a constant expression evaluates to.
//
// The function returns the following values:
//
//   - value: value.
func (expression *ConstantExpression) Value() *coreglib.Value {
	var _arg0 *C.GtkExpression // out
	var _cret *C.GValue        // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))

	_cret = C.gtk_constant_expression_get_value(_arg0)
	runtime.KeepAlive(expression)

	var _value *coreglib.Value // out

	_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))

	return _value
}

// ConstraintOverrides contains methods that are overridable.
type ConstraintOverrides struct {
}

func defaultConstraintOverrides(v *Constraint) ConstraintOverrides {
	return ConstraintOverrides{}
}

// Constraint: GtkConstraint describes a constraint between attributes of two
// widgets, expressed as a linear equation.
//
// The typical equation for a constraint is:
//
//	target.target_attr = source.source_attr × multiplier + constant
//
// Each GtkConstraint is part of a system that will be solved by a
// gtk.ConstraintLayout in order to allocate and position each child widget or
// guide.
//
// The source and target, as well as their attributes, of a GtkConstraint
// instance are immutable after creation.
type Constraint struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Constraint)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Constraint, *ConstraintClass, ConstraintOverrides](
		GTypeConstraint,
		initConstraintClass,
		wrapConstraint,
		defaultConstraintOverrides,
	)
}

func initConstraintClass(gclass unsafe.Pointer, overrides ConstraintOverrides, classInitFunc func(*ConstraintClass)) {
	if classInitFunc != nil {
		class := (*ConstraintClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConstraint(obj *coreglib.Object) *Constraint {
	return &Constraint{
		Object: obj,
	}
}

func marshalConstraint(p uintptr) (interface{}, error) {
	return wrapConstraint(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewConstraint creates a new constraint representing a relation between a
// layout attribute on a source and a layout attribute on a target.
//
// The function takes the following parameters:
//
//   - target (optional) of the constraint.
//   - targetAttribute: attribute of target to be set.
//   - relation equivalence between target_attribute and source_attribute.
//   - source (optional) of the constraint.
//   - sourceAttribute: attribute of source to be read.
//   - multiplier: multiplication factor to be applied to source_attribute.
//   - constant factor to be added to source_attribute.
//   - strength of the constraint.
//
// The function returns the following values:
//
//   - constraint: newly created constraint.
func NewConstraint(target ConstraintTargetter, targetAttribute ConstraintAttribute, relation ConstraintRelation, source ConstraintTargetter, sourceAttribute ConstraintAttribute, multiplier, constant float64, strength int) *Constraint {
	var _arg1 C.gpointer               // out
	var _arg2 C.GtkConstraintAttribute // out
	var _arg3 C.GtkConstraintRelation  // out
	var _arg4 C.gpointer               // out
	var _arg5 C.GtkConstraintAttribute // out
	var _arg6 C.double                 // out
	var _arg7 C.double                 // out
	var _arg8 C.int                    // out
	var _cret *C.GtkConstraint         // in

	if target != nil {
		_arg1 = *(*C.gpointer)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	}
	_arg2 = C.GtkConstraintAttribute(targetAttribute)
	_arg3 = C.GtkConstraintRelation(relation)
	if source != nil {
		_arg4 = *(*C.gpointer)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	}
	_arg5 = C.GtkConstraintAttribute(sourceAttribute)
	_arg6 = C.double(multiplier)
	_arg7 = C.double(constant)
	_arg8 = C.int(strength)

	_cret = C.gtk_constraint_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(target)
	runtime.KeepAlive(targetAttribute)
	runtime.KeepAlive(relation)
	runtime.KeepAlive(source)
	runtime.KeepAlive(sourceAttribute)
	runtime.KeepAlive(multiplier)
	runtime.KeepAlive(constant)
	runtime.KeepAlive(strength)

	var _constraint *Constraint // out

	_constraint = wrapConstraint(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraint
}

// NewConstraintConstant creates a new constraint representing a relation
// between a layout attribute on a target and a constant value.
//
// The function takes the following parameters:
//
//   - target (optional): the target of the constraint.
//   - targetAttribute: attribute of target to be set.
//   - relation equivalence between target_attribute and constant.
//   - constant factor to be set on target_attribute.
//   - strength of the constraint.
//
// The function returns the following values:
//
//   - constraint: newly created constraint.
func NewConstraintConstant(target ConstraintTargetter, targetAttribute ConstraintAttribute, relation ConstraintRelation, constant float64, strength int) *Constraint {
	var _arg1 C.gpointer               // out
	var _arg2 C.GtkConstraintAttribute // out
	var _arg3 C.GtkConstraintRelation  // out
	var _arg4 C.double                 // out
	var _arg5 C.int                    // out
	var _cret *C.GtkConstraint         // in

	if target != nil {
		_arg1 = *(*C.gpointer)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	}
	_arg2 = C.GtkConstraintAttribute(targetAttribute)
	_arg3 = C.GtkConstraintRelation(relation)
	_arg4 = C.double(constant)
	_arg5 = C.int(strength)

	_cret = C.gtk_constraint_new_constant(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(target)
	runtime.KeepAlive(targetAttribute)
	runtime.KeepAlive(relation)
	runtime.KeepAlive(constant)
	runtime.KeepAlive(strength)

	var _constraint *Constraint // out

	_constraint = wrapConstraint(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraint
}

// Constant retrieves the constant factor added to the source attributes' value.
//
// The function returns the following values:
//
//   - gdouble: constant factor.
func (constraint *Constraint) Constant() float64 {
	var _arg0 *C.GtkConstraint // out
	var _cret C.double         // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_constant(_arg0)
	runtime.KeepAlive(constraint)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Multiplier retrieves the multiplication factor applied to the source
// attribute's value.
//
// The function returns the following values:
//
//   - gdouble: multiplication factor.
func (constraint *Constraint) Multiplier() float64 {
	var _arg0 *C.GtkConstraint // out
	var _cret C.double         // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_multiplier(_arg0)
	runtime.KeepAlive(constraint)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Relation: order relation between the terms of the constraint.
//
// The function returns the following values:
//
//   - constraintRelation: relation type.
func (constraint *Constraint) Relation() ConstraintRelation {
	var _arg0 *C.GtkConstraint        // out
	var _cret C.GtkConstraintRelation // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_relation(_arg0)
	runtime.KeepAlive(constraint)

	var _constraintRelation ConstraintRelation // out

	_constraintRelation = ConstraintRelation(_cret)

	return _constraintRelation
}

// Source retrieves the gtk.ConstraintTarget used as the source for the
// constraint.
//
// If the source is set to NULL at creation, the constraint will use the widget
// using the gtk.ConstraintLayout as the source.
//
// The function returns the following values:
//
//   - constraintTarget (optional): source of the constraint.
func (constraint *Constraint) Source() *ConstraintTarget {
	var _arg0 *C.GtkConstraint       // out
	var _cret *C.GtkConstraintTarget // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_source(_arg0)
	runtime.KeepAlive(constraint)

	var _constraintTarget *ConstraintTarget // out

	if _cret != nil {
		_constraintTarget = wrapConstraintTarget(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _constraintTarget
}

// SourceAttribute retrieves the attribute of the source to be read by the
// constraint.
//
// The function returns the following values:
//
//   - constraintAttribute source's attribute.
func (constraint *Constraint) SourceAttribute() ConstraintAttribute {
	var _arg0 *C.GtkConstraint         // out
	var _cret C.GtkConstraintAttribute // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_source_attribute(_arg0)
	runtime.KeepAlive(constraint)

	var _constraintAttribute ConstraintAttribute // out

	_constraintAttribute = ConstraintAttribute(_cret)

	return _constraintAttribute
}

// Strength retrieves the strength of the constraint.
//
// The function returns the following values:
//
//   - gint: strength value.
func (constraint *Constraint) Strength() int {
	var _arg0 *C.GtkConstraint // out
	var _cret C.int            // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_strength(_arg0)
	runtime.KeepAlive(constraint)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Target retrieves the gtk.ConstraintTarget used as the target for the
// constraint.
//
// If the targe is set to NULL at creation, the constraint will use the widget
// using the gtk.ConstraintLayout as the target.
//
// The function returns the following values:
//
//   - constraintTarget (optional): ConstraintTarget.
func (constraint *Constraint) Target() *ConstraintTarget {
	var _arg0 *C.GtkConstraint       // out
	var _cret *C.GtkConstraintTarget // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_target(_arg0)
	runtime.KeepAlive(constraint)

	var _constraintTarget *ConstraintTarget // out

	if _cret != nil {
		_constraintTarget = wrapConstraintTarget(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _constraintTarget
}

// TargetAttribute retrieves the attribute of the target to be set by the
// constraint.
//
// The function returns the following values:
//
//   - constraintAttribute target's attribute.
func (constraint *Constraint) TargetAttribute() ConstraintAttribute {
	var _arg0 *C.GtkConstraint         // out
	var _cret C.GtkConstraintAttribute // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_get_target_attribute(_arg0)
	runtime.KeepAlive(constraint)

	var _constraintAttribute ConstraintAttribute // out

	_constraintAttribute = ConstraintAttribute(_cret)

	return _constraintAttribute
}

// IsAttached checks whether the constraint is attached to a
// gtk.ConstraintLayout, and it is contributing to the layout.
//
// The function returns the following values:
//
//   - ok: TRUE if the constraint is attached.
func (constraint *Constraint) IsAttached() bool {
	var _arg0 *C.GtkConstraint // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_is_attached(_arg0)
	runtime.KeepAlive(constraint)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsConstant checks whether the constraint describes a relation between an
// attribute on the gtk.Constraint:target and a constant value.
//
// The function returns the following values:
//
//   - ok: TRUE if the constraint is a constant relation.
func (constraint *Constraint) IsConstant() bool {
	var _arg0 *C.GtkConstraint // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_is_constant(_arg0)
	runtime.KeepAlive(constraint)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRequired checks whether the constraint is a required relation for solving
// the constraint layout.
//
// The function returns the following values:
//
//   - ok: TRUE if the constraint is required.
func (constraint *Constraint) IsRequired() bool {
	var _arg0 *C.GtkConstraint // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	_cret = C.gtk_constraint_is_required(_arg0)
	runtime.KeepAlive(constraint)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ConstraintGuideOverrides contains methods that are overridable.
type ConstraintGuideOverrides struct {
}

func defaultConstraintGuideOverrides(v *ConstraintGuide) ConstraintGuideOverrides {
	return ConstraintGuideOverrides{}
}

// ConstraintGuide: GtkConstraintGuide is an invisible layout element in a
// GtkConstraintLayout.
//
// The GtkConstraintLayout treats guides like widgets. They can be used as the
// source or target of a GtkConstraint.
//
// Guides have a minimum, maximum and natural size. Depending on the constraints
// that are applied, they can act like a guideline that widgets can be aligned
// to, or like *flexible space*.
//
// Unlike a GtkWidget, a GtkConstraintGuide will not be drawn.
type ConstraintGuide struct {
	_ [0]func() // equal guard
	*coreglib.Object

	ConstraintTarget
}

var (
	_ coreglib.Objector = (*ConstraintGuide)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ConstraintGuide, *ConstraintGuideClass, ConstraintGuideOverrides](
		GTypeConstraintGuide,
		initConstraintGuideClass,
		wrapConstraintGuide,
		defaultConstraintGuideOverrides,
	)
}

func initConstraintGuideClass(gclass unsafe.Pointer, overrides ConstraintGuideOverrides, classInitFunc func(*ConstraintGuideClass)) {
	if classInitFunc != nil {
		class := (*ConstraintGuideClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConstraintGuide(obj *coreglib.Object) *ConstraintGuide {
	return &ConstraintGuide{
		Object: obj,
		ConstraintTarget: ConstraintTarget{
			Object: obj,
		},
	}
}

func marshalConstraintGuide(p uintptr) (interface{}, error) {
	return wrapConstraintGuide(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewConstraintGuide creates a new GtkConstraintGuide object.
//
// The function returns the following values:
//
//   - constraintGuide: new GtkConstraintGuide object.
func NewConstraintGuide() *ConstraintGuide {
	var _cret *C.GtkConstraintGuide // in

	_cret = C.gtk_constraint_guide_new()

	var _constraintGuide *ConstraintGuide // out

	_constraintGuide = wrapConstraintGuide(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraintGuide
}

// MaxSize gets the maximum size of guide.
//
// The function takes the following parameters:
//
//   - width (optional): return location for the maximum width, or NULL.
//   - height (optional): return location for the maximum height, or NULL.
func (guide *ConstraintGuide) MaxSize(width, height *int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.int                // out
	var _arg2 *C.int                // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	if width != nil {
		_arg1 = (*C.int)(unsafe.Pointer(width))
	}
	if height != nil {
		_arg2 = (*C.int)(unsafe.Pointer(height))
	}

	C.gtk_constraint_guide_get_max_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// MinSize gets the minimum size of guide.
//
// The function takes the following parameters:
//
//   - width (optional): return location for the minimum width, or NULL.
//   - height (optional): return location for the minimum height, or NULL.
func (guide *ConstraintGuide) MinSize(width, height *int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.int                // out
	var _arg2 *C.int                // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	if width != nil {
		_arg1 = (*C.int)(unsafe.Pointer(width))
	}
	if height != nil {
		_arg2 = (*C.int)(unsafe.Pointer(height))
	}

	C.gtk_constraint_guide_get_min_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Name retrieves the name set using gtk_constraint_guide_set_name().
//
// The function returns the following values:
//
//   - utf8 (optional): name of the guide.
func (guide *ConstraintGuide) Name() string {
	var _arg0 *C.GtkConstraintGuide // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))

	_cret = C.gtk_constraint_guide_get_name(_arg0)
	runtime.KeepAlive(guide)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NatSize gets the natural size of guide.
//
// The function takes the following parameters:
//
//   - width (optional): return location for the natural width, or NULL.
//   - height (optional): return location for the natural height, or NULL.
func (guide *ConstraintGuide) NatSize(width, height *int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.int                // out
	var _arg2 *C.int                // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	if width != nil {
		_arg1 = (*C.int)(unsafe.Pointer(width))
	}
	if height != nil {
		_arg2 = (*C.int)(unsafe.Pointer(height))
	}

	C.gtk_constraint_guide_get_nat_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Strength retrieves the strength set using
// gtk_constraint_guide_set_strength().
//
// The function returns the following values:
//
//   - constraintStrength: strength of the constraint on the natural size.
func (guide *ConstraintGuide) Strength() ConstraintStrength {
	var _arg0 *C.GtkConstraintGuide   // out
	var _cret C.GtkConstraintStrength // in

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))

	_cret = C.gtk_constraint_guide_get_strength(_arg0)
	runtime.KeepAlive(guide)

	var _constraintStrength ConstraintStrength // out

	_constraintStrength = ConstraintStrength(_cret)

	return _constraintStrength
}

// SetMaxSize sets the maximum size of guide.
//
// If guide is attached to a GtkConstraintLayout, the constraints will be
// updated to reflect the new size.
//
// The function takes the following parameters:
//
//   - width: new maximum width, or -1 to not change it.
//   - height: new maximum height, or -1 to not change it.
func (guide *ConstraintGuide) SetMaxSize(width, height int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_constraint_guide_set_max_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetMinSize sets the minimum size of guide.
//
// If guide is attached to a GtkConstraintLayout, the constraints will be
// updated to reflect the new size.
//
// The function takes the following parameters:
//
//   - width: new minimum width, or -1 to not change it.
//   - height: new minimum height, or -1 to not change it.
func (guide *ConstraintGuide) SetMinSize(width, height int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_constraint_guide_set_min_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetName sets a name for the given GtkConstraintGuide.
//
// The name is useful for debugging purposes.
//
// The function takes the following parameters:
//
//   - name (optional) for the guide.
func (guide *ConstraintGuide) SetName(name string) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 *C.char               // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_constraint_guide_set_name(_arg0, _arg1)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(name)
}

// SetNatSize sets the natural size of guide.
//
// If guide is attached to a GtkConstraintLayout, the constraints will be
// updated to reflect the new size.
//
// The function takes the following parameters:
//
//   - width: new natural width, or -1 to not change it.
//   - height: new natural height, or -1 to not change it.
func (guide *ConstraintGuide) SetNatSize(width, height int) {
	var _arg0 *C.GtkConstraintGuide // out
	var _arg1 C.int                 // out
	var _arg2 C.int                 // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_constraint_guide_set_nat_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetStrength sets the strength of the constraint on the natural size of the
// given GtkConstraintGuide.
//
// The function takes the following parameters:
//
//   - strength of the constraint.
func (guide *ConstraintGuide) SetStrength(strength ConstraintStrength) {
	var _arg0 *C.GtkConstraintGuide   // out
	var _arg1 C.GtkConstraintStrength // out

	_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	_arg1 = C.GtkConstraintStrength(strength)

	C.gtk_constraint_guide_set_strength(_arg0, _arg1)
	runtime.KeepAlive(guide)
	runtime.KeepAlive(strength)
}

// ConstraintLayoutOverrides contains methods that are overridable.
type ConstraintLayoutOverrides struct {
}

func defaultConstraintLayoutOverrides(v *ConstraintLayout) ConstraintLayoutOverrides {
	return ConstraintLayoutOverrides{}
}

// ConstraintLayout: layout manager using constraints to describe relations
// between widgets.
//
// GtkConstraintLayout is a layout manager that uses relations between widget
// attributes, expressed via gtk.Constraint instances, to measure and allocate
// widgets.
//
// # How do constraints work
//
// Constraints are objects defining the relationship between attributes of a
// widget; you can read the description of the gtk.Constraint class to have a
// more in depth definition.
//
// By taking multiple constraints and applying them to the children of a widget
// using GtkConstraintLayout, it's possible to describe complex layout policies;
// each constraint applied to a child or to the parent widgets contributes to
// the full description of the layout, in terms of parameters for resolving the
// value of each attribute.
//
// It is important to note that a layout is defined by the totality of
// constraints; removing a child, or a constraint, from an existing layout
// without changing the remaining constraints may result in an unstable or
// unsolvable layout.
//
// Constraints have an implicit "reading order"; you should start describing
// each edge of each child, as well as their relationship with the parent
// container, from the top left (or top right, in RTL languages), horizontally
// first, and then vertically.
//
// A constraint-based layout with too few constraints can become "unstable",
// that is: have more than one solution. The behavior of an unstable layout is
// undefined.
//
// A constraint-based layout with conflicting constraints may be unsolvable,
// and lead to an unstable layout. You can use the gtk.Constraint:strength
// property of gtk.Constraint to "nudge" the layout towards a solution.
//
// # GtkConstraintLayout as GtkBuildable
//
// GtkConstraintLayout implements the gtk.Buildable interface and has a custom
// "constraints" element which allows describing constraints in a gtk.Builder UI
// file.
//
// An example of a UI definition fragment specifying a constraint:
//
//	<object class="GtkConstraintLayout">
//	  <constraints>
//	    <constraint target="button" target-attribute="start"
//	                relation="eq"
//	                source="super" source-attribute="start"
//	                constant="12"
//	                strength="required" />
//	    <constraint target="button" target-attribute="width"
//	                relation="ge"
//	                constant="250"
//	                strength="strong" />
//	  </constraints>
//	</object>
//
// The definition above will add two constraints to the GtkConstraintLayout:
//
//   - a required constraint between the leading edge of "button" and the
//     leading edge of the widget using the constraint layout, plus 12 pixels
//   - a strong, constant constraint making the width of "button" greater than,
//     or equal to 250 pixels
//
// The "target" and "target-attribute" attributes are required.
//
// The "source" and "source-attribute" attributes of the "constraint" element
// are optional; if they are not specified, the constraint is assumed to be a
// constant.
//
// The "relation" attribute is optional; if not specified, the constraint is
// assumed to be an equality.
//
// The "strength" attribute is optional; if not specified, the constraint is
// assumed to be required.
//
// The "source" and "target" attributes can be set to "super" to indicate that
// the constraint target is the widget using the GtkConstraintLayout.
//
// There can be "constant" and "multiplier" attributes.
//
// Additionally, the "constraints" element can also contain a description of the
// ConstraintGuides used by the layout:
//
//	<constraints>
//	  <guide min-width="100" max-width="500" name="hspace"/>
//	  <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
//	</constraints>
//
// The "guide" element has the following optional attributes:
//
//   - "min-width", "nat-width", and "max-width", describe the minimum, natural,
//     and maximum width of the guide, respectively
//   - "min-height", "nat-height", and "max-height", describe the minimum,
//     natural, and maximum height of the guide, respectively
//   - "strength" describes the strength of the constraint on the natural size
//     of the guide; if not specified, the constraint is assumed to have a
//     medium strength
//   - "name" describes a name for the guide, useful when debugging
//
// # Using the Visual Format Language
//
// Complex constraints can be described using a compact syntax called VFL,
// or *Visual Format Language*.
//
// The Visual Format Language describes all the constraints on a row or column,
// typically starting from the leading edge towards the trailing one.
// Each element of the layout is composed by "views", which identify a
// gtk.ConstraintTarget.
//
// For instance:
//
//	[button]-[textField]
//
// Describes a constraint that binds the trailing edge of "button" to the
// leading edge of "textField", leaving a default space between the two.
//
// Using VFL is also possible to specify predicates that describe constraints on
// attributes like width and height:
//
//	// Width must be greater than, or equal to 50
//	[button(>=50)]
//
//	// Width of button1 must be equal to width of button2
//	[button1(==button2)]
//
// The default orientation for a VFL description is horizontal, unless otherwise
// specified:
//
//	// horizontal orientation, default attribute: width
//	H:[button(>=150)]
//
//	// vertical orientation, default attribute: height
//	V:[button1(==button2)]
//
// It's also possible to specify multiple predicates, as well as their strength:
//
//	// minimum width of button must be 150
//	// natural width of button can be 250
//	[button(>=150required, ==250medium)]
//
// Finally, it's also possible to use simple arithmetic operators:
//
//	// width of button1 must be equal to width of button2
//	// divided by 2 plus 12
//	[button1(button2 / 2 + 12)].
type ConstraintLayout struct {
	_ [0]func() // equal guard
	LayoutManager

	*coreglib.Object
	Buildable
}

var (
	_ LayoutManagerer   = (*ConstraintLayout)(nil)
	_ coreglib.Objector = (*ConstraintLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ConstraintLayout, *ConstraintLayoutClass, ConstraintLayoutOverrides](
		GTypeConstraintLayout,
		initConstraintLayoutClass,
		wrapConstraintLayout,
		defaultConstraintLayoutOverrides,
	)
}

func initConstraintLayoutClass(gclass unsafe.Pointer, overrides ConstraintLayoutOverrides, classInitFunc func(*ConstraintLayoutClass)) {
	if classInitFunc != nil {
		class := (*ConstraintLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConstraintLayout(obj *coreglib.Object) *ConstraintLayout {
	return &ConstraintLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalConstraintLayout(p uintptr) (interface{}, error) {
	return wrapConstraintLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewConstraintLayout creates a new GtkConstraintLayout layout manager.
//
// The function returns the following values:
//
//   - constraintLayout: newly created GtkConstraintLayout.
func NewConstraintLayout() *ConstraintLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_constraint_layout_new()

	var _constraintLayout *ConstraintLayout // out

	_constraintLayout = wrapConstraintLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _constraintLayout
}

// AddConstraint adds a constraint to the layout manager.
//
// The gtk.Constraint:source and gtk.Constraint:target properties of constraint
// can be:
//
//   - set to NULL to indicate that the constraint refers to the widget using
//     layout
//   - set to the gtk.Widget using layout
//   - set to a child of the gtk.Widget using layout
//   - set to a gtk.ConstraintGuide that is part of layout
//
// The layout acquires the ownership of constraint after calling this function.
//
// The function takes the following parameters:
//
//   - constraint: gtk.Constraint.
func (layout *ConstraintLayout) AddConstraint(constraint *Constraint) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraint       // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(constraint).Native()))

	C.gtk_constraint_layout_add_constraint(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(constraint)
}

// AddConstraintsFromDescription creates a list of constraints from a VFL
// description.
//
// The Visual Format Language, VFL, is based on Apple's AutoLayout VFL
// (https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
//
// The views dictionary is used to match gtk.ConstraintTarget instances to the
// symbolic view name inside the VFL.
//
// The VFL grammar is:
//
//	     <visualFormatString> = (<orientation>)?
//	                            (<superview><connection>)?
//	                            <view>(<connection><view>)*
//	                            (<connection><superview>)?
//	            <orientation> = 'H' | 'V'
//	              <superview> = '|'
//	             <connection> = '' | '-' <predicateList> '-' | '-'
//	          <predicateList> = <simplePredicate> | <predicateListWithParens>
//	        <simplePredicate> = <metricName> | <positiveNumber>
//	<predicateListWithParens> = '(' <predicate> (',' <predicate>)* ')'
//	              <predicate> = (<relation>)? <objectOfPredicate> (<operatorList>)? ('@' <priority>)?
//	               <relation> = '==' | '<=' | '>='
//	      <objectOfPredicate> = <constant> | <viewName> | ('.' <attributeName>)?
//	               <priority> = <positiveNumber> | 'required' | 'strong' | 'medium' | 'weak'
//	               <constant> = <number>
//	           <operatorList> = (<multiplyOperator>)? (<addOperator>)?
//	       <multiplyOperator> = [ '*' | '/' ] <positiveNumber>
//	            <addOperator> = [ '+' | '-' ] <positiveNumber>
//	               <viewName> = A-Za-z_ ([A-Za-z0-9_]*) // A C identifier
//	             <metricName> = A-Za-z_ ([A-Za-z0-9_]*) // A C identifier
//	          <attributeName> = 'top' | 'bottom' | 'left' | 'right' | 'width' | 'height' |
//	                            'start' | 'end' | 'centerX' | 'centerY' | 'baseline'
//	         <positiveNumber> // A positive real number parseable by g_ascii_strtod()
//	                 <number> // A real number parseable by g_ascii_strtod()
//
// **Note**: The VFL grammar used by GTK is slightly different than the one
// defined by Apple, as it can use symbolic values for the constraint's strength
// instead of numeric values; additionally, GTK allows adding simple arithmetic
// operations inside predicates.
//
// Examples of VFL descriptions are:
//
//	// Default spacing
//	[button]-[textField]
//
//	// Width constraint
//	[button(>=50)]
//
//	// Connection to super view
//	|-50-[purpleBox]-50-|
//
//	// Vertical layout
//	V:[topField]-10-[bottomField]
//
//	// Flush views
//	[maroonView][blueView]
//
//	// Priority
//	[button(100strong)]
//
//	// Equal widths
//	[button1(==button2)]
//
//	// Multiple predicates
//	[flexibleButton(>=70,<=100)]
//
//	// A complete line of layout
//	|-[find]-[findNext]-[findField(>=20)]-|
//
//	// Operators
//	[button1(button2 / 3 + 50)]
//
//	// Named attributes
//	[button1(==button2.height)].
//
// The function takes the following parameters:
//
//   - lines: array of Visual Format Language lines defining a set of
//     constraints.
//   - hspacing: default horizontal spacing value, or -1 for the fallback value.
//   - vspacing: default vertical spacing value, or -1 for the fallback value.
//   - views: dictionary of [ name, target ] pairs; the name keys map to the
//     view names in the VFL lines, while the target values map to children of
//     the widget using a GtkConstraintLayout, or guides.
//
// The function returns the following values:
//
//   - list of gtk.Constraint instances that were added to the layout.
func (layout *ConstraintLayout) AddConstraintsFromDescription(lines []string, hspacing, vspacing int, views map[string]ConstraintTargetter) ([]*Constraint, error) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 **C.char               // out
	var _arg2 C.gsize
	var _arg3 C.int         // out
	var _arg4 C.int         // out
	var _arg5 *C.GHashTable // out
	var _cret *C.GList      // in
	var _cerr *C.GError     // in

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg2 = (C.gsize)(len(lines))
	_arg1 = (**C.char)(C.calloc(C.size_t(len(lines)), C.size_t(unsafe.Sizeof(uint(0)))))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((**C.char)(_arg1), len(lines))
		for i := range lines {
			out[i] = (*C.char)(unsafe.Pointer(C.CString(lines[i])))
			defer C.free(unsafe.Pointer(out[i]))
		}
	}
	_arg3 = C.int(hspacing)
	_arg4 = C.int(vspacing)
	_arg5 = C.g_hash_table_new_full(nil, nil, (*[0]byte)(C.free), (*[0]byte)(C.free))
	for ksrc, vsrc := range views {
		var kdst *C.gchar               // out
		var vdst *C.GtkConstraintTarget // out
		kdst = (*C.gchar)(unsafe.Pointer(C.CString(ksrc)))
		defer C.free(unsafe.Pointer(kdst))
		vdst = (*C.GtkConstraintTarget)(unsafe.Pointer(coreglib.InternObject(vsrc).Native()))
		C.g_hash_table_insert(_arg5, C.gpointer(unsafe.Pointer(kdst)), C.gpointer(unsafe.Pointer(vdst)))
	}
	defer C.g_hash_table_unref(_arg5)

	_cret = C.gtk_constraint_layout_add_constraints_from_descriptionv(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(lines)
	runtime.KeepAlive(hspacing)
	runtime.KeepAlive(vspacing)
	runtime.KeepAlive(views)

	var _list []*Constraint // out
	var _goerr error        // out

	_list = make([]*Constraint, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkConstraint)(v)
		var dst *Constraint // out
		dst = wrapConstraint(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _list, _goerr
}

// AddGuide adds a guide to layout.
//
// A guide can be used as the source or target of constraints, like a widget,
// but it is not visible.
//
// The layout acquires the ownership of guide after calling this function.
//
// The function takes the following parameters:
//
//   - guide: gtk.ConstraintGuide object.
func (layout *ConstraintLayout) AddGuide(guide *ConstraintGuide) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraintGuide  // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(guide).Native()))

	C.gtk_constraint_layout_add_guide(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(guide)
}

// ObserveConstraints returns a GListModel to track the constraints that are
// part of the layout.
//
// Calling this function will enable extra internal bookkeeping to track
// constraints and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of the
// slowdowns.
//
// The function returns the following values:
//
//   - listModel: a GListModel tracking the layout's constraints.
func (layout *ConstraintLayout) ObserveConstraints() *gio.ListModel {
	var _arg0 *C.GtkConstraintLayout // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.gtk_constraint_layout_observe_constraints(_arg0)
	runtime.KeepAlive(layout)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// ObserveGuides returns a GListModel to track the guides that are part of the
// layout.
//
// Calling this function will enable extra internal bookkeeping to track guides
// and emit signals on the returned listmodel. It may slow down operations a
// lot.
//
// Applications should try hard to avoid calling this function because of the
// slowdowns.
//
// The function returns the following values:
//
//   - listModel: a GListModel tracking the layout's guides.
func (layout *ConstraintLayout) ObserveGuides() *gio.ListModel {
	var _arg0 *C.GtkConstraintLayout // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	_cret = C.gtk_constraint_layout_observe_guides(_arg0)
	runtime.KeepAlive(layout)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// RemoveAllConstraints removes all constraints from the layout manager.
func (layout *ConstraintLayout) RemoveAllConstraints() {
	var _arg0 *C.GtkConstraintLayout // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.gtk_constraint_layout_remove_all_constraints(_arg0)
	runtime.KeepAlive(layout)
}

// RemoveConstraint removes constraint from the layout manager, so that it no
// longer influences the layout.
//
// The function takes the following parameters:
//
//   - constraint: gtk.Constraint.
func (layout *ConstraintLayout) RemoveConstraint(constraint *Constraint) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraint       // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = (*C.GtkConstraint)(unsafe.Pointer(coreglib.InternObject(constraint).Native()))

	C.gtk_constraint_layout_remove_constraint(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(constraint)
}

// RemoveGuide removes guide from the layout manager, so that it no longer
// influences the layout.
//
// The function takes the following parameters:
//
//   - guide: gtk.ConstraintGuide object.
func (layout *ConstraintLayout) RemoveGuide(guide *ConstraintGuide) {
	var _arg0 *C.GtkConstraintLayout // out
	var _arg1 *C.GtkConstraintGuide  // out

	_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg1 = (*C.GtkConstraintGuide)(unsafe.Pointer(coreglib.InternObject(guide).Native()))

	C.gtk_constraint_layout_remove_guide(_arg0, _arg1)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(guide)
}

// ConstraintLayoutChildOverrides contains methods that are overridable.
type ConstraintLayoutChildOverrides struct {
}

func defaultConstraintLayoutChildOverrides(v *ConstraintLayoutChild) ConstraintLayoutChildOverrides {
	return ConstraintLayoutChildOverrides{}
}

// ConstraintLayoutChild: GtkLayoutChild subclass for children in a
// GtkConstraintLayout.
type ConstraintLayoutChild struct {
	_ [0]func() // equal guard
	LayoutChild
}

var (
	_ LayoutChilder = (*ConstraintLayoutChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ConstraintLayoutChild, *ConstraintLayoutChildClass, ConstraintLayoutChildOverrides](
		GTypeConstraintLayoutChild,
		initConstraintLayoutChildClass,
		wrapConstraintLayoutChild,
		defaultConstraintLayoutChildOverrides,
	)
}

func initConstraintLayoutChildClass(gclass unsafe.Pointer, overrides ConstraintLayoutChildOverrides, classInitFunc func(*ConstraintLayoutChildClass)) {
	if classInitFunc != nil {
		class := (*ConstraintLayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapConstraintLayoutChild(obj *coreglib.Object) *ConstraintLayoutChild {
	return &ConstraintLayoutChild{
		LayoutChild: LayoutChild{
			Object: obj,
		},
	}
}

func marshalConstraintLayoutChild(p uintptr) (interface{}, error) {
	return wrapConstraintLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CSSProvider: GtkCssProvider is an object implementing the GtkStyleProvider
// interface for CSS.
//
// It is able to parse CSS-like input in order to style widgets.
//
// An application can make GTK parse a specific CSS style sheet by calling
// gtk.CSSProvider.LoadFromFile() or gtk.CSSProvider.LoadFromResource()
// and adding the provider with gtk.StyleContext.AddProvider() or
// gtk.StyleContext().AddProviderForDisplay.
//
// In addition, certain files will be read when GTK is initialized.
// First, the file $XDG_CONFIG_HOME/gtk-4.0/gtk.css is loaded
// if it exists. Then, GTK loads the first existing file among
// XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css,
// $HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css,
// $XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css and
// DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css, where THEME
// is the name of the current theme (see the gtk.Settings:gtk-theme-name
// setting), VARIANT is the variant to load (see the
// gtk.Settings:gtk-application-prefer-dark-theme setting), DATADIR is
// the prefix configured when GTK was compiled (unless overridden by the
// GTK_DATA_PREFIX environment variable), and VERSION is the GTK version number.
// If no file is found for the current version, GTK tries older versions all the
// way back to 4.0.
//
// To track errors while loading CSS, connect to the
// gtk.CSSProvider::parsing-error signal.
type CSSProvider struct {
	_ [0]func() // equal guard
	*coreglib.Object

	StyleProvider
}

var (
	_ coreglib.Objector = (*CSSProvider)(nil)
)

func wrapCSSProvider(obj *coreglib.Object) *CSSProvider {
	return &CSSProvider{
		Object: obj,
		StyleProvider: StyleProvider{
			Object: obj,
		},
	}
}

func marshalCSSProvider(p uintptr) (interface{}, error) {
	return wrapCSSProvider(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectParsingError signals that a parsing error occurred.
//
// The path, line and position describe the actual location of the error as
// accurately as possible.
//
// Parsing errors are never fatal, so the parsing will resume after the error.
// Errors may however cause parts of the given data or even all of it to not be
// parsed at all. So it is a useful idea to check that the parsing succeeds by
// connecting to this signal.
//
// Note that this signal may be emitted at any time as the css provider may
// opt to defer parsing parts or all of the input to a later time than when a
// loading function was called.
func (cssProvider *CSSProvider) ConnectParsingError(f func(section *CSSSection, err error)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(cssProvider, "parsing-error", false, unsafe.Pointer(C._gotk4_gtk4_CssProvider_ConnectParsingError), f)
}

// NewCSSProvider returns a newly created GtkCssProvider.
//
// The function returns the following values:
//
//   - cssProvider: new GtkCssProvider.
func NewCSSProvider() *CSSProvider {
	var _cret *C.GtkCssProvider // in

	_cret = C.gtk_css_provider_new()

	var _cssProvider *CSSProvider // out

	_cssProvider = wrapCSSProvider(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _cssProvider
}

// LoadFromData loads data into css_provider.
//
// This clears any previously loaded information.
//
// The function takes the following parameters:
//
//   - data: CSS data loaded in memory.
func (cssProvider *CSSProvider) LoadFromData(data string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char           // out
	var _arg2 C.gssize

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(coreglib.InternObject(cssProvider).Native()))
	_arg2 = (C.gssize)(len(data))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(data) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(data)), data)
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_css_provider_load_from_data(_arg0, _arg1, _arg2)
	runtime.KeepAlive(cssProvider)
	runtime.KeepAlive(data)
}

// LoadFromFile loads the data contained in file into css_provider.
//
// This clears any previously loaded information.
//
// The function takes the following parameters:
//
//   - file: GFile pointing to a file to load.
func (cssProvider *CSSProvider) LoadFromFile(file gio.Filer) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.GFile          // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(coreglib.InternObject(cssProvider).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	C.gtk_css_provider_load_from_file(_arg0, _arg1)
	runtime.KeepAlive(cssProvider)
	runtime.KeepAlive(file)
}

// LoadFromPath loads the data contained in path into css_provider.
//
// This clears any previously loaded information.
//
// The function takes the following parameters:
//
//   - path of a filename to load, in the GLib filename encoding.
func (cssProvider *CSSProvider) LoadFromPath(path string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(coreglib.InternObject(cssProvider).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_css_provider_load_from_path(_arg0, _arg1)
	runtime.KeepAlive(cssProvider)
	runtime.KeepAlive(path)
}

// LoadFromResource loads the data contained in the resource at resource_path
// into the css_provider.
//
// This clears any previously loaded information.
//
// The function takes the following parameters:
//
//   - resourcePath: GResource resource path.
func (cssProvider *CSSProvider) LoadFromResource(resourcePath string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(coreglib.InternObject(cssProvider).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_css_provider_load_from_resource(_arg0, _arg1)
	runtime.KeepAlive(cssProvider)
	runtime.KeepAlive(resourcePath)
}

// LoadNamed loads a theme from the usual theme paths.
//
// The actual process of finding the theme might change between releases,
// but it is guaranteed that this function uses the same mechanism to load the
// theme that GTK uses for loading its own theme.
//
// The function takes the following parameters:
//
//   - name: theme name.
//   - variant (optional) to load, for example, "dark", or NULL for the default.
func (provider *CSSProvider) LoadNamed(name, variant string) {
	var _arg0 *C.GtkCssProvider // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if variant != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(variant)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_css_provider_load_named(_arg0, _arg1, _arg2)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(name)
	runtime.KeepAlive(variant)
}

// String converts the provider into a string representation in CSS format.
//
// Using gtk.CSSProvider.LoadFromData() with the return value from this function
// on a new provider created with gtk.CSSProvider.New will basically create a
// duplicate of this provider.
//
// The function returns the following values:
//
//   - utf8: new string representing the provider.
func (provider *CSSProvider) String() string {
	var _arg0 *C.GtkCssProvider // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	_cret = C.gtk_css_provider_to_string(_arg0)
	runtime.KeepAlive(provider)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CustomFilterOverrides contains methods that are overridable.
type CustomFilterOverrides struct {
}

func defaultCustomFilterOverrides(v *CustomFilter) CustomFilterOverrides {
	return CustomFilterOverrides{}
}

// CustomFilter: GtkCustomFilter determines whether to include items with a
// callback.
type CustomFilter struct {
	_ [0]func() // equal guard
	Filter
}

var (
	_ coreglib.Objector = (*CustomFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CustomFilter, *CustomFilterClass, CustomFilterOverrides](
		GTypeCustomFilter,
		initCustomFilterClass,
		wrapCustomFilter,
		defaultCustomFilterOverrides,
	)
}

func initCustomFilterClass(gclass unsafe.Pointer, overrides CustomFilterOverrides, classInitFunc func(*CustomFilterClass)) {
	if classInitFunc != nil {
		class := (*CustomFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCustomFilter(obj *coreglib.Object) *CustomFilter {
	return &CustomFilter{
		Filter: Filter{
			Object: obj,
		},
	}
}

func marshalCustomFilter(p uintptr) (interface{}, error) {
	return wrapCustomFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCustomFilter creates a new filter using the given match_func to filter
// items.
//
// If match_func is NULL, the filter matches all items.
//
// If the filter func changes its filtering behavior, gtk_filter_changed() needs
// to be called.
//
// The function takes the following parameters:
//
//   - matchFunc (optional): function to filter items.
//
// The function returns the following values:
//
//   - customFilter: new GtkCustomFilter.
func NewCustomFilter(matchFunc CustomFilterFunc) *CustomFilter {
	var _arg1 C.GtkCustomFilterFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret *C.GtkCustomFilter // in

	if matchFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_CustomFilterFunc)
		_arg2 = C.gpointer(gbox.Assign(matchFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.gtk_custom_filter_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(matchFunc)

	var _customFilter *CustomFilter // out

	_customFilter = wrapCustomFilter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _customFilter
}

// SetFilterFunc sets the function used for filtering items.
//
// If match_func is NULL, the filter matches all items.
//
// If the filter func changes its filtering behavior, gtk_filter_changed() needs
// to be called.
//
// If a previous function was set, its user_destroy will be called now.
//
// The function takes the following parameters:
//
//   - matchFunc (optional): function to filter items.
func (self *CustomFilter) SetFilterFunc(matchFunc CustomFilterFunc) {
	var _arg0 *C.GtkCustomFilter    // out
	var _arg1 C.GtkCustomFilterFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkCustomFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if matchFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_CustomFilterFunc)
		_arg2 = C.gpointer(gbox.Assign(matchFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_custom_filter_set_filter_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(matchFunc)
}

// CustomLayoutOverrides contains methods that are overridable.
type CustomLayoutOverrides struct {
}

func defaultCustomLayoutOverrides(v *CustomLayout) CustomLayoutOverrides {
	return CustomLayoutOverrides{}
}

// CustomLayout: GtkCustomLayout uses closures for size negotiation.
//
// A GtkCustomLayout uses closures matching to the old GtkWidget virtual
// functions for size negotiation, as a convenience API to ease the porting
// towards the corresponding `GtkLayoutManager virtual functions.
type CustomLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*CustomLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CustomLayout, *CustomLayoutClass, CustomLayoutOverrides](
		GTypeCustomLayout,
		initCustomLayoutClass,
		wrapCustomLayout,
		defaultCustomLayoutOverrides,
	)
}

func initCustomLayoutClass(gclass unsafe.Pointer, overrides CustomLayoutOverrides, classInitFunc func(*CustomLayoutClass)) {
	if classInitFunc != nil {
		class := (*CustomLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCustomLayout(obj *coreglib.Object) *CustomLayout {
	return &CustomLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalCustomLayout(p uintptr) (interface{}, error) {
	return wrapCustomLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CustomSorterOverrides contains methods that are overridable.
type CustomSorterOverrides struct {
}

func defaultCustomSorterOverrides(v *CustomSorter) CustomSorterOverrides {
	return CustomSorterOverrides{}
}

// CustomSorter: GtkCustomSorter is a GtkSorter implementation that sorts via a
// callback function.
type CustomSorter struct {
	_ [0]func() // equal guard
	Sorter
}

var (
	_ coreglib.Objector = (*CustomSorter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*CustomSorter, *CustomSorterClass, CustomSorterOverrides](
		GTypeCustomSorter,
		initCustomSorterClass,
		wrapCustomSorter,
		defaultCustomSorterOverrides,
	)
}

func initCustomSorterClass(gclass unsafe.Pointer, overrides CustomSorterOverrides, classInitFunc func(*CustomSorterClass)) {
	if classInitFunc != nil {
		class := (*CustomSorterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapCustomSorter(obj *coreglib.Object) *CustomSorter {
	return &CustomSorter{
		Sorter: Sorter{
			Object: obj,
		},
	}
}

func marshalCustomSorter(p uintptr) (interface{}, error) {
	return wrapCustomSorter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewCustomSorter creates a new GtkSorter that works by calling sort_func to
// compare items.
//
// If sort_func is NULL, all items are considered equal.
//
// The function takes the following parameters:
//
//   - sortFunc (optional): GCompareDataFunc to use for sorting.
//
// The function returns the following values:
//
//   - customSorter: new GtkCustomSorter.
func NewCustomSorter(sortFunc glib.CompareDataFunc) *CustomSorter {
	var _arg1 C.GCompareDataFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret *C.GtkCustomSorter // in

	if sortFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
		_arg2 = C.gpointer(gbox.Assign(sortFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.gtk_custom_sorter_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(sortFunc)

	var _customSorter *CustomSorter // out

	_customSorter = wrapCustomSorter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _customSorter
}

// SetSortFunc sets (or unsets) the function used for sorting items.
//
// If sort_func is NULL, all items are considered equal.
//
// If the sort func changes its sorting behavior, gtk_sorter_changed() needs to
// be called.
//
// If a previous function was set, its user_destroy will be called now.
//
// The function takes the following parameters:
//
//   - sortFunc (optional): function to sort items.
func (self *CustomSorter) SetSortFunc(sortFunc glib.CompareDataFunc) {
	var _arg0 *C.GtkCustomSorter // out
	var _arg1 C.GCompareDataFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkCustomSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if sortFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_glib2_CompareDataFunc)
		_arg2 = C.gpointer(gbox.Assign(sortFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_custom_sorter_set_sort_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sortFunc)
}

// DialogOverrides contains methods that are overridable.
type DialogOverrides struct {
	Close func()
	// Response emits the ::response signal with the given response ID.
	//
	// Used to indicate that the user has responded to the dialog in some way.
	//
	// The function takes the following parameters:
	//
	//   - responseId: response ID.
	Response func(responseId int)
}

func defaultDialogOverrides(v *Dialog) DialogOverrides {
	return DialogOverrides{
		Close:    v.close,
		Response: v.response,
	}
}

// Dialog dialogs are a convenient way to prompt the user for a small amount of
// input.
//
// !An example GtkDialog (dialog.png)
//
// Typical uses are to display a message, ask a question, or anything else that
// does not require extensive effort on the user’s part.
//
// The main area of a GtkDialog is called the "content area", and is yours
// to populate with widgets such a GtkLabel or GtkEntry, to present your
// information, questions, or tasks to the user.
//
// In addition, dialogs allow you to add "action widgets". Most commonly,
// action widgets are buttons. Depending on the platform, action
// widgets may be presented in the header bar at the top of the window,
// or at the bottom of the window. To add action widgets, create your
// GtkDialog using gtk.Dialog.NewWithButtons, or use gtk.Dialog.AddButton(),
// gtk.Dialog.AddButtons(), or gtk.Dialog.AddActionWidget().
//
// GtkDialogs uses some heuristics to decide whether to add a close button to
// the window decorations. If any of the action buttons use the response ID
// GTK_RESPONSE_CLOSE or GTK_RESPONSE_CANCEL, the close button is omitted.
//
// Clicking a button that was added as an action widget will emit the
// gtk.Dialog::response signal with a response ID that you specified.
// GTK will never assign a meaning to positive response IDs; these are
// entirely user-defined. But for convenience, you can use the response IDs in
// the gtk.ResponseType enumeration (these all have values less than zero).
// If a dialog receives a delete event, the gtk.Dialog::response signal will be
// emitted with the GTK_RESPONSE_DELETE_EVENT response ID.
//
// Dialogs are created with a call to gtk.Dialog.New or
// gtk.Dialog.NewWithButtons. The latter is recommended; it allows you to set
// the dialog title, some convenient flags, and add buttons.
//
// A “modal” dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling gtk.Window.SetModal() on the dialog.
// When using gtk.Dialog.NewWithButtons, you can also pass the GTK_DIALOG_MODAL
// flag to make a dialog modal.
//
// For the simple dialog in the following example, a gtk.MessageDialog would
// save some effort. But you’d need to create the dialog contents manually if
// you had more than a simple message in the dialog.
//
// An example for simple GtkDialog usage:
//
//	// Function to open a dialog box with a message
//	void
//	quick_message (GtkWindow *parent, char *message)
//	{
//	 GtkWidget *dialog, *label, *content_area;
//	 GtkDialogFlags flags;
//
//	 // Create the widgets
//	 flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//	 dialog = gtk_dialog_new_with_buttons ("Message",
//	                                       parent,
//	                                       flags,
//	                                       _("_OK"),
//	                                       GTK_RESPONSE_NONE,
//	                                       NULL);
//	 content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//	 label = gtk_label_new (message);
//
//	 // Ensure that the dialog box is destroyed when the user responds
//
//	 g_signal_connect_swapped (dialog,
//	                           "response",
//	                           G_CALLBACK (gtk_window_destroy),
//	                           dialog);
//
//	 // Add the label, and show everything we’ve added
//
//	 gtk_box_append (GTK_BOX (content_area), label);
//	 gtk_widget_show (dialog);
//	}
//
// # GtkDialog as GtkBuildable
//
// The GtkDialog implementation of the GtkBuildable interface exposes the
// content_area as an internal child with the name “content_area”.
//
// GtkDialog supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs action_area). To mark a response as default,
// set the “default“ attribute of the <action-widget> element to true.
//
// GtkDialog supports adding action widgets by specifying “action“ as the “type“
// attribute of a <child> element. The widget will be added either to the action
// area or the headerbar of the dialog, depending on the “use-header-bar“
// property. The response id has to be associated with the action widget using
// the <action-widgets> element.
//
// An example of a Dialog UI definition fragment:
//
//	<object class="GtkDialog" id="dialog1">
//	  <child type="action">
//	    <object class="GtkButton" id="button_cancel"/>
//	  </child>
//	  <child type="action">
//	    <object class="GtkButton" id="button_ok">
//	    </object>
//	  </child>
//	  <action-widgets>
//	    <action-widget response="cancel">button_cancel</action-widget>
//	    <action-widget response="ok" default="true">button_ok</action-widget>
//	  </action-widgets>
//	</object>
//
// # Accessibility
//
// GtkDialog uses the GTK_ACCESSIBLE_ROLE_DIALOG role.
type Dialog struct {
	_ [0]func() // equal guard
	Window
}

var (
	_ Widgetter         = (*Dialog)(nil)
	_ coreglib.Objector = (*Dialog)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Dialog, *DialogClass, DialogOverrides](
		GTypeDialog,
		initDialogClass,
		wrapDialog,
		defaultDialogOverrides,
	)
}

func initDialogClass(gclass unsafe.Pointer, overrides DialogOverrides, classInitFunc func(*DialogClass)) {
	pclass := (*C.GtkDialogClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDialog))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gtk4_DialogClass_close)
	}

	if overrides.Response != nil {
		pclass.response = (*[0]byte)(C._gotk4_gtk4_DialogClass_response)
	}

	if classInitFunc != nil {
		class := (*DialogClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDialog(obj *coreglib.Object) *Dialog {
	return &Dialog{
		Window: Window{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Root: Root{
				NativeSurface: NativeSurface{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						Accessible: Accessible{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
						ConstraintTarget: ConstraintTarget{
							Object: obj,
						},
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
	}
}

func marshalDialog(p uintptr) (interface{}, error) {
	return wrapDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClose is emitted when the user uses a keybinding to close the dialog.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is the Escape key.
func (dialog *Dialog) ConnectClose(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(dialog, "close", false, unsafe.Pointer(C._gotk4_gtk4_Dialog_ConnectClose), f)
}

// ConnectResponse is emitted when an action widget is clicked.
//
// The signal is also emitted when the dialog receives a delete event, and
// when gtk.Dialog.Response() is called. On a delete event, the response ID is
// GTK_RESPONSE_DELETE_EVENT. Otherwise, it depends on which action widget was
// clicked.
func (dialog *Dialog) ConnectResponse(f func(responseId int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(dialog, "response", false, unsafe.Pointer(C._gotk4_gtk4_Dialog_ConnectResponse), f)
}

// NewDialog creates a new dialog box.
//
// Widgets should not be packed into the GtkWindow directly, but into the
// content_area and action_area, as described above.
//
// The function returns the following values:
//
//   - dialog: new dialog as a GtkWidget.
func NewDialog() *Dialog {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_dialog_new()

	var _dialog *Dialog // out

	_dialog = wrapDialog(coreglib.Take(unsafe.Pointer(_cret)))

	return _dialog
}

// AddActionWidget adds an activatable widget to the action area of a GtkDialog.
//
// GTK connects a signal handler that will emit the gtk.Dialog::response signal
// on the dialog when the widget is activated. The widget is appended to the end
// of the dialog’s action area.
//
// If you want to add a non-activatable widget, simply pack it into the
// action_area field of the GtkDialog struct.
//
// The function takes the following parameters:
//
//   - child: activatable widget.
//   - responseId: response ID for child.
func (dialog *Dialog) AddActionWidget(child Widgetter, responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(responseId)

	C.gtk_dialog_add_action_widget(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(child)
	runtime.KeepAlive(responseId)
}

// AddButton adds a button with the given text.
//
// GTK arranges things so that clicking the button will emit the
// gtk.Dialog::response signal with the given response_id. The button is
// appended to the end of the dialog’s action area. The button widget is
// returned, but usually you don’t need it.
//
// The function takes the following parameters:
//
//   - buttonText: text of button.
//   - responseId: response ID for the button.
//
// The function returns the following values:
//
//   - widget: GtkButton widget that was added.
func (dialog *Dialog) AddButton(buttonText string, responseId int) Widgetter {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.char      // out
	var _arg2 C.int        // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(buttonText)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(responseId)

	_cret = C.gtk_dialog_add_button(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(buttonText)
	runtime.KeepAlive(responseId)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// ContentArea returns the content area of dialog.
//
// The function returns the following values:
//
//   - box: content area Box.
func (dialog *Dialog) ContentArea() *Box {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))

	_cret = C.gtk_dialog_get_content_area(_arg0)
	runtime.KeepAlive(dialog)

	var _box *Box // out

	_box = wrapBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _box
}

// HeaderBar returns the header bar of dialog.
//
// Note that the headerbar is only used by the dialog if the
// gtk.Dialog:use-header-bar property is TRUE.
//
// The function returns the following values:
//
//   - headerBar: header bar.
func (dialog *Dialog) HeaderBar() *HeaderBar {
	var _arg0 *C.GtkDialog // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))

	_cret = C.gtk_dialog_get_header_bar(_arg0)
	runtime.KeepAlive(dialog)

	var _headerBar *HeaderBar // out

	_headerBar = wrapHeaderBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _headerBar
}

// ResponseForWidget gets the response id of a widget in the action area of a
// dialog.
//
// The function takes the following parameters:
//
//   - widget in the action area of dialog.
//
// The function returns the following values:
//
//   - gint: response id of widget, or GTK_RESPONSE_NONE if widget doesn’t have
//     a response id set.
func (dialog *Dialog) ResponseForWidget(widget Widgetter) int {
	var _arg0 *C.GtkDialog // out
	var _arg1 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_dialog_get_response_for_widget(_arg0, _arg1)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// WidgetForResponse gets the widget button that uses the given response ID in
// the action area of a dialog.
//
// The function takes the following parameters:
//
//   - responseId: response ID used by the dialog widget.
//
// The function returns the following values:
//
//   - widget (optional) button that uses the given response_id, or NULL.
func (dialog *Dialog) WidgetForResponse(responseId int) Widgetter {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = C.int(responseId)

	_cret = C.gtk_dialog_get_widget_for_response(_arg0, _arg1)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(responseId)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Response emits the ::response signal with the given response ID.
//
// Used to indicate that the user has responded to the dialog in some way.
//
// The function takes the following parameters:
//
//   - responseId: response ID.
func (dialog *Dialog) Response(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = C.int(responseId)

	C.gtk_dialog_response(_arg0, _arg1)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(responseId)
}

// SetDefaultResponse sets the default widget for the dialog based on the
// response ID.
//
// Pressing “Enter” normally activates the default widget.
//
// The function takes the following parameters:
//
//   - responseId: response ID.
func (dialog *Dialog) SetDefaultResponse(responseId int) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = C.int(responseId)

	C.gtk_dialog_set_default_response(_arg0, _arg1)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(responseId)
}

// SetResponseSensitive: convenient way to sensitize/desensitize dialog buttons.
//
// Calls gtk_widget_set_sensitive (widget, setting) for each widget in the
// dialog’s action area with the given response_id.
//
// The function takes the following parameters:
//
//   - responseId: response ID.
//   - setting: TRUE for sensitive.
func (dialog *Dialog) SetResponseSensitive(responseId int, setting bool) {
	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = C.int(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_dialog_set_response_sensitive(_arg0, _arg1, _arg2)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(responseId)
	runtime.KeepAlive(setting)
}

func (dialog *Dialog) close() {
	gclass := (*C.GtkDialogClass)(coreglib.PeekParentClass(dialog))
	fnarg := gclass.close

	var _arg0 *C.GtkDialog // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))

	C._gotk4_gtk4_Dialog_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(dialog)
}

// Response emits the ::response signal with the given response ID.
//
// Used to indicate that the user has responded to the dialog in some way.
//
// The function takes the following parameters:
//
//   - responseId: response ID.
func (dialog *Dialog) response(responseId int) {
	gclass := (*C.GtkDialogClass)(coreglib.PeekParentClass(dialog))
	fnarg := gclass.response

	var _arg0 *C.GtkDialog // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkDialog)(unsafe.Pointer(coreglib.InternObject(dialog).Native()))
	_arg1 = C.int(responseId)

	C._gotk4_gtk4_Dialog_virtual_response(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(dialog)
	runtime.KeepAlive(responseId)
}

// DirectoryListOverrides contains methods that are overridable.
type DirectoryListOverrides struct {
}

func defaultDirectoryListOverrides(v *DirectoryList) DirectoryListOverrides {
	return DirectoryListOverrides{}
}

// DirectoryList: GtkDirectoryList is a list model that wraps
// g_file_enumerate_children_async().
//
// It presents a GListModel and fills it asynchronously with the GFileInfos
// returned from that function.
//
// Enumeration will start automatically when a the gtk.DirectoryList:file
// property is set.
//
// While the GtkDirectoryList is being filled, the gtk.DirectoryList:loading
// property will be set to TRUE. You can listen to that property if you want to
// show information like a GtkSpinner or a "Loading..." text.
//
// If loading fails at any point, the gtk.DirectoryList:error property will be
// set to give more indication about the failure.
//
// The GFileInfos returned from a GtkDirectoryList have the "standard::file"
// attribute set to the GFile they refer to. This way you can get
// at the file that is referred to in the same way you would via
// g_file_enumerator_get_child(). This means you do not need access to the
// GtkDirectoryList, but can access the GFile directly from the GFileInfo when
// operating with a GtkListView or similar.
type DirectoryList struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*DirectoryList)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DirectoryList, *DirectoryListClass, DirectoryListOverrides](
		GTypeDirectoryList,
		initDirectoryListClass,
		wrapDirectoryList,
		defaultDirectoryListOverrides,
	)
}

func initDirectoryListClass(gclass unsafe.Pointer, overrides DirectoryListOverrides, classInitFunc func(*DirectoryListClass)) {
	if classInitFunc != nil {
		class := (*DirectoryListClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDirectoryList(obj *coreglib.Object) *DirectoryList {
	return &DirectoryList{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalDirectoryList(p uintptr) (interface{}, error) {
	return wrapDirectoryList(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDirectoryList creates a new GtkDirectoryList.
//
// The GtkDirectoryList is querying the given file with the given attributes.
//
// The function takes the following parameters:
//
//   - attributes (optional) to query with.
//   - file (optional) to query.
//
// The function returns the following values:
//
//   - directoryList: new GtkDirectoryList.
func NewDirectoryList(attributes string, file gio.Filer) *DirectoryList {
	var _arg1 *C.char             // out
	var _arg2 *C.GFile            // out
	var _cret *C.GtkDirectoryList // in

	if attributes != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if file != nil {
		_arg2 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}

	_cret = C.gtk_directory_list_new(_arg1, _arg2)
	runtime.KeepAlive(attributes)
	runtime.KeepAlive(file)

	var _directoryList *DirectoryList // out

	_directoryList = wrapDirectoryList(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _directoryList
}

// Attributes gets the attributes queried on the children.
//
// The function returns the following values:
//
//   - utf8 (optional): queried attributes.
func (self *DirectoryList) Attributes() string {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_directory_list_get_attributes(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Error gets the loading error, if any.
//
// If an error occurs during the loading process, the loading process will
// finish and this property allows querying the error that happened. This error
// will persist until a file is loaded again.
//
// An error being set does not mean that no files were loaded, and all
// successfully queried files will remain in the list.
//
// The function returns the following values:
//
//   - err (optional): loading error or NULL if loading finished successfully.
func (self *DirectoryList) Error() error {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.GError           // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_directory_list_get_error(_arg0)
	runtime.KeepAlive(self)

	var _err error // out

	if _cret != nil {
		_err = gerror.Take(unsafe.Pointer(_cret))
	}

	return _err
}

// File gets the file whose children are currently enumerated.
//
// The function returns the following values:
//
//   - file (optional) whose children are enumerated.
func (self *DirectoryList) File() *gio.File {
	var _arg0 *C.GtkDirectoryList // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_directory_list_get_file(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_file = &gio.File{
				Object: obj,
			}
		}
	}

	return _file
}

// IOPriority gets the IO priority set via gtk_directory_list_set_io_priority().
//
// The function returns the following values:
//
//   - gint: IO priority.
func (self *DirectoryList) IOPriority() int {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.int               // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_directory_list_get_io_priority(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Monitored returns whether the directory list is monitoring the directory for
// changes.
//
// The function returns the following values:
//
//   - ok: TRUE if the directory is monitored.
func (self *DirectoryList) Monitored() bool {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_directory_list_get_monitored(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLoading returns TRUE if the children enumeration is currently in progress.
//
// Files will be added to self from time to time while loading is going on.
// The order in which are added is undefined and may change in between runs.
//
// The function returns the following values:
//
//   - ok: TRUE if self is loading.
func (self *DirectoryList) IsLoading() bool {
	var _arg0 *C.GtkDirectoryList // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_directory_list_is_loading(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAttributes sets the attributes to be enumerated and starts the
// enumeration.
//
// If attributes is NULL, no attributes will be queried, but a list of
// GFileInfos will still be created.
//
// The function takes the following parameters:
//
//   - attributes (optional) to enumerate.
func (self *DirectoryList) SetAttributes(attributes string) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if attributes != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(attributes)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_directory_list_set_attributes(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(attributes)
}

// SetFile sets the file to be enumerated and starts the enumeration.
//
// If file is NULL, the result will be an empty list.
//
// The function takes the following parameters:
//
//   - file (optional) to be enumerated.
func (self *DirectoryList) SetFile(file gio.Filer) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 *C.GFile            // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if file != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}

	C.gtk_directory_list_set_file(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(file)
}

// SetIOPriority sets the IO priority to use while loading directories.
//
// Setting the priority while self is loading will reprioritize the ongoing load
// as soon as possible.
//
// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the
// GTK redraw priority. If you are loading a lot of directories in parallel,
// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
// responsiveness.
//
// The function takes the following parameters:
//
//   - ioPriority: IO priority to use.
func (self *DirectoryList) SetIOPriority(ioPriority int) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(ioPriority)

	C.gtk_directory_list_set_io_priority(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ioPriority)
}

// SetMonitored sets whether the directory list will monitor the directory for
// changes. If monitoring is enabled, the ::items-changed signal will be emitted
// when the directory contents change.
//
// When monitoring is turned on after the initial creation of the directory
// list, the directory is reloaded to avoid missing files that appeared between
// the initial loading and when monitoring was turned on.
//
// The function takes the following parameters:
//
//   - monitored: TRUE to monitor the directory for changes.
func (self *DirectoryList) SetMonitored(monitored bool) {
	var _arg0 *C.GtkDirectoryList // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if monitored {
		_arg1 = C.TRUE
	}

	C.gtk_directory_list_set_monitored(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(monitored)
}

// DragIconOverrides contains methods that are overridable.
type DragIconOverrides struct {
}

func defaultDragIconOverrides(v *DragIcon) DragIconOverrides {
	return DragIconOverrides{}
}

// DragIcon: GtkDragIcon is a GtkRoot implementation for drag icons.
//
// A drag icon moves with the pointer during a Drag-and-Drop operation and is
// destroyed when the drag ends.
//
// To set up a drag icon and associate it with an ongoing drag operation,
// use gtk.DragIcon().GetForDrag to get the icon for a drag. You can then use it
// like any other widget and use gtk.DragIcon.SetChild() to set whatever widget
// should be used for the drag icon.
//
// Keep in mind that drag icons do not allow user input.
type DragIcon struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Root
}

var (
	_ Widgetter         = (*DragIcon)(nil)
	_ coreglib.Objector = (*DragIcon)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DragIcon, *DragIconClass, DragIconOverrides](
		GTypeDragIcon,
		initDragIconClass,
		wrapDragIcon,
		defaultDragIconOverrides,
	)
}

func initDragIconClass(gclass unsafe.Pointer, overrides DragIconOverrides, classInitFunc func(*DragIconClass)) {
	if classInitFunc != nil {
		class := (*DragIconClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDragIcon(obj *coreglib.Object) *DragIcon {
	return &DragIcon{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Root: Root{
			NativeSurface: NativeSurface{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalDragIcon(p uintptr) (interface{}, error) {
	return wrapDragIcon(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Child gets the widget currently used as drag icon.
//
// The function returns the following values:
//
//   - widget (optional): drag icon or NULL if none.
func (self *DragIcon) Child() Widgetter {
	var _arg0 *C.GtkDragIcon // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkDragIcon)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drag_icon_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SetChild sets the widget to display as the drag icon.
//
// The function takes the following parameters:
//
//   - child (optional): GtkWidget or NULL.
func (self *DragIcon) SetChild(child Widgetter) {
	var _arg0 *C.GtkDragIcon // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkDragIcon)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_drag_icon_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// DragIconCreateWidgetForValue creates a widget that can be used as a drag icon
// for the given value.
//
// Supported types include strings, GdkRGBA and GtkTextBuffer. If GTK does not
// know how to create a widget for a given value, it will return NULL.
//
// This method is used to set the default drag icon on drag'n'drop operations
// started by GtkDragSource, so you don't need to set a drag icon using this
// function there.
//
// The function takes the following parameters:
//
//   - value: GValue.
//
// The function returns the following values:
//
//   - widget (optional): new GtkWidget for displaying value as a drag icon.
func DragIconCreateWidgetForValue(value *coreglib.Value) Widgetter {
	var _arg1 *C.GValue    // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_drag_icon_create_widget_for_value(_arg1)
	runtime.KeepAlive(value)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.AssumeOwnership(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// DragIconGetForDrag gets the GtkDragIcon in use with drag.
//
// If no drag icon exists yet, a new one will be created and shown.
//
// The function takes the following parameters:
//
//   - drag: GdkDrag.
//
// The function returns the following values:
//
//   - widget: GtkDragIcon.
func DragIconGetForDrag(drag gdk.Dragger) Widgetter {
	var _arg1 *C.GdkDrag   // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))

	_cret = C.gtk_drag_icon_get_for_drag(_arg1)
	runtime.KeepAlive(drag)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// DragIconSetFromPaintable creates a GtkDragIcon that shows paintable,
// and associates it with the drag operation.
//
// The hotspot position on the paintable is aligned with the hotspot of the
// cursor.
//
// The function takes the following parameters:
//
//   - drag: GdkDrag.
//   - paintable: GdkPaintable to display.
//   - hotX: x coordinate of the hotspot.
//   - hotY: y coordinate of the hotspot.
func DragIconSetFromPaintable(drag gdk.Dragger, paintable gdk.Paintabler, hotX, hotY int) {
	var _arg1 *C.GdkDrag      // out
	var _arg2 *C.GdkPaintable // out
	var _arg3 C.int           // out
	var _arg4 C.int           // out

	_arg1 = (*C.GdkDrag)(unsafe.Pointer(coreglib.InternObject(drag).Native()))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	_arg3 = C.int(hotX)
	_arg4 = C.int(hotY)

	C.gtk_drag_icon_set_from_paintable(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(drag)
	runtime.KeepAlive(paintable)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DragSource: GtkDragSource is an event controller to initiate Drag-And-Drop
// operations.
//
// GtkDragSource can be set up with the necessary ingredients for a DND
// operation ahead of time. This includes the source for the data that is being
// transferred, in the form of a gdk.ContentProvider, the desired action,
// and the icon to use during the drag operation. After setting it up,
// the drag source must be added to a widget as an event controller, using
// gtk.Widget.AddController().
//
//	static void
//	my_widget_init (MyWidget *self)
//	{
//	  GtkDragSource *drag_source = gtk_drag_source_new ();
//
//	  g_signal_connect (drag_source, "prepare", G_CALLBACK (on_drag_prepare), self);
//	  g_signal_connect (drag_source, "drag-begin", G_CALLBACK (on_drag_begin), self);
//
//	  gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (drag_source));
//	}
//
// Setting up the content provider and icon ahead of time only makes sense
// when the data does not change. More commonly, you will want to set them
// up just in time. To do so, GtkDragSource has gtk.DragSource::prepare and
// gtk.DragSource::drag-begin signals.
//
// The ::prepare signal is emitted before a drag is started, and can be used to
// set the content provider and actions that the drag should be started with.
//
//	static GdkContentProvider *
//	on_drag_prepare (GtkDragSource *source,
//	                 double         x,
//	                 double         y,
//	                 MyWidget      *self)
//	{
//	  // This widget supports two types of content: GFile objects
//	  // and GdkPixbuf objects; GTK will handle the serialization
//	  // of these types automatically
//	  GFile *file = my_widget_get_file (self);
//	  GdkPixbuf *pixbuf = my_widget_get_pixbuf (self);
//
//	  return gdk_content_provider_new_union ((GdkContentProvider *[2]) {
//	      gdk_content_provider_new_typed (G_TYPE_FILE, file),
//	      gdk_content_provider_new_typed (GDK_TYPE_PIXBUF, pixbuf),
//	    }, 2);
//	}
//
// The ::drag-begin signal is emitted after the GdkDrag object has been created,
// and can be used to set up the drag icon.
//
//	static void
//	on_drag_begin (GtkDragSource *source,
//	               GtkDrag       *drag,
//	               MyWidget      *self)
//	{
//	  // Set the widget as the drag icon
//	  GdkPaintable *paintable = gtk_widget_paintable_new (GTK_WIDGET (self));
//	  gtk_drag_source_set_icon (source, paintable, 0, 0);
//	  g_object_unref (paintable);
//	}
//
// During the DND operation, GtkDragSource emits signals that can be used
// to obtain updates about the status of the operation, but it is not
// normally necessary to connect to any signals, except for one case:
// when the supported actions include GDK_ACTION_MOVE, you need to listen for
// the gtk.DragSource::drag-end signal and delete the data after it has been
// transferred.
type DragSource struct {
	_ [0]func() // equal guard
	GestureSingle
}

var (
	_ Gesturer = (*DragSource)(nil)
)

func wrapDragSource(obj *coreglib.Object) *DragSource {
	return &DragSource{
		GestureSingle: GestureSingle{
			Gesture: Gesture{
				EventController: EventController{
					Object: obj,
				},
			},
		},
	}
}

func marshalDragSource(p uintptr) (interface{}, error) {
	return wrapDragSource(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDragBegin is emitted on the drag source when a drag is started.
//
// It can be used to e.g. set a custom drag icon with gtk.DragSource.SetIcon().
func (source *DragSource) ConnectDragBegin(f func(drag gdk.Dragger)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(source, "drag-begin", false, unsafe.Pointer(C._gotk4_gtk4_DragSource_ConnectDragBegin), f)
}

// ConnectDragCancel is emitted on the drag source when a drag has failed.
//
// The signal handler may handle a failed drag operation based on the type of
// error. It should return TRUE if the failure has been handled and the default
// "drag operation failed" animation should not be shown.
func (source *DragSource) ConnectDragCancel(f func(drag gdk.Dragger, reason gdk.DragCancelReason) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(source, "drag-cancel", false, unsafe.Pointer(C._gotk4_gtk4_DragSource_ConnectDragCancel), f)
}

// ConnectDragEnd is emitted on the drag source when a drag is finished.
//
// A typical reason to connect to this signal is to undo things done in
// gtk.DragSource::prepare or gtk.DragSource::drag-begin handlers.
func (source *DragSource) ConnectDragEnd(f func(drag gdk.Dragger, deleteData bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(source, "drag-end", false, unsafe.Pointer(C._gotk4_gtk4_DragSource_ConnectDragEnd), f)
}

// ConnectPrepare is emitted when a drag is about to be initiated.
//
// It returns the GdkContentProvider to use for the drag that is about
// to start. The default handler for this signal returns the value of the
// gtk.DragSource:content property, so if you set up that property ahead of
// time, you don't need to connect to this signal.
func (source *DragSource) ConnectPrepare(f func(x, y float64) (contentProvider *gdk.ContentProvider)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(source, "prepare", false, unsafe.Pointer(C._gotk4_gtk4_DragSource_ConnectPrepare), f)
}

// NewDragSource creates a new GtkDragSource object.
//
// The function returns the following values:
//
//   - dragSource: new GtkDragSource.
func NewDragSource() *DragSource {
	var _cret *C.GtkDragSource // in

	_cret = C.gtk_drag_source_new()

	var _dragSource *DragSource // out

	_dragSource = wrapDragSource(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dragSource
}

// DragCancel cancels a currently ongoing drag operation.
func (source *DragSource) DragCancel() {
	var _arg0 *C.GtkDragSource // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	C.gtk_drag_source_drag_cancel(_arg0)
	runtime.KeepAlive(source)
}

// Actions gets the actions that are currently set on the GtkDragSource.
//
// The function returns the following values:
//
//   - dragAction actions set on source.
func (source *DragSource) Actions() gdk.DragAction {
	var _arg0 *C.GtkDragSource // out
	var _cret C.GdkDragAction  // in

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	_cret = C.gtk_drag_source_get_actions(_arg0)
	runtime.KeepAlive(source)

	var _dragAction gdk.DragAction // out

	_dragAction = gdk.DragAction(_cret)

	return _dragAction
}

// Content gets the current content provider of a GtkDragSource.
//
// The function returns the following values:
//
//   - contentProvider (optional): GdkContentProvider of source.
func (source *DragSource) Content() *gdk.ContentProvider {
	var _arg0 *C.GtkDragSource      // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	_cret = C.gtk_drag_source_get_content(_arg0)
	runtime.KeepAlive(source)

	var _contentProvider *gdk.ContentProvider // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_contentProvider = &gdk.ContentProvider{
				Object: obj,
			}
		}
	}

	return _contentProvider
}

// Drag returns the underlying GdkDrag object for an ongoing drag.
//
// The function returns the following values:
//
//   - drag (optional): GdkDrag of the current drag operation, or NULL.
func (source *DragSource) Drag() gdk.Dragger {
	var _arg0 *C.GtkDragSource // out
	var _cret *C.GdkDrag       // in

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(coreglib.InternObject(source).Native()))

	_cret = C.gtk_drag_source_get_drag(_arg0)
	runtime.KeepAlive(source)

	var _drag gdk.Dragger // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Dragger)
				return ok
			})
			rv, ok := casted.(gdk.Dragger)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Dragger")
			}
			_drag = rv
		}
	}

	return _drag
}

// SetActions sets the actions on the GtkDragSource.
//
// During a DND operation, the actions are offered to potential drop
// targets. If actions include GDK_ACTION_MOVE, you need to listen to the
// gtk.DragSource::drag-end signal and handle delete_data being TRUE.
//
// This function can be called before a drag is started, or in a handler for the
// gtk.DragSource::prepare signal.
//
// The function takes the following parameters:
//
//   - actions to offer.
func (source *DragSource) SetActions(actions gdk.DragAction) {
	var _arg0 *C.GtkDragSource // out
	var _arg1 C.GdkDragAction  // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	_arg1 = C.GdkDragAction(actions)

	C.gtk_drag_source_set_actions(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(actions)
}

// SetContent sets a content provider on a GtkDragSource.
//
// When the data is requested in the cause of a DND operation, it will be
// obtained from the content provider.
//
// This function can be called before a drag is started, or in a handler for the
// gtk.DragSource::prepare signal.
//
// You may consider setting the content provider back to NULL in a
// gtk.DragSource::drag-end signal handler.
//
// The function takes the following parameters:
//
//   - content (optional): GdkContentProvider, or NULL.
func (source *DragSource) SetContent(content *gdk.ContentProvider) {
	var _arg0 *C.GtkDragSource      // out
	var _arg1 *C.GdkContentProvider // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	if content != nil {
		_arg1 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(content).Native()))
	}

	C.gtk_drag_source_set_content(_arg0, _arg1)
	runtime.KeepAlive(source)
	runtime.KeepAlive(content)
}

// SetIcon sets a paintable to use as icon during DND operations.
//
// The hotspot coordinates determine the point on the icon that gets aligned
// with the hotspot of the cursor.
//
// If paintable is NULL, a default icon is used.
//
// This function can be called before a drag is started, or in a
// gtk.DragSource::prepare or gtk.DragSource::drag-begin signal handler.
//
// The function takes the following parameters:
//
//   - paintable (optional) to use as icon, or NULL.
//   - hotX: hotspot X coordinate on the icon.
//   - hotY: hotspot Y coordinate on the icon.
func (source *DragSource) SetIcon(paintable gdk.Paintabler, hotX, hotY int) {
	var _arg0 *C.GtkDragSource // out
	var _arg1 *C.GdkPaintable  // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkDragSource)(unsafe.Pointer(coreglib.InternObject(source).Native()))
	if paintable != nil {
		_arg1 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	}
	_arg2 = C.int(hotX)
	_arg3 = C.int(hotY)

	C.gtk_drag_source_set_icon(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(source)
	runtime.KeepAlive(paintable)
	runtime.KeepAlive(hotX)
	runtime.KeepAlive(hotY)
}

// DrawingAreaOverrides contains methods that are overridable.
type DrawingAreaOverrides struct {
	// The function takes the following parameters:
	//
	//   - width
	//   - height
	Resize func(width, height int)
}

func defaultDrawingAreaOverrides(v *DrawingArea) DrawingAreaOverrides {
	return DrawingAreaOverrides{
		Resize: v.resize,
	}
}

// DrawingArea: GtkDrawingArea is a widget that allows drawing with cairo.
//
// !An example GtkDrawingArea (drawingarea.png)
//
// It’s essentially a blank widget; you can draw on it. After creating a drawing
// area, the application may want to connect to:
//
// - The gtk.Widget::realize signal to take any necessary actions when the
// widget is instantiated on a particular display. (Create GDK resources in
// response to this signal.)
//
// - The gtk.DrawingArea::resize signal to take any necessary actions when the
// widget changes size.
//
// - Call gtk.DrawingArea.SetDrawFunc() to handle redrawing the contents of the
// widget.
//
// The following code portion demonstrates using a drawing area to display a
// circle in the normal widget foreground color.
//
// Simple GtkDrawingArea usage
//
//	static void
//	draw_function (GtkDrawingArea *area,
//	               cairo_t        *cr,
//	               int             width,
//	               int             height,
//	               gpointer        data)
//	{
//	  GdkRGBA color;
//	  GtkStyleContext *context;
//
//	  context = gtk_widget_get_style_context (GTK_WIDGET (area));
//
//	  cairo_arc (cr,
//	             width / 2.0, height / 2.0,
//	             MIN (width, height) / 2.0,
//	             0, 2 * G_PI);
//
//	  gtk_style_context_get_color (context,
//	                               &color);
//	  gdk_cairo_set_source_rgba (cr, &color);
//
//	  cairo_fill (cr);
//	}
//
//	int
//	main (int argc, char **argv)
//	{
//	  gtk_init ();
//
//	  GtkWidget *area = gtk_drawing_area_new ();
//	  gtk_drawing_area_set_content_width (GTK_DRAWING_AREA (area), 100);
//	  gtk_drawing_area_set_content_height (GTK_DRAWING_AREA (area), 100);
//	  gtk_drawing_area_set_draw_func (GTK_DRAWING_AREA (area),
//	                                  draw_function,
//	                                  NULL, NULL);
//	  return 0;
//	}
//
// The draw function is normally called when a drawing area first comes
// onscreen, or when it’s covered by another window and then uncovered. You can
// also force a redraw by adding to the “damage region” of the drawing area’s
// window using gtk.Widget.QueueDraw(). This will cause the drawing area to call
// the draw function again.
//
// The available routines for drawing are documented on the [GDK Drawing
// Primitives][gdk4-Cairo-Interaction] page and the cairo documentation.
//
// To receive mouse events on a drawing area, you will need to use event
// controllers. To receive keyboard events, you will need to set the “can-focus”
// property on the drawing area, and you should probably draw some user-visible
// indication that the drawing area is focused.
//
// If you need more complex control over your widget, you should consider
// creating your own GtkWidget subclass.
type DrawingArea struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*DrawingArea)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DrawingArea, *DrawingAreaClass, DrawingAreaOverrides](
		GTypeDrawingArea,
		initDrawingAreaClass,
		wrapDrawingArea,
		defaultDrawingAreaOverrides,
	)
}

func initDrawingAreaClass(gclass unsafe.Pointer, overrides DrawingAreaOverrides, classInitFunc func(*DrawingAreaClass)) {
	pclass := (*C.GtkDrawingAreaClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeDrawingArea))))

	if overrides.Resize != nil {
		pclass.resize = (*[0]byte)(C._gotk4_gtk4_DrawingAreaClass_resize)
	}

	if classInitFunc != nil {
		class := (*DrawingAreaClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDrawingArea(obj *coreglib.Object) *DrawingArea {
	return &DrawingArea{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalDrawingArea(p uintptr) (interface{}, error) {
	return wrapDrawingArea(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectResize is emitted once when the widget is realized, and then each time
// the widget is changed while realized.
//
// This is useful in order to keep state up to date with the widget size,
// like for instance a backing surface.
func (self *DrawingArea) ConnectResize(f func(width, height int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "resize", false, unsafe.Pointer(C._gotk4_gtk4_DrawingArea_ConnectResize), f)
}

// NewDrawingArea creates a new drawing area.
//
// The function returns the following values:
//
//   - drawingArea: new GtkDrawingArea.
func NewDrawingArea() *DrawingArea {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_drawing_area_new()

	var _drawingArea *DrawingArea // out

	_drawingArea = wrapDrawingArea(coreglib.Take(unsafe.Pointer(_cret)))

	return _drawingArea
}

// ContentHeight retrieves the content height of the GtkDrawingArea.
//
// The function returns the following values:
//
//   - gint: height requested for content of the drawing area.
func (self *DrawingArea) ContentHeight() int {
	var _arg0 *C.GtkDrawingArea // out
	var _cret C.int             // in

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drawing_area_get_content_height(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ContentWidth retrieves the content width of the GtkDrawingArea.
//
// The function returns the following values:
//
//   - gint: width requested for content of the drawing area.
func (self *DrawingArea) ContentWidth() int {
	var _arg0 *C.GtkDrawingArea // out
	var _cret C.int             // in

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drawing_area_get_content_width(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SetContentHeight sets the desired height of the contents of the drawing area.
//
// Note that because widgets may be allocated larger sizes than they requested,
// it is possible that the actual height passed to your draw function is larger
// than the height set here. You can use gtk.Widget.SetVAlign() to avoid that.
//
// If the height is set to 0 (the default), the drawing area may disappear.
//
// The function takes the following parameters:
//
//   - height of contents.
func (self *DrawingArea) SetContentHeight(height int) {
	var _arg0 *C.GtkDrawingArea // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(height)

	C.gtk_drawing_area_set_content_height(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(height)
}

// SetContentWidth sets the desired width of the contents of the drawing area.
//
// Note that because widgets may be allocated larger sizes than they requested,
// it is possible that the actual width passed to your draw function is larger
// than the width set here. You can use gtk.Widget.SetHAlign() to avoid that.
//
// If the width is set to 0 (the default), the drawing area may disappear.
//
// The function takes the following parameters:
//
//   - width of contents.
func (self *DrawingArea) SetContentWidth(width int) {
	var _arg0 *C.GtkDrawingArea // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(width)

	C.gtk_drawing_area_set_content_width(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(width)
}

// SetDrawFunc: setting a draw function is the main thing you want to do when
// using a drawing area.
//
// The draw function is called whenever GTK needs to draw the contents of the
// drawing area to the screen.
//
// The draw function will be called during the drawing stage of GTK. In the
// drawing stage it is not allowed to change properties of any GTK widgets or
// call any functions that would cause any properties to be changed. You should
// restrict yourself exclusively to drawing your contents in the draw function.
//
// If what you are drawing does change, call gtk.Widget.QueueDraw() on the
// drawing area. This will cause a redraw and will call draw_func again.
//
// The function takes the following parameters:
//
//   - drawFunc (optional): callback that lets you draw the drawing area's
//     contents.
func (self *DrawingArea) SetDrawFunc(drawFunc DrawingAreaDrawFunc) {
	var _arg0 *C.GtkDrawingArea        // out
	var _arg1 C.GtkDrawingAreaDrawFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if drawFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_DrawingAreaDrawFunc)
		_arg2 = C.gpointer(gbox.Assign(drawFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_drawing_area_set_draw_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(drawFunc)
}

// The function takes the following parameters:
//
//   - width
//   - height
func (area *DrawingArea) resize(width, height int) {
	gclass := (*C.GtkDrawingAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.resize

	var _arg0 *C.GtkDrawingArea // out
	var _arg1 C.int             // out
	var _arg2 C.int             // out

	_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C._gotk4_gtk4_DrawingArea_virtual_resize(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// DropControllerMotion: GtkDropControllerMotion is an event controller tracking
// the pointer during Drag-and-Drop operations.
//
// It is modeled after gtk.EventControllerMotion so if you have used that,
// this should feel really familiar.
//
// This controller is not able to accept drops, use gtk.DropTarget for that
// purpose.
type DropControllerMotion struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*DropControllerMotion)(nil)
)

func wrapDropControllerMotion(obj *coreglib.Object) *DropControllerMotion {
	return &DropControllerMotion{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalDropControllerMotion(p uintptr) (interface{}, error) {
	return wrapDropControllerMotion(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEnter signals that the pointer has entered the widget.
func (self *DropControllerMotion) ConnectEnter(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "enter", false, unsafe.Pointer(C._gotk4_gtk4_DropControllerMotion_ConnectEnter), f)
}

// ConnectLeave signals that the pointer has left the widget.
func (self *DropControllerMotion) ConnectLeave(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "leave", false, unsafe.Pointer(C._gotk4_gtk4_DropControllerMotion_ConnectLeave), f)
}

// ConnectMotion is emitted when the pointer moves inside the widget.
func (self *DropControllerMotion) ConnectMotion(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "motion", false, unsafe.Pointer(C._gotk4_gtk4_DropControllerMotion_ConnectMotion), f)
}

// NewDropControllerMotion creates a new event controller that will handle
// pointer motion events during drag and drop.
//
// The function returns the following values:
//
//   - dropControllerMotion: new GtkDropControllerMotion.
func NewDropControllerMotion() *DropControllerMotion {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_drop_controller_motion_new()

	var _dropControllerMotion *DropControllerMotion // out

	_dropControllerMotion = wrapDropControllerMotion(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dropControllerMotion
}

// ContainsPointer returns if a Drag-and-Drop operation is within the widget
// self or one of its children.
//
// The function returns the following values:
//
//   - ok: TRUE if a dragging pointer is within self or one of its children.
func (self *DropControllerMotion) ContainsPointer() bool {
	var _arg0 *C.GtkDropControllerMotion // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_controller_motion_contains_pointer(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Drop returns the GdkDrop of a current Drag-and-Drop operation over the widget
// of self.
//
// The function returns the following values:
//
//   - drop (optional): GdkDrop currently happening within self or NULL if none.
func (self *DropControllerMotion) Drop() gdk.Dropper {
	var _arg0 *C.GtkDropControllerMotion // out
	var _cret *C.GdkDrop                 // in

	_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_controller_motion_get_drop(_arg0)
	runtime.KeepAlive(self)

	var _drop gdk.Dropper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Dropper)
				return ok
			})
			rv, ok := casted.(gdk.Dropper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Dropper")
			}
			_drop = rv
		}
	}

	return _drop
}

// IsPointer returns if a Drag-and-Drop operation is within the widget self,
// not one of its children.
//
// The function returns the following values:
//
//   - ok: TRUE if a dragging pointer is within self but not one of its
//     children.
func (self *DropControllerMotion) IsPointer() bool {
	var _arg0 *C.GtkDropControllerMotion // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_controller_motion_is_pointer(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DropDownOverrides contains methods that are overridable.
type DropDownOverrides struct {
}

func defaultDropDownOverrides(v *DropDown) DropDownOverrides {
	return DropDownOverrides{}
}

// DropDown: GtkDropDown is a widget that allows the user to choose an item from
// a list of options.
//
// !An example GtkDropDown (drop-down.png)
//
// The GtkDropDown displays the selected choice.
//
// The options are given to GtkDropDown in the form of GListModel and how the
// individual options are represented is determined by a gtk.ListItemFactory.
// The default factory displays simple strings.
//
// GtkDropDown knows how to obtain strings from the items in a gtk.StringList;
// for other models, you have to provide an expression to find the strings via
// gtk.DropDown.SetExpression().
//
// GtkDropDown can optionally allow search in the popup, which is useful
// if the list of options is long. To enable the search entry, use
// gtk.DropDown.SetEnableSearch().
//
// # CSS nodes
//
// GtkDropDown has a single CSS node with name dropdown, with the button and
// popover nodes as children.
//
// # Accessibility
//
// GtkDropDown uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
type DropDown struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*DropDown)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*DropDown, *DropDownClass, DropDownOverrides](
		GTypeDropDown,
		initDropDownClass,
		wrapDropDown,
		defaultDropDownOverrides,
	)
}

func initDropDownClass(gclass unsafe.Pointer, overrides DropDownOverrides, classInitFunc func(*DropDownClass)) {
	if classInitFunc != nil {
		class := (*DropDownClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapDropDown(obj *coreglib.Object) *DropDown {
	return &DropDown{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalDropDown(p uintptr) (interface{}, error) {
	return wrapDropDown(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewDropDown creates a new GtkDropDown.
//
// You may want to call gtk.DropDown.SetFactory() to set up a way to map its
// items to widgets.
//
// The function takes the following parameters:
//
//   - model (optional) to use or NULL for none.
//   - expression (optional) to use or NULL for none.
//
// The function returns the following values:
//
//   - dropDown: new GtkDropDown.
func NewDropDown(model gio.ListModeller, expression Expressioner) *DropDown {
	var _arg1 *C.GListModel    // out
	var _arg2 *C.GtkExpression // out
	var _cret *C.GtkWidget     // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	if expression != nil {
		_arg2 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}

	_cret = C.gtk_drop_down_new(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(expression)

	var _dropDown *DropDown // out

	_dropDown = wrapDropDown(coreglib.Take(unsafe.Pointer(_cret)))

	return _dropDown
}

// NewDropDownFromStrings creates a new GtkDropDown that is populated with the
// strings.
//
// The function takes the following parameters:
//
//   - strings to put in the dropdown.
//
// The function returns the following values:
//
//   - dropDown: new GtkDropDown.
func NewDropDownFromStrings(strings []string) *DropDown {
	var _arg1 **C.char     // out
	var _cret *C.GtkWidget // in

	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(strings) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(strings)+1)
			var zero *C.char
			out[len(strings)] = zero
			for i := range strings {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(strings[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gtk_drop_down_new_from_strings(_arg1)
	runtime.KeepAlive(strings)

	var _dropDown *DropDown // out

	_dropDown = wrapDropDown(coreglib.Take(unsafe.Pointer(_cret)))

	return _dropDown
}

// EnableSearch returns whether search is enabled.
//
// The function returns the following values:
//
//   - ok: TRUE if the popup includes a search entry.
func (self *DropDown) EnableSearch() bool {
	var _arg0 *C.GtkDropDown // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_down_get_enable_search(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Expression gets the expression set that is used to obtain strings from items.
//
// See gtk.DropDown.SetExpression().
//
// The function returns the following values:
//
//   - expression (optional): GtkExpression or NULL.
func (self *DropDown) Expression() Expressioner {
	var _arg0 *C.GtkDropDown   // out
	var _cret *C.GtkExpression // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_down_get_expression(_arg0)
	runtime.KeepAlive(self)

	var _expression Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// Factory gets the factory that's currently used to populate list items.
//
// The factory returned by this function is always used for the item in the
// button. It is also used for items in the popup if gtk.DropDown:list-factory
// is not set.
//
// The function returns the following values:
//
//   - listItemFactory (optional): factory in use.
func (self *DropDown) Factory() *ListItemFactory {
	var _arg0 *C.GtkDropDown        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_down_get_factory(_arg0)
	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if _cret != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// ListFactory gets the factory that's currently used to populate list items in
// the popup.
//
// The function returns the following values:
//
//   - listItemFactory (optional): factory in use.
func (self *DropDown) ListFactory() *ListItemFactory {
	var _arg0 *C.GtkDropDown        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_down_get_list_factory(_arg0)
	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if _cret != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// Model gets the model that provides the displayed items.
//
// The function returns the following values:
//
//   - listModel (optional): model in use.
func (self *DropDown) Model() *gio.ListModel {
	var _arg0 *C.GtkDropDown // out
	var _cret *C.GListModel  // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_down_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// Selected gets the position of the selected item.
//
// The function returns the following values:
//
//   - guint: position of the selected item, or GTK_INVALID_LIST_POSITION if not
//     item is selected.
func (self *DropDown) Selected() uint {
	var _arg0 *C.GtkDropDown // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_down_get_selected(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SelectedItem gets the selected item. If no item is selected, NULL is
// returned.
//
// The function returns the following values:
//
//   - object (optional): selected item.
func (self *DropDown) SelectedItem() *coreglib.Object {
	var _arg0 *C.GtkDropDown // out
	var _cret C.gpointer     // in

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_down_get_selected_item(_arg0)
	runtime.KeepAlive(self)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// SetEnableSearch sets whether a search entry will be shown in the popup that
// allows to search for items in the list.
//
// Note that gtk.DropDown:expression must be set for search to work.
//
// The function takes the following parameters:
//
//   - enableSearch: whether to enable search.
func (self *DropDown) SetEnableSearch(enableSearch bool) {
	var _arg0 *C.GtkDropDown // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enableSearch {
		_arg1 = C.TRUE
	}

	C.gtk_drop_down_set_enable_search(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enableSearch)
}

// SetExpression sets the expression that gets evaluated to obtain strings from
// items.
//
// This is used for search in the popup. The expression must have a value type
// of G_TYPE_STRING.
//
// The function takes the following parameters:
//
//   - expression (optional): GtkExpression, or NULL.
func (self *DropDown) SetExpression(expression Expressioner) {
	var _arg0 *C.GtkDropDown   // out
	var _arg1 *C.GtkExpression // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
	}

	C.gtk_drop_down_set_expression(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expression)
}

// SetFactory sets the GtkListItemFactory to use for populating list items.
//
// The function takes the following parameters:
//
//   - factory (optional) to use or NULL for none.
func (self *DropDown) SetFactory(factory *ListItemFactory) {
	var _arg0 *C.GtkDropDown        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	C.gtk_drop_down_set_factory(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetListFactory sets the GtkListItemFactory to use for populating list items
// in the popup.
//
// The function takes the following parameters:
//
//   - factory (optional) to use or NULL for none.
func (self *DropDown) SetListFactory(factory *ListItemFactory) {
	var _arg0 *C.GtkDropDown        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	C.gtk_drop_down_set_list_factory(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetModel sets the GListModel to use.
//
// The function takes the following parameters:
//
//   - model (optional) to use or NULL for none.
func (self *DropDown) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkDropDown // out
	var _arg1 *C.GListModel  // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_drop_down_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetSelected selects the item at the given position.
//
// The function takes the following parameters:
//
//   - position of the item to select, or GTK_INVALID_LIST_POSITION.
func (self *DropDown) SetSelected(position uint) {
	var _arg0 *C.GtkDropDown // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkDropDown)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	C.gtk_drop_down_set_selected(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// DropTarget: GtkDropTarget is an event controller to receive Drag-and-Drop
// operations.
//
// The most basic way to use a GtkDropTarget to receive drops on a widget is to
// create it via gtk.DropTarget.New, passing in the GType of the data you want
// to receive and connect to the gtk.DropTarget::drop signal to receive the
// data:
//
//	static gboolean
//	on_drop (GtkDropTarget *target,
//	         const GValue  *value,
//	         double         x,
//	         double         y,
//	         gpointer       data)
//	{
//	  MyWidget *self = data;
//
//	  // Call the appropriate setter depending on the type of data
//	  // that we received
//	  if (G_VALUE_HOLDS (value, G_TYPE_FILE))
//	    my_widget_set_file (self, g_value_get_object (value));
//	  else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
//	    my_widget_set_pixbuf (self, g_value_get_object (value));
//	  else
//	    return FALSE;
//
//	  return TRUE;
//	}
//
//	static void
//	my_widget_init (MyWidget *self)
//	{
//	  GtkDropTarget *target =
//	    gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);
//
//	  // This widget accepts two types of drop types: GFile objects
//	  // and GdkPixbuf objects
//	  gtk_drop_target_set_gtypes (target, (GTypes [2]) {
//	    G_TYPE_FILE,
//	    GDK_TYPE_PIXBUF,
//	  }, 2);
//
//	  gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
//	}
//
// GtkDropTarget supports more options, such as:
//
//   - rejecting potential drops via the gtk.DropTarget::accept signal and the
//     gtk.DropTarget.Reject() function to let other drop targets handle the
//     drop
//   - tracking an ongoing drag operation before the drop via the
//     gtk.DropTarget::enter, gtk.DropTarget::motion and gtk.DropTarget::leave
//     signals
//   - configuring how to receive data by setting the gtk.DropTarget:preload
//     property and listening for its availability via the gtk.DropTarget:value
//     property
//
// However, GtkDropTarget is ultimately modeled in a synchronous way and only
// supports data transferred via GType. If you want full control over an ongoing
// drop, the gtk.DropTargetAsync object gives you this ability.
//
// While a pointer is dragged over the drop target's widget and the drop has not
// been rejected, that widget will receive the GTK_STATE_FLAG_DROP_ACTIVE state,
// which can be used to style the widget.
//
// If you are not interested in receiving the drop, but just want to update UI
// state during a Drag-and-Drop operation (e.g. switching tabs), you can use
// gtk.DropControllerMotion.
type DropTarget struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*DropTarget)(nil)
)

func wrapDropTarget(obj *coreglib.Object) *DropTarget {
	return &DropTarget{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalDropTarget(p uintptr) (interface{}, error) {
	return wrapDropTarget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAccept is emitted on the drop site when a drop operation is about to
// begin.
//
// If the drop is not accepted, FALSE will be returned and the drop target will
// ignore the drop. If TRUE is returned, the drop is accepted for now but may
// be rejected later via a call to gtk.DropTarget.Reject() or ultimately by
// returning FALSE from a gtk.DropTarget::drop handler.
//
// The default handler for this signal decides whether to accept the drop based
// on the formats provided by the drop.
//
// If the decision whether the drop will be accepted or rejected depends on the
// data, this function should return TRUE, the gtk.DropTarget:preload property
// should be set and the value should be inspected via the ::notify:value
// signal, calling gtk.DropTarget.Reject() if required.
func (self *DropTarget) ConnectAccept(f func(drop gdk.Dropper) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "accept", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectAccept), f)
}

// ConnectDrop is emitted on the drop site when the user drops the data onto the
// widget.
//
// The signal handler must determine whether the pointer position is in a drop
// zone or not. If it is not in a drop zone, it returns FALSE and no further
// processing is necessary.
//
// Otherwise, the handler returns TRUE. In this case, this handler will
// accept the drop. The handler is responsible for rading the given value and
// performing the drop operation.
func (self *DropTarget) ConnectDrop(f func(value *coreglib.Value, x, y float64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "drop", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectDrop), f)
}

// ConnectEnter is emitted on the drop site when the pointer enters the widget.
//
// It can be used to set up custom highlighting.
func (self *DropTarget) ConnectEnter(f func(x, y float64) (dragAction gdk.DragAction)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "enter", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectEnter), f)
}

// ConnectLeave is emitted on the drop site when the pointer leaves the widget.
//
// Its main purpose it to undo things done in gtk.DropTarget::enter.
func (self *DropTarget) ConnectLeave(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "leave", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectLeave), f)
}

// ConnectMotion is emitted while the pointer is moving over the drop target.
func (self *DropTarget) ConnectMotion(f func(x, y float64) (dragAction gdk.DragAction)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "motion", false, unsafe.Pointer(C._gotk4_gtk4_DropTarget_ConnectMotion), f)
}

// NewDropTarget creates a new GtkDropTarget object.
//
// If the drop target should support more than 1 type, pass G_TYPE_INVALID for
// type and then call gtk.DropTarget.SetGTypes().
//
// The function takes the following parameters:
//
//   - typ: supported type or G_TYPE_INVALID.
//   - actions: supported actions.
//
// The function returns the following values:
//
//   - dropTarget: new GtkDropTarget.
func NewDropTarget(typ coreglib.Type, actions gdk.DragAction) *DropTarget {
	var _arg1 C.GType          // out
	var _arg2 C.GdkDragAction  // out
	var _cret *C.GtkDropTarget // in

	_arg1 = C.GType(typ)
	_arg2 = C.GdkDragAction(actions)

	_cret = C.gtk_drop_target_new(_arg1, _arg2)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(actions)

	var _dropTarget *DropTarget // out

	_dropTarget = wrapDropTarget(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dropTarget
}

// Actions gets the actions that this drop target supports.
//
// The function returns the following values:
//
//   - dragAction actions that this drop target supports.
func (self *DropTarget) Actions() gdk.DragAction {
	var _arg0 *C.GtkDropTarget // out
	var _cret C.GdkDragAction  // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_get_actions(_arg0)
	runtime.KeepAlive(self)

	var _dragAction gdk.DragAction // out

	_dragAction = gdk.DragAction(_cret)

	return _dragAction
}

// Drop gets the currently handled drop operation.
//
// If no drop operation is going on, NULL is returned.
//
// The function returns the following values:
//
//   - drop (optional): current drop.
func (self *DropTarget) Drop() gdk.Dropper {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GdkDrop       // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_get_drop(_arg0)
	runtime.KeepAlive(self)

	var _drop gdk.Dropper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Dropper)
				return ok
			})
			rv, ok := casted.(gdk.Dropper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Dropper")
			}
			_drop = rv
		}
	}

	return _drop
}

// Formats gets the data formats that this drop target accepts.
//
// If the result is NULL, all formats are expected to be supported.
//
// The function returns the following values:
//
//   - contentFormats (optional): supported data formats.
func (self *DropTarget) Formats() *gdk.ContentFormats {
	var _arg0 *C.GtkDropTarget     // out
	var _cret *C.GdkContentFormats // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_get_formats(_arg0)
	runtime.KeepAlive(self)

	var _contentFormats *gdk.ContentFormats // out

	if _cret != nil {
		_contentFormats = (*gdk.ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_contentFormats)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
			},
		)
	}

	return _contentFormats
}

// GTypes gets the list of supported GTypes for self.
//
// If no type have been set, NULL will be returned.
//
// The function returns the following values:
//
//   - gTypes (optional): G_TYPE_INVALID-terminated array of types included in
//     formats or NULL if none.
func (self *DropTarget) GTypes() []coreglib.Type {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GType         // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_get_gtypes(_arg0, &_arg1)
	runtime.KeepAlive(self)

	var _gTypes []coreglib.Type // out

	if _cret != nil {
		{
			src := unsafe.Slice((*C.GType)(_cret), _arg1)
			_gTypes = make([]coreglib.Type, _arg1)
			for i := 0; i < int(_arg1); i++ {
				_gTypes[i] = coreglib.Type(src[i])
			}
		}
	}

	return _gTypes
}

// Preload gets whether data should be preloaded on hover.
//
// The function returns the following values:
//
//   - ok: TRUE if drop data should be preloaded.
func (self *DropTarget) Preload() bool {
	var _arg0 *C.GtkDropTarget // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_get_preload(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets the current drop data, as a GValue.
//
// The function returns the following values:
//
//   - value (optional): current drop data.
func (self *DropTarget) Value() *coreglib.Value {
	var _arg0 *C.GtkDropTarget // out
	var _cret *C.GValue        // in

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_get_value(_arg0)
	runtime.KeepAlive(self)

	var _value *coreglib.Value // out

	if _cret != nil {
		_value = coreglib.ValueFromNative(unsafe.Pointer(_cret))
	}

	return _value
}

// Reject rejects the ongoing drop operation.
//
// If no drop operation is ongoing, i.e when gtk.DropTarget:drop is NULL,
// this function does nothing.
//
// This function should be used when delaying the decision on whether to accept
// a drag or not until after reading the data.
func (self *DropTarget) Reject() {
	var _arg0 *C.GtkDropTarget // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_drop_target_reject(_arg0)
	runtime.KeepAlive(self)
}

// SetActions sets the actions that this drop target supports.
//
// The function takes the following parameters:
//
//   - actions: supported actions.
func (self *DropTarget) SetActions(actions gdk.DragAction) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 C.GdkDragAction  // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GdkDragAction(actions)

	C.gtk_drop_target_set_actions(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(actions)
}

// SetGTypes sets the supported GTypes for this drop target.
//
// The function takes the following parameters:
//
//   - types (optional): all supported #GTypes that can be dropped.
func (self *DropTarget) SetGTypes(types []coreglib.Type) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 *C.GType         // out
	var _arg2 C.gsize

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg2 = (C.gsize)(len(types))
	_arg1 = (*C.GType)(C.calloc(C.size_t(len(types)), C.size_t(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GType)(_arg1), len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	C.gtk_drop_target_set_gtypes(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(types)
}

// SetPreload sets whether data should be preloaded on hover.
//
// The function takes the following parameters:
//
//   - preload: TRUE to preload drop data.
func (self *DropTarget) SetPreload(preload bool) {
	var _arg0 *C.GtkDropTarget // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if preload {
		_arg1 = C.TRUE
	}

	C.gtk_drop_target_set_preload(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(preload)
}

// DropTargetAsync: GtkDropTargetAsync is an event controller to receive
// Drag-and-Drop operations, asynchronously.
//
// It is the more complete but also more complex method of handling drop
// operations compared to gtk.DropTarget, and you should only use it if
// GtkDropTarget doesn't provide all the features you need.
//
// To use a GtkDropTargetAsync to receive drops on a widget, you create a
// GtkDropTargetAsync object, configure which data formats and actions you
// support, connect to its signals, and then attach it to the widget with
// gtk.Widget.AddController().
//
// During a drag operation, the first signal that a GtkDropTargetAsync emits is
// gtk.DropTargetAsync::accept, which is meant to determine whether the target
// is a possible drop site for the ongoing drop. The default handler for the
// ::accept signal accepts the drop if it finds a compatible data format and an
// action that is supported on both sides.
//
// If it is, and the widget becomes a target, you will receive
// a gtk.DropTargetAsync::drag-enter signal, followed by
// gtk.DropTargetAsync::drag-motion signals as the pointer moves, optionally
// a gtk.DropTargetAsync::drop signal when a drop happens, and finally a
// gtk.DropTargetAsync::drag-leave signal when the pointer moves off the widget.
//
// The ::drag-enter and ::drag-motion handler return a GdkDragAction to update
// the status of the ongoing operation. The ::drop handler should decide if
// it ultimately accepts the drop and if it does, it should initiate the data
// transfer and finish the operation by calling gdk.Drop.Finish().
//
// Between the ::drag-enter and ::drag-leave signals the widget is a current
// drop target, and will receive the GTK_STATE_FLAG_DROP_ACTIVE state, which can
// be used by themes to style the widget as a drop target.
type DropTargetAsync struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*DropTargetAsync)(nil)
)

func wrapDropTargetAsync(obj *coreglib.Object) *DropTargetAsync {
	return &DropTargetAsync{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalDropTargetAsync(p uintptr) (interface{}, error) {
	return wrapDropTargetAsync(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAccept is emitted on the drop site when a drop operation is about to
// begin.
//
// If the drop is not accepted, FALSE will be returned and the drop target will
// ignore the drop. If TRUE is returned, the drop is accepted for now but may be
// rejected later via a call to gtk.DropTargetAsync.RejectDrop() or ultimately
// by returning FALSE from a gtk.DropTargetAsync::drop handler.
//
// The default handler for this signal decides whether to accept the drop based
// on the formats provided by the drop.
//
// If the decision whether the drop will be accepted or rejected needs further
// processing, such as inspecting the data, this function should return TRUE and
// proceed as is drop was accepted and if it decides to reject the drop later,
// it should call gtk.DropTargetAsync.RejectDrop().
func (self *DropTargetAsync) ConnectAccept(f func(drop gdk.Dropper) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "accept", false, unsafe.Pointer(C._gotk4_gtk4_DropTargetAsync_ConnectAccept), f)
}

// ConnectDragEnter is emitted on the drop site when the pointer enters the
// widget.
//
// It can be used to set up custom highlighting.
func (self *DropTargetAsync) ConnectDragEnter(f func(drop gdk.Dropper, x, y float64) (dragAction gdk.DragAction)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "drag-enter", false, unsafe.Pointer(C._gotk4_gtk4_DropTargetAsync_ConnectDragEnter), f)
}

// ConnectDragLeave is emitted on the drop site when the pointer leaves the
// widget.
//
// Its main purpose it to undo things done in GtkDropTargetAsync::drag-enter.
func (self *DropTargetAsync) ConnectDragLeave(f func(drop gdk.Dropper)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "drag-leave", false, unsafe.Pointer(C._gotk4_gtk4_DropTargetAsync_ConnectDragLeave), f)
}

// ConnectDragMotion is emitted while the pointer is moving over the drop
// target.
func (self *DropTargetAsync) ConnectDragMotion(f func(drop gdk.Dropper, x, y float64) (dragAction gdk.DragAction)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "drag-motion", false, unsafe.Pointer(C._gotk4_gtk4_DropTargetAsync_ConnectDragMotion), f)
}

// ConnectDrop is emitted on the drop site when the user drops the data onto the
// widget.
//
// The signal handler must determine whether the pointer position is in a drop
// zone or not. If it is not in a drop zone, it returns FALSE and no further
// processing is necessary.
//
// Otherwise, the handler returns TRUE. In this case, this handler will accept
// the drop. The handler must ensure that gdk.Drop.Finish() is called to let the
// source know that the drop is done. The call to gdk.Drop.Finish() must only be
// done when all data has been received.
//
// To receive the data, use one of the read functions provided by gdk.Drop such
// as gdk.Drop.ReadAsync() or gdk.Drop.ReadValueAsync().
func (self *DropTargetAsync) ConnectDrop(f func(drop gdk.Dropper, x, y float64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "drop", false, unsafe.Pointer(C._gotk4_gtk4_DropTargetAsync_ConnectDrop), f)
}

// NewDropTargetAsync creates a new GtkDropTargetAsync object.
//
// The function takes the following parameters:
//
//   - formats (optional): supported data formats.
//   - actions: supported actions.
//
// The function returns the following values:
//
//   - dropTargetAsync: new GtkDropTargetAsync.
func NewDropTargetAsync(formats *gdk.ContentFormats, actions gdk.DragAction) *DropTargetAsync {
	var _arg1 *C.GdkContentFormats  // out
	var _arg2 C.GdkDragAction       // out
	var _cret *C.GtkDropTargetAsync // in

	if formats != nil {
		_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	}
	_arg2 = C.GdkDragAction(actions)

	_cret = C.gtk_drop_target_async_new(_arg1, _arg2)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(actions)

	var _dropTargetAsync *DropTargetAsync // out

	_dropTargetAsync = wrapDropTargetAsync(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _dropTargetAsync
}

// Actions gets the actions that this drop target supports.
//
// The function returns the following values:
//
//   - dragAction actions that this drop target supports.
func (self *DropTargetAsync) Actions() gdk.DragAction {
	var _arg0 *C.GtkDropTargetAsync // out
	var _cret C.GdkDragAction       // in

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_async_get_actions(_arg0)
	runtime.KeepAlive(self)

	var _dragAction gdk.DragAction // out

	_dragAction = gdk.DragAction(_cret)

	return _dragAction
}

// Formats gets the data formats that this drop target accepts.
//
// If the result is NULL, all formats are expected to be supported.
//
// The function returns the following values:
//
//   - contentFormats (optional): supported data formats.
func (self *DropTargetAsync) Formats() *gdk.ContentFormats {
	var _arg0 *C.GtkDropTargetAsync // out
	var _cret *C.GdkContentFormats  // in

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_drop_target_async_get_formats(_arg0)
	runtime.KeepAlive(self)

	var _contentFormats *gdk.ContentFormats // out

	if _cret != nil {
		_contentFormats = (*gdk.ContentFormats)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_contentFormats)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gdk_content_formats_unref((*C.GdkContentFormats)(intern.C))
			},
		)
	}

	return _contentFormats
}

// RejectDrop sets the drop as not accepted on this drag site.
//
// This function should be used when delaying the decision on whether to accept
// a drag or not until after reading the data.
//
// The function takes the following parameters:
//
//   - drop of an ongoing drag operation.
func (self *DropTargetAsync) RejectDrop(drop gdk.Dropper) {
	var _arg0 *C.GtkDropTargetAsync // out
	var _arg1 *C.GdkDrop            // out

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkDrop)(unsafe.Pointer(coreglib.InternObject(drop).Native()))

	C.gtk_drop_target_async_reject_drop(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(drop)
}

// SetActions sets the actions that this drop target supports.
//
// The function takes the following parameters:
//
//   - actions: supported actions.
func (self *DropTargetAsync) SetActions(actions gdk.DragAction) {
	var _arg0 *C.GtkDropTargetAsync // out
	var _arg1 C.GdkDragAction       // out

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GdkDragAction(actions)

	C.gtk_drop_target_async_set_actions(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(actions)
}

// SetFormats sets the data formats that this drop target will accept.
//
// The function takes the following parameters:
//
//   - formats (optional): supported data formats or NULL for any format.
func (self *DropTargetAsync) SetFormats(formats *gdk.ContentFormats) {
	var _arg0 *C.GtkDropTargetAsync // out
	var _arg1 *C.GdkContentFormats  // out

	_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if formats != nil {
		_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	}

	C.gtk_drop_target_async_set_formats(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(formats)
}

// EditableLabelOverrides contains methods that are overridable.
type EditableLabelOverrides struct {
}

func defaultEditableLabelOverrides(v *EditableLabel) EditableLabelOverrides {
	return EditableLabelOverrides{}
}

// EditableLabel: GtkEditableLabel is a label that allows users to edit the text
// by switching to an “edit mode”.
//
// !An example GtkEditableLabel (editable-label.png)
//
// GtkEditableLabel does not have API of its own, but it implements the
// gtk.Editable interface.
//
// The default bindings for activating the edit mode is to click or press the
// Enter key. The default bindings for leaving the edit mode are the Enter key
// (to save the results) or the Escape key (to cancel the editing).
//
// CSS nodes
//
//	editablelabel[.editing]
//	╰── stack
//	    ├── label
//	    ╰── text
//
// GtkEditableLabel has a main node with the name editablelabel. When the entry
// is in editing mode, it gets the .editing style class.
//
// For all the subnodes added to the text node in various situations, see
// gtk.Text.
type EditableLabel struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	EditableTextWidget
}

var (
	_ Widgetter         = (*EditableLabel)(nil)
	_ coreglib.Objector = (*EditableLabel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*EditableLabel, *EditableLabelClass, EditableLabelOverrides](
		GTypeEditableLabel,
		initEditableLabelClass,
		wrapEditableLabel,
		defaultEditableLabelOverrides,
	)
}

func initEditableLabelClass(gclass unsafe.Pointer, overrides EditableLabelOverrides, classInitFunc func(*EditableLabelClass)) {
	if classInitFunc != nil {
		class := (*EditableLabelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapEditableLabel(obj *coreglib.Object) *EditableLabel {
	return &EditableLabel{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		EditableTextWidget: EditableTextWidget{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalEditableLabel(p uintptr) (interface{}, error) {
	return wrapEditableLabel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEditableLabel creates a new GtkEditableLabel widget.
//
// The function takes the following parameters:
//
//   - str: text for the label.
//
// The function returns the following values:
//
//   - editableLabel: new GtkEditableLabel.
func NewEditableLabel(str string) *EditableLabel {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_editable_label_new(_arg1)
	runtime.KeepAlive(str)

	var _editableLabel *EditableLabel // out

	_editableLabel = wrapEditableLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _editableLabel
}

// Editing returns whether the label is currently in “editing mode”.
//
// The function returns the following values:
//
//   - ok: TRUE if self is currently in editing mode.
func (self *EditableLabel) Editing() bool {
	var _arg0 *C.GtkEditableLabel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_editable_label_get_editing(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartEditing switches the label into “editing mode”.
func (self *EditableLabel) StartEditing() {
	var _arg0 *C.GtkEditableLabel // out

	_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_editable_label_start_editing(_arg0)
	runtime.KeepAlive(self)
}

// StopEditing switches the label out of “editing mode”.
//
// If commit is TRUE, the resulting text is kept as the gtk.Editable:text
// property value, otherwise the resulting text is discarded and the label will
// keep its previous gtk.Editable:text property value.
//
// The function takes the following parameters:
//
//   - commit: whether to set the edited text on the label.
func (self *EditableLabel) StopEditing(commit bool) {
	var _arg0 *C.GtkEditableLabel // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if commit {
		_arg1 = C.TRUE
	}

	C.gtk_editable_label_stop_editing(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(commit)
}

// EmojiChooser: GtkEmojiChooser is used by text widgets such as GtkEntry or
// GtkTextView to let users insert Emoji characters.
//
// !An example GtkEmojiChooser (emojichooser.png)
//
// GtkEmojiChooser emits the gtk.EmojiChooser::emoji-picked signal when an Emoji
// is selected.
//
// CSS nodes
//
//	popover
//	├── box.emoji-searchbar
//	│   ╰── entry.search
//	╰── box.emoji-toolbar
//	    ├── button.image-button.emoji-section
//	    ├── ...
//	    ╰── button.image-button.emoji-section
//
// Every GtkEmojiChooser consists of a main node called popover. The
// contents of the popover are largely implementation defined and supposed
// to inherit general styles. The top searchbar used to search emoji and
// gets the .emoji-searchbar style class itself. The bottom toolbar used to
// switch between different emoji categories consists of buttons with the
// .emoji-section style class and gets the .emoji-toolbar style class itself.
type EmojiChooser struct {
	_ [0]func() // equal guard
	Popover
}

var (
	_ Widgetter         = (*EmojiChooser)(nil)
	_ coreglib.Objector = (*EmojiChooser)(nil)
)

func wrapEmojiChooser(obj *coreglib.Object) *EmojiChooser {
	return &EmojiChooser{
		Popover: Popover{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			NativeSurface: NativeSurface{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
	}
}

func marshalEmojiChooser(p uintptr) (interface{}, error) {
	return wrapEmojiChooser(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEmojiPicked is emitted when the user selects an Emoji.
func (v *EmojiChooser) ConnectEmojiPicked(f func(text string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "emoji-picked", false, unsafe.Pointer(C._gotk4_gtk4_EmojiChooser_ConnectEmojiPicked), f)
}

// NewEmojiChooser creates a new GtkEmojiChooser.
//
// The function returns the following values:
//
//   - emojiChooser: new GtkEmojiChooser.
func NewEmojiChooser() *EmojiChooser {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_emoji_chooser_new()

	var _emojiChooser *EmojiChooser // out

	_emojiChooser = wrapEmojiChooser(coreglib.Take(unsafe.Pointer(_cret)))

	return _emojiChooser
}

// EntryOverrides contains methods that are overridable.
type EntryOverrides struct {
	Activate func()
}

func defaultEntryOverrides(v *Entry) EntryOverrides {
	return EntryOverrides{
		Activate: v.activate,
	}
}

// Entry: GtkEntry is a single line text entry widget.
//
// !An example GtkEntry (entry.png)
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can
// be put into “password mode” using gtk.Entry.SetVisibility(). In this mode,
// entered text is displayed using a “invisible” character. By default,
// GTK picks the best invisible character that is available in the current font,
// but it can be changed with gtk.Entry.SetInvisibleChar().
//
// GtkEntry has the ability to display progress or activity information
// behind the text. To make an entry display such information, use
// gtk.Entry.SetProgressFraction() or gtk.Entry.SetProgressPulseStep().
//
// Additionally, GtkEntry can show icons at either side of the entry.
// These icons can be activatable by clicking, can be set up as drag source
// and can have tooltips. To add an icon, use gtk.Entry.SetIconFromGIcon()
// or one of the various other functions that set an icon from an icon
// name or a paintable. To trigger an action when the user clicks an icon,
// connect to the gtk.Entry::icon-press signal. To allow DND operations from
// an icon, use gtk.Entry.SetIconDragSource(). To set a tooltip on an icon,
// use gtk.Entry.SetIconTooltipText() or the corresponding function for markup.
//
// Note that functionality or information that is only available by clicking
// on an icon in an entry may not be accessible at all to users which are not
// able to use a mouse or other pointing device. It is therefore recommended
// that any such functionality should also be available by other means, e.g.
// via the context menu of the entry.
//
// CSS nodes
//
//	entry[.flat][.warning][.error]
//	├── text[.readonly]
//	├── image.left
//	├── image.right
//	╰── [progress[.pulse]]
//
// GtkEntry has a main node with the name entry. Depending on the properties
// of the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
//
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
//
// When the entry shows progress, it adds a subnode with the name progress.
// The node has the style class .pulse when the shown progress is pulsing.
//
// For all the subnodes added to the text node in various situations, see
// gtk.Text.
//
// # GtkEntry as GtkBuildable
//
// The GtkEntry implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements.
// The <attribute> element has attributes named “name“, “value“, “start“ and
// “end“ and allows you to specify Attribute values for this label.
//
// An example of a UI definition fragment specifying Pango attributes:
//
//	<object class="GtkEnry">
//	  <attributes>
//	    <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
//	    <attribute name="background" value="red" start="5" end="10"/>
//	  </attributes>
//	</object>
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute
// is applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
// # Accessibility
//
// GtkEntry uses the GTK_ACCESSIBLE_ROLE_TEXT_BOX role.
type Entry struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	coreglib.InitiallyUnowned
	Accessible
	Buildable
	CellEditable
	ConstraintTarget
	EditableTextWidget
}

var (
	_ Widgetter         = (*Entry)(nil)
	_ coreglib.Objector = (*Entry)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Entry, *EntryClass, EntryOverrides](
		GTypeEntry,
		initEntryClass,
		wrapEntry,
		defaultEntryOverrides,
	)
}

func initEntryClass(gclass unsafe.Pointer, overrides EntryOverrides, classInitFunc func(*EntryClass)) {
	pclass := (*C.GtkEntryClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeEntry))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_EntryClass_activate)
	}

	if classInitFunc != nil {
		class := (*EntryClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapEntry(obj *coreglib.Object) *Entry {
	return &Entry{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Accessible: Accessible{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
		CellEditable: CellEditable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
		ConstraintTarget: ConstraintTarget{
			Object: obj,
		},
		EditableTextWidget: EditableTextWidget{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalEntry(p uintptr) (interface{}, error) {
	return wrapEntry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when the entry is activated.
//
// The keybindings for this signal are all forms of the Enter key.
func (entry *Entry) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "activate", false, unsafe.Pointer(C._gotk4_gtk4_Entry_ConnectActivate), f)
}

// ConnectIconPress is emitted when an activatable icon is clicked.
func (entry *Entry) ConnectIconPress(f func(iconPos EntryIconPosition)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "icon-press", false, unsafe.Pointer(C._gotk4_gtk4_Entry_ConnectIconPress), f)
}

// ConnectIconRelease is emitted on the button release from a mouse click over
// an activatable icon.
func (entry *Entry) ConnectIconRelease(f func(iconPos EntryIconPosition)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "icon-release", false, unsafe.Pointer(C._gotk4_gtk4_Entry_ConnectIconRelease), f)
}

// NewEntry creates a new entry.
//
// The function returns the following values:
//
//   - entry: new GtkEntry.
func NewEntry() *Entry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_entry_new()

	var _entry *Entry // out

	_entry = wrapEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// NewEntryWithBuffer creates a new entry with the specified text buffer.
//
// The function takes the following parameters:
//
//   - buffer to use for the new GtkEntry.
//
// The function returns the following values:
//
//   - entry: new GtkEntry.
func NewEntryWithBuffer(buffer *EntryBuffer) *Entry {
	var _arg1 *C.GtkEntryBuffer // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_entry_new_with_buffer(_arg1)
	runtime.KeepAlive(buffer)

	var _entry *Entry // out

	_entry = wrapEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _entry
}

// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
//
// The function returns the following values:
//
//   - ok: TRUE if the entry will activate the default widget.
func (entry *Entry) ActivatesDefault() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_activates_default(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Alignment gets the value set by gtk_entry_set_alignment().
//
// See also: gtk.Editable:xalign.
//
// The function returns the following values:
//
//   - gfloat: alignment.
func (entry *Entry) Alignment() float32 {
	var _arg0 *C.GtkEntry // out
	var _cret C.float     // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_alignment(_arg0)
	runtime.KeepAlive(entry)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Attributes gets the attribute list of the GtkEntry.
//
// See gtk.Entry.SetAttributes().
//
// The function returns the following values:
//
//   - attrList (optional): attribute list, or NULL if none was set.
func (entry *Entry) Attributes() *pango.AttrList {
	var _arg0 *C.GtkEntry      // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_attributes(_arg0)
	runtime.KeepAlive(entry)

	var _attrList *pango.AttrList // out

	if _cret != nil {
		_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// Buffer: get the GtkEntryBuffer object which holds the text for this widget.
//
// The function returns the following values:
//
//   - entryBuffer: GtkEntryBuffer object.
func (entry *Entry) Buffer() *EntryBuffer {
	var _arg0 *C.GtkEntry       // out
	var _cret *C.GtkEntryBuffer // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_buffer(_arg0)
	runtime.KeepAlive(entry)

	var _entryBuffer *EntryBuffer // out

	_entryBuffer = wrapEntryBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _entryBuffer
}

// Completion returns the auxiliary completion object currently in use by entry.
//
// The function returns the following values:
//
//   - entryCompletion (optional): auxiliary completion object currently in use
//     by entry.
func (entry *Entry) Completion() *EntryCompletion {
	var _arg0 *C.GtkEntry           // out
	var _cret *C.GtkEntryCompletion // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_completion(_arg0)
	runtime.KeepAlive(entry)

	var _entryCompletion *EntryCompletion // out

	if _cret != nil {
		_entryCompletion = wrapEntryCompletion(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _entryCompletion
}

// CurrentIconDragSource returns the index of the icon which is the source of
// the current DND operation, or -1.
//
// The function returns the following values:
//
//   - gint: index of the icon which is the source of the current DND operation,
//     or -1.
func (entry *Entry) CurrentIconDragSource() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.int       // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_current_icon_drag_source(_arg0)
	runtime.KeepAlive(entry)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ExtraMenu gets the menu model set with gtk_entry_set_extra_menu().
//
// The function returns the following values:
//
//   - menuModel (optional): menu model.
func (entry *Entry) ExtraMenu() gio.MenuModeller {
	var _arg0 *C.GtkEntry   // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_extra_menu(_arg0)
	runtime.KeepAlive(entry)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// HasFrame gets the value set by gtk_entry_set_has_frame().
//
// The function returns the following values:
//
//   - ok: whether the entry has a beveled frame.
func (entry *Entry) HasFrame() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_has_frame(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconActivatable returns whether the icon is activatable.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - ok: TRUE if the icon is activatable.
func (entry *Entry) IconActivatable(iconPos EntryIconPosition) bool {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_activatable(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconArea gets the area where entry’s icon at icon_pos is drawn.
//
// This function is useful when drawing something to the entry in a draw
// callback.
//
// If the entry is not realized or has no icon at the given position, icon_area
// is filled with zeros. Otherwise, icon_area will be filled with the icon's
// allocation, relative to entry's allocation.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - iconArea: return location for the icon’s area.
func (entry *Entry) IconArea(iconPos EntryIconPosition) *gdk.Rectangle {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 C.GdkRectangle         // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	C.gtk_entry_get_icon_area(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _iconArea *gdk.Rectangle // out

	_iconArea = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _iconArea
}

// IconAtPos finds the icon at the given position and return its index.
//
// The position’s coordinates are relative to the entry’s top left corner. If x,
// y doesn’t lie inside an icon, -1 is returned. This function is intended for
// use in a gtk.Widget::query-tooltip signal handler.
//
// The function takes the following parameters:
//
//   - x coordinate of the position to find, relative to entry.
//   - y coordinate of the position to find, relative to entry.
//
// The function returns the following values:
//
//   - gint: index of the icon at the given position, or -1.
func (entry *Entry) IconAtPos(x, y int) int {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.int       // out
	var _arg2 C.int       // out
	var _cret C.int       // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_entry_get_icon_at_pos(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IconGIcon retrieves the GIcon used for the icon.
//
// NULL will be returned if there is no icon or if the icon was set by some
// other method (e.g., by GdkPaintable or icon name).
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - icon (optional): GIcon, or NULL if no icon is set or if the icon is not a
//     GIcon.
func (entry *Entry) IconGIcon(iconPos EntryIconPosition) *gio.Icon {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.GIcon               // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_gicon(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// IconName retrieves the icon name used for the icon.
//
// NULL is returned if there is no icon or if the icon was set by some other
// method (e.g., by GdkPaintable or gicon).
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - utf8 (optional): icon name, or NULL if no icon is set or if the icon
//     wasn’t set from an icon name.
func (entry *Entry) IconName(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_name(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IconPaintable retrieves the GdkPaintable used for the icon.
//
// If no GdkPaintable was used for the icon, NULL is returned.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - paintable (optional): GdkPaintable, or NULL if no icon is set for this
//     position or the icon set is not a GdkPaintable.
func (entry *Entry) IconPaintable(iconPos EntryIconPosition) *gdk.Paintable {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.GdkPaintable        // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_paintable(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _paintable *gdk.Paintable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_paintable = &gdk.Paintable{
				Object: obj,
			}
		}
	}

	return _paintable
}

// IconSensitive returns whether the icon appears sensitive or insensitive.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - ok: TRUE if the icon is sensitive.
func (entry *Entry) IconSensitive(iconPos EntryIconPosition) bool {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.gboolean             // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_sensitive(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconStorageType gets the type of representation being used by the icon to
// store image data.
//
// If the icon has no image data, the return value will be GTK_IMAGE_EMPTY.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - imageType: image representation being used.
func (entry *Entry) IconStorageType(iconPos EntryIconPosition) ImageType {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret C.GtkImageType         // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_storage_type(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _imageType ImageType // out

	_imageType = ImageType(_cret)

	return _imageType
}

// IconTooltipMarkup gets the contents of the tooltip on the icon at the
// specified position in entry.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - utf8 (optional): tooltip text, or NULL. Free the returned string with
//     g_free() when done.
func (entry *Entry) IconTooltipMarkup(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_tooltip_markup(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// IconTooltipText gets the contents of the tooltip on the icon at the specified
// position in entry.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//
// The function returns the following values:
//
//   - utf8 (optional): tooltip text, or NULL. Free the returned string with
//     g_free() when done.
func (entry *Entry) IconTooltipText(iconPos EntryIconPosition) string {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _cret *C.char                // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)

	_cret = C.gtk_entry_get_icon_tooltip_text(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// InputHints gets the input hints of this GtkEntry.
//
// The function returns the following values:
//
//   - inputHints: input hints.
func (entry *Entry) InputHints() InputHints {
	var _arg0 *C.GtkEntry     // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_input_hints(_arg0)
	runtime.KeepAlive(entry)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the input purpose of the GtkEntry.
//
// The function returns the following values:
//
//   - inputPurpose: input purpose.
func (entry *Entry) InputPurpose() InputPurpose {
	var _arg0 *C.GtkEntry       // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_input_purpose(_arg0)
	runtime.KeepAlive(entry)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// InvisibleChar retrieves the character displayed in place of the actual text
// in “password mode”.
//
// The function returns the following values:
//
//   - gunichar: current invisible char, or 0, if the entry does not show
//     invisible text at all.
func (entry *Entry) InvisibleChar() uint32 {
	var _arg0 *C.GtkEntry // out
	var _cret C.gunichar  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_invisible_char(_arg0)
	runtime.KeepAlive(entry)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// MaxLength retrieves the maximum allowed length of the text in entry.
//
// See gtk.Entry.SetMaxLength().
//
// The function returns the following values:
//
//   - gint: maximum allowed number of characters in GtkEntry, or 0 if there is
//     no maximum.
func (entry *Entry) MaxLength() int {
	var _arg0 *C.GtkEntry // out
	var _cret C.int       // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_max_length(_arg0)
	runtime.KeepAlive(entry)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// OverwriteMode gets whether the GtkEntry is in overwrite mode.
//
// The function returns the following values:
//
//   - ok: whether the text is overwritten when typing.
func (entry *Entry) OverwriteMode() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_overwrite_mode(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceholderText retrieves the text that will be displayed when entry is empty
// and unfocused.
//
// The function returns the following values:
//
//   - utf8 (optional): pointer to the placeholder text as a string. This
//     string points to internally allocated storage in the widget and must
//     not be freed, modified or stored. If no placeholder text has been set,
//     NULL will be returned.
func (entry *Entry) PlaceholderText() string {
	var _arg0 *C.GtkEntry // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_placeholder_text(_arg0)
	runtime.KeepAlive(entry)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ProgressFraction returns the current fraction of the task that’s been
// completed.
//
// See gtk.Entry.SetProgressFraction().
//
// The function returns the following values:
//
//   - gdouble: fraction from 0.0 to 1.0.
func (entry *Entry) ProgressFraction() float64 {
	var _arg0 *C.GtkEntry // out
	var _cret C.double    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_progress_fraction(_arg0)
	runtime.KeepAlive(entry)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ProgressPulseStep retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
//
// The function returns the following values:
//
//   - gdouble: fraction from 0.0 to 1.0.
func (entry *Entry) ProgressPulseStep() float64 {
	var _arg0 *C.GtkEntry // out
	var _cret C.double    // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_progress_pulse_step(_arg0)
	runtime.KeepAlive(entry)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Tabs gets the tabstops of the `GtkEntry.
//
// See gtk.Entry.SetTabs().
//
// The function returns the following values:
//
//   - tabArray (optional): tabstops, or NULL if none was set.
func (entry *Entry) Tabs() *pango.TabArray {
	var _arg0 *C.GtkEntry      // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_tabs(_arg0)
	runtime.KeepAlive(entry)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tabArray
}

// TextLength retrieves the current length of the text in entry.
//
// This is equivalent to getting entry's GtkEntryBuffer and calling
// gtk.EntryBuffer.GetLength() on it.
//
// The function returns the following values:
//
//   - guint16: current number of characters in GtkEntry, or 0 if there are
//     none.
func (entry *Entry) TextLength() uint16 {
	var _arg0 *C.GtkEntry // out
	var _cret C.guint16   // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_text_length(_arg0)
	runtime.KeepAlive(entry)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// Visibility retrieves whether the text in entry is visible.
//
// See gtk.Entry.SetVisibility().
//
// The function returns the following values:
//
//   - ok: TRUE if the text is currently visible.
func (entry *Entry) Visibility() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_get_visibility(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GrabFocusWithoutSelecting causes entry to have keyboard focus.
//
// It behaves like gtk.Widget.GrabFocus(), except that it doesn't select
// the contents of the entry. You only want to call this on some special
// entries which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
//
// The function returns the following values:
//
//   - ok: TRUE if focus is now inside self.
func (entry *Entry) GrabFocusWithoutSelecting() bool {
	var _arg0 *C.GtkEntry // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_entry_grab_focus_without_selecting(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ProgressPulse indicates that some progress is made, but you don’t know how
// much.
//
// Causes the entry’s progress indicator to enter “activity mode”, where a block
// bounces back and forth. Each call to gtk_entry_progress_pulse() causes the
// block to move by a little bit (the amount of movement per pulse is determined
// by gtk.Entry.SetProgressPulseStep()).
func (entry *Entry) ProgressPulse() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C.gtk_entry_progress_pulse(_arg0)
	runtime.KeepAlive(entry)
}

// ResetIMContext: reset the input method context of the entry if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (entry *Entry) ResetIMContext() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C.gtk_entry_reset_im_context(_arg0)
	runtime.KeepAlive(entry)
}

// SetActivatesDefault sets whether pressing Enter in the entry will activate
// the default widget for the window containing the entry.
//
// This usually means that the dialog containing the entry will be closed,
// since the default widget is usually one of the dialog buttons.
//
// The function takes the following parameters:
//
//   - setting: TRUE to activate window’s default widget on Enter keypress.
func (entry *Entry) SetActivatesDefault(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_activates_default(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(setting)
}

// SetAlignment sets the alignment for the contents of the entry.
//
// This controls the horizontal positioning of the contents when the displayed
// text is shorter than the width of the entry.
//
// See also: gtk.Editable:xalign.
//
// The function takes the following parameters:
//
//   - xalign: horizontal alignment, from 0 (left) to 1 (right). Reversed for
//     RTL layouts.
func (entry *Entry) SetAlignment(xalign float32) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.float(xalign)

	C.gtk_entry_set_alignment(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(xalign)
}

// SetAttributes sets a PangoAttrList.
//
// The attributes in the list are applied to the entry text.
//
// Since the attributes will be applies to text that changes as the user types,
// it makes most sense to use attributes with unlimited extent.
//
// The function takes the following parameters:
//
//   - attrs: PangoAttrList.
func (entry *Entry) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkEntry      // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))

	C.gtk_entry_set_attributes(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(attrs)
}

// SetBuffer: set the GtkEntryBuffer object which holds the text for this
// widget.
//
// The function takes the following parameters:
//
//   - buffer: GtkEntryBuffer.
func (entry *Entry) SetBuffer(buffer *EntryBuffer) {
	var _arg0 *C.GtkEntry       // out
	var _arg1 *C.GtkEntryBuffer // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_entry_set_buffer(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(buffer)
}

// SetCompletion sets completion to be the auxiliary completion object to use
// with entry.
//
// All further configuration of the completion mechanism is done on completion
// using the GtkEntryCompletion API. Completion is disabled if completion is set
// to NULL.
//
// The function takes the following parameters:
//
//   - completion (optional): GtkEntryCompletion or NULL.
func (entry *Entry) SetCompletion(completion *EntryCompletion) {
	var _arg0 *C.GtkEntry           // out
	var _arg1 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if completion != nil {
		_arg1 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	}

	C.gtk_entry_set_completion(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(completion)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// entry.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel.
func (entry *Entry) SetExtraMenu(model gio.MenuModeller) {
	var _arg0 *C.GtkEntry   // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_entry_set_extra_menu(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(model)
}

// SetHasFrame sets whether the entry has a beveled frame around it.
//
// The function takes the following parameters:
//
//   - setting: new value.
func (entry *Entry) SetHasFrame(setting bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_has_frame(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(setting)
}

// SetIconActivatable sets whether the icon is activatable.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//   - activatable: TRUE if the icon should be activatable.
func (entry *Entry) SetIconActivatable(iconPos EntryIconPosition, activatable bool) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 C.gboolean             // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	if activatable {
		_arg2 = C.TRUE
	}

	C.gtk_entry_set_icon_activatable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(activatable)
}

// SetIconDragSource sets up the icon at the given position as drag source.
//
// This makes it so that GTK will start a drag operation when the user clicks
// and drags the icon.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//   - provider: ContentProvider.
//   - actions: bitmask of the allowed drag actions.
func (entry *Entry) SetIconDragSource(iconPos EntryIconPosition, provider *gdk.ContentProvider, actions gdk.DragAction) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GdkContentProvider  // out
	var _arg3 C.GdkDragAction        // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	_arg2 = (*C.GdkContentProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg3 = C.GdkDragAction(actions)

	C.gtk_entry_set_icon_drag_source(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(actions)
}

// SetIconFromGIcon sets the icon shown in the entry at the specified position
// from the current icon theme.
//
// If the icon isn’t known, a “broken image” icon will be displayed instead.
//
// If icon is NULL, no icon will be shown in the specified position.
//
// The function takes the following parameters:
//
//   - iconPos: position at which to set the icon.
//   - icon (optional) to set, or NULL.
func (entry *Entry) SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Iconner) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GIcon               // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	if icon != nil {
		_arg2 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	}

	C.gtk_entry_set_icon_from_gicon(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(icon)
}

// SetIconFromIconName sets the icon shown in the entry at the specified
// position from the current icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead.
//
// If icon_name is NULL, no icon will be shown in the specified position.
//
// The function takes the following parameters:
//
//   - iconPos: position at which to set the icon.
//   - iconName (optional): icon name, or NULL.
func (entry *Entry) SetIconFromIconName(iconPos EntryIconPosition, iconName string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.char                // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	if iconName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_entry_set_icon_from_icon_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(iconName)
}

// SetIconFromPaintable sets the icon shown in the specified position using a
// GdkPaintable.
//
// If paintable is NULL, no icon will be shown in the specified position.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//   - paintable (optional): GdkPaintable, or NULL.
func (entry *Entry) SetIconFromPaintable(iconPos EntryIconPosition, paintable gdk.Paintabler) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.GdkPaintable        // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	if paintable != nil {
		_arg2 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	}

	C.gtk_entry_set_icon_from_paintable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(paintable)
}

// SetIconSensitive sets the sensitivity for the specified icon.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//   - sensitive specifies whether the icon should appear sensitive or
//     insensitive.
func (entry *Entry) SetIconSensitive(iconPos EntryIconPosition, sensitive bool) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 C.gboolean             // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	if sensitive {
		_arg2 = C.TRUE
	}

	C.gtk_entry_set_icon_sensitive(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(sensitive)
}

// SetIconTooltipMarkup sets tooltip as the contents of the tooltip for the icon
// at the specified position.
//
// tooltip is assumed to be marked up with Pango Markup.
//
// Use NULL for tooltip to remove an existing tooltip.
//
// See also gtk.Widget.SetTooltipMarkup() and gtk.Entry.SetIconTooltipText().
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//   - tooltip (optional) contents of the tooltip for the icon, or NULL.
func (entry *Entry) SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.char                // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	if tooltip != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(tooltip)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_entry_set_icon_tooltip_markup(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(tooltip)
}

// SetIconTooltipText sets tooltip as the contents of the tooltip for the icon
// at the specified position.
//
// Use NULL for tooltip to remove an existing tooltip.
//
// See also gtk.Widget.SetTooltipText() and gtk.Entry.SetIconTooltipMarkup().
//
// If you unset the widget tooltip via gtk.Widget.SetTooltipText() or
// gtk.Widget.SetTooltipMarkup(), this sets gtk.Widget:has-tooltip to FALSE,
// which suppresses icon tooltips too. You can resolve this by then calling
// gtk.Widget.SetHasTooltip() to set gtk.Widget:has-tooltip back to TRUE, or
// setting at least one non-empty tooltip on any icon achieves the same result.
//
// The function takes the following parameters:
//
//   - iconPos: icon position.
//   - tooltip (optional) contents of the tooltip for the icon, or NULL.
func (entry *Entry) SetIconTooltipText(iconPos EntryIconPosition, tooltip string) {
	var _arg0 *C.GtkEntry            // out
	var _arg1 C.GtkEntryIconPosition // out
	var _arg2 *C.char                // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkEntryIconPosition(iconPos)
	if tooltip != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(tooltip)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_entry_set_icon_tooltip_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(iconPos)
	runtime.KeepAlive(tooltip)
}

// SetInputHints: set additional hints which allow input methods to fine-tune
// their behavior.
//
// The function takes the following parameters:
//
//   - hints: hints.
func (entry *Entry) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkEntry     // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkInputHints(hints)

	C.gtk_entry_set_input_hints(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(hints)
}

// SetInputPurpose sets the input purpose which can be used by input methods to
// adjust their behavior.
//
// The function takes the following parameters:
//
//   - purpose: purpose.
func (entry *Entry) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkEntry       // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.GtkInputPurpose(purpose)

	C.gtk_entry_set_input_purpose(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(purpose)
}

// SetInvisibleChar sets the character to use in place of the actual text in
// “password mode”.
//
// See gtk.Entry.SetVisibility() for how to enable “password mode”.
//
// By default, GTK picks the best invisible char available in the current font.
// If you set the invisible char to 0, then the user will get no feedback at
// all; there will be no text on the screen as they type.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
func (entry *Entry) SetInvisibleChar(ch uint32) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gunichar  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.gunichar(ch)

	C.gtk_entry_set_invisible_char(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(ch)
}

// SetMaxLength sets the maximum allowed length of the contents of the widget.
//
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// This is equivalent to getting entry's GtkEntryBuffer and calling
// gtk.EntryBuffer.SetMaxLength() on it.
//
// The function takes the following parameters:
//
//   - max: maximum length of the entry, or 0 for no maximum. (other than the
//     maximum length of entries.) The value passed in will be clamped to the
//     range 0-65536.
func (entry *Entry) SetMaxLength(max int) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.int(max)

	C.gtk_entry_set_max_length(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(max)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// GtkEntry.
//
// The function takes the following parameters:
//
//   - overwrite: new value.
func (entry *Entry) SetOverwriteMode(overwrite bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_overwrite_mode(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(overwrite)
}

// SetPlaceholderText sets text to be displayed in entry when it is empty.
//
// This can be used to give a visual hint of the expected contents of the
// GtkEntry.
//
// The function takes the following parameters:
//
//   - text (optional): string to be displayed when entry is empty and
//     unfocused, or NULL.
func (entry *Entry) SetPlaceholderText(text string) {
	var _arg0 *C.GtkEntry // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_entry_set_placeholder_text(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(text)
}

// SetProgressFraction causes the entry’s progress indicator to “fill in” the
// given fraction of the bar.
//
// The fraction should be between 0.0 and 1.0, inclusive.
//
// The function takes the following parameters:
//
//   - fraction of the task that’s been completed.
func (entry *Entry) SetProgressFraction(fraction float64) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.double(fraction)

	C.gtk_entry_set_progress_fraction(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(fraction)
}

// SetProgressPulseStep sets the fraction of total entry width to move the
// progress bouncing block for each pulse.
//
// Use gtk.Entry.ProgressPulse() to pulse the progress.
//
// The function takes the following parameters:
//
//   - fraction between 0.0 and 1.0.
func (entry *Entry) SetProgressPulseStep(fraction float64) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	_arg1 = C.double(fraction)

	C.gtk_entry_set_progress_pulse_step(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(fraction)
}

// SetTabs sets a PangoTabArray.
//
// The tabstops in the array are applied to the entry text.
//
// The function takes the following parameters:
//
//   - tabs (optional): PangoTabArray.
func (entry *Entry) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkEntry      // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if tabs != nil {
		_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))
	}

	C.gtk_entry_set_tabs(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(tabs)
}

// SetVisibility sets whether the contents of the entry are visible or not.
//
// When visibility is set to FALSE, characters are displayed as the invisible
// char, and will also appear that way when the text in the entry widget is
// copied elsewhere.
//
// By default, GTK picks the best invisible character available in the current
// font, but it can be changed with gtk.Entry.SetInvisibleChar().
//
// Note that you probably want to set gtk.Entry:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this entry, in addition to setting visibility to FALSE.
//
// The function takes the following parameters:
//
//   - visible: TRUE if the contents of the entry are displayed as plaintext.
func (entry *Entry) SetVisibility(visible bool) {
	var _arg0 *C.GtkEntry // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_entry_set_visibility(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(visible)
}

// UnsetInvisibleChar unsets the invisible char, so that the default invisible
// char is used again. See gtk.Entry.SetInvisibleChar().
func (entry *Entry) UnsetInvisibleChar() {
	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C.gtk_entry_unset_invisible_char(_arg0)
	runtime.KeepAlive(entry)
}

func (entry *Entry) activate() {
	gclass := (*C.GtkEntryClass)(coreglib.PeekParentClass(entry))
	fnarg := gclass.activate

	var _arg0 *C.GtkEntry // out

	_arg0 = (*C.GtkEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C._gotk4_gtk4_Entry_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(entry)
}

// EntryBufferOverrides contains methods that are overridable.
type EntryBufferOverrides struct {
	// DeleteText deletes a sequence of characters from the buffer.
	//
	// n_chars characters are deleted starting at position. If n_chars is
	// negative, then all characters until the end of the text are deleted.
	//
	// If position or n_chars are out of bounds, then they are coerced to sane
	// values.
	//
	// Note that the positions are specified in characters, not bytes.
	//
	// The function takes the following parameters:
	//
	//   - position at which to delete text.
	//   - nChars: number of characters to delete.
	//
	// The function returns the following values:
	//
	//   - guint: number of characters deleted.
	DeleteText func(position, nChars uint) uint
	// The function takes the following parameters:
	//
	//   - position
	//   - nChars
	DeletedText func(position, nChars uint)
	// Length retrieves the length in characters of the buffer.
	//
	// The function returns the following values:
	//
	//   - guint: number of characters in the buffer.
	Length func() uint
	Text   func(nBytes *uint) string
	// InsertText inserts n_chars characters of chars into the contents of the
	// buffer, at position position.
	//
	// If n_chars is negative, then characters from chars will be inserted until
	// a null-terminator is found. If position or n_chars are out of bounds,
	// or the maximum buffer text length is exceeded, then they are coerced to
	// sane values.
	//
	// Note that the position and length are in characters, not in bytes.
	//
	// The function takes the following parameters:
	//
	//   - position at which to insert text.
	//   - chars: text to insert into the buffer.
	//   - nChars: length of the text in characters, or -1.
	//
	// The function returns the following values:
	//
	//   - guint: number of characters actually inserted.
	InsertText func(position uint, chars string, nChars uint) uint
	// The function takes the following parameters:
	//
	//   - position
	//   - chars
	//   - nChars
	InsertedText func(position uint, chars string, nChars uint)
}

func defaultEntryBufferOverrides(v *EntryBuffer) EntryBufferOverrides {
	return EntryBufferOverrides{
		DeleteText:   v.deleteText,
		DeletedText:  v.deletedText,
		Length:       v.length,
		Text:         v.text,
		InsertText:   v.insertText,
		InsertedText: v.insertedText,
	}
}

// EntryBuffer: GtkEntryBuffer hold the text displayed in a GtkText widget.
//
// A single GtkEntryBuffer object can be shared by multiple widgets which will
// then share the same text content, but not the cursor position, visibility
// attributes, icon etc.
//
// GtkEntryBuffer may be derived from. Such a derived class might allow text to
// be stored in an alternate location, such as non-pageable memory, useful in
// the case of important passwords. Or a derived class could integrate with an
// application’s concept of undo/redo.
type EntryBuffer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*EntryBuffer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*EntryBuffer, *EntryBufferClass, EntryBufferOverrides](
		GTypeEntryBuffer,
		initEntryBufferClass,
		wrapEntryBuffer,
		defaultEntryBufferOverrides,
	)
}

func initEntryBufferClass(gclass unsafe.Pointer, overrides EntryBufferOverrides, classInitFunc func(*EntryBufferClass)) {
	pclass := (*C.GtkEntryBufferClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeEntryBuffer))))

	if overrides.DeleteText != nil {
		pclass.delete_text = (*[0]byte)(C._gotk4_gtk4_EntryBufferClass_delete_text)
	}

	if overrides.DeletedText != nil {
		pclass.deleted_text = (*[0]byte)(C._gotk4_gtk4_EntryBufferClass_deleted_text)
	}

	if overrides.Length != nil {
		pclass.get_length = (*[0]byte)(C._gotk4_gtk4_EntryBufferClass_get_length)
	}

	if overrides.Text != nil {
		pclass.get_text = (*[0]byte)(C._gotk4_gtk4_EntryBufferClass_get_text)
	}

	if overrides.InsertText != nil {
		pclass.insert_text = (*[0]byte)(C._gotk4_gtk4_EntryBufferClass_insert_text)
	}

	if overrides.InsertedText != nil {
		pclass.inserted_text = (*[0]byte)(C._gotk4_gtk4_EntryBufferClass_inserted_text)
	}

	if classInitFunc != nil {
		class := (*EntryBufferClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapEntryBuffer(obj *coreglib.Object) *EntryBuffer {
	return &EntryBuffer{
		Object: obj,
	}
}

func marshalEntryBuffer(p uintptr) (interface{}, error) {
	return wrapEntryBuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDeletedText: text is altered in the default handler for this signal.
//
// If you want access to the text after the text has been modified, use
// G_CONNECT_AFTER.
func (buffer *EntryBuffer) ConnectDeletedText(f func(position, nChars uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "deleted-text", false, unsafe.Pointer(C._gotk4_gtk4_EntryBuffer_ConnectDeletedText), f)
}

// ConnectInsertedText: this signal is emitted after text is inserted into the
// buffer.
func (buffer *EntryBuffer) ConnectInsertedText(f func(position uint, chars string, nChars uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "inserted-text", false, unsafe.Pointer(C._gotk4_gtk4_EntryBuffer_ConnectInsertedText), f)
}

// NewEntryBuffer: create a new GtkEntryBuffer object.
//
// Optionally, specify initial text to set in the buffer.
//
// The function takes the following parameters:
//
//   - initialChars (optional): initial buffer text, or NULL.
//   - nInitialChars: number of characters in initial_chars, or -1.
//
// The function returns the following values:
//
//   - entryBuffer: new GtkEntryBuffer object.
func NewEntryBuffer(initialChars string, nInitialChars int) *EntryBuffer {
	var _arg1 *C.char           // out
	var _arg2 C.int             // out
	var _cret *C.GtkEntryBuffer // in

	if initialChars != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(initialChars)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = C.int(nInitialChars)

	_cret = C.gtk_entry_buffer_new(_arg1, _arg2)
	runtime.KeepAlive(initialChars)
	runtime.KeepAlive(nInitialChars)

	var _entryBuffer *EntryBuffer // out

	_entryBuffer = wrapEntryBuffer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryBuffer
}

// DeleteText deletes a sequence of characters from the buffer.
//
// n_chars characters are deleted starting at position. If n_chars is negative,
// then all characters until the end of the text are deleted.
//
// If position or n_chars are out of bounds, then they are coerced to sane
// values.
//
// Note that the positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - position at which to delete text.
//   - nChars: number of characters to delete.
//
// The function returns the following values:
//
//   - guint: number of characters deleted.
func (buffer *EntryBuffer) DeleteText(position uint, nChars int) uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.int             // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.int(nChars)

	_cret = C.gtk_entry_buffer_delete_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nChars)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// EmitDeletedText: used when subclassing GtkEntryBuffer.
//
// The function takes the following parameters:
//
//   - position at which text was deleted.
//   - nChars: number of characters deleted.
func (buffer *EntryBuffer) EmitDeletedText(position, nChars uint) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nChars)

	C.gtk_entry_buffer_emit_deleted_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nChars)
}

// EmitInsertedText: used when subclassing GtkEntryBuffer.
//
// The function takes the following parameters:
//
//   - position at which text was inserted.
//   - chars: text that was inserted.
//   - nChars: number of characters inserted.
func (buffer *EntryBuffer) EmitInsertedText(position uint, chars string, nChars uint) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.char           // out
	var _arg3 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(chars)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(nChars)

	C.gtk_entry_buffer_emit_inserted_text(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(chars)
	runtime.KeepAlive(nChars)
}

// Bytes retrieves the length in bytes of the buffer.
//
// See gtk.EntryBuffer.GetLength().
//
// The function returns the following values:
//
//   - gsize: byte length of the buffer.
func (buffer *EntryBuffer) Bytes() uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.gsize           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_entry_buffer_get_bytes(_arg0)
	runtime.KeepAlive(buffer)

	var _gsize uint // out

	_gsize = uint(_cret)

	return _gsize
}

// Length retrieves the length in characters of the buffer.
//
// The function returns the following values:
//
//   - guint: number of characters in the buffer.
func (buffer *EntryBuffer) Length() uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_entry_buffer_get_length(_arg0)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MaxLength retrieves the maximum allowed length of the text in buffer.
//
// The function returns the following values:
//
//   - gint: maximum allowed number of characters in EntryBuffer, or 0 if there
//     is no maximum.
func (buffer *EntryBuffer) MaxLength() int {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.int             // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_entry_buffer_get_max_length(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Text retrieves the contents of the buffer.
//
// The memory pointer returned by this call will not change unless this object
// emits a signal, or is finalized.
//
// The function returns the following values:
//
//   - utf8: pointer to the contents of the widget as a string. This string
//     points to internally allocated storage in the buffer and must not be
//     freed, modified or stored.
func (buffer *EntryBuffer) Text() string {
	var _arg0 *C.GtkEntryBuffer // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_entry_buffer_get_text(_arg0)
	runtime.KeepAlive(buffer)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// InsertText inserts n_chars characters of chars into the contents of the
// buffer, at position position.
//
// If n_chars is negative, then characters from chars will be inserted until a
// null-terminator is found. If position or n_chars are out of bounds, or the
// maximum buffer text length is exceeded, then they are coerced to sane values.
//
// Note that the position and length are in characters, not in bytes.
//
// The function takes the following parameters:
//
//   - position at which to insert text.
//   - chars: text to insert into the buffer.
//   - nChars: length of the text in characters, or -1.
//
// The function returns the following values:
//
//   - guint: number of characters actually inserted.
func (buffer *EntryBuffer) InsertText(position uint, chars string, nChars int) uint {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.char           // out
	var _arg3 C.int             // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(chars)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(nChars)

	_cret = C.gtk_entry_buffer_insert_text(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(chars)
	runtime.KeepAlive(nChars)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetMaxLength sets the maximum allowed length of the contents of the buffer.
//
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// The function takes the following parameters:
//
//   - maxLength: maximum length of the entry buffer, or 0 for no maximum.
//     (other than the maximum length of entries.) The value passed in will be
//     clamped to the range 0-65536.
func (buffer *EntryBuffer) SetMaxLength(maxLength int) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.int             // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.int(maxLength)

	C.gtk_entry_buffer_set_max_length(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(maxLength)
}

// SetText sets the text in the buffer.
//
// This is roughly equivalent to calling gtk.EntryBuffer.DeleteText() and
// gtk.EntryBuffer.InsertText().
//
// Note that n_chars is in characters, not in bytes.
//
// The function takes the following parameters:
//
//   - chars: new text.
//   - nChars: number of characters in text, or -1.
func (buffer *EntryBuffer) SetText(chars string, nChars int) {
	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 *C.char           // out
	var _arg2 C.int             // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(chars)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(nChars)

	C.gtk_entry_buffer_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(chars)
	runtime.KeepAlive(nChars)
}

// deleteText deletes a sequence of characters from the buffer.
//
// n_chars characters are deleted starting at position. If n_chars is negative,
// then all characters until the end of the text are deleted.
//
// If position or n_chars are out of bounds, then they are coerced to sane
// values.
//
// Note that the positions are specified in characters, not bytes.
//
// The function takes the following parameters:
//
//   - position at which to delete text.
//   - nChars: number of characters to delete.
//
// The function returns the following values:
//
//   - guint: number of characters deleted.
func (buffer *EntryBuffer) deleteText(position, nChars uint) uint {
	gclass := (*C.GtkEntryBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.delete_text

	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.guint           // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nChars)

	_cret = C._gotk4_gtk4_EntryBuffer_virtual_delete_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nChars)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//   - position
//   - nChars
func (buffer *EntryBuffer) deletedText(position, nChars uint) {
	gclass := (*C.GtkEntryBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.deleted_text

	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nChars)

	C._gotk4_gtk4_EntryBuffer_virtual_deleted_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nChars)
}

// Length retrieves the length in characters of the buffer.
//
// The function returns the following values:
//
//   - guint: number of characters in the buffer.
func (buffer *EntryBuffer) length() uint {
	gclass := (*C.GtkEntryBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.get_length

	var _arg0 *C.GtkEntryBuffer // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C._gotk4_gtk4_EntryBuffer_virtual_get_length(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

func (buffer *EntryBuffer) text(nBytes *uint) string {
	gclass := (*C.GtkEntryBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.get_text

	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 *C.gsize          // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.gsize)(unsafe.Pointer(nBytes))

	_cret = C._gotk4_gtk4_EntryBuffer_virtual_get_text(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(nBytes)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// insertText inserts n_chars characters of chars into the contents of the
// buffer, at position position.
//
// If n_chars is negative, then characters from chars will be inserted until a
// null-terminator is found. If position or n_chars are out of bounds, or the
// maximum buffer text length is exceeded, then they are coerced to sane values.
//
// Note that the position and length are in characters, not in bytes.
//
// The function takes the following parameters:
//
//   - position at which to insert text.
//   - chars: text to insert into the buffer.
//   - nChars: length of the text in characters, or -1.
//
// The function returns the following values:
//
//   - guint: number of characters actually inserted.
func (buffer *EntryBuffer) insertText(position uint, chars string, nChars uint) uint {
	gclass := (*C.GtkEntryBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.insert_text

	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.char           // out
	var _arg3 C.guint           // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(chars)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(nChars)

	_cret = C._gotk4_gtk4_EntryBuffer_virtual_insert_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(chars)
	runtime.KeepAlive(nChars)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// The function takes the following parameters:
//
//   - position
//   - chars
//   - nChars
func (buffer *EntryBuffer) insertedText(position uint, chars string, nChars uint) {
	gclass := (*C.GtkEntryBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.inserted_text

	var _arg0 *C.GtkEntryBuffer // out
	var _arg1 C.guint           // out
	var _arg2 *C.char           // out
	var _arg3 C.guint           // out

	_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(position)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(chars)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint(nChars)

	C._gotk4_gtk4_EntryBuffer_virtual_inserted_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(position)
	runtime.KeepAlive(chars)
	runtime.KeepAlive(nChars)
}

// EntryCompletion: GtkEntryCompletion is an auxiliary object to provide
// completion functionality for GtkEntry.
//
// It implements the gtk.CellLayout interface, to allow the user to add extra
// cells to the GtkTreeView with completion matches.
//
// “Completion functionality” means that when the user modifies the text in
// the entry, GtkEntryCompletion checks which rows in the model match the
// current content of the entry, and displays a list of matches. By default,
// the matching is done by comparing the entry text case-insensitively against
// the text column of the model (see gtk.EntryCompletion.SetTextColumn()),
// but this can be overridden with a custom match function (see
// gtk.EntryCompletion.SetMatchFunc()).
//
// When the user selects a completion, the content of the entry is updated.
// By default, the content of the entry is replaced by the text column
// of the model, but this can be overridden by connecting to the
// gtk.EntryCompletion::match-selected signal and updating the entry in the
// signal handler. Note that you should return TRUE from the signal handler to
// suppress the default behaviour.
//
// To add completion functionality to an entry, use gtk.Entry.SetCompletion().
//
// GtkEntryCompletion uses a gtk.TreeModelFilter model to represent
// the subset of the entire model that is currently matching. While the
// GtkEntryCompletion signals gtk.EntryCompletion::match-selected and
// gtk.EntryCompletion::cursor-on-match take the original model and an iter
// pointing to that model as arguments, other callbacks and signals (such as
// GtkCellLayoutDataFunc or gtk.CellArea::apply-attributes) will generally
// take the filter model as argument. As long as you are only calling
// gtk.TreeModel.Get(), this will make no difference to you. If for some reason,
// you need the original model, use gtk.TreeModelFilter.GetModel(). Don’t forget
// to use gtk.TreeModelFilter.ConvertIterToChildIter() to obtain a matching
// iter.
type EntryCompletion struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
	CellLayout
}

var (
	_ coreglib.Objector = (*EntryCompletion)(nil)
)

func wrapEntryCompletion(obj *coreglib.Object) *EntryCompletion {
	return &EntryCompletion{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		CellLayout: CellLayout{
			Object: obj,
		},
	}
}

func marshalEntryCompletion(p uintptr) (interface{}, error) {
	return wrapEntryCompletion(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCursorOnMatch is emitted when a match from the cursor is on a match of
// the list.
//
// The default behaviour is to replace the contents of the entry with the
// contents of the text column in the row pointed to by iter.
//
// Note that model is the model that was passed to
// gtk.EntryCompletion.SetModel().
func (completion *EntryCompletion) ConnectCursorOnMatch(f func(model TreeModeller, iter *TreeIter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "cursor-on-match", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectCursorOnMatch), f)
}

// ConnectInsertPrefix is emitted when the inline autocompletion is triggered.
//
// The default behaviour is to make the entry display the whole prefix and
// select the newly inserted part.
//
// Applications may connect to this signal in order to insert only a smaller
// part of the prefix into the entry - e.g. the entry used in the FileChooser
// inserts only the part of the prefix up to the next '/'.
func (completion *EntryCompletion) ConnectInsertPrefix(f func(prefix string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "insert-prefix", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectInsertPrefix), f)
}

// ConnectMatchSelected is emitted when a match from the list is selected.
//
// The default behaviour is to replace the contents of the entry with the
// contents of the text column in the row pointed to by iter.
//
// Note that model is the model that was passed to
// gtk.EntryCompletion.SetModel().
func (completion *EntryCompletion) ConnectMatchSelected(f func(model TreeModeller, iter *TreeIter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "match-selected", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectMatchSelected), f)
}

// ConnectNoMatches is emitted when the filter model has zero number of rows in
// completion_complete method.
//
// In other words when GtkEntryCompletion is out of suggestions.
func (completion *EntryCompletion) ConnectNoMatches(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(completion, "no-matches", false, unsafe.Pointer(C._gotk4_gtk4_EntryCompletion_ConnectNoMatches), f)
}

// NewEntryCompletion creates a new GtkEntryCompletion object.
//
// The function returns the following values:
//
//   - entryCompletion: newly created GtkEntryCompletion object.
func NewEntryCompletion() *EntryCompletion {
	var _cret *C.GtkEntryCompletion // in

	_cret = C.gtk_entry_completion_new()

	var _entryCompletion *EntryCompletion // out

	_entryCompletion = wrapEntryCompletion(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// NewEntryCompletionWithArea creates a new GtkEntryCompletion object using the
// specified area.
//
// The GtkCellArea is used to layout cells in the underlying GtkTreeViewColumn
// for the drop-down menu.
//
// The function takes the following parameters:
//
//   - area used to layout cells.
//
// The function returns the following values:
//
//   - entryCompletion: newly created GtkEntryCompletion object.
func NewEntryCompletionWithArea(area CellAreaer) *EntryCompletion {
	var _arg1 *C.GtkCellArea        // out
	var _cret *C.GtkEntryCompletion // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_entry_completion_new_with_area(_arg1)
	runtime.KeepAlive(area)

	var _entryCompletion *EntryCompletion // out

	_entryCompletion = wrapEntryCompletion(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _entryCompletion
}

// Complete requests a completion operation, or in other words a refiltering of
// the current list with completions, using the current key.
//
// The completion list view will be updated accordingly.
func (completion *EntryCompletion) Complete() {
	var _arg0 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C.gtk_entry_completion_complete(_arg0)
	runtime.KeepAlive(completion)
}

// ComputePrefix computes the common prefix that is shared by all rows in
// completion that start with key.
//
// If no row matches key, NULL will be returned. Note that a
// text column must have been set for this function to work, see
// gtk.EntryCompletion.SetTextColumn() for details.
//
// The function takes the following parameters:
//
//   - key: text to complete for.
//
// The function returns the following values:
//
//   - utf8 (optional): common prefix all rows starting with key or NULL if no
//     row matches key.
func (completion *EntryCompletion) ComputePrefix(key string) string {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 *C.char               // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_entry_completion_compute_prefix(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(key)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// CompletionPrefix: get the original text entered by the user that triggered
// the completion or NULL if there’s no completion ongoing.
//
// The function returns the following values:
//
//   - utf8 (optional): prefix for the current completion.
func (completion *EntryCompletion) CompletionPrefix() string {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_completion_prefix(_arg0)
	runtime.KeepAlive(completion)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Entry gets the entry completion has been attached to.
//
// The function returns the following values:
//
//   - widget: entry completion has been attached to.
func (completion *EntryCompletion) Entry() Widgetter {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_entry(_arg0)
	runtime.KeepAlive(completion)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
//
// The function returns the following values:
//
//   - ok: TRUE if inline completion is turned on.
func (completion *EntryCompletion) InlineCompletion() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_inline_completion(_arg0)
	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InlineSelection returns TRUE if inline-selection mode is turned on.
//
// The function returns the following values:
//
//   - ok: TRUE if inline-selection mode is on.
func (completion *EntryCompletion) InlineSelection() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_inline_selection(_arg0)
	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MinimumKeyLength returns the minimum key length as set for completion.
//
// The function returns the following values:
//
//   - gint: currently used minimum key length.
func (completion *EntryCompletion) MinimumKeyLength() int {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_minimum_key_length(_arg0)
	runtime.KeepAlive(completion)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Model returns the model the GtkEntryCompletion is using as data source.
//
// Returns NULL if the model is unset.
//
// The function returns the following values:
//
//   - treeModel (optional) or NULL if none is currently being used.
func (completion *EntryCompletion) Model() *TreeModel {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_model(_arg0)
	runtime.KeepAlive(completion)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// PopupCompletion returns whether the completions should be presented in a
// popup window.
//
// The function returns the following values:
//
//   - ok: TRUE if popup completion is turned on.
func (completion *EntryCompletion) PopupCompletion() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_popup_completion(_arg0)
	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopupSetWidth returns whether the completion popup window will be resized to
// the width of the entry.
//
// The function returns the following values:
//
//   - ok: TRUE if the popup window will be resized to the width of the entry.
func (completion *EntryCompletion) PopupSetWidth() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_popup_set_width(_arg0)
	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PopupSingleMatch returns whether the completion popup window will appear even
// if there is only a single match.
//
// The function returns the following values:
//
//   - ok: TRUE if the popup window will appear regardless of the number of
//     matches.
func (completion *EntryCompletion) PopupSingleMatch() bool {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_popup_single_match(_arg0)
	runtime.KeepAlive(completion)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextColumn returns the column in the model of completion to get strings from.
//
// The function returns the following values:
//
//   - gint: column containing the strings.
func (completion *EntryCompletion) TextColumn() int {
	var _arg0 *C.GtkEntryCompletion // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	_cret = C.gtk_entry_completion_get_text_column(_arg0)
	runtime.KeepAlive(completion)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InsertPrefix requests a prefix insertion.
func (completion *EntryCompletion) InsertPrefix() {
	var _arg0 *C.GtkEntryCompletion // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))

	C.gtk_entry_completion_insert_prefix(_arg0)
	runtime.KeepAlive(completion)
}

// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
//
// The function takes the following parameters:
//
//   - inlineCompletion: TRUE to do inline completion.
func (completion *EntryCompletion) SetInlineCompletion(inlineCompletion bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if inlineCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_completion(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(inlineCompletion)
}

// SetInlineSelection sets whether it is possible to cycle through the possible
// completions inside the entry.
//
// The function takes the following parameters:
//
//   - inlineSelection: TRUE to do inline selection.
func (completion *EntryCompletion) SetInlineSelection(inlineSelection bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if inlineSelection {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_inline_selection(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(inlineSelection)
}

// SetMatchFunc sets the match function for completion to be func.
//
// The match function is used to determine if a row should or should not be in
// the completion list.
//
// The function takes the following parameters:
//
//   - fn: GtkEntryCompletionMatchFunc to use.
func (completion *EntryCompletion) SetMatchFunc(fn EntryCompletionMatchFunc) {
	var _arg0 *C.GtkEntryCompletion         // out
	var _arg1 C.GtkEntryCompletionMatchFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_EntryCompletionMatchFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_entry_completion_set_match_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(fn)
}

// SetMinimumKeyLength requires the length of the search key for completion to
// be at least length.
//
// This is useful for long lists, where completing using a small key takes a lot
// of time and will come up with meaningless results anyway (ie, a too large
// dataset).
//
// The function takes the following parameters:
//
//   - length: minimum length of the key in order to start completing.
func (completion *EntryCompletion) SetMinimumKeyLength(length int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.int(length)

	C.gtk_entry_completion_set_minimum_key_length(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(length)
}

// SetModel sets the model for a GtkEntryCompletion.
//
// If completion already has a model set, it will remove it before setting the
// new model. If model is NULL, then it will unset the model.
//
// The function takes the following parameters:
//
//   - model (optional): GtkTreeModel.
func (completion *EntryCompletion) SetModel(model TreeModeller) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 *C.GtkTreeModel       // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if model != nil {
		_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_entry_completion_set_model(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(model)
}

// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
//
// The function takes the following parameters:
//
//   - popupCompletion: TRUE to do popup completion.
func (completion *EntryCompletion) SetPopupCompletion(popupCompletion bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if popupCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_completion(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(popupCompletion)
}

// SetPopupSetWidth sets whether the completion popup window will be resized to
// be the same width as the entry.
//
// The function takes the following parameters:
//
//   - popupSetWidth: TRUE to make the width of the popup the same as the entry.
func (completion *EntryCompletion) SetPopupSetWidth(popupSetWidth bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if popupSetWidth {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_set_width(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(popupSetWidth)
}

// SetPopupSingleMatch sets whether the completion popup window will appear even
// if there is only a single match.
//
// You may want to set this to FALSE if you are using
// gtk.EntryCompletion:inline-completion.
//
// The function takes the following parameters:
//
//   - popupSingleMatch: TRUE if the popup should appear even for a single
//     match.
func (completion *EntryCompletion) SetPopupSingleMatch(popupSingleMatch bool) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	if popupSingleMatch {
		_arg1 = C.TRUE
	}

	C.gtk_entry_completion_set_popup_single_match(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(popupSingleMatch)
}

// SetTextColumn: convenience function for setting up the most used case of this
// code: a completion list with just strings.
//
// This function will set up completion to have a list displaying all (and just)
// strings in the completion list, and to get those strings from column in the
// model of completion.
//
// This functions creates and adds a GtkCellRendererText for the selected
// column. If you need to set the text column, but don't want the cell renderer,
// use g_object_set() to set the gtk.EntryCompletion:text-column property
// directly.
//
// The function takes the following parameters:
//
//   - column in the model of completion to get strings from.
func (completion *EntryCompletion) SetTextColumn(column int) {
	var _arg0 *C.GtkEntryCompletion // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(coreglib.InternObject(completion).Native()))
	_arg1 = C.int(column)

	C.gtk_entry_completion_set_text_column(_arg0, _arg1)
	runtime.KeepAlive(completion)
	runtime.KeepAlive(column)
}

// EventController: GtkEventController is the base class for event controllers.
//
// These are ancillary objects associated to widgets, which react to GdkEvents,
// and possibly trigger actions as a consequence.
//
// Event controllers are added to a widget with gtk.Widget.AddController().
// It is rarely necessary to explicitly remove a controller with
// gtk.Widget.RemoveController().
//
// See the chapter of input handling (input-handling.html) for an overview
// of the basic concepts, such as the capture and bubble phases of even
// propagation.
type EventController struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*EventController)(nil)
)

// EventControllerer describes types inherited from class EventController.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type EventControllerer interface {
	coreglib.Objector
	baseEventController() *EventController
}

var _ EventControllerer = (*EventController)(nil)

func wrapEventController(obj *coreglib.Object) *EventController {
	return &EventController{
		Object: obj,
	}
}

func marshalEventController(p uintptr) (interface{}, error) {
	return wrapEventController(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (controller *EventController) baseEventController() *EventController {
	return controller
}

// BaseEventController returns the underlying base object.
func BaseEventController(obj EventControllerer) *EventController {
	return obj.baseEventController()
}

// CurrentEvent returns the event that is currently being handled by the
// controller, and NULL at other times.
//
// The function returns the following values:
//
//   - event (optional) that is currently handled by controller.
func (controller *EventController) CurrentEvent() gdk.Eventer {
	var _arg0 *C.GtkEventController // out
	var _cret *C.GdkEvent           // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_current_event(_arg0)
	runtime.KeepAlive(controller)

	var _event gdk.Eventer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Eventer)
				return ok
			})
			rv, ok := casted.(gdk.Eventer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Eventer")
			}
			_event = rv
		}
	}

	return _event
}

// CurrentEventDevice returns the device of the event that is currently being
// handled by the controller, and NULL otherwise.
//
// The function returns the following values:
//
//   - device (optional) of the event is currently handled by controller.
func (controller *EventController) CurrentEventDevice() gdk.Devicer {
	var _arg0 *C.GtkEventController // out
	var _cret *C.GdkDevice          // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_current_event_device(_arg0)
	runtime.KeepAlive(controller)

	var _device gdk.Devicer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Devicer)
				return ok
			})
			rv, ok := casted.(gdk.Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// CurrentEventState returns the modifier state of the event that is currently
// being handled by the controller, and 0 otherwise.
//
// The function returns the following values:
//
//   - modifierType: modifier state of the event is currently handled by
//     controller.
func (controller *EventController) CurrentEventState() gdk.ModifierType {
	var _arg0 *C.GtkEventController // out
	var _cret C.GdkModifierType     // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_current_event_state(_arg0)
	runtime.KeepAlive(controller)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// CurrentEventTime returns the timestamp of the event that is currently being
// handled by the controller, and 0 otherwise.
//
// The function returns the following values:
//
//   - guint32: timestamp of the event is currently handled by controller.
func (controller *EventController) CurrentEventTime() uint32 {
	var _arg0 *C.GtkEventController // out
	var _cret C.guint32             // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_current_event_time(_arg0)
	runtime.KeepAlive(controller)

	var _guint32 uint32 // out

	_guint32 = uint32(_cret)

	return _guint32
}

// Name gets the name of controller.
func (controller *EventController) Name() string {
	var _arg0 *C.GtkEventController // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_name(_arg0)
	runtime.KeepAlive(controller)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PropagationLimit gets the propagation limit of the event controller.
//
// The function returns the following values:
//
//   - propagationLimit: propagation limit.
func (controller *EventController) PropagationLimit() PropagationLimit {
	var _arg0 *C.GtkEventController // out
	var _cret C.GtkPropagationLimit // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_propagation_limit(_arg0)
	runtime.KeepAlive(controller)

	var _propagationLimit PropagationLimit // out

	_propagationLimit = PropagationLimit(_cret)

	return _propagationLimit
}

// PropagationPhase gets the propagation phase at which controller handles
// events.
//
// The function returns the following values:
//
//   - propagationPhase: propagation phase.
func (controller *EventController) PropagationPhase() PropagationPhase {
	var _arg0 *C.GtkEventController // out
	var _cret C.GtkPropagationPhase // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_propagation_phase(_arg0)
	runtime.KeepAlive(controller)

	var _propagationPhase PropagationPhase // out

	_propagationPhase = PropagationPhase(_cret)

	return _propagationPhase
}

// Widget returns the Widget this controller relates to.
//
// The function returns the following values:
//
//   - widget: GtkWidget.
func (controller *EventController) Widget() Widgetter {
	var _arg0 *C.GtkEventController // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_get_widget(_arg0)
	runtime.KeepAlive(controller)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// Reset resets the controller to a clean state.
func (controller *EventController) Reset() {
	var _arg0 *C.GtkEventController // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	C.gtk_event_controller_reset(_arg0)
	runtime.KeepAlive(controller)
}

// SetName sets a name on the controller that can be used for debugging.
//
// The function takes the following parameters:
//
//   - name for controller.
func (controller *EventController) SetName(name string) {
	var _arg0 *C.GtkEventController // out
	var _arg1 *C.char               // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_event_controller_set_name(_arg0, _arg1)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(name)
}

// SetPropagationLimit sets the event propagation limit on the event controller.
//
// If the limit is set to GTK_LIMIT_SAME_NATIVE, the controller won't handle
// events that are targeted at widgets on a different surface, such as popovers.
//
// The function takes the following parameters:
//
//   - limit: propagation limit.
func (controller *EventController) SetPropagationLimit(limit PropagationLimit) {
	var _arg0 *C.GtkEventController // out
	var _arg1 C.GtkPropagationLimit // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg1 = C.GtkPropagationLimit(limit)

	C.gtk_event_controller_set_propagation_limit(_arg0, _arg1)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(limit)
}

// SetPropagationPhase sets the propagation phase at which a controller handles
// events.
//
// If phase is GTK_PHASE_NONE, no automatic event handling will be performed,
// but other additional gesture maintenance will.
//
// The function takes the following parameters:
//
//   - phase: propagation phase.
func (controller *EventController) SetPropagationPhase(phase PropagationPhase) {
	var _arg0 *C.GtkEventController // out
	var _arg1 C.GtkPropagationPhase // out

	_arg0 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg1 = C.GtkPropagationPhase(phase)

	C.gtk_event_controller_set_propagation_phase(_arg0, _arg1)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(phase)
}

// EventControllerFocus: GtkEventControllerFocus is an event controller to keep
// track of keyboard focus.
//
// The event controller offers gtk.EventControllerFocus::enter
// and gtk.EventControllerFocus::leave signals, as well as
// gtk.EventControllerFocus:is-focus and gtk.EventControllerFocus:contains-focus
// properties which are updated to reflect focus changes inside the widget
// hierarchy that is rooted at the controllers widget.
type EventControllerFocus struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*EventControllerFocus)(nil)
)

func wrapEventControllerFocus(obj *coreglib.Object) *EventControllerFocus {
	return &EventControllerFocus{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalEventControllerFocus(p uintptr) (interface{}, error) {
	return wrapEventControllerFocus(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEnter is emitted whenever the focus enters into the widget or one of
// its descendents.
//
// Note that this means you may not get an ::enter signal even though the widget
// becomes the focus location, in certain cases (such as when the focus moves
// from a descendent of the widget to the widget itself). If you are interested
// in these cases, you can monitor the gtk.EventControllerFocus:is-focus
// property for changes.
func (self *EventControllerFocus) ConnectEnter(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "enter", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerFocus_ConnectEnter), f)
}

// ConnectLeave is emitted whenever the focus leaves the widget hierarchy that
// is rooted at the widget that the controller is attached to.
//
// Note that this means you may not get a ::leave signal even though the focus
// moves away from the widget, in certain cases (such as when the focus moves
// from the widget to a descendent). If you are interested in these cases,
// you can monitor the gtk.EventControllerFocus:is-focus property for changes.
func (self *EventControllerFocus) ConnectLeave(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "leave", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerFocus_ConnectLeave), f)
}

// NewEventControllerFocus creates a new event controller that will handle focus
// events.
//
// The function returns the following values:
//
//   - eventControllerFocus: new GtkEventControllerFocus.
func NewEventControllerFocus() *EventControllerFocus {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_focus_new()

	var _eventControllerFocus *EventControllerFocus // out

	_eventControllerFocus = wrapEventControllerFocus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerFocus
}

// ContainsFocus returns TRUE if focus is within self or one of its children.
//
// The function returns the following values:
//
//   - ok: TRUE if focus is within self or one of its children.
func (self *EventControllerFocus) ContainsFocus() bool {
	var _arg0 *C.GtkEventControllerFocus // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkEventControllerFocus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_event_controller_focus_contains_focus(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocus returns TRUE if focus is within self, but not one of its children.
//
// The function returns the following values:
//
//   - ok: TRUE if focus is within self, but not one of its children.
func (self *EventControllerFocus) IsFocus() bool {
	var _arg0 *C.GtkEventControllerFocus // out
	var _cret C.gboolean                 // in

	_arg0 = (*C.GtkEventControllerFocus)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_event_controller_focus_is_focus(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EventControllerKey: GtkEventControllerKey is an event controller that
// provides access to key events.
type EventControllerKey struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*EventControllerKey)(nil)
)

func wrapEventControllerKey(obj *coreglib.Object) *EventControllerKey {
	return &EventControllerKey{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalEventControllerKey(p uintptr) (interface{}, error) {
	return wrapEventControllerKey(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectIMUpdate is emitted whenever the input method context filters away a
// keypress and prevents the controller receiving it.
//
// See gtk.EventControllerKey.SetIMContext() and gtk.IMContext.FilterKeypress().
func (controller *EventControllerKey) ConnectIMUpdate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(controller, "im-update", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerKey_ConnectIMUpdate), f)
}

// ConnectKeyPressed is emitted whenever a key is pressed.
func (controller *EventControllerKey) ConnectKeyPressed(f func(keyval, keycode uint, state gdk.ModifierType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(controller, "key-pressed", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerKey_ConnectKeyPressed), f)
}

// ConnectKeyReleased is emitted whenever a key is released.
func (controller *EventControllerKey) ConnectKeyReleased(f func(keyval, keycode uint, state gdk.ModifierType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(controller, "key-released", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerKey_ConnectKeyReleased), f)
}

// ConnectModifiers is emitted whenever the state of modifier keys and pointer
// buttons change.
func (controller *EventControllerKey) ConnectModifiers(f func(keyval gdk.ModifierType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(controller, "modifiers", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerKey_ConnectModifiers), f)
}

// NewEventControllerKey creates a new event controller that will handle key
// events.
//
// The function returns the following values:
//
//   - eventControllerKey: new GtkEventControllerKey.
func NewEventControllerKey() *EventControllerKey {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_key_new()

	var _eventControllerKey *EventControllerKey // out

	_eventControllerKey = wrapEventControllerKey(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerKey
}

// Forward forwards the current event of this controller to a widget.
//
// This function can only be used in handlers for the
// gtk.EventControllerKey::key-pressed, gtk.EventControllerKey::key-released or
// gtk.EventControllerKey::modifiers signals.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget.
//
// The function returns the following values:
//
//   - ok: whether the widget handled the event.
func (controller *EventControllerKey) Forward(widget Widgetter) bool {
	var _arg0 *C.GtkEventControllerKey // out
	var _arg1 *C.GtkWidget             // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_event_controller_key_forward(_arg0, _arg1)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Group gets the key group of the current event of this controller.
//
// See gdk.KeyEvent.GetLayout().
//
// The function returns the following values:
//
//   - guint: key group.
func (controller *EventControllerKey) Group() uint {
	var _arg0 *C.GtkEventControllerKey // out
	var _cret C.guint                  // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_key_get_group(_arg0)
	runtime.KeepAlive(controller)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IMContext gets the input method context of the key controller.
//
// The function returns the following values:
//
//   - imContext: GtkIMContext.
func (controller *EventControllerKey) IMContext() IMContexter {
	var _arg0 *C.GtkEventControllerKey // out
	var _cret *C.GtkIMContext          // in

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	_cret = C.gtk_event_controller_key_get_im_context(_arg0)
	runtime.KeepAlive(controller)

	var _imContext IMContexter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.IMContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(IMContexter)
			return ok
		})
		rv, ok := casted.(IMContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.IMContexter")
		}
		_imContext = rv
	}

	return _imContext
}

// SetIMContext sets the input method context of the key controller.
//
// The function takes the following parameters:
//
//   - imContext: GtkIMContext.
func (controller *EventControllerKey) SetIMContext(imContext IMContexter) {
	var _arg0 *C.GtkEventControllerKey // out
	var _arg1 *C.GtkIMContext          // out

	_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg1 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(imContext).Native()))

	C.gtk_event_controller_key_set_im_context(_arg0, _arg1)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(imContext)
}

// EventControllerLegacy: GtkEventControllerLegacy is an event controller that
// provides raw access to the event stream.
//
// It should only be used as a last resort if none of the other event
// controllers or gestures do the job.
type EventControllerLegacy struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*EventControllerLegacy)(nil)
)

func wrapEventControllerLegacy(obj *coreglib.Object) *EventControllerLegacy {
	return &EventControllerLegacy{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalEventControllerLegacy(p uintptr) (interface{}, error) {
	return wrapEventControllerLegacy(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEvent is emitted for each GDK event delivered to controller.
func (v *EventControllerLegacy) ConnectEvent(f func(event gdk.Eventer) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "event", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerLegacy_ConnectEvent), f)
}

// NewEventControllerLegacy creates a new legacy event controller.
//
// The function returns the following values:
//
//   - eventControllerLegacy: newly created event controller.
func NewEventControllerLegacy() *EventControllerLegacy {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_legacy_new()

	var _eventControllerLegacy *EventControllerLegacy // out

	_eventControllerLegacy = wrapEventControllerLegacy(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerLegacy
}

// EventControllerMotion: GtkEventControllerMotion is an event controller
// tracking the pointer position.
//
// The event controller offers gtk.EventControllerMotion::enter
// and gtk.EventControllerMotion::leave signals,
// as well as gtk.EventControllerMotion:is-pointer and
// gtk.EventControllerMotion:contains-pointer properties which are updated to
// reflect changes in the pointer position as it moves over the widget.
type EventControllerMotion struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*EventControllerMotion)(nil)
)

func wrapEventControllerMotion(obj *coreglib.Object) *EventControllerMotion {
	return &EventControllerMotion{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalEventControllerMotion(p uintptr) (interface{}, error) {
	return wrapEventControllerMotion(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEnter signals that the pointer has entered the widget.
func (self *EventControllerMotion) ConnectEnter(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "enter", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerMotion_ConnectEnter), f)
}

// ConnectLeave signals that the pointer has left the widget.
func (self *EventControllerMotion) ConnectLeave(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "leave", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerMotion_ConnectLeave), f)
}

// ConnectMotion is emitted when the pointer moves inside the widget.
func (self *EventControllerMotion) ConnectMotion(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "motion", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerMotion_ConnectMotion), f)
}

// NewEventControllerMotion creates a new event controller that will handle
// motion events.
//
// The function returns the following values:
//
//   - eventControllerMotion: new GtkEventControllerMotion.
func NewEventControllerMotion() *EventControllerMotion {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_event_controller_motion_new()

	var _eventControllerMotion *EventControllerMotion // out

	_eventControllerMotion = wrapEventControllerMotion(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerMotion
}

// ContainsPointer returns if a pointer is within self or one of its children.
//
// The function returns the following values:
//
//   - ok: TRUE if a pointer is within self or one of its children.
func (self *EventControllerMotion) ContainsPointer() bool {
	var _arg0 *C.GtkEventControllerMotion // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkEventControllerMotion)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_event_controller_motion_contains_pointer(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPointer returns if a pointer is within self, but not one of its children.
//
// The function returns the following values:
//
//   - ok: TRUE if a pointer is within self but not one of its children.
func (self *EventControllerMotion) IsPointer() bool {
	var _arg0 *C.GtkEventControllerMotion // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkEventControllerMotion)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_event_controller_motion_is_pointer(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EventControllerScroll: GtkEventControllerScroll is an event controller that
// handles scroll events.
//
// It is capable of handling both discrete and continuous scroll
// events from mice or touchpads, abstracting them both with the
// gtk.EventControllerScroll::scroll signal. Deltas in the discrete case are
// multiples of 1.
//
// In the case of continuous scroll events, GtkEventControllerScroll
// encloses all gtk.EventControllerScroll::scroll emissions
// between two gtk.EventControllerScroll::scroll-begin and
// gtk.EventControllerScroll::scroll-end signals.
//
// The behavior of the event controller can be modified by the flags
// given at creation time, or modified at a later point through
// gtk.EventControllerScroll.SetFlags() (e.g. because the scrolling conditions
// of the widget changed).
//
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through GTK_EVENT_CONTROLLER_SCROLL_VERTICAL,
// GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL and
// GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES. If any axis is disabled, the
// respective gtk.EventControllerScroll::scroll delta will be 0. Vertical scroll
// events will be translated to horizontal motion for the devices incapable of
// horizontal scrolling.
//
// The event controller can also be forced to emit discrete events on all
// devices through GTK_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
//
// The GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// gtk.EventControllerScroll::decelerate signal, emitted at the end of scrolling
// with two X/Y velocity arguments that are consistent with the motion that was
// received.
type EventControllerScroll struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*EventControllerScroll)(nil)
)

func wrapEventControllerScroll(obj *coreglib.Object) *EventControllerScroll {
	return &EventControllerScroll{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalEventControllerScroll(p uintptr) (interface{}, error) {
	return wrapEventControllerScroll(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDecelerate is emitted after scroll is finished if the
// GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag is set.
//
// vel_x and vel_y express the initial velocity that was imprinted by the scroll
// events. vel_x and vel_y are expressed in pixels/ms.
func (scroll *EventControllerScroll) ConnectDecelerate(f func(velX, velY float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scroll, "decelerate", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectDecelerate), f)
}

// ConnectScroll signals that the widget should scroll by the amount specified
// by dx and dy.
func (scroll *EventControllerScroll) ConnectScroll(f func(dx, dy float64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scroll, "scroll", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectScroll), f)
}

// ConnectScrollBegin signals that a new scrolling operation has begun.
//
// It will only be emitted on devices capable of it.
func (scroll *EventControllerScroll) ConnectScrollBegin(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scroll, "scroll-begin", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectScrollBegin), f)
}

// ConnectScrollEnd signals that a scrolling operation has finished.
//
// It will only be emitted on devices capable of it.
func (scroll *EventControllerScroll) ConnectScrollEnd(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scroll, "scroll-end", false, unsafe.Pointer(C._gotk4_gtk4_EventControllerScroll_ConnectScrollEnd), f)
}

// NewEventControllerScroll creates a new event controller that will handle
// scroll events.
//
// The function takes the following parameters:
//
//   - flags affecting the controller behavior.
//
// The function returns the following values:
//
//   - eventControllerScroll: new GtkEventControllerScroll.
func NewEventControllerScroll(flags EventControllerScrollFlags) *EventControllerScroll {
	var _arg1 C.GtkEventControllerScrollFlags // out
	var _cret *C.GtkEventController           // in

	_arg1 = C.GtkEventControllerScrollFlags(flags)

	_cret = C.gtk_event_controller_scroll_new(_arg1)
	runtime.KeepAlive(flags)

	var _eventControllerScroll *EventControllerScroll // out

	_eventControllerScroll = wrapEventControllerScroll(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _eventControllerScroll
}

// Flags gets the flags conditioning the scroll controller behavior.
//
// The function returns the following values:
//
//   - eventControllerScrollFlags: controller flags.
func (scroll *EventControllerScroll) Flags() EventControllerScrollFlags {
	var _arg0 *C.GtkEventControllerScroll     // out
	var _cret C.GtkEventControllerScrollFlags // in

	_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(coreglib.InternObject(scroll).Native()))

	_cret = C.gtk_event_controller_scroll_get_flags(_arg0)
	runtime.KeepAlive(scroll)

	var _eventControllerScrollFlags EventControllerScrollFlags // out

	_eventControllerScrollFlags = EventControllerScrollFlags(_cret)

	return _eventControllerScrollFlags
}

// SetFlags sets the flags conditioning scroll controller behavior.
//
// The function takes the following parameters:
//
//   - flags affecting the controller behavior.
func (scroll *EventControllerScroll) SetFlags(flags EventControllerScrollFlags) {
	var _arg0 *C.GtkEventControllerScroll     // out
	var _arg1 C.GtkEventControllerScrollFlags // out

	_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(coreglib.InternObject(scroll).Native()))
	_arg1 = C.GtkEventControllerScrollFlags(flags)

	C.gtk_event_controller_scroll_set_flags(_arg0, _arg1)
	runtime.KeepAlive(scroll)
	runtime.KeepAlive(flags)
}

// EveryFilter: GtkEveryFilter matches an item when each of its filters matches.
//
// To add filters to a GtkEveryFilter, use gtk.MultiFilter.Append().
type EveryFilter struct {
	_ [0]func() // equal guard
	MultiFilter
}

var (
	_ MultiFilterer = (*EveryFilter)(nil)
)

func wrapEveryFilter(obj *coreglib.Object) *EveryFilter {
	return &EveryFilter{
		MultiFilter: MultiFilter{
			Filter: Filter{
				Object: obj,
			},
			Object: obj,
			ListModel: gio.ListModel{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
		},
	}
}

func marshalEveryFilter(p uintptr) (interface{}, error) {
	return wrapEveryFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewEveryFilter creates a new empty "every" filter.
//
// Use gtk.MultiFilter.Append() to add filters to it.
//
// This filter matches an item if each of the filters added to it matches the
// item. In particular, this means that if no filter has been added to it,
// the filter matches every item.
//
// The function returns the following values:
//
//   - everyFilter: new GtkEveryFilter.
func NewEveryFilter() *EveryFilter {
	var _cret *C.GtkEveryFilter // in

	_cret = C.gtk_every_filter_new()

	var _everyFilter *EveryFilter // out

	_everyFilter = wrapEveryFilter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _everyFilter
}

// Expander: GtkExpander allows the user to reveal its child by clicking on an
// expander triangle.
//
// !An example GtkExpander (expander.png)
//
// This is similar to the triangles used in a GtkTreeView.
//
// Normally you use an expander as you would use a frame; you create the
// child widget and use gtk.Expander.SetChild() to add it to the expander.
// When the expander is toggled, it will take care of showing and hiding the
// child automatically.
//
// # Special Usage
//
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a GtkExpander but do not add a child to
// it. The expander widget has an [propertyGtk.Expander:expanded[ property which
// can be used to monitor its expansion state. You should watch this property
// with a signal connection as follows:
//
//	static void
//	expander_callback (GObject    *object,
//	                   GParamSpec *param_spec,
//	                   gpointer    user_data)
//	{
//	  GtkExpander *expander;
//
//	  expander = GTK_EXPANDER (object);
//
//	  if (gtk_expander_get_expanded (expander))
//	    {
//	      // Show or create widgets
//	    }
//	  else
//	    {
//	      // Hide or destroy widgets
//	    }
//	}
//
//	static void
//	create_expander (void)
//	{
//	  GtkWidget *expander = gtk_expander_new_with_mnemonic ("_More Options");
//	  g_signal_connect (expander, "notify::expanded",
//	                    G_CALLBACK (expander_callback), NULL);
//
//	  // ...
//	}
//
// # GtkExpander as GtkBuildable
//
// The GtkExpander implementation of the GtkBuildable interface supports placing
// a child in the label position by specifying “label” as the “type” attribute
// of a <child> element. A normal content child can be specified without
// specifying a <child> type attribute.
//
// An example of a UI definition fragment with GtkExpander:
//
//	<object class="GtkExpander">
//	  <child type="label">
//	    <object class="GtkLabel" id="expander-label"/>
//	  </child>
//	  <child>
//	    <object class="GtkEntry" id="expander-content"/>
//	  </child>
//	</object>
//
// CSS nodes
//
//	expander
//	╰── box
//	    ├── title
//	    │   ├── arrow
//	    │   ╰── <label widget>
//	    ╰── <child>
//
// GtkExpander has three CSS nodes, the main node with the name expander,
// a subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
//
// # Accessibility
//
// GtkExpander uses the GTK_ACCESSIBLE_ROLE_BUTTON role.
type Expander struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Expander)(nil)
)

func wrapExpander(obj *coreglib.Object) *Expander {
	return &Expander{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalExpander(p uintptr) (interface{}, error) {
	return wrapExpander(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate activates the GtkExpander.
func (expander *Expander) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(expander, "activate", false, unsafe.Pointer(C._gotk4_gtk4_Expander_ConnectActivate), f)
}

// NewExpander creates a new expander using label as the text of the label.
//
// The function takes the following parameters:
//
//   - label (optional): text of the label.
//
// The function returns the following values:
//
//   - expander: new GtkExpander widget.
func NewExpander(label string) *Expander {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_expander_new(_arg1)
	runtime.KeepAlive(label)

	var _expander *Expander // out

	_expander = wrapExpander(coreglib.Take(unsafe.Pointer(_cret)))

	return _expander
}

// NewExpanderWithMnemonic creates a new expander using label as the text of the
// label.
//
// If characters in label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
//
// Pressing Alt and that key activates the button.
//
// The function takes the following parameters:
//
//   - label (optional): text of the label with an underscore in front of the
//     mnemonic character.
//
// The function returns the following values:
//
//   - expander: new GtkExpander widget.
func NewExpanderWithMnemonic(label string) *Expander {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_expander_new_with_mnemonic(_arg1)
	runtime.KeepAlive(label)

	var _expander *Expander // out

	_expander = wrapExpander(coreglib.Take(unsafe.Pointer(_cret)))

	return _expander
}

// Child gets the child widget of expander.
//
// The function returns the following values:
//
//   - widget (optional): child widget of expander.
func (expander *Expander) Child() Widgetter {
	var _arg0 *C.GtkExpander // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))

	_cret = C.gtk_expander_get_child(_arg0)
	runtime.KeepAlive(expander)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Expanded queries a Expander and returns its current state.
//
// Returns TRUE if the child widget is revealed.
//
// The function returns the following values:
//
//   - ok: current state of the expander.
func (expander *Expander) Expanded() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))

	_cret = C.gtk_expander_get_expanded(_arg0)
	runtime.KeepAlive(expander)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Label fetches the text from a label widget.
//
// This is including any embedded underlines indicating mnemonics and Pango
// markup, as set by gtk.Expander.SetLabel(). If the label text has not been set
// the return value will be NULL. This will be the case if you create an empty
// button with gtk_button_new() to use as a container.
//
// The function returns the following values:
//
//   - utf8 (optional): text of the label widget. This string is owned by the
//     widget and must not be modified or freed.
func (expander *Expander) Label() string {
	var _arg0 *C.GtkExpander // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))

	_cret = C.gtk_expander_get_label(_arg0)
	runtime.KeepAlive(expander)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// LabelWidget retrieves the label widget for the frame.
//
// The function returns the following values:
//
//   - widget (optional): label widget, or NULL if there is none.
func (expander *Expander) LabelWidget() Widgetter {
	var _arg0 *C.GtkExpander // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))

	_cret = C.gtk_expander_get_label_widget(_arg0)
	runtime.KeepAlive(expander)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ResizeToplevel returns whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
//
// The function returns the following values:
//
//   - ok: “resize toplevel” setting.
func (expander *Expander) ResizeToplevel() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))

	_cret = C.gtk_expander_get_resize_toplevel(_arg0)
	runtime.KeepAlive(expander)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseMarkup returns whether the label’s text is interpreted as Pango markup.
//
// The function returns the following values:
//
//   - ok: TRUE if the label’s text will be parsed for markup.
func (expander *Expander) UseMarkup() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))

	_cret = C.gtk_expander_get_use_markup(_arg0)
	runtime.KeepAlive(expander)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an underline in the text indicates a mnemonic.
//
// The function returns the following values:
//
//   - ok: TRUE if an embedded underline in the expander label indicates the
//     mnemonic accelerator keys.
func (expander *Expander) UseUnderline() bool {
	var _arg0 *C.GtkExpander // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))

	_cret = C.gtk_expander_get_use_underline(_arg0)
	runtime.KeepAlive(expander)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of expander.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (expander *Expander) SetChild(child Widgetter) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_expander_set_child(_arg0, _arg1)
	runtime.KeepAlive(expander)
	runtime.KeepAlive(child)
}

// SetExpanded sets the state of the expander.
//
// Set to TRUE, if you want the child widget to be revealed, and FALSE if you
// want the child widget to be hidden.
//
// The function takes the following parameters:
//
//   - expanded: whether the child widget is revealed.
func (expander *Expander) SetExpanded(expanded bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))
	if expanded {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_expanded(_arg0, _arg1)
	runtime.KeepAlive(expander)
	runtime.KeepAlive(expanded)
}

// SetLabel sets the text of the label of the expander to label.
//
// This will also clear any previously set labels.
//
// The function takes the following parameters:
//
//   - label (optional): string.
func (expander *Expander) SetLabel(label string) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))
	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_expander_set_label(_arg0, _arg1)
	runtime.KeepAlive(expander)
	runtime.KeepAlive(label)
}

// SetLabelWidget: set the label widget for the expander.
//
// This is the widget that will appear embedded alongside the expander arrow.
//
// The function takes the following parameters:
//
//   - labelWidget (optional): new label widget.
func (expander *Expander) SetLabelWidget(labelWidget Widgetter) {
	var _arg0 *C.GtkExpander // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))
	if labelWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(labelWidget).Native()))
	}

	C.gtk_expander_set_label_widget(_arg0, _arg1)
	runtime.KeepAlive(expander)
	runtime.KeepAlive(labelWidget)
}

// SetResizeToplevel sets whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
//
// The function takes the following parameters:
//
//   - resizeToplevel: whether to resize the toplevel.
func (expander *Expander) SetResizeToplevel(resizeToplevel bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))
	if resizeToplevel {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_resize_toplevel(_arg0, _arg1)
	runtime.KeepAlive(expander)
	runtime.KeepAlive(resizeToplevel)
}

// SetUseMarkup sets whether the text of the label contains Pango markup.
//
// The function takes the following parameters:
//
//   - useMarkup: TRUE if the label’s text should be parsed for markup.
func (expander *Expander) SetUseMarkup(useMarkup bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))
	if useMarkup {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_use_markup(_arg0, _arg1)
	runtime.KeepAlive(expander)
	runtime.KeepAlive(useMarkup)
}

// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
//
// The function takes the following parameters:
//
//   - useUnderline: TRUE if underlines in the text indicate mnemonics.
func (expander *Expander) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkExpander // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkExpander)(unsafe.Pointer(coreglib.InternObject(expander).Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_expander_set_use_underline(_arg0, _arg1)
	runtime.KeepAlive(expander)
	runtime.KeepAlive(useUnderline)
}

// Expression: GtkExpression provides a way to describe references to values.
//
// An important aspect of expressions is that the value can be obtained from a
// source that is several steps away. For example, an expression may describe
// ‘the value of property A of object1, which is itself the value of a property
// of object2’. And object1 may not even exist yet at the time that the
// expression is created. This is contrast to GObject property bindings, which
// can only create direct connections between the properties of two objects that
// must both exist for the duration of the binding.
//
// An expression needs to be "evaluated" to obtain the value that it currently
// refers to. An evaluation always happens in the context of a current object
// called this (it mirrors the behavior of object-oriented languages),
// which may or may not influence the result of the evaluation. Use
// gtk.Expression.Evaluate() for evaluating an expression.
//
// Various methods for defining expressions exist, from simple constants via
// gtk.ConstantExpression.New to looking up properties in a GObject (even
// recursively) via gtk.PropertyExpression.New or providing custom functions to
// transform and combine expressions via gtk.ClosureExpression.New.
//
// Here is an example of a complex expression:
//
//	color_expr = gtk_property_expression_new (GTK_TYPE_LIST_ITEM,
//	                                          NULL, "item");
//	expression = gtk_property_expression_new (GTK_TYPE_COLOR,
//	                                          color_expr, "name");
//
// when evaluated with this being a GtkListItem, it will obtain the "item"
// property from the GtkListItem, and then obtain the "name" property from the
// resulting object (which is assumed to be of type GTK_TYPE_COLOR).
//
// A more concise way to describe this would be
//
//	this->item->name
//
// The most likely place where you will encounter expressions is in the context
// of list models and list widgets using them. For example, GtkDropDown is
// evaluating a GtkExpression to obtain strings from the items in its model
// that it can then use to match against the contents of its search entry.
// GtkStringFilter is using a GtkExpression for similar reasons.
//
// By default, expressions are not paying attention to changes and evaluation
// is just a snapshot of the current state at a given time. To get informed
// about changes, an expression needs to be "watched" via a gtk.ExpressionWatch,
// which will cause a callback to be called whenever the value of the expression
// may have changed; gtk.Expression.Watch() starts watching an expression,
// and gtk.ExpressionWatch.Unwatch() stops.
//
// Watches can be created for automatically updating the property of an object,
// similar to GObject's GBinding mechanism, by using gtk.Expression.Bind().
//
// # GtkExpression in GObject properties
//
// In order to use a GtkExpression as a GObject property, you must use the
// gtk_param_spec_expression when creating a GParamSpec to install in the
// GObject class being defined; for instance:
//
//	obj_props[PROP_EXPRESSION] =
//	  gtk_param_spec_expression ("expression",
//	                             "Expression",
//	                             "The expression used by the widget",
//	                             G_PARAM_READWRITE |
//	                             G_PARAM_STATIC_STRINGS |
//	                             G_PARAM_EXPLICIT_NOTIFY);
//
// When implementing the GObjectClass.set_property and GObjectClass.get_property
// virtual functions, you must use gtk_value_get_expression, to retrieve the
// stored GtkExpression from the GValue container, and gtk_value_set_expression,
// to store the GtkExpression into the GValue; for instance:
//
//	// in set_property()...
//	case PROP_EXPRESSION:
//	  foo_widget_set_expression (foo, gtk_value_get_expression (value));
//	  break;
//
//	// in get_property()...
//	case PROP_EXPRESSION:
//	  gtk_value_set_expression (value, foo->expression);
//	  break;
//
// # GtkExpression in .ui files
//
// GtkBuilder has support for creating expressions. The syntax here can be
// used where a GtkExpression object is needed like in a <property> tag for
// an expression property, or in a <binding> tag to bind a property to an
// expression.
//
// To create an property expression, use the <lookup> element. It can have a
// type attribute to specify the object type, and a name attribute to specify
// the property to look up. The content of <lookup> can either be an element
// specfiying the expression to use the object, or a string that specifies the
// name of the object to use.
//
// Example:
//
//	<lookup name='search'>string_filter</lookup>
//
// To create a constant expression, use the <constant> element. If the type
// attribute is specified, the element content is interpreted as a value of that
// type. Otherwise, it is assumed to be an object. For instance:
//
//	<constant>string_filter</constant>
//	<constant type='gchararray'>Hello, world</constant>
//
// To create a closure expression, use the <closure> element. The type and
// function attributes specify what function to use for the closure, the content
// of the element contains the expressions for the parameters. For instance:
//
//	<closure type='gchararray' function='combine_args_somehow'>
//	  <constant type='gchararray'>File size:</constant>
//	  <lookup type='GFile' name='size'>myfile</lookup>
//	</closure>.
type Expression struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Expression)(nil)
)

// Expressioner describes types inherited from class Expression.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Expressioner interface {
	coreglib.Objector
	baseExpression() *Expression
}

var _ Expressioner = (*Expression)(nil)

func wrapExpression(obj *coreglib.Object) *Expression {
	return &Expression{
		Object: obj,
	}
}

func marshalExpression(p uintptr) (interface{}, error) {
	return wrapExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *Expression) baseExpression() *Expression {
	return self
}

// BaseExpression returns the underlying base object.
func BaseExpression(obj Expressioner) *Expression {
	return obj.baseExpression()
}

// Bind target's property named property to self.
//
// The value that self evaluates to is set via g_object_set() on target.
// This is repeated whenever self changes to ensure that the object's property
// stays synchronized with self.
//
// If self's evaluation fails, target's property is not updated. You can ensure
// that this doesn't happen by using a fallback expression.
//
// Note that this function takes ownership of self. If you want to keep it
// around, you should gtk.Expression.Ref() it beforehand.
//
// The function takes the following parameters:
//
//   - target object to bind to.
//   - property: name of the property on target to bind to.
//   - this_ (optional): argument for the evaluation of self.
//
// The function returns the following values:
//
//   - expressionWatch: GtkExpressionWatch.
func (self *Expression) Bind(target *coreglib.Object, property string, this_ *coreglib.Object) *ExpressionWatch {
	var _arg0 *C.GtkExpression      // out
	var _arg1 C.gpointer            // out
	var _arg2 *C.char               // out
	var _arg3 C.gpointer            // out
	var _cret *C.GtkExpressionWatch // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(target.Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(property)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.gpointer(unsafe.Pointer(this_.Native()))

	_cret = C.gtk_expression_bind(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(target)
	runtime.KeepAlive(property)
	runtime.KeepAlive(this_)

	var _expressionWatch *ExpressionWatch // out

	_expressionWatch = (*ExpressionWatch)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_expression_watch_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_expressionWatch)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_expression_watch_unref((*C.GtkExpressionWatch)(intern.C))
		},
	)

	return _expressionWatch
}

// Evaluate evaluates the given expression and on success stores the result in
// value.
//
// The GType of value will be the type given by gtk.Expression.GetValueType().
//
// It is possible that expressions cannot be evaluated - for example when the
// expression references objects that have been destroyed or set to NULL.
// In that case value will remain empty and FALSE will be returned.
//
// The function takes the following parameters:
//
//   - this_ (optional): argument for the evaluation.
//   - value: empty GValue.
//
// The function returns the following values:
//
//   - ok: TRUE if the expression could be evaluated.
func (self *Expression) Evaluate(this_ *coreglib.Object, value *coreglib.Value) bool {
	var _arg0 *C.GtkExpression // out
	var _arg1 C.gpointer       // out
	var _arg2 *C.GValue        // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(this_.Native()))
	_arg2 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_expression_evaluate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(this_)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ValueType gets the GType that this expression evaluates to.
//
// This type is constant and will not change over the lifetime of this
// expression.
//
// The function returns the following values:
//
//   - gType: type returned from gtk.Expression.Evaluate().
func (self *Expression) ValueType() coreglib.Type {
	var _arg0 *C.GtkExpression // out
	var _cret C.GType          // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_expression_get_value_type(_arg0)
	runtime.KeepAlive(self)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// IsStatic checks if the expression is static.
//
// A static expression will never change its result when
// gtk.Expression.Evaluate() is called on it with the same arguments.
//
// That means a call to gtk.Expression.Watch() is not necessary because it will
// never trigger a notify.
//
// The function returns the following values:
//
//   - ok: TRUE if the expression is static.
func (self *Expression) IsStatic() bool {
	var _arg0 *C.GtkExpression // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_expression_is_static(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Watch installs a watch for the given expression that calls the notify
// function whenever the evaluation of self may have changed.
//
// GTK cannot guarantee that the evaluation did indeed change when the notify
// gets invoked, but it guarantees the opposite: When it did in fact change,
// the notify will be invoked.
//
// The function takes the following parameters:
//
//   - this_ (optional): this argument to watch.
//   - notify: callback to invoke when the expression changes.
//
// The function returns the following values:
//
//   - expressionWatch: newly installed watch. Note that the only reference
//     held to the watch will be released when the watch is unwatched which can
//     happen automatically, and not just via gtk.ExpressionWatch.Unwatch().
//     You should call gtk.ExpressionWatch.Ref() if you want to keep the watch
//     around.
func (self *Expression) Watch(this_ *coreglib.Object, notify ExpressionNotify) *ExpressionWatch {
	var _arg0 *C.GtkExpression      // out
	var _arg1 C.gpointer            // out
	var _arg2 C.GtkExpressionNotify // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret *C.GtkExpressionWatch // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(this_.Native()))
	_arg2 = (*[0]byte)(C._gotk4_gtk4_ExpressionNotify)
	_arg3 = C.gpointer(gbox.Assign(notify))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gtk_expression_watch(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(this_)
	runtime.KeepAlive(notify)

	var _expressionWatch *ExpressionWatch // out

	_expressionWatch = (*ExpressionWatch)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.gtk_expression_watch_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_expressionWatch)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_expression_watch_unref((*C.GtkExpressionWatch)(intern.C))
		},
	)

	return _expressionWatch
}

// FileChooserDialog: GtkFileChooserDialog is a dialog suitable for use with
// “File Open” or “File Save” commands.
//
// !An example GtkFileChooserDialog (filechooser.png)
//
// This widget works by putting a gtk.FileChooserWidget inside a gtk.Dialog.
// It exposes the gtk.FileChooser interface, so you can use all of the
// gtk.FileChooser functions on the file chooser dialog as well as those for
// gtk.Dialog.
//
// Note that GtkFileChooserDialog does not have any methods of its own. Instead,
// you should use the functions that work on a gtk.FileChooser.
//
// If you want to integrate well with the platform you should use the
// gtk.FileChooserNative API, which will use a platform-specific dialog if
// available and fall back to GtkFileChooserDialog otherwise.
//
// # Typical usage
//
// In the simplest of cases, you can the following code to use
// GtkFileChooserDialog to select a file for opening:
//
//	static void
//	on_open_response (GtkDialog *dialog,
//	                  int        response)
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//	      g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//	      open_file (file);
//	    }
//
//	  gtk_window_destroy (GTK_WINDOW (dialog));
//	}
//
//	  // ...
//	  GtkWidget *dialog;
//	  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//	  dialog = gtk_file_chooser_dialog_new ("Open File",
//	                                        parent_window,
//	                                        action,
//	                                        _("_Cancel"),
//	                                        GTK_RESPONSE_CANCEL,
//	                                        _("_Open"),
//	                                        GTK_RESPONSE_ACCEPT,
//	                                        NULL);
//
//	  gtk_widget_show (dialog);
//
//	  g_signal_connect (dialog, "response",
//	                    G_CALLBACK (on_open_response),
//	                    NULL);
//
// To use a dialog for saving, you can use this:
//
//	static void
//	on_save_response (GtkDialog *dialog,
//	                  int        response)
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
//
//	      g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
//
//	      save_to_file (file);
//	    }
//
//	  gtk_window_destroy (GTK_WINDOW (dialog));
//	}
//
//	  // ...
//	  GtkWidget *dialog;
//	  GtkFileChooser *chooser;
//	  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//	  dialog = gtk_file_chooser_dialog_new ("Save File",
//	                                        parent_window,
//	                                        action,
//	                                        _("_Cancel"),
//	                                        GTK_RESPONSE_CANCEL,
//	                                        _("_Save"),
//	                                        GTK_RESPONSE_ACCEPT,
//	                                        NULL);
//	  chooser = GTK_FILE_CHOOSER (dialog);
//
//	  if (user_edited_a_new_document)
//	    gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//	  else
//	    gtk_file_chooser_set_file (chooser, existing_filename);
//
//	  gtk_widget_show (dialog);
//
//	  g_signal_connect (dialog, "response",
//	                    G_CALLBACK (on_save_response),
//	                    NULL);
//
// # Setting up a file chooser dialog
//
// There are various cases in which you may need to use a GtkFileChooserDialog:
//
// - To select a file for opening, use GTK_FILE_CHOOSER_ACTION_OPEN.
//
// - To save a file for the first time, use GTK_FILE_CHOOSER_ACTION_SAVE,
// and suggest a name such as “Untitled” with gtk.FileChooser.SetCurrentName().
//
// - To save a file under a different name, use GTK_FILE_CHOOSER_ACTION_SAVE,
// and set the existing file with gtk.FileChooser.SetFile().
//
// - To choose a folder instead of a filem use
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
//
// In general, you should only cause the file chooser to show a specific folder
// when it is appropriate to use gtk,filechooser.SetFile, i.e. when you are
// doing a “Save As” command and you already have a file saved somewhere.
//
// # Response Codes
//
// GtkFileChooserDialog inherits from gtk.Dialog, so buttons that go in
// its action area have response codes such as GTK_RESPONSE_ACCEPT and
// GTK_RESPONSE_CANCEL. For example, you could call gtk.FileChooserDialog.New as
// follows:
//
//	GtkWidget *dialog;
//	GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//	dialog = gtk_file_chooser_dialog_new ("Open File",
//	                                      parent_window,
//	                                      action,
//	                                      _("_Cancel"),
//	                                      GTK_RESPONSE_CANCEL,
//	                                      _("_Open"),
//	                                      GTK_RESPONSE_ACCEPT,
//	                                      NULL);
//
// This will create buttons for “Cancel” and “Open” that use predefined
// response identifiers from gtk.ResponseType. For most dialog boxes you can
// use your own custom response codes rather than the ones in gtk.ResponseType,
// but GtkFileChooserDialog assumes that its “accept”-type action, e.g.
// an “Open” or “Save” button, will have one of the following response codes:
//
// - GTK_RESPONSE_ACCEPT
//
// - GTK_RESPONSE_OK
//
// - GTK_RESPONSE_YES
//
// - GTK_RESPONSE_APPLY
//
// This is because GtkFileChooserDialog must intercept responses and switch
// to folders if appropriate, rather than letting the dialog terminate — the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
//
// To summarize, make sure you use a predefined response code when you use
// GtkFileChooserDialog to ensure proper operation.
type FileChooserDialog struct {
	_ [0]func() // equal guard
	Dialog

	*coreglib.Object
	FileChooser
}

var (
	_ coreglib.Objector = (*FileChooserDialog)(nil)
	_ Widgetter         = (*FileChooserDialog)(nil)
)

func wrapFileChooserDialog(obj *coreglib.Object) *FileChooserDialog {
	return &FileChooserDialog{
		Dialog: Dialog{
			Window: Window{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
				Object: obj,
				Root: Root{
					NativeSurface: NativeSurface{
						Widget: Widget{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
							Object: obj,
							Accessible: Accessible{
								Object: obj,
							},
							Buildable: Buildable{
								Object: obj,
							},
							ConstraintTarget: ConstraintTarget{
								Object: obj,
							},
						},
					},
				},
				ShortcutManager: ShortcutManager{
					Object: obj,
				},
			},
		},
		Object: obj,
		FileChooser: FileChooser{
			Object: obj,
		},
	}
}

func marshalFileChooserDialog(p uintptr) (interface{}, error) {
	return wrapFileChooserDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// FileChooserNativeOverrides contains methods that are overridable.
type FileChooserNativeOverrides struct {
}

func defaultFileChooserNativeOverrides(v *FileChooserNative) FileChooserNativeOverrides {
	return FileChooserNativeOverrides{}
}

// FileChooserNative: GtkFileChooserNative is an abstraction of a dialog
// suitable for use with “File Open” or “File Save as” commands.
//
// By default, this just uses a GtkFileChooserDialog to implement the actual
// dialog. However, on some platforms, such as Windows and macOS, the native
// platform file chooser is used instead. When the application is running in a
// sandboxed environment without direct filesystem access (such as Flatpak),
// GtkFileChooserNative may call the proper APIs (portals) to let the user
// choose a file and make it available to the application.
//
// While the API of GtkFileChooserNative closely mirrors GtkFileChooserDialog,
// the main difference is that there is no access to any GtkWindow or GtkWidget
// for the dialog. This is required, as there may not be one in the case of a
// platform native dialog.
//
// Showing, hiding and running the dialog is handled by the gtk.NativeDialog
// functions.
//
// Note that unlike GtkFileChooserDialog, GtkFileChooserNative objects are not
// toplevel widgets, and GTK does not keep them alive. It is your responsibility
// to keep a reference until you are done with the object.
//
// # Typical usage
//
// In the simplest of cases, you can the following code to use
// GtkFileChooserNative to select a file for opening:
//
//	static void
//	on_response (GtkNativeDialog *native,
//	             int              response)
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//	      GFile *file = gtk_file_chooser_get_file (chooser);
//
//	      open_file (file);
//
//	      g_object_unref (file);
//	    }
//
//	  g_object_unref (native);
//	}
//
//	  // ...
//	  GtkFileChooserNative *native;
//	  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
//
//	  native = gtk_file_chooser_native_new ("Open File",
//	                                        parent_window,
//	                                        action,
//	                                        "_Open",
//	                                        "_Cancel");
//
//	  g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//	  gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
// To use a GtkFileChooserNative for saving, you can use this:
//
//	static void
//	on_response (GtkNativeDialog *native,
//	             int              response)
//	{
//	  if (response == GTK_RESPONSE_ACCEPT)
//	    {
//	      GtkFileChooser *chooser = GTK_FILE_CHOOSER (native);
//	      GFile *file = gtk_file_chooser_get_file (chooser);
//
//	      save_to_file (file);
//
//	      g_object_unref (file);
//	    }
//
//	  g_object_unref (native);
//	}
//
//	  // ...
//	  GtkFileChooserNative *native;
//	  GtkFileChooser *chooser;
//	  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
//
//	  native = gtk_file_chooser_native_new ("Save File",
//	                                        parent_window,
//	                                        action,
//	                                        "_Save",
//	                                        "_Cancel");
//	  chooser = GTK_FILE_CHOOSER (native);
//
//	  if (user_edited_a_new_document)
//	    gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//	  else
//	    gtk_file_chooser_set_file (chooser, existing_file, NULL);
//
//	  g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//	  gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
//
// For more information on how to best set up a file dialog, see the
// gtk.FileChooserDialog documentation.
//
// # Response Codes
//
// GtkFileChooserNative inherits from gtk.NativeDialog, which means it will
// return GTK_RESPONSE_ACCEPT if the user accepted, and GTK_RESPONSE_CANCEL if
// he pressed cancel. It can also return GTK_RESPONSE_DELETE_EVENT if the window
// was unexpectedly closed.
//
// # Differences from FileChooserDialog
//
// There are a few things in the gtk.FileChooser interface that are not possible
// to use with GtkFileChooserNative, as such use would prohibit the use of a
// native dialog.
//
// No operations that change the dialog work while the dialog is visible.
// Set all the properties that are required before showing the dialog.
//
// # Win32 details
//
// On windows the IFileDialog implementation (added in Windows Vista) is used.
// It supports many of the features that GtkFileChooser has, but there are some
// things it does not handle:
//
// * Any gtk.FileFilter added using a mimetype
//
// If any of these features are used the regular GtkFileChooserDialog will be
// used in place of the native one.
//
// # Portal details
//
// When the org.freedesktop.portal.FileChooser portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK file chooser.
//
// macOS details
//
// On macOS the NSSavePanel and NSOpenPanel classes are used to provide native
// file chooser dialogs. Some features provided by GtkFileChooser are not
// supported:
//
// * Shortcut folders.
type FileChooserNative struct {
	_ [0]func() // equal guard
	NativeDialog

	*coreglib.Object
	FileChooser
}

var (
	_ NativeDialogger   = (*FileChooserNative)(nil)
	_ coreglib.Objector = (*FileChooserNative)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FileChooserNative, *FileChooserNativeClass, FileChooserNativeOverrides](
		GTypeFileChooserNative,
		initFileChooserNativeClass,
		wrapFileChooserNative,
		defaultFileChooserNativeOverrides,
	)
}

func initFileChooserNativeClass(gclass unsafe.Pointer, overrides FileChooserNativeOverrides, classInitFunc func(*FileChooserNativeClass)) {
	if classInitFunc != nil {
		class := (*FileChooserNativeClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFileChooserNative(obj *coreglib.Object) *FileChooserNative {
	return &FileChooserNative{
		NativeDialog: NativeDialog{
			Object: obj,
		},
		Object: obj,
		FileChooser: FileChooser{
			Object: obj,
		},
	}
}

func marshalFileChooserNative(p uintptr) (interface{}, error) {
	return wrapFileChooserNative(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFileChooserNative creates a new GtkFileChooserNative.
//
// The function takes the following parameters:
//
//   - title (optional): title of the native, or NULL.
//   - parent (optional): transient parent of the native, or NULL.
//   - action: open or save mode for the dialog.
//   - acceptLabel (optional): text to go in the accept button, or NULL for the
//     default.
//   - cancelLabel (optional): text to go in the cancel button, or NULL for the
//     default.
//
// The function returns the following values:
//
//   - fileChooserNative: new GtkFileChooserNative.
func NewFileChooserNative(title string, parent *Window, action FileChooserAction, acceptLabel, cancelLabel string) *FileChooserNative {
	var _arg1 *C.char                 // out
	var _arg2 *C.GtkWindow            // out
	var _arg3 C.GtkFileChooserAction  // out
	var _arg4 *C.char                 // out
	var _arg5 *C.char                 // out
	var _cret *C.GtkFileChooserNative // in

	if title != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if parent != nil {
		_arg2 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}
	_arg3 = C.GtkFileChooserAction(action)
	if acceptLabel != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(acceptLabel)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if cancelLabel != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(cancelLabel)))
		defer C.free(unsafe.Pointer(_arg5))
	}

	_cret = C.gtk_file_chooser_native_new(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(title)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(action)
	runtime.KeepAlive(acceptLabel)
	runtime.KeepAlive(cancelLabel)

	var _fileChooserNative *FileChooserNative // out

	_fileChooserNative = wrapFileChooserNative(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileChooserNative
}

// AcceptLabel retrieves the custom label text for the accept button.
//
// The function returns the following values:
//
//   - utf8 (optional): custom label, or NULL for the default. This string is
//     owned by GTK and should not be modified or freed.
func (self *FileChooserNative) AcceptLabel() string {
	var _arg0 *C.GtkFileChooserNative // out
	var _cret *C.char                 // in

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_file_chooser_native_get_accept_label(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CancelLabel retrieves the custom label text for the cancel button.
//
// The function returns the following values:
//
//   - utf8 (optional): custom label, or NULL for the default. This string is
//     owned by GTK and should not be modified or freed.
func (self *FileChooserNative) CancelLabel() string {
	var _arg0 *C.GtkFileChooserNative // out
	var _cret *C.char                 // in

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_file_chooser_native_get_cancel_label(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SetAcceptLabel sets the custom label text for the accept button.
//
// If characters in label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
//
// Pressing Alt and that key should activate the button.
//
// The function takes the following parameters:
//
//   - acceptLabel (optional): custom label or NULL for the default.
func (self *FileChooserNative) SetAcceptLabel(acceptLabel string) {
	var _arg0 *C.GtkFileChooserNative // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if acceptLabel != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(acceptLabel)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_file_chooser_native_set_accept_label(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(acceptLabel)
}

// SetCancelLabel sets the custom label text for the cancel button.
//
// If characters in label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use “__” (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
//
// Pressing Alt and that key should activate the button.
//
// The function takes the following parameters:
//
//   - cancelLabel (optional): custom label or NULL for the default.
func (self *FileChooserNative) SetCancelLabel(cancelLabel string) {
	var _arg0 *C.GtkFileChooserNative // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if cancelLabel != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(cancelLabel)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_file_chooser_native_set_cancel_label(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(cancelLabel)
}

// FileChooserWidget: GtkFileChooserWidget is a widget for choosing files.
//
// It exposes the gtk.FileChooser interface, and you should use the methods of
// this interface to interact with the widget.
//
// # CSS nodes
//
// GtkFileChooserWidget has a single CSS node with name filechooser.
type FileChooserWidget struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	FileChooser
}

var (
	_ Widgetter         = (*FileChooserWidget)(nil)
	_ coreglib.Objector = (*FileChooserWidget)(nil)
)

func wrapFileChooserWidget(obj *coreglib.Object) *FileChooserWidget {
	return &FileChooserWidget{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		FileChooser: FileChooser{
			Object: obj,
		},
	}
}

func marshalFileChooserWidget(p uintptr) (interface{}, error) {
	return wrapFileChooserWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDesktopFolder is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser show the user's Desktop folder in the
// file list.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>D</kbd>.
func (v *FileChooserWidget) ConnectDesktopFolder(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "desktop-folder", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectDesktopFolder), f)
}

// ConnectDownFolder is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser go to a child of the current folder
// in the file hierarchy. The subfolder that will be used is displayed in the
// path bar widget of the file chooser. For example, if the path bar is showing
// "/foo/bar/baz", with bar currently displayed, then this will cause the file
// chooser to switch to the "baz" subfolder.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>Down</kbd>.
func (v *FileChooserWidget) ConnectDownFolder(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "down-folder", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectDownFolder), f)
}

// ConnectHomeFolder is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser show the user's home folder in the file
// list.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>Home</kbd>.
func (v *FileChooserWidget) ConnectHomeFolder(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "home-folder", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectHomeFolder), f)
}

// ConnectLocationPopup is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser show a "Location" prompt which the user
// can use to manually type the name of the file he wishes to select.
//
// The default bindings for this signal are <kbd>Control</kbd>-<kbd>L</kbd> with
// a path string of "" (the empty string). It is also bound to <kbd>/</kbd> with
// a path string of "/" (a slash): this lets you type / and immediately type a
// path name. On Unix systems, this is bound to <kbd>~</kbd> (tilde) with a path
// string of "~" itself for access to home directories.
func (v *FileChooserWidget) ConnectLocationPopup(f func(path string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "location-popup", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectLocationPopup), f)
}

// ConnectLocationPopupOnPaste is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser show a "Location" prompt when the user
// pastes into a GtkFileChooserWidget.
//
// The default binding for this signal is <kbd>Control</kbd>-<kbd>V</kbd>.
func (v *FileChooserWidget) ConnectLocationPopupOnPaste(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "location-popup-on-paste", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectLocationPopupOnPaste), f)
}

// ConnectLocationTogglePopup is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to toggle the visibility of a "Location" prompt which the user
// can use to manually type the name of the file he wishes to select.
//
// The default binding for this signal is <kbd>Control</kbd>-<kbd>L</kbd>.
func (v *FileChooserWidget) ConnectLocationTogglePopup(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "location-toggle-popup", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectLocationTogglePopup), f)
}

// ConnectPlacesShortcut is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to move the focus to the places sidebar.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>P</kbd>.
func (v *FileChooserWidget) ConnectPlacesShortcut(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "places-shortcut", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectPlacesShortcut), f)
}

// ConnectQuickBookmark is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser switch to the bookmark specified in
// the bookmark_index parameter. For example, if you have three bookmarks,
// you can pass 0, 1, 2 to this signal to switch to each of them, respectively.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>1</kbd>,
// <kbd>Alt</kbd>-<kbd>2</kbd>, etc. until <kbd>Alt</kbd>-<kbd>0</kbd>. Note
// that in the default binding, that <kbd>Alt</kbd>-<kbd>1</kbd> is actually
// defined to switch to the bookmark at index 0, and so on successively.
func (v *FileChooserWidget) ConnectQuickBookmark(f func(bookmarkIndex int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "quick-bookmark", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectQuickBookmark), f)
}

// ConnectRecentShortcut is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser show the Recent location.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>R</kbd>.
func (v *FileChooserWidget) ConnectRecentShortcut(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "recent-shortcut", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectRecentShortcut), f)
}

// ConnectSearchShortcut is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser show the search entry.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>S</kbd>.
func (v *FileChooserWidget) ConnectSearchShortcut(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "search-shortcut", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectSearchShortcut), f)
}

// ConnectShowHidden is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser display hidden files.
//
// The default binding for this signal is <kbd>Control</kbd>-<kbd>H</kbd>.
func (v *FileChooserWidget) ConnectShowHidden(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "show-hidden", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectShowHidden), f)
}

// ConnectUpFolder is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This is used to make the file chooser go to the parent of the current folder
// in the file hierarchy.
//
// The default binding for this signal is <kbd>Alt</kbd>-<kbd>Up</kbd>.
func (v *FileChooserWidget) ConnectUpFolder(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "up-folder", false, unsafe.Pointer(C._gotk4_gtk4_FileChooserWidget_ConnectUpFolder), f)
}

// NewFileChooserWidget creates a new GtkFileChooserWidget.
//
// This is a file chooser widget that can be embedded in custom windows,
// and it is the same widget that is used by GtkFileChooserDialog.
//
// The function takes the following parameters:
//
//   - action: open or save mode for the widget.
//
// The function returns the following values:
//
//   - fileChooserWidget: new GtkFileChooserWidget.
func NewFileChooserWidget(action FileChooserAction) *FileChooserWidget {
	var _arg1 C.GtkFileChooserAction // out
	var _cret *C.GtkWidget           // in

	_arg1 = C.GtkFileChooserAction(action)

	_cret = C.gtk_file_chooser_widget_new(_arg1)
	runtime.KeepAlive(action)

	var _fileChooserWidget *FileChooserWidget // out

	_fileChooserWidget = wrapFileChooserWidget(coreglib.Take(unsafe.Pointer(_cret)))

	return _fileChooserWidget
}

// FileFilter: GtkFileFilter filters files by name or mime type.
//
// GtkFileFilter can be used to restrict the files being shown
// in a GtkFileChooser. Files can be filtered based on their name
// (with gtk.FileFilter.AddPattern()) or on their mime type (with
// gtk.FileFilter.AddMIMEType()).
//
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that GtkFileFilter
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
//
// Normally, file filters are used by adding them to a GtkFileChooser (see
// gtk.FileChooser.AddFilter()), but it is also possible to manually use a file
// filter on any gtk.FilterListModel containing GFileInfo objects.
//
// # GtkFileFilter as GtkBuildable
//
// The GtkFileFilter implementation of the GtkBuildable interface supports
// adding rules using the <mime-types> and <patterns> elements and listing the
// rules within. Specifying a <mime-type> or <pattern> has the same effect as as
// calling gtk.FileFilter.AddMIMEType() or gtk.FileFilter.AddPattern().
//
// An example of a UI definition fragment specifying GtkFileFilter rules:
//
//	<object class="GtkFileFilter">
//	  <property name="name" translatable="yes">Text and Images</property>
//	  <mime-types>
//	    <mime-type>text/plain</mime-type>
//	    <mime-type>image/ *</mime-type>
//	  </mime-types>
//	  <patterns>
//	    <pattern>*.txt</pattern>
//	    <pattern>*.png</pattern>
//	  </patterns>
//	</object>.
type FileFilter struct {
	_ [0]func() // equal guard
	Filter

	*coreglib.Object
	Buildable
}

var (
	_ coreglib.Objector = (*FileFilter)(nil)
)

func wrapFileFilter(obj *coreglib.Object) *FileFilter {
	return &FileFilter{
		Filter: Filter{
			Object: obj,
		},
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalFileFilter(p uintptr) (interface{}, error) {
	return wrapFileFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFileFilter creates a new GtkFileFilter with no rules added to it.
//
// Such a filter doesn’t accept any files, so is not particularly useful until
// you add rules with gtk.FileFilter.AddMIMEType(), gtk.FileFilter.AddPattern(),
// or gtk.FileFilter.AddPixbufFormats().
//
// To create a filter that accepts any file, use:
//
//	GtkFileFilter *filter = gtk_file_filter_new ();
//	gtk_file_filter_add_pattern (filter, "*");.
//
// The function returns the following values:
//
//   - fileFilter: new GtkFileFilter.
func NewFileFilter() *FileFilter {
	var _cret *C.GtkFileFilter // in

	_cret = C.gtk_file_filter_new()

	var _fileFilter *FileFilter // out

	_fileFilter = wrapFileFilter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileFilter
}

// NewFileFilterFromGVariant: deserialize a file filter from a GVariant.
//
// The variant must be in the format produced by gtk.FileFilter.ToGVariant().
//
// The function takes the following parameters:
//
//   - variant: a{sv} GVariant.
//
// The function returns the following values:
//
//   - fileFilter: new GtkFileFilter object.
func NewFileFilterFromGVariant(variant *glib.Variant) *FileFilter {
	var _arg1 *C.GVariant      // out
	var _cret *C.GtkFileFilter // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(variant)))

	_cret = C.gtk_file_filter_new_from_gvariant(_arg1)
	runtime.KeepAlive(variant)

	var _fileFilter *FileFilter // out

	_fileFilter = wrapFileFilter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fileFilter
}

// AddMIMEType adds a rule allowing a given mime type to filter.
//
// The function takes the following parameters:
//
//   - mimeType: name of a MIME type.
func (filter *FileFilter) AddMIMEType(mimeType string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mimeType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_mime_type(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(mimeType)
}

// AddPattern adds a rule allowing a shell style glob to a filter.
//
// The function takes the following parameters:
//
//   - pattern: shell style glob.
func (filter *FileFilter) AddPattern(pattern string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_file_filter_add_pattern(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(pattern)
}

// AddPixbufFormats adds a rule allowing image files in the formats supported by
// GdkPixbuf.
//
// This is equivalent to calling gtk.FileFilter.AddMIMEType() for all the
// supported mime types.
func (filter *FileFilter) AddPixbufFormats() {
	var _arg0 *C.GtkFileFilter // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gtk_file_filter_add_pixbuf_formats(_arg0)
	runtime.KeepAlive(filter)
}

// Attributes gets the attributes that need to be filled in for the GFileInfo
// passed to this filter.
//
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of GtkFileChooser.
//
// The function returns the following values:
//
//   - utf8s: attributes.
func (filter *FileFilter) Attributes() []string {
	var _arg0 *C.GtkFileFilter // out
	var _cret **C.char         // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gtk_file_filter_get_attributes(_arg0)
	runtime.KeepAlive(filter)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// Name gets the human-readable name for the filter.
//
// See gtk.FileFilter.SetName().
//
// The function returns the following values:
//
//   - utf8 (optional): human-readable name of the filter, or NULL. This value
//     is owned by GTK and must not be modified or freed.
func (filter *FileFilter) Name() string {
	var _arg0 *C.GtkFileFilter // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gtk_file_filter_get_name(_arg0)
	runtime.KeepAlive(filter)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SetName sets a human-readable name of the filter.
//
// This is the string that will be displayed in the file chooser if there is a
// selectable list of filters.
//
// The function takes the following parameters:
//
//   - name (optional) for the filter, or NULL to remove any existing name.
func (filter *FileFilter) SetName(name string) {
	var _arg0 *C.GtkFileFilter // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_file_filter_set_name(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(name)
}

// ToGVariant: serialize a file filter to an a{sv} variant.
//
// The function returns the following values:
//
//   - variant: new, floating, GVariant.
func (filter *FileFilter) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkFileFilter // out
	var _cret *C.GVariant      // in

	_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gtk_file_filter_to_gvariant(_arg0)
	runtime.KeepAlive(filter)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// FilterOverrides contains methods that are overridable.
type FilterOverrides struct {
	// Strictness gets the known strictness of filters. If the strictness is not
	// known, GTK_FILTER_MATCH_SOME is returned.
	//
	// This value may change after emission of the Filter::changed signal.
	//
	// This function is meant purely for optimization purposes, filters can
	// choose to omit implementing it, but FilterListModel uses it.
	//
	// The function returns the following values:
	//
	//   - filterMatch strictness of self.
	Strictness func() FilterMatch
	// Match checks if the given item is matched by the filter or not.
	//
	// The function takes the following parameters:
	//
	//   - item (optional) to check.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the filter matches the item and a filter model should
	//     keep it, FALSE if not.
	Match func(item *coreglib.Object) bool
}

func defaultFilterOverrides(v *Filter) FilterOverrides {
	return FilterOverrides{
		Strictness: v.strictness,
		Match:      v.match,
	}
}

// Filter: GtkFilter object describes the filtering to be performed by a
// GtkFilterListModel.
//
// The model will use the filter to determine if it should include items or not
// by calling gtk.Filter.Match() for each item and only keeping the ones that
// the function returns TRUE for.
//
// Filters may change what items they match through their lifetime. In that
// case, they will emit the gtk.Filter::changed signal to notify that previous
// filter results are no longer valid and that items should be checked again via
// gtk.Filter.Match().
//
// GTK provides various pre-made filter implementations for common filtering
// operations. These filters often include properties that can be linked to
// various widgets to easily allow searches.
//
// However, in particular for large lists or complex search methods, it is also
// possible to subclass Filter and provide one's own filter.
type Filter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Filter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Filter, *FilterClass, FilterOverrides](
		GTypeFilter,
		initFilterClass,
		wrapFilter,
		defaultFilterOverrides,
	)
}

func initFilterClass(gclass unsafe.Pointer, overrides FilterOverrides, classInitFunc func(*FilterClass)) {
	pclass := (*C.GtkFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFilter))))

	if overrides.Strictness != nil {
		pclass.get_strictness = (*[0]byte)(C._gotk4_gtk4_FilterClass_get_strictness)
	}

	if overrides.Match != nil {
		pclass.match = (*[0]byte)(C._gotk4_gtk4_FilterClass_match)
	}

	if classInitFunc != nil {
		class := (*FilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFilter(obj *coreglib.Object) *Filter {
	return &Filter{
		Object: obj,
	}
}

func marshalFilter(p uintptr) (interface{}, error) {
	return wrapFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted whenever the filter changed.
//
// Users of the filter should then check items again via gtk.Filter.Match().
//
// GtkFilterListModel handles this signal automatically.
//
// Depending on the change parameter, not all items need to be checked, but only
// some. Refer to the gtk.FilterChange documentation for details.
func (self *Filter) ConnectChanged(f func(change FilterChange)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "changed", false, unsafe.Pointer(C._gotk4_gtk4_Filter_ConnectChanged), f)
}

// Changed emits the Filter::changed signal to notify all users of the filter
// that the filter changed. Users of the filter should then check items again
// via gtk_filter_match().
//
// Depending on the change parameter, not all items need to be changed, but only
// some. Refer to the FilterChange documentation for details.
//
// This function is intended for implementors of Filter subclasses and should
// not be called from other functions.
//
// The function takes the following parameters:
//
//   - change: how the filter changed.
func (self *Filter) Changed(change FilterChange) {
	var _arg0 *C.GtkFilter      // out
	var _arg1 C.GtkFilterChange // out

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkFilterChange(change)

	C.gtk_filter_changed(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(change)
}

// Strictness gets the known strictness of filters. If the strictness is not
// known, GTK_FILTER_MATCH_SOME is returned.
//
// This value may change after emission of the Filter::changed signal.
//
// This function is meant purely for optimization purposes, filters can choose
// to omit implementing it, but FilterListModel uses it.
//
// The function returns the following values:
//
//   - filterMatch strictness of self.
func (self *Filter) Strictness() FilterMatch {
	var _arg0 *C.GtkFilter     // out
	var _cret C.GtkFilterMatch // in

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_filter_get_strictness(_arg0)
	runtime.KeepAlive(self)

	var _filterMatch FilterMatch // out

	_filterMatch = FilterMatch(_cret)

	return _filterMatch
}

// Match checks if the given item is matched by the filter or not.
//
// The function takes the following parameters:
//
//   - item to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the filter matches the item and a filter model should keep
//     it, FALSE if not.
func (self *Filter) Match(item *coreglib.Object) bool {
	var _arg0 *C.GtkFilter // out
	var _arg1 C.gpointer   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item.Native()))

	_cret = C.gtk_filter_match(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(item)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Strictness gets the known strictness of filters. If the strictness is not
// known, GTK_FILTER_MATCH_SOME is returned.
//
// This value may change after emission of the Filter::changed signal.
//
// This function is meant purely for optimization purposes, filters can choose
// to omit implementing it, but FilterListModel uses it.
//
// The function returns the following values:
//
//   - filterMatch strictness of self.
func (self *Filter) strictness() FilterMatch {
	gclass := (*C.GtkFilterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_strictness

	var _arg0 *C.GtkFilter     // out
	var _cret C.GtkFilterMatch // in

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C._gotk4_gtk4_Filter_virtual_get_strictness(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)

	var _filterMatch FilterMatch // out

	_filterMatch = FilterMatch(_cret)

	return _filterMatch
}

// Match checks if the given item is matched by the filter or not.
//
// The function takes the following parameters:
//
//   - item (optional) to check.
//
// The function returns the following values:
//
//   - ok: TRUE if the filter matches the item and a filter model should keep
//     it, FALSE if not.
func (self *Filter) match(item *coreglib.Object) bool {
	gclass := (*C.GtkFilterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.match

	var _arg0 *C.GtkFilter // out
	var _arg1 C.gpointer   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item.Native()))

	_cret = C._gotk4_gtk4_Filter_virtual_match(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(item)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FilterListModelOverrides contains methods that are overridable.
type FilterListModelOverrides struct {
}

func defaultFilterListModelOverrides(v *FilterListModel) FilterListModelOverrides {
	return FilterListModelOverrides{}
}

// FilterListModel: GtkFilterListModel is a list model that filters the elements
// of the underlying model according to a GtkFilter.
//
// It hides some elements from the other model according to criteria given by a
// GtkFilter.
//
// The model can be set up to do incremental searching, so that filtering long
// lists doesn't block the UI. See gtk.FilterListModel.SetIncremental() for
// details.
type FilterListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*FilterListModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FilterListModel, *FilterListModelClass, FilterListModelOverrides](
		GTypeFilterListModel,
		initFilterListModelClass,
		wrapFilterListModel,
		defaultFilterListModelOverrides,
	)
}

func initFilterListModelClass(gclass unsafe.Pointer, overrides FilterListModelOverrides, classInitFunc func(*FilterListModelClass)) {
	if classInitFunc != nil {
		class := (*FilterListModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFilterListModel(obj *coreglib.Object) *FilterListModel {
	return &FilterListModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalFilterListModel(p uintptr) (interface{}, error) {
	return wrapFilterListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFilterListModel creates a new GtkFilterListModel that will filter model
// using the given filter.
//
// The function takes the following parameters:
//
//   - model (optional) to sort, or NULL.
//   - filter (optional) or NULL to not filter items.
//
// The function returns the following values:
//
//   - filterListModel: new GtkFilterListModel.
func NewFilterListModel(model gio.ListModeller, filter *Filter) *FilterListModel {
	var _arg1 *C.GListModel         // out
	var _arg2 *C.GtkFilter          // out
	var _cret *C.GtkFilterListModel // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	if filter != nil {
		_arg2 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(filter).Native()))
	}

	_cret = C.gtk_filter_list_model_new(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(filter)

	var _filterListModel *FilterListModel // out

	_filterListModel = wrapFilterListModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _filterListModel
}

// Filter gets the GtkFilter currently set on self.
//
// The function returns the following values:
//
//   - filter (optional) currently in use or NULL if the list isn't filtered.
func (self *FilterListModel) Filter() *Filter {
	var _arg0 *C.GtkFilterListModel // out
	var _cret *C.GtkFilter          // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_filter_list_model_get_filter(_arg0)
	runtime.KeepAlive(self)

	var _filter *Filter // out

	if _cret != nil {
		_filter = wrapFilter(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _filter
}

// Incremental returns whether incremental filtering is enabled.
//
// See gtk.FilterListModel.SetIncremental().
//
// The function returns the following values:
//
//   - ok: TRUE if incremental filtering is enabled.
func (self *FilterListModel) Incremental() bool {
	var _arg0 *C.GtkFilterListModel // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_filter_list_model_get_incremental(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Model gets the model currently filtered or NULL if none.
//
// The function returns the following values:
//
//   - listModel (optional): model that gets filtered.
func (self *FilterListModel) Model() *gio.ListModel {
	var _arg0 *C.GtkFilterListModel // out
	var _cret *C.GListModel         // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_filter_list_model_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// Pending returns the number of items that have not been filtered yet.
//
// You can use this value to check if self is busy filtering by comparing the
// return value to 0 or you can compute the percentage of the filter remaining
// by dividing the return value by the total number of items in the underlying
// model:
//
//	pending = gtk_filter_list_model_get_pending (self);
//	model = gtk_filter_list_model_get_model (self);
//	percentage = pending / (double) g_list_model_get_n_items (model);
//
// If no filter operation is ongoing - in particular when
// gtk.FilterListModel:incremental is FALSE - this function returns 0.
//
// The function returns the following values:
//
//   - guint: number of items not yet filtered.
func (self *FilterListModel) Pending() uint {
	var _arg0 *C.GtkFilterListModel // out
	var _cret C.guint               // in

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_filter_list_model_get_pending(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetFilter sets the filter used to filter items.
//
// The function takes the following parameters:
//
//   - filter (optional) to use or NULL to not filter items.
func (self *FilterListModel) SetFilter(filter *Filter) {
	var _arg0 *C.GtkFilterListModel // out
	var _arg1 *C.GtkFilter          // out

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if filter != nil {
		_arg1 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	}

	C.gtk_filter_list_model_set_filter(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(filter)
}

// SetIncremental sets the filter model to do an incremental sort.
//
// When incremental filtering is enabled, the GtkFilterListModel will not
// run filters immediately, but will instead queue an idle handler that
// incrementally filters the items and adds them to the list. This of course
// means that items are not instantly added to the list, but only appear
// incrementally.
//
// When your filter blocks the UI while filtering, you might consider turning
// this on. Depending on your model and filters, this may become interesting
// around 10,000 to 100,000 items.
//
// By default, incremental filtering is disabled.
//
// See gtk.FilterListModel.GetPending() for progress information about an
// ongoing incremental filtering operation.
//
// The function takes the following parameters:
//
//   - incremental: TRUE to enable incremental filtering.
func (self *FilterListModel) SetIncremental(incremental bool) {
	var _arg0 *C.GtkFilterListModel // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if incremental {
		_arg1 = C.TRUE
	}

	C.gtk_filter_list_model_set_incremental(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(incremental)
}

// SetModel sets the model to be filtered.
//
// Note that GTK makes no effort to ensure that model conforms to the item type
// of self. It assumes that the caller knows what they are doing and have set up
// an appropriate filter to ensure that item types match.
//
// The function takes the following parameters:
//
//   - model (optional) to be filtered.
func (self *FilterListModel) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkFilterListModel // out
	var _arg1 *C.GListModel         // out

	_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_filter_list_model_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// FixedOverrides contains methods that are overridable.
type FixedOverrides struct {
}

func defaultFixedOverrides(v *Fixed) FixedOverrides {
	return FixedOverrides{}
}

// Fixed: GtkFixed places its child widgets at fixed positions and with fixed
// sizes.
//
// GtkFixed performs no automatic layout management.
//
// For most applications, you should not use this container! It keeps you from
// having to learn about the other GTK containers, but it results in broken
// applications. With GtkFixed, the following things will result in truncated
// text, overlapping widgets, and other display bugs:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a
// larger font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, GtkFixed does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately for the text direction, e.g. to put labels to the right of
// the thing they label when using an RTL language, but it can’t do that with
// GtkFixed. So if you need to reorder widgets depending on the text direction,
// you would need to manually detect it and adjust child positions accordingly.
//
// Finally, fixed positioning makes it kind of annoying to add/remove UI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
//
// If you know none of these things are an issue for your application,
// and prefer the simplicity of GtkFixed, by all means use the widget. But you
// should be aware of the tradeoffs.
type Fixed struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Fixed)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Fixed, *FixedClass, FixedOverrides](
		GTypeFixed,
		initFixedClass,
		wrapFixed,
		defaultFixedOverrides,
	)
}

func initFixedClass(gclass unsafe.Pointer, overrides FixedOverrides, classInitFunc func(*FixedClass)) {
	if classInitFunc != nil {
		class := (*FixedClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFixed(obj *coreglib.Object) *Fixed {
	return &Fixed{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalFixed(p uintptr) (interface{}, error) {
	return wrapFixed(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFixed creates a new GtkFixed.
//
// The function returns the following values:
//
//   - fixed: new GtkFixed.
func NewFixed() *Fixed {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_fixed_new()

	var _fixed *Fixed // out

	_fixed = wrapFixed(coreglib.Take(unsafe.Pointer(_cret)))

	return _fixed
}

// ChildPosition retrieves the translation transformation of the given child
// GtkWidget in the GtkFixed.
//
// See also: gtk.Fixed.GetChildTransform().
//
// The function takes the following parameters:
//
//   - widget: child of fixed.
//
// The function returns the following values:
//
//   - x: horizontal position of the widget.
//   - y: vertical position of the widget.
func (fixed *Fixed) ChildPosition(widget Widgetter) (x, y float64) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // in
	var _arg3 C.double     // in

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(coreglib.InternObject(fixed).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_fixed_get_child_position(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(fixed)
	runtime.KeepAlive(widget)

	var _x float64 // out
	var _y float64 // out

	_x = float64(_arg2)
	_y = float64(_arg3)

	return _x, _y
}

// ChildTransform retrieves the transformation for widget set using
// gtk_fixed_set_child_transform().
//
// The function takes the following parameters:
//
//   - widget: GtkWidget, child of fixed.
//
// The function returns the following values:
//
//   - transform (optional): GskTransform or NULL in case no transform has been
//     set on widget.
func (fixed *Fixed) ChildTransform(widget Widgetter) *gsk.Transform {
	var _arg0 *C.GtkFixed     // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GskTransform // in

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(coreglib.InternObject(fixed).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_fixed_get_child_transform(_arg0, _arg1)
	runtime.KeepAlive(fixed)
	runtime.KeepAlive(widget)

	var _transform *gsk.Transform // out

	if _cret != nil {
		_transform = (*gsk.Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gsk_transform_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_transform)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gsk_transform_unref((*C.GskTransform)(intern.C))
			},
		)
	}

	return _transform
}

// Move sets a translation transformation to the given x and y coordinates to
// the child widget of the GtkFixed.
//
// The function takes the following parameters:
//
//   - widget: child widget.
//   - x: horizontal position to move the widget to.
//   - y: vertical position to move the widget to.
func (fixed *Fixed) Move(widget Widgetter, x, y float64) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(coreglib.InternObject(fixed).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)

	C.gtk_fixed_move(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(fixed)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// Put adds a widget to a GtkFixed at the given position.
//
// The function takes the following parameters:
//
//   - widget to add.
//   - x: horizontal position to place the widget at.
//   - y: vertical position to place the widget at.
func (fixed *Fixed) Put(widget Widgetter, x, y float64) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(coreglib.InternObject(fixed).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)

	C.gtk_fixed_put(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(fixed)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
}

// Remove removes a child from fixed.
//
// The function takes the following parameters:
//
//   - widget: child widget to remove.
func (fixed *Fixed) Remove(widget Widgetter) {
	var _arg0 *C.GtkFixed  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(coreglib.InternObject(fixed).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_fixed_remove(_arg0, _arg1)
	runtime.KeepAlive(fixed)
	runtime.KeepAlive(widget)
}

// SetChildTransform sets the transformation for widget.
//
// This is a convenience function that retrieves the gtk.FixedLayoutChild
// instance associated to widget and calls gtk.FixedLayoutChild.SetTransform().
//
// The function takes the following parameters:
//
//   - widget: GtkWidget, child of fixed.
//   - transform (optional): transformation assigned to widget or NULL to reset
//     widget's transform.
func (fixed *Fixed) SetChildTransform(widget Widgetter, transform *gsk.Transform) {
	var _arg0 *C.GtkFixed     // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.GskTransform // out

	_arg0 = (*C.GtkFixed)(unsafe.Pointer(coreglib.InternObject(fixed).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if transform != nil {
		_arg2 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))
	}

	C.gtk_fixed_set_child_transform(_arg0, _arg1, _arg2)
	runtime.KeepAlive(fixed)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(transform)
}

// FixedLayoutOverrides contains methods that are overridable.
type FixedLayoutOverrides struct {
}

func defaultFixedLayoutOverrides(v *FixedLayout) FixedLayoutOverrides {
	return FixedLayoutOverrides{}
}

// FixedLayout: GtkFixedLayout is a layout manager which can place child widgets
// at fixed positions.
//
// Most applications should never use this layout manager; fixed positioning
// and sizing requires constant recalculations on where children need to
// be positioned and sized. Other layout managers perform this kind of work
// internally so that application developers don't need to do it. Specifically,
// widgets positioned in a fixed layout manager will need to take into account:
//
// - Themes, which may change widget sizes.
//
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a
// larger font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
//
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
//
// In addition, GtkFixedLayout does not pay attention to text direction and thus
// may produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately depending on the text direction, e.g. to put labels to the
// right of the thing they label when using an RTL language; GtkFixedLayout
// won't be able to do that for you.
//
// Finally, fixed positioning makes it kind of annoying to add/remove UI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
type FixedLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*FixedLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FixedLayout, *FixedLayoutClass, FixedLayoutOverrides](
		GTypeFixedLayout,
		initFixedLayoutClass,
		wrapFixedLayout,
		defaultFixedLayoutOverrides,
	)
}

func initFixedLayoutClass(gclass unsafe.Pointer, overrides FixedLayoutOverrides, classInitFunc func(*FixedLayoutClass)) {
	if classInitFunc != nil {
		class := (*FixedLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFixedLayout(obj *coreglib.Object) *FixedLayout {
	return &FixedLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalFixedLayout(p uintptr) (interface{}, error) {
	return wrapFixedLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFixedLayout creates a new GtkFixedLayout.
//
// The function returns the following values:
//
//   - fixedLayout: newly created GtkFixedLayout.
func NewFixedLayout() *FixedLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_fixed_layout_new()

	var _fixedLayout *FixedLayout // out

	_fixedLayout = wrapFixedLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fixedLayout
}

// FixedLayoutChildOverrides contains methods that are overridable.
type FixedLayoutChildOverrides struct {
}

func defaultFixedLayoutChildOverrides(v *FixedLayoutChild) FixedLayoutChildOverrides {
	return FixedLayoutChildOverrides{}
}

// FixedLayoutChild: GtkLayoutChild subclass for children in a GtkFixedLayout.
type FixedLayoutChild struct {
	_ [0]func() // equal guard
	LayoutChild
}

var (
	_ LayoutChilder = (*FixedLayoutChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FixedLayoutChild, *FixedLayoutChildClass, FixedLayoutChildOverrides](
		GTypeFixedLayoutChild,
		initFixedLayoutChildClass,
		wrapFixedLayoutChild,
		defaultFixedLayoutChildOverrides,
	)
}

func initFixedLayoutChildClass(gclass unsafe.Pointer, overrides FixedLayoutChildOverrides, classInitFunc func(*FixedLayoutChildClass)) {
	if classInitFunc != nil {
		class := (*FixedLayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFixedLayoutChild(obj *coreglib.Object) *FixedLayoutChild {
	return &FixedLayoutChild{
		LayoutChild: LayoutChild{
			Object: obj,
		},
	}
}

func marshalFixedLayoutChild(p uintptr) (interface{}, error) {
	return wrapFixedLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Transform retrieves the transformation of the child.
//
// The function returns the following values:
//
//   - transform (optional): GskTransform.
func (child *FixedLayoutChild) Transform() *gsk.Transform {
	var _arg0 *C.GtkFixedLayoutChild // out
	var _cret *C.GskTransform        // in

	_arg0 = (*C.GtkFixedLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_fixed_layout_child_get_transform(_arg0)
	runtime.KeepAlive(child)

	var _transform *gsk.Transform // out

	if _cret != nil {
		_transform = (*gsk.Transform)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gsk_transform_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_transform)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gsk_transform_unref((*C.GskTransform)(intern.C))
			},
		)
	}

	return _transform
}

// SetTransform sets the transformation of the child of a GtkFixedLayout.
//
// The function takes the following parameters:
//
//   - transform: GskTransform.
func (child *FixedLayoutChild) SetTransform(transform *gsk.Transform) {
	var _arg0 *C.GtkFixedLayoutChild // out
	var _arg1 *C.GskTransform        // out

	_arg0 = (*C.GtkFixedLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))

	C.gtk_fixed_layout_child_set_transform(_arg0, _arg1)
	runtime.KeepAlive(child)
	runtime.KeepAlive(transform)
}

// FlattenListModelOverrides contains methods that are overridable.
type FlattenListModelOverrides struct {
}

func defaultFlattenListModelOverrides(v *FlattenListModel) FlattenListModelOverrides {
	return FlattenListModelOverrides{}
}

// FlattenListModel: GtkFlattenListModel is a list model that concatenates other
// list models.
//
// GtkFlattenListModel takes a list model containing list models, and flattens
// it into a single model.
type FlattenListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*FlattenListModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FlattenListModel, *FlattenListModelClass, FlattenListModelOverrides](
		GTypeFlattenListModel,
		initFlattenListModelClass,
		wrapFlattenListModel,
		defaultFlattenListModelOverrides,
	)
}

func initFlattenListModelClass(gclass unsafe.Pointer, overrides FlattenListModelOverrides, classInitFunc func(*FlattenListModelClass)) {
	if classInitFunc != nil {
		class := (*FlattenListModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFlattenListModel(obj *coreglib.Object) *FlattenListModel {
	return &FlattenListModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalFlattenListModel(p uintptr) (interface{}, error) {
	return wrapFlattenListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFlattenListModel creates a new GtkFlattenListModel that flattens list.
//
// The function takes the following parameters:
//
//   - model (optional) to be flattened.
//
// The function returns the following values:
//
//   - flattenListModel: new GtkFlattenListModel.
func NewFlattenListModel(model gio.ListModeller) *FlattenListModel {
	var _arg1 *C.GListModel          // out
	var _cret *C.GtkFlattenListModel // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_flatten_list_model_new(_arg1)
	runtime.KeepAlive(model)

	var _flattenListModel *FlattenListModel // out

	_flattenListModel = wrapFlattenListModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _flattenListModel
}

// Model gets the model set via gtk_flatten_list_model_set_model().
//
// The function returns the following values:
//
//   - listModel (optional): model flattened by self.
func (self *FlattenListModel) Model() *gio.ListModel {
	var _arg0 *C.GtkFlattenListModel // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_flatten_list_model_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// ModelForItem returns the model containing the item at the given position.
//
// The function takes the following parameters:
//
//   - position: position.
//
// The function returns the following values:
//
//   - listModel: model containing the item at position.
func (self *FlattenListModel) ModelForItem(position uint) *gio.ListModel {
	var _arg0 *C.GtkFlattenListModel // out
	var _arg1 C.guint                // out
	var _cret *C.GListModel          // in

	_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	_cret = C.gtk_flatten_list_model_get_model_for_item(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// SetModel sets a new model to be flattened.
//
// The function takes the following parameters:
//
//   - model (optional): new model or NULL.
func (self *FlattenListModel) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkFlattenListModel // out
	var _arg1 *C.GListModel          // out

	_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_flatten_list_model_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// FlowBox: GtkFlowBox puts child widgets in reflowing grid.
//
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
//
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
//
// The size request of a GtkFlowBox alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a GtkScrolledWindow to enable that.
//
// The children of a GtkFlowBox can be dynamically sorted and filtered.
//
// Although a GtkFlowBox must have only GtkFlowBoxChild children, you can add
// any kind of widget to it via gtk.FlowBox.Insert(), and a GtkFlowBoxChild
// widget will automatically be inserted between the box and the widget.
//
// Also see gtk.ListBox.
//
// CSS nodes
//
//	flowbox
//	├── flowboxchild
//	│   ╰── <child>
//	├── flowboxchild
//	│   ╰── <child>
//	┊
//	╰── [rubberband]
//
// GtkFlowBox uses a single CSS node with name flowbox. GtkFlowBoxChild uses a
// single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
//
// # Accessibility
//
// GtkFlowBox uses the GTK_ACCESSIBLE_ROLE_GRID role, and GtkFlowBoxChild uses
// the GTK_ACCESSIBLE_ROLE_GRID_CELL role.
type FlowBox struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*FlowBox)(nil)
	_ coreglib.Objector = (*FlowBox)(nil)
)

func wrapFlowBox(obj *coreglib.Object) *FlowBox {
	return &FlowBox{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalFlowBox(p uintptr) (interface{}, error) {
	return wrapFlowBox(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateCursorChild is emitted when the user activates the box.
//
// This is a keybinding signal (class.SignalAction.html).
func (box *FlowBox) ConnectActivateCursorChild(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "activate-cursor-child", false, unsafe.Pointer(C._gotk4_gtk4_FlowBox_ConnectActivateCursorChild), f)
}

// ConnectChildActivated is emitted when a child has been activated by the user.
func (box *FlowBox) ConnectChildActivated(f func(child *FlowBoxChild)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "child-activated", false, unsafe.Pointer(C._gotk4_gtk4_FlowBox_ConnectChildActivated), f)
}

// ConnectMoveCursor is emitted when the user initiates a cursor movement.
//
// This is a keybinding signal (class.SignalAction.html). Applications should
// not connect to it, but may emit it with g_signal_emit_by_name() if they need
// to control the cursor programmatically.
//
// The default bindings for this signal come in two variants, the variant with
// the Shift modifier extends the selection, the variant without the Shift
// modifier does not. There are too many key combinations to list them all here.
//
// - <kbd>←</kbd>, <kbd>→</kbd>, <kbd>↑</kbd>, <kbd>↓</kbd> move by individual
// children
//
// - <kbd>Home</kbd>, <kbd>End</kbd> move to the ends of the box
//
// - <kbd>PgUp</kbd>, <kbd>PgDn</kbd> move vertically by pages.
func (box *FlowBox) ConnectMoveCursor(f func(step MovementStep, count int, extend, modify bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk4_FlowBox_ConnectMoveCursor), f)
}

// ConnectSelectAll is emitted to select all children of the box, if the
// selection mode permits it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal is <kbd>Ctrl</kbd>-<kbd>a</kbd>.
func (box *FlowBox) ConnectSelectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_FlowBox_ConnectSelectAll), f)
}

// ConnectSelectedChildrenChanged is emitted when the set of selected children
// changes.
//
// Use gtk.FlowBox.SelectedForEach() or gtk.FlowBox.GetSelectedChildren() to
// obtain the selected children.
func (box *FlowBox) ConnectSelectedChildrenChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "selected-children-changed", false, unsafe.Pointer(C._gotk4_gtk4_FlowBox_ConnectSelectedChildrenChanged), f)
}

// ConnectToggleCursorChild is emitted to toggle the selection of the child that
// has the focus.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is <kbd>Ctrl</kbd>-<kbd>Space</kbd>.
func (box *FlowBox) ConnectToggleCursorChild(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "toggle-cursor-child", false, unsafe.Pointer(C._gotk4_gtk4_FlowBox_ConnectToggleCursorChild), f)
}

// ConnectUnselectAll is emitted to unselect all children of the box, if the
// selection mode permits it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal is
// <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>a</kbd>.
func (box *FlowBox) ConnectUnselectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk4_FlowBox_ConnectUnselectAll), f)
}

// NewFlowBox creates a GtkFlowBox.
//
// The function returns the following values:
//
//   - flowBox: new GtkFlowBox.
func NewFlowBox() *FlowBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_flow_box_new()

	var _flowBox *FlowBox // out

	_flowBox = wrapFlowBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _flowBox
}

// BindModel binds model to box.
//
// If box was already bound to a model, that previous binding is destroyed.
//
// The contents of box are cleared and then filled with widgets that represent
// items from model. box is updated whenever model changes. If model is NULL,
// box is left empty.
//
// It is undefined to add or remove widgets directly (for example, with
// gtk.FlowBox.Insert()) while box is bound to a model.
//
// Note that using a model is incompatible with the filtering and sorting
// functionality in GtkFlowBox. When using a model, filtering and sorting should
// be implemented by the model.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to be bound to box.
//   - createWidgetFunc: function that creates widgets for items.
func (box *FlowBox) BindModel(model gio.ListModeller, createWidgetFunc FlowBoxCreateWidgetFunc) {
	var _arg0 *C.GtkFlowBox                // out
	var _arg1 *C.GListModel                // out
	var _arg2 C.GtkFlowBoxCreateWidgetFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}
	_arg2 = (*[0]byte)(C._gotk4_gtk4_FlowBoxCreateWidgetFunc)
	_arg3 = C.gpointer(gbox.Assign(createWidgetFunc))
	_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_flow_box_bind_model(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(box)
	runtime.KeepAlive(model)
	runtime.KeepAlive(createWidgetFunc)
}

// ActivateOnSingleClick returns whether children activate on single clicks.
//
// The function returns the following values:
//
//   - ok: TRUE if children are activated on single click, FALSE otherwise.
func (box *FlowBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_activate_on_single_click(_arg0)
	runtime.KeepAlive(box)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildAtIndex gets the nth child in the box.
//
// The function takes the following parameters:
//
//   - idx: position of the child.
//
// The function returns the following values:
//
//   - flowBoxChild (optional): child widget, which will always be a
//     GtkFlowBoxChild or NULL in case no child widget with the given index
//     exists.
func (box *FlowBox) ChildAtIndex(idx int) *FlowBoxChild {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.int              // out
	var _cret *C.GtkFlowBoxChild // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.int(idx)

	_cret = C.gtk_flow_box_get_child_at_index(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(idx)

	var _flowBoxChild *FlowBoxChild // out

	if _cret != nil {
		_flowBoxChild = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _flowBoxChild
}

// ChildAtPos gets the child in the (x, y) position.
//
// Both x and y are assumed to be relative to the origin of box.
//
// The function takes the following parameters:
//
//   - x coordinate of the child.
//   - y coordinate of the child.
//
// The function returns the following values:
//
//   - flowBoxChild (optional): child widget, which will always be a
//     GtkFlowBoxChild or NULL in case no child widget exists for the given x
//     and y coordinates.
func (box *FlowBox) ChildAtPos(x, y int) *FlowBoxChild {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out
	var _cret *C.GtkFlowBoxChild // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_flow_box_get_child_at_pos(_arg0, _arg1, _arg2)
	runtime.KeepAlive(box)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _flowBoxChild *FlowBoxChild // out

	if _cret != nil {
		_flowBoxChild = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _flowBoxChild
}

// ColumnSpacing gets the horizontal spacing.
//
// The function returns the following values:
//
//   - guint: horizontal spacing.
func (box *FlowBox) ColumnSpacing() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_column_spacing(_arg0)
	runtime.KeepAlive(box)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Homogeneous returns whether the box is homogeneous.
//
// The function returns the following values:
//
//   - ok: TRUE if the box is homogeneous.
func (box *FlowBox) Homogeneous() bool {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_homogeneous(_arg0)
	runtime.KeepAlive(box)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxChildrenPerLine gets the maximum number of children per line.
//
// The function returns the following values:
//
//   - guint: maximum number of children per line.
func (box *FlowBox) MaxChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_max_children_per_line(_arg0)
	runtime.KeepAlive(box)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MinChildrenPerLine gets the minimum number of children per line.
//
// The function returns the following values:
//
//   - guint: minimum number of children per line.
func (box *FlowBox) MinChildrenPerLine() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_min_children_per_line(_arg0)
	runtime.KeepAlive(box)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RowSpacing gets the vertical spacing.
//
// The function returns the following values:
//
//   - guint: vertical spacing.
func (box *FlowBox) RowSpacing() uint {
	var _arg0 *C.GtkFlowBox // out
	var _cret C.guint       // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_row_spacing(_arg0)
	runtime.KeepAlive(box)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SelectedChildren creates a list of all selected children.
//
// The function returns the following values:
//
//   - list: A GList containing the GtkWidget for each selected child. Free with
//     g_list_free() when done.
func (box *FlowBox) SelectedChildren() []*FlowBoxChild {
	var _arg0 *C.GtkFlowBox // out
	var _cret *C.GList      // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_selected_children(_arg0)
	runtime.KeepAlive(box)

	var _list []*FlowBoxChild // out

	_list = make([]*FlowBoxChild, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkFlowBoxChild)(v)
		var dst *FlowBoxChild // out
		dst = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// SelectionMode gets the selection mode of box.
//
// The function returns the following values:
//
//   - selectionMode: GtkSelectionMode.
func (box *FlowBox) SelectionMode() SelectionMode {
	var _arg0 *C.GtkFlowBox      // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_flow_box_get_selection_mode(_arg0)
	runtime.KeepAlive(box)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// Insert inserts the widget into box at position.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// If position is -1, or larger than the total number of children in the box,
// then the widget will be appended to the end.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget to add.
//   - position to insert child in.
func (box *FlowBox) Insert(widget Widgetter, position int) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.int(position)

	C.gtk_flow_box_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(box)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(position)
}

// InvalidateFilter updates the filtering for all children.
//
// Call this function when the result of the filter function on the box is
// changed due ot an external factor. For instance, this would be used if the
// filter function just looked for a specific search term, and the entry with
// the string has changed.
func (box *FlowBox) InvalidateFilter() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_flow_box_invalidate_filter(_arg0)
	runtime.KeepAlive(box)
}

// InvalidateSort updates the sorting for all children.
//
// Call this when the result of the sort function on box is changed due to an
// external factor.
func (box *FlowBox) InvalidateSort() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_flow_box_invalidate_sort(_arg0)
	runtime.KeepAlive(box)
}

// Remove removes a child from box.
//
// The function takes the following parameters:
//
//   - widget: child widget to remove.
func (box *FlowBox) Remove(widget Widgetter) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_flow_box_remove(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(widget)
}

// SelectAll: select all children of box, if the selection mode allows it.
func (box *FlowBox) SelectAll() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_flow_box_select_all(_arg0)
	runtime.KeepAlive(box)
}

// SelectChild selects a single child of box, if the selection mode allows it.
//
// The function takes the following parameters:
//
//   - child of box.
func (box *FlowBox) SelectChild(child *FlowBoxChild) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_flow_box_select_child(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// SelectedForEach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
//
// The function takes the following parameters:
//
//   - fn: function to call for each selected child.
func (box *FlowBox) SelectedForEach(fn FlowBoxForEachFunc) {
	var _arg0 *C.GtkFlowBox           // out
	var _arg1 C.GtkFlowBoxForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_FlowBoxForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_flow_box_selected_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(box)
	runtime.KeepAlive(fn)
}

// SetActivateOnSingleClick: if single is TRUE, children will be activated when
// you click on them, otherwise you need to double-click.
//
// The function takes the following parameters:
//
//   - single: TRUE to emit child-activated on a single click.
func (box *FlowBox) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_flow_box_set_activate_on_single_click(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(single)
}

// SetColumnSpacing sets the horizontal space to add between children.
//
// The function takes the following parameters:
//
//   - spacing to use.
func (box *FlowBox) SetColumnSpacing(spacing uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_flow_box_set_column_spacing(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(spacing)
}

// SetFilterFunc: by setting a filter function on the box one can decide
// dynamically which of the children to show.
//
// For instance, to implement a search function that only shows the children
// matching the search terms.
//
// The filter_func will be called for each child after the call,
// and it will continue to be called each time a child changes (via
// gtk.FlowBoxChild.Changed()) or when gtk.FlowBox.InvalidateFilter() is called.
//
// Note that using a filter function is incompatible with using a model (see
// gtk.FlowBox.BindModel()).
//
// The function takes the following parameters:
//
//   - filterFunc (optional): callback that lets you filter which children to
//     show.
func (box *FlowBox) SetFilterFunc(filterFunc FlowBoxFilterFunc) {
	var _arg0 *C.GtkFlowBox          // out
	var _arg1 C.GtkFlowBoxFilterFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if filterFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_FlowBoxFilterFunc)
		_arg2 = C.gpointer(gbox.Assign(filterFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_flow_box_set_filter_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(box)
	runtime.KeepAlive(filterFunc)
}

// SetHAdjustment hooks up an adjustment to focus handling in box.
//
// The adjustment is also used for autoscrolling during rubberband selection.
// See gtk.ScrolledWindow.GetHAdjustment() for a typical way of obtaining
// the adjustment, and gtk.FlowBox.SetVAdjustment() for setting the vertical
// adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
//
// The function takes the following parameters:
//
//   - adjustment which should be adjusted when the focus is moved among the
//     descendents of container.
func (box *FlowBox) SetHAdjustment(adjustment *Adjustment) {
	var _arg0 *C.GtkFlowBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	C.gtk_flow_box_set_hadjustment(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(adjustment)
}

// SetHomogeneous sets whether or not all children of box are given equal space
// in the box.
//
// The function takes the following parameters:
//
//   - homogeneous: TRUE to create equal allotments, FALSE for variable
//     allotments.
func (box *FlowBox) SetHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_flow_box_set_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(homogeneous)
}

// SetMaxChildrenPerLine sets the maximum number of children to request and
// allocate space for in box’s orientation.
//
// Setting the maximum number of children per line limits the overall natural
// size request to be no more than n_children children long in the given
// orientation.
//
// The function takes the following parameters:
//
//   - nChildren: maximum number of children per line.
func (box *FlowBox) SetMaxChildrenPerLine(nChildren uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_max_children_per_line(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(nChildren)
}

// SetMinChildrenPerLine sets the minimum number of children to line up in box’s
// orientation before flowing.
//
// The function takes the following parameters:
//
//   - nChildren: minimum number of children per line.
func (box *FlowBox) SetMinChildrenPerLine(nChildren uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.guint(nChildren)

	C.gtk_flow_box_set_min_children_per_line(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(nChildren)
}

// SetRowSpacing sets the vertical space to add between children.
//
// The function takes the following parameters:
//
//   - spacing to use.
func (box *FlowBox) SetRowSpacing(spacing uint) {
	var _arg0 *C.GtkFlowBox // out
	var _arg1 C.guint       // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_flow_box_set_row_spacing(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(spacing)
}

// SetSelectionMode sets how selection works in box.
//
// The function takes the following parameters:
//
//   - mode: new selection mode.
func (box *FlowBox) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.GtkSelectionMode(mode)

	C.gtk_flow_box_set_selection_mode(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(mode)
}

// SetSortFunc: by setting a sort function on the box, one can dynamically
// reorder the children of the box, based on the contents of the children.
//
// The sort_func will be called for each child after the call, and will continue
// to be called each time a child changes (via gtk.FlowBoxChild.Changed()) and
// when gtk.FlowBox.InvalidateSort() is called.
//
// Note that using a sort function is incompatible with using a model (see
// gtk.FlowBox.BindModel()).
//
// The function takes the following parameters:
//
//   - sortFunc (optional): sort function.
func (box *FlowBox) SetSortFunc(sortFunc FlowBoxSortFunc) {
	var _arg0 *C.GtkFlowBox        // out
	var _arg1 C.GtkFlowBoxSortFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if sortFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_FlowBoxSortFunc)
		_arg2 = C.gpointer(gbox.Assign(sortFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_flow_box_set_sort_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(box)
	runtime.KeepAlive(sortFunc)
}

// SetVAdjustment hooks up an adjustment to focus handling in box.
//
// The adjustment is also used for autoscrolling during rubberband selection.
// See gtk.ScrolledWindow.GetVAdjustment() for a typical way of obtaining the
// adjustment, and gtk.FlowBox.SetHAdjustment() for setting the horizontal
// adjustment.
//
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
//
// The function takes the following parameters:
//
//   - adjustment which should be adjusted when the focus is moved among the
//     descendents of container.
func (box *FlowBox) SetVAdjustment(adjustment *Adjustment) {
	var _arg0 *C.GtkFlowBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	C.gtk_flow_box_set_vadjustment(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(adjustment)
}

// UnselectAll: unselect all children of box, if the selection mode allows it.
func (box *FlowBox) UnselectAll() {
	var _arg0 *C.GtkFlowBox // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_flow_box_unselect_all(_arg0)
	runtime.KeepAlive(box)
}

// UnselectChild unselects a single child of box, if the selection mode allows
// it.
//
// The function takes the following parameters:
//
//   - child of box.
func (box *FlowBox) UnselectChild(child *FlowBoxChild) {
	var _arg0 *C.GtkFlowBox      // out
	var _arg1 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_flow_box_unselect_child(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// FlowBoxChildOverrides contains methods that are overridable.
type FlowBoxChildOverrides struct {
	Activate func()
}

func defaultFlowBoxChildOverrides(v *FlowBoxChild) FlowBoxChildOverrides {
	return FlowBoxChildOverrides{
		Activate: v.activate,
	}
}

// FlowBoxChild: GtkFlowBoxChild is the kind of widget that can be added to a
// GtkFlowBox.
type FlowBoxChild struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*FlowBoxChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*FlowBoxChild, *FlowBoxChildClass, FlowBoxChildOverrides](
		GTypeFlowBoxChild,
		initFlowBoxChildClass,
		wrapFlowBoxChild,
		defaultFlowBoxChildOverrides,
	)
}

func initFlowBoxChildClass(gclass unsafe.Pointer, overrides FlowBoxChildOverrides, classInitFunc func(*FlowBoxChildClass)) {
	pclass := (*C.GtkFlowBoxChildClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFlowBoxChild))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_FlowBoxChildClass_activate)
	}

	if classInitFunc != nil {
		class := (*FlowBoxChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFlowBoxChild(obj *coreglib.Object) *FlowBoxChild {
	return &FlowBoxChild{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalFlowBoxChild(p uintptr) (interface{}, error) {
	return wrapFlowBoxChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when the user activates a child widget in a
// GtkFlowBox.
//
// This can be happen either by clicking or double-clicking, or via a
// keybinding.
//
// This is a keybinding signal (class.SignalAction.html), but it can be used by
// applications for their own purposes.
//
// The default bindings are <kbd>Space</kbd> and <kbd>Enter</kbd>.
func (child *FlowBoxChild) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(child, "activate", false, unsafe.Pointer(C._gotk4_gtk4_FlowBoxChild_ConnectActivate), f)
}

// NewFlowBoxChild creates a new GtkFlowBoxChild.
//
// This should only be used as a child of a GtkFlowBox.
//
// The function returns the following values:
//
//   - flowBoxChild: new GtkFlowBoxChild.
func NewFlowBoxChild() *FlowBoxChild {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_flow_box_child_new()

	var _flowBoxChild *FlowBoxChild // out

	_flowBoxChild = wrapFlowBoxChild(coreglib.Take(unsafe.Pointer(_cret)))

	return _flowBoxChild
}

// Changed marks child as changed, causing any state that depends on this to be
// updated.
//
// This affects sorting and filtering.
//
// Note that calls to this method must be in sync with the data used for the
// sorting and filtering functions. For instance, if the list is mirroring some
// external data set, and *two* children changed in the external data set when
// you call gtk_flow_box_child_changed() on the first child, the sort function
// must only read the new data for the first of the two changed children,
// otherwise the resorting of the children will be wrong.
//
// This generally means that if you don’t fully control the data model, you have
// to duplicate the data that affects the sorting and filtering functions into
// the widgets themselves.
//
// Another alternative is to call gtk.FlowBox.InvalidateSort() on any model
// change, but that is more expensive.
func (child *FlowBoxChild) Changed() {
	var _arg0 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_flow_box_child_changed(_arg0)
	runtime.KeepAlive(child)
}

// Child gets the child widget of self.
//
// The function returns the following values:
//
//   - widget (optional): child widget of self.
func (self *FlowBoxChild) Child() Widgetter {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_flow_box_child_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Index gets the current index of the child in its GtkFlowBox container.
//
// The function returns the following values:
//
//   - gint: index of the child, or -1 if the child is not in a flow box.
func (child *FlowBoxChild) Index() int {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret C.int              // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_flow_box_child_get_index(_arg0)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsSelected returns whether the child is currently selected in its GtkFlowBox
// container.
//
// The function returns the following values:
//
//   - ok: TRUE if child is selected.
func (child *FlowBoxChild) IsSelected() bool {
	var _arg0 *C.GtkFlowBoxChild // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_flow_box_child_is_selected(_arg0)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of self.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (self *FlowBoxChild) SetChild(child Widgetter) {
	var _arg0 *C.GtkFlowBoxChild // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_flow_box_child_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

func (child *FlowBoxChild) activate() {
	gclass := (*C.GtkFlowBoxChildClass)(coreglib.PeekParentClass(child))
	fnarg := gclass.activate

	var _arg0 *C.GtkFlowBoxChild // out

	_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C._gotk4_gtk4_FlowBoxChild_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(child)
}

// FontButton: GtkFontButton allows to open a font chooser dialog to change the
// font.
//
// !An example GtkFontButton (font-button.png)
//
// It is suitable widget for selecting a font in a preference dialog.
//
// CSS nodes
//
//	fontbutton
//	╰── button.font
//	    ╰── [content]
//
// GtkFontButton has a single CSS node with name fontbutton which contains a
// button node with the .font style class.
type FontButton struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	FontChooser
}

var (
	_ Widgetter         = (*FontButton)(nil)
	_ coreglib.Objector = (*FontButton)(nil)
)

func wrapFontButton(obj *coreglib.Object) *FontButton {
	return &FontButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		FontChooser: FontChooser{
			Object: obj,
		},
	}
}

func marshalFontButton(p uintptr) (interface{}, error) {
	return wrapFontButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectFontSet is emitted when the user selects a font.
//
// When handling this signal, use gtk.FontChooser.GetFont() to find out which
// font was just selected.
//
// Note that this signal is only emitted when the user changes the font. If you
// need to react to programmatic font changes as well, use the notify::font
// signal.
func (fontButton *FontButton) ConnectFontSet(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(fontButton, "font-set", false, unsafe.Pointer(C._gotk4_gtk4_FontButton_ConnectFontSet), f)
}

// NewFontButton creates a new font picker widget.
//
// The function returns the following values:
//
//   - fontButton: new font picker widget.
func NewFontButton() *FontButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_font_button_new()

	var _fontButton *FontButton // out

	_fontButton = wrapFontButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _fontButton
}

// NewFontButtonWithFont creates a new font picker widget showing the given
// font.
//
// The function takes the following parameters:
//
//   - fontname: name of font to display in font chooser dialog.
//
// The function returns the following values:
//
//   - fontButton: new font picker widget.
func NewFontButtonWithFont(fontname string) *FontButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fontname)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_font_button_new_with_font(_arg1)
	runtime.KeepAlive(fontname)

	var _fontButton *FontButton // out

	_fontButton = wrapFontButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _fontButton
}

// Modal gets whether the dialog is modal.
//
// The function returns the following values:
//
//   - ok: TRUE if the dialog is modal.
func (fontButton *FontButton) Modal() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))

	_cret = C.gtk_font_button_get_modal(_arg0)
	runtime.KeepAlive(fontButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the font chooser dialog.
//
// The function returns the following values:
//
//   - utf8: internal copy of the title string which must not be freed.
func (fontButton *FontButton) Title() string {
	var _arg0 *C.GtkFontButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))

	_cret = C.gtk_font_button_get_title(_arg0)
	runtime.KeepAlive(fontButton)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UseFont returns whether the selected font is used in the label.
//
// The function returns the following values:
//
//   - ok: whether the selected font is used in the label.
func (fontButton *FontButton) UseFont() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))

	_cret = C.gtk_font_button_get_use_font(_arg0)
	runtime.KeepAlive(fontButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseSize returns whether the selected size is used in the label.
//
// The function returns the following values:
//
//   - ok: whether the selected size is used in the label.
func (fontButton *FontButton) UseSize() bool {
	var _arg0 *C.GtkFontButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))

	_cret = C.gtk_font_button_get_use_size(_arg0)
	runtime.KeepAlive(fontButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetModal sets whether the dialog should be modal.
//
// The function takes the following parameters:
//
//   - modal: TRUE to make the dialog modal.
func (fontButton *FontButton) SetModal(modal bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_modal(_arg0, _arg1)
	runtime.KeepAlive(fontButton)
	runtime.KeepAlive(modal)
}

// SetTitle sets the title for the font chooser dialog.
//
// The function takes the following parameters:
//
//   - title: string containing the font chooser dialog title.
func (fontButton *FontButton) SetTitle(title string) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_font_button_set_title(_arg0, _arg1)
	runtime.KeepAlive(fontButton)
	runtime.KeepAlive(title)
}

// SetUseFont: if use_font is TRUE, the font name will be written using the
// selected font.
//
// The function takes the following parameters:
//
//   - useFont: if TRUE, font name will be written using font chosen.
func (fontButton *FontButton) SetUseFont(useFont bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))
	if useFont {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_use_font(_arg0, _arg1)
	runtime.KeepAlive(fontButton)
	runtime.KeepAlive(useFont)
}

// SetUseSize: if use_size is TRUE, the font name will be written using the
// selected size.
//
// The function takes the following parameters:
//
//   - useSize: if TRUE, font name will be written using the selected size.
func (fontButton *FontButton) SetUseSize(useSize bool) {
	var _arg0 *C.GtkFontButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkFontButton)(unsafe.Pointer(coreglib.InternObject(fontButton).Native()))
	if useSize {
		_arg1 = C.TRUE
	}

	C.gtk_font_button_set_use_size(_arg0, _arg1)
	runtime.KeepAlive(fontButton)
	runtime.KeepAlive(useSize)
}

// FontChooserDialog: GtkFontChooserDialog widget is a dialog for selecting a
// font.
//
// !An example GtkFontChooserDialog (fontchooser.png)
//
// GtkFontChooserDialog implements the gtk.FontChooser interface and does not
// provide much API of its own.
//
// To create a GtkFontChooserDialog, use gtk.FontChooserDialog.New.
//
// # GtkFontChooserDialog as GtkBuildable
//
// The GtkFontChooserDialog implementation of the GtkBuildable interface exposes
// the buttons with the names “select_button” and “cancel_button”.
type FontChooserDialog struct {
	_ [0]func() // equal guard
	Dialog

	*coreglib.Object
	FontChooser
}

var (
	_ coreglib.Objector = (*FontChooserDialog)(nil)
	_ Widgetter         = (*FontChooserDialog)(nil)
)

func wrapFontChooserDialog(obj *coreglib.Object) *FontChooserDialog {
	return &FontChooserDialog{
		Dialog: Dialog{
			Window: Window{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
				Object: obj,
				Root: Root{
					NativeSurface: NativeSurface{
						Widget: Widget{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
							Object: obj,
							Accessible: Accessible{
								Object: obj,
							},
							Buildable: Buildable{
								Object: obj,
							},
							ConstraintTarget: ConstraintTarget{
								Object: obj,
							},
						},
					},
				},
				ShortcutManager: ShortcutManager{
					Object: obj,
				},
			},
		},
		Object: obj,
		FontChooser: FontChooser{
			Object: obj,
		},
	}
}

func marshalFontChooserDialog(p uintptr) (interface{}, error) {
	return wrapFontChooserDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFontChooserDialog creates a new GtkFontChooserDialog.
//
// The function takes the following parameters:
//
//   - title (optional): title of the dialog, or NULL.
//   - parent (optional): transient parent of the dialog, or NULL.
//
// The function returns the following values:
//
//   - fontChooserDialog: new GtkFontChooserDialog.
func NewFontChooserDialog(title string, parent *Window) *FontChooserDialog {
	var _arg1 *C.char      // out
	var _arg2 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	if title != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if parent != nil {
		_arg2 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gtk_font_chooser_dialog_new(_arg1, _arg2)
	runtime.KeepAlive(title)
	runtime.KeepAlive(parent)

	var _fontChooserDialog *FontChooserDialog // out

	_fontChooserDialog = wrapFontChooserDialog(coreglib.Take(unsafe.Pointer(_cret)))

	return _fontChooserDialog
}

// FontChooserWidget: GtkFontChooserWidget widget lets the user select a font.
//
// It is used in the GtkFontChooserDialog widget to provide a dialog for
// selecting fonts.
//
// To set the font which is initially selected, use gtk.FontChooser.SetFont() or
// gtk.FontChooser.SetFontDesc().
//
// To get the selected font use gtk.FontChooser.GetFont() or
// gtk.FontChooser.GetFontDesc().
//
// To change the text which is shown in the preview area, use
// gtk.FontChooser.SetPreviewText().
//
// # CSS nodes
//
// GtkFontChooserWidget has a single CSS node with name fontchooser.
type FontChooserWidget struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	FontChooser
}

var (
	_ Widgetter         = (*FontChooserWidget)(nil)
	_ coreglib.Objector = (*FontChooserWidget)(nil)
)

func wrapFontChooserWidget(obj *coreglib.Object) *FontChooserWidget {
	return &FontChooserWidget{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		FontChooser: FontChooser{
			Object: obj,
		},
	}
}

func marshalFontChooserWidget(p uintptr) (interface{}, error) {
	return wrapFontChooserWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFontChooserWidget creates a new GtkFontChooserWidget.
//
// The function returns the following values:
//
//   - fontChooserWidget: new GtkFontChooserWidget.
func NewFontChooserWidget() *FontChooserWidget {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_font_chooser_widget_new()

	var _fontChooserWidget *FontChooserWidget // out

	_fontChooserWidget = wrapFontChooserWidget(coreglib.Take(unsafe.Pointer(_cret)))

	return _fontChooserWidget
}

// FrameOverrides contains methods that are overridable.
type FrameOverrides struct {
	ComputeChildAllocation func(allocation *Allocation)
}

func defaultFrameOverrides(v *Frame) FrameOverrides {
	return FrameOverrides{
		ComputeChildAllocation: v.computeChildAllocation,
	}
}

// Frame: GtkFrame is a widget that surrounds its child with a decorative frame
// and an optional label.
//
// !An example GtkFrame (frame.png)
//
// If present, the label is drawn inside the top edge of the frame.
// The horizontal position of the label can be controlled with
// gtk.Frame.SetLabelAlign().
//
// GtkFrame clips its child. You can use this to add rounded corners to widgets,
// but be aware that it also cuts off shadows.
//
// # GtkFrame as GtkBuildable
//
// The GtkFrame implementation of the GtkBuildable interface supports placing a
// child in the label position by specifying “label” as the “type” attribute of
// a <child> element. A normal content child can be specified without specifying
// a <child> type attribute.
//
// An example of a UI definition fragment with GtkFrame:
//
//	<object class="GtkFrame">
//	  <child type="label">
//	    <object class="GtkLabel" id="frame_label"/>
//	  </child>
//	  <child>
//	    <object class="GtkEntry" id="frame_content"/>
//	  </child>
//	</object>
//
// CSS nodes
//
//	frame
//	├── <label widget>
//	╰── <child>
//
// GtkFrame has a main CSS node with name “frame”, which is used to draw the
// visible border. You can set the appearance of the border using CSS properties
// like “border-style” on this node.
type Frame struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Frame)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Frame, *FrameClass, FrameOverrides](
		GTypeFrame,
		initFrameClass,
		wrapFrame,
		defaultFrameOverrides,
	)
}

func initFrameClass(gclass unsafe.Pointer, overrides FrameOverrides, classInitFunc func(*FrameClass)) {
	pclass := (*C.GtkFrameClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeFrame))))

	if overrides.ComputeChildAllocation != nil {
		pclass.compute_child_allocation = (*[0]byte)(C._gotk4_gtk4_FrameClass_compute_child_allocation)
	}

	if classInitFunc != nil {
		class := (*FrameClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapFrame(obj *coreglib.Object) *Frame {
	return &Frame{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalFrame(p uintptr) (interface{}, error) {
	return wrapFrame(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewFrame creates a new GtkFrame, with optional label label.
//
// If label is NULL, the label is omitted.
//
// The function takes the following parameters:
//
//   - label (optional): text to use as the label of the frame.
//
// The function returns the following values:
//
//   - frame: new GtkFrame widget.
func NewFrame(label string) *Frame {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_frame_new(_arg1)
	runtime.KeepAlive(label)

	var _frame *Frame // out

	_frame = wrapFrame(coreglib.Take(unsafe.Pointer(_cret)))

	return _frame
}

// Child gets the child widget of frame.
//
// The function returns the following values:
//
//   - widget (optional): child widget of frame.
func (frame *Frame) Child() Widgetter {
	var _arg0 *C.GtkFrame  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))

	_cret = C.gtk_frame_get_child(_arg0)
	runtime.KeepAlive(frame)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Label returns the frame labels text.
//
// If the frame's label widget is not a GtkLabel, NULL is returned.
//
// The function returns the following values:
//
//   - utf8 (optional): text in the label, or NULL if there was no label widget
//     or the label widget was not a GtkLabel. This string is owned by GTK and
//     must not be modified or freed.
func (frame *Frame) Label() string {
	var _arg0 *C.GtkFrame // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))

	_cret = C.gtk_frame_get_label(_arg0)
	runtime.KeepAlive(frame)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// LabelAlign retrieves the X alignment of the frame’s label.
//
// The function returns the following values:
//
//   - gfloat frames X alignment.
func (frame *Frame) LabelAlign() float32 {
	var _arg0 *C.GtkFrame // out
	var _cret C.float     // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))

	_cret = C.gtk_frame_get_label_align(_arg0)
	runtime.KeepAlive(frame)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// LabelWidget retrieves the label widget for the frame.
//
// The function returns the following values:
//
//   - widget (optional): label widget, or NULL if there is none.
func (frame *Frame) LabelWidget() Widgetter {
	var _arg0 *C.GtkFrame  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))

	_cret = C.gtk_frame_get_label_widget(_arg0)
	runtime.KeepAlive(frame)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SetChild sets the child widget of frame.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (frame *Frame) SetChild(child Widgetter) {
	var _arg0 *C.GtkFrame  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_frame_set_child(_arg0, _arg1)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(child)
}

// SetLabel creates a new GtkLabel with the label and sets it as the frame's
// label widget.
//
// The function takes the following parameters:
//
//   - label (optional): text to use as the label of the frame.
func (frame *Frame) SetLabel(label string) {
	var _arg0 *C.GtkFrame // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))
	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_frame_set_label(_arg0, _arg1)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(label)
}

// SetLabelAlign sets the X alignment of the frame widget’s label.
//
// The default value for a newly created frame is 0.0.
//
// The function takes the following parameters:
//
//   - xalign: position of the label along the top edge of the widget. A value
//     of 0.0 represents left alignment; 1.0 represents right alignment.
func (frame *Frame) SetLabelAlign(xalign float32) {
	var _arg0 *C.GtkFrame // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))
	_arg1 = C.float(xalign)

	C.gtk_frame_set_label_align(_arg0, _arg1)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(xalign)
}

// SetLabelWidget sets the label widget for the frame.
//
// This is the widget that will appear embedded in the top edge of the frame as
// a title.
//
// The function takes the following parameters:
//
//   - labelWidget (optional): new label widget.
func (frame *Frame) SetLabelWidget(labelWidget Widgetter) {
	var _arg0 *C.GtkFrame  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))
	if labelWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(labelWidget).Native()))
	}

	C.gtk_frame_set_label_widget(_arg0, _arg1)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(labelWidget)
}

func (frame *Frame) computeChildAllocation(allocation *Allocation) {
	gclass := (*C.GtkFrameClass)(coreglib.PeekParentClass(frame))
	fnarg := gclass.compute_child_allocation

	var _arg0 *C.GtkFrame      // out
	var _arg1 *C.GtkAllocation // out

	_arg0 = (*C.GtkFrame)(unsafe.Pointer(coreglib.InternObject(frame).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	C._gotk4_gtk4_Frame_virtual_compute_child_allocation(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(frame)
	runtime.KeepAlive(allocation)
}

// GLAreaOverrides contains methods that are overridable.
type GLAreaOverrides struct {
	Render func(context gdk.GLContexter) bool
	// The function takes the following parameters:
	//
	//   - width
	//   - height
	Resize func(width, height int)
}

func defaultGLAreaOverrides(v *GLArea) GLAreaOverrides {
	return GLAreaOverrides{
		Render: v.render,
		Resize: v.resize,
	}
}

// GLArea: GtkGLArea is a widget that allows drawing with OpenGL.
//
// !An example GtkGLArea (glarea.png)
//
// GtkGLArea sets up its own gdk.GLContext, and creates a custom GL framebuffer
// that the widget will do GL rendering onto. It also ensures that this
// framebuffer is the default GL rendering target when rendering.
//
// In order to draw, you have to connect to the gtk.GLArea::render signal, or
// subclass GtkGLArea and override the GtkGLAreaClass.render virtual function.
//
// The GtkGLArea widget ensures that the GdkGLContext is associated with the
// widget's drawing area, and it is kept updated when the size and position of
// the drawing area changes.
//
// # Drawing with GtkGLArea
//
// The simplest way to draw using OpenGL commands in a GtkGLArea is to create a
// widget instance and connect to the gtk.GLArea::render signal:
//
// The render() function will be called when the GtkGLArea is ready for you to
// draw its content:
//
//	static gboolean
//	render (GtkGLArea *area, GdkGLContext *context)
//	{
//	  // inside this function it's safe to use GL; the given
//	  // GLContext has been made current to the drawable
//	  // surface used by the GtkGLArea and the viewport has
//	  // already been set to be the size of the allocation
//
//	  // we can start by clearing the buffer
//	  glClearColor (0, 0, 0, 0);
//	  glClear (GL_COLOR_BUFFER_BIT);
//
//	  // draw your object
//	  // draw_an_object ();
//
//	  // we completed our drawing; the draw commands will be
//	  // flushed at the end of the signal emission chain, and
//	  // the buffers will be drawn on the window
//	  return TRUE;
//	}
//
//	void setup_glarea (void)
//	{
//	  // create a GtkGLArea instance
//	  GtkWidget *gl_area = gtk_gl_area_new ();
//
//	  // connect to the "render" signal
//	  g_signal_connect (gl_area, "render", G_CALLBACK (render), NULL);
//	}
//
// If you need to initialize OpenGL state, e.g. buffer objects or shaders,
// you should use the gtk.Widget::realize signal; you can use the
// gtk.Widget::unrealize signal to clean up. Since the GdkGLContext creation
// and initialization may fail, you will need to check for errors, using
// gtk.GLArea.GetError().
//
// An example of how to safely initialize the GL state is:
//
//	static void
//	on_realize (GtkGLarea *area)
//	{
//	  // We need to make the context current if we want to
//	  // call GL API
//	  gtk_gl_area_make_current (area);
//
//	  // If there were errors during the initialization or
//	  // when trying to make the context current, this
//	  // function will return a #GError for you to catch
//	  if (gtk_gl_area_get_error (area) != NULL)
//	    return;
//
//	  // You can also use gtk_gl_area_set_error() in order
//	  // to show eventual initialization errors on the
//	  // GtkGLArea widget itself
//	  GError *internal_error = NULL;
//	  init_buffer_objects (&error);
//	  if (error != NULL)
//	    {
//	      gtk_gl_area_set_error (area, error);
//	      g_error_free (error);
//	      return;
//	    }
//
//	  init_shaders (&error);
//	  if (error != NULL)
//	    {
//	      gtk_gl_area_set_error (area, error);
//	      g_error_free (error);
//	      return;
//	    }
//	}
//
// If you need to change the options for creating the GdkGLContext you should
// use the gtk.GLArea::create-context signal.
type GLArea struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*GLArea)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GLArea, *GLAreaClass, GLAreaOverrides](
		GTypeGLArea,
		initGLAreaClass,
		wrapGLArea,
		defaultGLAreaOverrides,
	)
}

func initGLAreaClass(gclass unsafe.Pointer, overrides GLAreaOverrides, classInitFunc func(*GLAreaClass)) {
	pclass := (*C.GtkGLAreaClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeGLArea))))

	if overrides.Render != nil {
		pclass.render = (*[0]byte)(C._gotk4_gtk4_GLAreaClass_render)
	}

	if overrides.Resize != nil {
		pclass.resize = (*[0]byte)(C._gotk4_gtk4_GLAreaClass_resize)
	}

	if classInitFunc != nil {
		class := (*GLAreaClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGLArea(obj *coreglib.Object) *GLArea {
	return &GLArea{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalGLArea(p uintptr) (interface{}, error) {
	return wrapGLArea(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCreateContext is emitted when the widget is being realized.
//
// This allows you to override how the GL context is created. This is useful
// when you want to reuse an existing GL context, or if you want to try creating
// different kinds of GL options.
//
// If context creation fails then the signal handler can use
// gtk.GLArea.SetError() to register a more detailed error of how the
// construction failed.
func (area *GLArea) ConnectCreateContext(f func() (glContext gdk.GLContexter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(area, "create-context", false, unsafe.Pointer(C._gotk4_gtk4_GLArea_ConnectCreateContext), f)
}

// ConnectRender is emitted every time the contents of the GtkGLArea should be
// redrawn.
//
// The context is bound to the area prior to emitting this function, and the
// buffers are painted to the window once the emission terminates.
func (area *GLArea) ConnectRender(f func(context gdk.GLContexter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(area, "render", false, unsafe.Pointer(C._gotk4_gtk4_GLArea_ConnectRender), f)
}

// ConnectResize is emitted once when the widget is realized, and then each time
// the widget is changed while realized.
//
// This is useful in order to keep GL state up to date with the widget size,
// like for instance camera properties which may depend on the width/height
// ratio.
//
// The GL context for the area is guaranteed to be current when this signal is
// emitted.
//
// The default handler sets up the GL viewport.
func (area *GLArea) ConnectResize(f func(width, height int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(area, "resize", false, unsafe.Pointer(C._gotk4_gtk4_GLArea_ConnectResize), f)
}

// NewGLArea creates a new GtkGLArea widget.
//
// The function returns the following values:
//
//   - glArea: new GtkGLArea.
func NewGLArea() *GLArea {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_gl_area_new()

	var _glArea *GLArea // out

	_glArea = wrapGLArea(coreglib.Take(unsafe.Pointer(_cret)))

	return _glArea
}

// AttachBuffers binds buffers to the framebuffer.
//
// Ensures that the area framebuffer object is made the current draw and read
// target, and that all the required buffers for the area are created and bound
// to the framebuffer.
//
// This function is automatically called before emitting the gtk.GLArea::render
// signal, and doesn't normally need to be called by application code.
func (area *GLArea) AttachBuffers() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	C.gtk_gl_area_attach_buffers(_arg0)
	runtime.KeepAlive(area)
}

// AutoRender returns whether the area is in auto render mode or not.
//
// The function returns the following values:
//
//   - ok: TRUE if the area is auto rendering, FALSE otherwise.
func (area *GLArea) AutoRender() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_gl_area_get_auto_render(_arg0)
	runtime.KeepAlive(area)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Context retrieves the GdkGLContext used by area.
//
// The function returns the following values:
//
//   - glContext: GdkGLContext.
func (area *GLArea) Context() gdk.GLContexter {
	var _arg0 *C.GtkGLArea    // out
	var _cret *C.GdkGLContext // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_gl_area_get_context(_arg0)
	runtime.KeepAlive(area)

	var _glContext gdk.GLContexter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gdk.GLContexter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gdk.GLContexter)
			return ok
		})
		rv, ok := casted.(gdk.GLContexter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.GLContexter")
		}
		_glContext = rv
	}

	return _glContext
}

// Error gets the current error set on the area.
//
// The function returns the following values:
//
//   - err (optional) or NULL.
func (area *GLArea) Error() error {
	var _arg0 *C.GtkGLArea // out
	var _cret *C.GError    // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_gl_area_get_error(_arg0)
	runtime.KeepAlive(area)

	var _err error // out

	if _cret != nil {
		_err = gerror.Take(unsafe.Pointer(_cret))
	}

	return _err
}

// HasDepthBuffer returns whether the area has a depth buffer.
//
// The function returns the following values:
//
//   - ok: TRUE if the area has a depth buffer, FALSE otherwise.
func (area *GLArea) HasDepthBuffer() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_gl_area_get_has_depth_buffer(_arg0)
	runtime.KeepAlive(area)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasStencilBuffer returns whether the area has a stencil buffer.
//
// The function returns the following values:
//
//   - ok: TRUE if the area has a stencil buffer, FALSE otherwise.
func (area *GLArea) HasStencilBuffer() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_gl_area_get_has_stencil_buffer(_arg0)
	runtime.KeepAlive(area)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequiredVersion retrieves the required version of OpenGL.
//
// See gtk.GLArea.SetRequiredVersion().
//
// The function returns the following values:
//
//   - major: return location for the required major version.
//   - minor: return location for the required minor version.
func (area *GLArea) RequiredVersion() (major, minor int) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	C.gtk_gl_area_get_required_version(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(area)

	var _major int // out
	var _minor int // out

	_major = int(_arg1)
	_minor = int(_arg2)

	return _major, _minor
}

// UseES returns whether the GtkGLArea should use OpenGL ES.
//
// See gtk.GLArea.SetUseES().
//
// The function returns the following values:
//
//   - ok: TRUE if the GtkGLArea should create an OpenGL ES context and FALSE
//     otherwise.
func (area *GLArea) UseES() bool {
	var _arg0 *C.GtkGLArea // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_gl_area_get_use_es(_arg0)
	runtime.KeepAlive(area)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MakeCurrent ensures that the GdkGLContext used by area is associated with the
// GtkGLArea.
//
// This function is automatically called before emitting the gtk.GLArea::render
// signal, and doesn't normally need to be called by application code.
func (area *GLArea) MakeCurrent() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	C.gtk_gl_area_make_current(_arg0)
	runtime.KeepAlive(area)
}

// QueueRender marks the currently rendered data (if any) as invalid, and queues
// a redraw of the widget.
//
// This ensures that the gtk.GLArea::render signal is emitted during the draw.
//
// This is only needed when gtk.GLArea.SetAutoRender() has been called with
// a FALSE value. The default behaviour is to emit gtk.GLArea::render on each
// draw.
func (area *GLArea) QueueRender() {
	var _arg0 *C.GtkGLArea // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	C.gtk_gl_area_queue_render(_arg0)
	runtime.KeepAlive(area)
}

// SetAutoRender sets whether the GtkGLArea is in auto render mode.
//
// If auto_render is TRUE the gtk.GLArea::render signal will be emitted every
// time the widget draws. This is the default and is useful if drawing the
// widget is faster.
//
// If auto_render is FALSE the data from previous rendering is kept around
// and will be used for drawing the widget the next time, unless the window
// is resized. In order to force a rendering gtk.GLArea.QueueRender() must be
// called. This mode is useful when the scene changes seldom, but takes a long
// time to redraw.
//
// The function takes the following parameters:
//
//   - autoRender: boolean.
func (area *GLArea) SetAutoRender(autoRender bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	if autoRender {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_auto_render(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(autoRender)
}

// SetError sets an error on the area which will be shown instead of the GL
// rendering.
//
// This is useful in the gtk.GLArea::create-context signal if GL context
// creation fails.
//
// The function takes the following parameters:
//
//   - err (optional): new GError, or NULL to unset the error.
func (area *GLArea) SetError(err error) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 *C.GError    // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	C.gtk_gl_area_set_error(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(err)
}

// SetHasDepthBuffer sets whether the GtkGLArea should use a depth buffer.
//
// If has_depth_buffer is TRUE the widget will allocate and enable a depth
// buffer for the target framebuffer. Otherwise there will be none.
//
// The function takes the following parameters:
//
//   - hasDepthBuffer: TRUE to add a depth buffer.
func (area *GLArea) SetHasDepthBuffer(hasDepthBuffer bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	if hasDepthBuffer {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_has_depth_buffer(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(hasDepthBuffer)
}

// SetHasStencilBuffer sets whether the GtkGLArea should use a stencil buffer.
//
// If has_stencil_buffer is TRUE the widget will allocate and enable a stencil
// buffer for the target framebuffer. Otherwise there will be none.
//
// The function takes the following parameters:
//
//   - hasStencilBuffer: TRUE to add a stencil buffer.
func (area *GLArea) SetHasStencilBuffer(hasStencilBuffer bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	if hasStencilBuffer {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_has_stencil_buffer(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(hasStencilBuffer)
}

// SetRequiredVersion sets the required version of OpenGL to be used when
// creating the context for the widget.
//
// This function must be called before the area has been realized.
//
// The function takes the following parameters:
//
//   - major version.
//   - minor version.
func (area *GLArea) SetRequiredVersion(major, minor int) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = C.int(major)
	_arg2 = C.int(minor)

	C.gtk_gl_area_set_required_version(_arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(major)
	runtime.KeepAlive(minor)
}

// SetUseES sets whether the area should create an OpenGL or an OpenGL ES
// context.
//
// You should check the capabilities of the GLContext before drawing with either
// API.
//
// The function takes the following parameters:
//
//   - useEs: whether to use OpenGL or OpenGL ES.
func (area *GLArea) SetUseES(useEs bool) {
	var _arg0 *C.GtkGLArea // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	if useEs {
		_arg1 = C.TRUE
	}

	C.gtk_gl_area_set_use_es(_arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(useEs)
}

func (area *GLArea) render(context gdk.GLContexter) bool {
	gclass := (*C.GtkGLAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.render

	var _arg0 *C.GtkGLArea    // out
	var _arg1 *C.GdkGLContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = (*C.GdkGLContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gtk4_GLArea_virtual_render(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(area)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - width
//   - height
func (area *GLArea) resize(width, height int) {
	gclass := (*C.GtkGLAreaClass)(coreglib.PeekParentClass(area))
	fnarg := gclass.resize

	var _arg0 *C.GtkGLArea // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkGLArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C._gotk4_gtk4_GLArea_virtual_resize(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(area)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// Gesture: GtkGesture is the base class for gesture recognition.
//
// Although GtkGesture is quite generalized to serve as a base for multi-touch
// gestures, it is suitable to implement single-touch and pointer-based gestures
// (using the special NULL GdkEventSequence value for these).
//
// The number of touches that a GtkGesture need to be recognized is controlled
// by the gtk.Gesture:n-points property, if a gesture is keeping track of less
// or more than that number of sequences, it won't check whether the gesture is
// recognized.
//
// As soon as the gesture has the expected number of touches, it will check
// regularly if it is recognized, the criteria to consider a gesture as
// "recognized" is left to GtkGesture subclasses.
//
// A recognized gesture will then emit the following signals:
//
// - gtk.Gesture::begin when the gesture is recognized.
//
// - gtk.Gesture::update, whenever an input event is processed.
//
// - gtk.Gesture::end when the gesture is no longer recognized.
//
// # Event propagation
//
// In order to receive events, a gesture needs to set a propagation phase
// through gtk.EventController.SetPropagationPhase().
//
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
//
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
//
// # States of a sequence
//
// Whenever input interaction happens, a single event may trigger a cascade of
// GtkGestures, both across the parents of the widget receiving the event and in
// parallel within an individual widget. It is a responsibility of the widgets
// using those gestures to set the state of touch sequences accordingly in order
// to enable cooperation of gestures around the GdkEventSequences triggering
// those.
//
// Within a widget, gestures can be grouped through gtk.Gesture.Group().
// Grouped gestures synchronize the state of sequences, so calling
// gtk.Gesture.SetSequenceState() on one will effectively propagate the state
// throughout the group.
//
// By default, all sequences start out in the GTK_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
//
// If a sequence enters into the GTK_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
//
// If a sequence enters in the GTK_EVENT_SEQUENCE_CLAIMED state, the gesture
// group will grab all interaction on the sequence, by:
//
// - Setting the same sequence to GTK_EVENT_SEQUENCE_DENIED on every other
// gesture group within the widget, and every gesture on parent widgets in the
// propagation chain.
//
// - Emitting gtk.Gesture::cancel on every gesture in widgets underneath in the
// propagation chain.
//
// - Stopping event propagation after the gesture group handles the event.
//
// Note: if a sequence is set early to GTK_EVENT_SEQUENCE_CLAIMED on
// GDK_TOUCH_BEGIN/GDK_BUTTON_PRESS (so those events are captured before
// reaching the event widget, this implies GTK_PHASE_CAPTURE), one similar event
// will emulated if the sequence changes to GTK_EVENT_SEQUENCE_DENIED. This way
// event coherence is preserved before event propagation is unstopped again.
//
// Sequence states can't be changed freely. See gtk.Gesture.SetSequenceState()
// to know about the possible lifetimes of a GdkEventSequence.
//
// # Touchpad gestures
//
// On the platforms that support it, GtkGesture will handle transparently
// touchpad gesture events. The only precautions users of GtkGesture should do
// to enable this support are:
//
// - If the gesture has GTK_PHASE_NONE, ensuring events of type
// GDK_TOUCHPAD_SWIPE and GDK_TOUCHPAD_PINCH are handled by the GtkGesture.
type Gesture struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*Gesture)(nil)
)

// Gesturer describes types inherited from class Gesture.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Gesturer interface {
	coreglib.Objector
	baseGesture() *Gesture
}

var _ Gesturer = (*Gesture)(nil)

func wrapGesture(obj *coreglib.Object) *Gesture {
	return &Gesture{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalGesture(p uintptr) (interface{}, error) {
	return wrapGesture(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (gesture *Gesture) baseGesture() *Gesture {
	return gesture
}

// BaseGesture returns the underlying base object.
func BaseGesture(obj Gesturer) *Gesture {
	return obj.baseGesture()
}

// ConnectBegin is emitted when the gesture is recognized.
//
// This means the number of touch sequences matches gtk.Gesture:n-points.
//
// Note: These conditions may also happen when an extra touch (eg. a third touch
// on a 2-touches gesture) is lifted, in that situation sequence won't pertain
// to the current set of active touches, so don't rely on this being true.
func (gesture *Gesture) ConnectBegin(f func(sequence *gdk.EventSequence)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "begin", false, unsafe.Pointer(C._gotk4_gtk4_Gesture_ConnectBegin), f)
}

// ConnectCancel is emitted whenever a sequence is cancelled.
//
// This usually happens on active touches when gtk.EventController.Reset() is
// called on gesture (manually, due to grabs...), or the individual sequence was
// claimed by parent widgets' controllers (see gtk.Gesture.SetSequenceState()).
//
// gesture must forget everything about sequence as in response to this signal.
func (gesture *Gesture) ConnectCancel(f func(sequence *gdk.EventSequence)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "cancel", false, unsafe.Pointer(C._gotk4_gtk4_Gesture_ConnectCancel), f)
}

// ConnectEnd is emitted when gesture either stopped recognizing the event
// sequences as something to be handled, or the number of touch sequences became
// higher or lower than gtk.Gesture:n-points.
//
// Note: sequence might not pertain to the group of sequences that were
// previously triggering recognition on gesture (ie. a just pressed touch
// sequence that exceeds gtk.Gesture:n-points). This situation may be detected
// by checking through gtk.Gesture.HandlesSequence().
func (gesture *Gesture) ConnectEnd(f func(sequence *gdk.EventSequence)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "end", false, unsafe.Pointer(C._gotk4_gtk4_Gesture_ConnectEnd), f)
}

// ConnectSequenceStateChanged is emitted whenever a sequence state changes.
//
// See gtk.Gesture.SetSequenceState() to know more about the expectable sequence
// lifetimes.
func (gesture *Gesture) ConnectSequenceStateChanged(f func(sequence *gdk.EventSequence, state EventSequenceState)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "sequence-state-changed", false, unsafe.Pointer(C._gotk4_gtk4_Gesture_ConnectSequenceStateChanged), f)
}

// ConnectUpdate is emitted whenever an event is handled while the gesture is
// recognized.
//
// sequence is guaranteed to pertain to the set of active touches.
func (gesture *Gesture) ConnectUpdate(f func(sequence *gdk.EventSequence)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "update", false, unsafe.Pointer(C._gotk4_gtk4_Gesture_ConnectUpdate), f)
}

// BoundingBox: if there are touch sequences being currently handled by gesture,
// returns TRUE and fills in rect with the bounding box containing all active
// touches.
//
// Otherwise, FALSE will be returned.
//
// Note: This function will yield unexpected results on touchpad gestures.
// Since there is no correlation between physical and pixel distances,
// these will look as if constrained in an infinitely small area, rect width and
// height will thus be 0 regardless of the number of touchpoints.
//
// The function returns the following values:
//
//   - rect: bounding box containing all active touches.
//   - ok: TRUE if there are active touches, FALSE otherwise.
func (gesture *Gesture) BoundingBox() (*gdk.Rectangle, bool) {
	var _arg0 *C.GtkGesture  // out
	var _arg1 C.GdkRectangle // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_get_bounding_box(_arg0, &_arg1)
	runtime.KeepAlive(gesture)

	var _rect *gdk.Rectangle // out
	var _ok bool             // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// BoundingBoxCenter: if there are touch sequences being currently handled by
// gesture, returns TRUE and fills in x and y with the center of the bounding
// box containing all active touches.
//
// Otherwise, FALSE will be returned.
//
// The function returns the following values:
//
//   - x: x coordinate for the bounding box center.
//   - y: y coordinate for the bounding box center.
//   - ok: FALSE if no active touches are present, TRUE otherwise.
func (gesture *Gesture) BoundingBoxCenter() (x, y float64, ok bool) {
	var _arg0 *C.GtkGesture // out
	var _arg1 C.double      // in
	var _arg2 C.double      // in
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_get_bounding_box_center(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(gesture)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg1)
	_y = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// Device returns the logical GdkDevice that is currently operating on gesture.
//
// This returns NULL if the gesture is not being interacted.
//
// The function returns the following values:
//
//   - device (optional): GdkDevice, or NULL.
func (gesture *Gesture) Device() gdk.Devicer {
	var _arg0 *C.GtkGesture // out
	var _cret *C.GdkDevice  // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_get_device(_arg0)
	runtime.KeepAlive(gesture)

	var _device gdk.Devicer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Devicer)
				return ok
			})
			rv, ok := casted.(gdk.Devicer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Devicer")
			}
			_device = rv
		}
	}

	return _device
}

// GetGroup returns all gestures in the group of gesture.
//
// The function returns the following values:
//
//   - list: list of GtkGestures, free with g_list_free().
func (gesture *Gesture) GetGroup() []Gesturer {
	var _arg0 *C.GtkGesture // out
	var _cret *C.GList      // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_get_group(_arg0)
	runtime.KeepAlive(gesture)

	var _list []Gesturer // out

	_list = make([]Gesturer, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkGesture)(v)
		var dst Gesturer // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Gesturer is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Gesturer)
				return ok
			})
			rv, ok := casted.(Gesturer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Gesturer")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// LastEvent returns the last event that was processed for sequence.
//
// Note that the returned pointer is only valid as long as the sequence is still
// interpreted by the gesture. If in doubt, you should make a copy of the event.
//
// The function takes the following parameters:
//
//   - sequence (optional): GdkEventSequence.
//
// The function returns the following values:
//
//   - event (optional): last event from sequence.
func (gesture *Gesture) LastEvent(sequence *gdk.EventSequence) gdk.Eventer {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _cret *C.GdkEvent         // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	if sequence != nil {
		_arg1 = (*C.GdkEventSequence)(gextras.StructNative(unsafe.Pointer(sequence)))
	}

	_cret = C.gtk_gesture_get_last_event(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(sequence)

	var _event gdk.Eventer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.Eventer)
				return ok
			})
			rv, ok := casted.(gdk.Eventer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.Eventer")
			}
			_event = rv
		}
	}

	return _event
}

// LastUpdatedSequence returns the GdkEventSequence that was last updated on
// gesture.
//
// The function returns the following values:
//
//   - eventSequence (optional): last updated sequence.
func (gesture *Gesture) LastUpdatedSequence() *gdk.EventSequence {
	var _arg0 *C.GtkGesture       // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_get_last_updated_sequence(_arg0)
	runtime.KeepAlive(gesture)

	var _eventSequence *gdk.EventSequence // out

	if _cret != nil {
		_eventSequence = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _eventSequence
}

// Point: if sequence is currently being interpreted by gesture, returns
// TRUE and fills in x and y with the last coordinates stored for that event
// sequence.
//
// The coordinates are always relative to the widget allocation.
//
// The function takes the following parameters:
//
//   - sequence (optional): GdkEventSequence, or NULL for pointer events.
//
// The function returns the following values:
//
//   - x (optional): return location for X axis of the sequence coordinates.
//   - y (optional): return location for Y axis of the sequence coordinates.
//   - ok: TRUE if sequence is currently interpreted.
func (gesture *Gesture) Point(sequence *gdk.EventSequence) (x, y float64, ok bool) {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _arg2 C.double            // in
	var _arg3 C.double            // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	if sequence != nil {
		_arg1 = (*C.GdkEventSequence)(gextras.StructNative(unsafe.Pointer(sequence)))
	}

	_cret = C.gtk_gesture_get_point(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(sequence)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg2)
	_y = float64(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// SequenceState returns the sequence state, as seen by gesture.
//
// The function takes the following parameters:
//
//   - sequence: EventSequence.
//
// The function returns the following values:
//
//   - eventSequenceState: sequence state in gesture.
func (gesture *Gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState {
	var _arg0 *C.GtkGesture           // out
	var _arg1 *C.GdkEventSequence     // out
	var _cret C.GtkEventSequenceState // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = (*C.GdkEventSequence)(gextras.StructNative(unsafe.Pointer(sequence)))

	_cret = C.gtk_gesture_get_sequence_state(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(sequence)

	var _eventSequenceState EventSequenceState // out

	_eventSequenceState = EventSequenceState(_cret)

	return _eventSequenceState
}

// Sequences returns the list of GdkEventSequences currently being interpreted
// by gesture.
//
// The function returns the following values:
//
//   - list: list of GdkEventSequence, the list elements are owned by GTK and
//     must not be freed or modified, the list itself must be deleted through
//     g_list_free().
func (gesture *Gesture) Sequences() []*gdk.EventSequence {
	var _arg0 *C.GtkGesture // out
	var _cret *C.GList      // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_get_sequences(_arg0)
	runtime.KeepAlive(gesture)

	var _list []*gdk.EventSequence // out

	_list = make([]*gdk.EventSequence, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GdkEventSequence)(v)
		var dst *gdk.EventSequence // out
		dst = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Group adds gesture to the same group than group_gesture.
//
// Gestures are by default isolated in their own groups.
//
// Both gestures must have been added to the same widget before they can be
// grouped.
//
// When gestures are grouped, the state of GdkEventSequences is kept in sync for
// all of those, so calling gtk.Gesture.SetSequenceState(), on one will transfer
// the same value to the others.
//
// Groups also perform an "implicit grabbing" of sequences, if a
// GdkEventSequence state is set to GTK_EVENT_SEQUENCE_CLAIMED on one group,
// every other gesture group attached to the same GtkWidget will switch the
// state for that sequence to GTK_EVENT_SEQUENCE_DENIED.
//
// The function takes the following parameters:
//
//   - gesture: GtkGesture.
func (groupGesture *Gesture) Group(gesture Gesturer) {
	var _arg0 *C.GtkGesture // out
	var _arg1 *C.GtkGesture // out

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(groupGesture).Native()))
	_arg1 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	C.gtk_gesture_group(_arg0, _arg1)
	runtime.KeepAlive(groupGesture)
	runtime.KeepAlive(gesture)
}

// HandlesSequence returns TRUE if gesture is currently handling events
// corresponding to sequence.
//
// The function takes the following parameters:
//
//   - sequence (optional): GdkEventSequence or NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if gesture is handling sequence, FALSE otherwise.
func (gesture *Gesture) HandlesSequence(sequence *gdk.EventSequence) bool {
	var _arg0 *C.GtkGesture       // out
	var _arg1 *C.GdkEventSequence // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	if sequence != nil {
		_arg1 = (*C.GdkEventSequence)(gextras.StructNative(unsafe.Pointer(sequence)))
	}

	_cret = C.gtk_gesture_handles_sequence(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(sequence)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive returns TRUE if the gesture is currently active.
//
// A gesture is active while there are touch sequences interacting with it.
//
// The function returns the following values:
//
//   - ok: TRUE if gesture is active.
func (gesture *Gesture) IsActive() bool {
	var _arg0 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_is_active(_arg0)
	runtime.KeepAlive(gesture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsGroupedWith returns TRUE if both gestures pertain to the same group.
//
// The function takes the following parameters:
//
//   - other GtkGesture.
//
// The function returns the following values:
//
//   - ok: whether the gestures are grouped.
func (gesture *Gesture) IsGroupedWith(other Gesturer) bool {
	var _arg0 *C.GtkGesture // out
	var _arg1 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(other).Native()))

	_cret = C.gtk_gesture_is_grouped_with(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(other)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsRecognized returns TRUE if the gesture is currently recognized.
//
// A gesture is recognized if there are as many interacting touch sequences as
// required by gesture.
//
// The function returns the following values:
//
//   - ok: TRUE if gesture is recognized.
func (gesture *Gesture) IsRecognized() bool {
	var _arg0 *C.GtkGesture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_is_recognized(_arg0)
	runtime.KeepAlive(gesture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSequenceState sets the state of sequence in gesture.
//
// Sequences start in state GTK_EVENT_SEQUENCE_NONE, and whenever they change
// state, they can never go back to that state. Likewise, sequences in state
// GTK_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With these
// rules, the lifetime of an event sequence is constrained to the next four:
//
// * None * None → Denied * None → Claimed * None → Claimed → Denied
//
// Note: Due to event handling ordering, it may be unsafe to set the state on
// another gesture within a gtk.Gesture::begin signal handler, as the callback
// might be executed before the other gesture knows about the sequence. A safe
// way to perform this could be:
//
//	static void
//	first_gesture_begin_cb (GtkGesture       *first_gesture,
//	                        GdkEventSequence *sequence,
//	                        gpointer          user_data)
//	{
//	  gtk_gesture_set_sequence_state (first_gesture, sequence, GTK_EVENT_SEQUENCE_CLAIMED);
//	  gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//	}
//
//	static void
//	second_gesture_begin_cb (GtkGesture       *second_gesture,
//	                         GdkEventSequence *sequence,
//	                         gpointer          user_data)
//	{
//	  if (gtk_gesture_get_sequence_state (first_gesture, sequence) == GTK_EVENT_SEQUENCE_CLAIMED)
//	    gtk_gesture_set_sequence_state (second_gesture, sequence, GTK_EVENT_SEQUENCE_DENIED);
//	}
//
// If both gestures are in the same group, just set the state on the gesture
// emitting the event, the sequence will be already be initialized to the
// group's global state when the second gesture processes the event.
//
// The function takes the following parameters:
//
//   - sequence: GdkEventSequence.
//   - state: sequence state.
//
// The function returns the following values:
//
//   - ok: TRUE if sequence is handled by gesture, and the state is changed
//     successfully.
func (gesture *Gesture) SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool {
	var _arg0 *C.GtkGesture           // out
	var _arg1 *C.GdkEventSequence     // out
	var _arg2 C.GtkEventSequenceState // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = (*C.GdkEventSequence)(gextras.StructNative(unsafe.Pointer(sequence)))
	_arg2 = C.GtkEventSequenceState(state)

	_cret = C.gtk_gesture_set_sequence_state(_arg0, _arg1, _arg2)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(sequence)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetState sets the state of all sequences that gesture is currently
// interacting with.
//
// See gtk.Gesture.SetSequenceState() for more details on sequence states.
//
// The function takes the following parameters:
//
//   - state: sequence state.
//
// The function returns the following values:
//
//   - ok: TRUE if the state of at least one sequence was changed successfully.
func (gesture *Gesture) SetState(state EventSequenceState) bool {
	var _arg0 *C.GtkGesture           // out
	var _arg1 C.GtkEventSequenceState // out
	var _cret C.gboolean              // in

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = C.GtkEventSequenceState(state)

	_cret = C.gtk_gesture_set_state(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(state)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Ungroup separates gesture into an isolated group.
func (gesture *Gesture) Ungroup() {
	var _arg0 *C.GtkGesture // out

	_arg0 = (*C.GtkGesture)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	C.gtk_gesture_ungroup(_arg0)
	runtime.KeepAlive(gesture)
}

// GestureClick: GtkGestureClick is a GtkGesture implementation for clicks.
//
// It is able to recognize multiple clicks on a nearby zone, which can be
// listened for through the gtk.GestureClick::pressed signal. Whenever time or
// distance between clicks exceed the GTK defaults, gtk.GestureClick::stopped is
// emitted, and the click counter is reset.
type GestureClick struct {
	_ [0]func() // equal guard
	GestureSingle
}

var (
	_ Gesturer = (*GestureClick)(nil)
)

func wrapGestureClick(obj *coreglib.Object) *GestureClick {
	return &GestureClick{
		GestureSingle: GestureSingle{
			Gesture: Gesture{
				EventController: EventController{
					Object: obj,
				},
			},
		},
	}
}

func marshalGestureClick(p uintptr) (interface{}, error) {
	return wrapGestureClick(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectPressed is emitted whenever a button or touch press happens.
func (v *GestureClick) ConnectPressed(f func(nPress int, x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "pressed", false, unsafe.Pointer(C._gotk4_gtk4_GestureClick_ConnectPressed), f)
}

// ConnectReleased is emitted when a button or touch is released.
//
// n_press will report the number of press that is paired to this event,
// note that gtk.GestureClick::stopped may have been emitted between the press
// and its release, n_press will only start over at the next press.
func (v *GestureClick) ConnectReleased(f func(nPress int, x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "released", false, unsafe.Pointer(C._gotk4_gtk4_GestureClick_ConnectReleased), f)
}

// ConnectStopped is emitted whenever any time/distance threshold has been
// exceeded.
func (v *GestureClick) ConnectStopped(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "stopped", false, unsafe.Pointer(C._gotk4_gtk4_GestureClick_ConnectStopped), f)
}

// ConnectUnpairedRelease is emitted whenever the gesture receives a release
// event that had no previous corresponding press.
//
// Due to implicit grabs, this can only happen on situations where input is
// grabbed elsewhere mid-press or the pressed widget voluntarily relinquishes
// its implicit grab.
func (v *GestureClick) ConnectUnpairedRelease(f func(x, y float64, button uint, sequence *gdk.EventSequence)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unpaired-release", false, unsafe.Pointer(C._gotk4_gtk4_GestureClick_ConnectUnpairedRelease), f)
}

// NewGestureClick returns a newly created GtkGesture that recognizes single and
// multiple presses.
//
// The function returns the following values:
//
//   - gestureClick: newly created GtkGestureClick.
func NewGestureClick() *GestureClick {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_click_new()

	var _gestureClick *GestureClick // out

	_gestureClick = wrapGestureClick(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureClick
}

// GestureDrag: GtkGestureDrag is a GtkGesture implementation for drags.
//
// The drag operation itself can be tracked throughout the
// gtk.GestureDrag::drag-begin, gtk.GestureDrag::drag-update and
// gtk.GestureDrag::drag-end signals, and the relevant coordinates
// can be extracted through gtk.GestureDrag.GetOffset() and
// gtk.GestureDrag.GetStartPoint().
type GestureDrag struct {
	_ [0]func() // equal guard
	GestureSingle
}

var (
	_ Gesturer = (*GestureDrag)(nil)
)

func wrapGestureDrag(obj *coreglib.Object) *GestureDrag {
	return &GestureDrag{
		GestureSingle: GestureSingle{
			Gesture: Gesture{
				EventController: EventController{
					Object: obj,
				},
			},
		},
	}
}

func marshalGestureDrag(p uintptr) (interface{}, error) {
	return wrapGestureDrag(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDragBegin is emitted whenever dragging starts.
func (gesture *GestureDrag) ConnectDragBegin(f func(startX, startY float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "drag-begin", false, unsafe.Pointer(C._gotk4_gtk4_GestureDrag_ConnectDragBegin), f)
}

// ConnectDragEnd is emitted whenever the dragging is finished.
func (gesture *GestureDrag) ConnectDragEnd(f func(offsetX, offsetY float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "drag-end", false, unsafe.Pointer(C._gotk4_gtk4_GestureDrag_ConnectDragEnd), f)
}

// ConnectDragUpdate is emitted whenever the dragging point moves.
func (gesture *GestureDrag) ConnectDragUpdate(f func(offsetX, offsetY float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "drag-update", false, unsafe.Pointer(C._gotk4_gtk4_GestureDrag_ConnectDragUpdate), f)
}

// NewGestureDrag returns a newly created GtkGesture that recognizes drags.
//
// The function returns the following values:
//
//   - gestureDrag: newly created GtkGestureDrag.
func NewGestureDrag() *GestureDrag {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_drag_new()

	var _gestureDrag *GestureDrag // out

	_gestureDrag = wrapGestureDrag(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureDrag
}

// Offset gets the offset from the start point.
//
// If the gesture is active, this function returns TRUE and fills in x and y
// with the coordinates of the current point, as an offset to the starting drag
// point.
//
// The function returns the following values:
//
//   - x (optional): x offset for the current point.
//   - y (optional): y offset for the current point.
//   - ok: TRUE if the gesture is active.
func (gesture *GestureDrag) Offset() (x, y float64, ok bool) {
	var _arg0 *C.GtkGestureDrag // out
	var _arg1 C.double          // in
	var _arg2 C.double          // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_drag_get_offset(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(gesture)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg1)
	_y = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// StartPoint gets the point where the drag started.
//
// If the gesture is active, this function returns TRUE and fills in x and y
// with the drag start coordinates, in surface-relative coordinates.
//
// The function returns the following values:
//
//   - x (optional): x coordinate for the drag start point.
//   - y (optional): y coordinate for the drag start point.
//   - ok: TRUE if the gesture is active.
func (gesture *GestureDrag) StartPoint() (x, y float64, ok bool) {
	var _arg0 *C.GtkGestureDrag // out
	var _arg1 C.double          // in
	var _arg2 C.double          // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_drag_get_start_point(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(gesture)

	var _x float64 // out
	var _y float64 // out
	var _ok bool   // out

	_x = float64(_arg1)
	_y = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _x, _y, _ok
}

// GestureLongPress: GtkGestureLongPress is a GtkGesture for long presses.
//
// This gesture is also known as “Press and Hold”.
//
// When the timeout is exceeded, the gesture is triggering the
// gtk.GestureLongPress::pressed signal.
//
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the gtk.GestureLongPress::cancelled signal
// will be emitted.
//
// How long the timeout is before the ::pressed signal gets emitted is
// determined by the gtk.Settings:gtk-long-press-time setting. It can be
// modified by the gtk.GestureLongPress:delay-factor property.
type GestureLongPress struct {
	_ [0]func() // equal guard
	GestureSingle
}

var (
	_ Gesturer = (*GestureLongPress)(nil)
)

func wrapGestureLongPress(obj *coreglib.Object) *GestureLongPress {
	return &GestureLongPress{
		GestureSingle: GestureSingle{
			Gesture: Gesture{
				EventController: EventController{
					Object: obj,
				},
			},
		},
	}
}

func marshalGestureLongPress(p uintptr) (interface{}, error) {
	return wrapGestureLongPress(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectCancelled is emitted whenever a press moved too far, or was released
// before gtk.GestureLongPress::pressed happened.
func (gesture *GestureLongPress) ConnectCancelled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "cancelled", false, unsafe.Pointer(C._gotk4_gtk4_GestureLongPress_ConnectCancelled), f)
}

// ConnectPressed is emitted whenever a press goes unmoved/unreleased longer
// than what the GTK defaults tell.
func (gesture *GestureLongPress) ConnectPressed(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "pressed", false, unsafe.Pointer(C._gotk4_gtk4_GestureLongPress_ConnectPressed), f)
}

// NewGestureLongPress returns a newly created GtkGesture that recognizes long
// presses.
//
// The function returns the following values:
//
//   - gestureLongPress: newly created GtkGestureLongPress.
func NewGestureLongPress() *GestureLongPress {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_long_press_new()

	var _gestureLongPress *GestureLongPress // out

	_gestureLongPress = wrapGestureLongPress(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureLongPress
}

// DelayFactor returns the delay factor.
//
// The function returns the following values:
//
//   - gdouble: delay factor.
func (gesture *GestureLongPress) DelayFactor() float64 {
	var _arg0 *C.GtkGestureLongPress // out
	var _cret C.double               // in

	_arg0 = (*C.GtkGestureLongPress)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_long_press_get_delay_factor(_arg0)
	runtime.KeepAlive(gesture)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SetDelayFactor applies the given delay factor.
//
// The default long press time will be multiplied by this value. Valid values
// are in the range [0.5..2.0].
//
// The function takes the following parameters:
//
//   - delayFactor: delay factor to apply.
func (gesture *GestureLongPress) SetDelayFactor(delayFactor float64) {
	var _arg0 *C.GtkGestureLongPress // out
	var _arg1 C.double               // out

	_arg0 = (*C.GtkGestureLongPress)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = C.double(delayFactor)

	C.gtk_gesture_long_press_set_delay_factor(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(delayFactor)
}

// GesturePan: GtkGesturePan is a GtkGesture for pan gestures.
//
// These are drags that are locked to happen along one axis. The axis that
// a GtkGesturePan handles is defined at construct time, and can be changed
// through gtk.GesturePan.SetOrientation().
//
// When the gesture starts to be recognized, GtkGesturePan will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
//
// Once a panning gesture along the expected axis is recognized, the
// gtk.GesturePan::pan signal will be emitted as input events are received,
// containing the offset in the given axis.
type GesturePan struct {
	_ [0]func() // equal guard
	GestureDrag
}

var (
	_ Gesturer = (*GesturePan)(nil)
)

func wrapGesturePan(obj *coreglib.Object) *GesturePan {
	return &GesturePan{
		GestureDrag: GestureDrag{
			GestureSingle: GestureSingle{
				Gesture: Gesture{
					EventController: EventController{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalGesturePan(p uintptr) (interface{}, error) {
	return wrapGesturePan(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectPan is emitted once a panning gesture along the expected axis is
// detected.
func (gesture *GesturePan) ConnectPan(f func(direction PanDirection, offset float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "pan", false, unsafe.Pointer(C._gotk4_gtk4_GesturePan_ConnectPan), f)
}

// NewGesturePan returns a newly created GtkGesture that recognizes pan
// gestures.
//
// The function takes the following parameters:
//
//   - orientation: expected orientation.
//
// The function returns the following values:
//
//   - gesturePan: newly created GtkGesturePan.
func NewGesturePan(orientation Orientation) *GesturePan {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkGesture    // in

	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_gesture_pan_new(_arg1)
	runtime.KeepAlive(orientation)

	var _gesturePan *GesturePan // out

	_gesturePan = wrapGesturePan(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gesturePan
}

// Orientation returns the orientation of the pan gestures that this gesture
// expects.
//
// The function returns the following values:
//
//   - orientation: expected orientation for pan gestures.
func (gesture *GesturePan) Orientation() Orientation {
	var _arg0 *C.GtkGesturePan // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_pan_get_orientation(_arg0)
	runtime.KeepAlive(gesture)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// SetOrientation sets the orientation to be expected on pan gestures.
//
// The function takes the following parameters:
//
//   - orientation: expected orientation.
func (gesture *GesturePan) SetOrientation(orientation Orientation) {
	var _arg0 *C.GtkGesturePan // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = C.GtkOrientation(orientation)

	C.gtk_gesture_pan_set_orientation(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(orientation)
}

// GestureRotate: GtkGestureRotate is a GtkGesture for 2-finger rotations.
//
// Whenever the angle between both handled sequences changes, the
// gtk.GestureRotate::angle-changed signal is emitted.
type GestureRotate struct {
	_ [0]func() // equal guard
	Gesture
}

var (
	_ Gesturer = (*GestureRotate)(nil)
)

func wrapGestureRotate(obj *coreglib.Object) *GestureRotate {
	return &GestureRotate{
		Gesture: Gesture{
			EventController: EventController{
				Object: obj,
			},
		},
	}
}

func marshalGestureRotate(p uintptr) (interface{}, error) {
	return wrapGestureRotate(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAngleChanged is emitted when the angle between both tracked points
// changes.
func (gesture *GestureRotate) ConnectAngleChanged(f func(angle, angleDelta float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "angle-changed", false, unsafe.Pointer(C._gotk4_gtk4_GestureRotate_ConnectAngleChanged), f)
}

// NewGestureRotate returns a newly created GtkGesture that recognizes 2-touch
// rotation gestures.
//
// The function returns the following values:
//
//   - gestureRotate: newly created GtkGestureRotate.
func NewGestureRotate() *GestureRotate {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_rotate_new()

	var _gestureRotate *GestureRotate // out

	_gestureRotate = wrapGestureRotate(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureRotate
}

// AngleDelta gets the angle delta in radians.
//
// If gesture is active, this function returns the angle difference in
// radians since the gesture was first recognized. If gesture is not active,
// 0 is returned.
//
// The function returns the following values:
//
//   - gdouble: angle delta in radians.
func (gesture *GestureRotate) AngleDelta() float64 {
	var _arg0 *C.GtkGestureRotate // out
	var _cret C.double            // in

	_arg0 = (*C.GtkGestureRotate)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_rotate_get_angle_delta(_arg0)
	runtime.KeepAlive(gesture)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// GestureSingle: GtkGestureSingle is a GtkGestures subclass optimized for
// singe-touch and mouse gestures.
//
// Under interaction, these gestures stick to the first interacting sequence,
// which is accessible through gtk.GestureSingle.GetCurrentSequence() while the
// gesture is being interacted with.
//
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events.
// gtk.GestureSingle.SetTouchOnly() can be used to change the touch behavior.
// Callers may also specify a different mouse button number to interact with
// through gtk.GestureSingle.SetButton(), or react to any mouse button by
// setting it to 0. While the gesture is active, the button being currently
// pressed can be known through gtk.GestureSingle.GetCurrentButton().
type GestureSingle struct {
	_ [0]func() // equal guard
	Gesture
}

var (
	_ Gesturer = (*GestureSingle)(nil)
)

func wrapGestureSingle(obj *coreglib.Object) *GestureSingle {
	return &GestureSingle{
		Gesture: Gesture{
			EventController: EventController{
				Object: obj,
			},
		},
	}
}

func marshalGestureSingle(p uintptr) (interface{}, error) {
	return wrapGestureSingle(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Button returns the button number gesture listens for.
//
// If this is 0, the gesture reacts to any button press.
//
// The function returns the following values:
//
//   - guint: button number, or 0 for any button.
func (gesture *GestureSingle) Button() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_single_get_button(_arg0)
	runtime.KeepAlive(gesture)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CurrentButton returns the button number currently interacting with gesture,
// or 0 if there is none.
//
// The function returns the following values:
//
//   - guint: current button number.
func (gesture *GestureSingle) CurrentButton() uint {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_single_get_current_button(_arg0)
	runtime.KeepAlive(gesture)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CurrentSequence returns the event sequence currently interacting with
// gesture.
//
// This is only meaningful if gtk.Gesture.IsActive() returns TRUE.
//
// The function returns the following values:
//
//   - eventSequence (optional): current sequence.
func (gesture *GestureSingle) CurrentSequence() *gdk.EventSequence {
	var _arg0 *C.GtkGestureSingle // out
	var _cret *C.GdkEventSequence // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_single_get_current_sequence(_arg0)
	runtime.KeepAlive(gesture)

	var _eventSequence *gdk.EventSequence // out

	if _cret != nil {
		_eventSequence = (*gdk.EventSequence)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_eventSequence)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.free(intern.C)
			},
		)
	}

	return _eventSequence
}

// Exclusive gets whether a gesture is exclusive.
//
// For more information, see gtk.GestureSingle.SetExclusive().
//
// The function returns the following values:
//
//   - ok: whether the gesture is exclusive.
func (gesture *GestureSingle) Exclusive() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_single_get_exclusive(_arg0)
	runtime.KeepAlive(gesture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TouchOnly returns TRUE if the gesture is only triggered by touch events.
//
// The function returns the following values:
//
//   - ok: TRUE if the gesture only handles touch events.
func (gesture *GestureSingle) TouchOnly() bool {
	var _arg0 *C.GtkGestureSingle // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_single_get_touch_only(_arg0)
	runtime.KeepAlive(gesture)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetButton sets the button number gesture listens to.
//
// If non-0, every button press from a different button number will be ignored.
// Touch events implicitly match with button 1.
//
// The function takes the following parameters:
//
//   - button number to listen to, or 0 for any button.
func (gesture *GestureSingle) SetButton(button uint) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.guint             // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = C.guint(button)

	C.gtk_gesture_single_set_button(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(button)
}

// SetExclusive sets whether gesture is exclusive.
//
// An exclusive gesture will only handle pointer and "pointer emulated" touch
// events, so at any given time, there is only one sequence able to interact
// with those.
//
// The function takes the following parameters:
//
//   - exclusive: TRUE to make gesture exclusive.
func (gesture *GestureSingle) SetExclusive(exclusive bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	if exclusive {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_exclusive(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(exclusive)
}

// SetTouchOnly sets whether to handle only touch events.
//
// If touch_only is TRUE, gesture will only handle events of type
// GDK_TOUCH_BEGIN, GDK_TOUCH_UPDATE or GDK_TOUCH_END. If FALSE, mouse events
// will be handled too.
//
// The function takes the following parameters:
//
//   - touchOnly: whether gesture handles only touch events.
func (gesture *GestureSingle) SetTouchOnly(touchOnly bool) {
	var _arg0 *C.GtkGestureSingle // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	if touchOnly {
		_arg1 = C.TRUE
	}

	C.gtk_gesture_single_set_touch_only(_arg0, _arg1)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(touchOnly)
}

// GestureStylus: GtkGestureStylus is a GtkGesture specific to stylus input.
//
// The provided signals just relay the basic information of the stylus events.
type GestureStylus struct {
	_ [0]func() // equal guard
	GestureSingle
}

var (
	_ Gesturer = (*GestureStylus)(nil)
)

func wrapGestureStylus(obj *coreglib.Object) *GestureStylus {
	return &GestureStylus{
		GestureSingle: GestureSingle{
			Gesture: Gesture{
				EventController: EventController{
					Object: obj,
				},
			},
		},
	}
}

func marshalGestureStylus(p uintptr) (interface{}, error) {
	return wrapGestureStylus(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectDown is emitted when the stylus touches the device.
func (gesture *GestureStylus) ConnectDown(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "down", false, unsafe.Pointer(C._gotk4_gtk4_GestureStylus_ConnectDown), f)
}

// ConnectMotion is emitted when the stylus moves while touching the device.
func (gesture *GestureStylus) ConnectMotion(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "motion", false, unsafe.Pointer(C._gotk4_gtk4_GestureStylus_ConnectMotion), f)
}

// ConnectProximity is emitted when the stylus is in proximity of the device.
func (gesture *GestureStylus) ConnectProximity(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "proximity", false, unsafe.Pointer(C._gotk4_gtk4_GestureStylus_ConnectProximity), f)
}

// ConnectUp is emitted when the stylus no longer touches the device.
func (gesture *GestureStylus) ConnectUp(f func(x, y float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "up", false, unsafe.Pointer(C._gotk4_gtk4_GestureStylus_ConnectUp), f)
}

// NewGestureStylus creates a new GtkGestureStylus.
//
// The function returns the following values:
//
//   - gestureStylus: newly created stylus gesture.
func NewGestureStylus() *GestureStylus {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_stylus_new()

	var _gestureStylus *GestureStylus // out

	_gestureStylus = wrapGestureStylus(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureStylus
}

// Axis returns the current value for the requested axis.
//
// This function must be called from the handler of one of the
// gtk.GestureStylus::down, gtk.GestureStylus::motion, gtk.GestureStylus::up or
// gtk.GestureStylus::proximity signals.
//
// The function takes the following parameters:
//
//   - axis: requested device axis.
//
// The function returns the following values:
//
//   - value: return location for the axis value.
//   - ok: TRUE if there is a current value for the axis.
func (gesture *GestureStylus) Axis(axis gdk.AxisUse) (float64, bool) {
	var _arg0 *C.GtkGestureStylus // out
	var _arg1 C.GdkAxisUse        // out
	var _arg2 C.double            // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))
	_arg1 = C.GdkAxisUse(axis)

	_cret = C.gtk_gesture_stylus_get_axis(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(gesture)
	runtime.KeepAlive(axis)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Backlog returns the accumulated backlog of tracking information.
//
// By default, GTK will limit rate of input events. On stylus input
// where accuracy of strokes is paramount, this function returns the
// accumulated coordinate/timing state before the emission of the current
// [Gtk.GestureStylus::motion] signal.
//
// This function may only be called within a gtk.GestureStylus::motion
// signal handler, the state given in this signal and obtainable through
// gtk.GestureStylus.GetAxis() express the latest (most up-to-date) state in
// motion history.
//
// The backlog is provided in chronological order.
//
// The function returns the following values:
//
//   - backlog coordinates and times for the backlog events.
//   - ok: TRUE if there is a backlog to unfold in the current state.
func (gesture *GestureStylus) Backlog() ([]gdk.TimeCoord, bool) {
	var _arg0 *C.GtkGestureStylus // out
	var _arg1 *C.GdkTimeCoord     // in
	var _arg2 C.guint             // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_stylus_get_backlog(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(gesture)

	var _backlog []gdk.TimeCoord // out
	var _ok bool                 // out

	defer C.free(unsafe.Pointer(_arg1))
	{
		src := unsafe.Slice((*C.GdkTimeCoord)(_arg1), _arg2)
		_backlog = make([]gdk.TimeCoord, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_backlog[i] = *(*gdk.TimeCoord)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(&_backlog[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.free(intern.C)
				},
			)
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _backlog, _ok
}

// DeviceTool returns the GdkDeviceTool currently driving input through this
// gesture.
//
// This function must be called from the handler of one of the
// gtk.GestureStylus::down, gtk.GestureStylus::motion, gtk.GestureStylus::up or
// gtk.GestureStylus::proximity signals.
//
// The function returns the following values:
//
//   - deviceTool (optional): current stylus tool.
func (gesture *GestureStylus) DeviceTool() *gdk.DeviceTool {
	var _arg0 *C.GtkGestureStylus // out
	var _cret *C.GdkDeviceTool    // in

	_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_stylus_get_device_tool(_arg0)
	runtime.KeepAlive(gesture)

	var _deviceTool *gdk.DeviceTool // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_deviceTool = &gdk.DeviceTool{
				Object: obj,
			}
		}
	}

	return _deviceTool
}

// GestureSwipe: GtkGestureSwipe is a GtkGesture for swipe gestures.
//
// After a press/move/.../move/release sequence happens, the
// gtk.GestureSwipe::swipe signal will be emitted, providing the velocity and
// directionality of the sequence at the time it was lifted.
//
// If the velocity is desired in intermediate points,
// gtk.GestureSwipe.GetVelocity() can be called in a gtk.Gesture::update
// handler.
//
// All velocities are reported in pixels/sec units.
type GestureSwipe struct {
	_ [0]func() // equal guard
	GestureSingle
}

var (
	_ Gesturer = (*GestureSwipe)(nil)
)

func wrapGestureSwipe(obj *coreglib.Object) *GestureSwipe {
	return &GestureSwipe{
		GestureSingle: GestureSingle{
			Gesture: Gesture{
				EventController: EventController{
					Object: obj,
				},
			},
		},
	}
}

func marshalGestureSwipe(p uintptr) (interface{}, error) {
	return wrapGestureSwipe(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectSwipe is emitted when the recognized gesture is finished.
//
// Velocity and direction are a product of previously recorded events.
func (gesture *GestureSwipe) ConnectSwipe(f func(velocityX, velocityY float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "swipe", false, unsafe.Pointer(C._gotk4_gtk4_GestureSwipe_ConnectSwipe), f)
}

// NewGestureSwipe returns a newly created GtkGesture that recognizes swipes.
//
// The function returns the following values:
//
//   - gestureSwipe: newly created GtkGestureSwipe.
func NewGestureSwipe() *GestureSwipe {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_swipe_new()

	var _gestureSwipe *GestureSwipe // out

	_gestureSwipe = wrapGestureSwipe(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureSwipe
}

// Velocity gets the current velocity.
//
// If the gesture is recognized, this function returns TRUE and fills in
// velocity_x and velocity_y with the recorded velocity, as per the last events
// processed.
//
// The function returns the following values:
//
//   - velocityX: return value for the velocity in the X axis, in pixels/sec.
//   - velocityY: return value for the velocity in the Y axis, in pixels/sec.
//   - ok: whether velocity could be calculated.
func (gesture *GestureSwipe) Velocity() (velocityX, velocityY float64, ok bool) {
	var _arg0 *C.GtkGestureSwipe // out
	var _arg1 C.double           // in
	var _arg2 C.double           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkGestureSwipe)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_swipe_get_velocity(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(gesture)

	var _velocityX float64 // out
	var _velocityY float64 // out
	var _ok bool           // out

	_velocityX = float64(_arg1)
	_velocityY = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _velocityX, _velocityY, _ok
}

// GestureZoom: GtkGestureZoom is a GtkGesture for 2-finger pinch/zoom gestures.
//
// Whenever the distance between both tracked sequences changes, the
// gtk.GestureZoom::scale-changed signal is emitted to report the scale factor.
type GestureZoom struct {
	_ [0]func() // equal guard
	Gesture
}

var (
	_ Gesturer = (*GestureZoom)(nil)
)

func wrapGestureZoom(obj *coreglib.Object) *GestureZoom {
	return &GestureZoom{
		Gesture: Gesture{
			EventController: EventController{
				Object: obj,
			},
		},
	}
}

func marshalGestureZoom(p uintptr) (interface{}, error) {
	return wrapGestureZoom(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectScaleChanged is emitted whenever the distance between both tracked
// sequences changes.
func (gesture *GestureZoom) ConnectScaleChanged(f func(scale float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(gesture, "scale-changed", false, unsafe.Pointer(C._gotk4_gtk4_GestureZoom_ConnectScaleChanged), f)
}

// NewGestureZoom returns a newly created GtkGesture that recognizes pinch/zoom
// gestures.
//
// The function returns the following values:
//
//   - gestureZoom: newly created GtkGestureZoom.
func NewGestureZoom() *GestureZoom {
	var _cret *C.GtkGesture // in

	_cret = C.gtk_gesture_zoom_new()

	var _gestureZoom *GestureZoom // out

	_gestureZoom = wrapGestureZoom(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gestureZoom
}

// ScaleDelta gets the scale delta.
//
// If gesture is active, this function returns the zooming difference since
// the gesture was recognized (hence the starting point is considered 1:1).
// If gesture is not active, 1 is returned.
//
// The function returns the following values:
//
//   - gdouble: scale delta.
func (gesture *GestureZoom) ScaleDelta() float64 {
	var _arg0 *C.GtkGestureZoom // out
	var _cret C.double          // in

	_arg0 = (*C.GtkGestureZoom)(unsafe.Pointer(coreglib.InternObject(gesture).Native()))

	_cret = C.gtk_gesture_zoom_get_scale_delta(_arg0)
	runtime.KeepAlive(gesture)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// GridOverrides contains methods that are overridable.
type GridOverrides struct {
}

func defaultGridOverrides(v *Grid) GridOverrides {
	return GridOverrides{}
}

// Grid: GtkGrid is a container which arranges its child widgets in rows and
// columns.
//
// !An example GtkGrid (grid.png)
//
// It supports arbitrary positions and horizontal/vertical spans.
//
// Children are added using gtk.Grid.Attach(). They can span multiple rows
// or columns. It is also possible to add a child next to an existing child,
// using gtk.Grid.AttachNextTo(). To remove a child from the grid, use
// gtk.Grid.Remove().
//
// The behaviour of GtkGrid when several children occupy the same grid cell is
// undefined.
//
// # GtkGrid as GtkBuildable
//
// Every child in a GtkGrid has access to a custom gtk.Buildable element,
// called ´<layout>´. It can by used to specify a position in the grid and
// optionally spans. All properties that can be used in the ´<layout>´ element
// are implemented by gtk.GridLayoutChild.
//
// It is implemented by GtkWidget using gtk.LayoutManager.
//
// To showcase it, here is a simple example:
//
//	<object class="GtkGrid" id="my_grid">
//	  <child>
//	    <object class="GtkButton" id="button1">
//	      <property name="label">Button 1</property>
//	      <layout>
//	        <property name="column">0</property>
//	        <property name="row">0</property>
//	      </layout>
//	    </object>
//	  </child>
//	  <child>
//	    <object class="GtkButton" id="button2">
//	      <property name="label">Button 2</property>
//	      <layout>
//	        <property name="column">1</property>
//	        <property name="row">0</property>
//	      </layout>
//	    </object>
//	  </child>
//	  <child>
//	    <object class="GtkButton" id="button3">
//	      <property name="label">Button 3</property>
//	      <layout>
//	        <property name="column">2</property>
//	        <property name="row">0</property>
//	        <property name="row-span">2</property>
//	      </layout>
//	    </object>
//	  </child>
//	  <child>
//	    <object class="GtkButton" id="button4">
//	      <property name="label">Button 4</property>
//	      <layout>
//	        <property name="column">0</property>
//	        <property name="row">1</property>
//	        <property name="column-span">2</property>
//	      </layout>
//	    </object>
//	  </child>
//	</object>
//
// It organizes the first two buttons side-by-side in one cell each. The third
// button is in the last column but spans across two rows. This is defined by
// the ´row-span´ property. The last button is located in the second row and
// spans across two columns, which is defined by the ´column-span´ property.
//
// # CSS nodes
//
// GtkGrid uses a single CSS node with name grid.
//
// # Accessibility
//
// GtkGrid uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Grid struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*Grid)(nil)
	_ coreglib.Objector = (*Grid)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Grid, *GridClass, GridOverrides](
		GTypeGrid,
		initGridClass,
		wrapGrid,
		defaultGridOverrides,
	)
}

func initGridClass(gclass unsafe.Pointer, overrides GridOverrides, classInitFunc func(*GridClass)) {
	if classInitFunc != nil {
		class := (*GridClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGrid(obj *coreglib.Object) *Grid {
	return &Grid{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalGrid(p uintptr) (interface{}, error) {
	return wrapGrid(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGrid creates a new grid widget.
//
// The function returns the following values:
//
//   - grid: new GtkGrid.
func NewGrid() *Grid {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_grid_new()

	var _grid *Grid // out

	_grid = wrapGrid(coreglib.Take(unsafe.Pointer(_cret)))

	return _grid
}

// Attach adds a widget to the grid.
//
// The position of child is determined by column and row. The number of “cells”
// that child will occupy is determined by width and height.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//   - column number to attach the left side of child to.
//   - row number to attach the top side of child to.
//   - width: number of columns that child will span.
//   - height: number of rows that child will span.
func (grid *Grid) Attach(child Widgetter, column, row, width, height int) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _arg5 C.int        // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(column)
	_arg3 = C.int(row)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	C.gtk_grid_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(child)
	runtime.KeepAlive(column)
	runtime.KeepAlive(row)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// AttachNextTo adds a widget to the grid.
//
// The widget is placed next to sibling, on the side determined by side. When
// sibling is NULL, the widget is placed in row (for left or right placement) or
// column 0 (for top or bottom placement), at the end indicated by side.
//
// Attaching widgets labeled [1], [2], [3] with sibling == NULL and side ==
// GTK_POS_LEFT yields a layout of [3][2][1].
//
// The function takes the following parameters:
//
//   - child: widget to add.
//   - sibling (optional): child of grid that child will be placed next to,
//     or NULL to place child at the beginning or end.
//   - side of sibling that child is positioned next to.
//   - width: number of columns that child will span.
//   - height: number of rows that child will span.
func (grid *Grid) AttachNextTo(child, sibling Widgetter, side PositionType, width, height int) {
	var _arg0 *C.GtkGrid        // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 *C.GtkWidget      // out
	var _arg3 C.GtkPositionType // out
	var _arg4 C.int             // out
	var _arg5 C.int             // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	}
	_arg3 = C.GtkPositionType(side)
	_arg4 = C.int(width)
	_arg5 = C.int(height)

	C.gtk_grid_attach_next_to(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(child)
	runtime.KeepAlive(sibling)
	runtime.KeepAlive(side)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// BaselineRow returns which row defines the global baseline of grid.
//
// The function returns the following values:
//
//   - gint: row index defining the global baseline.
func (grid *Grid) BaselineRow() int {
	var _arg0 *C.GtkGrid // out
	var _cret C.int      // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_baseline_row(_arg0)
	runtime.KeepAlive(grid)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ChildAt gets the child of grid whose area covers the grid cell at column,
// row.
//
// The function takes the following parameters:
//
//   - column: left edge of the cell.
//   - row: top edge of the cell.
//
// The function returns the following values:
//
//   - widget (optional): child at the given position, or NULL.
func (grid *Grid) ChildAt(column, row int) Widgetter {
	var _arg0 *C.GtkGrid   // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(column)
	_arg2 = C.int(row)

	_cret = C.gtk_grid_get_child_at(_arg0, _arg1, _arg2)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(column)
	runtime.KeepAlive(row)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ColumnHomogeneous returns whether all columns of grid have the same width.
//
// The function returns the following values:
//
//   - ok: whether all columns of grid have the same width.
func (grid *Grid) ColumnHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_column_homogeneous(_arg0)
	runtime.KeepAlive(grid)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnSpacing returns the amount of space between the columns of grid.
//
// The function returns the following values:
//
//   - guint: column spacing of grid.
func (grid *Grid) ColumnSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_column_spacing(_arg0)
	runtime.KeepAlive(grid)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RowBaselinePosition returns the baseline position of row.
//
// See gtk.Grid.SetRowBaselinePosition().
//
// The function takes the following parameters:
//
//   - row index.
//
// The function returns the following values:
//
//   - baselinePosition: baseline position of row.
func (grid *Grid) RowBaselinePosition(row int) BaselinePosition {
	var _arg0 *C.GtkGrid            // out
	var _arg1 C.int                 // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(row)

	_cret = C.gtk_grid_get_row_baseline_position(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(row)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// RowHomogeneous returns whether all rows of grid have the same height.
//
// The function returns the following values:
//
//   - ok: whether all rows of grid have the same height.
func (grid *Grid) RowHomogeneous() bool {
	var _arg0 *C.GtkGrid // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_row_homogeneous(_arg0)
	runtime.KeepAlive(grid)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing returns the amount of space between the rows of grid.
//
// The function returns the following values:
//
//   - guint: row spacing of grid.
func (grid *Grid) RowSpacing() uint {
	var _arg0 *C.GtkGrid // out
	var _cret C.guint    // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_get_row_spacing(_arg0)
	runtime.KeepAlive(grid)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// InsertColumn inserts a column at the specified position.
//
// Children which are attached at or to the right of this position are moved one
// column to the right. Children which span across this position are grown to
// span the new column.
//
// The function takes the following parameters:
//
//   - position to insert the column at.
func (grid *Grid) InsertColumn(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(position)

	C.gtk_grid_insert_column(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(position)
}

// InsertNextTo inserts a row or column at the specified position.
//
// The new row or column is placed next to sibling, on the side determined by
// side. If side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted. If side is
// GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
//
// The function takes the following parameters:
//
//   - sibling: child of grid that the new row or column will be placed next to.
//   - side of sibling that child is positioned next to.
func (grid *Grid) InsertNextTo(sibling Widgetter, side PositionType) {
	var _arg0 *C.GtkGrid        // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 C.GtkPositionType // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(sibling).Native()))
	_arg2 = C.GtkPositionType(side)

	C.gtk_grid_insert_next_to(_arg0, _arg1, _arg2)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(sibling)
	runtime.KeepAlive(side)
}

// InsertRow inserts a row at the specified position.
//
// Children which are attached at or below this position are moved one row down.
// Children which span across this position are grown to span the new row.
//
// The function takes the following parameters:
//
//   - position to insert the row at.
func (grid *Grid) InsertRow(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(position)

	C.gtk_grid_insert_row(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(position)
}

// QueryChild queries the attach points and spans of child inside the given
// GtkGrid.
//
// The function takes the following parameters:
//
//   - child: GtkWidget child of grid.
//
// The function returns the following values:
//
//   - column (optional) used to attach the left side of child.
//   - row (optional) used to attach the top side of child.
//   - width (optional): number of columns child spans.
//   - height (optional): number of rows child spans.
func (grid *Grid) QueryChild(child Widgetter) (column, row, width, height int) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.int        // in
	var _arg3 C.int        // in
	var _arg4 C.int        // in
	var _arg5 C.int        // in

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_grid_query_child(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(child)

	var _column int // out
	var _row int    // out
	var _width int  // out
	var _height int // out

	_column = int(_arg2)
	_row = int(_arg3)
	_width = int(_arg4)
	_height = int(_arg5)

	return _column, _row, _width, _height
}

// Remove removes a child from grid.
//
// The child must have been added with gtk.Grid.Attach() or
// gtk.Grid.AttachNextTo().
//
// The function takes the following parameters:
//
//   - child widget to remove.
func (grid *Grid) Remove(child Widgetter) {
	var _arg0 *C.GtkGrid   // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_grid_remove(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(child)
}

// RemoveColumn removes a column from the grid.
//
// Children that are placed in this column are removed, spanning children that
// overlap this column have their width reduced by one, and children after the
// column are moved to the left.
//
// The function takes the following parameters:
//
//   - position of the column to remove.
func (grid *Grid) RemoveColumn(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(position)

	C.gtk_grid_remove_column(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(position)
}

// RemoveRow removes a row from the grid.
//
// Children that are placed in this row are removed, spanning children that
// overlap this row have their height reduced by one, and children below the row
// are moved up.
//
// The function takes the following parameters:
//
//   - position of the row to remove.
func (grid *Grid) RemoveRow(position int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(position)

	C.gtk_grid_remove_row(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(position)
}

// SetBaselineRow sets which row defines the global baseline for the entire
// grid.
//
// Each row in the grid can have its own local baseline, but only one of those
// is global, meaning it will be the baseline in the parent of the grid.
//
// The function takes the following parameters:
//
//   - row index.
func (grid *Grid) SetBaselineRow(row int) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(row)

	C.gtk_grid_set_baseline_row(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(row)
}

// SetColumnHomogeneous sets whether all columns of grid will have the same
// width.
//
// The function takes the following parameters:
//
//   - homogeneous: TRUE to make columns homogeneous.
func (grid *Grid) SetColumnHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_column_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(homogeneous)
}

// SetColumnSpacing sets the amount of space between columns of grid.
//
// The function takes the following parameters:
//
//   - spacing: amount of space to insert between columns.
func (grid *Grid) SetColumnSpacing(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_grid_set_column_spacing(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(spacing)
}

// SetRowBaselinePosition sets how the baseline should be positioned on row of
// the grid, in case that row is assigned more space than is requested.
//
// The default baseline position is GTK_BASELINE_POSITION_CENTER.
//
// The function takes the following parameters:
//
//   - row index.
//   - pos: GtkBaselinePosition.
func (grid *Grid) SetRowBaselinePosition(row int, pos BaselinePosition) {
	var _arg0 *C.GtkGrid            // out
	var _arg1 C.int                 // out
	var _arg2 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(row)
	_arg2 = C.GtkBaselinePosition(pos)

	C.gtk_grid_set_row_baseline_position(_arg0, _arg1, _arg2)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(row)
	runtime.KeepAlive(pos)
}

// SetRowHomogeneous sets whether all rows of grid will have the same height.
//
// The function takes the following parameters:
//
//   - homogeneous: TRUE to make rows homogeneous.
func (grid *Grid) SetRowHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_set_row_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(homogeneous)
}

// SetRowSpacing sets the amount of space between rows of grid.
//
// The function takes the following parameters:
//
//   - spacing: amount of space to insert between rows.
func (grid *Grid) SetRowSpacing(spacing uint) {
	var _arg0 *C.GtkGrid // out
	var _arg1 C.guint    // out

	_arg0 = (*C.GtkGrid)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_grid_set_row_spacing(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(spacing)
}

// GridLayoutOverrides contains methods that are overridable.
type GridLayoutOverrides struct {
}

func defaultGridLayoutOverrides(v *GridLayout) GridLayoutOverrides {
	return GridLayoutOverrides{}
}

// GridLayout: GtkGridLayout is a layout manager which arranges child widgets in
// rows and columns.
//
// Children have an "attach point" defined by the horizontal and vertical
// index of the cell they occupy; children can span multiple rows or columns.
// The layout properties for setting the attach points and spans are set using
// the gtk.GridLayoutChild associated to each child widget.
//
// The behaviour of GtkGridLayout when several children occupy the same grid
// cell is undefined.
//
// GtkGridLayout can be used like a GtkBoxLayout if all children are attached
// to the same row or column; however, if you only ever need a single row or
// column, you should consider using GtkBoxLayout.
type GridLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*GridLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GridLayout, *GridLayoutClass, GridLayoutOverrides](
		GTypeGridLayout,
		initGridLayoutClass,
		wrapGridLayout,
		defaultGridLayoutOverrides,
	)
}

func initGridLayoutClass(gclass unsafe.Pointer, overrides GridLayoutOverrides, classInitFunc func(*GridLayoutClass)) {
	if classInitFunc != nil {
		class := (*GridLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGridLayout(obj *coreglib.Object) *GridLayout {
	return &GridLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalGridLayout(p uintptr) (interface{}, error) {
	return wrapGridLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewGridLayout creates a new GtkGridLayout.
//
// The function returns the following values:
//
//   - gridLayout: newly created GtkGridLayout.
func NewGridLayout() *GridLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_grid_layout_new()

	var _gridLayout *GridLayout // out

	_gridLayout = wrapGridLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _gridLayout
}

// BaselineRow retrieves the row set with gtk_grid_layout_set_baseline_row().
//
// The function returns the following values:
//
//   - gint: global baseline row.
func (grid *GridLayout) BaselineRow() int {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.int            // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_layout_get_baseline_row(_arg0)
	runtime.KeepAlive(grid)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ColumnHomogeneous checks whether all columns of grid should have the same
// width.
//
// The function returns the following values:
//
//   - ok: TRUE if the columns are homogeneous, and FALSE otherwise.
func (grid *GridLayout) ColumnHomogeneous() bool {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_layout_get_column_homogeneous(_arg0)
	runtime.KeepAlive(grid)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnSpacing retrieves the spacing set with
// gtk_grid_layout_set_column_spacing().
//
// The function returns the following values:
//
//   - guint: spacing between consecutive columns.
func (grid *GridLayout) ColumnSpacing() uint {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_layout_get_column_spacing(_arg0)
	runtime.KeepAlive(grid)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// RowBaselinePosition returns the baseline position of row.
//
// If no value has been set with gtk.GridLayout.SetRowBaselinePosition(),
// the default value of GTK_BASELINE_POSITION_CENTER is returned.
//
// The function takes the following parameters:
//
//   - row index.
//
// The function returns the following values:
//
//   - baselinePosition: baseline position of row.
func (grid *GridLayout) RowBaselinePosition(row int) BaselinePosition {
	var _arg0 *C.GtkGridLayout      // out
	var _arg1 C.int                 // out
	var _cret C.GtkBaselinePosition // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(row)

	_cret = C.gtk_grid_layout_get_row_baseline_position(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(row)

	var _baselinePosition BaselinePosition // out

	_baselinePosition = BaselinePosition(_cret)

	return _baselinePosition
}

// RowHomogeneous checks whether all rows of grid should have the same height.
//
// The function returns the following values:
//
//   - ok: TRUE if the rows are homogeneous, and FALSE otherwise.
func (grid *GridLayout) RowHomogeneous() bool {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_layout_get_row_homogeneous(_arg0)
	runtime.KeepAlive(grid)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing retrieves the spacing set with gtk_grid_layout_set_row_spacing().
//
// The function returns the following values:
//
//   - guint: spacing between consecutive rows.
func (grid *GridLayout) RowSpacing() uint {
	var _arg0 *C.GtkGridLayout // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))

	_cret = C.gtk_grid_layout_get_row_spacing(_arg0)
	runtime.KeepAlive(grid)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetBaselineRow sets which row defines the global baseline for the entire
// grid.
//
// Each row in the grid can have its own local baseline, but only one of those
// is global, meaning it will be the baseline in the parent of the grid.
//
// The function takes the following parameters:
//
//   - row index.
func (grid *GridLayout) SetBaselineRow(row int) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.int            // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(row)

	C.gtk_grid_layout_set_baseline_row(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(row)
}

// SetColumnHomogeneous sets whether all columns of grid should have the same
// width.
//
// The function takes the following parameters:
//
//   - homogeneous: TRUE to make columns homogeneous.
func (grid *GridLayout) SetColumnHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_layout_set_column_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(homogeneous)
}

// SetColumnSpacing sets the amount of space to insert between consecutive
// columns.
//
// The function takes the following parameters:
//
//   - spacing: amount of space between columns, in pixels.
func (grid *GridLayout) SetColumnSpacing(spacing uint) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_grid_layout_set_column_spacing(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(spacing)
}

// SetRowBaselinePosition sets how the baseline should be positioned on row of
// the grid, in case that row is assigned more space than is requested.
//
// The function takes the following parameters:
//
//   - row index.
//   - pos: GtkBaselinePosition.
func (grid *GridLayout) SetRowBaselinePosition(row int, pos BaselinePosition) {
	var _arg0 *C.GtkGridLayout      // out
	var _arg1 C.int                 // out
	var _arg2 C.GtkBaselinePosition // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.int(row)
	_arg2 = C.GtkBaselinePosition(pos)

	C.gtk_grid_layout_set_row_baseline_position(_arg0, _arg1, _arg2)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(row)
	runtime.KeepAlive(pos)
}

// SetRowHomogeneous sets whether all rows of grid should have the same height.
//
// The function takes the following parameters:
//
//   - homogeneous: TRUE to make rows homogeneous.
func (grid *GridLayout) SetRowHomogeneous(homogeneous bool) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	if homogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_grid_layout_set_row_homogeneous(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(homogeneous)
}

// SetRowSpacing sets the amount of space to insert between consecutive rows.
//
// The function takes the following parameters:
//
//   - spacing: amount of space between rows, in pixels.
func (grid *GridLayout) SetRowSpacing(spacing uint) {
	var _arg0 *C.GtkGridLayout // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(coreglib.InternObject(grid).Native()))
	_arg1 = C.guint(spacing)

	C.gtk_grid_layout_set_row_spacing(_arg0, _arg1)
	runtime.KeepAlive(grid)
	runtime.KeepAlive(spacing)
}

// GridLayoutChildOverrides contains methods that are overridable.
type GridLayoutChildOverrides struct {
}

func defaultGridLayoutChildOverrides(v *GridLayoutChild) GridLayoutChildOverrides {
	return GridLayoutChildOverrides{}
}

// GridLayoutChild: GtkLayoutChild subclass for children in a GtkGridLayout.
type GridLayoutChild struct {
	_ [0]func() // equal guard
	LayoutChild
}

var (
	_ LayoutChilder = (*GridLayoutChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*GridLayoutChild, *GridLayoutChildClass, GridLayoutChildOverrides](
		GTypeGridLayoutChild,
		initGridLayoutChildClass,
		wrapGridLayoutChild,
		defaultGridLayoutChildOverrides,
	)
}

func initGridLayoutChildClass(gclass unsafe.Pointer, overrides GridLayoutChildOverrides, classInitFunc func(*GridLayoutChildClass)) {
	if classInitFunc != nil {
		class := (*GridLayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapGridLayoutChild(obj *coreglib.Object) *GridLayoutChild {
	return &GridLayoutChild{
		LayoutChild: LayoutChild{
			Object: obj,
		},
	}
}

func marshalGridLayoutChild(p uintptr) (interface{}, error) {
	return wrapGridLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Column retrieves the column number to which child attaches its left side.
//
// The function returns the following values:
//
//   - gint: column number.
func (child *GridLayoutChild) Column() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_grid_layout_child_get_column(_arg0)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ColumnSpan retrieves the number of columns that child spans to.
//
// The function returns the following values:
//
//   - gint: number of columns.
func (child *GridLayoutChild) ColumnSpan() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_grid_layout_child_get_column_span(_arg0)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Row retrieves the row number to which child attaches its top side.
//
// The function returns the following values:
//
//   - gint: row number.
func (child *GridLayoutChild) Row() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_grid_layout_child_get_row(_arg0)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RowSpan retrieves the number of rows that child spans to.
//
// The function returns the following values:
//
//   - gint: number of row.
func (child *GridLayoutChild) RowSpan() int {
	var _arg0 *C.GtkGridLayoutChild // out
	var _cret C.int                 // in

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_grid_layout_child_get_row_span(_arg0)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SetColumn sets the column number to attach the left side of child.
//
// The function takes the following parameters:
//
//   - column: attach point for child.
func (child *GridLayoutChild) SetColumn(column int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = C.int(column)

	C.gtk_grid_layout_child_set_column(_arg0, _arg1)
	runtime.KeepAlive(child)
	runtime.KeepAlive(column)
}

// SetColumnSpan sets the number of columns child spans to.
//
// The function takes the following parameters:
//
//   - span of child.
func (child *GridLayoutChild) SetColumnSpan(span int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = C.int(span)

	C.gtk_grid_layout_child_set_column_span(_arg0, _arg1)
	runtime.KeepAlive(child)
	runtime.KeepAlive(span)
}

// SetRow sets the row to place child in.
//
// The function takes the following parameters:
//
//   - row for child.
func (child *GridLayoutChild) SetRow(row int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = C.int(row)

	C.gtk_grid_layout_child_set_row(_arg0, _arg1)
	runtime.KeepAlive(child)
	runtime.KeepAlive(row)
}

// SetRowSpan sets the number of rows child spans to.
//
// The function takes the following parameters:
//
//   - span of child.
func (child *GridLayoutChild) SetRowSpan(span int) {
	var _arg0 *C.GtkGridLayoutChild // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg1 = C.int(span)

	C.gtk_grid_layout_child_set_row_span(_arg0, _arg1)
	runtime.KeepAlive(child)
	runtime.KeepAlive(span)
}

// GridView: GtkGridView presents a large dynamic grid of items.
//
// GtkGridView uses its factory to generate one child widget for each visible
// item and shows them in a grid. The orientation of the grid view determines if
// the grid reflows vertically or horizontally.
//
// GtkGridView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected
// items, it is possible to turn on _rubberband selection_, using
// gtk.GridView:enable-rubberband.
//
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
//
// CSS nodes
//
//	gridview
//	├── child
//	│
//	├── child
//	│
//	┊
//	╰── [rubberband]
//
// GtkGridView uses a single CSS node with name gridview. Each child uses a
// single CSS node with name child. For rubberband selection, a subnode with
// name rubberband is used.
//
// # Accessibility
//
// GtkGridView uses the GTK_ACCESSIBLE_ROLE_GRID role, and the items use the
// GTK_ACCESSIBLE_ROLE_GRID_CELL role.
type GridView struct {
	_ [0]func() // equal guard
	ListBase
}

var (
	_ ListBaser = (*GridView)(nil)
)

func wrapGridView(obj *coreglib.Object) *GridView {
	return &GridView{
		ListBase: ListBase{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
			Scrollable: Scrollable{
				Object: obj,
			},
		},
	}
}

func marshalGridView(p uintptr) (interface{}, error) {
	return wrapGridView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when a cell has been activated by the user,
// usually via activating the GtkGridView|list.activate-item action.
//
// This allows for a convenient way to handle activation in a gridview.
// See gtk.ListItem:activatable for details on how to use this signal.
func (self *GridView) ConnectActivate(f func(position uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate", false, unsafe.Pointer(C._gotk4_gtk4_GridView_ConnectActivate), f)
}

// NewGridView creates a new GtkGridView that uses the given factory for mapping
// items to widgets.
//
// The function takes ownership of the arguments, so you can write code like
//
//	grid_view = gtk_grid_view_new (create_model (),
//	  gtk_builder_list_item_factory_new_from_resource ("/resource.ui"));.
//
// The function takes the following parameters:
//
//   - model (optional) to use, or NULL.
//   - factory (optional) to populate items with, or NULL.
//
// The function returns the following values:
//
//   - gridView: new GtkGridView using the given model and factory.
func NewGridView(model SelectionModeller, factory *ListItemFactory) *GridView {
	var _arg1 *C.GtkSelectionModel  // out
	var _arg2 *C.GtkListItemFactory // out
	var _cret *C.GtkWidget          // in

	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	if factory != nil {
		_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(factory).Native()))
	}

	_cret = C.gtk_grid_view_new(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(factory)

	var _gridView *GridView // out

	_gridView = wrapGridView(coreglib.Take(unsafe.Pointer(_cret)))

	return _gridView
}

// EnableRubberband returns whether rows can be selected by dragging with the
// mouse.
//
// The function returns the following values:
//
//   - ok: TRUE if rubberband selection is enabled.
func (self *GridView) EnableRubberband() bool {
	var _arg0 *C.GtkGridView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_grid_view_get_enable_rubberband(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Factory gets the factory that's currently used to populate list items.
//
// The function returns the following values:
//
//   - listItemFactory (optional): factory in use.
func (self *GridView) Factory() *ListItemFactory {
	var _arg0 *C.GtkGridView        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_grid_view_get_factory(_arg0)
	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if _cret != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// MaxColumns gets the maximum number of columns that the grid will use.
//
// The function returns the following values:
//
//   - guint: maximum number of columns.
func (self *GridView) MaxColumns() uint {
	var _arg0 *C.GtkGridView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_grid_view_get_max_columns(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MinColumns gets the minimum number of columns that the grid will use.
//
// The function returns the following values:
//
//   - guint: minimum number of columns.
func (self *GridView) MinColumns() uint {
	var _arg0 *C.GtkGridView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_grid_view_get_min_columns(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Model gets the model that's currently used to read the items displayed.
//
// The function returns the following values:
//
//   - selectionModel (optional): model in use.
func (self *GridView) Model() *SelectionModel {
	var _arg0 *C.GtkGridView       // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_grid_view_get_model(_arg0)
	runtime.KeepAlive(self)

	var _selectionModel *SelectionModel // out

	if _cret != nil {
		_selectionModel = wrapSelectionModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _selectionModel
}

// SingleClickActivate returns whether items will be activated on single click
// and selected on hover.
//
// The function returns the following values:
//
//   - ok: TRUE if items are activated on single click.
func (self *GridView) SingleClickActivate() bool {
	var _arg0 *C.GtkGridView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_grid_view_get_single_click_activate(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetEnableRubberband sets whether selections can be changed by dragging with
// the mouse.
//
// The function takes the following parameters:
//
//   - enableRubberband: TRUE to enable rubberband selection.
func (self *GridView) SetEnableRubberband(enableRubberband bool) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enableRubberband {
		_arg1 = C.TRUE
	}

	C.gtk_grid_view_set_enable_rubberband(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enableRubberband)
}

// SetFactory sets the GtkListItemFactory to use for populating list items.
//
// The function takes the following parameters:
//
//   - factory (optional) to use or NULL for none.
func (self *GridView) SetFactory(factory *ListItemFactory) {
	var _arg0 *C.GtkGridView        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	C.gtk_grid_view_set_factory(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetMaxColumns sets the maximum number of columns to use.
//
// This number must be at least 1.
//
// If max_columns is smaller than the minimum set via
// gtk.GridView.SetMinColumns(), that value is used instead.
//
// The function takes the following parameters:
//
//   - maxColumns: maximum number of columns.
func (self *GridView) SetMaxColumns(maxColumns uint) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(maxColumns)

	C.gtk_grid_view_set_max_columns(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(maxColumns)
}

// SetMinColumns sets the minimum number of columns to use.
//
// This number must be at least 1.
//
// If min_columns is smaller than the minimum set via
// gtk.GridView.SetMaxColumns(), that value is ignored.
//
// The function takes the following parameters:
//
//   - minColumns: minimum number of columns.
func (self *GridView) SetMinColumns(minColumns uint) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(minColumns)

	C.gtk_grid_view_set_min_columns(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(minColumns)
}

// SetModel sets the imodel to use.
//
// This must be a gtk.SelectionModel.
//
// The function takes the following parameters:
//
//   - model (optional) to use or NULL for none.
func (self *GridView) SetModel(model SelectionModeller) {
	var _arg0 *C.GtkGridView       // out
	var _arg1 *C.GtkSelectionModel // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_grid_view_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetSingleClickActivate sets whether items should be activated on single click
// and selected on hover.
//
// The function takes the following parameters:
//
//   - singleClickActivate: TRUE to activate items on single click.
func (self *GridView) SetSingleClickActivate(singleClickActivate bool) {
	var _arg0 *C.GtkGridView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkGridView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if singleClickActivate {
		_arg1 = C.TRUE
	}

	C.gtk_grid_view_set_single_click_activate(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(singleClickActivate)
}

// HeaderBar: GtkHeaderBar is a widget for creating custom title bars for
// windows.
//
// !An example GtkHeaderBar (headerbar.png)
//
// GtkHeaderBar is similar to a horizontal GtkCenterBox. It allows children to
// be placed at the start or the end. In addition, it allows the window title
// to be displayed. The title will be centered with respect to the width of the
// box, even if the children at either side take up different amounts of space.
//
// GtkHeaderBar can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
//
// For these reasons, GtkHeaderBar is the natural choice for use as the custom
// titlebar widget of a `GtkWindow (see gtk.Window.SetTitlebar()), as it gives
// features typical of titlebars while allowing the addition of child widgets.
//
// # GtkHeaderBar as GtkBuildable
//
// The GtkHeaderBar implementation of the GtkBuildable interface supports
// adding children at the start or end sides by specifying “start” or “end” as
// the “type” attribute of a <child> element, or setting the title widget by
// specifying “title” value.
//
// By default the GtkHeaderBar uses a GtkLabel displaying the title of the
// window it is contained in as the title widget, equivalent to the following UI
// definition:
//
//	<object class="GtkHeaderBar">
//	  <property name="title-widget">
//	    <object class="GtkLabel">
//	      <property name="label" translatable="yes">Label</property>
//	      <property name="single-line-mode">True</property>
//	      <property name="ellipsize">end</property>
//	      <property name="width-chars">5</property>
//	      <style>
//	        <class name="title"/>
//	      </style>
//	    </object>
//	  </property>
//	</object>
//
// CSS nodes
//
//	headerbar
//	╰── windowhandle
//	    ╰── box
//	        ├── box.start
//	        │   ├── windowcontrols.start
//	        │   ╰── [other children]
//	        ├── [Title Widget]
//	        ╰── box.end
//	            ├── [other children]
//	            ╰── windowcontrols.end
//
// A GtkHeaderBar's CSS node is called headerbar. It contains a windowhandle
// subnode, which contains a box subnode, which contains two box subnodes at the
// start and end of the header bar, as well as a center node that represents the
// title.
//
// Each of the boxes contains a windowcontrols subnode, see gtk.WindowControls
// for details, as well as other children.
//
// # Accessibility
//
// GtkHeaderBar uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type HeaderBar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*HeaderBar)(nil)
)

func wrapHeaderBar(obj *coreglib.Object) *HeaderBar {
	return &HeaderBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalHeaderBar(p uintptr) (interface{}, error) {
	return wrapHeaderBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewHeaderBar creates a new GtkHeaderBar widget.
//
// The function returns the following values:
//
//   - headerBar: new GtkHeaderBar.
func NewHeaderBar() *HeaderBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_header_bar_new()

	var _headerBar *HeaderBar // out

	_headerBar = wrapHeaderBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _headerBar
}

// DecorationLayout gets the decoration layout of the GtkHeaderBar.
//
// The function returns the following values:
//
//   - utf8 (optional): decoration layout.
func (bar *HeaderBar) DecorationLayout() string {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_header_bar_get_decoration_layout(_arg0)
	runtime.KeepAlive(bar)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// ShowTitleButtons returns whether this header bar shows the standard window
// title buttons.
//
// The function returns the following values:
//
//   - ok: TRUE if title buttons are shown.
func (bar *HeaderBar) ShowTitleButtons() bool {
	var _arg0 *C.GtkHeaderBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_header_bar_get_show_title_buttons(_arg0)
	runtime.KeepAlive(bar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TitleWidget retrieves the title widget of the header.
//
// See gtk.HeaderBar.SetTitleWidget().
//
// The function returns the following values:
//
//   - widget (optional): title widget of the header, or NULL if none has been
//     set explicitly.
func (bar *HeaderBar) TitleWidget() Widgetter {
	var _arg0 *C.GtkHeaderBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_header_bar_get_title_widget(_arg0)
	runtime.KeepAlive(bar)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// PackEnd adds child to bar, packed with reference to the end of the bar.
//
// The function takes the following parameters:
//
//   - child to be added to bar.
func (bar *HeaderBar) PackEnd(child Widgetter) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_header_bar_pack_end(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(child)
}

// PackStart adds child to bar, packed with reference to the start of the bar.
//
// The function takes the following parameters:
//
//   - child to be added to bar.
func (bar *HeaderBar) PackStart(child Widgetter) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_header_bar_pack_start(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(child)
}

// Remove removes a child from the GtkHeaderBar.
//
// The child must have been added with gtk.HeaderBar.PackStart(),
// gtk.HeaderBar.PackEnd() or gtk.HeaderBar.SetTitleWidget().
//
// The function takes the following parameters:
//
//   - child to remove.
func (bar *HeaderBar) Remove(child Widgetter) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_header_bar_remove(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(child)
}

// SetDecorationLayout sets the decoration layout for this header bar.
//
// This property overrides the gtk.Settings:gtk-decoration-layout setting.
//
// There can be valid reasons for overriding the setting, such as a header bar
// design that does not allow for buttons to take room on the right, or only
// offers room for a single close button. Split header bars are another example
// for overriding the setting.
//
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the right.
// Recognized button names are minimize, maximize, close and icon (the window
// icon).
//
// For example, “icon:minimize,maximize,close” specifies a icon on the left,
// and minimize, maximize and close buttons on the right.
//
// The function takes the following parameters:
//
//   - layout (optional): decoration layout, or NULL to unset the layout.
func (bar *HeaderBar) SetDecorationLayout(layout string) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if layout != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(layout)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_header_bar_set_decoration_layout(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(layout)
}

// SetShowTitleButtons sets whether this header bar shows the standard window
// title buttons.
//
// The function takes the following parameters:
//
//   - setting: TRUE to show standard title buttons.
func (bar *HeaderBar) SetShowTitleButtons(setting bool) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_header_bar_set_show_title_buttons(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(setting)
}

// SetTitleWidget sets the title for the GtkHeaderBar.
//
// When set to NULL, the headerbar will display the title of the window it is
// contained in.
//
// The title should help a user identify the current view. To achieve the same
// style as the builtin title, use the “title” style class.
//
// You should set the title widget to NULL, for the window title label to be
// visible again.
//
// The function takes the following parameters:
//
//   - titleWidget (optional): widget to use for a title.
func (bar *HeaderBar) SetTitleWidget(titleWidget Widgetter) {
	var _arg0 *C.GtkHeaderBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if titleWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(titleWidget).Native()))
	}

	C.gtk_header_bar_set_title_widget(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(titleWidget)
}

// IMContextOverrides contains methods that are overridable.
type IMContextOverrides struct {
	Commit func(str string)
	// DeleteSurrounding asks the widget that the input context is attached
	// to delete characters around the cursor position by emitting the
	// GtkIMContext::delete_surrounding signal.
	//
	// Note that offset and n_chars are in characters not in bytes which differs
	// from the usage other places in IMContext.
	//
	// In order to use this function, you should first call
	// gtk_im_context_get_surrounding() to get the current context, and call
	// this function immediately afterwards to make sure that you know what
	// you are deleting. You should also account for the fact that even if the
	// signal was handled, the input context might not have deleted all the
	// characters that were requested to be deleted.
	//
	// This function is used by an input method that wants to make subsitutions
	// in the existing text in response to new input. It is not useful for
	// applications.
	//
	// The function takes the following parameters:
	//
	//   - offset from cursor position in chars; a negative value means start
	//     before the cursor.
	//   - nChars: number of characters to delete.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the signal was handled.
	DeleteSurrounding func(offset, nChars int) bool
	// FilterKeypress: allow an input method to internally handle key press and
	// release events.
	//
	// If this function returns TRUE, then no further processing should be done
	// for this key event.
	//
	// The function takes the following parameters:
	//
	//   - event: key event.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the input method handled the key event.
	FilterKeypress func(event gdk.Eventer) bool
	// FocusIn: notify the input method that the widget to which this input
	// context corresponds has gained focus.
	//
	// The input method may, for example, change the displayed feedback to
	// reflect this change.
	FocusIn func()
	// FocusOut: notify the input method that the widget to which this input
	// context corresponds has lost focus.
	//
	// The input method may, for example, change the displayed feedback or reset
	// the contexts state to reflect this change.
	FocusOut func()
	// PreeditString: retrieve the current preedit string for the input context,
	// and a list of attributes to apply to the string.
	//
	// This string should be displayed inserted at the insertion point.
	//
	// The function returns the following values:
	//
	//   - str: location to store the retrieved string. The string retrieved
	//     must be freed with g_free().
	//   - attrs: location to store the retrieved attribute list.
	//     When you are done with this list, you must unreference it with
	//     pango_attr_list_unref().
	//   - cursorPos: location to store position of cursor (in characters)
	//     within the preedit string.
	PreeditString func() (string, *pango.AttrList, int)
	// Surrounding retrieves context around the insertion point.
	//
	// Input methods typically want context in order to constrain input text
	// based on existing text; this is important for languages such as Thai
	// where only some sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// gtk.IMContext::retrieve-surrounding signal on the input method;
	// in response to this signal, a widget should provide as much
	// context as is available, up to an entire paragraph, by calling
	// gtk.IMContext.SetSurrounding().
	//
	// Note that there is no obligation for a widget to respond to the
	// ::retrieve-surrounding signal, so input methods must be prepared to
	// function without context.
	//
	// Deprecated: Use gtk.IMContext.GetSurroundingWithSelection() instead.
	//
	// The function returns the following values:
	//
	//   - text: location to store a UTF-8 encoded string of text holding
	//     context around the insertion point. If the function returns TRUE,
	//     then you must free the result stored in this location with g_free().
	//   - cursorIndex: location to store byte index of the insertion cursor
	//     within text.
	//   - ok: TRUE if surrounding text was provided; in this case you must free
	//     the result stored in text.
	Surrounding func() (string, int, bool)
	// SurroundingWithSelection retrieves context around the insertion point.
	//
	// Input methods typically want context in order to constrain input text
	// based on existing text; this is important for languages such as Thai
	// where only some sequences of characters are allowed.
	//
	// This function is implemented by emitting the
	// gtk.IMContext::retrieve-surrounding signal on the input method;
	// in response to this signal, a widget should provide as much
	// context as is available, up to an entire paragraph, by calling
	// gtk.IMContext.SetSurroundingWithSelection().
	//
	// Note that there is no obligation for a widget to respond to the
	// ::retrieve-surrounding signal, so input methods must be prepared to
	// function without context.
	//
	// The function returns the following values:
	//
	//   - text: location to store a UTF-8 encoded string of text holding
	//     context around the insertion point. If the function returns TRUE,
	//     then you must free the result stored in this location with g_free().
	//   - cursorIndex: location to store byte index of the insertion cursor
	//     within text.
	//   - anchorIndex: location to store byte index of the selection bound
	//     within text.
	//   - ok: TRUE if surrounding text was provided; in this case you must free
	//     the result stored in text.
	SurroundingWithSelection func() (text string, cursorIndex, anchorIndex int, ok bool)
	PreeditChanged           func()
	PreeditEnd               func()
	PreeditStart             func()
	// Reset: notify the input method that a change such as a change in cursor
	// position has been made.
	//
	// This will typically cause the input method to clear the preedit state.
	Reset               func()
	RetrieveSurrounding func() bool
	// SetClientWidget: set the client widget for the input context.
	//
	// This is the GtkWidget holding the input focus. This widget is used in
	// order to correctly position status windows, and may also be used for
	// purposes internal to the input method.
	//
	// The function takes the following parameters:
	//
	//   - widget (optional): client widget. This may be NULL to indicate that
	//     the previous client widget no longer exists.
	SetClientWidget func(widget Widgetter)
	// SetCursorLocation: notify the input method that a change in cursor
	// position has been made.
	//
	// The location is relative to the client window.
	//
	// The function takes the following parameters:
	//
	//   - area: new location.
	SetCursorLocation func(area *gdk.Rectangle)
	// SetSurrounding sets surrounding context around the insertion point and
	// preedit string.
	//
	// This function is expected to be called in response to the
	// gtk.IMContext::retrieve-surrounding signal, and will likely have no
	// effect if called at other times.
	//
	// Deprecated: Use gtk.IMContext.SetSurroundingWithSelection() instead.
	//
	// The function takes the following parameters:
	//
	//   - text surrounding the insertion point, as UTF-8. the preedit string
	//     should not be included within text.
	//   - len: length of text, or -1 if text is nul-terminated.
	//   - cursorIndex: byte index of the insertion cursor within text.
	SetSurrounding func(text string, len, cursorIndex int)
	// SetSurroundingWithSelection sets surrounding context around the insertion
	// point and preedit string. This function is expected to be called in
	// response to the GtkIMContext::retrieve_surrounding signal, and will
	// likely have no effect if called at other times.
	//
	// The function takes the following parameters:
	//
	//   - text surrounding the insertion point, as UTF-8. the preedit string
	//     should not be included within text.
	//   - len: length of text, or -1 if text is nul-terminated.
	//   - cursorIndex: byte index of the insertion cursor within text.
	//   - anchorIndex: byte index of the selection bound within text.
	SetSurroundingWithSelection func(text string, len, cursorIndex, anchorIndex int)
	// SetUsePreedit sets whether the IM context should use the preedit string
	// to display feedback.
	//
	// If use_preedit is FALSE (default is TRUE), then the IM context may use
	// some other method to display feedback, such as displaying it in a child
	// of the root window.
	//
	// The function takes the following parameters:
	//
	//   - usePreedit: whether the IM context should use the preedit string.
	SetUsePreedit func(usePreedit bool)
}

func defaultIMContextOverrides(v *IMContext) IMContextOverrides {
	return IMContextOverrides{
		Commit:                      v.commit,
		DeleteSurrounding:           v.deleteSurrounding,
		FilterKeypress:              v.filterKeypress,
		FocusIn:                     v.focusIn,
		FocusOut:                    v.focusOut,
		PreeditString:               v.preeditString,
		Surrounding:                 v.surrounding,
		SurroundingWithSelection:    v.surroundingWithSelection,
		PreeditChanged:              v.preeditChanged,
		PreeditEnd:                  v.preeditEnd,
		PreeditStart:                v.preeditStart,
		Reset:                       v.reset,
		RetrieveSurrounding:         v.retrieveSurrounding,
		SetClientWidget:             v.setClientWidget,
		SetCursorLocation:           v.setCursorLocation,
		SetSurrounding:              v.setSurrounding,
		SetSurroundingWithSelection: v.setSurroundingWithSelection,
		SetUsePreedit:               v.setUsePreedit,
	}
}

// IMContext: GtkIMContext defines the interface for GTK input methods.
//
// GtkIMContext is used by GTK text input widgets like GtkText to map from key
// events to Unicode character strings.
//
// By default, GTK uses a platform-dependent default input method. On Windows,
// the default implementation is IME-based and on Wayland, it is using the
// Wayland text protocol. The choice can be overridden programmatically via
// the gtk.Settings:gtk-im-module setting. Users may set the GTK_IM_MODULE
// environment variable to override the default.
//
// Text widgets have a :im-module property (e.g. gtk.TextView:im-module)
// that may also be used to set input methods for specific widget instances.
// For instance, a certain entry widget might be expected to contain certain
// characters which would be easier to input with a specific input method.
//
// An input method may consume multiple key events in sequence before finally
// outputting the composed result. This is called *preediting*, and an input
// method may provide feedback about this process by displaying the intermediate
// composition states as preedit text.
//
// For instance, the built-in GTK input method GtkIMContextSimple implements the
// input of arbitrary Unicode code points by holding down the <kbd>Control</kbd>
// and <kbd>Shift</kbd> keys and then typing <kbd>U</kbd> followed by the
// hexadecimal digits of the code point. When releasing the <kbd>Control</kbd>
// and <kbd>Shift</kbd> keys, preediting ends and the character is inserted as
// text. For example,
//
//	Ctrl+Shift+u 2 0 A C
//
// results in the € sign.
//
// Additional input methods can be made available for use by GTK widgets as
// loadable modules. An input method module is a small shared library which
// provides a GIOExtension for the extension point named "gtk-im-module".
type IMContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IMContext)(nil)
)

// IMContexter describes types inherited from class IMContext.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type IMContexter interface {
	coreglib.Objector
	baseIMContext() *IMContext
}

var _ IMContexter = (*IMContext)(nil)

func init() {
	coreglib.RegisterClassInfo[*IMContext, *IMContextClass, IMContextOverrides](
		GTypeIMContext,
		initIMContextClass,
		wrapIMContext,
		defaultIMContextOverrides,
	)
}

func initIMContextClass(gclass unsafe.Pointer, overrides IMContextOverrides, classInitFunc func(*IMContextClass)) {
	pclass := (*C.GtkIMContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeIMContext))))

	if overrides.Commit != nil {
		pclass.commit = (*[0]byte)(C._gotk4_gtk4_IMContextClass_commit)
	}

	if overrides.DeleteSurrounding != nil {
		pclass.delete_surrounding = (*[0]byte)(C._gotk4_gtk4_IMContextClass_delete_surrounding)
	}

	if overrides.FilterKeypress != nil {
		pclass.filter_keypress = (*[0]byte)(C._gotk4_gtk4_IMContextClass_filter_keypress)
	}

	if overrides.FocusIn != nil {
		pclass.focus_in = (*[0]byte)(C._gotk4_gtk4_IMContextClass_focus_in)
	}

	if overrides.FocusOut != nil {
		pclass.focus_out = (*[0]byte)(C._gotk4_gtk4_IMContextClass_focus_out)
	}

	if overrides.PreeditString != nil {
		pclass.get_preedit_string = (*[0]byte)(C._gotk4_gtk4_IMContextClass_get_preedit_string)
	}

	if overrides.Surrounding != nil {
		pclass.get_surrounding = (*[0]byte)(C._gotk4_gtk4_IMContextClass_get_surrounding)
	}

	if overrides.SurroundingWithSelection != nil {
		pclass.get_surrounding_with_selection = (*[0]byte)(C._gotk4_gtk4_IMContextClass_get_surrounding_with_selection)
	}

	if overrides.PreeditChanged != nil {
		pclass.preedit_changed = (*[0]byte)(C._gotk4_gtk4_IMContextClass_preedit_changed)
	}

	if overrides.PreeditEnd != nil {
		pclass.preedit_end = (*[0]byte)(C._gotk4_gtk4_IMContextClass_preedit_end)
	}

	if overrides.PreeditStart != nil {
		pclass.preedit_start = (*[0]byte)(C._gotk4_gtk4_IMContextClass_preedit_start)
	}

	if overrides.Reset != nil {
		pclass.reset = (*[0]byte)(C._gotk4_gtk4_IMContextClass_reset)
	}

	if overrides.RetrieveSurrounding != nil {
		pclass.retrieve_surrounding = (*[0]byte)(C._gotk4_gtk4_IMContextClass_retrieve_surrounding)
	}

	if overrides.SetClientWidget != nil {
		pclass.set_client_widget = (*[0]byte)(C._gotk4_gtk4_IMContextClass_set_client_widget)
	}

	if overrides.SetCursorLocation != nil {
		pclass.set_cursor_location = (*[0]byte)(C._gotk4_gtk4_IMContextClass_set_cursor_location)
	}

	if overrides.SetSurrounding != nil {
		pclass.set_surrounding = (*[0]byte)(C._gotk4_gtk4_IMContextClass_set_surrounding)
	}

	if overrides.SetSurroundingWithSelection != nil {
		pclass.set_surrounding_with_selection = (*[0]byte)(C._gotk4_gtk4_IMContextClass_set_surrounding_with_selection)
	}

	if overrides.SetUsePreedit != nil {
		pclass.set_use_preedit = (*[0]byte)(C._gotk4_gtk4_IMContextClass_set_use_preedit)
	}

	if classInitFunc != nil {
		class := (*IMContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapIMContext(obj *coreglib.Object) *IMContext {
	return &IMContext{
		Object: obj,
	}
}

func marshalIMContext(p uintptr) (interface{}, error) {
	return wrapIMContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (context *IMContext) baseIMContext() *IMContext {
	return context
}

// BaseIMContext returns the underlying base object.
func BaseIMContext(obj IMContexter) *IMContext {
	return obj.baseIMContext()
}

// ConnectCommit signal is emitted when a complete input sequence has been
// entered by the user. This can be a single character immediately after a key
// press or the final result of preediting.
func (context *IMContext) ConnectCommit(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "commit", false, unsafe.Pointer(C._gotk4_gtk4_IMContext_ConnectCommit), f)
}

// ConnectDeleteSurrounding signal is emitted when the input method needs to
// delete all or part of the context surrounding the cursor.
func (context *IMContext) ConnectDeleteSurrounding(f func(offset, nChars int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "delete-surrounding", false, unsafe.Pointer(C._gotk4_gtk4_IMContext_ConnectDeleteSurrounding), f)
}

// ConnectPreeditChanged signal is emitted whenever the preedit sequence
// currently being entered has changed. It is also emitted at the end of a
// preedit sequence, in which case gtk_im_context_get_preedit_string() returns
// the empty string.
func (context *IMContext) ConnectPreeditChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk4_IMContext_ConnectPreeditChanged), f)
}

// ConnectPreeditEnd signal is emitted when a preediting sequence has been
// completed or canceled.
func (context *IMContext) ConnectPreeditEnd(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "preedit-end", false, unsafe.Pointer(C._gotk4_gtk4_IMContext_ConnectPreeditEnd), f)
}

// ConnectPreeditStart signal is emitted when a new preediting sequence starts.
func (context *IMContext) ConnectPreeditStart(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "preedit-start", false, unsafe.Pointer(C._gotk4_gtk4_IMContext_ConnectPreeditStart), f)
}

// ConnectRetrieveSurrounding signal is emitted when the input method requires
// the context surrounding the cursor. The callback should set the input method
// surrounding context by calling the gtk_im_context_set_surrounding() method.
func (context *IMContext) ConnectRetrieveSurrounding(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(context, "retrieve-surrounding", false, unsafe.Pointer(C._gotk4_gtk4_IMContext_ConnectRetrieveSurrounding), f)
}

// DeleteSurrounding asks the widget that the input context is attached
// to delete characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal.
//
// Note that offset and n_chars are in characters not in bytes which differs
// from the usage other places in IMContext.
//
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and call this
// function immediately afterwards to make sure that you know what you are
// deleting. You should also account for the fact that even if the signal was
// handled, the input context might not have deleted all the characters that
// were requested to be deleted.
//
// This function is used by an input method that wants to make subsitutions
// in the existing text in response to new input. It is not useful for
// applications.
//
// The function takes the following parameters:
//
//   - offset from cursor position in chars; a negative value means start before
//     the cursor.
//   - nChars: number of characters to delete.
//
// The function returns the following values:
//
//   - ok: TRUE if the signal was handled.
func (context *IMContext) DeleteSurrounding(offset, nChars int) bool {
	var _arg0 *C.GtkIMContext // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(offset)
	_arg2 = C.int(nChars)

	_cret = C.gtk_im_context_delete_surrounding(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(nChars)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FilterKey: allow an input method to forward key press and release events to
// another input methodm without necessarily having a GdkEvent available.
//
// The function takes the following parameters:
//
//   - press: whether to forward a key press or release event.
//   - surface the event is for.
//   - device that the event is for.
//   - time: timestamp for the event.
//   - keycode for the event.
//   - state: modifier state for the event.
//   - group: active keyboard group for the event.
//
// The function returns the following values:
//
//   - ok: TRUE if the input method handled the key event.
func (context *IMContext) FilterKey(press bool, surface gdk.Surfacer, device gdk.Devicer, time uint32, keycode uint, state gdk.ModifierType, group int) bool {
	var _arg0 *C.GtkIMContext   // out
	var _arg1 C.gboolean        // out
	var _arg2 *C.GdkSurface     // out
	var _arg3 *C.GdkDevice      // out
	var _arg4 C.guint32         // out
	var _arg5 C.guint           // out
	var _arg6 C.GdkModifierType // out
	var _arg7 C.int             // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if press {
		_arg1 = C.TRUE
	}
	_arg2 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))
	_arg3 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(device).Native()))
	_arg4 = C.guint32(time)
	_arg5 = C.guint(keycode)
	_arg6 = C.GdkModifierType(state)
	_arg7 = C.int(group)

	_cret = C.gtk_im_context_filter_key(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
	runtime.KeepAlive(context)
	runtime.KeepAlive(press)
	runtime.KeepAlive(surface)
	runtime.KeepAlive(device)
	runtime.KeepAlive(time)
	runtime.KeepAlive(keycode)
	runtime.KeepAlive(state)
	runtime.KeepAlive(group)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FilterKeypress: allow an input method to internally handle key press and
// release events.
//
// If this function returns TRUE, then no further processing should be done for
// this key event.
//
// The function takes the following parameters:
//
//   - event: key event.
//
// The function returns the following values:
//
//   - ok: TRUE if the input method handled the key event.
func (context *IMContext) FilterKeypress(event gdk.Eventer) bool {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkEvent     // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gtk_im_context_filter_keypress(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FocusIn: notify the input method that the widget to which this input context
// corresponds has gained focus.
//
// The input method may, for example, change the displayed feedback to reflect
// this change.
func (context *IMContext) FocusIn() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_im_context_focus_in(_arg0)
	runtime.KeepAlive(context)
}

// FocusOut: notify the input method that the widget to which this input context
// corresponds has lost focus.
//
// The input method may, for example, change the displayed feedback or reset the
// contexts state to reflect this change.
func (context *IMContext) FocusOut() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_im_context_focus_out(_arg0)
	runtime.KeepAlive(context)
}

// PreeditString: retrieve the current preedit string for the input context,
// and a list of attributes to apply to the string.
//
// This string should be displayed inserted at the insertion point.
//
// The function returns the following values:
//
//   - str: location to store the retrieved string. The string retrieved must be
//     freed with g_free().
//   - attrs: location to store the retrieved attribute list. When you are done
//     with this list, you must unreference it with pango_attr_list_unref().
//   - cursorPos: location to store position of cursor (in characters) within
//     the preedit string.
func (context *IMContext) PreeditString() (string, *pango.AttrList, int) {
	var _arg0 *C.GtkIMContext  // out
	var _arg1 *C.char          // in
	var _arg2 *C.PangoAttrList // in
	var _arg3 C.int            // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_im_context_get_preedit_string(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)

	var _str string            // out
	var _attrs *pango.AttrList // out
	var _cursorPos int         // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	defer C.free(unsafe.Pointer(_arg1))
	_attrs = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrs)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
		},
	)
	_cursorPos = int(_arg3)

	return _str, _attrs, _cursorPos
}

// Surrounding retrieves context around the insertion point.
//
// Input methods typically want context in order to constrain input text based
// on existing text; this is important for languages such as Thai where only
// some sequences of characters are allowed.
//
// This function is implemented by emitting the
// gtk.IMContext::retrieve-surrounding signal on the input method; in response
// to this signal, a widget should provide as much context as is available,
// up to an entire paragraph, by calling gtk.IMContext.SetSurrounding().
//
// Note that there is no obligation for a widget to respond to the
// ::retrieve-surrounding signal, so input methods must be prepared to function
// without context.
//
// Deprecated: Use gtk.IMContext.GetSurroundingWithSelection() instead.
//
// The function returns the following values:
//
//   - text: location to store a UTF-8 encoded string of text holding context
//     around the insertion point. If the function returns TRUE, then you must
//     free the result stored in this location with g_free().
//   - cursorIndex: location to store byte index of the insertion cursor within
//     text.
//   - ok: TRUE if surrounding text was provided; in this case you must free the
//     result stored in text.
func (context *IMContext) Surrounding() (string, int, bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // in
	var _arg2 C.int           // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_im_context_get_surrounding(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _text string     // out
	var _cursorIndex int // out
	var _ok bool         // out

	_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	defer C.free(unsafe.Pointer(_arg1))
	_cursorIndex = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _text, _cursorIndex, _ok
}

// SurroundingWithSelection retrieves context around the insertion point.
//
// Input methods typically want context in order to constrain input text based
// on existing text; this is important for languages such as Thai where only
// some sequences of characters are allowed.
//
// This function is implemented by emitting the
// gtk.IMContext::retrieve-surrounding signal on the input method;
// in response to this signal, a widget should provide as much
// context as is available, up to an entire paragraph, by calling
// gtk.IMContext.SetSurroundingWithSelection().
//
// Note that there is no obligation for a widget to respond to the
// ::retrieve-surrounding signal, so input methods must be prepared to function
// without context.
//
// The function returns the following values:
//
//   - text: location to store a UTF-8 encoded string of text holding context
//     around the insertion point. If the function returns TRUE, then you must
//     free the result stored in this location with g_free().
//   - cursorIndex: location to store byte index of the insertion cursor within
//     text.
//   - anchorIndex: location to store byte index of the selection bound within
//     text.
//   - ok: TRUE if surrounding text was provided; in this case you must free the
//     result stored in text.
func (context *IMContext) SurroundingWithSelection() (text string, cursorIndex, anchorIndex int, ok bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // in
	var _arg2 C.int           // in
	var _arg3 C.int           // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_im_context_get_surrounding_with_selection(_arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)

	var _text string     // out
	var _cursorIndex int // out
	var _anchorIndex int // out
	var _ok bool         // out

	_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	defer C.free(unsafe.Pointer(_arg1))
	_cursorIndex = int(_arg2)
	_anchorIndex = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _text, _cursorIndex, _anchorIndex, _ok
}

// Reset: notify the input method that a change such as a change in cursor
// position has been made.
//
// This will typically cause the input method to clear the preedit state.
func (context *IMContext) Reset() {
	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_im_context_reset(_arg0)
	runtime.KeepAlive(context)
}

// SetClientWidget: set the client widget for the input context.
//
// This is the GtkWidget holding the input focus. This widget is used in order
// to correctly position status windows, and may also be used for purposes
// internal to the input method.
//
// The function takes the following parameters:
//
//   - widget (optional): client widget. This may be NULL to indicate that the
//     previous client widget no longer exists.
func (context *IMContext) SetClientWidget(widget Widgetter) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_im_context_set_client_widget(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
}

// SetCursorLocation: notify the input method that a change in cursor position
// has been made.
//
// The location is relative to the client window.
//
// The function takes the following parameters:
//
//   - area: new location.
func (context *IMContext) SetCursorLocation(area *gdk.Rectangle) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))

	C.gtk_im_context_set_cursor_location(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(area)
}

// SetSurrounding sets surrounding context around the insertion point and
// preedit string.
//
// This function is expected to be called in response to the
// gtk.IMContext::retrieve-surrounding signal, and will likely have no effect if
// called at other times.
//
// Deprecated: Use gtk.IMContext.SetSurroundingWithSelection() instead.
//
// The function takes the following parameters:
//
//   - text surrounding the insertion point, as UTF-8. the preedit string should
//     not be included within text.
//   - len: length of text, or -1 if text is nul-terminated.
//   - cursorIndex: byte index of the insertion cursor within text.
func (context *IMContext) SetSurrounding(text string, len, cursorIndex int) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)
	_arg3 = C.int(cursorIndex)

	C.gtk_im_context_set_surrounding(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(cursorIndex)
}

// SetSurroundingWithSelection sets surrounding context around the insertion
// point and preedit string. This function is expected to be called in response
// to the GtkIMContext::retrieve_surrounding signal, and will likely have no
// effect if called at other times.
//
// The function takes the following parameters:
//
//   - text surrounding the insertion point, as UTF-8. the preedit string should
//     not be included within text.
//   - len: length of text, or -1 if text is nul-terminated.
//   - cursorIndex: byte index of the insertion cursor within text.
//   - anchorIndex: byte index of the selection bound within text.
func (context *IMContext) SetSurroundingWithSelection(text string, len, cursorIndex, anchorIndex int) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out
	var _arg4 C.int           // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)
	_arg3 = C.int(cursorIndex)
	_arg4 = C.int(anchorIndex)

	C.gtk_im_context_set_surrounding_with_selection(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(cursorIndex)
	runtime.KeepAlive(anchorIndex)
}

// SetUsePreedit sets whether the IM context should use the preedit string to
// display feedback.
//
// If use_preedit is FALSE (default is TRUE), then the IM context may use some
// other method to display feedback, such as displaying it in a child of the
// root window.
//
// The function takes the following parameters:
//
//   - usePreedit: whether the IM context should use the preedit string.
func (context *IMContext) SetUsePreedit(usePreedit bool) {
	var _arg0 *C.GtkIMContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if usePreedit {
		_arg1 = C.TRUE
	}

	C.gtk_im_context_set_use_preedit(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(usePreedit)
}

func (context *IMContext) commit(str string) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.commit

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gtk4_IMContext_virtual_commit(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(str)
}

// deleteSurrounding asks the widget that the input context is attached
// to delete characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal.
//
// Note that offset and n_chars are in characters not in bytes which differs
// from the usage other places in IMContext.
//
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and call this
// function immediately afterwards to make sure that you know what you are
// deleting. You should also account for the fact that even if the signal was
// handled, the input context might not have deleted all the characters that
// were requested to be deleted.
//
// This function is used by an input method that wants to make subsitutions
// in the existing text in response to new input. It is not useful for
// applications.
//
// The function takes the following parameters:
//
//   - offset from cursor position in chars; a negative value means start before
//     the cursor.
//   - nChars: number of characters to delete.
//
// The function returns the following values:
//
//   - ok: TRUE if the signal was handled.
func (context *IMContext) deleteSurrounding(offset, nChars int) bool {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.delete_surrounding

	var _arg0 *C.GtkIMContext // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(offset)
	_arg2 = C.int(nChars)

	_cret = C._gotk4_gtk4_IMContext_virtual_delete_surrounding(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(nChars)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// filterKeypress: allow an input method to internally handle key press and
// release events.
//
// If this function returns TRUE, then no further processing should be done for
// this key event.
//
// The function takes the following parameters:
//
//   - event: key event.
//
// The function returns the following values:
//
//   - ok: TRUE if the input method handled the key event.
func (context *IMContext) filterKeypress(event gdk.Eventer) bool {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.filter_keypress

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkEvent     // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C._gotk4_gtk4_IMContext_virtual_filter_keypress(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// focusIn: notify the input method that the widget to which this input context
// corresponds has gained focus.
//
// The input method may, for example, change the displayed feedback to reflect
// this change.
func (context *IMContext) focusIn() {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.focus_in

	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_IMContext_virtual_focus_in(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// focusOut: notify the input method that the widget to which this input context
// corresponds has lost focus.
//
// The input method may, for example, change the displayed feedback or reset the
// contexts state to reflect this change.
func (context *IMContext) focusOut() {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.focus_out

	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_IMContext_virtual_focus_out(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// preeditString: retrieve the current preedit string for the input context,
// and a list of attributes to apply to the string.
//
// This string should be displayed inserted at the insertion point.
//
// The function returns the following values:
//
//   - str: location to store the retrieved string. The string retrieved must be
//     freed with g_free().
//   - attrs: location to store the retrieved attribute list. When you are done
//     with this list, you must unreference it with pango_attr_list_unref().
//   - cursorPos: location to store position of cursor (in characters) within
//     the preedit string.
func (context *IMContext) preeditString() (string, *pango.AttrList, int) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_preedit_string

	var _arg0 *C.GtkIMContext  // out
	var _arg1 *C.char          // in
	var _arg2 *C.PangoAttrList // in
	var _arg3 C.int            // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_IMContext_virtual_get_preedit_string(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)

	var _str string            // out
	var _attrs *pango.AttrList // out
	var _cursorPos int         // out

	_str = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	defer C.free(unsafe.Pointer(_arg1))
	_attrs = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_attrs)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
		},
	)
	_cursorPos = int(_arg3)

	return _str, _attrs, _cursorPos
}

// Surrounding retrieves context around the insertion point.
//
// Input methods typically want context in order to constrain input text based
// on existing text; this is important for languages such as Thai where only
// some sequences of characters are allowed.
//
// This function is implemented by emitting the
// gtk.IMContext::retrieve-surrounding signal on the input method; in response
// to this signal, a widget should provide as much context as is available,
// up to an entire paragraph, by calling gtk.IMContext.SetSurrounding().
//
// Note that there is no obligation for a widget to respond to the
// ::retrieve-surrounding signal, so input methods must be prepared to function
// without context.
//
// Deprecated: Use gtk.IMContext.GetSurroundingWithSelection() instead.
//
// The function returns the following values:
//
//   - text: location to store a UTF-8 encoded string of text holding context
//     around the insertion point. If the function returns TRUE, then you must
//     free the result stored in this location with g_free().
//   - cursorIndex: location to store byte index of the insertion cursor within
//     text.
//   - ok: TRUE if surrounding text was provided; in this case you must free the
//     result stored in text.
func (context *IMContext) surrounding() (string, int, bool) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_surrounding

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // in
	var _arg2 C.int           // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gtk4_IMContext_virtual_get_surrounding(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(context)

	var _text string     // out
	var _cursorIndex int // out
	var _ok bool         // out

	_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	defer C.free(unsafe.Pointer(_arg1))
	_cursorIndex = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _text, _cursorIndex, _ok
}

// surroundingWithSelection retrieves context around the insertion point.
//
// Input methods typically want context in order to constrain input text based
// on existing text; this is important for languages such as Thai where only
// some sequences of characters are allowed.
//
// This function is implemented by emitting the
// gtk.IMContext::retrieve-surrounding signal on the input method;
// in response to this signal, a widget should provide as much
// context as is available, up to an entire paragraph, by calling
// gtk.IMContext.SetSurroundingWithSelection().
//
// Note that there is no obligation for a widget to respond to the
// ::retrieve-surrounding signal, so input methods must be prepared to function
// without context.
//
// The function returns the following values:
//
//   - text: location to store a UTF-8 encoded string of text holding context
//     around the insertion point. If the function returns TRUE, then you must
//     free the result stored in this location with g_free().
//   - cursorIndex: location to store byte index of the insertion cursor within
//     text.
//   - anchorIndex: location to store byte index of the selection bound within
//     text.
//   - ok: TRUE if surrounding text was provided; in this case you must free the
//     result stored in text.
func (context *IMContext) surroundingWithSelection() (text string, cursorIndex, anchorIndex int, ok bool) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.get_surrounding_with_selection

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // in
	var _arg2 C.int           // in
	var _arg3 C.int           // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gtk4_IMContext_virtual_get_surrounding_with_selection(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2, &_arg3)
	runtime.KeepAlive(context)

	var _text string     // out
	var _cursorIndex int // out
	var _anchorIndex int // out
	var _ok bool         // out

	_text = C.GoString((*C.gchar)(unsafe.Pointer(_arg1)))
	defer C.free(unsafe.Pointer(_arg1))
	_cursorIndex = int(_arg2)
	_anchorIndex = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _text, _cursorIndex, _anchorIndex, _ok
}

func (context *IMContext) preeditChanged() {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.preedit_changed

	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_IMContext_virtual_preedit_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

func (context *IMContext) preeditEnd() {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.preedit_end

	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_IMContext_virtual_preedit_end(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

func (context *IMContext) preeditStart() {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.preedit_start

	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_IMContext_virtual_preedit_start(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// Reset: notify the input method that a change such as a change in cursor
// position has been made.
//
// This will typically cause the input method to clear the preedit state.
func (context *IMContext) reset() {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.reset

	var _arg0 *C.GtkIMContext // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_IMContext_virtual_reset(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

func (context *IMContext) retrieveSurrounding() bool {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.retrieve_surrounding

	var _arg0 *C.GtkIMContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gtk4_IMContext_virtual_retrieve_surrounding(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// setClientWidget: set the client widget for the input context.
//
// This is the GtkWidget holding the input focus. This widget is used in order
// to correctly position status windows, and may also be used for purposes
// internal to the input method.
//
// The function takes the following parameters:
//
//   - widget (optional): client widget. This may be NULL to indicate that the
//     previous client widget no longer exists.
func (context *IMContext) setClientWidget(widget Widgetter) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.set_client_widget

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C._gotk4_gtk4_IMContext_virtual_set_client_widget(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(widget)
}

// setCursorLocation: notify the input method that a change in cursor position
// has been made.
//
// The location is relative to the client window.
//
// The function takes the following parameters:
//
//   - area: new location.
func (context *IMContext) setCursorLocation(area *gdk.Rectangle) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.set_cursor_location

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(area)))

	C._gotk4_gtk4_IMContext_virtual_set_cursor_location(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(area)
}

// setSurrounding sets surrounding context around the insertion point and
// preedit string.
//
// This function is expected to be called in response to the
// gtk.IMContext::retrieve-surrounding signal, and will likely have no effect if
// called at other times.
//
// Deprecated: Use gtk.IMContext.SetSurroundingWithSelection() instead.
//
// The function takes the following parameters:
//
//   - text surrounding the insertion point, as UTF-8. the preedit string should
//     not be included within text.
//   - len: length of text, or -1 if text is nul-terminated.
//   - cursorIndex: byte index of the insertion cursor within text.
func (context *IMContext) setSurrounding(text string, len, cursorIndex int) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.set_surrounding

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)
	_arg3 = C.int(cursorIndex)

	C._gotk4_gtk4_IMContext_virtual_set_surrounding(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(cursorIndex)
}

// setSurroundingWithSelection sets surrounding context around the insertion
// point and preedit string. This function is expected to be called in response
// to the GtkIMContext::retrieve_surrounding signal, and will likely have no
// effect if called at other times.
//
// The function takes the following parameters:
//
//   - text surrounding the insertion point, as UTF-8. the preedit string should
//     not be included within text.
//   - len: length of text, or -1 if text is nul-terminated.
//   - cursorIndex: byte index of the insertion cursor within text.
//   - anchorIndex: byte index of the selection bound within text.
func (context *IMContext) setSurroundingWithSelection(text string, len, cursorIndex, anchorIndex int) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.set_surrounding_with_selection

	var _arg0 *C.GtkIMContext // out
	var _arg1 *C.char         // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out
	var _arg4 C.int           // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)
	_arg3 = C.int(cursorIndex)
	_arg4 = C.int(anchorIndex)

	C._gotk4_gtk4_IMContext_virtual_set_surrounding_with_selection(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(context)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(cursorIndex)
	runtime.KeepAlive(anchorIndex)
}

// setUsePreedit sets whether the IM context should use the preedit string to
// display feedback.
//
// If use_preedit is FALSE (default is TRUE), then the IM context may use some
// other method to display feedback, such as displaying it in a child of the
// root window.
//
// The function takes the following parameters:
//
//   - usePreedit: whether the IM context should use the preedit string.
func (context *IMContext) setUsePreedit(usePreedit bool) {
	gclass := (*C.GtkIMContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.set_use_preedit

	var _arg0 *C.GtkIMContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkIMContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	if usePreedit {
		_arg1 = C.TRUE
	}

	C._gotk4_gtk4_IMContext_virtual_set_use_preedit(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(usePreedit)
}

// IMContextSimpleOverrides contains methods that are overridable.
type IMContextSimpleOverrides struct {
}

func defaultIMContextSimpleOverrides(v *IMContextSimple) IMContextSimpleOverrides {
	return IMContextSimpleOverrides{}
}

// IMContextSimple: GtkIMContextSimple is an input method supporting table-based
// input methods.
//
// GtkIMContextSimple has a built-in table of compose sequences that is derived
// from the X11 Compose files.
//
// GtkIMContextSimple reads additional compose sequences from the first of
// the following files that is found: ~/.config/gtk-4.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
//
// # Unicode characters
//
// GtkIMContextSimple also supports numeric entry of Unicode characters
// by typing <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>u</kbd>, followed by a
// hexadecimal Unicode codepoint.
//
// For example,
//
//	Ctrl-Shift-u 1 2 3 Enter
//
// yields U+0123 LATIN SMALL LETTER G WITH CEDILLA, i.e. ģ.
type IMContextSimple struct {
	_ [0]func() // equal guard
	IMContext
}

var (
	_ IMContexter = (*IMContextSimple)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*IMContextSimple, *IMContextSimpleClass, IMContextSimpleOverrides](
		GTypeIMContextSimple,
		initIMContextSimpleClass,
		wrapIMContextSimple,
		defaultIMContextSimpleOverrides,
	)
}

func initIMContextSimpleClass(gclass unsafe.Pointer, overrides IMContextSimpleOverrides, classInitFunc func(*IMContextSimpleClass)) {
	if classInitFunc != nil {
		class := (*IMContextSimpleClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapIMContextSimple(obj *coreglib.Object) *IMContextSimple {
	return &IMContextSimple{
		IMContext: IMContext{
			Object: obj,
		},
	}
}

func marshalIMContextSimple(p uintptr) (interface{}, error) {
	return wrapIMContextSimple(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewIMContextSimple creates a new IMContextSimple.
//
// The function returns the following values:
//
//   - imContextSimple: new IMContextSimple.
func NewIMContextSimple() *IMContextSimple {
	var _cret *C.GtkIMContext // in

	_cret = C.gtk_im_context_simple_new()

	var _imContextSimple *IMContextSimple // out

	_imContextSimple = wrapIMContextSimple(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _imContextSimple
}

// AddComposeFile adds an additional table from the X11 compose file.
//
// The function takes the following parameters:
//
//   - composeFile: path of compose file.
func (contextSimple *IMContextSimple) AddComposeFile(composeFile string) {
	var _arg0 *C.GtkIMContextSimple // out
	var _arg1 *C.char               // out

	_arg0 = (*C.GtkIMContextSimple)(unsafe.Pointer(coreglib.InternObject(contextSimple).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(composeFile)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_im_context_simple_add_compose_file(_arg0, _arg1)
	runtime.KeepAlive(contextSimple)
	runtime.KeepAlive(composeFile)
}

// IMMulticontextOverrides contains methods that are overridable.
type IMMulticontextOverrides struct {
}

func defaultIMMulticontextOverrides(v *IMMulticontext) IMMulticontextOverrides {
	return IMMulticontextOverrides{}
}

// IMMulticontext: GtkIMMulticontext is input method supporting multiple,
// switchable input methods.
//
// Text widgets such as GtkText or GtkTextView use a GtkIMMultiContext to
// implement their im-module property for switching between different input
// methods.
type IMMulticontext struct {
	_ [0]func() // equal guard
	IMContext
}

var (
	_ IMContexter = (*IMMulticontext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*IMMulticontext, *IMMulticontextClass, IMMulticontextOverrides](
		GTypeIMMulticontext,
		initIMMulticontextClass,
		wrapIMMulticontext,
		defaultIMMulticontextOverrides,
	)
}

func initIMMulticontextClass(gclass unsafe.Pointer, overrides IMMulticontextOverrides, classInitFunc func(*IMMulticontextClass)) {
	if classInitFunc != nil {
		class := (*IMMulticontextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapIMMulticontext(obj *coreglib.Object) *IMMulticontext {
	return &IMMulticontext{
		IMContext: IMContext{
			Object: obj,
		},
	}
}

func marshalIMMulticontext(p uintptr) (interface{}, error) {
	return wrapIMMulticontext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewIMMulticontext creates a new GtkIMMulticontext.
//
// The function returns the following values:
//
//   - imMulticontext: new GtkIMMulticontext.
func NewIMMulticontext() *IMMulticontext {
	var _cret *C.GtkIMContext // in

	_cret = C.gtk_im_multicontext_new()

	var _imMulticontext *IMMulticontext // out

	_imMulticontext = wrapIMMulticontext(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _imMulticontext
}

// ContextID gets the id of the currently active delegate of the context.
//
// The function returns the following values:
//
//   - utf8: id of the currently active delegate.
func (context *IMMulticontext) ContextID() string {
	var _arg0 *C.GtkIMMulticontext // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_im_multicontext_get_context_id(_arg0)
	runtime.KeepAlive(context)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SetContextID sets the context id for context.
//
// This causes the currently active delegate of context to be replaced by the
// delegate corresponding to the new context id.
//
// The function takes the following parameters:
//
//   - contextId: id to use.
func (context *IMMulticontext) SetContextID(contextId string) {
	var _arg0 *C.GtkIMMulticontext // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contextId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_im_multicontext_set_context_id(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(contextId)
}

// IconPaintable contains information found when looking up an icon in
// GtkIconTheme.
//
// GtkIconPaintable implements GdkPaintable.
type IconPaintable struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gdk.Paintable
}

var (
	_ coreglib.Objector = (*IconPaintable)(nil)
)

func wrapIconPaintable(obj *coreglib.Object) *IconPaintable {
	return &IconPaintable{
		Object: obj,
		Paintable: gdk.Paintable{
			Object: obj,
		},
	}
}

func marshalIconPaintable(p uintptr) (interface{}, error) {
	return wrapIconPaintable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewIconPaintableForFile creates a GtkIconPaintable for a file with a given
// size and scale.
//
// The icon can then be rendered by using it as a GdkPaintable.
//
// The function takes the following parameters:
//
//   - file: GFile.
//   - size: desired icon size.
//   - scale: desired scale.
//
// The function returns the following values:
//
//   - iconPaintable: GtkIconPaintable containing for the icon. Unref with
//     g_object_unref().
func NewIconPaintableForFile(file gio.Filer, size, scale int) *IconPaintable {
	var _arg1 *C.GFile            // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _cret *C.GtkIconPaintable // in

	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	_arg2 = C.int(size)
	_arg3 = C.int(scale)

	_cret = C.gtk_icon_paintable_new_for_file(_arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)

	var _iconPaintable *IconPaintable // out

	_iconPaintable = wrapIconPaintable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconPaintable
}

// File gets the GFile that was used to load the icon.
//
// Returns NULL if the icon was not loaded from a file.
//
// The function returns the following values:
//
//   - file (optional) for the icon, or NULL. Free with g_object_unref().
func (self *IconPaintable) File() *gio.File {
	var _arg0 *C.GtkIconPaintable // out
	var _cret *C.GFile            // in

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_paintable_get_file(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_file = &gio.File{
				Object: obj,
			}
		}
	}

	return _file
}

// IconName: get the icon name being used for this icon.
//
// When an icon looked up in the icon theme was not available,
// the icon theme may use fallback icons - either those specified to
// gtk_icon_theme_lookup_icon() or the always-available "image-missing".
// The icon chosen is returned by this function.
//
// If the icon was created without an icon theme, this function returns NULL.
//
// The function returns the following values:
//
//   - filename (optional): themed icon-name for the icon, or NULL if its not a
//     themed icon.
func (self *IconPaintable) IconName() string {
	var _arg0 *C.GtkIconPaintable // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_paintable_get_icon_name(_arg0)
	runtime.KeepAlive(self)

	var _filename string // out

	if _cret != nil {
		_filename = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _filename
}

// IsSymbolic checks if the icon is symbolic or not.
//
// This currently uses only the file name and not the file contents for
// determining this. This behaviour may change in the future.
//
// Note that to render a symbolic GtkIconPaintable properly (with recoloring),
// you have to set its icon name on a GtkImage.
//
// The function returns the following values:
//
//   - ok: TRUE if the icon is symbolic, FALSE otherwise.
func (self *IconPaintable) IsSymbolic() bool {
	var _arg0 *C.GtkIconPaintable // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_paintable_is_symbolic(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconTheme: GtkIconTheme provides a facility for loading themed icons.
//
// The main reason for using a name rather than simply providing
// a filename is to allow different icons to be used depending on
// what “icon theme” is selected by the user. The operation of icon
// themes on Linux and Unix follows the Icon Theme Specification
// (http://www.freedesktop.org/Standards/icon-theme-spec) There is a fallback
// icon theme, named hicolor, where applications should install their icons,
// but additional icon themes can be installed as operating system vendors and
// users choose.
//
// In many cases, named themes are used indirectly, via gtk.Image rather than
// directly, but looking up icons directly is also simple. The GtkIconTheme
// object acts as a database of all the icons in the current theme. You can
// create new GtkIconTheme objects, but it’s much more efficient to use the
// standard icon theme of the GtkWidget so that the icon information is shared
// with other people looking up icons.
//
//	GtkIconTheme *icon_theme;
//	GtkIconPaintable *icon;
//	GdkPaintable *paintable;
//
//	icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display (my_widget));
//	icon = gtk_icon_theme_lookup_icon (icon_theme,
//	                                   "my-icon-name", // icon name
//	                                   48, // icon size
//	                                   1,  // scale
//	                                   0,  // flags);
//	paintable = GDK_PAINTABLE (icon);
//	// Use the paintable
//	g_object_unref (icon);.
type IconTheme struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*IconTheme)(nil)
)

func wrapIconTheme(obj *coreglib.Object) *IconTheme {
	return &IconTheme{
		Object: obj,
	}
}

func marshalIconTheme(p uintptr) (interface{}, error) {
	return wrapIconTheme(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the icon theme changes.
//
// This can happen becuase current icon theme is switched or because GTK detects
// that a change has occurred in the contents of the current icon theme.
func (self *IconTheme) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "changed", false, unsafe.Pointer(C._gotk4_gtk4_IconTheme_ConnectChanged), f)
}

// NewIconTheme creates a new icon theme object.
//
// Icon theme objects are used to lookup up an icon by name in a particular icon
// theme. Usually, you’ll want to use gtk.IconTheme().GetForDisplay rather than
// creating a new icon theme object for scratch.
//
// The function returns the following values:
//
//   - iconTheme: newly created GtkIconTheme object.
func NewIconTheme() *IconTheme {
	var _cret *C.GtkIconTheme // in

	_cret = C.gtk_icon_theme_new()

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconTheme
}

// AddResourcePath adds a resource path that will be looked at when looking for
// icons, similar to search paths.
//
// See gtk.IconTheme.SetResourcePath().
//
// This function should be used to make application-specific icons available as
// part of the icon theme.
//
// The function takes the following parameters:
//
//   - path: resource path.
func (self *IconTheme) AddResourcePath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(path)
}

// AddSearchPath appends a directory to the search path.
//
// See gtk.IconTheme.SetSearchPath().
//
// The function takes the following parameters:
//
//   - path: directory name to append to the icon path.
func (self *IconTheme) AddSearchPath(path string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_icon_theme_add_search_path(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(path)
}

// Display returns the display that the GtkIconTheme object was created for.
//
// The function returns the following values:
//
//   - display (optional) of icon_theme.
func (self *IconTheme) Display() *gdk.Display {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.GdkDisplay   // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_theme_get_display(_arg0)
	runtime.KeepAlive(self)

	var _display *gdk.Display // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_display = &gdk.Display{
				Object: obj,
			}
		}
	}

	return _display
}

// IconNames lists the names of icons in the current icon theme.
//
// The function returns the following values:
//
//   - utf8s: string array holding the names of all the icons in the theme.
//     You must free the array using g_strfreev().
func (self *IconTheme) IconNames() []string {
	var _arg0 *C.GtkIconTheme // out
	var _cret **C.char        // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_theme_get_icon_names(_arg0)
	runtime.KeepAlive(self)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// IconSizes returns an array of integers describing the sizes at which the icon
// is available without scaling.
//
// A size of -1 means that the icon is available in a scalable format. The array
// is zero-terminated.
//
// The function takes the following parameters:
//
//   - iconName: name of an icon.
//
// The function returns the following values:
//
//   - gints: newly allocated array describing the sizes at which the icon is
//     available. The array should be freed with g_free() when it is no longer
//     needed.
func (self *IconTheme) IconSizes(iconName string) []int {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out
	var _cret *C.int          // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(iconName)

	var _gints []int // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z C.int
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_gints = make([]int, i)
		for i := range src {
			_gints[i] = int(src[i])
		}
	}

	return _gints
}

// ResourcePath gets the current resource path.
//
// See gtk.IconTheme.SetResourcePath().
//
// The function returns the following values:
//
//   - utf8s (optional): A list of resource paths or NULL. The returned value
//     should be freed with g_strfreev().
func (self *IconTheme) ResourcePath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _cret **C.char        // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_theme_get_resource_path(_arg0)
	runtime.KeepAlive(self)

	var _utf8s []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_utf8s = make([]string, i)
			for i := range src {
				_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _utf8s
}

// SearchPath gets the current search path.
//
// See gtk.IconTheme.SetSearchPath().
//
// The function returns the following values:
//
//   - filenames (optional): a list of icon theme path directories or NULL.
//     The returned value should be freed with g_strfreev().
func (self *IconTheme) SearchPath() []string {
	var _arg0 *C.GtkIconTheme // out
	var _cret **C.char        // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_theme_get_search_path(_arg0)
	runtime.KeepAlive(self)

	var _filenames []string // out

	if _cret != nil {
		defer C.free(unsafe.Pointer(_cret))
		{
			var i int
			var z *C.char
			for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
				i++
			}

			src := unsafe.Slice(_cret, i)
			_filenames = make([]string, i)
			for i := range src {
				_filenames[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
				defer C.free(unsafe.Pointer(src[i]))
			}
		}
	}

	return _filenames
}

// ThemeName gets the current icon theme name.
//
// Returns (transfer full): the current icon theme name,.
func (self *IconTheme) ThemeName() string {
	var _arg0 *C.GtkIconTheme // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_icon_theme_get_theme_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasGIcon checks whether an icon theme includes an icon for a particular
// GIcon.
//
// The function takes the following parameters:
//
//   - gicon: GIcon.
//
// The function returns the following values:
//
//   - ok: TRUE if self includes an icon for gicon.
func (self *IconTheme) HasGIcon(gicon gio.Iconner) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.GIcon        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(gicon).Native()))

	_cret = C.gtk_icon_theme_has_gicon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(gicon)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasIcon checks whether an icon theme includes an icon for a particular name.
//
// The function takes the following parameters:
//
//   - iconName: name of an icon.
//
// The function returns the following values:
//
//   - ok: TRUE if self includes an icon for icon_name.
func (self *IconTheme) HasIcon(iconName string) bool {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(iconName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupByGIcon looks up a icon for a desired size and window scale.
//
// The icon can then be rendered by using it as a GdkPaintable, or you can get
// information such as the filename and size.
//
// The function takes the following parameters:
//
//   - icon: GIcon to look up.
//   - size: desired icon size.
//   - scale: desired scale.
//   - direction: text direction the icon will be displayed in.
//   - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//   - iconPaintable: GtkIconPaintable containing information about the icon.
//     Unref with g_object_unref().
func (self *IconTheme) LookupByGIcon(icon gio.Iconner, size, scale int, direction TextDirection, flags IconLookupFlags) *IconPaintable {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.GIcon             // out
	var _arg2 C.int                // out
	var _arg3 C.int                // out
	var _arg4 C.GtkTextDirection   // out
	var _arg5 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconPaintable  // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))
	_arg2 = C.int(size)
	_arg3 = C.int(scale)
	_arg4 = C.GtkTextDirection(direction)
	_arg5 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_by_gicon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(self)
	runtime.KeepAlive(icon)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(flags)

	var _iconPaintable *IconPaintable // out

	_iconPaintable = wrapIconPaintable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconPaintable
}

// LookupIcon looks up a named icon for a desired size and window scale,
// returning a GtkIconPaintable.
//
// The icon can then be rendered by using it as a GdkPaintable, or you can get
// information such as the filename and size.
//
// If the available icon_name is not available and fallbacks are provided,
// they will be tried in order.
//
// If no matching icon is found, then a paintable that renders the "missing
// icon" icon is returned. If you need to do something else for missing icons
// you need to use gtk.IconTheme.HasIcon().
//
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by overriding the GtkWidgetClass.css-changed()
// function.
//
// The function takes the following parameters:
//
//   - iconName: name of the icon to lookup.
//   - fallbacks (optional)
//   - size: desired icon size.
//   - scale: window scale this will be displayed on.
//   - direction: text direction the icon will be displayed in.
//   - flags modifying the behavior of the icon lookup.
//
// The function returns the following values:
//
//   - iconPaintable: GtkIconPaintable object containing the icon.
func (self *IconTheme) LookupIcon(iconName string, fallbacks []string, size, scale int, direction TextDirection, flags IconLookupFlags) *IconPaintable {
	var _arg0 *C.GtkIconTheme      // out
	var _arg1 *C.char              // out
	var _arg2 **C.char             // out
	var _arg3 C.int                // out
	var _arg4 C.int                // out
	var _arg5 C.GtkTextDirection   // out
	var _arg6 C.GtkIconLookupFlags // out
	var _cret *C.GtkIconPaintable  // in

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(fallbacks) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(fallbacks)+1)
			var zero *C.char
			out[len(fallbacks)] = zero
			for i := range fallbacks {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(fallbacks[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	_arg3 = C.int(size)
	_arg4 = C.int(scale)
	_arg5 = C.GtkTextDirection(direction)
	_arg6 = C.GtkIconLookupFlags(flags)

	_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(self)
	runtime.KeepAlive(iconName)
	runtime.KeepAlive(fallbacks)
	runtime.KeepAlive(size)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(flags)

	var _iconPaintable *IconPaintable // out

	_iconPaintable = wrapIconPaintable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _iconPaintable
}

// SetSearchPath sets the search path for the icon theme object.
//
// When looking for an icon theme, GTK will search for a subdirectory of one
// or more of the directories in path with the same name as the icon theme
// containing an index.theme file. (Themes from multiple of the path elements
// are combined to allow themes to be extended by adding icons in the user’s
// home directory.)
//
// In addition if an icon found isn’t found either in the current icon theme
// or the default icon theme, and an image file with the right name is found
// directly in one of the elements of path, then that image will be used for
// the icon name. (This is legacy feature, and new icons should be put into the
// fallback icon theme, which is called hicolor, rather than directly on the
// icon path.).
//
// The function takes the following parameters:
//
//   - path (optional): NULL-terminated array of directories that are searched
//     for icon themes.
func (self *IconTheme) SetSearchPath(path []string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 **C.char        // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(path) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(path)+1)
			var zero *C.char
			out[len(path)] = zero
			for i := range path {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(path[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_icon_theme_set_search_path(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(path)
}

// SetThemeName sets the name of the icon theme that the GtkIconTheme object
// uses overriding system configuration.
//
// This function cannot be called on the icon theme objects returned from
// gtk.IconTheme.GetForDisplay.
//
// The function takes the following parameters:
//
//   - themeName (optional): name of icon theme to use instead of configured
//     theme, or NULL to unset a previously set custom theme.
func (self *IconTheme) SetThemeName(themeName string) {
	var _arg0 *C.GtkIconTheme // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if themeName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(themeName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_icon_theme_set_theme_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(themeName)
}

// IconThemeGetForDisplay gets the icon theme object associated with display.
//
// If this function has not previously been called for the given display,
// a new icon theme object will be created and associated with the display.
// Icon theme objects are fairly expensive to create, so using this function
// is usually a better choice than calling gtk.IconTheme.New and setting the
// display yourself; by using this function a single icon theme object will be
// shared between users.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
//
// The function returns the following values:
//
//   - iconTheme: unique GtkIconTheme associated with the given display.
//     This icon theme is associated with the display and can be used as long as
//     the display is open. Do not ref or unref it.
func IconThemeGetForDisplay(display *gdk.Display) *IconTheme {
	var _arg1 *C.GdkDisplay   // out
	var _cret *C.GtkIconTheme // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gtk_icon_theme_get_for_display(_arg1)
	runtime.KeepAlive(display)

	var _iconTheme *IconTheme // out

	_iconTheme = wrapIconTheme(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconTheme
}

// IconView: GtkIconView is a widget which displays data in a grid of icons.
//
// GtkIconView provides an alternative view on a GtkTreeModel.
// It displays the model as a grid of icons with labels. Like gtk.TreeView,
// it allows to select one or multiple items (depending on the selection mode,
// see gtk.IconView.SetSelectionMode()). In addition to selection with the
// arrow keys, GtkIconView supports rubberband selection, which is controlled by
// dragging the pointer.
//
// Note that if the tree model is backed by an actual tree store (as opposed
// to a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the tree’s branches.
//
// CSS nodes
//
//	iconview.view
//	╰── [rubberband]
//
// GtkIconView has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
type IconView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	CellLayout
	Scrollable
}

var (
	_ Widgetter         = (*IconView)(nil)
	_ coreglib.Objector = (*IconView)(nil)
)

func wrapIconView(obj *coreglib.Object) *IconView {
	return &IconView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		CellLayout: CellLayout{
			Object: obj,
		},
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalIconView(p uintptr) (interface{}, error) {
	return wrapIconView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateCursorItem: [keybinding signal][GtkSignalAction] which gets
// emitted when the user activates the currently focused item.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control activation programmatically.
//
// The default bindings for this signal are Space, Return and Enter.
func (iconView *IconView) ConnectActivateCursorItem(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "activate-cursor-item", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectActivateCursorItem), f)
}

// ConnectItemActivated signal is emitted when the method
// gtk_icon_view_item_activated() is called, when the user double clicks an item
// with the "activate-on-single-click" property set to FALSE, or when the user
// single clicks an item when the "activate-on-single-click" property set to
// TRUE. It is also emitted when a non-editable item is selected and one of the
// keys: Space, Return or Enter is pressed.
func (iconView *IconView) ConnectItemActivated(f func(path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "item-activated", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectItemActivated), f)
}

// ConnectMoveCursor signal is a [keybinding signal][GtkSignalAction] which gets
// emitted when the user initiates a cursor movement.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
// # The default bindings for this signal include
//
// - Arrow keys which move by individual steps
//
// - Home/End keys which move to the first/last item
//
// - PageUp/PageDown which move by "pages" All of these will extend the
// selection when combined with the Shift modifier.
func (iconView *IconView) ConnectMoveCursor(f func(step MovementStep, count int, extend, modify bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectMoveCursor), f)
}

// ConnectSelectAll: [keybinding signal][GtkSignalAction] which gets emitted
// when the user selects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// The default binding for this signal is Ctrl-a.
func (iconView *IconView) ConnectSelectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectSelectAll), f)
}

// ConnectSelectCursorItem: [keybinding signal][GtkSignalAction] which gets
// emitted when the user selects the item that is currently focused.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// There is no default binding for this signal.
func (iconView *IconView) ConnectSelectCursorItem(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "select-cursor-item", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectSelectCursorItem), f)
}

// ConnectSelectionChanged signal is emitted when the selection (i.e. the set of
// selected items) changes.
func (iconView *IconView) ConnectSelectionChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "selection-changed", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectSelectionChanged), f)
}

// ConnectToggleCursorItem: [keybinding signal][GtkSignalAction] which gets
// emitted when the user toggles whether the currently focused item is selected
// or not. The exact effect of this depend on the selection mode.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// There is no default binding for this signal is Ctrl-Space.
func (iconView *IconView) ConnectToggleCursorItem(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "toggle-cursor-item", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectToggleCursorItem), f)
}

// ConnectUnselectAll: [keybinding signal][GtkSignalAction] which gets emitted
// when the user unselects all items.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control selection programmatically.
//
// The default binding for this signal is Ctrl-Shift-a.
func (iconView *IconView) ConnectUnselectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(iconView, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk4_IconView_ConnectUnselectAll), f)
}

// NewIconView creates a new IconView widget.
//
// The function returns the following values:
//
//   - iconView: newly created IconView widget.
func NewIconView() *IconView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_icon_view_new()

	var _iconView *IconView // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithArea creates a new IconView widget using the specified area to
// layout cells inside the icons.
//
// The function takes the following parameters:
//
//   - area to use to layout cells.
//
// The function returns the following values:
//
//   - iconView: newly created IconView widget.
func NewIconViewWithArea(area CellAreaer) *IconView {
	var _arg1 *C.GtkCellArea // out
	var _cret *C.GtkWidget   // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_icon_view_new_with_area(_arg1)
	runtime.KeepAlive(area)

	var _iconView *IconView // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// NewIconViewWithModel creates a new IconView widget with the model model.
//
// The function takes the following parameters:
//
//   - model: model.
//
// The function returns the following values:
//
//   - iconView: newly created IconView widget.
func NewIconViewWithModel(model TreeModeller) *IconView {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_icon_view_new_with_model(_arg1)
	runtime.KeepAlive(model)

	var _iconView *IconView // out

	_iconView = wrapIconView(coreglib.Take(unsafe.Pointer(_cret)))

	return _iconView
}

// CreateDragIcon creates a #cairo_surface_t representation of the item at path.
// This image is used for a drag icon.
//
// The function takes the following parameters:
//
//   - path in icon_view.
//
// The function returns the following values:
//
//   - paintable: newly-allocated surface of the drag icon.
func (iconView *IconView) CreateDragIcon(path *TreePath) *gdk.Paintable {
	var _arg0 *C.GtkIconView  // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_icon_view_create_drag_icon(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)

	var _paintable *gdk.Paintable // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_paintable = &gdk.Paintable{
			Object: obj,
		}
	}

	return _paintable
}

// EnableModelDragDest turns icon_view into a drop destination for automatic
// DND. Calling this method sets IconView:reorderable to FALSE.
//
// The function takes the following parameters:
//
//   - formats that the drag will support.
//   - actions: bitmask of possible actions for a drag to this widget.
func (iconView *IconView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView       // out
	var _arg1 *C.GdkContentFormats // out
	var _arg2 C.GdkDragAction      // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg2 = C.GdkDragAction(actions)

	C.gtk_icon_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(actions)
}

// EnableModelDragSource turns icon_view into a drag source for automatic DND.
// Calling this method sets IconView:reorderable to FALSE.
//
// The function takes the following parameters:
//
//   - startButtonMask: mask of allowed buttons to start drag.
//   - formats that the drag will support.
//   - actions: bitmask of possible actions for a drag from this widget.
func (iconView *IconView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkIconView       // out
	var _arg1 C.GdkModifierType    // out
	var _arg2 *C.GdkContentFormats // out
	var _arg3 C.GdkDragAction      // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.GdkModifierType(startButtonMask)
	_arg2 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg3 = C.GdkDragAction(actions)

	C.gtk_icon_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(startButtonMask)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(actions)
}

// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
//
// The function returns the following values:
//
//   - ok: TRUE if item-activated will be emitted on a single click.
func (iconView *IconView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_activate_on_single_click(_arg0)
	runtime.KeepAlive(iconView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by path and cell. If cell is NULL the main cell area is used.
//
// This function is only valid if icon_view is realized.
//
// The function takes the following parameters:
//
//   - path: TreePath.
//   - cell (optional) or NULL.
//
// The function returns the following values:
//
//   - rect: rectangle to fill with cell rect.
//   - ok: FALSE if there is no such item, TRUE otherwise.
func (iconView *IconView) CellRect(path *TreePath, cell CellRendererer) (*gdk.Rectangle, bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GtkCellRenderer // out
	var _arg3 C.GdkRectangle     // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if cell != nil {
		_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}

	_cret = C.gtk_icon_view_get_cell_rect(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cell)

	var _rect *gdk.Rectangle // out
	var _ok bool             // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// ColumnSpacing returns the value of the ::column-spacing property.
//
// The function returns the following values:
//
//   - gint: space between columns.
func (iconView *IconView) ColumnSpacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_column_spacing(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Columns returns the value of the ::columns property.
//
// The function returns the following values:
//
//   - gint: number of columns, or -1.
func (iconView *IconView) Columns() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_columns(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Cursor fills in path and cell with the current cursor path and cell. If the
// cursor isn’t currently set, then *path will be NULL. If no cell currently has
// focus, then *cell will be NULL.
//
// The returned TreePath must be freed with gtk_tree_path_free().
//
// The function returns the following values:
//
//   - path (optional): return location for the current cursor path, or NULL.
//   - cell (optional): return location the current focus cell, or NULL.
//   - ok: TRUE if the cursor is set.
func (iconView *IconView) Cursor() (*TreePath, CellRendererer, bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // in
	var _arg2 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_cursor(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconView)

	var _path *TreePath      // out
	var _cell CellRendererer // out
	var _ok bool             // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		{
			objptr := unsafe.Pointer(_arg2)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			_cell = rv
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

// DestItemAtPos determines the destination item for a given position.
//
// The function takes the following parameters:
//
//   - dragX: position to determine the destination item for.
//   - dragY: position to determine the destination item for.
//
// The function returns the following values:
//
//   - path (optional): return location for the path of the item, or NULL.
//   - pos (optional): return location for the drop position, or NULL.
//   - ok: whether there is an item at the given position.
func (iconView *IconView) DestItemAtPos(dragX, dragY int) (*TreePath, IconViewDropPosition, bool) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 C.int                     // out
	var _arg2 C.int                     // out
	var _arg3 *C.GtkTreePath            // in
	var _arg4 C.GtkIconViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(dragX)
	_arg2 = C.int(dragY)

	_cret = C.gtk_icon_view_get_dest_item_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(dragX)
	runtime.KeepAlive(dragY)

	var _path *TreePath           // out
	var _pos IconViewDropPosition // out
	var _ok bool                  // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = IconViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

// DragDestItem gets information about the item that is highlighted for
// feedback.
//
// The function returns the following values:
//
//   - path (optional): return location for the path of the highlighted item,
//     or NULL.
//   - pos (optional): return location for the drop position, or NULL.
func (iconView *IconView) DragDestItem() (*TreePath, IconViewDropPosition) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 *C.GtkTreePath            // in
	var _arg2 C.GtkIconViewDropPosition // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_get_drag_dest_item(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconView)

	var _path *TreePath           // out
	var _pos IconViewDropPosition // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = IconViewDropPosition(_arg2)

	return _path, _pos
}

// ItemAtPos gets the path and cell for the icon at the given position.
//
// The function takes the following parameters:
//
//   - x position to be identified.
//   - y position to be identified.
//
// The function returns the following values:
//
//   - path (optional): return location for the path, or NULL.
//   - cell (optional): return location for the renderer responsible for the
//     cell at (x, y), or NULL.
//   - ok: TRUE if an item exists at the specified position.
func (iconView *IconView) ItemAtPos(x, y int) (*TreePath, CellRendererer, bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 C.int              // out
	var _arg2 C.int              // out
	var _arg3 *C.GtkTreePath     // in
	var _arg4 *C.GtkCellRenderer // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_icon_view_get_item_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _path *TreePath      // out
	var _cell CellRendererer // out
	var _ok bool             // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg4 != nil {
		{
			objptr := unsafe.Pointer(_arg4)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(CellRendererer)
				return ok
			})
			rv, ok := casted.(CellRendererer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.CellRendererer")
			}
			_cell = rv
		}
	}
	if _cret != 0 {
		_ok = true
	}

	return _path, _cell, _ok
}

// ItemColumn gets the column in which the item path is currently displayed.
// Column numbers start at 0.
//
// The function takes the following parameters:
//
//   - path of the item.
//
// The function returns the following values:
//
//   - gint: column in which the item is displayed.
func (iconView *IconView) ItemColumn(path *TreePath) int {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_icon_view_get_item_column(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ItemOrientation returns the value of the ::item-orientation property which
// determines whether the labels are drawn beside the icons instead of below.
//
// The function returns the following values:
//
//   - orientation: relative position of texts and icons.
func (iconView *IconView) ItemOrientation() Orientation {
	var _arg0 *C.GtkIconView   // out
	var _cret C.GtkOrientation // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_item_orientation(_arg0)
	runtime.KeepAlive(iconView)

	var _orientation Orientation // out

	_orientation = Orientation(_cret)

	return _orientation
}

// ItemPadding returns the value of the ::item-padding property.
//
// The function returns the following values:
//
//   - gint: padding around items.
func (iconView *IconView) ItemPadding() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_item_padding(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ItemRow gets the row in which the item path is currently displayed. Row
// numbers start at 0.
//
// The function takes the following parameters:
//
//   - path of the item.
//
// The function returns the following values:
//
//   - gint: row in which the item is displayed.
func (iconView *IconView) ItemRow(path *TreePath) int {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_icon_view_get_item_row(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ItemWidth returns the value of the ::item-width property.
//
// The function returns the following values:
//
//   - gint: width of a single item, or -1.
func (iconView *IconView) ItemWidth() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_item_width(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Margin returns the value of the ::margin property.
//
// The function returns the following values:
//
//   - gint: space at the borders.
func (iconView *IconView) Margin() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_margin(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarkupColumn returns the column with markup text for icon_view.
//
// The function returns the following values:
//
//   - gint: markup column, or -1 if it’s unset.
func (iconView *IconView) MarkupColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_markup_column(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Model returns the model the IconView is based on. Returns NULL if the model
// is unset.
//
// The function returns the following values:
//
//   - treeModel (optional) or NULL if none is currently being used.
func (iconView *IconView) Model() *TreeModel {
	var _arg0 *C.GtkIconView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_model(_arg0)
	runtime.KeepAlive(iconView)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// PathAtPos gets the path for the icon at the given position.
//
// The function takes the following parameters:
//
//   - x position to be identified.
//   - y position to be identified.
//
// The function returns the following values:
//
//   - treePath (optional) corresponding to the icon or NULL if no icon exists
//     at that position.
func (iconView *IconView) PathAtPos(x, y int) *TreePath {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_icon_view_get_path_at_pos(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// PixbufColumn returns the column with pixbufs for icon_view.
//
// The function returns the following values:
//
//   - gint: pixbuf column, or -1 if it’s unset.
func (iconView *IconView) PixbufColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_pixbuf_column(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
//
// The function returns the following values:
//
//   - ok: TRUE if the list can be reordered.
func (iconView *IconView) Reorderable() bool {
	var _arg0 *C.GtkIconView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_reorderable(_arg0)
	runtime.KeepAlive(iconView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RowSpacing returns the value of the ::row-spacing property.
//
// The function returns the following values:
//
//   - gint: space between rows.
func (iconView *IconView) RowSpacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_row_spacing(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SelectedItems creates a list of paths of all selected items. Additionally,
// if you are planning on modifying the model after calling this function,
// you may want to convert the returned list into a list of TreeRowReferences.
// To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//	g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);.
//
// The function returns the following values:
//
//   - list containing a TreePath for each selected row.
func (iconView *IconView) SelectedItems() []*TreePath {
	var _arg0 *C.GtkIconView // out
	var _cret *C.GList       // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_selected_items(_arg0)
	runtime.KeepAlive(iconView)

	var _list []*TreePath // out

	_list = make([]*TreePath, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkTreePath)(v)
		var dst *TreePath // out
		dst = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// SelectionMode gets the selection mode of the icon_view.
//
// The function returns the following values:
//
//   - selectionMode: current selection mode.
func (iconView *IconView) SelectionMode() SelectionMode {
	var _arg0 *C.GtkIconView     // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_selection_mode(_arg0)
	runtime.KeepAlive(iconView)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// Spacing returns the value of the ::spacing property.
//
// The function returns the following values:
//
//   - gint: space between cells.
func (iconView *IconView) Spacing() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_spacing(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TextColumn returns the column with text for icon_view.
//
// The function returns the following values:
//
//   - gint: text column, or -1 if it’s unset.
func (iconView *IconView) TextColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_text_column(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TooltipColumn returns the column of icon_view’s model which is being used for
// displaying tooltips on icon_view’s rows.
//
// The function returns the following values:
//
//   - gint: index of the tooltip column that is currently being used, or -1 if
//     this is disabled.
func (iconView *IconView) TooltipColumn() int {
	var _arg0 *C.GtkIconView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_tooltip_column(_arg0)
	runtime.KeepAlive(iconView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for IconView. The x, y and keyboard_tip
// values which are received in the signal handler, should be passed to this
// function without modification.
//
// The return value indicates whether there is an icon view item at the given
// coordinates (TRUE) or not (FALSE) for mouse tooltips. For keyboard tooltips
// the item returned will be the cursor item. When TRUE, then any of model,
// path and iter which have been provided will be set to point to that row and
// the corresponding model.
//
// The function takes the following parameters:
//
//   - x coordinate (relative to widget coordinates).
//   - y coordinate (relative to widget coordinates).
//   - keyboardTip: whether this is a keyboard tooltip or not.
//
// The function returns the following values:
//
//   - model (optional): pointer to receive a TreeModel or NULL.
//   - path (optional): pointer to receive a TreePath or NULL.
//   - iter (optional): pointer to receive a TreeIter or NULL.
//   - ok: whether or not the given tooltip context points to an item.
func (iconView *IconView) TooltipContext(x, y int, keyboardTip bool) (*TreeModel, *TreePath, *TreeIter, bool) {
	var _arg0 *C.GtkIconView  // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.gboolean      // out
	var _arg4 *C.GtkTreeModel // in
	var _arg5 *C.GtkTreePath  // in
	var _arg6 C.GtkTreeIter   // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	if keyboardTip {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_icon_view_get_tooltip_context(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(keyboardTip)

	var _model *TreeModel // out
	var _path *TreePath   // out
	var _iter *TreeIter   // out
	var _ok bool          // out

	if _arg4 != nil {
		_model = wrapTreeModel(coreglib.Take(unsafe.Pointer(_arg4)))
	}
	if _arg5 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg6))))
	if _cret != 0 {
		_ok = true
	}

	return _model, _path, _iter, _ok
}

// VisibleRange sets start_path and end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// Both paths should be freed with gtk_tree_path_free() after use.
//
// The function returns the following values:
//
//   - startPath (optional): return location for start of region, or NULL.
//   - endPath (optional): return location for end of region, or NULL.
//   - ok: TRUE, if valid paths were placed in start_path and end_path.
func (iconView *IconView) VisibleRange() (startPath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // in
	var _arg2 *C.GtkTreePath // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	_cret = C.gtk_icon_view_get_visible_range(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(iconView)

	var _startPath *TreePath // out
	var _endPath *TreePath   // out
	var _ok bool             // out

	if _arg1 != nil {
		_startPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_startPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		_endPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_endPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// ItemActivated activates the item determined by path.
//
// The function takes the following parameters:
//
//   - path to be activated.
func (iconView *IconView) ItemActivated(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_icon_view_item_activated(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
}

// PathIsSelected returns TRUE if the icon pointed to by path is currently
// selected. If path does not point to a valid location, FALSE is returned.
//
// The function takes the following parameters:
//
//   - path to check selection on.
//
// The function returns the following values:
//
//   - ok: TRUE if path is selected.
func (iconView *IconView) PathIsSelected(path *TreePath) bool {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_icon_view_path_is_selected(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToPath moves the alignments of icon_view to the position specified by
// path. row_align determines where the row is placed, and col_align determines
// where column is placed. Both are expected to be between 0.0 and 1.0. 0.0
// means left/top alignment, 1.0 means right/bottom alignment, 0.5 means center.
//
// If use_align is FALSE, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen.
// This means that the item will be scrolled to the edge closest to its current
// position. If the item is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and path is a valid row on the
// model. If the model changes before the icon_view is realized, the centered
// path will be modified to reflect this change.
//
// The function takes the following parameters:
//
//   - path of the item to move to.
//   - useAlign: whether to use alignment arguments, or FALSE.
//   - rowAlign: vertical alignment of the item specified by path.
//   - colAlign: horizontal alignment of the item specified by path.
func (iconView *IconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign, colAlign float32) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _arg3 C.float        // out
	var _arg4 C.float        // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if useAlign {
		_arg2 = C.TRUE
	}
	_arg3 = C.float(rowAlign)
	_arg4 = C.float(colAlign)

	C.gtk_icon_view_scroll_to_path(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(rowAlign)
	runtime.KeepAlive(colAlign)
}

// SelectAll selects all the icons. icon_view must has its selection mode set to
// K_SELECTION_MULTIPLE.
func (iconView *IconView) SelectAll() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_select_all(_arg0)
	runtime.KeepAlive(iconView)
}

// SelectPath selects the row at path.
//
// The function takes the following parameters:
//
//   - path to be selected.
func (iconView *IconView) SelectPath(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_icon_view_select_path(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
}

// SelectedForEach calls a function for each selected icon. Note that the model
// or selection cannot be modified from within this function.
//
// The function takes the following parameters:
//
//   - fn: function to call for each selected icon.
func (iconView *IconView) SelectedForEach(fn IconViewForEachFunc) {
	var _arg0 *C.GtkIconView           // out
	var _arg1 C.GtkIconViewForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_IconViewForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_icon_view_selected_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(fn)
}

// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
//
// The function takes the following parameters:
//
//   - single: TRUE to emit item-activated on a single click.
func (iconView *IconView) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_icon_view_set_activate_on_single_click(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(single)
}

// SetColumnSpacing sets the ::column-spacing property which specifies the space
// which is inserted between the columns of the icon view.
//
// The function takes the following parameters:
//
//   - columnSpacing: column spacing.
func (iconView *IconView) SetColumnSpacing(columnSpacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(columnSpacing)

	C.gtk_icon_view_set_column_spacing(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(columnSpacing)
}

// SetColumns sets the ::columns property which determines in how many columns
// the icons are arranged. If columns is -1, the number of columns will be
// chosen automatically to fill the available area.
//
// The function takes the following parameters:
//
//   - columns: number of columns.
func (iconView *IconView) SetColumns(columns int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(columns)

	C.gtk_icon_view_set_columns(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(columns)
}

// SetCursor sets the current keyboard focus to be at path, and selects it.
// This is useful when you want to focus the user’s attention on a particular
// item. If cell is not NULL, then focus is given to the cell specified by it.
// Additionally, if start_editing is TRUE, then editing should be started in the
// specified cell.
//
// This function is often followed by gtk_widget_grab_focus (icon_view) in
// order to give keyboard focus to the widget. Please note that editing can only
// happen when the widget is realized.
//
// The function takes the following parameters:
//
//   - path: TreePath.
//   - cell (optional): one of the cell renderers of icon_view, or NULL.
//   - startEditing: TRUE if the specified cell should start being edited.
func (iconView *IconView) SetCursor(path *TreePath, cell CellRendererer, startEditing bool) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTreePath     // out
	var _arg2 *C.GtkCellRenderer // out
	var _arg3 C.gboolean         // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if cell != nil {
		_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_icon_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(startEditing)
}

// SetDragDestItem sets the item that is highlighted for feedback.
//
// The function takes the following parameters:
//
//   - path (optional) of the item to highlight, or NULL.
//   - pos specifies where to drop, relative to the item.
func (iconView *IconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition) {
	var _arg0 *C.GtkIconView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkIconViewDropPosition // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	_arg2 = C.GtkIconViewDropPosition(pos)

	C.gtk_icon_view_set_drag_dest_item(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
//
// The function takes the following parameters:
//
//   - orientation: relative position of texts and icons.
func (iconView *IconView) SetItemOrientation(orientation Orientation) {
	var _arg0 *C.GtkIconView   // out
	var _arg1 C.GtkOrientation // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.GtkOrientation(orientation)

	C.gtk_icon_view_set_item_orientation(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(orientation)
}

// SetItemPadding sets the IconView:item-padding property which specifies the
// padding around each of the icon view’s items.
//
// The function takes the following parameters:
//
//   - itemPadding: item padding.
func (iconView *IconView) SetItemPadding(itemPadding int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(itemPadding)

	C.gtk_icon_view_set_item_padding(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(itemPadding)
}

// SetItemWidth sets the ::item-width property which specifies the width to use
// for each item. If it is set to -1, the icon view will automatically determine
// a suitable item size.
//
// The function takes the following parameters:
//
//   - itemWidth: width for each item.
func (iconView *IconView) SetItemWidth(itemWidth int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(itemWidth)

	C.gtk_icon_view_set_item_width(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(itemWidth)
}

// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
//
// The function takes the following parameters:
//
//   - margin: margin.
func (iconView *IconView) SetMargin(margin int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(margin)

	C.gtk_icon_view_set_margin(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(margin)
}

// SetMarkupColumn sets the column with markup information for icon_view
// to be column. The markup column must be of type TYPE_STRING. If the
// markup column is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
//
// The function takes the following parameters:
//
//   - column in the currently used model, or -1 to display no text.
func (iconView *IconView) SetMarkupColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_markup_column(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(column)
}

// SetModel sets the model for a IconView. If the icon_view already has a model
// set, it will remove it before setting the new model. If model is NULL,
// then it will unset the old model.
//
// The function takes the following parameters:
//
//   - model (optional): model.
func (iconView *IconView) SetModel(model TreeModeller) {
	var _arg0 *C.GtkIconView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if model != nil {
		_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_icon_view_set_model(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(model)
}

// SetPixbufColumn sets the column with pixbufs for icon_view to be column.
// The pixbuf column must be of type K_TYPE_PIXBUF.
//
// The function takes the following parameters:
//
//   - column in the currently used model, or -1 to disable.
func (iconView *IconView) SetPixbufColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_pixbuf_column(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(column)
}

// SetReorderable: this function is a convenience function to allow
// you to reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If reorderable
// is TRUE, then the user can reorder the model by dragging and dropping rows.
// The developer can listen to these changes by connecting to the model's
// row_inserted and row_deleted signals. The reordering is implemented by
// setting up the icon view as a drag source and destination. Therefore,
// drag and drop can not be used in a reorderable view for any other purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
//
// The function takes the following parameters:
//
//   - reorderable: TRUE, if the list of items can be reordered.
func (iconView *IconView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_icon_view_set_reorderable(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(reorderable)
}

// SetRowSpacing sets the ::row-spacing property which specifies the space which
// is inserted between the rows of the icon view.
//
// The function takes the following parameters:
//
//   - rowSpacing: row spacing.
func (iconView *IconView) SetRowSpacing(rowSpacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(rowSpacing)

	C.gtk_icon_view_set_row_spacing(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(rowSpacing)
}

// SetSelectionMode sets the selection mode of the icon_view.
//
// The function takes the following parameters:
//
//   - mode: selection mode.
func (iconView *IconView) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.GtkSelectionMode(mode)

	C.gtk_icon_view_set_selection_mode(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(mode)
}

// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
//
// The function takes the following parameters:
//
//   - spacing: spacing.
func (iconView *IconView) SetSpacing(spacing int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(spacing)

	C.gtk_icon_view_set_spacing(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(spacing)
}

// SetTextColumn sets the column with text for icon_view to be column. The text
// column must be of type TYPE_STRING.
//
// The function takes the following parameters:
//
//   - column in the currently used model, or -1 to display no text.
func (iconView *IconView) SetTextColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_text_column(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(column)
}

// SetTooltipCell sets the tip area of tooltip to the area which cell occupies
// in the item pointed to by path. See also gtk_tooltip_set_tip_area().
//
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
//
// The function takes the following parameters:
//
//   - tooltip: Tooltip.
//   - path: TreePath.
//   - cell (optional) or NULL.
func (iconView *IconView) SetTooltipCell(tooltip *Tooltip, path *TreePath, cell CellRendererer) {
	var _arg0 *C.GtkIconView     // out
	var _arg1 *C.GtkTooltip      // out
	var _arg2 *C.GtkTreePath     // out
	var _arg3 *C.GtkCellRenderer // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if cell != nil {
		_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}

	C.gtk_icon_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
	runtime.KeepAlive(cell)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips
// on full items, you can use this function to have IconView handle these
// automatically for you. column should be set to the column in icon_view’s
// model containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, Widget:has-tooltip will be set to TRUE and icon_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
//
// The function takes the following parameters:
//
//   - column: integer, which is a valid column number for icon_view’s model.
func (iconView *IconView) SetTooltipColumn(column int) {
	var _arg0 *C.GtkIconView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = C.int(column)

	C.gtk_icon_view_set_tooltip_column(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(column)
}

// SetTooltipItem sets the tip area of tooltip to be the area covered by the
// item at path. See also gtk_icon_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
//
// The function takes the following parameters:
//
//   - tooltip: Tooltip.
//   - path: TreePath.
func (iconView *IconView) SetTooltipItem(tooltip *Tooltip, path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTooltip  // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_icon_view_set_tooltip_item(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
}

// UnselectAll unselects all the icons.
func (iconView *IconView) UnselectAll() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_unselect_all(_arg0)
	runtime.KeepAlive(iconView)
}

// UnselectPath unselects the row at path.
//
// The function takes the following parameters:
//
//   - path to be unselected.
func (iconView *IconView) UnselectPath(path *TreePath) {
	var _arg0 *C.GtkIconView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_icon_view_unselect_path(_arg0, _arg1)
	runtime.KeepAlive(iconView)
	runtime.KeepAlive(path)
}

// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to FALSE.
func (iconView *IconView) UnsetModelDragDest() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_unset_model_drag_dest(_arg0)
	runtime.KeepAlive(iconView)
}

// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to FALSE.
func (iconView *IconView) UnsetModelDragSource() {
	var _arg0 *C.GtkIconView // out

	_arg0 = (*C.GtkIconView)(unsafe.Pointer(coreglib.InternObject(iconView).Native()))

	C.gtk_icon_view_unset_model_drag_source(_arg0)
	runtime.KeepAlive(iconView)
}

// Image: GtkImage widget displays an image.
//
// !An example GtkImage (image.png)
//
// Various kinds of object can be displayed as an image; most typically,
// you would load a GdkTexture from a file, using the convenience function
// gtk.Image.NewFromFile, for instance:
//
//	GtkWidget *image = gtk_image_new_from_file ("myfile.png");
//
// If the file isn’t loaded successfully, the image will contain a “broken
// image” icon similar to that used in many web browsers.
//
// If you want to handle errors in loading the file yourself,
// for example by displaying an error message, then load the image
// with gdk.Texture.NewFromFile, then create the GtkImage with
// gtk.Image.NewFromPaintable.
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of GResource inside GIO,
// for details. In this case, gtk.Image:resource, gtk.Image.NewFromResource,
// and gtk.Image.SetFromResource() should be used.
//
// GtkImage displays its image as an icon, with a size that is determined by the
// application. See gtk.Picture if you want to show an image at is actual size.
//
// # CSS nodes
//
// GtkImage has a single CSS node with the name image. The style
// classes .normal-icons or .large-icons may appear, depending on the
// gtk.Image:icon-size property.
//
// # Accessibility
//
// GtkImage uses the GTK_ACCESSIBLE_ROLE_IMG role.
type Image struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Image)(nil)
)

func wrapImage(obj *coreglib.Object) *Image {
	return &Image{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalImage(p uintptr) (interface{}, error) {
	return wrapImage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewImage creates a new empty GtkImage widget.
//
// The function returns the following values:
//
//   - image: newly created GtkImage widget.
func NewImage() *Image {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_image_new()

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromFile creates a new GtkImage displaying the file filename.
//
// If the file isn’t found or can’t be loaded, the resulting GtkImage will
// display a “broken image” icon. This function never returns NULL, it always
// returns a valid GtkImage widget.
//
// If you need to detect failures to load the file, use gdk.Texture.NewFromFile
// to load the file yourself, then create the GtkImage from the texture.
//
// The storage type (see gtk.Image.GetStorageType()) of the returned image is
// not defined, it will be whatever is appropriate for displaying the file.
//
// The function takes the following parameters:
//
//   - filename: filename.
//
// The function returns the following values:
//
//   - image: new GtkImage.
func NewImageFromFile(filename string) *Image {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_new_from_file(_arg1)
	runtime.KeepAlive(filename)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromGIcon creates a GtkImage displaying an icon from the current icon
// theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
//
// The function takes the following parameters:
//
//   - icon: icon.
//
// The function returns the following values:
//
//   - image: new GtkImage displaying the themed icon.
func NewImageFromGIcon(icon gio.Iconner) *Image {
	var _arg1 *C.GIcon     // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	_cret = C.gtk_image_new_from_gicon(_arg1)
	runtime.KeepAlive(icon)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromIconName creates a GtkImage displaying an icon from the current
// icon theme.
//
// If the icon name isn’t known, a “broken image” icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
//
// The function takes the following parameters:
//
//   - iconName (optional): icon name or NULL.
//
// The function returns the following values:
//
//   - image: new GtkImage displaying the themed icon.
func NewImageFromIconName(iconName string) *Image {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if iconName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_image_new_from_icon_name(_arg1)
	runtime.KeepAlive(iconName)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromPaintable creates a new GtkImage displaying paintable.
//
// The GtkImage does not assume a reference to the paintable; you still need to
// unref it if you own references. GtkImage will add its own reference rather
// than adopting yours.
//
// The GtkImage will track changes to the paintable and update its size and
// contents in response to it.
//
// The function takes the following parameters:
//
//   - paintable (optional): GdkPaintable, or NULL.
//
// The function returns the following values:
//
//   - image: new GtkImage.
func NewImageFromPaintable(paintable gdk.Paintabler) *Image {
	var _arg1 *C.GdkPaintable // out
	var _cret *C.GtkWidget    // in

	if paintable != nil {
		_arg1 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	}

	_cret = C.gtk_image_new_from_paintable(_arg1)
	runtime.KeepAlive(paintable)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromPixbuf creates a new GtkImage displaying pixbuf.
//
// The GtkImage does not assume a reference to the pixbuf; you still need to
// unref it if you own references. GtkImage will add its own reference rather
// than adopting yours.
//
// This is a helper for gtk.Image.NewFromPaintable, and you can't get back the
// exact pixbuf once this is called, only a texture.
//
// Note that this function just creates an GtkImage from the pixbuf.
// The GtkImage created will not react to state changes. Should you want that,
// you should use gtk.Image.NewFromIconName.
//
// The function takes the following parameters:
//
//   - pixbuf (optional): GdkPixbuf, or NULL.
//
// The function returns the following values:
//
//   - image: new GtkImage.
func NewImageFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) *Image {
	var _arg1 *C.GdkPixbuf // out
	var _cret *C.GtkWidget // in

	if pixbuf != nil {
		_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	}

	_cret = C.gtk_image_new_from_pixbuf(_arg1)
	runtime.KeepAlive(pixbuf)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// NewImageFromResource creates a new GtkImage displaying the resource file
// resource_path.
//
// If the file isn’t found or can’t be loaded, the resulting GtkImage will
// display a “broken image” icon. This function never returns NULL, it always
// returns a valid GtkImage widget.
//
// If you need to detect failures to load the file, use
// gdkpixbuf.Pixbuf.NewFromFile to load the file yourself, then create the
// GtkImage from the pixbuf.
//
// The storage type (see gtk.Image.GetStorageType()) of the returned image is
// not defined, it will be whatever is appropriate for displaying the file.
//
// The function takes the following parameters:
//
//   - resourcePath: resource path.
//
// The function returns the following values:
//
//   - image: new GtkImage.
func NewImageFromResource(resourcePath string) *Image {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_image_new_from_resource(_arg1)
	runtime.KeepAlive(resourcePath)

	var _image *Image // out

	_image = wrapImage(coreglib.Take(unsafe.Pointer(_cret)))

	return _image
}

// Clear resets the image to be empty.
func (image *Image) Clear() {
	var _arg0 *C.GtkImage // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	C.gtk_image_clear(_arg0)
	runtime.KeepAlive(image)
}

// GIcon gets the GIcon being displayed by the GtkImage.
//
// The storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON
// (see gtk.Image.GetStorageType()). The caller of this function does not own a
// reference to the returned GIcon.
//
// The function returns the following values:
//
//   - icon (optional): GIcon, or NULL.
func (image *Image) GIcon() *gio.Icon {
	var _arg0 *C.GtkImage // out
	var _cret *C.GIcon    // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_cret = C.gtk_image_get_gicon(_arg0)
	runtime.KeepAlive(image)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// IconName gets the icon name and size being displayed by the GtkImage.
//
// The storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
// (see gtk.Image.GetStorageType()). The returned string is owned by the
// GtkImage and should not be freed.
//
// The function returns the following values:
//
//   - utf8 (optional): icon name, or NULL.
func (image *Image) IconName() string {
	var _arg0 *C.GtkImage // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_cret = C.gtk_image_get_icon_name(_arg0)
	runtime.KeepAlive(image)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// IconSize gets the icon size used by the image when rendering icons.
//
// The function returns the following values:
//
//   - iconSize: image size used by icons.
func (image *Image) IconSize() IconSize {
	var _arg0 *C.GtkImage   // out
	var _cret C.GtkIconSize // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_cret = C.gtk_image_get_icon_size(_arg0)
	runtime.KeepAlive(image)

	var _iconSize IconSize // out

	_iconSize = IconSize(_cret)

	return _iconSize
}

// Paintable gets the image GdkPaintable being displayed by the GtkImage.
//
// The storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PAINTABLE
// (see gtk.Image.GetStorageType()). The caller of this function does not own a
// reference to the returned paintable.
//
// The function returns the following values:
//
//   - paintable (optional): displayed paintable, or NULL if the image is empty.
func (image *Image) Paintable() *gdk.Paintable {
	var _arg0 *C.GtkImage     // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_cret = C.gtk_image_get_paintable(_arg0)
	runtime.KeepAlive(image)

	var _paintable *gdk.Paintable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_paintable = &gdk.Paintable{
				Object: obj,
			}
		}
	}

	return _paintable
}

// PixelSize gets the pixel size used for named icons.
//
// The function returns the following values:
//
//   - gint: pixel size used for named icons.
func (image *Image) PixelSize() int {
	var _arg0 *C.GtkImage // out
	var _cret C.int       // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_cret = C.gtk_image_get_pixel_size(_arg0)
	runtime.KeepAlive(image)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StorageType gets the type of representation being used by the GtkImage to
// store image data.
//
// If the GtkImage has no image data, the return value will be GTK_IMAGE_EMPTY.
//
// The function returns the following values:
//
//   - imageType: image representation being used.
func (image *Image) StorageType() ImageType {
	var _arg0 *C.GtkImage    // out
	var _cret C.GtkImageType // in

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))

	_cret = C.gtk_image_get_storage_type(_arg0)
	runtime.KeepAlive(image)

	var _imageType ImageType // out

	_imageType = ImageType(_cret)

	return _imageType
}

// SetFromFile sets a GtkImage to show a file.
//
// See gtk.Image.NewFromFile for details.
//
// The function takes the following parameters:
//
//   - filename (optional) or NULL.
func (image *Image) SetFromFile(filename string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if filename != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_image_set_from_file(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(filename)
}

// SetFromGIcon sets a GtkImage to show a GIcon.
//
// See gtk.Image.NewFromGIcon for details.
//
// The function takes the following parameters:
//
//   - icon: icon.
func (image *Image) SetFromGIcon(icon gio.Iconner) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.GIcon    // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(icon).Native()))

	C.gtk_image_set_from_gicon(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(icon)
}

// SetFromIconName sets a GtkImage to show a named icon.
//
// See gtk.Image.NewFromIconName for details.
//
// The function takes the following parameters:
//
//   - iconName (optional): icon name or NULL.
func (image *Image) SetFromIconName(iconName string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if iconName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_image_set_from_icon_name(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(iconName)
}

// SetFromPaintable sets a GtkImage to show a GdkPaintable.
//
// See gtk.Image.NewFromPaintable for details.
//
// The function takes the following parameters:
//
//   - paintable (optional): GdkPaintable or NULL.
func (image *Image) SetFromPaintable(paintable gdk.Paintabler) {
	var _arg0 *C.GtkImage     // out
	var _arg1 *C.GdkPaintable // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if paintable != nil {
		_arg1 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	}

	C.gtk_image_set_from_paintable(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(paintable)
}

// SetFromPixbuf sets a GtkImage to show a GdkPixbuf.
//
// See gtk.Image.NewFromPixbuf for details.
//
// Note: This is a helper for gtk.Image.SetFromPaintable(), and you can't get
// back the exact pixbuf once this is called, only a paintable.
//
// The function takes the following parameters:
//
//   - pixbuf (optional): GdkPixbuf or NULL.
func (image *Image) SetFromPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkImage  // out
	var _arg1 *C.GdkPixbuf // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if pixbuf != nil {
		_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	}

	C.gtk_image_set_from_pixbuf(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(pixbuf)
}

// SetFromResource sets a GtkImage to show a resource.
//
// See gtk.Image.NewFromResource for details.
//
// The function takes the following parameters:
//
//   - resourcePath (optional): resource path or NULL.
func (image *Image) SetFromResource(resourcePath string) {
	var _arg0 *C.GtkImage // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	if resourcePath != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_image_set_from_resource(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(resourcePath)
}

// SetIconSize suggests an icon size to the theme for named icons.
//
// The function takes the following parameters:
//
//   - iconSize: new icon size.
func (image *Image) SetIconSize(iconSize IconSize) {
	var _arg0 *C.GtkImage   // out
	var _arg1 C.GtkIconSize // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	_arg1 = C.GtkIconSize(iconSize)

	C.gtk_image_set_icon_size(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(iconSize)
}

// SetPixelSize sets the pixel size to use for named icons.
//
// If the pixel size is set to a value != -1, it is used instead of the icon
// size set by gtk.Image.SetFromIconName().
//
// The function takes the following parameters:
//
//   - pixelSize: new pixel size.
func (image *Image) SetPixelSize(pixelSize int) {
	var _arg0 *C.GtkImage // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkImage)(unsafe.Pointer(coreglib.InternObject(image).Native()))
	_arg1 = C.int(pixelSize)

	C.gtk_image_set_pixel_size(_arg0, _arg1)
	runtime.KeepAlive(image)
	runtime.KeepAlive(pixelSize)
}

// InfoBar: GtkInfoBar can be show messages to the user without a dialog.
//
// !An example GtkInfoBar (info-bar.png)
//
// It is often temporarily shown at the top or bottom of a document. In contrast
// to gtk.Dialog, which has an action area at the bottom, GtkInfoBar has an
// action area at the side.
//
// The API of GtkInfoBar is very similar to GtkDialog, allowing you
// to add buttons to the action area with gtk.InfoBar.AddButton() or
// gtk.InfoBar.NewWithButtons. The sensitivity of action widgets can be
// controlled with gtk.InfoBar.SetResponseSensitive().
//
// To add widgets to the main content area of a GtkInfoBar, use
// gtk.InfoBar.AddChild().
//
// Similar to gtk.MessageDialog, the contents of a GtkInfoBar can by
// classified as error message, warning, informational message, etc, by using
// gtk.InfoBar.SetMessageType(). GTK may use the message type to determine how
// the message is displayed.
//
// A simple example for using a GtkInfoBar:
//
//	GtkWidget *message_label;
//	GtkWidget *widget;
//	GtkWidget *grid;
//	GtkInfoBar *bar;
//
//	// set up info bar
//	widget = gtk_info_bar_new ();
//	bar = GTK_INFO_BAR (widget);
//	grid = gtk_grid_new ();
//
//	message_label = gtk_label_new ("");
//	gtk_info_bar_add_child (bar, message_label);
//	gtk_info_bar_add_button (bar,
//	                         _("_OK"),
//	                         GTK_RESPONSE_OK);
//	g_signal_connect (bar,
//	                  "response",
//	                  G_CALLBACK (gtk_widget_hide),
//	                  NULL);
//	gtk_grid_attach (GTK_GRID (grid),
//	                 widget,
//	                 0, 2, 1, 1);
//
//	// ...
//
//	// show an error message
//	gtk_label_set_text (GTK_LABEL (message_label), "An error occurred!");
//	gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
//	gtk_widget_show (bar);
//
// # GtkInfoBar as GtkBuildable
//
// The GtkInfoBar implementation of the GtkBuildable interface exposes
// the content area and action area as internal children with the names
// “content_area” and “action_area”.
//
// GtkInfoBar supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The “response” attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs action_area).
//
// # CSS nodes
//
// GtkInfoBar has a single CSS node with name infobar. The node may get one
// of the style classes .info, .warning, .error or .question, depending on the
// message type. If the info bar shows a close button, that button will have the
// .close style class applied.
type InfoBar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*InfoBar)(nil)
)

func wrapInfoBar(obj *coreglib.Object) *InfoBar {
	return &InfoBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalInfoBar(p uintptr) (interface{}, error) {
	return wrapInfoBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClose gets emitted when the user uses a keybinding to dismiss the info
// bar.
//
// The ::close signal is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is the Escape key.
func (infoBar *InfoBar) ConnectClose(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(infoBar, "close", false, unsafe.Pointer(C._gotk4_gtk4_InfoBar_ConnectClose), f)
}

// ConnectResponse is emitted when an action widget is clicked.
//
// The signal is also emitted when the application programmer calls
// gtk.InfoBar.Response(). The response_id depends on which action widget was
// clicked.
func (infoBar *InfoBar) ConnectResponse(f func(responseId int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(infoBar, "response", false, unsafe.Pointer(C._gotk4_gtk4_InfoBar_ConnectResponse), f)
}

// NewInfoBar creates a new GtkInfoBar object.
//
// The function returns the following values:
//
//   - infoBar: new GtkInfoBar object.
func NewInfoBar() *InfoBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_info_bar_new()

	var _infoBar *InfoBar // out

	_infoBar = wrapInfoBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _infoBar
}

// AddActionWidget: add an activatable widget to the action area of a
// GtkInfoBar.
//
// This also connects a signal handler that will emit the gtk.InfoBar::response
// signal on the message area when the widget is activated. The widget is
// appended to the end of the message areas action area.
//
// The function takes the following parameters:
//
//   - child: activatable widget.
//   - responseId: response ID for child.
func (infoBar *InfoBar) AddActionWidget(child Widgetter, responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(responseId)

	C.gtk_info_bar_add_action_widget(_arg0, _arg1, _arg2)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(child)
	runtime.KeepAlive(responseId)
}

// AddButton adds a button with the given text.
//
// Clicking the button will emit the gtk.InfoBar::response signal with the given
// response_id. The button is appended to the end of the info bars's action
// area. The button widget is returned, but usually you don't need it.
//
// The function takes the following parameters:
//
//   - buttonText: text of button.
//   - responseId: response ID for the button.
//
// The function returns the following values:
//
//   - button: GtkButton widget that was added.
func (infoBar *InfoBar) AddButton(buttonText string, responseId int) *Button {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.char       // out
	var _arg2 C.int         // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(buttonText)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(responseId)

	_cret = C.gtk_info_bar_add_button(_arg0, _arg1, _arg2)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(buttonText)
	runtime.KeepAlive(responseId)

	var _button *Button // out

	_button = wrapButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _button
}

// AddChild adds a widget to the content area of the info bar.
//
// The function takes the following parameters:
//
//   - widget: child to be added.
func (infoBar *InfoBar) AddChild(widget Widgetter) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_info_bar_add_child(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(widget)
}

// MessageType returns the message type of the message area.
//
// The function returns the following values:
//
//   - messageType: message type of the message area.
func (infoBar *InfoBar) MessageType() MessageType {
	var _arg0 *C.GtkInfoBar    // out
	var _cret C.GtkMessageType // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))

	_cret = C.gtk_info_bar_get_message_type(_arg0)
	runtime.KeepAlive(infoBar)

	var _messageType MessageType // out

	_messageType = MessageType(_cret)

	return _messageType
}

// Revealed returns whether the info bar is currently revealed.
//
// The function returns the following values:
//
//   - ok: current value of the gtk.InfoBar:revealed property.
func (infoBar *InfoBar) Revealed() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))

	_cret = C.gtk_info_bar_get_revealed(_arg0)
	runtime.KeepAlive(infoBar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowCloseButton returns whether the widget will display a standard close
// button.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget displays standard close button.
func (infoBar *InfoBar) ShowCloseButton() bool {
	var _arg0 *C.GtkInfoBar // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))

	_cret = C.gtk_info_bar_get_show_close_button(_arg0)
	runtime.KeepAlive(infoBar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveActionWidget removes a widget from the action area of info_bar.
//
// The widget must have been put there by a call to
// gtk.InfoBar.AddActionWidget() or gtk.InfoBar.AddButton().
//
// The function takes the following parameters:
//
//   - widget: action widget to remove.
func (infoBar *InfoBar) RemoveActionWidget(widget Widgetter) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_info_bar_remove_action_widget(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(widget)
}

// RemoveChild removes a widget from the content area of the info bar.
//
// The function takes the following parameters:
//
//   - widget: child that has been added to the content area.
func (infoBar *InfoBar) RemoveChild(widget Widgetter) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_info_bar_remove_child(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(widget)
}

// Response emits the “response” signal with the given response_id.
//
// The function takes the following parameters:
//
//   - responseId: response ID.
func (infoBar *InfoBar) Response(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = C.int(responseId)

	C.gtk_info_bar_response(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(responseId)
}

// SetDefaultResponse sets the last widget in the info bar’s action area with
// the given response_id as the default widget for the dialog.
//
// Pressing “Enter” normally activates the default widget.
//
// Note that this function currently requires info_bar to be added to a widget
// hierarchy.
//
// The function takes the following parameters:
//
//   - responseId: response ID.
func (infoBar *InfoBar) SetDefaultResponse(responseId int) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = C.int(responseId)

	C.gtk_info_bar_set_default_response(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(responseId)
}

// SetMessageType sets the message type of the message area.
//
// GTK uses this type to determine how the message is displayed.
//
// The function takes the following parameters:
//
//   - messageType: MessageType.
func (infoBar *InfoBar) SetMessageType(messageType MessageType) {
	var _arg0 *C.GtkInfoBar    // out
	var _arg1 C.GtkMessageType // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = C.GtkMessageType(messageType)

	C.gtk_info_bar_set_message_type(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(messageType)
}

// SetResponseSensitive sets the sensitivity of action widgets for response_id.
//
// Calls gtk_widget_set_sensitive (widget, setting) for each widget in the
// info bars’s action area with the given response_id. A convenient way to
// sensitize/desensitize buttons.
//
// The function takes the following parameters:
//
//   - responseId: response ID.
//   - setting: TRUE for sensitive.
func (infoBar *InfoBar) SetResponseSensitive(responseId int, setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.int         // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	_arg1 = C.int(responseId)
	if setting {
		_arg2 = C.TRUE
	}

	C.gtk_info_bar_set_response_sensitive(_arg0, _arg1, _arg2)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(responseId)
	runtime.KeepAlive(setting)
}

// SetRevealed sets whether the GtkInfoBar is revealed.
//
// Changing this will make info_bar reveal or conceal itself via a sliding
// transition.
//
// Note: this does not show or hide info_bar in the gtk.Widget:visible sense,
// so revealing has no effect if gtk.Widget:visible is FALSE.
//
// The function takes the following parameters:
//
//   - revealed: new value of the property.
func (infoBar *InfoBar) SetRevealed(revealed bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	if revealed {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_revealed(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(revealed)
}

// SetShowCloseButton: if true, a standard close button is shown.
//
// When clicked it emits the response GTK_RESPONSE_CLOSE.
//
// The function takes the following parameters:
//
//   - setting: TRUE to include a close button.
func (infoBar *InfoBar) SetShowCloseButton(setting bool) {
	var _arg0 *C.GtkInfoBar // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(coreglib.InternObject(infoBar).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_info_bar_set_show_close_button(_arg0, _arg1)
	runtime.KeepAlive(infoBar)
	runtime.KeepAlive(setting)
}

// KeyvalTrigger: GtkShortcutTrigger that triggers when a specific keyval and
// modifiers are pressed.
type KeyvalTrigger struct {
	_ [0]func() // equal guard
	ShortcutTrigger
}

var (
	_ ShortcutTriggerer = (*KeyvalTrigger)(nil)
)

func wrapKeyvalTrigger(obj *coreglib.Object) *KeyvalTrigger {
	return &KeyvalTrigger{
		ShortcutTrigger: ShortcutTrigger{
			Object: obj,
		},
	}
}

func marshalKeyvalTrigger(p uintptr) (interface{}, error) {
	return wrapKeyvalTrigger(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewKeyvalTrigger creates a GtkShortcutTrigger that will trigger whenever the
// key with the given keyval and modifiers is pressed.
//
// The function takes the following parameters:
//
//   - keyval to trigger for.
//   - modifiers that need to be present.
//
// The function returns the following values:
//
//   - keyvalTrigger: new GtkShortcutTrigger.
func NewKeyvalTrigger(keyval uint, modifiers gdk.ModifierType) *KeyvalTrigger {
	var _arg1 C.guint               // out
	var _arg2 C.GdkModifierType     // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = C.guint(keyval)
	_arg2 = C.GdkModifierType(modifiers)

	_cret = C.gtk_keyval_trigger_new(_arg1, _arg2)
	runtime.KeepAlive(keyval)
	runtime.KeepAlive(modifiers)

	var _keyvalTrigger *KeyvalTrigger // out

	_keyvalTrigger = wrapKeyvalTrigger(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _keyvalTrigger
}

// Keyval gets the keyval that must be pressed to succeed triggering self.
//
// The function returns the following values:
//
//   - guint: keyval.
func (self *KeyvalTrigger) Keyval() uint {
	var _arg0 *C.GtkKeyvalTrigger // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkKeyvalTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_keyval_trigger_get_keyval(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Modifiers gets the modifiers that must be present to succeed triggering self.
//
// The function returns the following values:
//
//   - modifierType: modifiers.
func (self *KeyvalTrigger) Modifiers() gdk.ModifierType {
	var _arg0 *C.GtkKeyvalTrigger // out
	var _cret C.GdkModifierType   // in

	_arg0 = (*C.GtkKeyvalTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_keyval_trigger_get_modifiers(_arg0)
	runtime.KeepAlive(self)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// Label: GtkLabel widget displays a small amount of text.
//
// As the name implies, most labels are used to label another widget such as a
// button.
//
// !An example GtkLabel (label.png)
//
// CSS nodes
//
//	label
//	├── [selection]
//	├── [link]
//	┊
//	╰── [link]
//
// GtkLabel has a single CSS node with the name label. A wide variety of style
// classes may be applied to labels, such as .title, .subtitle, .dim-label, etc.
// In the GtkShortcutsWindow, labels are used with the .keycap style class.
//
// If the label has a selection, it gets a subnode with name selection.
//
// If the label has links, there is one subnode per link. These subnodes carry
// the link or visited state depending on whether they have been visited.
// In this case, label node also gets a .link style class.
//
// # GtkLabel as GtkBuildable
//
// The GtkLabel implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements.
// The <attribute> element has attributes named “name“, “value“, “start“ and
// “end“ and allows you to specify pango.Attribute values for this label.
//
// An example of a UI definition fragment specifying Pango attributes:
//
//	<object class="GtkLabel">
//	  <attributes>
//	    <attribute name="weight" value="PANGO_WEIGHT_BOLD"/>
//	    <attribute name="background" value="red" start="5" end="10"/>
//	  </attributes>
//	</object>
//
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute
// is applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
//
// # Accessibility
//
// GtkLabel uses the K_ACCESSIBLE_ROLE_LABEL role.
//
// # Mnemonics
//
// Labels may contain “mnemonics”. Mnemonics are underlined characters in the
// label, used for keyboard navigation. Mnemonics are created by providing a
// string with an underscore before the mnemonic character, such as "_File", to
// the functions gtk.Label.NewWithMnemonic or gtk.Label.SetTextWithMnemonic().
//
// Mnemonics automatically activate any activatable widget the label is
// inside, such as a gtk.Button; if the label is not inside the mnemonic’s
// target widget, you have to tell the label about the target using
// gtk.Label.SetMnemonicWidget. Here’s a simple example where the label is
// inside a button:
//
//	// Pressing Alt+H will activate this button
//	GtkWidget *button = gtk_button_new ();
//	GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
//	gtk_button_set_child (GTK_BUTTON (button), label);
//
// There’s a convenience function to create buttons with a mnemonic label
// already inside:
//
//	// Pressing Alt+H will activate this button
//	GtkWidget *button = gtk_button_new_with_mnemonic ("_Hello");
//
// To create a mnemonic for a widget alongside the label, such as a gtk.Entry,
// you have to point the label at the entry with gtk.Label.SetMnemonicWidget():
//
//	// Pressing Alt+H will focus the entry
//	GtkWidget *entry = gtk_entry_new ();
//	GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
//	gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry);
//
// Markup (styled text)
//
// To make it easy to format text in a label (changing colors, fonts, etc.),
// label text can be provided in a simple markup format:
//
// Here’s how to create a label with a small font:
//
//	GtkWidget *label = gtk_label_new (NULL);
//	gtk_label_set_markup (GTK_LABEL (label), "<small>Small text</small>");
//
// (See the Pango manual for complete documentation] of available tags,
// pango.ParseMarkup())
//
// The markup passed to gtk_label_set_markup() must be valid; for example,
// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;.
// If you pass text obtained from the user, file, or a network to
// gtk.Label.SetMarkup(), you’ll want to escape it with g_markup_escape_text()
// or g_markup_printf_escaped().
//
// Markup strings are just a convenient way to set the pango.AttrList on a
// label; gtk.Label.SetAttributes() may be a simpler way to set attributes
// in some cases. Be careful though; pango.AttrList tends to cause
// internationalization problems, unless you’re applying attributes to the
// entire string (i.e. unless you set the range of each attribute to [0,
// G_MAXINT)). The reason is that specifying the start_index and end_index for
// a pango.Attribute requires knowledge of the exact string being displayed,
// so translations will cause problems.
//
// # Selectable labels
//
// Labels can be made selectable with gtk.Label.SetSelectable(). Selectable
// labels allow the user to copy the label contents to the clipboard. Only
// labels that contain useful-to-copy information — such as error messages —
// should be made selectable.
//
// # Text layout
//
// A label can contain any number of paragraphs, but will have performance
// problems if it contains more than a small number. Paragraphs are separated by
// newlines or other paragraph separators understood by Pango.
//
// Labels can automatically wrap text if you call gtk.Label.SetWrap().
//
// gtk.Label.SetJustify() sets how the lines in a label align with one another.
// If you want to set how the label as a whole aligns in its available space,
// see the gtk.Widget:halign and gtk.Widget:valign properties.
//
// The gtk.Label:width-chars and gtk.Label:max-width-chars properties can
// be used to control the size allocation of ellipsized or wrapped labels.
// For ellipsizing labels, if either is specified (and less than the actual text
// size), it is used as the minimum width, and the actual text size is used as
// the natural width of the label. For wrapping labels, width-chars is used as
// the minimum width, if specified, and max-width-chars is used as the natural
// width. Even if max-width-chars specified, wrapping labels will be rewrapped
// to use all of the available width.
//
// # Links
//
// GTK supports markup for clickable hyperlinks in addition to regular Pango
// markup. The markup for links is borrowed from HTML, using the <a> with
// “href“, “title“ and “class“ attributes. GTK renders links similar to the
// way they appear in web browsers, with colored, underlined text. The “title“
// attribute is displayed as a tooltip on the link. The “class“ attribute is
// used as style class on the CSS node for the link.
//
// An example looks like this:
//
//	const char *text =
//	"Go to the"
//	"<a href=\"http://www.gtk.org title=\"&lt;i&gt;Our&lt;/i&gt; website\">"
//	"GTK website</a> for more...";
//	GtkWidget *label = gtk_label_new (NULL);
//	gtk_label_set_markup (GTK_LABEL (label), text);
//
// It is possible to implement custom handling for links and their tooltips
// with the gtk.Label::activate-link signal and the gtk.Label.GetCurrentURI()
// function.
type Label struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Label)(nil)
)

func wrapLabel(obj *coreglib.Object) *Label {
	return &Label{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalLabel(p uintptr) (interface{}, error) {
	return wrapLabel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateCurrentLink gets emitted when the user activates a link in the
// label.
//
// The ::activate-current-link is a keybinding signal (class.SignalAction.html).
//
// Applications may also emit the signal with g_signal_emit_by_name() if they
// need to control activation of URIs programmatically.
//
// The default bindings for this signal are all forms of the Enter key.
func (self *Label) ConnectActivateCurrentLink(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate-current-link", false, unsafe.Pointer(C._gotk4_gtk4_Label_ConnectActivateCurrentLink), f)
}

// ConnectActivateLink gets emitted to activate a URI.
//
// Applications may connect to it to override the default behaviour, which is to
// call gtk_show_uri().
func (self *Label) ConnectActivateLink(f func(uri string) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate-link", false, unsafe.Pointer(C._gotk4_gtk4_Label_ConnectActivateLink), f)
}

// ConnectCopyClipboard gets emitted to copy the slection to the clipboard.
//
// The ::copy-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is Ctrl-c.
func (self *Label) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Label_ConnectCopyClipboard), f)
}

// ConnectMoveCursor gets emitted when the user initiates a cursor movement.
//
// The ::move-cursor signal is a keybinding signal (class.SignalAction.html).
// If the cursor is not visible in entry, this signal causes the viewport to be
// moved instead.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
// The default bindings for this signal come in two variants, the variant with
// the Shift modifier extends the selection, the variant without the Shift
// modifier does not. There are too many key combinations to list them all here.
//
// - Arrow keys move by individual characters/lines
//
// - Ctrl-arrow key combinations move by words/paragraphs
//
// - Home/End keys move to the ends of the buffer.
func (self *Label) ConnectMoveCursor(f func(step MovementStep, count int, extendSelection bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk4_Label_ConnectMoveCursor), f)
}

// NewLabel creates a new label with the given text inside it.
//
// You can pass NULL to get an empty label widget.
//
// The function takes the following parameters:
//
//   - str (optional): text of the label.
//
// The function returns the following values:
//
//   - label: new GtkLabel.
func NewLabel(str string) *Label {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if str != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_label_new(_arg1)
	runtime.KeepAlive(str)

	var _label *Label // out

	_label = wrapLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// NewLabelWithMnemonic creates a new GtkLabel, containing the text in str.
//
// If characters in str are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use '__' (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. The mnemonic key can be used to
// activate another widget, chosen automatically, or explicitly using
// gtk.Label.SetMnemonicWidget().
//
// If gtk.Label.SetMnemonicWidget() is not called, then the first activatable
// ancestor of the GtkLabel will be chosen as the mnemonic widget. For instance,
// if the label is inside a button or menu item, the button or menu item will
// automatically become the mnemonic widget and be activated by the mnemonic.
//
// The function takes the following parameters:
//
//   - str (optional): text of the label, with an underscore in front of the
//     mnemonic character.
//
// The function returns the following values:
//
//   - label: new GtkLabel.
func NewLabelWithMnemonic(str string) *Label {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if str != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_label_new_with_mnemonic(_arg1)
	runtime.KeepAlive(str)

	var _label *Label // out

	_label = wrapLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _label
}

// Attributes gets the labels attribute list.
//
// This is the pango.AttrList that was set on the label using
// gtk.Label.SetAttributes(), if any. This function does not reflect attributes
// that come from the labels markup (see gtk.Label.SetMarkup()). If you want to
// get the effective attributes for the label, use pango_layout_get_attribute
// (gtk_label_get_layout (self)).
//
// The function returns the following values:
//
//   - attrList (optional): attribute list, or NULL if none was set.
func (self *Label) Attributes() *pango.AttrList {
	var _arg0 *C.GtkLabel      // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_attributes(_arg0)
	runtime.KeepAlive(self)

	var _attrList *pango.AttrList // out

	if _cret != nil {
		_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// CurrentURI returns the URI for the currently active link in the label.
//
// The active link is the one under the mouse pointer or, in a selectable label,
// the link in which the text cursor is currently positioned.
//
// This function is intended for use in a gtk.Label::activate-link handler or
// for use in a gtk.Widget::query-tooltip handler.
//
// The function returns the following values:
//
//   - utf8 (optional): currently active URI or NULL if there is none. The
//     string is owned by GTK and must not be freed or modified.
func (self *Label) CurrentURI() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_current_uri(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Ellipsize returns the ellipsizing position of the label.
//
// See gtk.Label.SetEllipsize().
//
// The function returns the following values:
//
//   - ellipsizeMode: PangoEllipsizeMode.
func (self *Label) Ellipsize() pango.EllipsizeMode {
	var _arg0 *C.GtkLabel          // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_ellipsize(_arg0)
	runtime.KeepAlive(self)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

// ExtraMenu gets the extra menu model of label.
//
// See gtk.Label.SetExtraMenu().
//
// The function returns the following values:
//
//   - menuModel (optional): menu model.
func (self *Label) ExtraMenu() gio.MenuModeller {
	var _arg0 *C.GtkLabel   // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_extra_menu(_arg0)
	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// Justify returns the justification of the label.
//
// See gtk.Label.SetJustify().
//
// The function returns the following values:
//
//   - justification: GtkJustification.
func (self *Label) Justify() Justification {
	var _arg0 *C.GtkLabel        // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_justify(_arg0)
	runtime.KeepAlive(self)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

// Label fetches the text from a label.
//
// The returned text includes any embedded underlines indicating mnemonics and
// Pango markup. (See gtk.Label.GetText()).
//
// The function returns the following values:
//
//   - utf8: text of the label widget. This string is owned by the widget and
//     must not be modified or freed.
func (self *Label) Label() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_label(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Layout gets the PangoLayout used to display the label.
//
// The layout is useful to e.g. convert text positions to pixel positions,
// in combination with gtk.Label.GetLayoutOffsets(). The returned layout is
// owned by the label so need not be freed by the caller. The label is free to
// recreate its layout at any time, so it should be considered read-only.
//
// The function returns the following values:
//
//   - layout: pango.Layout for this label.
func (self *Label) Layout() *pango.Layout {
	var _arg0 *C.GtkLabel    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_layout(_arg0)
	runtime.KeepAlive(self)

	var _layout *pango.Layout // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// LayoutOffsets obtains the coordinates where the label will draw its
// PangoLayout.
//
// The coordinates are useful to convert mouse events into coordinates inside
// the pango.Layout, e.g. to take some action if some part of the label is
// clicked. Remember when using the pango.Layout functions you need to convert
// to and from pixels using PANGO_PIXELS() or pango.SCALE.
//
// The function returns the following values:
//
//   - x (optional): location to store X offset of layout, or NULL.
//   - y (optional): location to store Y offset of layout, or NULL.
func (self *Label) LayoutOffsets() (x, y int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_label_get_layout_offsets(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(self)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// Lines gets the number of lines to which an ellipsized, wrapping label should
// be limited.
//
// See gtk.Label.SetLines().
//
// The function returns the following values:
//
//   - gint: number of lines.
func (self *Label) Lines() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_lines(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxWidthChars retrieves the desired maximum width of label, in characters.
//
// See gtk.Label.SetWidthChars().
//
// The function returns the following values:
//
//   - gint: maximum width of the label in characters.
func (self *Label) MaxWidthChars() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_max_width_chars(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MnemonicKeyval: return the mnemonic accelerator.
//
// If the label has been set so that it has a mnemonic key this function returns
// the keyval used for the mnemonic accelerator. If there is no mnemonic set up
// it returns GDK_KEY_VoidSymbol.
//
// The function returns the following values:
//
//   - guint: GDK keyval usable for accelerators, or GDK_KEY_VoidSymbol.
func (self *Label) MnemonicKeyval() uint {
	var _arg0 *C.GtkLabel // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_mnemonic_keyval(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut) of
// this label.
//
// See gtk.Label.SetMnemonicWidget().
//
// The function returns the following values:
//
//   - widget (optional): target of the label’s mnemonic, or NULL if none has
//     been set and the default algorithm will be used.
func (self *Label) MnemonicWidget() Widgetter {
	var _arg0 *C.GtkLabel  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_mnemonic_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Selectable returns whether the label is selectable.
//
// The function returns the following values:
//
//   - ok: TRUE if the user can copy text from the label.
func (self *Label) Selectable() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_selectable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionBounds gets the selected range of characters in the label.
//
// The function returns the following values:
//
//   - start: return location for start of selection, as a character offset.
//   - end: return location for end of selection, as a character offset.
//   - ok: TRUE if selection is non-empty.
func (self *Label) SelectionBounds() (start, end int, ok bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_selection_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(self)

	var _start int // out
	var _end int   // out
	var _ok bool   // out

	_start = int(_arg1)
	_end = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// SingleLineMode returns whether the label is in single line mode.
//
// The function returns the following values:
//
//   - ok: TRUE when the label is in single line mode.
func (self *Label) SingleLineMode() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_single_line_mode(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Text fetches the text from a label.
//
// The returned text is as it appears on screen. This does not include
// any embedded underlines indicating mnemonics or Pango markup. (See
// gtk.Label.GetLabel()).
//
// The function returns the following values:
//
//   - utf8: text in the label widget. This is the internal string used by the
//     label, and must not be modified.
func (self *Label) Text() string {
	var _arg0 *C.GtkLabel // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_text(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// UseMarkup returns whether the label’s text is interpreted as Pango markup.
//
// See gtk.Label.SetUseMarkup().
//
// The function returns the following values:
//
//   - ok: TRUE if the label’s text will be parsed for markup.
func (self *Label) UseMarkup() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_use_markup(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UseUnderline returns whether an embedded underlines in the label indicate
// mnemonics.
//
// See gtk.Label.SetUseUnderline().
//
// The function returns the following values:
//
//   - ok: TRUE whether an embedded underline in the label indicates the
//     mnemonic accelerator keys.
func (self *Label) UseUnderline() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_use_underline(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WidthChars retrieves the desired width of label, in characters.
//
// See gtk.Label.SetWidthChars().
//
// The function returns the following values:
//
//   - gint: width of the label in characters.
func (self *Label) WidthChars() int {
	var _arg0 *C.GtkLabel // out
	var _cret C.int       // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_width_chars(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Wrap returns whether lines in the label are automatically wrapped.
//
// See gtk.Label.SetWrap().
//
// The function returns the following values:
//
//   - ok: TRUE if the lines of the label are automatically wrapped.
func (self *Label) Wrap() bool {
	var _arg0 *C.GtkLabel // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_wrap(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WrapMode returns line wrap mode used by the label.
//
// See gtk.Label.SetWrapMode().
//
// The function returns the following values:
//
//   - wrapMode: TRUE if the lines of the label are automatically wrapped.
func (self *Label) WrapMode() pango.WrapMode {
	var _arg0 *C.GtkLabel     // out
	var _cret C.PangoWrapMode // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_wrap_mode(_arg0)
	runtime.KeepAlive(self)

	var _wrapMode pango.WrapMode // out

	_wrapMode = pango.WrapMode(_cret)

	return _wrapMode
}

// XAlign gets the xalign of the label.
//
// See the gtk.Label:xalign property.
//
// The function returns the following values:
//
//   - gfloat: xalign property.
func (self *Label) XAlign() float32 {
	var _arg0 *C.GtkLabel // out
	var _cret C.float     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_xalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// YAlign gets the yalign of the label.
//
// See the gtk.Label:yalign property.
//
// The function returns the following values:
//
//   - gfloat: yalign property.
func (self *Label) YAlign() float32 {
	var _arg0 *C.GtkLabel // out
	var _cret C.float     // in

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_label_get_yalign(_arg0)
	runtime.KeepAlive(self)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// SelectRegion selects a range of characters in the label, if the label is
// selectable.
//
// See gtk.Label.SetSelectable(). If the label is not selectable, this function
// has no effect. If start_offset or end_offset are -1, then the end of the
// label will be substituted.
//
// The function takes the following parameters:
//
//   - startOffset: start offset (in characters not bytes).
//   - endOffset: end offset (in characters not bytes).
func (self *Label) SelectRegion(startOffset, endOffset int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out
	var _arg2 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(startOffset)
	_arg2 = C.int(endOffset)

	C.gtk_label_select_region(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(startOffset)
	runtime.KeepAlive(endOffset)
}

// SetAttributes: apply attributes to the label text.
//
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the gtk.Label:use-underline
// or gtk.Label:use-markup properties. While it is not recommended to mix markup
// strings with manually set attributes, if you must; know that the attributes
// will be applied to the label after the markup string is parsed.
//
// The function takes the following parameters:
//
//   - attrs (optional): pango.AttrList, or NULL.
func (self *Label) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkLabel      // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if attrs != nil {
		_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	}

	C.gtk_label_set_attributes(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(attrs)
}

// SetEllipsize sets the mode used to ellipsizei the text.
//
// The text will be ellipsized if there is not enough space to render the entire
// string.
//
// The function takes the following parameters:
//
//   - mode: PangoEllipsizeMode.
func (self *Label) SetEllipsize(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkLabel          // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.PangoEllipsizeMode(mode)

	C.gtk_label_set_ellipsize(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(mode)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// label.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel.
func (self *Label) SetExtraMenu(model gio.MenuModeller) {
	var _arg0 *C.GtkLabel   // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_label_set_extra_menu(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetJustify sets the alignment of the lines in the text of the label relative
// to each other.
//
// GTK_JUSTIFY_LEFT is the default value when the widget is first created with
// gtk.Label.New. If you instead want to set the alignment of the label as a
// whole, use gtk.Widget.SetHAlign() instead. gtk.Label.SetJustify() has no
// effect on labels containing only a single line.
//
// The function takes the following parameters:
//
//   - jtype: GtkJustification.
func (self *Label) SetJustify(jtype Justification) {
	var _arg0 *C.GtkLabel        // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkJustification(jtype)

	C.gtk_label_set_justify(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(jtype)
}

// SetLabel sets the text of the label.
//
// The label is interpreted as including embedded underlines and/or Pango
// markup depending on the values of the gtk.Label:use-underline and
// gtk.Label:use-markup properties.
//
// The function takes the following parameters:
//
//   - str: new text to set for the label.
func (self *Label) SetLabel(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_label(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited.
//
// This has no effect if the label is not wrapping or ellipsized. Set this to -1
// if you don’t want to limit the number of lines.
//
// The function takes the following parameters:
//
//   - lines: desired number of lines, or -1.
func (self *Label) SetLines(lines int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(lines)

	C.gtk_label_set_lines(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(lines)
}

// SetMarkup sets the labels text and attributes from markup.
//
// The string must be marked up with Pango markup (see pango.ParseMarkup()).
//
// If the str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
//
//	GtkWidget *self = gtk_label_new (NULL);
//	const char *str = "...";
//	const char *format = "<span style=\"italic\">\s</span>";
//	char *markup;
//
//	markup = g_markup_printf_escaped (format, str);
//	gtk_label_set_markup (GTK_LABEL (self), markup);
//	g_free (markup);
//
// This function will set the gtk.Label:use-markup property to TRUE as a side
// effect.
//
// If you set the label contents using the gtk.Label:label property you should
// also ensure that you set the gtk.Label:use-markup property accordingly.
//
// See also: gtk.Label.SetText().
//
// The function takes the following parameters:
//
//   - str: markup string.
func (self *Label) SetMarkup(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetMarkupWithMnemonic sets the labels text, attributes and mnemonic from
// markup.
//
// Parses str which is marked up with Pango markup (see pango.ParseMarkup()),
// setting the label’s text and attribute list based on the parse results.
// If characters in str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic.
//
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using methodGtk.Label.set_mnemonic_widget].
//
// The function takes the following parameters:
//
//   - str: markup string.
func (self *Label) SetMarkupWithMnemonic(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_markup_with_mnemonic(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetMaxWidthChars sets the desired maximum width in characters of label to
// n_chars.
//
// The function takes the following parameters:
//
//   - nChars: new desired maximum width, in characters.
func (self *Label) SetMaxWidthChars(nChars int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(nChars)

	C.gtk_label_set_max_width_chars(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(nChars)
}

// SetMnemonicWidget: associate the label with its mnemonic target.
//
// If the label has been set so that it has a mnemonic key (using i.e.
// gtk.Label.SetMarkupWithMnemonic(), gtk.Label.SetTextWithMnemonic(),
// gtk.Label.NewWithMnemonic or the gtk.Label:useUnderline property) the
// label can be associated with a widget that is the target of the mnemonic.
// When the label is inside a widget (like a gtk.Button or a gtk.Notebook tab)
// it is automatically associated with the correct widget, but sometimes (i.e.
// when the target is a gtk.Entry next to the label) you need to set it
// explicitly using this function.
//
// The target widget will be accelerated by emitting the
// gtkwidget::mnemonic-activate signal on it. The default handler for this
// signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
//
// The function takes the following parameters:
//
//   - widget (optional): target Widget, or NULL to unset.
func (self *Label) SetMnemonicWidget(widget Widgetter) {
	var _arg0 *C.GtkLabel  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_label_set_mnemonic_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(widget)
}

// SetSelectable makes text in the label selectable.
//
// Selectable labels allow the user to select text from the label, for
// copy-and-paste.
//
// The function takes the following parameters:
//
//   - setting: TRUE to allow selecting text in the label.
func (self *Label) SetSelectable(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_selectable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetSingleLineMode sets whether the label is in single line mode.
//
// The function takes the following parameters:
//
//   - singleLineMode: TRUE if the label should be in single line mode.
func (self *Label) SetSingleLineMode(singleLineMode bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if singleLineMode {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_single_line_mode(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(singleLineMode)
}

// SetText sets the text within the GtkLabel widget.
//
// It overwrites any text that was there before.
//
// This function will clear any previously set mnemonic accelerators, and set
// the gtk.Label:use-underline property to FALSE as a side effect.
//
// This function will set the gtk.Label:use-markup property to FALSE as a side
// effect.
//
// See also: gtk.Label.SetMarkup().
//
// The function takes the following parameters:
//
//   - str: text you want to set.
func (self *Label) SetText(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetTextWithMnemonic sets the label’s text from the string str.
//
// If characters in str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic. The
// mnemonic key can be used to activate another widget, chosen automatically,
// or explicitly using gtk.Label.SetMnemonicWidget().
//
// The function takes the following parameters:
//
//   - str: string.
func (self *Label) SetTextWithMnemonic(str string) {
	var _arg0 *C.GtkLabel // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_label_set_text_with_mnemonic(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// SetUseMarkup sets whether the text of the label contains markup.
//
// See gtk.Label.SetMarkup().
//
// The function takes the following parameters:
//
//   - setting: TRUE if the label’s text should be parsed for markup.
func (self *Label) SetUseMarkup(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_use_markup(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetUseUnderline sets whether underlines in the text indicate mnemonics.
//
// The function takes the following parameters:
//
//   - setting: TRUE if underlines in the text indicate mnemonics.
func (self *Label) SetUseUnderline(setting bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_use_underline(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetWidthChars sets the desired width in characters of label to n_chars.
//
// The function takes the following parameters:
//
//   - nChars: new desired width, in characters.
func (self *Label) SetWidthChars(nChars int) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(nChars)

	C.gtk_label_set_width_chars(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(nChars)
}

// SetWrap toggles line wrapping within the GtkLabel widget.
//
// TRUE makes it break lines if text exceeds the widget’s size. FALSE lets the
// text get cut off by the edge of the widget if it exceeds the widget size.
//
// Note that setting line wrapping to TRUE does not make the label wrap at its
// parent container’s width, because GTK widgets conceptually can’t make their
// requisition depend on the parent container’s size. For a label that wraps at
// a specific position, set the label’s width using gtk.Widget.SetSizeRequest().
//
// The function takes the following parameters:
//
//   - wrap: setting.
func (self *Label) SetWrap(wrap bool) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if wrap {
		_arg1 = C.TRUE
	}

	C.gtk_label_set_wrap(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(wrap)
}

// SetWrapMode controls how line wrapping is done.
//
// This only affects the label if line wrapping is on. (See gtk.Label.SetWrap())
// The default is PANGO_WRAP_WORD which means wrap on word boundaries.
//
// The function takes the following parameters:
//
//   - wrapMode: line wrapping mode.
func (self *Label) SetWrapMode(wrapMode pango.WrapMode) {
	var _arg0 *C.GtkLabel     // out
	var _arg1 C.PangoWrapMode // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.PangoWrapMode(wrapMode)

	C.gtk_label_set_wrap_mode(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(wrapMode)
}

// SetXAlign sets the xalign of the label.
//
// See the gtk.Label:xalign property.
//
// The function takes the following parameters:
//
//   - xalign: new xalign value, between 0 and 1.
func (self *Label) SetXAlign(xalign float32) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(xalign)

	C.gtk_label_set_xalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(xalign)
}

// SetYAlign sets the yalign of the label.
//
// See the gtk.Label:yalign property.
//
// The function takes the following parameters:
//
//   - yalign: new yalign value, between 0 and 1.
func (self *Label) SetYAlign(yalign float32) {
	var _arg0 *C.GtkLabel // out
	var _arg1 C.float     // out

	_arg0 = (*C.GtkLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.float(yalign)

	C.gtk_label_set_yalign(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(yalign)
}

// LayoutChildOverrides contains methods that are overridable.
type LayoutChildOverrides struct {
}

func defaultLayoutChildOverrides(v *LayoutChild) LayoutChildOverrides {
	return LayoutChildOverrides{}
}

// LayoutChild: GtkLayoutChild is the base class for objects that are meant to
// hold layout properties.
//
// If a GtkLayoutManager has per-child properties, like their packing type, or
// the horizontal and vertical span, or the icon name, then the layout manager
// should use a GtkLayoutChild implementation to store those properties.
//
// A GtkLayoutChild instance is only ever valid while a widget is part of a
// layout.
type LayoutChild struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*LayoutChild)(nil)
)

// LayoutChilder describes types inherited from class LayoutChild.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type LayoutChilder interface {
	coreglib.Objector
	baseLayoutChild() *LayoutChild
}

var _ LayoutChilder = (*LayoutChild)(nil)

func init() {
	coreglib.RegisterClassInfo[*LayoutChild, *LayoutChildClass, LayoutChildOverrides](
		GTypeLayoutChild,
		initLayoutChildClass,
		wrapLayoutChild,
		defaultLayoutChildOverrides,
	)
}

func initLayoutChildClass(gclass unsafe.Pointer, overrides LayoutChildOverrides, classInitFunc func(*LayoutChildClass)) {
	if classInitFunc != nil {
		class := (*LayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapLayoutChild(obj *coreglib.Object) *LayoutChild {
	return &LayoutChild{
		Object: obj,
	}
}

func marshalLayoutChild(p uintptr) (interface{}, error) {
	return wrapLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (layoutChild *LayoutChild) baseLayoutChild() *LayoutChild {
	return layoutChild
}

// BaseLayoutChild returns the underlying base object.
func BaseLayoutChild(obj LayoutChilder) *LayoutChild {
	return obj.baseLayoutChild()
}

// ChildWidget retrieves the GtkWidget associated to the given layout_child.
//
// The function returns the following values:
//
//   - widget: Widget.
func (layoutChild *LayoutChild) ChildWidget() Widgetter {
	var _arg0 *C.GtkLayoutChild // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkLayoutChild)(unsafe.Pointer(coreglib.InternObject(layoutChild).Native()))

	_cret = C.gtk_layout_child_get_child_widget(_arg0)
	runtime.KeepAlive(layoutChild)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// LayoutManager retrieves the GtkLayoutManager instance that created the given
// layout_child.
//
// The function returns the following values:
//
//   - layoutManager: GtkLayoutManager.
func (layoutChild *LayoutChild) LayoutManager() LayoutManagerer {
	var _arg0 *C.GtkLayoutChild   // out
	var _cret *C.GtkLayoutManager // in

	_arg0 = (*C.GtkLayoutChild)(unsafe.Pointer(coreglib.InternObject(layoutChild).Native()))

	_cret = C.gtk_layout_child_get_layout_manager(_arg0)
	runtime.KeepAlive(layoutChild)

	var _layoutManager LayoutManagerer // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.LayoutManagerer is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(LayoutManagerer)
			return ok
		})
		rv, ok := casted.(LayoutManagerer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.LayoutManagerer")
		}
		_layoutManager = rv
	}

	return _layoutManager
}

// LayoutManagerOverrides contains methods that are overridable.
type LayoutManagerOverrides struct {
	// Allocate assigns the given width, height, and baseline to a widget,
	// and computes the position and sizes of the children of the widget using
	// the layout management policy of manager.
	//
	// The function takes the following parameters:
	//
	//   - widget: GtkWidget using manager.
	//   - width: new width of the widget.
	//   - height: new height of the widget.
	//   - baseline position of the widget, or -1.
	Allocate func(widget Widgetter, width, height, baseline int)
	// CreateLayoutChild: create a LayoutChild instance for the given for_child
	// widget.
	//
	// The function takes the following parameters:
	//
	//   - widget using the manager.
	//   - forChild: child of widget.
	//
	// The function returns the following values:
	//
	//   - layoutChild: LayoutChild.
	CreateLayoutChild func(widget, forChild Widgetter) LayoutChilder
	RequestMode       func(widget Widgetter) SizeRequestMode
	// Measure measures the size of the widget using manager, for the given
	// orientation and size.
	//
	// See the gtk.Widget documentation on layout management for more details.
	//
	// The function takes the following parameters:
	//
	//   - widget: GtkWidget using manager.
	//   - orientation to measure.
	//   - forSize: size for the opposite of orientation; for instance, if the
	//     orientation is GTK_ORIENTATION_HORIZONTAL, this is the height of the
	//     widget; if the orientation is GTK_ORIENTATION_VERTICAL, this is the
	//     width of the widget. This allows to measure the height for the given
	//     width, and the width for the given height. Use -1 if the size is not
	//     known.
	//
	// The function returns the following values:
	//
	//   - minimum (optional) size for the given size and orientation.
	//   - natural (optional): natural, or preferred size for the given size and
	//     orientation.
	//   - minimumBaseline (optional): baseline position for the minimum size.
	//   - naturalBaseline (optional): baseline position for the natural size.
	Measure func(widget Widgetter, orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int)
	Root    func()
	Unroot  func()
}

func defaultLayoutManagerOverrides(v *LayoutManager) LayoutManagerOverrides {
	return LayoutManagerOverrides{
		Allocate:          v.allocate,
		CreateLayoutChild: v.createLayoutChild,
		RequestMode:       v.requestMode,
		Measure:           v.measure,
		Root:              v.root,
		Unroot:            v.unroot,
	}
}

// LayoutManager: layout managers are delegate classes that handle the preferred
// size and the allocation of a widget.
//
// You typically subclass GtkLayoutManager if you want to implement a layout
// policy for the children of a widget, or if you want to determine the size of
// a widget depending on its contents.
//
// Each GtkWidget can only have a GtkLayoutManager instance associated to it
// at any given time; it is possible, though, to replace the layout manager
// instance using gtk.Widget.SetLayoutManager().
//
// # Layout properties
//
// A layout manager can expose properties for controlling the layout of each
// child, by creating an object type derived from gtk.LayoutChild and installing
// the properties on it as normal GObject properties.
//
// Each GtkLayoutChild instance storing the layout properties for a specific
// child is created through the gtk.LayoutManager.GetLayoutChild() method;
// a GtkLayoutManager controls the creation of its GtkLayoutChild instances by
// overriding the GtkLayoutManagerClass.create_layout_child() virtual function.
// The typical implementation should look like:
//
//	static GtkLayoutChild *
//	create_layout_child (GtkLayoutManager *manager,
//	                     GtkWidget        *container,
//	                     GtkWidget        *child)
//	{
//	  return g_object_new (your_layout_child_get_type (),
//	                       "layout-manager", manager,
//	                       "child-widget", child,
//	                       NULL);
//	}
//
// The gtk.LayoutChild:layout-manager and gtk.LayoutChild:child-widget
// properties on the newly created GtkLayoutChild instance are mandatory.
// The GtkLayoutManager will cache the newly created GtkLayoutChild instance
// until the widget is removed from its parent, or the parent removes the layout
// manager.
//
// Each GtkLayoutManager instance creating a GtkLayoutChild should use
// gtk.LayoutManager.GetLayoutChild() every time it needs to query
// the layout properties; each GtkLayoutChild instance should call
// gtk.LayoutManager.LayoutChanged() every time a property is updated, in order
// to queue a new size measuring and allocation.
type LayoutManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*LayoutManager)(nil)
)

// LayoutManagerer describes types inherited from class LayoutManager.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type LayoutManagerer interface {
	coreglib.Objector
	baseLayoutManager() *LayoutManager
}

var _ LayoutManagerer = (*LayoutManager)(nil)

func init() {
	coreglib.RegisterClassInfo[*LayoutManager, *LayoutManagerClass, LayoutManagerOverrides](
		GTypeLayoutManager,
		initLayoutManagerClass,
		wrapLayoutManager,
		defaultLayoutManagerOverrides,
	)
}

func initLayoutManagerClass(gclass unsafe.Pointer, overrides LayoutManagerOverrides, classInitFunc func(*LayoutManagerClass)) {
	pclass := (*C.GtkLayoutManagerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeLayoutManager))))

	if overrides.Allocate != nil {
		pclass.allocate = (*[0]byte)(C._gotk4_gtk4_LayoutManagerClass_allocate)
	}

	if overrides.CreateLayoutChild != nil {
		pclass.create_layout_child = (*[0]byte)(C._gotk4_gtk4_LayoutManagerClass_create_layout_child)
	}

	if overrides.RequestMode != nil {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk4_LayoutManagerClass_get_request_mode)
	}

	if overrides.Measure != nil {
		pclass.measure = (*[0]byte)(C._gotk4_gtk4_LayoutManagerClass_measure)
	}

	if overrides.Root != nil {
		pclass.root = (*[0]byte)(C._gotk4_gtk4_LayoutManagerClass_root)
	}

	if overrides.Unroot != nil {
		pclass.unroot = (*[0]byte)(C._gotk4_gtk4_LayoutManagerClass_unroot)
	}

	if classInitFunc != nil {
		class := (*LayoutManagerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapLayoutManager(obj *coreglib.Object) *LayoutManager {
	return &LayoutManager{
		Object: obj,
	}
}

func marshalLayoutManager(p uintptr) (interface{}, error) {
	return wrapLayoutManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (manager *LayoutManager) baseLayoutManager() *LayoutManager {
	return manager
}

// BaseLayoutManager returns the underlying base object.
func BaseLayoutManager(obj LayoutManagerer) *LayoutManager {
	return obj.baseLayoutManager()
}

// Allocate assigns the given width, height, and baseline to a widget,
// and computes the position and sizes of the children of the widget using the
// layout management policy of manager.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget using manager.
//   - width: new width of the widget.
//   - height: new height of the widget.
//   - baseline position of the widget, or -1.
func (manager *LayoutManager) Allocate(widget Widgetter, width, height, baseline int) {
	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // out

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.int(width)
	_arg3 = C.int(height)
	_arg4 = C.int(baseline)

	C.gtk_layout_manager_allocate(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(baseline)
}

// LayoutChild retrieves a GtkLayoutChild instance for the GtkLayoutManager,
// creating one if necessary.
//
// The child widget must be a child of the widget using manager.
//
// The GtkLayoutChild instance is owned by the GtkLayoutManager, and is
// guaranteed to exist as long as child is a child of the GtkWidget using the
// given GtkLayoutManager.
//
// The function takes the following parameters:
//
//   - child: GtkWidget.
//
// The function returns the following values:
//
//   - layoutChild: GtkLayoutChild.
func (manager *LayoutManager) LayoutChild(child Widgetter) LayoutChilder {
	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _cret *C.GtkLayoutChild   // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_layout_manager_get_layout_child(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(child)

	var _layoutChild LayoutChilder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.LayoutChilder is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(LayoutChilder)
			return ok
		})
		rv, ok := casted.(LayoutChilder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.LayoutChilder")
		}
		_layoutChild = rv
	}

	return _layoutChild
}

// RequestMode retrieves the request mode of manager.
//
// The function returns the following values:
//
//   - sizeRequestMode: GtkSizeRequestMode.
func (manager *LayoutManager) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkLayoutManager  // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_layout_manager_get_request_mode(_arg0)
	runtime.KeepAlive(manager)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Widget retrieves the GtkWidget using the given GtkLayoutManager.
//
// The function returns the following values:
//
//   - widget (optional): GtkWidget.
func (manager *LayoutManager) Widget() Widgetter {
	var _arg0 *C.GtkLayoutManager // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_layout_manager_get_widget(_arg0)
	runtime.KeepAlive(manager)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// LayoutChanged queues a resize on the GtkWidget using manager, if any.
//
// This function should be called by subclasses of GtkLayoutManager in response
// to changes to their layout management policies.
func (manager *LayoutManager) LayoutChanged() {
	var _arg0 *C.GtkLayoutManager // out

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C.gtk_layout_manager_layout_changed(_arg0)
	runtime.KeepAlive(manager)
}

// Measure measures the size of the widget using manager, for the given
// orientation and size.
//
// See the gtk.Widget documentation on layout management for more details.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget using manager.
//   - orientation to measure.
//   - forSize: size for the opposite of orientation; for instance, if the
//     orientation is GTK_ORIENTATION_HORIZONTAL, this is the height of the
//     widget; if the orientation is GTK_ORIENTATION_VERTICAL, this is the width
//     of the widget. This allows to measure the height for the given width,
//     and the width for the given height. Use -1 if the size is not known.
//
// The function returns the following values:
//
//   - minimum (optional) size for the given size and orientation.
//   - natural (optional): natural, or preferred size for the given size and
//     orientation.
//   - minimumBaseline (optional): baseline position for the minimum size.
//   - naturalBaseline (optional): baseline position for the natural size.
func (manager *LayoutManager) Measure(widget Widgetter, orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int) {
	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.GtkOrientation    // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in
	var _arg6 C.int               // in
	var _arg7 C.int               // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.GtkOrientation(orientation)
	_arg3 = C.int(forSize)

	C.gtk_layout_manager_measure(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(forSize)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = int(_arg4)
	_natural = int(_arg5)
	_minimumBaseline = int(_arg6)
	_naturalBaseline = int(_arg7)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

// Allocate assigns the given width, height, and baseline to a widget,
// and computes the position and sizes of the children of the widget using the
// layout management policy of manager.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget using manager.
//   - width: new width of the widget.
//   - height: new height of the widget.
//   - baseline position of the widget, or -1.
func (manager *LayoutManager) allocate(widget Widgetter, width, height, baseline int) {
	gclass := (*C.GtkLayoutManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.allocate

	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // out

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.int(width)
	_arg3 = C.int(height)
	_arg4 = C.int(baseline)

	C._gotk4_gtk4_LayoutManager_virtual_allocate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(baseline)
}

// createLayoutChild: create a LayoutChild instance for the given for_child
// widget.
//
// The function takes the following parameters:
//
//   - widget using the manager.
//   - forChild: child of widget.
//
// The function returns the following values:
//
//   - layoutChild: LayoutChild.
func (manager *LayoutManager) createLayoutChild(widget, forChild Widgetter) LayoutChilder {
	gclass := (*C.GtkLayoutManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.create_layout_child

	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 *C.GtkWidget        // out
	var _cret *C.GtkLayoutChild   // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(forChild).Native()))

	_cret = C._gotk4_gtk4_LayoutManager_virtual_create_layout_child(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(forChild)

	var _layoutChild LayoutChilder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.LayoutChilder is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(LayoutChilder)
			return ok
		})
		rv, ok := casted.(LayoutChilder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.LayoutChilder")
		}
		_layoutChild = rv
	}

	return _layoutChild
}

func (manager *LayoutManager) requestMode(widget Widgetter) SizeRequestMode {
	gclass := (*C.GtkLayoutManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.get_request_mode

	var _arg0 *C.GtkLayoutManager  // out
	var _arg1 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk4_LayoutManager_virtual_get_request_mode(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Measure measures the size of the widget using manager, for the given
// orientation and size.
//
// See the gtk.Widget documentation on layout management for more details.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget using manager.
//   - orientation to measure.
//   - forSize: size for the opposite of orientation; for instance, if the
//     orientation is GTK_ORIENTATION_HORIZONTAL, this is the height of the
//     widget; if the orientation is GTK_ORIENTATION_VERTICAL, this is the width
//     of the widget. This allows to measure the height for the given width,
//     and the width for the given height. Use -1 if the size is not known.
//
// The function returns the following values:
//
//   - minimum (optional) size for the given size and orientation.
//   - natural (optional): natural, or preferred size for the given size and
//     orientation.
//   - minimumBaseline (optional): baseline position for the minimum size.
//   - naturalBaseline (optional): baseline position for the natural size.
func (manager *LayoutManager) measure(widget Widgetter, orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int) {
	gclass := (*C.GtkLayoutManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.measure

	var _arg0 *C.GtkLayoutManager // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.GtkOrientation    // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in
	var _arg6 C.int               // in
	var _arg7 C.int               // in

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.GtkOrientation(orientation)
	_arg3 = C.int(forSize)

	C._gotk4_gtk4_LayoutManager_virtual_measure(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_arg7)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(forSize)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = int(_arg4)
	_natural = int(_arg5)
	_minimumBaseline = int(_arg6)
	_naturalBaseline = int(_arg7)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

func (manager *LayoutManager) root() {
	gclass := (*C.GtkLayoutManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.root

	var _arg0 *C.GtkLayoutManager // out

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C._gotk4_gtk4_LayoutManager_virtual_root(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(manager)
}

func (manager *LayoutManager) unroot() {
	gclass := (*C.GtkLayoutManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.unroot

	var _arg0 *C.GtkLayoutManager // out

	_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C._gotk4_gtk4_LayoutManager_virtual_unroot(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(manager)
}

// LevelBar: GtkLevelBar is a widget that can be used as a level indicator.
//
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
//
// !An example GtkLevelBar (levelbar.png)
//
// Use gtk.LevelBar.SetValue() to set the current value, and
// gtk.LevelBar.AddOffsetValue() to set the value offsets at which the bar will
// be considered in a different state. GTK will add a few offsets by default
// on the level bar: GTK_LEVEL_BAR_OFFSET_LOW, GTK_LEVEL_BAR_OFFSET_HIGH and
// GTK_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
//
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK will simply clamp them to the new
// range.
//
// Adding a custom offset on the bar
//
//	static GtkWidget *
//	create_level_bar (void)
//	{
//	  GtkWidget *widget;
//	  GtkLevelBar *bar;
//
//	  widget = gtk_level_bar_new ();
//	  bar = GTK_LEVEL_BAR (widget);
//
//	  // This changes the value of the default low offset
//
//	  gtk_level_bar_add_offset_value (bar,
//	                                  GTK_LEVEL_BAR_OFFSET_LOW,
//	                                  0.10);
//
//	  // This adds a new offset to the bar; the application will
//	  // be able to change its color CSS like this:
//	  //
//	  // levelbar block.my-offset {
//	  //   background-color: magenta;
//	  //   border-style: solid;
//	  //   border-color: black;
//	  //   border-style: 1px;
//	  // }
//
//	  gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);
//
//	  return widget;
//	}
//
// The default interval of values is between zero and one, but it’s
// possible to modify the interval using gtk.LevelBar.SetMinValue() and
// gtk.LevelBar.SetMaxValue(). The value will be always drawn in proportion to
// the admissible interval, i.e. a value of 15 with a specified interval between
// 10 and 20 is equivalent to a value of 0.5 with an interval between 0 and 1.
// When K_LEVEL_BAR_MODE_DISCRETE is used, the bar level is rendered as a finite
// number of separated blocks instead of a single one. The number of blocks that
// will be rendered is equal to the number of units specified by the admissible
// interval.
//
// For instance, to build a bar rendered with five blocks, it’s sufficient to
// set the minimum value to 0 and the maximum value to 5 after changing the
// indicator mode to discrete.
//
// # GtkLevelBar as GtkBuildable
//
// The GtkLevelBar implementation of the GtkBuildable interface supports a
// custom <offsets> element, which can contain any number of <offset> elements,
// each of which must have name and value attributes.
//
// CSS nodes
//
//	levelbar[.discrete]
//	╰── trough
//	    ├── block.filled.level-name
//	    ┊
//	    ├── block.empty
//	    ┊
//
// GtkLevelBar has a main CSS node with name levelbar and one of the
// style classes .discrete or .continuous and a subnode with name trough.
// Below the trough node are a number of nodes with name block and style class
// .filled or .empty. In continuous mode, there is exactly one node of each, in
// discrete mode, the number of filled and unfilled nodes corresponds to blocks
// that are drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
//
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
//
// # Accessibility
//
// GtkLevelBar uses the K_ACCESSIBLE_ROLE_METER role.
type LevelBar struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*LevelBar)(nil)
	_ coreglib.Objector = (*LevelBar)(nil)
)

func wrapLevelBar(obj *coreglib.Object) *LevelBar {
	return &LevelBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalLevelBar(p uintptr) (interface{}, error) {
	return wrapLevelBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectOffsetChanged is emitted when an offset specified on the bar changes
// value.
//
// This typically is the result of a gtk.LevelBar.AddOffsetValue() call.
//
// The signal supports detailed connections; you can connect to the detailed
// signal "changed::x" in order to only receive callbacks when the value of
// offset "x" changes.
func (self *LevelBar) ConnectOffsetChanged(f func(name string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "offset-changed", false, unsafe.Pointer(C._gotk4_gtk4_LevelBar_ConnectOffsetChanged), f)
}

// NewLevelBar creates a new GtkLevelBar.
//
// The function returns the following values:
//
//   - levelBar: GtkLevelBar.
func NewLevelBar() *LevelBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_level_bar_new()

	var _levelBar *LevelBar // out

	_levelBar = wrapLevelBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _levelBar
}

// NewLevelBarForInterval creates a new GtkLevelBar for the specified interval.
//
// The function takes the following parameters:
//
//   - minValue: positive value.
//   - maxValue: positive value.
//
// The function returns the following values:
//
//   - levelBar: GtkLevelBar.
func NewLevelBarForInterval(minValue, maxValue float64) *LevelBar {
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _cret *C.GtkWidget // in

	_arg1 = C.double(minValue)
	_arg2 = C.double(maxValue)

	_cret = C.gtk_level_bar_new_for_interval(_arg1, _arg2)
	runtime.KeepAlive(minValue)
	runtime.KeepAlive(maxValue)

	var _levelBar *LevelBar // out

	_levelBar = wrapLevelBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _levelBar
}

// AddOffsetValue adds a new offset marker on self at the position specified by
// value.
//
// When the bar value is in the interval topped by value (or between value and
// gtk.LevelBar:max-value in case the offset is the last one on the bar) a style
// class named level-name will be applied when rendering the level bar fill.
//
// If another offset marker named name exists, its value will be replaced by
// value.
//
// The function takes the following parameters:
//
//   - name of the new offset.
//   - value for the new offset.
func (self *LevelBar) AddOffsetValue(name string, value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.char        // out
	var _arg2 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(value)

	C.gtk_level_bar_add_offset_value(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
	runtime.KeepAlive(value)
}

// Inverted returns whether the levelbar is inverted.
//
// The function returns the following values:
//
//   - ok: TRUE if the level bar is inverted.
func (self *LevelBar) Inverted() bool {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_level_bar_get_inverted(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxValue returns the max-value of the GtkLevelBar.
//
// The function returns the following values:
//
//   - gdouble: positive value.
func (self *LevelBar) MaxValue() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.double       // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_level_bar_get_max_value(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// MinValue returns the min-value of the GtkLevelBar`.
//
// The function returns the following values:
//
//   - gdouble: positive value.
func (self *LevelBar) MinValue() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.double       // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_level_bar_get_min_value(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Mode returns the mode of the GtkLevelBar.
//
// The function returns the following values:
//
//   - levelBarMode: GtkLevelBarMode.
func (self *LevelBar) Mode() LevelBarMode {
	var _arg0 *C.GtkLevelBar    // out
	var _cret C.GtkLevelBarMode // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_level_bar_get_mode(_arg0)
	runtime.KeepAlive(self)

	var _levelBarMode LevelBarMode // out

	_levelBarMode = LevelBarMode(_cret)

	return _levelBarMode
}

// OffsetValue fetches the value specified for the offset marker name in self.
//
// The function takes the following parameters:
//
//   - name (optional) of an offset in the bar.
//
// The function returns the following values:
//
//   - value: location where to store the value.
//   - ok: TRUE if the specified offset is found.
func (self *LevelBar) OffsetValue(name string) (float64, bool) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.char        // out
	var _arg2 C.double       // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_level_bar_get_offset_value(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)

	var _value float64 // out
	var _ok bool       // out

	_value = float64(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Value returns the value of the GtkLevelBar.
//
// The function returns the following values:
//
//   - gdouble: value in the interval between GtkLevelBar:min-value and
//     GtkLevelBar:max-value.
func (self *LevelBar) Value() float64 {
	var _arg0 *C.GtkLevelBar // out
	var _cret C.double       // in

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_level_bar_get_value(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// RemoveOffsetValue removes an offset marker from a GtkLevelBar.
//
// The marker must have been previously added with
// gtk.LevelBar.AddOffsetValue().
//
// The function takes the following parameters:
//
//   - name (optional) of an offset in the bar.
func (self *LevelBar) RemoveOffsetValue(name string) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_level_bar_remove_offset_value(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(name)
}

// SetInverted sets whether the GtkLevelBar is inverted.
//
// The function takes the following parameters:
//
//   - inverted: TRUE to invert the level bar.
func (self *LevelBar) SetInverted(inverted bool) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if inverted {
		_arg1 = C.TRUE
	}

	C.gtk_level_bar_set_inverted(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(inverted)
}

// SetMaxValue sets the max-value of the GtkLevelBar.
//
// You probably want to update preexisting level offsets after calling this
// function.
//
// The function takes the following parameters:
//
//   - value: positive value.
func (self *LevelBar) SetMaxValue(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.double(value)

	C.gtk_level_bar_set_max_value(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)
}

// SetMinValue sets the min-value of the GtkLevelBar.
//
// You probably want to update preexisting level offsets after calling this
// function.
//
// The function takes the following parameters:
//
//   - value: positive value.
func (self *LevelBar) SetMinValue(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.double(value)

	C.gtk_level_bar_set_min_value(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)
}

// SetMode sets the mode of the GtkLevelBar.
//
// The function takes the following parameters:
//
//   - mode: GtkLevelBarMode.
func (self *LevelBar) SetMode(mode LevelBarMode) {
	var _arg0 *C.GtkLevelBar    // out
	var _arg1 C.GtkLevelBarMode // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkLevelBarMode(mode)

	C.gtk_level_bar_set_mode(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(mode)
}

// SetValue sets the value of the GtkLevelBar.
//
// The function takes the following parameters:
//
//   - value in the interval between gtk.LevelBar:min-value and
//     gtk.LevelBar:max-value.
func (self *LevelBar) SetValue(value float64) {
	var _arg0 *C.GtkLevelBar // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.double(value)

	C.gtk_level_bar_set_value(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)
}

// LinkButton: GtkLinkButton is a button with a hyperlink.
//
// !An example GtkLinkButton (link-button.png)
//
// It is useful to show quick links to resources.
//
// A link button is created by calling either gtk.LinkButton.New or
// gtk.LinkButton.NewWithLabel. If using the former, the URI you pass to the
// constructor is used as a label for the widget.
//
// The URI bound to a GtkLinkButton can be set specifically using
// gtk.LinkButton.SetURI().
//
// By default, GtkLinkButton calls gtk.ShowURI() when the button is
// clicked. This behaviour can be overridden by connecting to the
// gtk.LinkButton::activate-link signal and returning TRUE from the signal
// handler.
//
// # CSS nodes
//
// GtkLinkButton has a single CSS node with name button. To differentiate it
// from a plain GtkButton, it gets the .link style class.
//
// # Accessibility
//
// GtkLinkButton uses the K_ACCESSIBLE_ROLE_LINK role.
type LinkButton struct {
	_ [0]func() // equal guard
	Button
}

var (
	_ Widgetter         = (*LinkButton)(nil)
	_ coreglib.Objector = (*LinkButton)(nil)
)

func wrapLinkButton(obj *coreglib.Object) *LinkButton {
	return &LinkButton{
		Button: Button{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Actionable: Actionable{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalLinkButton(p uintptr) (interface{}, error) {
	return wrapLinkButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateLink is emitted each time the GtkLinkButton is clicked.
//
// The default handler will call gtk.ShowURI() with the URI stored inside the
// gtk.LinkButton:uri property.
//
// To override the default behavior, you can connect to the ::activate-link
// signal and stop the propagation of the signal by returning TRUE from your
// handler.
func (linkButton *LinkButton) ConnectActivateLink(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(linkButton, "activate-link", false, unsafe.Pointer(C._gotk4_gtk4_LinkButton_ConnectActivateLink), f)
}

// NewLinkButton creates a new GtkLinkButton with the URI as its text.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - linkButton: new link button widget.
func NewLinkButton(uri string) *LinkButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_link_button_new(_arg1)
	runtime.KeepAlive(uri)

	var _linkButton *LinkButton // out

	_linkButton = wrapLinkButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _linkButton
}

// NewLinkButtonWithLabel creates a new GtkLinkButton containing a label.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - label (optional): text of the button.
//
// The function returns the following values:
//
//   - linkButton: new link button widget.
func NewLinkButtonWithLabel(uri, label string) *LinkButton {
	var _arg1 *C.char      // out
	var _arg2 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if label != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_link_button_new_with_label(_arg1, _arg2)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(label)

	var _linkButton *LinkButton // out

	_linkButton = wrapLinkButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _linkButton
}

// URI retrieves the URI of the GtkLinkButton.
//
// The function returns the following values:
//
//   - utf8: valid URI. The returned string is owned by the link button and
//     should not be modified or freed.
func (linkButton *LinkButton) URI() string {
	var _arg0 *C.GtkLinkButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(coreglib.InternObject(linkButton).Native()))

	_cret = C.gtk_link_button_get_uri(_arg0)
	runtime.KeepAlive(linkButton)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Visited retrieves the “visited” state of the GtkLinkButton.
//
// The button becomes visited when it is clicked. If the URI is changed on the
// button, the “visited” state is unset again.
//
// The state may also be changed using gtk.LinkButton.SetVisited().
//
// The function returns the following values:
//
//   - ok: TRUE if the link has been visited, FALSE otherwise.
func (linkButton *LinkButton) Visited() bool {
	var _arg0 *C.GtkLinkButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(coreglib.InternObject(linkButton).Native()))

	_cret = C.gtk_link_button_get_visited(_arg0)
	runtime.KeepAlive(linkButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetURI sets uri as the URI where the GtkLinkButton points.
//
// As a side-effect this unsets the “visited” state of the button.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
func (linkButton *LinkButton) SetURI(uri string) {
	var _arg0 *C.GtkLinkButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(coreglib.InternObject(linkButton).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_link_button_set_uri(_arg0, _arg1)
	runtime.KeepAlive(linkButton)
	runtime.KeepAlive(uri)
}

// SetVisited sets the “visited” state of the GtkLinkButton.
//
// See gtk.LinkButton.GetVisited() for more details.
//
// The function takes the following parameters:
//
//   - visited: new “visited” state.
func (linkButton *LinkButton) SetVisited(visited bool) {
	var _arg0 *C.GtkLinkButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(coreglib.InternObject(linkButton).Native()))
	if visited {
		_arg1 = C.TRUE
	}

	C.gtk_link_button_set_visited(_arg0, _arg1)
	runtime.KeepAlive(linkButton)
	runtime.KeepAlive(visited)
}

// ListBase: GtkListBase is the abstract base class for GTK's list widgets.
type ListBase struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
	Scrollable
}

var (
	_ Widgetter         = (*ListBase)(nil)
	_ coreglib.Objector = (*ListBase)(nil)
)

// ListBaser describes types inherited from class ListBase.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type ListBaser interface {
	coreglib.Objector
	baseListBase() *ListBase
}

var _ ListBaser = (*ListBase)(nil)

func wrapListBase(obj *coreglib.Object) *ListBase {
	return &ListBase{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalListBase(p uintptr) (interface{}, error) {
	return wrapListBase(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *ListBase) baseListBase() *ListBase {
	return v
}

// BaseListBase returns the underlying base object.
func BaseListBase(obj ListBaser) *ListBase {
	return obj.baseListBase()
}

// ListBox: GtkListBox is a vertical list.
//
// A GtkListBox only contains GtkListBoxRow children. These rows can by
// dynamically sorted and filtered, and headers can be added dynamically
// depending on the row content. It also allows keyboard and mouse navigation
// and selection like a typical list.
//
// Using GtkListBox is often an alternative to GtkTreeView, especially when
// the list contents has a more complicated layout than what is allowed by a
// GtkCellRenderer, or when the contents is interactive (i.e. has a button in
// it).
//
// Although a GtkListBox must have only GtkListBoxRow children, you can add
// any kind of widget to it via gtk.ListBox.Prepend(), gtk.ListBox.Append()
// and gtk.ListBox.Insert() and a GtkListBoxRow widget will automatically be
// inserted between the list and the widget.
//
// GtkListBoxRows can be marked as activatable or selectable. If a row is
// activatable, gtk.ListBox::row-activated will be emitted for it when the user
// tries to activate it. If it is selectable, the row will be marked as selected
// when the user tries to select it.
//
// # GtkListBox as GtkBuildable
//
// The GtkListBox implementation of the GtkBuildable interface supports
// setting a child as the placeholder by specifying “placeholder” as the “type”
// attribute of a <child> element. See gtk.ListBox.SetPlaceholder() for info.
//
// CSS nodes
//
//	list[.separators][.rich-list][.navigation-sidebar]
//	╰── row[.activatable]
//
// GtkListBox uses a single CSS node named list. It may carry the .separators
// style class, when the gtk.ListBox:show-separators property is set.
// Each GtkListBoxRow uses a single CSS node named row. The row nodes get the
// .activatable style class added when appropriate.
//
// The main list node may also carry style classes to select the style of
// list presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
// # Accessibility
//
// GtkListBox uses the GTK_ACCESSIBLE_ROLE_LIST role and GtkListBoxRow uses the
// GTK_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListBox struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*ListBox)(nil)
)

func wrapListBox(obj *coreglib.Object) *ListBox {
	return &ListBox{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalListBox(p uintptr) (interface{}, error) {
	return wrapListBox(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (box *ListBox) ConnectActivateCursorRow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "activate-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectActivateCursorRow), f)
}

func (box *ListBox) ConnectMoveCursor(f func(object MovementStep, p0 int, p1, p2 bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectMoveCursor), f)
}

// ConnectRowActivated is emitted when a row has been activated by the user.
func (box *ListBox) ConnectRowActivated(f func(row *ListBoxRow)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "row-activated", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectRowActivated), f)
}

// ConnectRowSelected is emitted when a new row is selected, or (with a NULL
// row) when the selection is cleared.
//
// When the box is using GTK_SELECTION_MULTIPLE, this signal will not
// give you the full picture of selection changes, and you should use the
// gtk.ListBox::selected-rows-changed signal instead.
func (box *ListBox) ConnectRowSelected(f func(row *ListBoxRow)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "row-selected", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectRowSelected), f)
}

// ConnectSelectAll is emitted to select all children of the box, if the
// selection mode permits it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is <kbd>Ctrl</kbd>-<kbd>a</kbd>.
func (box *ListBox) ConnectSelectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectSelectAll), f)
}

// ConnectSelectedRowsChanged is emitted when the set of selected rows changes.
func (box *ListBox) ConnectSelectedRowsChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "selected-rows-changed", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectSelectedRowsChanged), f)
}

func (box *ListBox) ConnectToggleCursorRow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "toggle-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectToggleCursorRow), f)
}

// ConnectUnselectAll is emitted to unselect all children of the box, if the
// selection mode permits it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is
// <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>a</kbd>.
func (box *ListBox) ConnectUnselectAll(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(box, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk4_ListBox_ConnectUnselectAll), f)
}

// NewListBox creates a new GtkListBox container.
//
// The function returns the following values:
//
//   - listBox: new GtkListBox.
func NewListBox() *ListBox {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_list_box_new()

	var _listBox *ListBox // out

	_listBox = wrapListBox(coreglib.Take(unsafe.Pointer(_cret)))

	return _listBox
}

// Append a widget to the list.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to add.
func (box *ListBox) Append(child Widgetter) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_list_box_append(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// BindModel binds model to box.
//
// If box was already bound to a model, that previous binding is destroyed.
//
// The contents of box are cleared and then filled with widgets that represent
// items from model. box is updated whenever model changes. If model is NULL,
// box is left empty.
//
// It is undefined to add or remove widgets directly (for example, with
// gtk.ListBox.Insert()) while box is bound to a model.
//
// Note that using a model is incompatible with the filtering and sorting
// functionality in GtkListBox. When using a model, filtering and sorting should
// be implemented by the model.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to be bound to box.
//   - createWidgetFunc (optional): function that creates widgets for items or
//     NULL in case you also passed NULL as model.
func (box *ListBox) BindModel(model gio.ListModeller, createWidgetFunc ListBoxCreateWidgetFunc) {
	var _arg0 *C.GtkListBox                // out
	var _arg1 *C.GListModel                // out
	var _arg2 C.GtkListBoxCreateWidgetFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}
	if createWidgetFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_gtk4_ListBoxCreateWidgetFunc)
		_arg3 = C.gpointer(gbox.Assign(createWidgetFunc))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_list_box_bind_model(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(box)
	runtime.KeepAlive(model)
	runtime.KeepAlive(createWidgetFunc)
}

// DragHighlightRow: add a drag highlight to a row.
//
// This is a helper function for implementing DnD onto a GtkListBox. The passed
// in row will be highlighted by setting the GTK_STATE_FLAG_DROP_ACTIVE state
// and any previously highlighted row will be unhighlighted.
//
// The row will also be unhighlighted when the widget gets a drag leave event.
//
// The function takes the following parameters:
//
//   - row: GtkListBoxRow.
func (box *ListBox) DragHighlightRow(row *ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	C.gtk_list_box_drag_highlight_row(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(row)
}

// DragUnhighlightRow: if a row has previously been highlighted via
// gtk_list_box_drag_highlight_row(), it will have the highlight removed.
func (box *ListBox) DragUnhighlightRow() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_list_box_drag_unhighlight_row(_arg0)
	runtime.KeepAlive(box)
}

// ActivateOnSingleClick returns whether rows activate on single clicks.
//
// The function returns the following values:
//
//   - ok: TRUE if rows are activated on single click, FALSE otherwise.
func (box *ListBox) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkListBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_list_box_get_activate_on_single_click(_arg0)
	runtime.KeepAlive(box)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Adjustment gets the adjustment (if any) that the widget uses to for vertical
// scrolling.
//
// The function returns the following values:
//
//   - adjustment: adjustment.
func (box *ListBox) Adjustment() *Adjustment {
	var _arg0 *C.GtkListBox    // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_list_box_get_adjustment(_arg0)
	runtime.KeepAlive(box)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// RowAtIndex gets the n-th child in the list (not counting headers).
//
// If index_ is negative or larger than the number of items in the list,
// NULL is returned.
//
// The function takes the following parameters:
//
//   - index_: index of the row.
//
// The function returns the following values:
//
//   - listBoxRow (optional): child GtkWidget or NULL.
func (box *ListBox) RowAtIndex(index_ int) *ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _arg1 C.int            // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.int(index_)

	_cret = C.gtk_list_box_get_row_at_index(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(index_)

	var _listBoxRow *ListBoxRow // out

	if _cret != nil {
		_listBoxRow = wrapListBoxRow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listBoxRow
}

// RowAtY gets the row at the y position.
//
// The function takes the following parameters:
//
//   - y: position.
//
// The function returns the following values:
//
//   - listBoxRow (optional): row or NULL in case no row exists for the given y
//     coordinate.
func (box *ListBox) RowAtY(y int) *ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _arg1 C.int            // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.int(y)

	_cret = C.gtk_list_box_get_row_at_y(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(y)

	var _listBoxRow *ListBoxRow // out

	if _cret != nil {
		_listBoxRow = wrapListBoxRow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listBoxRow
}

// SelectedRow gets the selected row, or NULL if no rows are selected.
//
// Note that the box may allow multiple selection, in which case you should use
// gtk.ListBox.SelectedForEach() to find all selected rows.
//
// The function returns the following values:
//
//   - listBoxRow (optional): selected row or NULL.
func (box *ListBox) SelectedRow() *ListBoxRow {
	var _arg0 *C.GtkListBox    // out
	var _cret *C.GtkListBoxRow // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_list_box_get_selected_row(_arg0)
	runtime.KeepAlive(box)

	var _listBoxRow *ListBoxRow // out

	if _cret != nil {
		_listBoxRow = wrapListBoxRow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listBoxRow
}

// SelectedRows creates a list of all selected children.
//
// The function returns the following values:
//
//   - list: A GList containing the GtkWidget for each selected child. Free with
//     g_list_free() when done.
func (box *ListBox) SelectedRows() []*ListBoxRow {
	var _arg0 *C.GtkListBox // out
	var _cret *C.GList      // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_list_box_get_selected_rows(_arg0)
	runtime.KeepAlive(box)

	var _list []*ListBoxRow // out

	_list = make([]*ListBoxRow, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkListBoxRow)(v)
		var dst *ListBoxRow // out
		dst = wrapListBoxRow(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// SelectionMode gets the selection mode of the listbox.
//
// The function returns the following values:
//
//   - selectionMode: GtkSelectionMode.
func (box *ListBox) SelectionMode() SelectionMode {
	var _arg0 *C.GtkListBox      // out
	var _cret C.GtkSelectionMode // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_list_box_get_selection_mode(_arg0)
	runtime.KeepAlive(box)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// ShowSeparators returns whether the list box should show separators between
// rows.
//
// The function returns the following values:
//
//   - ok: TRUE if the list box shows separators.
func (box *ListBox) ShowSeparators() bool {
	var _arg0 *C.GtkListBox // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	_cret = C.gtk_list_box_get_show_separators(_arg0)
	runtime.KeepAlive(box)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Insert the child into the box at position.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// If position is -1, or larger than the total number of items in the box,
// then the child will be appended to the end.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to add.
//   - position to insert child in.
func (box *ListBox) Insert(child Widgetter, position int) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(position)

	C.gtk_list_box_insert(_arg0, _arg1, _arg2)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)
}

// InvalidateFilter: update the filtering for all rows.
//
// Call this when result of the filter function on the box is changed due to an
// external factor. For instance, this would be used if the filter function just
// looked for a specific search string and the entry with the search string has
// changed.
func (box *ListBox) InvalidateFilter() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_list_box_invalidate_filter(_arg0)
	runtime.KeepAlive(box)
}

// InvalidateHeaders: update the separators for all rows.
//
// Call this when result of the header function on the box is changed due to an
// external factor.
func (box *ListBox) InvalidateHeaders() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_list_box_invalidate_headers(_arg0)
	runtime.KeepAlive(box)
}

// InvalidateSort: update the sorting for all rows.
//
// Call this when result of the sort function on the box is changed due to an
// external factor.
func (box *ListBox) InvalidateSort() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_list_box_invalidate_sort(_arg0)
	runtime.KeepAlive(box)
}

// Prepend a widget to the list.
//
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to add.
func (box *ListBox) Prepend(child Widgetter) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_list_box_prepend(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// Remove removes a child from box.
//
// The function takes the following parameters:
//
//   - child to remove.
func (box *ListBox) Remove(child Widgetter) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_list_box_remove(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(child)
}

// SelectAll: select all children of box, if the selection mode allows it.
func (box *ListBox) SelectAll() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_list_box_select_all(_arg0)
	runtime.KeepAlive(box)
}

// SelectRow: make row the currently selected row.
//
// The function takes the following parameters:
//
//   - row (optional) to select or NULL.
func (box *ListBox) SelectRow(row *ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if row != nil {
		_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))
	}

	C.gtk_list_box_select_row(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(row)
}

// SelectedForEach calls a function for each selected child.
//
// Note that the selection cannot be modified from within this function.
//
// The function takes the following parameters:
//
//   - fn: function to call for each selected child.
func (box *ListBox) SelectedForEach(fn ListBoxForEachFunc) {
	var _arg0 *C.GtkListBox           // out
	var _arg1 C.GtkListBoxForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_ListBoxForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_list_box_selected_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(box)
	runtime.KeepAlive(fn)
}

// SetActivateOnSingleClick: if single is TRUE, rows will be activated when you
// click on them, otherwise you need to double-click.
//
// The function takes the following parameters:
//
//   - single: boolean.
func (box *ListBox) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkListBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_set_activate_on_single_click(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(single)
}

// SetAdjustment sets the adjustment (if any) that the widget uses to for
// vertical scrolling.
//
// For instance, this is used to get the page size for PageUp/Down key handling.
//
// In the normal case when the box is packed inside a GtkScrolledWindow the
// adjustment from that will be picked up automatically, so there is no need to
// manually do that.
//
// The function takes the following parameters:
//
//   - adjustment (optional): adjustment, or NULL.
func (box *ListBox) SetAdjustment(adjustment *Adjustment) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if adjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}

	C.gtk_list_box_set_adjustment(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(adjustment)
}

// SetFilterFunc: by setting a filter function on the box one can decide
// dynamically which of the rows to show.
//
// For instance, to implement a search function on a list that filters the
// original list to only show the matching rows.
//
// The filter_func will be called for each row after the call, and it will
// continue to be called each time a row changes (via gtk.ListBoxRow.Changed())
// or when gtk.ListBox.InvalidateFilter() is called.
//
// Note that using a filter function is incompatible with using a model (see
// gtk.ListBox.BindModel()).
//
// The function takes the following parameters:
//
//   - filterFunc (optional): callback that lets you filter which rows to show.
func (box *ListBox) SetFilterFunc(filterFunc ListBoxFilterFunc) {
	var _arg0 *C.GtkListBox          // out
	var _arg1 C.GtkListBoxFilterFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if filterFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_ListBoxFilterFunc)
		_arg2 = C.gpointer(gbox.Assign(filterFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_list_box_set_filter_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(box)
	runtime.KeepAlive(filterFunc)
}

// SetHeaderFunc sets a header function.
//
// By setting a header function on the box one can dynamically add headers in
// front of rows, depending on the contents of the row and its position in the
// list.
//
// For instance, one could use it to add headers in front of the first item of a
// new kind, in a list sorted by the kind.
//
// The update_header can look at the current header widget using
// gtk.ListBoxRow.GetHeader() and either update the state of the widget as
// needed, or set a new one using gtk.ListBoxRow.SetHeader(). If no header is
// needed, set the header to NULL.
//
// Note that you may get many calls update_header to this for a particular row
// when e.g. changing things that don’t affect the header. In this case it is
// important for performance to not blindly replace an existing header with an
// identical one.
//
// The update_header function will be called for each row after the call,
// and it will continue to be called each time a row changes (via
// gtk.ListBoxRow.Changed()) and when the row before changes (either by
// gtk.ListBoxRow.Changed() on the previous row, or when the previous
// row becomes a different row). It is also called for all rows when
// gtk.ListBox.InvalidateHeaders() is called.
//
// The function takes the following parameters:
//
//   - updateHeader (optional): callback that lets you add row headers.
func (box *ListBox) SetHeaderFunc(updateHeader ListBoxUpdateHeaderFunc) {
	var _arg0 *C.GtkListBox                // out
	var _arg1 C.GtkListBoxUpdateHeaderFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if updateHeader != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_ListBoxUpdateHeaderFunc)
		_arg2 = C.gpointer(gbox.Assign(updateHeader))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_list_box_set_header_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(box)
	runtime.KeepAlive(updateHeader)
}

// SetPlaceholder sets the placeholder widget that is shown in the list when it
// doesn't display any visible children.
//
// The function takes the following parameters:
//
//   - placeholder (optional) or NULL.
func (box *ListBox) SetPlaceholder(placeholder Widgetter) {
	var _arg0 *C.GtkListBox // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if placeholder != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(placeholder).Native()))
	}

	C.gtk_list_box_set_placeholder(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(placeholder)
}

// SetSelectionMode sets how selection works in the listbox.
//
// The function takes the following parameters:
//
//   - mode: GtkSelectionMode.
func (box *ListBox) SetSelectionMode(mode SelectionMode) {
	var _arg0 *C.GtkListBox      // out
	var _arg1 C.GtkSelectionMode // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = C.GtkSelectionMode(mode)

	C.gtk_list_box_set_selection_mode(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(mode)
}

// SetShowSeparators sets whether the list box should show separators between
// rows.
//
// The function takes the following parameters:
//
//   - showSeparators: TRUE to show separators.
func (box *ListBox) SetShowSeparators(showSeparators bool) {
	var _arg0 *C.GtkListBox // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if showSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_set_show_separators(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(showSeparators)
}

// SetSortFunc sets a sort function.
//
// By setting a sort function on the box one can dynamically reorder the rows of
// the list, based on the contents of the rows.
//
// The sort_func will be called for each row after the call, and will continue
// to be called each time a row changes (via gtk.ListBoxRow.Changed()) and when
// gtk.ListBox.InvalidateSort() is called.
//
// Note that using a sort function is incompatible with using a model (see
// gtk.ListBox.BindModel()).
//
// The function takes the following parameters:
//
//   - sortFunc (optional): sort function.
func (box *ListBox) SetSortFunc(sortFunc ListBoxSortFunc) {
	var _arg0 *C.GtkListBox        // out
	var _arg1 C.GtkListBoxSortFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	if sortFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_ListBoxSortFunc)
		_arg2 = C.gpointer(gbox.Assign(sortFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_list_box_set_sort_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(box)
	runtime.KeepAlive(sortFunc)
}

// UnselectAll: unselect all children of box, if the selection mode allows it.
func (box *ListBox) UnselectAll() {
	var _arg0 *C.GtkListBox // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))

	C.gtk_list_box_unselect_all(_arg0)
	runtime.KeepAlive(box)
}

// UnselectRow unselects a single row of box, if the selection mode allows it.
//
// The function takes the following parameters:
//
//   - row to unselected.
func (box *ListBox) UnselectRow(row *ListBoxRow) {
	var _arg0 *C.GtkListBox    // out
	var _arg1 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBox)(unsafe.Pointer(coreglib.InternObject(box).Native()))
	_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	C.gtk_list_box_unselect_row(_arg0, _arg1)
	runtime.KeepAlive(box)
	runtime.KeepAlive(row)
}

// ListBoxRowOverrides contains methods that are overridable.
type ListBoxRowOverrides struct {
	Activate func()
}

func defaultListBoxRowOverrides(v *ListBoxRow) ListBoxRowOverrides {
	return ListBoxRowOverrides{
		Activate: v.activate,
	}
}

// ListBoxRow: GtkListBoxRow is the kind of widget that can be added to a
// GtkListBox.
type ListBoxRow struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Actionable
}

var (
	_ Widgetter         = (*ListBoxRow)(nil)
	_ coreglib.Objector = (*ListBoxRow)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ListBoxRow, *ListBoxRowClass, ListBoxRowOverrides](
		GTypeListBoxRow,
		initListBoxRowClass,
		wrapListBoxRow,
		defaultListBoxRowOverrides,
	)
}

func initListBoxRowClass(gclass unsafe.Pointer, overrides ListBoxRowOverrides, classInitFunc func(*ListBoxRowClass)) {
	pclass := (*C.GtkListBoxRowClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeListBoxRow))))

	if overrides.Activate != nil {
		pclass.activate = (*[0]byte)(C._gotk4_gtk4_ListBoxRowClass_activate)
	}

	if classInitFunc != nil {
		class := (*ListBoxRowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapListBoxRow(obj *coreglib.Object) *ListBoxRow {
	return &ListBoxRow{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Actionable: Actionable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalListBoxRow(p uintptr) (interface{}, error) {
	return wrapListBoxRow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate: this is a keybinding signal, which will cause this row to be
// activated.
//
// If you want to be notified when the user activates a row (by key or not),
// use the gtk.ListBox::row-activated signal on the row’s parent GtkListBox.
func (row *ListBoxRow) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(row, "activate", false, unsafe.Pointer(C._gotk4_gtk4_ListBoxRow_ConnectActivate), f)
}

// NewListBoxRow creates a new GtkListBoxRow.
//
// The function returns the following values:
//
//   - listBoxRow: new GtkListBoxRow.
func NewListBoxRow() *ListBoxRow {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_list_box_row_new()

	var _listBoxRow *ListBoxRow // out

	_listBoxRow = wrapListBoxRow(coreglib.Take(unsafe.Pointer(_cret)))

	return _listBoxRow
}

// Changed marks row as changed, causing any state that depends on this to be
// updated.
//
// This affects sorting, filtering and headers.
//
// Note that calls to this method must be in sync with the data used for the row
// functions. For instance, if the list is mirroring some external data set,
// and *two* rows changed in the external data set then when you call
// gtk_list_box_row_changed() on the first row the sort function must only read
// the new data for the first of the two changed rows, otherwise the resorting
// of the rows will be wrong.
//
// This generally means that if you don’t fully control the data model
// you have to duplicate the data that affects the listbox row functions
// into the row widgets themselves. Another alternative is to call
// gtk.ListBox.InvalidateSort() on any model change, but that is more expensive.
func (row *ListBoxRow) Changed() {
	var _arg0 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	C.gtk_list_box_row_changed(_arg0)
	runtime.KeepAlive(row)
}

// Activatable gets whether the row is activatable.
//
// The function returns the following values:
//
//   - ok: TRUE if the row is activatable.
func (row *ListBoxRow) Activatable() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	_cret = C.gtk_list_box_row_get_activatable(_arg0)
	runtime.KeepAlive(row)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Child gets the child widget of row.
//
// The function returns the following values:
//
//   - widget (optional): child widget of row.
func (row *ListBoxRow) Child() Widgetter {
	var _arg0 *C.GtkListBoxRow // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	_cret = C.gtk_list_box_row_get_child(_arg0)
	runtime.KeepAlive(row)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Header returns the current header of the row.
//
// This can be used in a gtk.ListBoxUpdateHeaderFunc to see if there is a header
// set already, and if so to update the state of it.
//
// The function returns the following values:
//
//   - widget (optional): current header, or NULL if none.
func (row *ListBoxRow) Header() Widgetter {
	var _arg0 *C.GtkListBoxRow // out
	var _cret *C.GtkWidget     // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	_cret = C.gtk_list_box_row_get_header(_arg0)
	runtime.KeepAlive(row)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Index gets the current index of the row in its GtkListBox container.
//
// The function returns the following values:
//
//   - gint: index of the row, or -1 if the row is not in a listbox.
func (row *ListBoxRow) Index() int {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.int            // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	_cret = C.gtk_list_box_row_get_index(_arg0)
	runtime.KeepAlive(row)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Selectable gets whether the row can be selected.
//
// The function returns the following values:
//
//   - ok: TRUE if the row is selectable.
func (row *ListBoxRow) Selectable() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	_cret = C.gtk_list_box_row_get_selectable(_arg0)
	runtime.KeepAlive(row)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSelected returns whether the child is currently selected in its GtkListBox
// container.
//
// The function returns the following values:
//
//   - ok: TRUE if row is selected.
func (row *ListBoxRow) IsSelected() bool {
	var _arg0 *C.GtkListBoxRow // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	_cret = C.gtk_list_box_row_is_selected(_arg0)
	runtime.KeepAlive(row)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatable: set whether the row is activatable.
//
// The function takes the following parameters:
//
//   - activatable: TRUE to mark the row as activatable.
func (row *ListBoxRow) SetActivatable(activatable bool) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_row_set_activatable(_arg0, _arg1)
	runtime.KeepAlive(row)
	runtime.KeepAlive(activatable)
}

// SetChild sets the child widget of self.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (row *ListBoxRow) SetChild(child Widgetter) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_list_box_row_set_child(_arg0, _arg1)
	runtime.KeepAlive(row)
	runtime.KeepAlive(child)
}

// SetHeader sets the current header of the row.
//
// This is only allowed to be called from a gtk.ListBoxUpdateHeaderFunc.
// It will replace any existing header in the row, and be shown in front of the
// row in the listbox.
//
// The function takes the following parameters:
//
//   - header (optional): header, or NULL.
func (row *ListBoxRow) SetHeader(header Widgetter) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))
	if header != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(header).Native()))
	}

	C.gtk_list_box_row_set_header(_arg0, _arg1)
	runtime.KeepAlive(row)
	runtime.KeepAlive(header)
}

// SetSelectable: set whether the row can be selected.
//
// The function takes the following parameters:
//
//   - selectable: TRUE to mark the row as selectable.
func (row *ListBoxRow) SetSelectable(selectable bool) {
	var _arg0 *C.GtkListBoxRow // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))
	if selectable {
		_arg1 = C.TRUE
	}

	C.gtk_list_box_row_set_selectable(_arg0, _arg1)
	runtime.KeepAlive(row)
	runtime.KeepAlive(selectable)
}

func (row *ListBoxRow) activate() {
	gclass := (*C.GtkListBoxRowClass)(coreglib.PeekParentClass(row))
	fnarg := gclass.activate

	var _arg0 *C.GtkListBoxRow // out

	_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(coreglib.InternObject(row).Native()))

	C._gotk4_gtk4_ListBoxRow_virtual_activate(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(row)
}

// ListItem: GtkListItem is used by list widgets to represent items in a
// GListModel.
//
// The GtkListItems are managed by the list widget (with its factory) and cannot
// be created by applications, but they need to be populated by application
// code. This is done by calling gtk.ListItem.SetChild().
//
// GtkListItems exist in 2 stages:
//
// 1. The unbound stage where the listitem is not currently connected to an item
// in the list. In that case, the gtk.ListItem:item property is set to NULL.
//
// 2. The bound stage where the listitem references an item from the list.
// The gtk.ListItem:item property is not NULL.
type ListItem struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ListItem)(nil)
)

func wrapListItem(obj *coreglib.Object) *ListItem {
	return &ListItem{
		Object: obj,
	}
}

func marshalListItem(p uintptr) (interface{}, error) {
	return wrapListItem(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Activatable checks if a list item has been set to be activatable via
// gtk_list_item_set_activatable().
//
// The function returns the following values:
//
//   - ok: TRUE if the item is activatable.
func (self *ListItem) Activatable() bool {
	var _arg0 *C.GtkListItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_item_get_activatable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Child gets the child previously set via gtk_list_item_set_child() or NULL if
// none was set.
//
// The function returns the following values:
//
//   - widget (optional): child.
func (self *ListItem) Child() Widgetter {
	var _arg0 *C.GtkListItem // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_item_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Item gets the model item that associated with self.
//
// If self is unbound, this function returns NULL.
//
// The function returns the following values:
//
//   - object (optional): item displayed.
func (self *ListItem) Item() *coreglib.Object {
	var _arg0 *C.GtkListItem // out
	var _cret C.gpointer     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_item_get_item(_arg0)
	runtime.KeepAlive(self)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// Position gets the position in the model that self currently displays.
//
// If self is unbound, GTK_INVALID_LIST_POSITION is returned.
//
// The function returns the following values:
//
//   - guint: position of this item.
func (self *ListItem) Position() uint {
	var _arg0 *C.GtkListItem // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_item_get_position(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Selectable checks if a list item has been set to be selectable via
// gtk_list_item_set_selectable().
//
// Do not confuse this function with gtk.ListItem.GetSelected().
//
// The function returns the following values:
//
//   - ok: TRUE if the item is selectable.
func (self *ListItem) Selectable() bool {
	var _arg0 *C.GtkListItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_item_get_selectable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Selected checks if the item is displayed as selected.
//
// The selected state is maintained by the liste widget and its model and cannot
// be set otherwise.
//
// The function returns the following values:
//
//   - ok: TRUE if the item is selected.
func (self *ListItem) Selected() bool {
	var _arg0 *C.GtkListItem // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_item_get_selected(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatable sets self to be activatable.
//
// If an item is activatable, double-clicking on the item, using the Return key
// or calling gtk_widget_activate() will activate the item. Activating instructs
// the containing view to handle activation. GtkListView for example will be
// emitting the gtk.ListView::activate signal.
//
// By default, list items are activatable.
//
// The function takes the following parameters:
//
//   - activatable: if the item should be activatable.
func (self *ListItem) SetActivatable(activatable bool) {
	var _arg0 *C.GtkListItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if activatable {
		_arg1 = C.TRUE
	}

	C.gtk_list_item_set_activatable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(activatable)
}

// SetChild sets the child to be used for this listitem.
//
// This function is typically called by applications when setting up a listitem
// so that the widget can be reused when binding it multiple times.
//
// The function takes the following parameters:
//
//   - child (optional): list item's child or NULL to unset.
func (self *ListItem) SetChild(child Widgetter) {
	var _arg0 *C.GtkListItem // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_list_item_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// SetSelectable sets self to be selectable.
//
// If an item is selectable, clicking on the item or using the keyboard will
// try to select or unselect the item. If this succeeds is up to the model to
// determine, as it is managing the selected state.
//
// Note that this means that making an item non-selectable has no influence on
// the selected state at all. A non-selectable item may still be selected.
//
// By default, list items are selectable. When rebinding them to a new item,
// they will also be reset to be selectable by GTK.
//
// The function takes the following parameters:
//
//   - selectable: if the item should be selectable.
func (self *ListItem) SetSelectable(selectable bool) {
	var _arg0 *C.GtkListItem // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListItem)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if selectable {
		_arg1 = C.TRUE
	}

	C.gtk_list_item_set_selectable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(selectable)
}

// ListItemFactory: GtkListItemFactory creates widgets for the items taken from
// a GListModel.
//
// This is one of the core concepts of handling list widgets such as
// gtk.ListView or gtk.GridView.
//
// The GtkListItemFactory is tasked with creating widgets for items taken from
// the model when the views need them and updating them as the items displayed
// by the view change.
//
// A view is usually only able to display anything after both a factory and a
// model have been set on the view. So it is important that you do not skip this
// step when setting up your first view.
//
// Because views do not display the whole list at once but only a few items,
// they only need to maintain a few widgets at a time. They will instruct the
// GtkListItemFactory to create these widgets and bind them to the items that
// are currently displayed.
//
// As the list model changes or the user scrolls to the list, the items will
// change and the view will instruct the factory to bind the widgets to those
// new items.
//
// The actual widgets used for displaying those widgets is provided by you.
//
// When the factory needs widgets created, it will create a GtkListItem and
// hand it to your code to set up a widget for. This list item will provide
// various properties with information about what item to display and provide
// you with some opportunities to configure its behavior. See the gtk.ListItem
// documentation for further details.
//
// Various implementations of GtkListItemFactory exist to allow you different
// ways to provide those widgets. The most common implementations are
// gtk.BuilderListItemFactory which takes a GtkBuilder .ui file and then creates
// widgets and manages everything automatically from the information in that
// file and gtk.SignalListItemFactory which allows you to connect to signals
// with your own code and retain full control over how the widgets are setup and
// managed.
//
// A GtkListItemFactory is supposed to be final - that means its behavior should
// not change and the first widget created from it should behave the same way as
// the last widget created from it. If you intend to do changes to the behavior,
// it is recommended that you create a new GtkListItemFactory which will allow
// the views to recreate its widgets.
//
// Once you have chosen your factory and created it, you need to set it on the
// view widget you want to use it with, such as via gtk.ListView.SetFactory().
// Reusing factories across different views is allowed, but very uncommon.
type ListItemFactory struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ListItemFactory)(nil)
)

func wrapListItemFactory(obj *coreglib.Object) *ListItemFactory {
	return &ListItemFactory{
		Object: obj,
	}
}

func marshalListItemFactory(p uintptr) (interface{}, error) {
	return wrapListItemFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ListStoreOverrides contains methods that are overridable.
type ListStoreOverrides struct {
}

func defaultListStoreOverrides(v *ListStore) ListStoreOverrides {
	return ListStoreOverrides{}
}

// ListStore: list-like data structure that can be used with the GtkTreeView
//
// The ListStore object is a list model for use with a TreeView widget.
// It implements the TreeModel interface, and consequentialy, can use all of the
// methods available there. It also implements the TreeSortable interface so it
// can be sorted by the view. Finally, it also implements the tree [drag and
// drop][gtk4-GtkTreeView-drag-and-drop] interfaces.
//
// The ListStore can accept most GObject types as a column type, though it can’t
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Textures stored.
//
// An example for creating a simple list store:
//
//	<object class="GtkListStore">
//	  <columns>
//	    <column type="gchararray"/>
//	    <column type="gchararray"/>
//	    <column type="gint"/>
//	  </columns>
//	  <data>
//	    <row>
//	      <col id="0">John</col>
//	      <col id="1">Doe</col>
//	      <col id="2">25</col>
//	    </row>
//	    <row>
//	      <col id="0">Johan</col>
//	      <col id="1">Dahlin</col>
//	      <col id="2">50</col>
//	    </row>
//	  </data>
//	</object>.
type ListStore struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
	TreeDragDest
	TreeDragSource
	TreeSortable
}

var (
	_ coreglib.Objector = (*ListStore)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ListStore, *ListStoreClass, ListStoreOverrides](
		GTypeListStore,
		initListStoreClass,
		wrapListStore,
		defaultListStoreOverrides,
	)
}

func initListStoreClass(gclass unsafe.Pointer, overrides ListStoreOverrides, classInitFunc func(*ListStoreClass)) {
	if classInitFunc != nil {
		class := (*ListStoreClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapListStore(obj *coreglib.Object) *ListStore {
	return &ListStore{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		TreeDragDest: TreeDragDest{
			Object: obj,
		},
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeSortable: TreeSortable{
			TreeModel: TreeModel{
				Object: obj,
			},
		},
	}
}

func marshalListStore(p uintptr) (interface{}, error) {
	return wrapListStore(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewListStore: non-vararg creation function. Used primarily by language
// bindings.
//
// The function takes the following parameters:
//
//   - types: array of #GType types for the columns, from first to last.
//
// The function returns the following values:
//
//   - listStore: new ListStore.
func NewListStore(types []coreglib.Type) *ListStore {
	var _arg2 *C.GType // out
	var _arg1 C.int
	var _cret *C.GtkListStore // in

	_arg1 = (C.int)(len(types))
	_arg2 = (*C.GType)(C.calloc(C.size_t(len(types)), C.size_t(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GType)(_arg2), len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	_cret = C.gtk_list_store_newv(_arg1, _arg2)
	runtime.KeepAlive(types)

	var _listStore *ListStore // out

	_listStore = wrapListStore(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _listStore
}

// Append appends a new row to list_store. iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the appended row.
func (listStore *ListStore) Append() *TreeIter {
	var _arg0 *C.GtkListStore // out
	var _arg1 C.GtkTreeIter   // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))

	C.gtk_list_store_append(_arg0, &_arg1)
	runtime.KeepAlive(listStore)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// Clear removes all rows from the list store.
func (listStore *ListStore) Clear() {
	var _arg0 *C.GtkListStore // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))

	C.gtk_list_store_clear(_arg0)
	runtime.KeepAlive(listStore)
}

// Insert creates a new row at position. iter will be changed to point to
// this new row. If position is -1 or is larger than the number of rows on
// the list, then the new row will be appended to the list. The row will be
// empty after this function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
//
// The function takes the following parameters:
//
//   - position to insert the new row, or -1 for last.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the new row.
func (listStore *ListStore) Insert(position int) *TreeIter {
	var _arg0 *C.GtkListStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 C.int           // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	_arg2 = C.int(position)

	C.gtk_list_store_insert(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(position)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// InsertAfter inserts a new row after sibling. If sibling is NULL,
// then the row will be prepended to the beginning of the list. iter will be
// changed to point to this new row. The row will be empty after this function
// is called. To fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
//
// The function takes the following parameters:
//
//   - sibling (optional): valid TreeIter, or NULL.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the new row.
func (listStore *ListStore) InsertAfter(sibling *TreeIter) *TreeIter {
	var _arg0 *C.GtkListStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(sibling)))
	}

	C.gtk_list_store_insert_after(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(sibling)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// InsertBefore inserts a new row before sibling. If sibling is NULL, then the
// row will be appended to the end of the list. iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
//
// The function takes the following parameters:
//
//   - sibling (optional): valid TreeIter, or NULL.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the new row.
func (listStore *ListStore) InsertBefore(sibling *TreeIter) *TreeIter {
	var _arg0 *C.GtkListStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	if sibling != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(sibling)))
	}

	C.gtk_list_store_insert_before(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(sibling)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// InsertWithValues: variant of gtk_list_store_insert_with_values() which takes
// the columns and values as two arrays, instead of varargs.
//
// This function is mainly intended for language-bindings.
//
// The function takes the following parameters:
//
//   - position to insert the new row, or -1 for last.
//   - columns: array of column numbers.
//   - values: array of GValues.
//
// The function returns the following values:
//
//   - iter (optional): unset TreeIter to set to the new row.
func (listStore *ListStore) InsertWithValues(position int, columns []int, values []coreglib.Value) *TreeIter {
	var _arg0 *C.GtkListStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 C.int           // out
	var _arg3 *C.int          // out
	var _arg5 C.int
	var _arg4 *C.GValue // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	_arg2 = C.int(position)
	_arg5 = (C.int)(len(columns))
	_arg3 = (*C.int)(C.calloc(C.size_t(len(columns)), C.size_t(C.sizeof_int)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.int)(_arg3), len(columns))
		for i := range columns {
			out[i] = C.int(columns[i])
		}
	}
	_arg5 = (C.int)(len(values))
	_arg4 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GValue)(_arg4), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	C.gtk_list_store_insert_with_valuesv(_arg0, &_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(position)
	runtime.KeepAlive(columns)
	runtime.KeepAlive(values)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this ListStore.
//
// The function takes the following parameters:
//
//   - iter: TreeIter.
//
// The function returns the following values:
//
//   - ok: TRUE if the iter is valid, FALSE if the iter is invalid.
func (listStore *ListStore) IterIsValid(iter *TreeIter) bool {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_list_store_iter_is_valid(_arg0, _arg1)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveAfter moves iter in store to the position after position. Note that this
// function only works with unsorted stores. If position is NULL, iter will be
// moved to the start of the list.
//
// The function takes the following parameters:
//
//   - iter: TreeIter.
//   - position (optional) or NULL.
func (store *ListStore) MoveAfter(iter, position *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if position != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(position)))
	}

	C.gtk_list_store_move_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(store)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(position)
}

// MoveBefore moves iter in store to the position before position. Note that
// this function only works with unsorted stores. If position is NULL, iter will
// be moved to the end of the list.
//
// The function takes the following parameters:
//
//   - iter: TreeIter.
//   - position (optional) or NULL.
func (store *ListStore) MoveBefore(iter, position *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if position != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(position)))
	}

	C.gtk_list_store_move_before(_arg0, _arg1, _arg2)
	runtime.KeepAlive(store)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(position)
}

// Prepend prepends a new row to list_store. iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the prepend row.
func (listStore *ListStore) Prepend() *TreeIter {
	var _arg0 *C.GtkListStore // out
	var _arg1 C.GtkTreeIter   // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))

	C.gtk_list_store_prepend(_arg0, &_arg1)
	runtime.KeepAlive(listStore)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// Remove removes the given row from the list store. After being removed,
// iter is set to be the next valid row, or invalidated if it pointed to the
// last row in list_store.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is valid, FALSE if not.
func (listStore *ListStore) Remove(iter *TreeIter) bool {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_list_store_remove(_arg0, _arg1)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Reorder reorders store to follow the order indicated by new_order. Note that
// this function only works with unsorted stores.
//
// The function takes the following parameters:
//
//   - newOrder: array of integers mapping the new position of each child to its
//     old position before the re-ordering, i.e. new_order[newpos] = oldpos.
//     It must have exactly as many items as the list store’s length.
func (store *ListStore) Reorder(newOrder []int) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.int          // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	{
		_arg1 = (*C.int)(C.calloc(C.size_t((len(newOrder) + 1)), C.size_t(C.sizeof_int)))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(newOrder)+1)
			var zero C.int
			out[len(newOrder)] = zero
			for i := range newOrder {
				out[i] = C.int(newOrder[i])
			}
		}
	}

	C.gtk_list_store_reorder(_arg0, _arg1)
	runtime.KeepAlive(store)
	runtime.KeepAlive(newOrder)
}

// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from ListStore, and should only be used when constructing a new ListStore.
// It will not function after a row has been added, or a method on the TreeModel
// interface is called.
//
// The function takes the following parameters:
//
//   - types: array length n of #GTypes.
func (listStore *ListStore) SetColumnTypes(types []coreglib.Type) {
	var _arg0 *C.GtkListStore // out
	var _arg2 *C.GType        // out
	var _arg1 C.int

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	_arg1 = (C.int)(len(types))
	_arg2 = (*C.GType)(C.calloc(C.size_t(len(types)), C.size_t(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GType)(_arg2), len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	C.gtk_list_store_set_column_types(_arg0, _arg1, _arg2)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(types)
}

// SetValue sets the data in the cell specified by iter and column. The type of
// value must be convertible to the type of the column.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter for the row being modified.
//   - column number to modify.
//   - value: new value for the cell.
func (listStore *ListStore) SetValue(iter *TreeIter, column int, value *coreglib.Value) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.int           // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.int(column)
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_list_store_set_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(column)
	runtime.KeepAlive(value)
}

// Set: variant of gtk_list_store_set_valist() which takes the columns and
// values as two arrays, instead of varargs. This function is mainly intended
// for language-bindings and in case the number of columns to change is not
// known until run-time.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter for the row being modified.
//   - columns: array of column numbers.
//   - values: array of GValues.
func (listStore *ListStore) Set(iter *TreeIter, columns []int, values []coreglib.Value) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.int          // out
	var _arg4 C.int
	var _arg3 *C.GValue // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(listStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg4 = (C.int)(len(columns))
	_arg2 = (*C.int)(C.calloc(C.size_t(len(columns)), C.size_t(C.sizeof_int)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.int)(_arg2), len(columns))
		for i := range columns {
			out[i] = C.int(columns[i])
		}
	}
	_arg4 = (C.int)(len(values))
	_arg3 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GValue)(_arg3), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	C.gtk_list_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(listStore)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(columns)
	runtime.KeepAlive(values)
}

// Swap swaps a and b in store. Note that this function only works with unsorted
// stores.
//
// The function takes the following parameters:
//
//   - a: TreeIter.
//   - b: another TreeIter.
func (store *ListStore) Swap(a, b *TreeIter) {
	var _arg0 *C.GtkListStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkListStore)(unsafe.Pointer(coreglib.InternObject(store).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(a)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(b)))

	C.gtk_list_store_swap(_arg0, _arg1, _arg2)
	runtime.KeepAlive(store)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)
}

// ListView: GtkListView presents a large dynamic list of items.
//
// GtkListView uses its factory to generate one row widget for each visible item
// and shows them in a linear display, either vertically or horizontally.
//
// The gtk.ListView:show-separators property offers a simple way to display
// separators between the rows.
//
// GtkListView allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected
// items, it is possible to turn on _rubberband selection_, using
// gtk.ListView:enable-rubberband.
//
// If you need multiple columns with headers, see gtk.ColumnView.
//
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
//
// An example of using GtkListView:
//
//	static void
//	setup_listitem_cb (GtkListItemFactory *factory,
//	                   GtkListItem        *list_item)
//	{
//	  GtkWidget *image;
//
//	  image = gtk_image_new ();
//	  gtk_image_set_icon_size (GTK_IMAGE (image), GTK_ICON_SIZE_LARGE);
//	  gtk_list_item_set_child (list_item, image);
//	}
//
//	static void
//	bind_listitem_cb (GtkListItemFactory *factory,
//	                  GtkListItem        *list_item)
//	{
//	  GtkWidget *image;
//	  GAppInfo *app_info;
//
//	  image = gtk_list_item_get_child (list_item);
//	  app_info = gtk_list_item_get_item (list_item);
//	  gtk_image_set_from_gicon (GTK_IMAGE (image), g_app_info_get_icon (app_info));
//	}
//
//	static void
//	activate_cb (GtkListView  *list,
//	             guint         position,
//	             gpointer      unused)
//	{
//	  GAppInfo *app_info;
//
//	  app_info = g_list_model_get_item (G_LIST_MODEL (gtk_list_view_get_model (list)), position);
//	  g_app_info_launch (app_info, NULL, NULL, NULL);
//	  g_object_unref (app_info);
//	}
//
//	...
//
//	  model = create_application_list ();
//
//	  factory = gtk_signal_list_item_factory_new ();
//	  g_signal_connect (factory, "setup", G_CALLBACK (setup_listitem_cb), NULL);
//	  g_signal_connect (factory, "bind", G_CALLBACK (bind_listitem_cb), NULL);
//
//	  list = gtk_list_view_new (GTK_SELECTION_MODEL (gtk_single_selection_new (model)), factory);
//
//	  g_signal_connect (list, "activate", G_CALLBACK (activate_cb), NULL);
//
//	  gtk_scrolled_window_set_child (GTK_SCROLLED_WINDOW (sw), list);
//
// CSS nodes
//
//	listview[.separators][.rich-list][.navigation-sidebar][.data-table]
//	├── row
//	│
//	├── row
//	│
//	┊
//	╰── [rubberband]
//
// GtkListView uses a single CSS node named listview. It may carry the
// .separators style class, when GtkListView:show-separators property is set.
// Each child widget uses a single CSS node named row. For rubberband selection,
// a node with name rubberband is used.
//
// The main listview node may also carry style classes to select the style
// of list presentation (ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
//
// # Accessibility
//
// GtkListView uses the GTK_ACCESSIBLE_ROLE_LIST role, and the list items use
// the GTK_ACCESSIBLE_ROLE_LIST_ITEM role.
type ListView struct {
	_ [0]func() // equal guard
	ListBase
}

var (
	_ ListBaser = (*ListView)(nil)
)

func wrapListView(obj *coreglib.Object) *ListView {
	return &ListView{
		ListBase: ListBase{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
			Scrollable: Scrollable{
				Object: obj,
			},
		},
	}
}

func marshalListView(p uintptr) (interface{}, error) {
	return wrapListView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when a row has been activated by the user, usually
// via activating the GtkListView|list.activate-item action.
//
// This allows for a convenient way to handle activation in a listview.
// See gtk.ListItem.SetActivatable() for details on how to use this signal.
func (self *ListView) ConnectActivate(f func(position uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate", false, unsafe.Pointer(C._gotk4_gtk4_ListView_ConnectActivate), f)
}

// NewListView creates a new GtkListView that uses the given factory for mapping
// items to widgets.
//
// The function takes ownership of the arguments, so you can write code like
//
//	list_view = gtk_list_view_new (create_model (),
//	  gtk_builder_list_item_factory_new_from_resource ("/resource.ui"));.
//
// The function takes the following parameters:
//
//   - model (optional) to use, or NULL.
//   - factory (optional) to populate items with, or NULL.
//
// The function returns the following values:
//
//   - listView: new GtkListView using the given model and factory.
func NewListView(model SelectionModeller, factory *ListItemFactory) *ListView {
	var _arg1 *C.GtkSelectionModel  // out
	var _arg2 *C.GtkListItemFactory // out
	var _cret *C.GtkWidget          // in

	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	if factory != nil {
		_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(factory).Native()))
	}

	_cret = C.gtk_list_view_new(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(factory)

	var _listView *ListView // out

	_listView = wrapListView(coreglib.Take(unsafe.Pointer(_cret)))

	return _listView
}

// EnableRubberband returns whether rows can be selected by dragging with the
// mouse.
//
// The function returns the following values:
//
//   - ok: TRUE if rubberband selection is enabled.
func (self *ListView) EnableRubberband() bool {
	var _arg0 *C.GtkListView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_view_get_enable_rubberband(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Factory gets the factory that's currently used to populate list items.
//
// The function returns the following values:
//
//   - listItemFactory (optional): factory in use.
func (self *ListView) Factory() *ListItemFactory {
	var _arg0 *C.GtkListView        // out
	var _cret *C.GtkListItemFactory // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_view_get_factory(_arg0)
	runtime.KeepAlive(self)

	var _listItemFactory *ListItemFactory // out

	if _cret != nil {
		_listItemFactory = wrapListItemFactory(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _listItemFactory
}

// Model gets the model that's currently used to read the items displayed.
//
// The function returns the following values:
//
//   - selectionModel (optional): model in use.
func (self *ListView) Model() *SelectionModel {
	var _arg0 *C.GtkListView       // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_view_get_model(_arg0)
	runtime.KeepAlive(self)

	var _selectionModel *SelectionModel // out

	if _cret != nil {
		_selectionModel = wrapSelectionModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _selectionModel
}

// ShowSeparators returns whether the list box should show separators between
// rows.
//
// The function returns the following values:
//
//   - ok: TRUE if the list box shows separators.
func (self *ListView) ShowSeparators() bool {
	var _arg0 *C.GtkListView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_view_get_show_separators(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SingleClickActivate returns whether rows will be activated on single click
// and selected on hover.
//
// The function returns the following values:
//
//   - ok: TRUE if rows are activated on single click.
func (self *ListView) SingleClickActivate() bool {
	var _arg0 *C.GtkListView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_list_view_get_single_click_activate(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetEnableRubberband sets whether selections can be changed by dragging with
// the mouse.
//
// The function takes the following parameters:
//
//   - enableRubberband: TRUE to enable rubberband selection.
func (self *ListView) SetEnableRubberband(enableRubberband bool) {
	var _arg0 *C.GtkListView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enableRubberband {
		_arg1 = C.TRUE
	}

	C.gtk_list_view_set_enable_rubberband(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enableRubberband)
}

// SetFactory sets the GtkListItemFactory to use for populating list items.
//
// The function takes the following parameters:
//
//   - factory (optional) to use or NULL for none.
func (self *ListView) SetFactory(factory *ListItemFactory) {
	var _arg0 *C.GtkListView        // out
	var _arg1 *C.GtkListItemFactory // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if factory != nil {
		_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(coreglib.InternObject(factory).Native()))
	}

	C.gtk_list_view_set_factory(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(factory)
}

// SetModel sets the model to use.
//
// This must be a gtk.SelectionModel to use.
//
// The function takes the following parameters:
//
//   - model (optional) to use or NULL for none.
func (self *ListView) SetModel(model SelectionModeller) {
	var _arg0 *C.GtkListView       // out
	var _arg1 *C.GtkSelectionModel // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_list_view_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetShowSeparators sets whether the list box should show separators between
// rows.
//
// The function takes the following parameters:
//
//   - showSeparators: TRUE to show separators.
func (self *ListView) SetShowSeparators(showSeparators bool) {
	var _arg0 *C.GtkListView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if showSeparators {
		_arg1 = C.TRUE
	}

	C.gtk_list_view_set_show_separators(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(showSeparators)
}

// SetSingleClickActivate sets whether rows should be activated on single click
// and selected on hover.
//
// The function takes the following parameters:
//
//   - singleClickActivate: TRUE to activate items on single click.
func (self *ListView) SetSingleClickActivate(singleClickActivate bool) {
	var _arg0 *C.GtkListView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkListView)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if singleClickActivate {
		_arg1 = C.TRUE
	}

	C.gtk_list_view_set_single_click_activate(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(singleClickActivate)
}

// LockButton: GtkLockButton is a widget to obtain and revoke authorizations
// needed to operate the controls.
//
// !An example GtkLockButton (lock-button.png)
//
// It is typically used in preference dialogs or control panels.
//
// The required authorization is represented by a GPermission object.
// Concrete implementations of GPermission may use PolicyKit or some other
// authorization framework. To obtain a PolicyKit-based GPermission, use
// polkit_permission_new().
//
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
//
// ! (lockbutton-locked.png)
//
// and the user can click the button to request the permission. Depending on
// the platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
//
// ! (lockbutton-unlocked.png)
//
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
//
// ! (lockbutton-sorry.png)
//
// If the user has the permission and cannot drop it, the button is hidden.
//
// The text (and tooltips) that are shown in the various cases can be
// adjusted with the gtk.LockButton:text-lock, gtk.LockButton:text-unlock,
// gtk.LockButton:tooltip-lock, gtk.LockButton:tooltip-unlock and
// gtk.LockButton:tooltip-not-authorized properties.
type LockButton struct {
	_ [0]func() // equal guard
	Button
}

var (
	_ Widgetter         = (*LockButton)(nil)
	_ coreglib.Objector = (*LockButton)(nil)
)

func wrapLockButton(obj *coreglib.Object) *LockButton {
	return &LockButton{
		Button: Button{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Actionable: Actionable{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalLockButton(p uintptr) (interface{}, error) {
	return wrapLockButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewLockButton creates a new lock button which reflects the permission.
//
// The function takes the following parameters:
//
//   - permission (optional): GPermission.
//
// The function returns the following values:
//
//   - lockButton: new GtkLockButton.
func NewLockButton(permission gio.Permissioner) *LockButton {
	var _arg1 *C.GPermission // out
	var _cret *C.GtkWidget   // in

	if permission != nil {
		_arg1 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	}

	_cret = C.gtk_lock_button_new(_arg1)
	runtime.KeepAlive(permission)

	var _lockButton *LockButton // out

	_lockButton = wrapLockButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _lockButton
}

// Permission obtains the GPermission object that controls button.
//
// The function returns the following values:
//
//   - permission: GPermission of button.
func (button *LockButton) Permission() gio.Permissioner {
	var _arg0 *C.GtkLockButton // out
	var _cret *C.GPermission   // in

	_arg0 = (*C.GtkLockButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_lock_button_get_permission(_arg0)
	runtime.KeepAlive(button)

	var _permission gio.Permissioner // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.Permissioner is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.Permissioner)
			return ok
		})
		rv, ok := casted.(gio.Permissioner)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.Permissioner")
		}
		_permission = rv
	}

	return _permission
}

// SetPermission sets the GPermission object that controls button.
//
// The function takes the following parameters:
//
//   - permission (optional): GPermission object, or NULL.
func (button *LockButton) SetPermission(permission gio.Permissioner) {
	var _arg0 *C.GtkLockButton // out
	var _arg1 *C.GPermission   // out

	_arg0 = (*C.GtkLockButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	if permission != nil {
		_arg1 = (*C.GPermission)(unsafe.Pointer(coreglib.InternObject(permission).Native()))
	}

	C.gtk_lock_button_set_permission(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(permission)
}

// MapListModelOverrides contains methods that are overridable.
type MapListModelOverrides struct {
}

func defaultMapListModelOverrides(v *MapListModel) MapListModelOverrides {
	return MapListModelOverrides{}
}

// MapListModel: GtkMapListModel maps the items in a list model to different
// items.
//
// GtkMapListModel uses a gtk.MapListModelMapFunc.
//
// Example: Create a list of GtkEventControllers
//
//	static gpointer
//	map_to_controllers (gpointer widget,
//	                    gpointer data)
//	{
//	  gpointer result = gtk_widget_observe_controllers (widget);
//	  g_object_unref (widget);
//	  return result;
//	}
//
//	widgets = gtk_widget_observe_children (widget);
//
//	controllers = gtk_map_list_model_new (G_TYPE_LIST_MODEL,
//	                                      widgets,
//	                                      map_to_controllers,
//	                                      NULL, NULL);
//
//	model = gtk_flatten_list_model_new (GTK_TYPE_EVENT_CONTROLLER,
//	                                    controllers);
//
// GtkMapListModel will attempt to discard the mapped objects as soon as they
// are no longer needed and recreate them if necessary.
type MapListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*MapListModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MapListModel, *MapListModelClass, MapListModelOverrides](
		GTypeMapListModel,
		initMapListModelClass,
		wrapMapListModel,
		defaultMapListModelOverrides,
	)
}

func initMapListModelClass(gclass unsafe.Pointer, overrides MapListModelOverrides, classInitFunc func(*MapListModelClass)) {
	if classInitFunc != nil {
		class := (*MapListModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMapListModel(obj *coreglib.Object) *MapListModel {
	return &MapListModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalMapListModel(p uintptr) (interface{}, error) {
	return wrapMapListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMapListModel creates a new GtkMapListModel for the given arguments.
//
// The function takes the following parameters:
//
//   - model (optional) to map or NULL for none.
//   - mapFunc (optional): map function or NULL to not map items.
//
// The function returns the following values:
//
//   - mapListModel: new GtkMapListModel.
func NewMapListModel(model gio.ListModeller, mapFunc MapListModelMapFunc) *MapListModel {
	var _arg1 *C.GListModel            // out
	var _arg2 C.GtkMapListModelMapFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify
	var _cret *C.GtkMapListModel // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	if mapFunc != nil {
		_arg2 = (*[0]byte)(C._gotk4_gtk4_MapListModelMapFunc)
		_arg3 = C.gpointer(gbox.Assign(mapFunc))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	_cret = C.gtk_map_list_model_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(model)
	runtime.KeepAlive(mapFunc)

	var _mapListModel *MapListModel // out

	_mapListModel = wrapMapListModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mapListModel
}

// Model gets the model that is currently being mapped or NULL if none.
//
// The function returns the following values:
//
//   - listModel (optional): model that gets mapped.
func (self *MapListModel) Model() *gio.ListModel {
	var _arg0 *C.GtkMapListModel // out
	var _cret *C.GListModel      // in

	_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_map_list_model_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// HasMap checks if a map function is currently set on self.
//
// The function returns the following values:
//
//   - ok: TRUE if a map function is set.
func (self *MapListModel) HasMap() bool {
	var _arg0 *C.GtkMapListModel // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_map_list_model_has_map(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetMapFunc sets the function used to map items.
//
// The function will be called whenever an item needs to be mapped and must
// return the item to use for the given input item.
//
// Note that GtkMapListModel may call this function multiple times on the same
// item, because it may delete items it doesn't need anymore.
//
// GTK makes no effort to ensure that map_func conforms to the item type of
// self. It assumes that the caller knows what they are doing and the map
// function returns items of the appropriate type.
//
// The function takes the following parameters:
//
//   - mapFunc (optional): map function or NULL to not map items.
func (self *MapListModel) SetMapFunc(mapFunc MapListModelMapFunc) {
	var _arg0 *C.GtkMapListModel       // out
	var _arg1 C.GtkMapListModelMapFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if mapFunc != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_MapListModelMapFunc)
		_arg2 = C.gpointer(gbox.Assign(mapFunc))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_map_list_model_set_map_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(mapFunc)
}

// SetModel sets the model to be mapped.
//
// GTK makes no effort to ensure that model conforms to the item type expected
// by the map function. It assumes that the caller knows what they are doing and
// have set up an appropriate map function.
//
// The function takes the following parameters:
//
//   - model (optional) to be mapped.
func (self *MapListModel) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkMapListModel // out
	var _arg1 *C.GListModel      // out

	_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_map_list_model_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// MediaControlsOverrides contains methods that are overridable.
type MediaControlsOverrides struct {
}

func defaultMediaControlsOverrides(v *MediaControls) MediaControlsOverrides {
	return MediaControlsOverrides{}
}

// MediaControls: GtkMediaControls is a widget to show controls for a video.
//
// !An example GtkMediaControls (media-controls.png)
//
// Usually, GtkMediaControls is used as part of gtk.Video.
type MediaControls struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*MediaControls)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MediaControls, *MediaControlsClass, MediaControlsOverrides](
		GTypeMediaControls,
		initMediaControlsClass,
		wrapMediaControls,
		defaultMediaControlsOverrides,
	)
}

func initMediaControlsClass(gclass unsafe.Pointer, overrides MediaControlsOverrides, classInitFunc func(*MediaControlsClass)) {
	if classInitFunc != nil {
		class := (*MediaControlsClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMediaControls(obj *coreglib.Object) *MediaControls {
	return &MediaControls{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalMediaControls(p uintptr) (interface{}, error) {
	return wrapMediaControls(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMediaControls creates a new GtkMediaControls managing the stream passed to
// it.
//
// The function takes the following parameters:
//
//   - stream (optional) to manage or NULL for none.
//
// The function returns the following values:
//
//   - mediaControls: new GtkMediaControls.
func NewMediaControls(stream MediaStreamer) *MediaControls {
	var _arg1 *C.GtkMediaStream // out
	var _cret *C.GtkWidget      // in

	if stream != nil {
		_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	}

	_cret = C.gtk_media_controls_new(_arg1)
	runtime.KeepAlive(stream)

	var _mediaControls *MediaControls // out

	_mediaControls = wrapMediaControls(coreglib.Take(unsafe.Pointer(_cret)))

	return _mediaControls
}

// MediaStream gets the media stream managed by controls or NULL if none.
//
// The function returns the following values:
//
//   - mediaStream (optional): media stream managed by controls.
func (controls *MediaControls) MediaStream() MediaStreamer {
	var _arg0 *C.GtkMediaControls // out
	var _cret *C.GtkMediaStream   // in

	_arg0 = (*C.GtkMediaControls)(unsafe.Pointer(coreglib.InternObject(controls).Native()))

	_cret = C.gtk_media_controls_get_media_stream(_arg0)
	runtime.KeepAlive(controls)

	var _mediaStream MediaStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MediaStreamer)
				return ok
			})
			rv, ok := casted.(MediaStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.MediaStreamer")
			}
			_mediaStream = rv
		}
	}

	return _mediaStream
}

// SetMediaStream sets the stream that is controlled by controls.
//
// The function takes the following parameters:
//
//   - stream (optional): GtkMediaStream, or NULL.
func (controls *MediaControls) SetMediaStream(stream MediaStreamer) {
	var _arg0 *C.GtkMediaControls // out
	var _arg1 *C.GtkMediaStream   // out

	_arg0 = (*C.GtkMediaControls)(unsafe.Pointer(coreglib.InternObject(controls).Native()))
	if stream != nil {
		_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	}

	C.gtk_media_controls_set_media_stream(_arg0, _arg1)
	runtime.KeepAlive(controls)
	runtime.KeepAlive(stream)
}

// MediaFileOverrides contains methods that are overridable.
type MediaFileOverrides struct {
	Close func()
	Open  func()
}

func defaultMediaFileOverrides(v *MediaFile) MediaFileOverrides {
	return MediaFileOverrides{
		Close: v.close,
		Open:  v.open,
	}
}

// MediaFile: GtkMediaFile implements GtkMediaStream for files.
//
// This provides a simple way to play back video files with GTK.
//
// GTK provides a GIO extension point for GtkMediaFile implementations to allow
// for external implementations using various media frameworks.
//
// GTK itself includes implementations using GStreamer and ffmpeg.
type MediaFile struct {
	_ [0]func() // equal guard
	MediaStream
}

var (
	_ MediaStreamer = (*MediaFile)(nil)
)

// MediaFiler describes types inherited from class MediaFile.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MediaFiler interface {
	coreglib.Objector
	baseMediaFile() *MediaFile
}

var _ MediaFiler = (*MediaFile)(nil)

func init() {
	coreglib.RegisterClassInfo[*MediaFile, *MediaFileClass, MediaFileOverrides](
		GTypeMediaFile,
		initMediaFileClass,
		wrapMediaFile,
		defaultMediaFileOverrides,
	)
}

func initMediaFileClass(gclass unsafe.Pointer, overrides MediaFileOverrides, classInitFunc func(*MediaFileClass)) {
	pclass := (*C.GtkMediaFileClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMediaFile))))

	if overrides.Close != nil {
		pclass.close = (*[0]byte)(C._gotk4_gtk4_MediaFileClass_close)
	}

	if overrides.Open != nil {
		pclass.open = (*[0]byte)(C._gotk4_gtk4_MediaFileClass_open)
	}

	if classInitFunc != nil {
		class := (*MediaFileClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMediaFile(obj *coreglib.Object) *MediaFile {
	return &MediaFile{
		MediaStream: MediaStream{
			Object: obj,
			Paintable: gdk.Paintable{
				Object: obj,
			},
		},
	}
}

func marshalMediaFile(p uintptr) (interface{}, error) {
	return wrapMediaFile(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *MediaFile) baseMediaFile() *MediaFile {
	return self
}

// BaseMediaFile returns the underlying base object.
func BaseMediaFile(obj MediaFiler) *MediaFile {
	return obj.baseMediaFile()
}

// NewMediaFile creates a new empty media file.
//
// The function returns the following values:
//
//   - mediaFile: new GtkMediaFile.
func NewMediaFile() *MediaFile {
	var _cret *C.GtkMediaStream // in

	_cret = C.gtk_media_file_new()

	var _mediaFile *MediaFile // out

	_mediaFile = wrapMediaFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForFile creates a new media file to play file.
//
// The function takes the following parameters:
//
//   - file to play.
//
// The function returns the following values:
//
//   - mediaFile: new GtkMediaFile playing file.
func NewMediaFileForFile(file gio.Filer) *MediaFile {
	var _arg1 *C.GFile          // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))

	_cret = C.gtk_media_file_new_for_file(_arg1)
	runtime.KeepAlive(file)

	var _mediaFile *MediaFile // out

	_mediaFile = wrapMediaFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForFilename creates a new media file for the given filename.
//
// This is a utility function that converts the given filename to a GFile and
// calls gtk.MediaFile.NewForFile.
//
// The function takes the following parameters:
//
//   - filename to open.
//
// The function returns the following values:
//
//   - mediaFile: new GtkMediaFile playing filename.
func NewMediaFileForFilename(filename string) *MediaFile {
	var _arg1 *C.char           // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_media_file_new_for_filename(_arg1)
	runtime.KeepAlive(filename)

	var _mediaFile *MediaFile // out

	_mediaFile = wrapMediaFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForInputStream creates a new media file to play stream.
//
// If you want the resulting media to be seekable, the stream should implement
// the GSeekable interface.
//
// The function takes the following parameters:
//
//   - stream to play.
//
// The function returns the following values:
//
//   - mediaFile: new GtkMediaFile.
func NewMediaFileForInputStream(stream gio.InputStreamer) *MediaFile {
	var _arg1 *C.GInputStream   // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))

	_cret = C.gtk_media_file_new_for_input_stream(_arg1)
	runtime.KeepAlive(stream)

	var _mediaFile *MediaFile // out

	_mediaFile = wrapMediaFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// NewMediaFileForResource creates a new new media file for the given resource.
//
// This is a utility function that converts the given resource to a GFile and
// calls gtk.MediaFile.NewForFile.
//
// The function takes the following parameters:
//
//   - resourcePath: resource path to open.
//
// The function returns the following values:
//
//   - mediaFile: new GtkMediaFile playing resource_path.
func NewMediaFileForResource(resourcePath string) *MediaFile {
	var _arg1 *C.char           // out
	var _cret *C.GtkMediaStream // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_media_file_new_for_resource(_arg1)
	runtime.KeepAlive(resourcePath)

	var _mediaFile *MediaFile // out

	_mediaFile = wrapMediaFile(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mediaFile
}

// Clear resets the media file to be empty.
func (self *MediaFile) Clear() {
	var _arg0 *C.GtkMediaFile // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_media_file_clear(_arg0)
	runtime.KeepAlive(self)
}

// File returns the file that self is currently playing from.
//
// When self is not playing or not playing from a file, NULL is returned.
//
// The function returns the following values:
//
//   - file (optional): currently playing file or NULL if not playing from a
//     file.
func (self *MediaFile) File() *gio.File {
	var _arg0 *C.GtkMediaFile // out
	var _cret *C.GFile        // in

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_file_get_file(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_file = &gio.File{
				Object: obj,
			}
		}
	}

	return _file
}

// InputStream returns the stream that self is currently playing from.
//
// When self is not playing or not playing from a stream, NULL is returned.
//
// The function returns the following values:
//
//   - inputStream (optional): currently playing stream or NULL if not playing
//     from a stream.
func (self *MediaFile) InputStream() gio.InputStreamer {
	var _arg0 *C.GtkMediaFile // out
	var _cret *C.GInputStream // in

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_file_get_input_stream(_arg0)
	runtime.KeepAlive(self)

	var _inputStream gio.InputStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.InputStreamer)
				return ok
			})
			rv, ok := casted.(gio.InputStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.InputStreamer")
			}
			_inputStream = rv
		}
	}

	return _inputStream
}

// SetFile sets the GtkMediaFile to play the given file.
//
// If any file is still playing, stop playing it.
//
// The function takes the following parameters:
//
//   - file (optional) to play.
func (self *MediaFile) SetFile(file gio.Filer) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.GFile        // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if file != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}

	C.gtk_media_file_set_file(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(file)
}

// SetFilename sets the `GtkMediaFile to play the given file.
//
// This is a utility function that converts the given filename to a GFile and
// calls gtk.MediaFile.SetFile().
//
// The function takes the following parameters:
//
//   - filename (optional): name of file to play.
func (self *MediaFile) SetFilename(filename string) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if filename != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_media_file_set_filename(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(filename)
}

// SetInputStream sets the GtkMediaFile to play the given stream.
//
// If anything is still playing, stop playing it.
//
// Full control about the stream is assumed for the duration of playback.
// The stream will not be closed.
//
// The function takes the following parameters:
//
//   - stream (optional) to play from.
func (self *MediaFile) SetInputStream(stream gio.InputStreamer) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.GInputStream // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if stream != nil {
		_arg1 = (*C.GInputStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	}

	C.gtk_media_file_set_input_stream(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(stream)
}

// SetResource sets the `GtkMediaFile to play the given resource.
//
// This is a utility function that converts the given resource_path to a GFile
// and calls gtk.MediaFile.SetFile().
//
// The function takes the following parameters:
//
//   - resourcePath (optional): path to resource to play.
func (self *MediaFile) SetResource(resourcePath string) {
	var _arg0 *C.GtkMediaFile // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if resourcePath != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_media_file_set_resource(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(resourcePath)
}

func (self *MediaFile) close() {
	gclass := (*C.GtkMediaFileClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.close

	var _arg0 *C.GtkMediaFile // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C._gotk4_gtk4_MediaFile_virtual_close(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)
}

func (self *MediaFile) open() {
	gclass := (*C.GtkMediaFileClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.open

	var _arg0 *C.GtkMediaFile // out

	_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C._gotk4_gtk4_MediaFile_virtual_open(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)
}

// MediaStreamOverrides contains methods that are overridable.
type MediaStreamOverrides struct {
	// Pause pauses playback of the stream.
	//
	// If the stream is not playing, do nothing.
	Pause func()
	Play  func() bool
	// Realize: called by users to attach the media stream to a GdkSurface they
	// manage.
	//
	// The stream can then access the resources of surface for its rendering
	// purposes. In particular, media streams might want to create a
	// GdkGLContext or sync to the GdkFrameClock.
	//
	// Whoever calls this function is responsible for calling
	// gtk.MediaStream.Unrealize() before either the stream or surface get
	// destroyed.
	//
	// Multiple calls to this function may happen from different users of the
	// video, even with the same surface. Each of these calls must be followed
	// by its own call to gtk.MediaStream.Unrealize().
	//
	// It is not required to call this function to make a media stream work.
	//
	// The function takes the following parameters:
	//
	//   - surface: GdkSurface.
	Realize func(surface gdk.Surfacer)
	// Seek: start a seek operation on self to timestamp.
	//
	// If timestamp is out of range, it will be clamped.
	//
	// Seek operations may not finish instantly. While a seek operation is in
	// process, the gtk.MediaStream:seeking property will be set.
	//
	// When calling gtk_media_stream_seek() during an ongoing seek operation,
	// the new seek will override any pending seek.
	//
	// The function takes the following parameters:
	//
	//   - timestamp to seek to.
	Seek func(timestamp int64)
	// Unrealize undoes a previous call to gtk_media_stream_realize().
	//
	// This causes the stream to release all resources it had allocated from
	// surface.
	//
	// The function takes the following parameters:
	//
	//   - surface: GdkSurface the stream was realized with.
	Unrealize func(surface gdk.Surfacer)
	// The function takes the following parameters:
	//
	//   - muted
	//   - volume
	UpdateAudio func(muted bool, volume float64)
}

func defaultMediaStreamOverrides(v *MediaStream) MediaStreamOverrides {
	return MediaStreamOverrides{
		Pause:       v.pause,
		Play:        v.play,
		Realize:     v.realize,
		Seek:        v.seek,
		Unrealize:   v.unrealize,
		UpdateAudio: v.updateAudio,
	}
}

// MediaStream: GtkMediaStream is the integration point for media playback
// inside GTK.
//
// GTK provides an implementation of the GtkMediaStream interface that is called
// gtk.MediaFile.
//
// Apart from application-facing API for stream playback, GtkMediaStream
// has a number of APIs that are only useful for implementations and
// should not be used in applications: gtk.MediaStream.Prepared(),
// gtk.MediaStream.Unprepared(), gtk.MediaStream.Update(),
// gtk.MediaStream.Ended(), gtk.MediaStream.SeekSuccess(),
// gtk.MediaStream.SeekFailed(), gtk.MediaStream.GError(),
// gtk.MediaStream.Error(), gtk.MediaStream.ErrorValist().
type MediaStream struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gdk.Paintable
}

var (
	_ coreglib.Objector = (*MediaStream)(nil)
)

// MediaStreamer describes types inherited from class MediaStream.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MediaStreamer interface {
	coreglib.Objector
	baseMediaStream() *MediaStream
}

var _ MediaStreamer = (*MediaStream)(nil)

func init() {
	coreglib.RegisterClassInfo[*MediaStream, *MediaStreamClass, MediaStreamOverrides](
		GTypeMediaStream,
		initMediaStreamClass,
		wrapMediaStream,
		defaultMediaStreamOverrides,
	)
}

func initMediaStreamClass(gclass unsafe.Pointer, overrides MediaStreamOverrides, classInitFunc func(*MediaStreamClass)) {
	pclass := (*C.GtkMediaStreamClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeMediaStream))))

	if overrides.Pause != nil {
		pclass.pause = (*[0]byte)(C._gotk4_gtk4_MediaStreamClass_pause)
	}

	if overrides.Play != nil {
		pclass.play = (*[0]byte)(C._gotk4_gtk4_MediaStreamClass_play)
	}

	if overrides.Realize != nil {
		pclass.realize = (*[0]byte)(C._gotk4_gtk4_MediaStreamClass_realize)
	}

	if overrides.Seek != nil {
		pclass.seek = (*[0]byte)(C._gotk4_gtk4_MediaStreamClass_seek)
	}

	if overrides.Unrealize != nil {
		pclass.unrealize = (*[0]byte)(C._gotk4_gtk4_MediaStreamClass_unrealize)
	}

	if overrides.UpdateAudio != nil {
		pclass.update_audio = (*[0]byte)(C._gotk4_gtk4_MediaStreamClass_update_audio)
	}

	if classInitFunc != nil {
		class := (*MediaStreamClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMediaStream(obj *coreglib.Object) *MediaStream {
	return &MediaStream{
		Object: obj,
		Paintable: gdk.Paintable{
			Object: obj,
		},
	}
}

func marshalMediaStream(p uintptr) (interface{}, error) {
	return wrapMediaStream(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *MediaStream) baseMediaStream() *MediaStream {
	return self
}

// BaseMediaStream returns the underlying base object.
func BaseMediaStream(obj MediaStreamer) *MediaStream {
	return obj.baseMediaStream()
}

// Ended pauses the media stream and marks it as ended.
//
// This is a hint only, calls to GtkMediaStream.play() may still happen.
//
// The media stream must be prepared when this function is called.
func (self *MediaStream) Ended() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_media_stream_ended(_arg0)
	runtime.KeepAlive(self)
}

// GError sets self into an error state.
//
// This will pause the stream (you can check for an error via
// gtk.MediaStream.GetError() in your GtkMediaStream.pause() implementation),
// abort pending seeks and mark the stream as prepared.
//
// if the stream is already in an error state, this call will be ignored and the
// existing error will be retained.
//
// To unset an error, the stream must be reset via a call to
// gtk.MediaStream.Unprepared().
//
// The function takes the following parameters:
//
//   - err: GError to set.
func (self *MediaStream) GError(err error) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GError         // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if err != nil {
		_arg1 = (*C.GError)(gerror.New(err))
	}

	C.gtk_media_stream_gerror(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(err)
}

// Duration gets the duration of the stream.
//
// If the duration is not known, 0 will be returned.
//
// The function returns the following values:
//
//   - gint64: duration of the stream or 0 if not known.
func (self *MediaStream) Duration() int64 {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gint64          // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_duration(_arg0)
	runtime.KeepAlive(self)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// GetEnded returns whether the streams playback is finished.
//
// The function returns the following values:
//
//   - ok: TRUE if playback is finished.
func (self *MediaStream) GetEnded() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_ended(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Error: if the stream is in an error state, returns the GError explaining that
// state.
//
// Any type of error can be reported here depending on the implementation of the
// media stream.
//
// A media stream in an error cannot be operated on, calls like
// gtk.MediaStream.Play() or gtk.MediaStream.Seek() will not have any effect.
//
// GtkMediaStream itself does not provide a way to unset an error, but
// implementations may provide options. For example, a gtk.MediaFile will unset
// errors when a new source is set, e.g. with gtk.MediaFile.SetFile().
//
// The function returns the following values:
//
//   - err (optional): NULL if not in an error state or the GError of the
//     stream.
func (self *MediaStream) Error() error {
	var _arg0 *C.GtkMediaStream // out
	var _cret *C.GError         // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_error(_arg0)
	runtime.KeepAlive(self)

	var _err error // out

	if _cret != nil {
		_err = gerror.Take(unsafe.Pointer(_cret))
	}

	return _err
}

// Loop returns whether the stream is set to loop.
//
// See gtk.MediaStream.SetLoop() for details.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream should loop.
func (self *MediaStream) Loop() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_loop(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Muted returns whether the audio for the stream is muted.
//
// See gtk.MediaStream.SetMuted() for details.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream is muted.
func (self *MediaStream) Muted() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_muted(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Playing: return whether the stream is currently playing.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream is playing.
func (self *MediaStream) Playing() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_playing(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Timestamp returns the current presentation timestamp in microseconds.
//
// The function returns the following values:
//
//   - gint64: timestamp in microseconds.
func (self *MediaStream) Timestamp() int64 {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gint64          // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_timestamp(_arg0)
	runtime.KeepAlive(self)

	var _gint64 int64 // out

	_gint64 = int64(_cret)

	return _gint64
}

// Volume returns the volume of the audio for the stream.
//
// See gtk.MediaStream.SetVolume() for details.
//
// The function returns the following values:
//
//   - gdouble: volume of the stream from 0.0 to 1.0.
func (self *MediaStream) Volume() float64 {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.double          // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_get_volume(_arg0)
	runtime.KeepAlive(self)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// HasAudio returns whether the stream has audio.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream has audio.
func (self *MediaStream) HasAudio() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_has_audio(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasVideo returns whether the stream has video.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream has video.
func (self *MediaStream) HasVideo() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_has_video(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsPrepared returns whether the stream has finished initializing.
//
// At this point the existence of audio and video is known.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream is prepared.
func (self *MediaStream) IsPrepared() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_is_prepared(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSeekable checks if a stream may be seekable.
//
// This is meant to be a hint. Streams may not allow seeking even if this
// function returns TRUE. However, if this function returns FALSE, streams are
// guaranteed to not be seekable and user interfaces may hide controls that
// allow seeking.
//
// It is allowed to call gtk.MediaStream.Seek() on a non-seekable stream,
// though it will not do anything.
//
// The function returns the following values:
//
//   - ok: TRUE if the stream may support seeking.
func (self *MediaStream) IsSeekable() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_is_seekable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSeeking checks if there is currently a seek operation going on.
//
// The function returns the following values:
//
//   - ok: TRUE if a seek operation is ongoing.
func (self *MediaStream) IsSeeking() bool {
	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_media_stream_is_seeking(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Pause pauses playback of the stream.
//
// If the stream is not playing, do nothing.
func (self *MediaStream) Pause() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_media_stream_pause(_arg0)
	runtime.KeepAlive(self)
}

// Play starts playing the stream.
//
// If the stream is in error or already playing, do nothing.
func (self *MediaStream) Play() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_media_stream_play(_arg0)
	runtime.KeepAlive(self)
}

// Prepared: called by GtkMediaStream implementations to advertise the stream
// being ready to play and providing details about the stream.
//
// Note that the arguments are hints. If the stream implementation cannot
// determine the correct values, it is better to err on the side of caution and
// return TRUE. User interfaces will use those values to determine what controls
// to show.
//
// This function may not be called again until the stream has been reset via
// gtk.MediaStream.Unprepared().
//
// The function takes the following parameters:
//
//   - hasAudio: TRUE if the stream should advertise audio support.
//   - hasVideo: TRUE if the stream should advertise video support.
//   - seekable: TRUE if the stream should advertise seekability.
//   - duration of the stream or 0 if unknown.
func (self *MediaStream) Prepared(hasAudio, hasVideo, seekable bool, duration int64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out
	var _arg2 C.gboolean        // out
	var _arg3 C.gboolean        // out
	var _arg4 C.gint64          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if hasAudio {
		_arg1 = C.TRUE
	}
	if hasVideo {
		_arg2 = C.TRUE
	}
	if seekable {
		_arg3 = C.TRUE
	}
	_arg4 = C.gint64(duration)

	C.gtk_media_stream_prepared(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(hasAudio)
	runtime.KeepAlive(hasVideo)
	runtime.KeepAlive(seekable)
	runtime.KeepAlive(duration)
}

// Realize: called by users to attach the media stream to a GdkSurface they
// manage.
//
// The stream can then access the resources of surface for its rendering
// purposes. In particular, media streams might want to create a GdkGLContext or
// sync to the GdkFrameClock.
//
// Whoever calls this function is responsible for calling
// gtk.MediaStream.Unrealize() before either the stream or surface get
// destroyed.
//
// Multiple calls to this function may happen from different users of the video,
// even with the same surface. Each of these calls must be followed by its own
// call to gtk.MediaStream.Unrealize().
//
// It is not required to call this function to make a media stream work.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface.
func (self *MediaStream) Realize(surface gdk.Surfacer) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GdkSurface     // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gtk_media_stream_realize(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(surface)
}

// Seek: start a seek operation on self to timestamp.
//
// If timestamp is out of range, it will be clamped.
//
// Seek operations may not finish instantly. While a seek operation is in
// process, the gtk.MediaStream:seeking property will be set.
//
// When calling gtk_media_stream_seek() during an ongoing seek operation,
// the new seek will override any pending seek.
//
// The function takes the following parameters:
//
//   - timestamp to seek to.
func (self *MediaStream) Seek(timestamp int64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gint64          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gint64(timestamp)

	C.gtk_media_stream_seek(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(timestamp)
}

// SeekFailed ends a seek operation started via GtkMediaStream.seek() as a
// failure.
//
// This will not cause an error on the stream and will assume that playback
// continues as if no seek had happened.
//
// See gtk.MediaStream.SeekSuccess() for the other way of ending a seek.
func (self *MediaStream) SeekFailed() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_media_stream_seek_failed(_arg0)
	runtime.KeepAlive(self)
}

// SeekSuccess ends a seek operation started via GtkMediaStream.seek()
// successfully.
//
// This function will unset the GtkMediaStream:ended property if it was set.
//
// See gtk.MediaStream.SeekFailed() for the other way of ending a seek.
func (self *MediaStream) SeekSuccess() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_media_stream_seek_success(_arg0)
	runtime.KeepAlive(self)
}

// SetLoop sets whether the stream should loop.
//
// In this case, it will attempt to restart playback from the beginning instead
// of stopping at the end.
//
// Not all streams may support looping, in particular non-seekable streams.
// Those streams will ignore the loop setting and just end.
//
// The function takes the following parameters:
//
//   - loop: TRUE if the stream should loop.
func (self *MediaStream) SetLoop(loop bool) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if loop {
		_arg1 = C.TRUE
	}

	C.gtk_media_stream_set_loop(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(loop)
}

// SetMuted sets whether the audio stream should be muted.
//
// Muting a stream will cause no audio to be played, but it does not modify the
// volume. This means that muting and then unmuting the stream will restore the
// volume settings.
//
// If the stream has no audio, calling this function will still work but it will
// not have an audible effect.
//
// The function takes the following parameters:
//
//   - muted: TRUE if the stream should be muted.
func (self *MediaStream) SetMuted(muted bool) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if muted {
		_arg1 = C.TRUE
	}

	C.gtk_media_stream_set_muted(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(muted)
}

// SetPlaying starts or pauses playback of the stream.
//
// The function takes the following parameters:
//
//   - playing: whether to start or pause playback.
func (self *MediaStream) SetPlaying(playing bool) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if playing {
		_arg1 = C.TRUE
	}

	C.gtk_media_stream_set_playing(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(playing)
}

// SetVolume sets the volume of the audio stream.
//
// This function call will work even if the stream is muted.
//
// The given volume should range from 0.0 for silence to 1.0 for as loud as
// possible. Values outside of this range will be clamped to the nearest value.
//
// If the stream has no audio or is muted, calling this function will still work
// but it will not have an immediate audible effect. When the stream is unmuted,
// the new volume setting will take effect.
//
// The function takes the following parameters:
//
//   - volume: new volume of the stream from 0.0 to 1.0.
func (self *MediaStream) SetVolume(volume float64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.double(volume)

	C.gtk_media_stream_set_volume(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(volume)
}

// Unprepared resets a given media stream implementation.
//
// gtk.MediaStream.Prepared() can then be called again.
//
// This function will also reset any error state the stream was in.
func (self *MediaStream) Unprepared() {
	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_media_stream_unprepared(_arg0)
	runtime.KeepAlive(self)
}

// Unrealize undoes a previous call to gtk_media_stream_realize().
//
// This causes the stream to release all resources it had allocated from
// surface.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface the stream was realized with.
func (self *MediaStream) Unrealize(surface gdk.Surfacer) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GdkSurface     // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C.gtk_media_stream_unrealize(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(surface)
}

// Update: media stream implementations should regularly call this function to
// update the timestamp reported by the stream.
//
// It is up to implementations to call this at the frequency they deem
// appropriate.
//
// The media stream must be prepared when this function is called.
//
// The function takes the following parameters:
//
//   - timestamp: new timestamp.
func (self *MediaStream) Update(timestamp int64) {
	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gint64          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gint64(timestamp)

	C.gtk_media_stream_update(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(timestamp)
}

// Pause pauses playback of the stream.
//
// If the stream is not playing, do nothing.
func (self *MediaStream) pause() {
	gclass := (*C.GtkMediaStreamClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.pause

	var _arg0 *C.GtkMediaStream // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C._gotk4_gtk4_MediaStream_virtual_pause(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)
}

func (self *MediaStream) play() bool {
	gclass := (*C.GtkMediaStreamClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.play

	var _arg0 *C.GtkMediaStream // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C._gotk4_gtk4_MediaStream_virtual_play(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realize: called by users to attach the media stream to a GdkSurface they
// manage.
//
// The stream can then access the resources of surface for its rendering
// purposes. In particular, media streams might want to create a GdkGLContext or
// sync to the GdkFrameClock.
//
// Whoever calls this function is responsible for calling
// gtk.MediaStream.Unrealize() before either the stream or surface get
// destroyed.
//
// Multiple calls to this function may happen from different users of the video,
// even with the same surface. Each of these calls must be followed by its own
// call to gtk.MediaStream.Unrealize().
//
// It is not required to call this function to make a media stream work.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface.
func (self *MediaStream) realize(surface gdk.Surfacer) {
	gclass := (*C.GtkMediaStreamClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.realize

	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GdkSurface     // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C._gotk4_gtk4_MediaStream_virtual_realize(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(surface)
}

// Seek: start a seek operation on self to timestamp.
//
// If timestamp is out of range, it will be clamped.
//
// Seek operations may not finish instantly. While a seek operation is in
// process, the gtk.MediaStream:seeking property will be set.
//
// When calling gtk_media_stream_seek() during an ongoing seek operation,
// the new seek will override any pending seek.
//
// The function takes the following parameters:
//
//   - timestamp to seek to.
func (self *MediaStream) seek(timestamp int64) {
	gclass := (*C.GtkMediaStreamClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.seek

	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gint64          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gint64(timestamp)

	C._gotk4_gtk4_MediaStream_virtual_seek(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(timestamp)
}

// Unrealize undoes a previous call to gtk_media_stream_realize().
//
// This causes the stream to release all resources it had allocated from
// surface.
//
// The function takes the following parameters:
//
//   - surface: GdkSurface the stream was realized with.
func (self *MediaStream) unrealize(surface gdk.Surfacer) {
	gclass := (*C.GtkMediaStreamClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.unrealize

	var _arg0 *C.GtkMediaStream // out
	var _arg1 *C.GdkSurface     // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkSurface)(unsafe.Pointer(coreglib.InternObject(surface).Native()))

	C._gotk4_gtk4_MediaStream_virtual_unrealize(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(surface)
}

// The function takes the following parameters:
//
//   - muted
//   - volume
func (self *MediaStream) updateAudio(muted bool, volume float64) {
	gclass := (*C.GtkMediaStreamClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.update_audio

	var _arg0 *C.GtkMediaStream // out
	var _arg1 C.gboolean        // out
	var _arg2 C.double          // out

	_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if muted {
		_arg1 = C.TRUE
	}
	_arg2 = C.double(volume)

	C._gotk4_gtk4_MediaStream_virtual_update_audio(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(muted)
	runtime.KeepAlive(volume)
}

// MenuButton: GtkMenuButton widget is used to display a popup when clicked.
//
// !An example GtkMenuButton (menu-button.png)
//
// This popup can be provided either as a GtkPopover or as an abstract
// GMenuModel.
//
// The GtkMenuButton widget can show either an icon (set with the
// gtk.MenuButton:icon-name property) or a label (set with the
// gtk.MenuButton:label property). If neither is explicitly set, a gtk.Image
// is automatically created, using an arrow image oriented according to
// gtk.MenuButton:direction or the generic “open-menu-symbolic” icon if the
// direction is not set.
//
// The positioning of the popup is determined by the gtk.MenuButton:direction
// property of the menu button.
//
// For menus, the gtk.Widget:halign and gtk.Widget:valign properties of
// the menu are also taken into account. For example, when the direction is
// GTK_ARROW_DOWN and the horizontal alignment is GTK_ALIGN_START, the menu will
// be positioned below the button, with the starting edge (depending on the
// text direction) of the menu aligned with the starting edge of the button.
// If there is not enough space below the button, the menu is popped up above
// the button instead. If the alignment would move part of the menu offscreen,
// it is “pushed in”.
//
// | | start | center | end | | - | --- | --- | --- | | **down** | !
// (down-start.png) | ! (down-center.png) | ! (down-end.png) | | **up** |
// ! (up-start.png) | ! (up-center.png) | ! (up-end.png) | | **left** | !
// (left-start.png) | ! (left-center.png) | ! (left-end.png) | | **right** | !
// (right-start.png) | ! (right-center.png) | ! (right-end.png) |
//
// CSS nodes
//
//	menubutton
//	╰── button.toggle
//	    ╰── <content>
//	         ╰── [arrow]
//
// GtkMenuButton has a single CSS node with name menubutton which contains a
// button node with a .toggle style class.
//
// Inside the toggle button content, there is an arrow node for the indicator,
// which will carry one of the .none, .up, .down, .left or .right style
// classes to indicate the direction that the menu will appear in. The CSS
// is expected to provide a suitable image for each of these cases using the
// -gtk-icon-source property.
//
// Optionally, the menubutton node can carry the .circular style class to
// request a round appearance.
//
// # Accessibility
//
// GtkMenuButton uses the K_ACCESSIBLE_ROLE_BUTTON role.
type MenuButton struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*MenuButton)(nil)
)

func wrapMenuButton(obj *coreglib.Object) *MenuButton {
	return &MenuButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalMenuButton(p uintptr) (interface{}, error) {
	return wrapMenuButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMenuButton creates a new GtkMenuButton widget with downwards-pointing
// arrow as the only child.
//
// You can replace the child widget with another GtkWidget should you wish to.
//
// The function returns the following values:
//
//   - menuButton: newly created GtkMenuButton.
func NewMenuButton() *MenuButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_menu_button_new()

	var _menuButton *MenuButton // out

	_menuButton = wrapMenuButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _menuButton
}

// Direction returns the direction the popup will be pointing at when popped up.
//
// The function returns the following values:
//
//   - arrowType: GtkArrowType value.
func (menuButton *MenuButton) Direction() ArrowType {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.GtkArrowType   // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	_cret = C.gtk_menu_button_get_direction(_arg0)
	runtime.KeepAlive(menuButton)

	var _arrowType ArrowType // out

	_arrowType = ArrowType(_cret)

	return _arrowType
}

// HasFrame returns whether the button has a frame.
//
// The function returns the following values:
//
//   - ok: TRUE if the button has a frame.
func (menuButton *MenuButton) HasFrame() bool {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	_cret = C.gtk_menu_button_get_has_frame(_arg0)
	runtime.KeepAlive(menuButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconName gets the name of the icon shown in the button.
//
// The function returns the following values:
//
//   - utf8: name of the icon shown in the button.
func (menuButton *MenuButton) IconName() string {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	_cret = C.gtk_menu_button_get_icon_name(_arg0)
	runtime.KeepAlive(menuButton)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Label gets the label shown in the button.
//
// The function returns the following values:
//
//   - utf8: label shown in the button.
func (menuButton *MenuButton) Label() string {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	_cret = C.gtk_menu_button_get_label(_arg0)
	runtime.KeepAlive(menuButton)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// MenuModel returns the GMenuModel used to generate the popup.
//
// The function returns the following values:
//
//   - menuModel (optional): GMenuModel or NULL.
func (menuButton *MenuButton) MenuModel() gio.MenuModeller {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GMenuModel    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	_cret = C.gtk_menu_button_get_menu_model(_arg0)
	runtime.KeepAlive(menuButton)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// Popover returns the GtkPopover that pops out of the button.
//
// If the button is not using a GtkPopover, this function returns NULL.
//
// The function returns the following values:
//
//   - popover (optional): GtkPopover or NULL.
func (menuButton *MenuButton) Popover() *Popover {
	var _arg0 *C.GtkMenuButton // out
	var _cret *C.GtkPopover    // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	_cret = C.gtk_menu_button_get_popover(_arg0)
	runtime.KeepAlive(menuButton)

	var _popover *Popover // out

	if _cret != nil {
		_popover = wrapPopover(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _popover
}

// UseUnderline returns whether an embedded underline in the text indicates a
// mnemonic.
//
// The function returns the following values:
//
//   - ok: TRUE whether an embedded underline in the text indicates the mnemonic
//     accelerator keys.
func (menuButton *MenuButton) UseUnderline() bool {
	var _arg0 *C.GtkMenuButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	_cret = C.gtk_menu_button_get_use_underline(_arg0)
	runtime.KeepAlive(menuButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Popdown dismiss the menu.
func (menuButton *MenuButton) Popdown() {
	var _arg0 *C.GtkMenuButton // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	C.gtk_menu_button_popdown(_arg0)
	runtime.KeepAlive(menuButton)
}

// Popup: pop up the menu.
func (menuButton *MenuButton) Popup() {
	var _arg0 *C.GtkMenuButton // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))

	C.gtk_menu_button_popup(_arg0)
	runtime.KeepAlive(menuButton)
}

// SetCreatePopupFunc sets func to be called when a popup is about to be shown.
//
// func should use one of
//
//   - gtk.MenuButton.SetPopover()
//   - gtk.MenuButton.SetMenuModel()
//
// to set a popup for menu_button. If func is non-NULL, menu_button will always
// be sensitive.
//
// Using this function will not reset the menu widget attached to menu_button.
// Instead, this can be done manually in func.
//
// The function takes the following parameters:
//
//   - fn (optional): function to call when a popup is about to be shown,
//     but none has been provided via other means, or NULL to reset to default
//     behavior.
func (menuButton *MenuButton) SetCreatePopupFunc(fn MenuButtonCreatePopupFunc) {
	var _arg0 *C.GtkMenuButton               // out
	var _arg1 C.GtkMenuButtonCreatePopupFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_MenuButtonCreatePopupFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_menu_button_set_create_popup_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(fn)
}

// SetDirection sets the direction in which the popup will be popped up.
//
// If the button is automatically populated with an arrow icon, its direction
// will be changed to match.
//
// If the does not fit in the available space in the given direction, GTK will
// its best to keep it inside the screen and fully visible.
//
// If you pass GTK_ARROW_NONE for a direction, the popup will behave as if you
// passed GTK_ARROW_DOWN (although you won’t see any arrows).
//
// The function takes the following parameters:
//
//   - direction: GtkArrowType.
func (menuButton *MenuButton) SetDirection(direction ArrowType) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.GtkArrowType   // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	_arg1 = C.GtkArrowType(direction)

	C.gtk_menu_button_set_direction(_arg0, _arg1)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(direction)
}

// SetHasFrame sets the style of the button.
//
// The function takes the following parameters:
//
//   - hasFrame: whether the button should have a visible frame.
func (menuButton *MenuButton) SetHasFrame(hasFrame bool) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_menu_button_set_has_frame(_arg0, _arg1)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(hasFrame)
}

// SetIconName sets the name of an icon to show inside the menu button.
//
// The function takes the following parameters:
//
//   - iconName: icon name.
func (menuButton *MenuButton) SetIconName(iconName string) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(iconName)
}

// SetLabel sets the label to show inside the menu button.
//
// The function takes the following parameters:
//
//   - label: label.
func (menuButton *MenuButton) SetLabel(label string) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_menu_button_set_label(_arg0, _arg1)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(label)
}

// SetMenuModel sets the GMenuModel from which the popup will be constructed.
//
// If menu_model is NULL, the button is disabled.
//
// A gtk.Popover will be created from the menu model with
// gtk.PopoverMenu.NewFromModel. Actions will be connected as documented for
// this function.
//
// If gtk.MenuButton:popover is already set, it will be dissociated from the
// menu_button, and the property is set to NULL.
//
// The function takes the following parameters:
//
//   - menuModel (optional): GMenuModel, or NULL to unset and disable the
//     button.
func (menuButton *MenuButton) SetMenuModel(menuModel gio.MenuModeller) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GMenuModel    // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	if menuModel != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(menuModel).Native()))
	}

	C.gtk_menu_button_set_menu_model(_arg0, _arg1)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(menuModel)
}

// SetPopover sets the GtkPopover that will be popped up when the menu_button is
// clicked.
//
// If popover is NULL, the button is disabled.
//
// If gtk.MenuButton:menu-model is set, the menu model is dissociated from the
// menu_button, and the property is set to NULL.
//
// The function takes the following parameters:
//
//   - popover (optional): GtkPopover, or NULL to unset and disable the button.
func (menuButton *MenuButton) SetPopover(popover Widgetter) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 *C.GtkWidget     // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	if popover != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	}

	C.gtk_menu_button_set_popover(_arg0, _arg1)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(popover)
}

// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
//
// The function takes the following parameters:
//
//   - useUnderline: TRUE if underlines in the text indicate mnemonics.
func (menuButton *MenuButton) SetUseUnderline(useUnderline bool) {
	var _arg0 *C.GtkMenuButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(coreglib.InternObject(menuButton).Native()))
	if useUnderline {
		_arg1 = C.TRUE
	}

	C.gtk_menu_button_set_use_underline(_arg0, _arg1)
	runtime.KeepAlive(menuButton)
	runtime.KeepAlive(useUnderline)
}

// MessageDialog: GtkMessageDialog presents a dialog with some message text.
//
// !An example GtkMessageDialog (messagedialog.png)
//
// It’s simply a convenience widget; you could construct the equivalent of
// GtkMessageDialog from GtkDialog without too much effort, but GtkMessageDialog
// saves typing.
//
// The easiest way to do a modal message dialog is to use the GTK_DIALOG_MODAL
// flag, which will call gtk.Window.SetModal() internally. The dialog will
// prevent interaction with the parent window until it's hidden or destroyed.
// You can use the gtk.Dialog::response signal to know when the user dismissed
// the dialog.
//
// An example for using a modal dialog:
//
//	GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL;
//	dialog = gtk_message_dialog_new (parent_window,
//	                                 flags,
//	                                 GTK_MESSAGE_ERROR,
//	                                 GTK_BUTTONS_CLOSE,
//	                                 "Error reading “s”: s",
//	                                 filename,
//	                                 g_strerror (errno));
//	// Destroy the dialog when the user responds to it
//	// (e.g. clicks a button)
//
//	g_signal_connect (dialog, "response",
//	                  G_CALLBACK (gtk_window_destroy),
//	                  NULL);
//
// You might do a non-modal GtkMessageDialog simply by omitting the
// GTK_DIALOG_MODAL flag:
//
//	GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//	dialog = gtk_message_dialog_new (parent_window,
//	                                 flags,
//	                                 GTK_MESSAGE_ERROR,
//	                                 GTK_BUTTONS_CLOSE,
//	                                 "Error reading “s”: s",
//	                                 filename,
//	                                 g_strerror (errno));
//
//	// Destroy the dialog when the user responds to it
//	// (e.g. clicks a button)
//	g_signal_connect (dialog, "response",
//	                  G_CALLBACK (gtk_window_destroy),
//	                  NULL);
//
// # GtkMessageDialog as GtkBuildable
//
// The GtkMessageDialog implementation of the GtkBuildable interface exposes the
// message area as an internal child with the name “message_area”.
type MessageDialog struct {
	_ [0]func() // equal guard
	Dialog
}

var (
	_ Widgetter         = (*MessageDialog)(nil)
	_ coreglib.Objector = (*MessageDialog)(nil)
)

func wrapMessageDialog(obj *coreglib.Object) *MessageDialog {
	return &MessageDialog{
		Dialog: Dialog{
			Window: Window{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
				Object: obj,
				Root: Root{
					NativeSurface: NativeSurface{
						Widget: Widget{
							InitiallyUnowned: coreglib.InitiallyUnowned{
								Object: obj,
							},
							Object: obj,
							Accessible: Accessible{
								Object: obj,
							},
							Buildable: Buildable{
								Object: obj,
							},
							ConstraintTarget: ConstraintTarget{
								Object: obj,
							},
						},
					},
				},
				ShortcutManager: ShortcutManager{
					Object: obj,
				},
			},
		},
	}
}

func marshalMessageDialog(p uintptr) (interface{}, error) {
	return wrapMessageDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// MessageArea returns the message area of the dialog.
//
// This is the box where the dialog’s primary and secondary labels are packed.
// You can add your own extra content to that box and it will appear below those
// labels. See gtk.Dialog.GetContentArea() for the corresponding function in the
// parent gtk.Dialog.
//
// The function returns the following values:
//
//   - widget: GtkBox corresponding to the “message area” in the message_dialog.
func (messageDialog *MessageDialog) MessageArea() Widgetter {
	var _arg0 *C.GtkMessageDialog // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(coreglib.InternObject(messageDialog).Native()))

	_cret = C.gtk_message_dialog_get_message_area(_arg0)
	runtime.KeepAlive(messageDialog)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// SetMarkup sets the text of the message dialog.
//
// The function takes the following parameters:
//
//   - str: string with Pango markup.
func (messageDialog *MessageDialog) SetMarkup(str string) {
	var _arg0 *C.GtkMessageDialog // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(coreglib.InternObject(messageDialog).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_message_dialog_set_markup(_arg0, _arg1)
	runtime.KeepAlive(messageDialog)
	runtime.KeepAlive(str)
}

// MnemonicAction: GtkShortcutAction that calls gtk_widget_mnemonic_activate().
type MnemonicAction struct {
	_ [0]func() // equal guard
	ShortcutAction
}

var (
	_ ShortcutActioner = (*MnemonicAction)(nil)
)

func wrapMnemonicAction(obj *coreglib.Object) *MnemonicAction {
	return &MnemonicAction{
		ShortcutAction: ShortcutAction{
			Object: obj,
		},
	}
}

func marshalMnemonicAction(p uintptr) (interface{}, error) {
	return wrapMnemonicAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// MnemonicActionGet gets the mnemonic action.
//
// This is an action that calls gtk_widget_mnemonic_activate() on the given
// widget upon activation.
//
// The function returns the following values:
//
//   - mnemonicAction: mnemonic action.
func MnemonicActionGet() *MnemonicAction {
	var _cret *C.GtkShortcutAction // in

	_cret = C.gtk_mnemonic_action_get()

	var _mnemonicAction *MnemonicAction // out

	_mnemonicAction = wrapMnemonicAction(coreglib.Take(unsafe.Pointer(_cret)))

	return _mnemonicAction
}

// MnemonicTrigger: GtkShortcutTrigger that triggers when a specific mnemonic is
// pressed.
//
// Mnemonics require a *mnemonic modifier* (typically <kbd>Alt</kbd>) to be
// pressed together with the mnemonic key.
type MnemonicTrigger struct {
	_ [0]func() // equal guard
	ShortcutTrigger
}

var (
	_ ShortcutTriggerer = (*MnemonicTrigger)(nil)
)

func wrapMnemonicTrigger(obj *coreglib.Object) *MnemonicTrigger {
	return &MnemonicTrigger{
		ShortcutTrigger: ShortcutTrigger{
			Object: obj,
		},
	}
}

func marshalMnemonicTrigger(p uintptr) (interface{}, error) {
	return wrapMnemonicTrigger(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMnemonicTrigger creates a GtkShortcutTrigger that will trigger whenever
// the key with the given keyval is pressed and mnemonics have been activated.
//
// Mnemonics are activated by calling code when a key event with the right
// modifiers is detected.
//
// The function takes the following parameters:
//
//   - keyval to trigger for.
//
// The function returns the following values:
//
//   - mnemonicTrigger: new GtkShortcutTrigger.
func NewMnemonicTrigger(keyval uint) *MnemonicTrigger {
	var _arg1 C.guint               // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = C.guint(keyval)

	_cret = C.gtk_mnemonic_trigger_new(_arg1)
	runtime.KeepAlive(keyval)

	var _mnemonicTrigger *MnemonicTrigger // out

	_mnemonicTrigger = wrapMnemonicTrigger(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mnemonicTrigger
}

// Keyval gets the keyval that must be pressed to succeed triggering self.
//
// The function returns the following values:
//
//   - guint: keyval.
func (self *MnemonicTrigger) Keyval() uint {
	var _arg0 *C.GtkMnemonicTrigger // out
	var _cret C.guint               // in

	_arg0 = (*C.GtkMnemonicTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_mnemonic_trigger_get_keyval(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// MountOperationOverrides contains methods that are overridable.
type MountOperationOverrides struct {
}

func defaultMountOperationOverrides(v *MountOperation) MountOperationOverrides {
	return MountOperationOverrides{}
}

// MountOperation: GtkMountOperation is an implementation of GMountOperation.
//
// The functions and objects described here make working with GTK and GIO more
// convenient.
//
// GtkMountOperation is needed when mounting volumes: It is an implementation
// of GMountOperation that can be used with GIO functions for mounting
// volumes such as g_file_mount_enclosing_volume(), g_file_mount_mountable(),
// g_volume_mount(), g_mount_unmount_with_operation() and others.
//
// When necessary, GtkMountOperation shows dialogs to let the user enter
// passwords, ask questions or show processes blocking unmount.
type MountOperation struct {
	_ [0]func() // equal guard
	gio.MountOperation
}

var (
	_ coreglib.Objector = (*MountOperation)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MountOperation, *MountOperationClass, MountOperationOverrides](
		GTypeMountOperation,
		initMountOperationClass,
		wrapMountOperation,
		defaultMountOperationOverrides,
	)
}

func initMountOperationClass(gclass unsafe.Pointer, overrides MountOperationOverrides, classInitFunc func(*MountOperationClass)) {
	if classInitFunc != nil {
		class := (*MountOperationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMountOperation(obj *coreglib.Object) *MountOperation {
	return &MountOperation{
		MountOperation: gio.MountOperation{
			Object: obj,
		},
	}
}

func marshalMountOperation(p uintptr) (interface{}, error) {
	return wrapMountOperation(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMountOperation creates a new GtkMountOperation.
//
// The function takes the following parameters:
//
//   - parent (optional): transient parent of the window, or NULL.
//
// The function returns the following values:
//
//   - mountOperation: new GtkMountOperation.
func NewMountOperation(parent *Window) *MountOperation {
	var _arg1 *C.GtkWindow       // out
	var _cret *C.GMountOperation // in

	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gtk_mount_operation_new(_arg1)
	runtime.KeepAlive(parent)

	var _mountOperation *MountOperation // out

	_mountOperation = wrapMountOperation(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _mountOperation
}

// Display gets the display on which windows of the GtkMountOperation will be
// shown.
//
// The function returns the following values:
//
//   - display on which windows of op are shown.
func (op *MountOperation) Display() *gdk.Display {
	var _arg0 *C.GtkMountOperation // out
	var _cret *C.GdkDisplay        // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_mount_operation_get_display(_arg0)
	runtime.KeepAlive(op)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// Parent gets the transient parent used by the GtkMountOperation.
//
// The function returns the following values:
//
//   - window: transient parent for windows shown by op.
func (op *MountOperation) Parent() *Window {
	var _arg0 *C.GtkMountOperation // out
	var _cret *C.GtkWindow         // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_mount_operation_get_parent(_arg0)
	runtime.KeepAlive(op)

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _window
}

// IsShowing returns whether the GtkMountOperation is currently displaying a
// window.
//
// The function returns the following values:
//
//   - ok: TRUE if op is currently displaying a window.
func (op *MountOperation) IsShowing() bool {
	var _arg0 *C.GtkMountOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_mount_operation_is_showing(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetDisplay sets the display to show windows of the GtkMountOperation on.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
func (op *MountOperation) SetDisplay(display *gdk.Display) {
	var _arg0 *C.GtkMountOperation // out
	var _arg1 *C.GdkDisplay        // out

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gtk_mount_operation_set_display(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(display)
}

// SetParent sets the transient parent for windows shown by the
// GtkMountOperation.
//
// The function takes the following parameters:
//
//   - parent (optional): transient parent of the window, or NULL.
func (op *MountOperation) SetParent(parent *Window) {
	var _arg0 *C.GtkMountOperation // out
	var _arg1 *C.GtkWindow         // out

	_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	C.gtk_mount_operation_set_parent(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(parent)
}

// MultiFilter: GtkMultiFilter is the base class for filters that combine
// multiple filters.
type MultiFilter struct {
	_ [0]func() // equal guard
	Filter

	*coreglib.Object
	gio.ListModel
	Buildable
}

var (
	_ coreglib.Objector = (*MultiFilter)(nil)
)

// MultiFilterer describes types inherited from class MultiFilter.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type MultiFilterer interface {
	coreglib.Objector
	baseMultiFilter() *MultiFilter
}

var _ MultiFilterer = (*MultiFilter)(nil)

func wrapMultiFilter(obj *coreglib.Object) *MultiFilter {
	return &MultiFilter{
		Filter: Filter{
			Object: obj,
		},
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalMultiFilter(p uintptr) (interface{}, error) {
	return wrapMultiFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *MultiFilter) baseMultiFilter() *MultiFilter {
	return self
}

// BaseMultiFilter returns the underlying base object.
func BaseMultiFilter(obj MultiFilterer) *MultiFilter {
	return obj.baseMultiFilter()
}

// Append adds a filter to self to use for matching.
//
// The function takes the following parameters:
//
//   - filter: new filter to use.
func (self *MultiFilter) Append(filter *Filter) {
	var _arg0 *C.GtkMultiFilter // out
	var _arg1 *C.GtkFilter      // out

	_arg0 = (*C.GtkMultiFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(filter).Native()))

	C.gtk_multi_filter_append(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(filter)
}

// Remove removes the filter at the given position from the list of filters used
// by self.
//
// If position is larger than the number of filters, nothing happens and the
// function returns.
//
// The function takes the following parameters:
//
//   - position of filter to remove.
func (self *MultiFilter) Remove(position uint) {
	var _arg0 *C.GtkMultiFilter // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkMultiFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	C.gtk_multi_filter_remove(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// MultiSelectionOverrides contains methods that are overridable.
type MultiSelectionOverrides struct {
}

func defaultMultiSelectionOverrides(v *MultiSelection) MultiSelectionOverrides {
	return MultiSelectionOverrides{}
}

// MultiSelection: GtkMultiSelection is a GtkSelectionModel that allows
// selecting multiple elements.
type MultiSelection struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SelectionModel
}

var (
	_ coreglib.Objector = (*MultiSelection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MultiSelection, *MultiSelectionClass, MultiSelectionOverrides](
		GTypeMultiSelection,
		initMultiSelectionClass,
		wrapMultiSelection,
		defaultMultiSelectionOverrides,
	)
}

func initMultiSelectionClass(gclass unsafe.Pointer, overrides MultiSelectionOverrides, classInitFunc func(*MultiSelectionClass)) {
	if classInitFunc != nil {
		class := (*MultiSelectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMultiSelection(obj *coreglib.Object) *MultiSelection {
	return &MultiSelection{
		Object: obj,
		SelectionModel: SelectionModel{
			ListModel: gio.ListModel{
				Object: obj,
			},
		},
	}
}

func marshalMultiSelection(p uintptr) (interface{}, error) {
	return wrapMultiSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMultiSelection creates a new selection to handle model.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to manage, or NULL.
//
// The function returns the following values:
//
//   - multiSelection: new GtkMultiSelection.
func NewMultiSelection(model gio.ListModeller) *MultiSelection {
	var _arg1 *C.GListModel        // out
	var _cret *C.GtkMultiSelection // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_multi_selection_new(_arg1)
	runtime.KeepAlive(model)

	var _multiSelection *MultiSelection // out

	_multiSelection = wrapMultiSelection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _multiSelection
}

// Model returns the underlying model of self.
//
// The function returns the following values:
//
//   - listModel: underlying model.
func (self *MultiSelection) Model() *gio.ListModel {
	var _arg0 *C.GtkMultiSelection // out
	var _cret *C.GListModel        // in

	_arg0 = (*C.GtkMultiSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_multi_selection_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// SetModel sets the model that self should wrap.
//
// If model is NULL, self will be empty.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to wrap.
func (self *MultiSelection) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkMultiSelection // out
	var _arg1 *C.GListModel        // out

	_arg0 = (*C.GtkMultiSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_multi_selection_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// MultiSorterOverrides contains methods that are overridable.
type MultiSorterOverrides struct {
}

func defaultMultiSorterOverrides(v *MultiSorter) MultiSorterOverrides {
	return MultiSorterOverrides{}
}

// MultiSorter: GtkMultiSorter combines multiple sorters by trying them in turn.
//
// If the first sorter compares two items as equal, the second is tried next,
// and so on.
type MultiSorter struct {
	_ [0]func() // equal guard
	Sorter

	*coreglib.Object
	gio.ListModel
	Buildable
}

var (
	_ coreglib.Objector = (*MultiSorter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*MultiSorter, *MultiSorterClass, MultiSorterOverrides](
		GTypeMultiSorter,
		initMultiSorterClass,
		wrapMultiSorter,
		defaultMultiSorterOverrides,
	)
}

func initMultiSorterClass(gclass unsafe.Pointer, overrides MultiSorterOverrides, classInitFunc func(*MultiSorterClass)) {
	if classInitFunc != nil {
		class := (*MultiSorterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapMultiSorter(obj *coreglib.Object) *MultiSorter {
	return &MultiSorter{
		Sorter: Sorter{
			Object: obj,
		},
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalMultiSorter(p uintptr) (interface{}, error) {
	return wrapMultiSorter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewMultiSorter creates a new multi sorter.
//
// This sorter compares items by trying each of the sorters in turn, until one
// returns non-zero. In particular, if no sorter has been added to it, it will
// always compare items as equal.
//
// The function returns the following values:
//
//   - multiSorter: new GtkMultiSorter.
func NewMultiSorter() *MultiSorter {
	var _cret *C.GtkMultiSorter // in

	_cret = C.gtk_multi_sorter_new()

	var _multiSorter *MultiSorter // out

	_multiSorter = wrapMultiSorter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _multiSorter
}

// Append: add sorter to self to use for sorting at the end.
//
// self will consult all existing sorters before it will sort with the given
// sorter.
//
// The function takes the following parameters:
//
//   - sorter to add.
func (self *MultiSorter) Append(sorter *Sorter) {
	var _arg0 *C.GtkMultiSorter // out
	var _arg1 *C.GtkSorter      // out

	_arg0 = (*C.GtkMultiSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(sorter).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(sorter).Native()))

	C.gtk_multi_sorter_append(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sorter)
}

// Remove removes the sorter at the given position from the list of sorter used
// by self.
//
// If position is larger than the number of sorters, nothing happens.
//
// The function takes the following parameters:
//
//   - position of sorter to remove.
func (self *MultiSorter) Remove(position uint) {
	var _arg0 *C.GtkMultiSorter // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkMultiSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	C.gtk_multi_sorter_remove(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// NamedAction: GtkShortcutAction that activates an action by name.
type NamedAction struct {
	_ [0]func() // equal guard
	ShortcutAction
}

var (
	_ ShortcutActioner = (*NamedAction)(nil)
)

func wrapNamedAction(obj *coreglib.Object) *NamedAction {
	return &NamedAction{
		ShortcutAction: ShortcutAction{
			Object: obj,
		},
	}
}

func marshalNamedAction(p uintptr) (interface{}, error) {
	return wrapNamedAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNamedAction creates an action that when activated, activates the named
// action on the widget.
//
// It also passes the given arguments to it.
//
// See gtk.Widget.InsertActionGroup() for how to add actions to widgets.
//
// The function takes the following parameters:
//
//   - name: detailed name of the action.
//
// The function returns the following values:
//
//   - namedAction: new GtkShortcutAction.
func NewNamedAction(name string) *NamedAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_named_action_new(_arg1)
	runtime.KeepAlive(name)

	var _namedAction *NamedAction // out

	_namedAction = wrapNamedAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _namedAction
}

// ActionName returns the name of the action that will be activated.
//
// The function returns the following values:
//
//   - utf8: name of the action to activate.
func (self *NamedAction) ActionName() string {
	var _arg0 *C.GtkNamedAction // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkNamedAction)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_named_action_get_action_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NativeDialogOverrides contains methods that are overridable.
type NativeDialogOverrides struct {
	// Hide hides the dialog if it is visible, aborting any interaction.
	//
	// Once this is called the gtk.NativeDialog::response signal will *not* be
	// emitted until after the next call to gtk.NativeDialog.Show().
	//
	// If the dialog is not visible this does nothing.
	Hide     func()
	Response func(responseId int)
	// Show shows the dialog on the display.
	//
	// When the user accepts the state of the dialog the dialog will be
	// automatically hidden and the gtk.NativeDialog::response signal will be
	// emitted.
	//
	// Multiple calls while the dialog is visible will be ignored.
	Show func()
}

func defaultNativeDialogOverrides(v *NativeDialog) NativeDialogOverrides {
	return NativeDialogOverrides{
		Hide:     v.hide,
		Response: v.response,
		Show:     v.show,
	}
}

// NativeDialog: native dialogs are platform dialogs that don't use GtkDialog.
//
// They are used in order to integrate better with a platform, by looking the
// same as other native applications and supporting platform specific features.
//
// The gtk.Dialog functions cannot be used on such objects, but we need a
// similar API in order to drive them. The GtkNativeDialog object is an API that
// allows you to do this. It allows you to set various common properties on the
// dialog, as well as show and hide it and get a gtk.NativeDialog::response
// signal when the user finished with the dialog.
//
// Note that unlike GtkDialog, GtkNativeDialog objects are not toplevel widgets,
// and GTK does not keep them alive. It is your responsibility to keep a
// reference until you are done with the object.
type NativeDialog struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*NativeDialog)(nil)
)

// NativeDialogger describes types inherited from class NativeDialog.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type NativeDialogger interface {
	coreglib.Objector
	baseNativeDialog() *NativeDialog
}

var _ NativeDialogger = (*NativeDialog)(nil)

func init() {
	coreglib.RegisterClassInfo[*NativeDialog, *NativeDialogClass, NativeDialogOverrides](
		GTypeNativeDialog,
		initNativeDialogClass,
		wrapNativeDialog,
		defaultNativeDialogOverrides,
	)
}

func initNativeDialogClass(gclass unsafe.Pointer, overrides NativeDialogOverrides, classInitFunc func(*NativeDialogClass)) {
	pclass := (*C.GtkNativeDialogClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeNativeDialog))))

	if overrides.Hide != nil {
		pclass.hide = (*[0]byte)(C._gotk4_gtk4_NativeDialogClass_hide)
	}

	if overrides.Response != nil {
		pclass.response = (*[0]byte)(C._gotk4_gtk4_NativeDialogClass_response)
	}

	if overrides.Show != nil {
		pclass.show = (*[0]byte)(C._gotk4_gtk4_NativeDialogClass_show)
	}

	if classInitFunc != nil {
		class := (*NativeDialogClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNativeDialog(obj *coreglib.Object) *NativeDialog {
	return &NativeDialog{
		Object: obj,
	}
}

func marshalNativeDialog(p uintptr) (interface{}, error) {
	return wrapNativeDialog(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *NativeDialog) baseNativeDialog() *NativeDialog {
	return self
}

// BaseNativeDialog returns the underlying base object.
func BaseNativeDialog(obj NativeDialogger) *NativeDialog {
	return obj.baseNativeDialog()
}

// ConnectResponse is emitted when the user responds to the dialog.
//
// When this is called the dialog has been hidden.
//
// If you call gtk.NativeDialog.Hide() before the user responds to the dialog
// this signal will not be emitted.
func (self *NativeDialog) ConnectResponse(f func(responseId int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "response", false, unsafe.Pointer(C._gotk4_gtk4_NativeDialog_ConnectResponse), f)
}

// Destroy destroys a dialog.
//
// When a dialog is destroyed, it will break any references it holds to other
// objects.
//
// If it is visible it will be hidden and any underlying window system resources
// will be destroyed.
//
// Note that this does not release any reference to the object (as opposed to
// destroying a GtkWindow) because there is no reference from the windowing
// system to the GtkNativeDialog.
func (self *NativeDialog) Destroy() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_native_dialog_destroy(_arg0)
	runtime.KeepAlive(self)
}

// Modal returns whether the dialog is modal.
//
// The function returns the following values:
//
//   - ok: TRUE if the dialog is set to be modal.
func (self *NativeDialog) Modal() bool {
	var _arg0 *C.GtkNativeDialog // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_native_dialog_get_modal(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title gets the title of the GtkNativeDialog.
//
// The function returns the following values:
//
//   - utf8 (optional): title of the dialog, or NULL if none has been set
//     explicitly. The returned string is owned by the widget and must not be
//     modified or freed.
func (self *NativeDialog) Title() string {
	var _arg0 *C.GtkNativeDialog // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_native_dialog_get_title(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TransientFor fetches the transient parent for this window.
//
// The function returns the following values:
//
//   - window (optional): transient parent for this window, or NULL if no
//     transient parent has been set.
func (self *NativeDialog) TransientFor() *Window {
	var _arg0 *C.GtkNativeDialog // out
	var _cret *C.GtkWindow       // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_native_dialog_get_transient_for(_arg0)
	runtime.KeepAlive(self)

	var _window *Window // out

	if _cret != nil {
		_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _window
}

// Visible determines whether the dialog is visible.
//
// The function returns the following values:
//
//   - ok: TRUE if the dialog is visible.
func (self *NativeDialog) Visible() bool {
	var _arg0 *C.GtkNativeDialog // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_native_dialog_get_visible(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide hides the dialog if it is visible, aborting any interaction.
//
// Once this is called the gtk.NativeDialog::response signal will *not* be
// emitted until after the next call to gtk.NativeDialog.Show().
//
// If the dialog is not visible this does nothing.
func (self *NativeDialog) Hide() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_native_dialog_hide(_arg0)
	runtime.KeepAlive(self)
}

// SetModal sets a dialog modal or non-modal.
//
// Modal dialogs prevent interaction with other windows in the same
// application. To keep modal dialogs on top of main application windows,
// use gtk.NativeDialog.SetTransientFor() to make the dialog transient for the
// parent; most window managers will then disallow lowering the dialog below the
// parent.
//
// The function takes the following parameters:
//
//   - modal: whether the window is modal.
func (self *NativeDialog) SetModal(modal bool) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_native_dialog_set_modal(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(modal)
}

// SetTitle sets the title of the GtkNativeDialog.
//
// The function takes the following parameters:
//
//   - title of the dialog.
func (self *NativeDialog) SetTitle(title string) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_native_dialog_set_title(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(title)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from.
//
// This allows window managers to e.g. keep the dialog on top of the main
// window, or center the dialog over the main window.
//
// Passing NULL for parent unsets the current transient window.
//
// The function takes the following parameters:
//
//   - parent (optional) window, or NULL.
func (self *NativeDialog) SetTransientFor(parent *Window) {
	var _arg0 *C.GtkNativeDialog // out
	var _arg1 *C.GtkWindow       // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	C.gtk_native_dialog_set_transient_for(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(parent)
}

// Show shows the dialog on the display.
//
// When the user accepts the state of the dialog the dialog will be
// automatically hidden and the gtk.NativeDialog::response signal will be
// emitted.
//
// Multiple calls while the dialog is visible will be ignored.
func (self *NativeDialog) Show() {
	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_native_dialog_show(_arg0)
	runtime.KeepAlive(self)
}

// Hide hides the dialog if it is visible, aborting any interaction.
//
// Once this is called the gtk.NativeDialog::response signal will *not* be
// emitted until after the next call to gtk.NativeDialog.Show().
//
// If the dialog is not visible this does nothing.
func (self *NativeDialog) hide() {
	gclass := (*C.GtkNativeDialogClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.hide

	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C._gotk4_gtk4_NativeDialog_virtual_hide(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)
}

func (self *NativeDialog) response(responseId int) {
	gclass := (*C.GtkNativeDialogClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.response

	var _arg0 *C.GtkNativeDialog // out
	var _arg1 C.int              // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(responseId)

	C._gotk4_gtk4_NativeDialog_virtual_response(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(responseId)
}

// Show shows the dialog on the display.
//
// When the user accepts the state of the dialog the dialog will be
// automatically hidden and the gtk.NativeDialog::response signal will be
// emitted.
//
// Multiple calls while the dialog is visible will be ignored.
func (self *NativeDialog) show() {
	gclass := (*C.GtkNativeDialogClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.show

	var _arg0 *C.GtkNativeDialog // out

	_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C._gotk4_gtk4_NativeDialog_virtual_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)
}

// NeverTrigger: GtkShortcutTrigger that never triggers.
type NeverTrigger struct {
	_ [0]func() // equal guard
	ShortcutTrigger
}

var (
	_ ShortcutTriggerer = (*NeverTrigger)(nil)
)

func wrapNeverTrigger(obj *coreglib.Object) *NeverTrigger {
	return &NeverTrigger{
		ShortcutTrigger: ShortcutTrigger{
			Object: obj,
		},
	}
}

func marshalNeverTrigger(p uintptr) (interface{}, error) {
	return wrapNeverTrigger(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NeverTriggerGet gets the never trigger.
//
// This is a singleton for a trigger that never triggers. Use this trigger
// instead of NULL because it implements all virtual functions.
//
// The function returns the following values:
//
//   - neverTrigger: never trigger.
func NeverTriggerGet() *NeverTrigger {
	var _cret *C.GtkShortcutTrigger // in

	_cret = C.gtk_never_trigger_get()

	var _neverTrigger *NeverTrigger // out

	_neverTrigger = wrapNeverTrigger(coreglib.Take(unsafe.Pointer(_cret)))

	return _neverTrigger
}

// NoSelectionOverrides contains methods that are overridable.
type NoSelectionOverrides struct {
}

func defaultNoSelectionOverrides(v *NoSelection) NoSelectionOverrides {
	return NoSelectionOverrides{}
}

// NoSelection: GtkNoSelection is a GtkSelectionModel that does not allow
// selecting anything.
//
// This model is meant to be used as a simple wrapper around a GListModel when a
// GtkSelectionModel is required.
type NoSelection struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SelectionModel
}

var (
	_ coreglib.Objector = (*NoSelection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NoSelection, *NoSelectionClass, NoSelectionOverrides](
		GTypeNoSelection,
		initNoSelectionClass,
		wrapNoSelection,
		defaultNoSelectionOverrides,
	)
}

func initNoSelectionClass(gclass unsafe.Pointer, overrides NoSelectionOverrides, classInitFunc func(*NoSelectionClass)) {
	if classInitFunc != nil {
		class := (*NoSelectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNoSelection(obj *coreglib.Object) *NoSelection {
	return &NoSelection{
		Object: obj,
		SelectionModel: SelectionModel{
			ListModel: gio.ListModel{
				Object: obj,
			},
		},
	}
}

func marshalNoSelection(p uintptr) (interface{}, error) {
	return wrapNoSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNoSelection creates a new selection to handle model.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to manage, or NULL.
//
// The function returns the following values:
//
//   - noSelection: new GtkNoSelection.
func NewNoSelection(model gio.ListModeller) *NoSelection {
	var _arg1 *C.GListModel     // out
	var _cret *C.GtkNoSelection // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_no_selection_new(_arg1)
	runtime.KeepAlive(model)

	var _noSelection *NoSelection // out

	_noSelection = wrapNoSelection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _noSelection
}

// Model gets the model that self is wrapping.
//
// The function returns the following values:
//
//   - listModel: model being wrapped.
func (self *NoSelection) Model() *gio.ListModel {
	var _arg0 *C.GtkNoSelection // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkNoSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_no_selection_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// SetModel sets the model that self should wrap.
//
// If model is NULL, this model will be empty.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to wrap.
func (self *NoSelection) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkNoSelection // out
	var _arg1 *C.GListModel     // out

	_arg0 = (*C.GtkNoSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_no_selection_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// Notebook: GtkNotebook is a container whose children are pages switched
// between using tabs.
//
// !An example GtkNotebook (notebook.png)
//
// There are many configuration options for GtkNotebook. Among other things,
// you can choose on which edge the tabs appear (see gtk.Notebook.SetTabPos()),
// whether, if there are too many tabs to fit the notebook should be made
// bigger or scrolling arrows added (see gtk.Notebook.SetScrollable()),
// and whether there will be a popup menu allowing the users to switch pages.
// (see gtk.Notebook.PopupEnable()).
//
// # GtkNotebook as GtkBuildable
//
// The GtkNotebook implementation of the GtkBuildable interface supports placing
// children into tabs by specifying “tab” as the “type” attribute of a <child>
// element. Note that the content of the tab must be created before the tab can
// be filled. A tab child can be specified without specifying a <child> type
// attribute.
//
// To add a child widget in the notebooks action area, specify "action-start" or
// “action-end” as the “type” attribute of the <child> element.
//
// An example of a UI definition fragment with GtkNotebook:
//
//	<object class="GtkNotebook">
//	  <child>
//	    <object class="GtkLabel" id="notebook-content">
//	      <property name="label">Content</property>
//	    </object>
//	  </child>
//	  <child type="tab">
//	    <object class="GtkLabel" id="notebook-tab">
//	      <property name="label">Tab</property>
//	    </object>
//	  </child>
//	</object>
//
// CSS nodes
//
//	notebook
//	├── header.top
//	│   ├── [<action widget>]
//	│   ├── tabs
//	│   │   ├── [arrow]
//	│   │   ├── tab
//	│   │   │   ╰── <tab label>
//	┊   ┊   ┊
//	│   │   ├── tab[.reorderable-page]
//	│   │   │   ╰── <tab label>
//	│   │   ╰── [arrow]
//	│   ╰── [<action widget>]
//	│
//	╰── stack
//	    ├── <child>
//	    ┊
//	    ╰── <child>
//
// GtkNotebook has a main CSS node with name notebook, a subnode with name
// header and below that a subnode with name tabs which contains one subnode per
// tab with name tab.
//
// If action widgets are present, their CSS nodes are placed next to the tabs
// node. If the notebook is scrollable, CSS nodes with name arrow are placed as
// first and last child of the tabs node.
//
// The main node gets the .frame style class when the notebook has a border (see
// gtk.Notebook.SetShowBorder()).
//
// The header node gets one of the style class .top, .bottom, .left or .right,
// depending on where the tabs are placed. For reorderable pages, the tab node
// gets the .reorderable-page class.
//
// A tab node gets the .dnd style class while it is moved with drag-and-drop.
//
// The nodes are always arranged from left-to-right, regardless of text
// direction.
//
// # Accessibility
//
// GtkNotebook uses the following roles:
//
//   - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//   - GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//   - GTK_ACCESSIBLE_ROLE_TAB role for each tab
//   - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page.
type Notebook struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Notebook)(nil)
)

func wrapNotebook(obj *coreglib.Object) *Notebook {
	return &Notebook{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalNotebook(p uintptr) (interface{}, error) {
	return wrapNotebook(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (notebook *Notebook) ConnectChangeCurrentPage(f func(object int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "change-current-page", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectChangeCurrentPage), f)
}

// ConnectCreateWindow signal is emitted when a detachable tab is dropped on the
// root window.
//
// A handler for this signal can create a window containing a notebook where
// the tab will be attached. It is also responsible for moving/resizing
// the window and adding the necessary properties to the notebook (e.g.
// the GtkNotebook:group-name ).
func (notebook *Notebook) ConnectCreateWindow(f func(page Widgetter) (notebook *Notebook)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "create-window", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectCreateWindow), f)
}

func (notebook *Notebook) ConnectFocusTab(f func(object NotebookTab) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "focus-tab", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectFocusTab), f)
}

func (notebook *Notebook) ConnectMoveFocusOut(f func(object DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "move-focus-out", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectMoveFocusOut), f)
}

// ConnectPageAdded signal is emitted in the notebook right after a page is
// added to the notebook.
func (notebook *Notebook) ConnectPageAdded(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "page-added", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectPageAdded), f)
}

// ConnectPageRemoved signal is emitted in the notebook right after a page is
// removed from the notebook.
func (notebook *Notebook) ConnectPageRemoved(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "page-removed", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectPageRemoved), f)
}

// ConnectPageReordered signal is emitted in the notebook right after a page has
// been reordered.
func (notebook *Notebook) ConnectPageReordered(f func(child Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "page-reordered", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectPageReordered), f)
}

func (notebook *Notebook) ConnectReorderTab(f func(object DirectionType, p0 bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "reorder-tab", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectReorderTab), f)
}

func (notebook *Notebook) ConnectSelectPage(f func(object bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "select-page", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectSelectPage), f)
}

// ConnectSwitchPage is emitted when the user or a function changes the current
// page.
func (notebook *Notebook) ConnectSwitchPage(f func(page Widgetter, pageNum uint)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(notebook, "switch-page", false, unsafe.Pointer(C._gotk4_gtk4_Notebook_ConnectSwitchPage), f)
}

// NewNotebook creates a new GtkNotebook widget with no pages.
//
// The function returns the following values:
//
//   - notebook: newly created GtkNotebook.
func NewNotebook() *Notebook {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_notebook_new()

	var _notebook *Notebook // out

	_notebook = wrapNotebook(coreglib.Take(unsafe.Pointer(_cret)))

	return _notebook
}

// AppendPage appends a page to notebook.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to use as the contents of the page.
//   - tabLabel (optional): GtkWidget to be used as the label for the page,
//     or NULL to use the default label, “page N”.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the appended page in the notebook,
//     or -1 if function fails.
func (notebook *Notebook) AppendPage(child, tabLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}

	_cret = C.gtk_notebook_append_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AppendPageMenu appends a page to notebook, specifying the widget to use as
// the label in the popup menu.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to use as the contents of the page.
//   - tabLabel (optional): GtkWidget to be used as the label for the page,
//     or NULL to use the default label, “page N”.
//   - menuLabel (optional): widget to use as a label for the page-switch menu,
//     if that is enabled. If NULL, and tab_label is a Label or NULL, then the
//     menu label will be a newly created label with the same text as tab_label;
//     if tab_label is not a GtkLabel, menu_label must be specified if the
//     page-switch menu is to be used.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the appended page in the notebook,
//     or -1 if function fails.
func (notebook *Notebook) AppendPageMenu(child, tabLabel, menuLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	if menuLabel != nil {
		_arg3 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}

	_cret = C.gtk_notebook_append_page_menu(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(menuLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DetachTab removes the child from the notebook.
//
// This function is very similar to gtk.Notebook.RemovePage(), but additionally
// informs the notebook that the removal is happening as part of a tab DND
// operation, which should not be cancelled.
//
// The function takes the following parameters:
//
//   - child: child.
func (notebook *Notebook) DetachTab(child Widgetter) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_notebook_detach_tab(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
}

// ActionWidget gets one of the action widgets.
//
// See gtk.Notebook.SetActionWidget().
//
// The function takes the following parameters:
//
//   - packType: pack type of the action widget to receive.
//
// The function returns the following values:
//
//   - widget (optional): action widget with the given pack_type or NULL when
//     this action widget has not been set.
func (notebook *Notebook) ActionWidget(packType PackType) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.GtkPackType  // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.GtkPackType(packType)

	_cret = C.gtk_notebook_get_action_widget(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(packType)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// CurrentPage returns the page number of the current page.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the current page in the notebook.
//     If the notebook has no pages, then -1 will be returned.
func (notebook *Notebook) CurrentPage() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_current_page(_arg0)
	runtime.KeepAlive(notebook)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// GroupName gets the current group name for notebook.
//
// The function returns the following values:
//
//   - utf8 (optional): group name, or NULL if none is set.
func (notebook *Notebook) GroupName() string {
	var _arg0 *C.GtkNotebook // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_group_name(_arg0)
	runtime.KeepAlive(notebook)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MenuLabel retrieves the menu label widget of the page containing child.
//
// The function takes the following parameters:
//
//   - child: widget contained in a page of notebook.
//
// The function returns the following values:
//
//   - widget (optional): menu label, or NULL if the notebook page does not have
//     a menu label other than the default (the tab label).
func (notebook *Notebook) MenuLabel(child Widgetter) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_menu_label(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// MenuLabelText retrieves the text of the menu label for the page containing
// child.
//
// The function takes the following parameters:
//
//   - child widget of a page of the notebook.
//
// The function returns the following values:
//
//   - utf8 (optional): text of the tab label, or NULL if the widget does not
//     have a menu label other than the default menu label, or the menu label
//     widget is not a GtkLabel. The string is owned by the widget and must not
//     be freed.
func (notebook *Notebook) MenuLabelText(child Widgetter) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_menu_label_text(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NPages gets the number of pages in a notebook.
//
// The function returns the following values:
//
//   - gint: number of pages in the notebook.
func (notebook *Notebook) NPages() int {
	var _arg0 *C.GtkNotebook // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_n_pages(_arg0)
	runtime.KeepAlive(notebook)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NthPage returns the child widget contained in page number page_num.
//
// The function takes the following parameters:
//
//   - pageNum: index of a page in the notebook, or -1 to get the last page.
//
// The function returns the following values:
//
//   - widget (optional): child widget, or NULL if page_num is out of bounds.
func (notebook *Notebook) NthPage(pageNum int) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.int          // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.int(pageNum)

	_cret = C.gtk_notebook_get_nth_page(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pageNum)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Page returns the GtkNotebookPage for child.
//
// The function takes the following parameters:
//
//   - child of notebook.
//
// The function returns the following values:
//
//   - notebookPage: GtkNotebookPage for child.
func (notebook *Notebook) Page(child Widgetter) *NotebookPage {
	var _arg0 *C.GtkNotebook     // out
	var _arg1 *C.GtkWidget       // out
	var _cret *C.GtkNotebookPage // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_page(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _notebookPage *NotebookPage // out

	_notebookPage = wrapNotebookPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _notebookPage
}

// Pages returns a GListModel that contains the pages of the notebook.
//
// This can be used to keep an up-to-date view. The model also implements
// gtk.SelectionModel and can be used to track and modify the visible page.
//
// The function returns the following values:
//
//   - listModel: a GListModel for the notebook's children.
func (notebook *Notebook) Pages() *gio.ListModel {
	var _arg0 *C.GtkNotebook // out
	var _cret *C.GListModel  // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_pages(_arg0)
	runtime.KeepAlive(notebook)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// Scrollable returns whether the tab label area has arrows for scrolling.
//
// The function returns the following values:
//
//   - ok: TRUE if arrows for scrolling are present.
func (notebook *Notebook) Scrollable() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_scrollable(_arg0)
	runtime.KeepAlive(notebook)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowBorder returns whether a bevel will be drawn around the notebook pages.
//
// The function returns the following values:
//
//   - ok: TRUE if the bevel is drawn.
func (notebook *Notebook) ShowBorder() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_show_border(_arg0)
	runtime.KeepAlive(notebook)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowTabs returns whether the tabs of the notebook are shown.
//
// The function returns the following values:
//
//   - ok: TRUE if the tabs are shown.
func (notebook *Notebook) ShowTabs() bool {
	var _arg0 *C.GtkNotebook // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_show_tabs(_arg0)
	runtime.KeepAlive(notebook)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabDetachable returns whether the tab contents can be detached from notebook.
//
// The function takes the following parameters:
//
//   - child GtkWidget.
//
// The function returns the following values:
//
//   - ok: TRUE if the tab is detachable.
func (notebook *Notebook) TabDetachable(child Widgetter) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabLabel returns the tab label widget for the page child.
//
// NULL is returned if child is not in notebook or if no tab label has
// specifically been set for child.
//
// The function takes the following parameters:
//
//   - child: page.
//
// The function returns the following values:
//
//   - widget (optional): tab label.
func (notebook *Notebook) TabLabel(child Widgetter) Widgetter {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_label(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// TabLabelText retrieves the text of the tab label for the page containing
// child.
//
// The function takes the following parameters:
//
//   - child: widget contained in a page of notebook.
//
// The function returns the following values:
//
//   - utf8 (optional): text of the tab label, or NULL if the tab label idget is
//     not a GtkLabel. The string is owned by the widget and must not be freed.
func (notebook *Notebook) TabLabelText(child Widgetter) string {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_label_text(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TabPos gets the edge at which the tabs are drawn.
//
// The function returns the following values:
//
//   - positionType: edge at which the tabs are drawn.
func (notebook *Notebook) TabPos() PositionType {
	var _arg0 *C.GtkNotebook    // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	_cret = C.gtk_notebook_get_tab_pos(_arg0)
	runtime.KeepAlive(notebook)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
//
// The function takes the following parameters:
//
//   - child GtkWidget.
//
// The function returns the following values:
//
//   - ok: TRUE if the tab is reorderable.
func (notebook *Notebook) TabReorderable(child Widgetter) bool {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertPage: insert a page into notebook at the given position.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to use as the contents of the page.
//   - tabLabel (optional): GtkWidget to be used as the label for the page,
//     or NULL to use the default label, “page N”.
//   - position: index (starting at 0) at which to insert the page, or -1 to
//     append the page after all other pages.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the inserted page in the notebook,
//     or -1 if function fails.
func (notebook *Notebook) InsertPage(child, tabLabel Widgetter, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 C.int          // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	_arg3 = C.int(position)

	_cret = C.gtk_notebook_insert_page(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InsertPageMenu: insert a page into notebook at the given position, specifying
// the widget to use as the label in the popup menu.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to use as the contents of the page.
//   - tabLabel (optional): GtkWidget to be used as the label for the page,
//     or NULL to use the default label, “page N”.
//   - menuLabel (optional): widget to use as a label for the page-switch menu,
//     if that is enabled. If NULL, and tab_label is a Label or NULL, then the
//     menu label will be a newly created label with the same text as tab_label;
//     if tab_label is not a Label, menu_label must be specified if the
//     page-switch menu is to be used.
//   - position: index (starting at 0) at which to insert the page, or -1 to
//     append the page after all other pages.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the inserted page in the notebook.
func (notebook *Notebook) InsertPageMenu(child, tabLabel, menuLabel Widgetter, position int) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _arg4 C.int          // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	if menuLabel != nil {
		_arg3 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}
	_arg4 = C.int(position)

	_cret = C.gtk_notebook_insert_page_menu(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(menuLabel)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NextPage switches to the next page.
//
// Nothing happens if the current page is the last page.
func (notebook *Notebook) NextPage() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_next_page(_arg0)
	runtime.KeepAlive(notebook)
}

// PageNum finds the index of the page which contains the given child widget.
//
// The function takes the following parameters:
//
//   - child: GtkWidget.
//
// The function returns the following values:
//
//   - gint: index of the page containing child, or -1 if child is not in the
//     notebook.
func (notebook *Notebook) PageNum(child Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_notebook_page_num(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PopupDisable disables the popup menu.
func (notebook *Notebook) PopupDisable() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_popup_disable(_arg0)
	runtime.KeepAlive(notebook)
}

// PopupEnable enables the popup menu.
//
// If the user clicks with the right mouse button on the tab labels, a menu with
// all the pages will be popped up.
func (notebook *Notebook) PopupEnable() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_popup_enable(_arg0)
	runtime.KeepAlive(notebook)
}

// PrependPage prepends a page to notebook.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to use as the contents of the page.
//   - tabLabel (optional) to be used as the label for the page, or NULL to use
//     the default label, “page N”.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the prepended page in the notebook,
//     or -1 if function fails.
func (notebook *Notebook) PrependPage(child, tabLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}

	_cret = C.gtk_notebook_prepend_page(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PrependPageMenu prepends a page to notebook, specifying the widget to use as
// the label in the popup menu.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to use as the contents of the page.
//   - tabLabel (optional): GtkWidget to be used as the label for the page,
//     or NULL to use the default label, “page N”.
//   - menuLabel (optional): widget to use as a label for the page-switch menu,
//     if that is enabled. If NULL, and tab_label is a Label or NULL, then the
//     menu label will be a newly created label with the same text as tab_label;
//     if tab_label is not a Label, menu_label must be specified if the
//     page-switch menu is to be used.
//
// The function returns the following values:
//
//   - gint: index (starting from 0) of the prepended page in the notebook,
//     or -1 if function fails.
func (notebook *Notebook) PrependPageMenu(child, tabLabel, menuLabel Widgetter) int {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out
	var _arg3 *C.GtkWidget   // out
	var _cret C.int          // in

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}
	if menuLabel != nil {
		_arg3 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}

	_cret = C.gtk_notebook_prepend_page_menu(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
	runtime.KeepAlive(menuLabel)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PrevPage switches to the previous page.
//
// Nothing happens if the current page is the first page.
func (notebook *Notebook) PrevPage() {
	var _arg0 *C.GtkNotebook // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))

	C.gtk_notebook_prev_page(_arg0)
	runtime.KeepAlive(notebook)
}

// RemovePage removes a page from the notebook given its index in the notebook.
//
// The function takes the following parameters:
//
//   - pageNum: index of a notebook page, starting from 0. If -1, the last page
//     will be removed.
func (notebook *Notebook) RemovePage(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.int(pageNum)

	C.gtk_notebook_remove_page(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pageNum)
}

// ReorderChild reorders the page containing child, so that it appears in
// position position.
//
// If position is greater than or equal to the number of children in the list or
// negative, child will be moved to the end of the list.
//
// The function takes the following parameters:
//
//   - child to move.
//   - position: new position, or -1 to move to the end.
func (notebook *Notebook) ReorderChild(child Widgetter, position int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(position)

	C.gtk_notebook_reorder_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(position)
}

// SetActionWidget sets widget as one of the action widgets.
//
// Depending on the pack type the widget will be placed before or after the
// tabs. You can use a GtkBox if you need to pack more than one widget on the
// same side.
//
// The function takes the following parameters:
//
//   - widget: Widget.
//   - packType: pack type of the action widget.
func (notebook *Notebook) SetActionWidget(widget Widgetter, packType PackType) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.GtkPackType  // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = C.GtkPackType(packType)

	C.gtk_notebook_set_action_widget(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(packType)
}

// SetCurrentPage switches to the page number page_num.
//
// Note that due to historical reasons, GtkNotebook refuses to switch to a page
// unless the child widget is visible. Therefore, it is recommended to show
// child widgets before adding them to a notebook.
//
// The function takes the following parameters:
//
//   - pageNum: index of the page to switch to, starting from 0. If negative,
//     the last page will be used. If greater than the number of pages in the
//     notebook, nothing will be done.
func (notebook *Notebook) SetCurrentPage(pageNum int) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.int(pageNum)

	C.gtk_notebook_set_current_page(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pageNum)
}

// SetGroupName sets a group name for notebook.
//
// Notebooks with the same name will be able to exchange tabs via drag and drop.
// A notebook with a NULL group name will not be able to exchange tabs with any
// other notebook.
//
// The function takes the following parameters:
//
//   - groupName (optional): name of the notebook group, or NULL to unset it.
func (notebook *Notebook) SetGroupName(groupName string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if groupName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_notebook_set_group_name(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(groupName)
}

// SetMenuLabel changes the menu label for the page containing child.
//
// The function takes the following parameters:
//
//   - child widget.
//   - menuLabel (optional): menu label, or NULL for default.
func (notebook *Notebook) SetMenuLabel(child, menuLabel Widgetter) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if menuLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(menuLabel).Native()))
	}

	C.gtk_notebook_set_menu_label(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(menuLabel)
}

// SetMenuLabelText creates a new label and sets it as the menu label of child.
//
// The function takes the following parameters:
//
//   - child widget.
//   - menuText: label text.
func (notebook *Notebook) SetMenuLabelText(child Widgetter, menuText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.char        // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(menuText)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_menu_label_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(menuText)
}

// SetScrollable sets whether the tab label area will have arrows for scrolling
// if there are too many tabs to fit in the area.
//
// The function takes the following parameters:
//
//   - scrollable: TRUE if scroll arrows should be added.
func (notebook *Notebook) SetScrollable(scrollable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if scrollable {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_scrollable(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(scrollable)
}

// SetShowBorder sets whether a bevel will be drawn around the notebook pages.
//
// This only has a visual effect when the tabs are not shown.
//
// The function takes the following parameters:
//
//   - showBorder: TRUE if a bevel should be drawn around the notebook.
func (notebook *Notebook) SetShowBorder(showBorder bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if showBorder {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_border(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(showBorder)
}

// SetShowTabs sets whether to show the tabs for the notebook or not.
//
// The function takes the following parameters:
//
//   - showTabs: TRUE if the tabs should be shown.
func (notebook *Notebook) SetShowTabs(showTabs bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	if showTabs {
		_arg1 = C.TRUE
	}

	C.gtk_notebook_set_show_tabs(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(showTabs)
}

// SetTabDetachable sets whether the tab can be detached from notebook to
// another notebook or widget.
//
// Note that two notebooks must share a common group identificator (see
// gtk.Notebook.SetGroupName()) to allow automatic tabs interchange between
// them.
//
// If you want a widget to interact with a notebook through DnD (i.e.:
// accept dragged tabs from it) it must be set as a drop destination and accept
// the target “GTK_NOTEBOOK_TAB”. The notebook will fill the selection with a
// GtkWidget** pointing to the child widget that corresponds to the dropped tab.
//
// Note that you should use gtk.Notebook.DetachTab() instead of
// gtk.Notebook.RemovePage() if you want to remove the tab from the source
// notebook as part of accepting a drop. Otherwise, the source notebook will
// think that the dragged tab was removed from underneath the ongoing drag
// operation, and will initiate a drag cancel animation.
//
//	static void
//	on_drag_data_received (GtkWidget        *widget,
//	                       GdkDrop          *drop,
//	                       GtkSelectionData *data,
//	                       guint             time,
//	                       gpointer          user_data)
//	{
//	  GtkDrag *drag;
//	  GtkWidget *notebook;
//	  GtkWidget **child;
//
//	  drag = gtk_drop_get_drag (drop);
//	  notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
//	  child = (void*) gtk_selection_data_get_data (data);
//
//	  // process_widget (*child);
//
//	  gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
//	}
//
// If you want a notebook to accept drags from other widgets, you will have to
// set your own DnD code to do it.
//
// The function takes the following parameters:
//
//   - child GtkWidget.
//   - detachable: whether the tab is detachable or not.
func (notebook *Notebook) SetTabDetachable(child Widgetter, detachable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if detachable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(detachable)
}

// SetTabLabel changes the tab label for child.
//
// If NULL is specified for tab_label, then the page will have the label “page
// N”.
//
// The function takes the following parameters:
//
//   - child: page.
//   - tabLabel (optional): tab label widget to use, or NULL for default tab
//     label.
func (notebook *Notebook) SetTabLabel(child, tabLabel Widgetter) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkWidget   // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if tabLabel != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(tabLabel).Native()))
	}

	C.gtk_notebook_set_tab_label(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabLabel)
}

// SetTabLabelText creates a new label and sets it as the tab label for the page
// containing child.
//
// The function takes the following parameters:
//
//   - child: page.
//   - tabText: label text.
func (notebook *Notebook) SetTabLabelText(child Widgetter, tabText string) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.char        // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(tabText)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_notebook_set_tab_label_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(tabText)
}

// SetTabPos sets the edge at which the tabs are drawn.
//
// The function takes the following parameters:
//
//   - pos: edge to draw the tabs at.
func (notebook *Notebook) SetTabPos(pos PositionType) {
	var _arg0 *C.GtkNotebook    // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = C.GtkPositionType(pos)

	C.gtk_notebook_set_tab_pos(_arg0, _arg1)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(pos)
}

// SetTabReorderable sets whether the notebook tab can be reordered via drag and
// drop or not.
//
// The function takes the following parameters:
//
//   - child GtkWidget.
//   - reorderable: whether the tab is reorderable or not.
func (notebook *Notebook) SetTabReorderable(child Widgetter, reorderable bool) {
	var _arg0 *C.GtkNotebook // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.gboolean     // out

	_arg0 = (*C.GtkNotebook)(unsafe.Pointer(coreglib.InternObject(notebook).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if reorderable {
		_arg2 = C.TRUE
	}

	C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(notebook)
	runtime.KeepAlive(child)
	runtime.KeepAlive(reorderable)
}

// NotebookPage: GtkNotebookPage is an auxiliary object used by GtkNotebook.
type NotebookPage struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*NotebookPage)(nil)
)

func wrapNotebookPage(obj *coreglib.Object) *NotebookPage {
	return &NotebookPage{
		Object: obj,
	}
}

func marshalNotebookPage(p uintptr) (interface{}, error) {
	return wrapNotebookPage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Child returns the notebook child to which page belongs.
//
// The function returns the following values:
//
//   - widget: child to which page belongs.
func (page *NotebookPage) Child() Widgetter {
	var _arg0 *C.GtkNotebookPage // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkNotebookPage)(unsafe.Pointer(coreglib.InternObject(page).Native()))

	_cret = C.gtk_notebook_page_get_child(_arg0)
	runtime.KeepAlive(page)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// NothingAction: GtkShortcutAction that does nothing.
type NothingAction struct {
	_ [0]func() // equal guard
	ShortcutAction
}

var (
	_ ShortcutActioner = (*NothingAction)(nil)
)

func wrapNothingAction(obj *coreglib.Object) *NothingAction {
	return &NothingAction{
		ShortcutAction: ShortcutAction{
			Object: obj,
		},
	}
}

func marshalNothingAction(p uintptr) (interface{}, error) {
	return wrapNothingAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NothingActionGet gets the nothing action.
//
// This is an action that does nothing and where activating it always fails.
//
// The function returns the following values:
//
//   - nothingAction: nothing action.
func NothingActionGet() *NothingAction {
	var _cret *C.GtkShortcutAction // in

	_cret = C.gtk_nothing_action_get()

	var _nothingAction *NothingAction // out

	_nothingAction = wrapNothingAction(coreglib.Take(unsafe.Pointer(_cret)))

	return _nothingAction
}

// NumericSorterOverrides contains methods that are overridable.
type NumericSorterOverrides struct {
}

func defaultNumericSorterOverrides(v *NumericSorter) NumericSorterOverrides {
	return NumericSorterOverrides{}
}

// NumericSorter: GtkNumericSorter is a GtkSorter that compares numbers.
//
// To obtain the numbers to compare, this sorter evaluates a gtk.Expression.
type NumericSorter struct {
	_ [0]func() // equal guard
	Sorter
}

var (
	_ coreglib.Objector = (*NumericSorter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*NumericSorter, *NumericSorterClass, NumericSorterOverrides](
		GTypeNumericSorter,
		initNumericSorterClass,
		wrapNumericSorter,
		defaultNumericSorterOverrides,
	)
}

func initNumericSorterClass(gclass unsafe.Pointer, overrides NumericSorterOverrides, classInitFunc func(*NumericSorterClass)) {
	if classInitFunc != nil {
		class := (*NumericSorterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapNumericSorter(obj *coreglib.Object) *NumericSorter {
	return &NumericSorter{
		Sorter: Sorter{
			Object: obj,
		},
	}
}

func marshalNumericSorter(p uintptr) (interface{}, error) {
	return wrapNumericSorter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewNumericSorter creates a new numeric sorter using the given expression.
//
// Smaller numbers will be sorted first. You can call
// gtk.NumericSorter.SetSortOrder() to change this.
//
// The function takes the following parameters:
//
//   - expression (optional) to evaluate.
//
// The function returns the following values:
//
//   - numericSorter: new GtkNumericSorter.
func NewNumericSorter(expression Expressioner) *NumericSorter {
	var _arg1 *C.GtkExpression    // out
	var _cret *C.GtkNumericSorter // in

	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}

	_cret = C.gtk_numeric_sorter_new(_arg1)
	runtime.KeepAlive(expression)

	var _numericSorter *NumericSorter // out

	_numericSorter = wrapNumericSorter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _numericSorter
}

// Expression gets the expression that is evaluated to obtain numbers from
// items.
//
// The function returns the following values:
//
//   - expression (optional): GtkExpression, or NULL.
func (self *NumericSorter) Expression() Expressioner {
	var _arg0 *C.GtkNumericSorter // out
	var _cret *C.GtkExpression    // in

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_numeric_sorter_get_expression(_arg0)
	runtime.KeepAlive(self)

	var _expression Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// SortOrder gets whether this sorter will sort smaller numbers first.
//
// The function returns the following values:
//
//   - sortType: order of the numbers.
func (self *NumericSorter) SortOrder() SortType {
	var _arg0 *C.GtkNumericSorter // out
	var _cret C.GtkSortType       // in

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_numeric_sorter_get_sort_order(_arg0)
	runtime.KeepAlive(self)

	var _sortType SortType // out

	_sortType = SortType(_cret)

	return _sortType
}

// SetExpression sets the expression that is evaluated to obtain numbers from
// items.
//
// Unless an expression is set on self, the sorter will always compare items as
// invalid.
//
// The expression must have a return type that can be compared numerically,
// such as G_TYPE_INT or G_TYPE_DOUBLE.
//
// The function takes the following parameters:
//
//   - expression (optional): GtkExpression, or NULL.
func (self *NumericSorter) SetExpression(expression Expressioner) {
	var _arg0 *C.GtkNumericSorter // out
	var _arg1 *C.GtkExpression    // out

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
	}

	C.gtk_numeric_sorter_set_expression(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expression)
}

// SetSortOrder sets whether to sort smaller numbers before larger ones.
//
// The function takes the following parameters:
//
//   - sortOrder: whether to sort smaller numbers first.
func (self *NumericSorter) SetSortOrder(sortOrder SortType) {
	var _arg0 *C.GtkNumericSorter // out
	var _arg1 C.GtkSortType       // out

	_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkSortType(sortOrder)

	C.gtk_numeric_sorter_set_sort_order(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sortOrder)
}

// ObjectExpression: GObject value in a GtkExpression.
type ObjectExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*ObjectExpression)(nil)
)

func wrapObjectExpression(obj *coreglib.Object) *ObjectExpression {
	return &ObjectExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalObjectExpression(p uintptr) (interface{}, error) {
	return wrapObjectExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewObjectExpression creates an expression evaluating to the given object with
// a weak reference.
//
// Once the object is disposed, it will fail to evaluate.
//
// This expression is meant to break reference cycles.
//
// If you want to keep a reference to object, use gtk.ConstantExpression.New.
//
// The function takes the following parameters:
//
//   - object to watch.
//
// The function returns the following values:
//
//   - objectExpression: new GtkExpression.
func NewObjectExpression(object *coreglib.Object) *ObjectExpression {
	var _arg1 *C.GObject       // out
	var _cret *C.GtkExpression // in

	_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))

	_cret = C.gtk_object_expression_new(_arg1)
	runtime.KeepAlive(object)

	var _objectExpression *ObjectExpression // out

	_objectExpression = wrapObjectExpression(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _objectExpression
}

// Object gets the object that the expression evaluates to.
//
// The function returns the following values:
//
//   - object (optional): object, or NULL.
func (expression *ObjectExpression) Object() *coreglib.Object {
	var _arg0 *C.GtkExpression // out
	var _cret *C.GObject       // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))

	_cret = C.gtk_object_expression_get_object(_arg0)
	runtime.KeepAlive(expression)

	var _object *coreglib.Object // out

	if _cret != nil {
		_object = coreglib.Take(unsafe.Pointer(_cret))
	}

	return _object
}

// Overlay: GtkOverlay is a container which contains a single main child,
// on top of which it can place “overlay” widgets.
//
// !An example GtkOverlay (overlay.png)
//
// The position of each overlay widget is determined by its gtk.Widget:halign
// and gtk.Widget:valign properties. E.g. a widget with both alignments set
// to GTK_ALIGN_START will be placed at the top left corner of the GtkOverlay
// container, whereas an overlay with halign set to GTK_ALIGN_CENTER and valign
// set to GTK_ALIGN_END will be placed a the bottom edge of the GtkOverlay,
// horizontally centered. The position can be adjusted by setting the margin
// properties of the child to non-zero values.
//
// More complicated placement of overlays is possible by connecting to the
// gtk.Overlay::get-child-position signal.
//
// An overlay’s minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
//
// # GtkOverlay as GtkBuildable
//
// The GtkOverlay implementation of the GtkBuildable interface supports placing
// a child as an overlay by specifying “overlay” as the “type” attribute of a
// <child> element.
//
// # CSS nodes
//
// GtkOverlay has a single CSS node with the name “overlay”. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// “.left”, “.right”, “.top”, and/or “.bottom” according to their position.
type Overlay struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Overlay)(nil)
)

func wrapOverlay(obj *coreglib.Object) *Overlay {
	return &Overlay{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalOverlay(p uintptr) (interface{}, error) {
	return wrapOverlay(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectGetChildPosition is emitted to determine the position and size of any
// overlay child widgets.
//
// A handler for this signal should fill allocation with the desired position
// and size for widget, relative to the 'main' child of overlay.
//
// The default handler for this signal uses the widget's halign and valign
// properties to determine the position and gives the widget its natural size
// (except that an alignment of GTK_ALIGN_FILL will cause the overlay to be
// full-width/height). If the main child is a GtkScrolledWindow, the overlays
// are placed relative to its contents.
func (overlay *Overlay) ConnectGetChildPosition(f func(widget Widgetter) (allocation *gdk.Rectangle, ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(overlay, "get-child-position", false, unsafe.Pointer(C._gotk4_gtk4_Overlay_ConnectGetChildPosition), f)
}

// NewOverlay creates a new GtkOverlay.
//
// The function returns the following values:
//
//   - overlay: new GtkOverlay object.
func NewOverlay() *Overlay {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_overlay_new()

	var _overlay *Overlay // out

	_overlay = wrapOverlay(coreglib.Take(unsafe.Pointer(_cret)))

	return _overlay
}

// AddOverlay adds widget to overlay.
//
// The widget will be stacked on top of the main widget added with
// gtk.Overlay.SetChild().
//
// The position at which widget is placed is determined from its
// gtk.Widget:halign and gtk.Widget:valign properties.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget to be added to the container.
func (overlay *Overlay) AddOverlay(widget Widgetter) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_overlay_add_overlay(_arg0, _arg1)
	runtime.KeepAlive(overlay)
	runtime.KeepAlive(widget)
}

// Child gets the child widget of overlay.
//
// The function returns the following values:
//
//   - widget (optional): child widget of overlay.
func (overlay *Overlay) Child() Widgetter {
	var _arg0 *C.GtkOverlay // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))

	_cret = C.gtk_overlay_get_child(_arg0)
	runtime.KeepAlive(overlay)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ClipOverlay gets whether widget should be clipped within the parent.
//
// The function takes the following parameters:
//
//   - widget: overlay child of GtkOverlay.
//
// The function returns the following values:
//
//   - ok: whether the widget is clipped within the parent.
func (overlay *Overlay) ClipOverlay(widget Widgetter) bool {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_overlay_get_clip_overlay(_arg0, _arg1)
	runtime.KeepAlive(overlay)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MeasureOverlay gets whether widget's size is included in the measurement of
// overlay.
//
// The function takes the following parameters:
//
//   - widget: overlay child of GtkOverlay.
//
// The function returns the following values:
//
//   - ok: whether the widget is measured.
func (overlay *Overlay) MeasureOverlay(widget Widgetter) bool {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_overlay_get_measure_overlay(_arg0, _arg1)
	runtime.KeepAlive(overlay)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveOverlay removes an overlay that was added with
// gtk_overlay_add_overlay().
//
// The function takes the following parameters:
//
//   - widget: GtkWidget to be removed.
func (overlay *Overlay) RemoveOverlay(widget Widgetter) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_overlay_remove_overlay(_arg0, _arg1)
	runtime.KeepAlive(overlay)
	runtime.KeepAlive(widget)
}

// SetChild sets the child widget of overlay.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (overlay *Overlay) SetChild(child Widgetter) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_overlay_set_child(_arg0, _arg1)
	runtime.KeepAlive(overlay)
	runtime.KeepAlive(child)
}

// SetClipOverlay sets whether widget should be clipped within the parent.
//
// The function takes the following parameters:
//
//   - widget: overlay child of GtkOverlay.
//   - clipOverlay: whether the child should be clipped.
func (overlay *Overlay) SetClipOverlay(widget Widgetter, clipOverlay bool) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if clipOverlay {
		_arg2 = C.TRUE
	}

	C.gtk_overlay_set_clip_overlay(_arg0, _arg1, _arg2)
	runtime.KeepAlive(overlay)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(clipOverlay)
}

// SetMeasureOverlay sets whether widget is included in the measured size of
// overlay.
//
// The overlay will request the size of the largest child that has this property
// set to TRUE. Children who are not included may be drawn outside of overlay's
// allocation if they are too large.
//
// The function takes the following parameters:
//
//   - widget: overlay child of GtkOverlay.
//   - measure: whether the child should be measured.
func (overlay *Overlay) SetMeasureOverlay(widget Widgetter, measure bool) {
	var _arg0 *C.GtkOverlay // out
	var _arg1 *C.GtkWidget  // out
	var _arg2 C.gboolean    // out

	_arg0 = (*C.GtkOverlay)(unsafe.Pointer(coreglib.InternObject(overlay).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if measure {
		_arg2 = C.TRUE
	}

	C.gtk_overlay_set_measure_overlay(_arg0, _arg1, _arg2)
	runtime.KeepAlive(overlay)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(measure)
}

// OverlayLayoutOverrides contains methods that are overridable.
type OverlayLayoutOverrides struct {
}

func defaultOverlayLayoutOverrides(v *OverlayLayout) OverlayLayoutOverrides {
	return OverlayLayoutOverrides{}
}

// OverlayLayout: GtkOverlayLayout is the layout manager used by GtkOverlay.
//
// It places widgets as overlays on top of the main child.
//
// This is not a reusable layout manager, since it expects its widget to be a
// GtkOverlay. It only listed here so that its layout properties get documented.
type OverlayLayout struct {
	_ [0]func() // equal guard
	LayoutManager
}

var (
	_ LayoutManagerer = (*OverlayLayout)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*OverlayLayout, *OverlayLayoutClass, OverlayLayoutOverrides](
		GTypeOverlayLayout,
		initOverlayLayoutClass,
		wrapOverlayLayout,
		defaultOverlayLayoutOverrides,
	)
}

func initOverlayLayoutClass(gclass unsafe.Pointer, overrides OverlayLayoutOverrides, classInitFunc func(*OverlayLayoutClass)) {
	if classInitFunc != nil {
		class := (*OverlayLayoutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapOverlayLayout(obj *coreglib.Object) *OverlayLayout {
	return &OverlayLayout{
		LayoutManager: LayoutManager{
			Object: obj,
		},
	}
}

func marshalOverlayLayout(p uintptr) (interface{}, error) {
	return wrapOverlayLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewOverlayLayout creates a new GtkOverlayLayout instance.
//
// The function returns the following values:
//
//   - overlayLayout: newly created instance.
func NewOverlayLayout() *OverlayLayout {
	var _cret *C.GtkLayoutManager // in

	_cret = C.gtk_overlay_layout_new()

	var _overlayLayout *OverlayLayout // out

	_overlayLayout = wrapOverlayLayout(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _overlayLayout
}

// OverlayLayoutChildOverrides contains methods that are overridable.
type OverlayLayoutChildOverrides struct {
}

func defaultOverlayLayoutChildOverrides(v *OverlayLayoutChild) OverlayLayoutChildOverrides {
	return OverlayLayoutChildOverrides{}
}

// OverlayLayoutChild: GtkLayoutChild subclass for children in a
// GtkOverlayLayout.
type OverlayLayoutChild struct {
	_ [0]func() // equal guard
	LayoutChild
}

var (
	_ LayoutChilder = (*OverlayLayoutChild)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*OverlayLayoutChild, *OverlayLayoutChildClass, OverlayLayoutChildOverrides](
		GTypeOverlayLayoutChild,
		initOverlayLayoutChildClass,
		wrapOverlayLayoutChild,
		defaultOverlayLayoutChildOverrides,
	)
}

func initOverlayLayoutChildClass(gclass unsafe.Pointer, overrides OverlayLayoutChildOverrides, classInitFunc func(*OverlayLayoutChildClass)) {
	if classInitFunc != nil {
		class := (*OverlayLayoutChildClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapOverlayLayoutChild(obj *coreglib.Object) *OverlayLayoutChild {
	return &OverlayLayoutChild{
		LayoutChild: LayoutChild{
			Object: obj,
		},
	}
}

func marshalOverlayLayoutChild(p uintptr) (interface{}, error) {
	return wrapOverlayLayoutChild(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ClipOverlay retrieves whether the child is clipped.
//
// The function returns the following values:
//
//   - ok: whether the child is clipped.
func (child *OverlayLayoutChild) ClipOverlay() bool {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_overlay_layout_child_get_clip_overlay(_arg0)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Measure retrieves whether the child is measured.
//
// The function returns the following values:
//
//   - ok: whether the child is measured.
func (child *OverlayLayoutChild) Measure() bool {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_overlay_layout_child_get_measure(_arg0)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetClipOverlay sets whether to clip this child.
//
// The function takes the following parameters:
//
//   - clipOverlay: whether to clip this child.
func (child *OverlayLayoutChild) SetClipOverlay(clipOverlay bool) {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if clipOverlay {
		_arg1 = C.TRUE
	}

	C.gtk_overlay_layout_child_set_clip_overlay(_arg0, _arg1)
	runtime.KeepAlive(child)
	runtime.KeepAlive(clipOverlay)
}

// SetMeasure sets whether to measure this child.
//
// The function takes the following parameters:
//
//   - measure: whether to measure this child.
func (child *OverlayLayoutChild) SetMeasure(measure bool) {
	var _arg0 *C.GtkOverlayLayoutChild // out
	var _arg1 C.gboolean               // out

	_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if measure {
		_arg1 = C.TRUE
	}

	C.gtk_overlay_layout_child_set_measure(_arg0, _arg1)
	runtime.KeepAlive(child)
	runtime.KeepAlive(measure)
}

// PadController: GtkPadController is an event controller for the pads found in
// drawing tablets.
//
// Pads are the collection of buttons and tactile sensors often found around the
// stylus-sensitive area.
//
// These buttons and sensors have no implicit meaning, and by default they
// perform no action. GtkPadController is provided to map those to GAction
// objects, thus letting the application give them a more semantic meaning.
//
// Buttons and sensors are not constrained to triggering a single action,
// some GDK_SOURCE_TABLET_PAD devices feature multiple "modes". All these input
// elements have one current mode, which may determine the final action being
// triggered.
//
// Pad devices often divide buttons and sensors into groups. All elements in a
// group share the same current mode, but different groups may have different
// modes. See gdk.DevicePad.GetNGroups() and gdk.DevicePad.GetGroupNModes().
//
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by a gtk.PadActionEntry. It contains an action name that will be
// looked up in the given GActionGroup and activated whenever the specified
// input element and mode are triggered.
//
// A simple example of GtkPadController usage: Assigning button 1 in all modes
// and pad devices to an "invert-selection" action:
//
//	GtkPadActionEntry *pad_actions[] = {
//	  { GTK_PAD_ACTION_BUTTON, 1, -1, "Invert selection", "pad-actions.invert-selection" },
//	  …
//	};
//
//	…
//	action_group = g_simple_action_group_new ();
//	action = g_simple_action_new ("pad-actions.invert-selection", NULL);
//	g_signal_connect (action, "activate", on_invert_selection_activated, NULL);
//	g_action_map_add_action (G_ACTION_MAP (action_group), action);
//	…
//	pad_controller = gtk_pad_controller_new (action_group, NULL);
//
// The actions belonging to rings/strips will be activated with a parameter
// of type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this GVariantType.
type PadController struct {
	_ [0]func() // equal guard
	EventController
}

var (
	_ EventControllerer = (*PadController)(nil)
)

func wrapPadController(obj *coreglib.Object) *PadController {
	return &PadController{
		EventController: EventController{
			Object: obj,
		},
	}
}

func marshalPadController(p uintptr) (interface{}, error) {
	return wrapPadController(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPadController creates a new GtkPadController that will associate events
// from pad to actions.
//
// A NULL pad may be provided so the controller manages all pad devices
// generically, it is discouraged to mix GtkPadController objects with NULL and
// non-NULL pad argument on the same toplevel window, as execution order is not
// guaranteed.
//
// The GtkPadController is created with no mapped actions. In order to
// map pad events to actions, use gtk.PadController.SetActionEntries() or
// gtk.PadController.SetAction().
//
// Be aware that pad events will only be delivered to GtkWindows, so adding a
// pad controller to any other type of widget will not have an effect.
//
// The function takes the following parameters:
//
//   - group: GActionGroup to trigger actions from.
//   - pad (optional): GDK_SOURCE_TABLET_PAD device, or NULL to handle all pads.
//
// The function returns the following values:
//
//   - padController: newly created GtkPadController.
func NewPadController(group gio.ActionGrouper, pad gdk.Devicer) *PadController {
	var _arg1 *C.GActionGroup     // out
	var _arg2 *C.GdkDevice        // out
	var _cret *C.GtkPadController // in

	_arg1 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	if pad != nil {
		_arg2 = (*C.GdkDevice)(unsafe.Pointer(coreglib.InternObject(pad).Native()))
	}

	_cret = C.gtk_pad_controller_new(_arg1, _arg2)
	runtime.KeepAlive(group)
	runtime.KeepAlive(pad)

	var _padController *PadController // out

	_padController = wrapPadController(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _padController
}

// SetAction adds an individual action to controller.
//
// This action will only be activated if the given button/ring/strip number in
// index is interacted while the current mode is mode. -1 may be used for simple
// cases, so the action is triggered on all modes.
//
// The given label should be considered user-visible, so internationalization
// rules apply. Some windowing systems may be able to use those for user
// feedback.
//
// The function takes the following parameters:
//
//   - typ: type of pad feature that will trigger this action.
//   - index: 0-indexed button/ring/strip number that will trigger this action.
//   - mode that will trigger this action, or -1 for all modes.
//   - label: human readable description of this action, this string should be
//     deemed user-visible.
//   - actionName: action name that will be activated in the Group.
func (controller *PadController) SetAction(typ PadActionType, index, mode int, label, actionName string) {
	var _arg0 *C.GtkPadController // out
	var _arg1 C.GtkPadActionType  // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 *C.char             // out
	var _arg5 *C.char             // out

	_arg0 = (*C.GtkPadController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg1 = C.GtkPadActionType(typ)
	_arg2 = C.int(index)
	_arg3 = C.int(mode)
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg4))
	_arg5 = (*C.char)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg5))

	C.gtk_pad_controller_set_action(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(index)
	runtime.KeepAlive(mode)
	runtime.KeepAlive(label)
	runtime.KeepAlive(actionName)
}

// SetActionEntries: convenience function to add a group of action entries on
// controller.
//
// See gtk.PadActionEntry and gtk.PadController.SetAction().
//
// The function takes the following parameters:
//
//   - entries: action entries to set on controller.
func (controller *PadController) SetActionEntries(entries []PadActionEntry) {
	var _arg0 *C.GtkPadController  // out
	var _arg1 *C.GtkPadActionEntry // out
	var _arg2 C.int

	_arg0 = (*C.GtkPadController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	_arg2 = (C.int)(len(entries))
	_arg1 = (*C.GtkPadActionEntry)(C.calloc(C.size_t(len(entries)), C.size_t(C.sizeof_GtkPadActionEntry)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GtkPadActionEntry)(_arg1), len(entries))
		for i := range entries {
			out[i] = *(*C.GtkPadActionEntry)(gextras.StructNative(unsafe.Pointer((&entries[i]))))
		}
	}

	C.gtk_pad_controller_set_action_entries(_arg0, _arg1, _arg2)
	runtime.KeepAlive(controller)
	runtime.KeepAlive(entries)
}

// PageSetup: GtkPageSetup object stores the page size, orientation and margins.
//
// The idea is that you can get one of these from the page setup dialog and then
// pass it to the GtkPrintOperation when printing. The benefit of splitting this
// out of the GtkPrintSettings is that these affect the actual layout of the
// page, and thus need to be set long before user prints.
//
// # Margins
//
// The margins specified in this object are the “print margins”, i.e.
// the parts of the page that the printer cannot print on. These are different
// from the layout margins that a word processor uses; they are typically used
// to determine the minimal size for the layout margins.
//
// To obtain a GtkPageSetup use gtk.PageSetup.New to get the defaults, or use
// gtk.PrintRunPageSetupDialog() to show the page setup dialog and receive the
// resulting page setup.
//
// A page setup dialog
//
//	static GtkPrintSettings *settings = NULL;
//	static GtkPageSetup *page_setup = NULL;
//
//	static void
//	do_page_setup (void)
//	{
//	  GtkPageSetup *new_page_setup;
//
//	  if (settings == NULL)
//	    settings = gtk_print_settings_new ();
//
//	  new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//	                                                    page_setup, settings);
//
//	  if (page_setup)
//	    g_object_unref (page_setup);
//
//	  page_setup = new_page_setup;
//	}.
type PageSetup struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PageSetup)(nil)
)

func wrapPageSetup(obj *coreglib.Object) *PageSetup {
	return &PageSetup{
		Object: obj,
	}
}

func marshalPageSetup(p uintptr) (interface{}, error) {
	return wrapPageSetup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPageSetup creates a new GtkPageSetup.
//
// The function returns the following values:
//
//   - pageSetup: new GtkPageSetup.
func NewPageSetup() *PageSetup {
	var _cret *C.GtkPageSetup // in

	_cret = C.gtk_page_setup_new()

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// NewPageSetupFromFile reads the page setup from the file file_name.
//
// Returns a new GtkPageSetup object with the restored page setup, or NULL if an
// error occurred. See gtk.PageSetup.ToFile().
//
// The function takes the following parameters:
//
//   - fileName: filename to read the page setup from.
//
// The function returns the following values:
//
//   - pageSetup: restored GtkPageSetup.
func NewPageSetupFromFile(fileName string) (*PageSetup, error) {
	var _arg1 *C.char         // out
	var _cret *C.GtkPageSetup // in
	var _cerr *C.GError       // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_page_setup_new_from_file(_arg1, &_cerr)
	runtime.KeepAlive(fileName)

	var _pageSetup *PageSetup // out
	var _goerr error          // out

	_pageSetup = wrapPageSetup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pageSetup, _goerr
}

// NewPageSetupFromGVariant: desrialize a page setup from an a{sv} variant.
//
// The variant must be in the format produced by gtk.PageSetup.ToGVariant().
//
// The function takes the following parameters:
//
//   - variant: a{sv} GVariant.
//
// The function returns the following values:
//
//   - pageSetup: new GtkPageSetup object.
func NewPageSetupFromGVariant(variant *glib.Variant) *PageSetup {
	var _arg1 *C.GVariant     // out
	var _cret *C.GtkPageSetup // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(variant)))

	_cret = C.gtk_page_setup_new_from_gvariant(_arg1)
	runtime.KeepAlive(variant)

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// NewPageSetupFromKeyFile reads the page setup from the group group_name in the
// key file key_file.
//
// Returns a new GtkPageSetup object with the restored page setup, or NULL if an
// error occurred.
//
// The function takes the following parameters:
//
//   - keyFile: GKeyFile to retrieve the page_setup from.
//   - groupName (optional): name of the group in the key_file to read, or NULL
//     to use the default name “Page Setup”.
//
// The function returns the following values:
//
//   - pageSetup: restored GtkPageSetup.
func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PageSetup, error) {
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out
	var _cret *C.GtkPageSetup // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_page_setup_new_from_key_file(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _pageSetup *PageSetup // out
	var _goerr error          // out

	_pageSetup = wrapPageSetup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pageSetup, _goerr
}

// Copy copies a GtkPageSetup.
//
// The function returns the following values:
//
//   - pageSetup: copy of other.
func (other *PageSetup) Copy() *PageSetup {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GtkPageSetup // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(other).Native()))

	_cret = C.gtk_page_setup_copy(_arg0)
	runtime.KeepAlive(other)

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _pageSetup
}

// BottomMargin gets the bottom margin in units of unit.
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: bottom margin.
func (setup *PageSetup) BottomMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_bottom_margin(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// LeftMargin gets the left margin in units of unit.
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: left margin.
func (setup *PageSetup) LeftMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_left_margin(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Orientation gets the page orientation of the GtkPageSetup.
//
// The function returns the following values:
//
//   - pageOrientation: page orientation.
func (setup *PageSetup) Orientation() PageOrientation {
	var _arg0 *C.GtkPageSetup      // out
	var _cret C.GtkPageOrientation // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))

	_cret = C.gtk_page_setup_get_orientation(_arg0)
	runtime.KeepAlive(setup)

	var _pageOrientation PageOrientation // out

	_pageOrientation = PageOrientation(_cret)

	return _pageOrientation
}

// PageHeight returns the page height in units of unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk.PageSetup.GetPaperHeight().
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: page height.
func (setup *PageSetup) PageHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_page_height(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PageWidth returns the page width in units of unit.
//
// Note that this function takes orientation and margins into consideration.
// See gtk.PageSetup.GetPaperWidth().
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: page width.
func (setup *PageSetup) PageWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_page_width(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PaperHeight returns the paper height in units of unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk.PageSetup.GetPageHeight().
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: paper height.
func (setup *PageSetup) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_paper_height(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PaperSize gets the paper size of the GtkPageSetup.
//
// The function returns the following values:
//
//   - paperSize: paper size.
func (setup *PageSetup) PaperSize() *PaperSize {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GtkPaperSize // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))

	_cret = C.gtk_page_setup_get_paper_size(_arg0)
	runtime.KeepAlive(setup)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _paperSize
}

// PaperWidth returns the paper width in units of unit.
//
// Note that this function takes orientation, but not margins into
// consideration. See gtk.PageSetup.GetPageWidth().
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: paper width.
func (setup *PageSetup) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_paper_width(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// RightMargin gets the right margin in units of unit.
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: right margin.
func (setup *PageSetup) RightMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_right_margin(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// TopMargin gets the top margin in units of unit.
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: top margin.
func (setup *PageSetup) TopMargin(unit Unit) float64 {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_page_setup_get_top_margin(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// LoadFile reads the page setup from the file file_name.
//
// See gtk.PageSetup.ToFile().
//
// The function takes the following parameters:
//
//   - fileName: filename to read the page setup from.
func (setup *PageSetup) LoadFile(fileName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_page_setup_load_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(fileName)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadKeyFile reads the page setup from the group group_name in the key file
// key_file.
//
// The function takes the following parameters:
//
//   - keyFile: GKeyFile to retrieve the page_setup from.
//   - groupName (optional): name of the group in the key_file to read, or NULL
//     to use the default name “Page Setup”.
func (setup *PageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_page_setup_load_key_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetBottomMargin sets the bottom margin of the GtkPageSetup.
//
// The function takes the following parameters:
//
//   - margin: new bottom margin in units of unit.
//   - unit units for margin.
func (setup *PageSetup) SetBottomMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.double(margin)
	_arg2 = C.GtkUnit(unit)

	C.gtk_page_setup_set_bottom_margin(_arg0, _arg1, _arg2)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(margin)
	runtime.KeepAlive(unit)
}

// SetLeftMargin sets the left margin of the GtkPageSetup.
//
// The function takes the following parameters:
//
//   - margin: new left margin in units of unit.
//   - unit units for margin.
func (setup *PageSetup) SetLeftMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.double(margin)
	_arg2 = C.GtkUnit(unit)

	C.gtk_page_setup_set_left_margin(_arg0, _arg1, _arg2)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(margin)
	runtime.KeepAlive(unit)
}

// SetOrientation sets the page orientation of the GtkPageSetup.
//
// The function takes the following parameters:
//
//   - orientation: PageOrientation value.
func (setup *PageSetup) SetOrientation(orientation PageOrientation) {
	var _arg0 *C.GtkPageSetup      // out
	var _arg1 C.GtkPageOrientation // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.GtkPageOrientation(orientation)

	C.gtk_page_setup_set_orientation(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(orientation)
}

// SetPaperSize sets the paper size of the GtkPageSetup without changing the
// margins.
//
// See gtk.PageSetup.SetPaperSizeAndDefaultMargins().
//
// The function takes the following parameters:
//
//   - size: PaperSize.
func (setup *PageSetup) SetPaperSize(size *PaperSize) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))

	C.gtk_page_setup_set_paper_size(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(size)
}

// SetPaperSizeAndDefaultMargins sets the paper size of the GtkPageSetup and
// modifies the margins according to the new paper size.
//
// The function takes the following parameters:
//
//   - size: PaperSize.
func (setup *PageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GtkPaperSize // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))

	C.gtk_page_setup_set_paper_size_and_default_margins(_arg0, _arg1)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(size)
}

// SetRightMargin sets the right margin of the GtkPageSetup.
//
// The function takes the following parameters:
//
//   - margin: new right margin in units of unit.
//   - unit units for margin.
func (setup *PageSetup) SetRightMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.double(margin)
	_arg2 = C.GtkUnit(unit)

	C.gtk_page_setup_set_right_margin(_arg0, _arg1, _arg2)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(margin)
	runtime.KeepAlive(unit)
}

// SetTopMargin sets the top margin of the GtkPageSetup.
//
// The function takes the following parameters:
//
//   - margin: new top margin in units of unit.
//   - unit units for margin.
func (setup *PageSetup) SetTopMargin(margin float64, unit Unit) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 C.double        // out
	var _arg2 C.GtkUnit       // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = C.double(margin)
	_arg2 = C.GtkUnit(unit)

	C.gtk_page_setup_set_top_margin(_arg0, _arg1, _arg2)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(margin)
	runtime.KeepAlive(unit)
}

// ToFile: this function saves the information from setup to file_name.
//
// The function takes the following parameters:
//
//   - fileName: file to save to.
func (setup *PageSetup) ToFile(fileName string) error {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.char         // out
	var _cerr *C.GError       // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_page_setup_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(fileName)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ToGVariant: serialize page setup to an a{sv} variant.
//
// The function returns the following values:
//
//   - variant: new, floating, #GVariant.
func (setup *PageSetup) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkPageSetup // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))

	_cret = C.gtk_page_setup_to_gvariant(_arg0)
	runtime.KeepAlive(setup)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// ToKeyFile: this function adds the page setup from setup to key_file.
//
// The function takes the following parameters:
//
//   - keyFile: GKeyFile to save the page setup to.
//   - groupName (optional): group to add the settings to in key_file, or NULL
//     to use the default name “Page Setup”.
func (setup *PageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPageSetup // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out

	_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_page_setup_to_key_file(_arg0, _arg1, _arg2)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
}

// Paned: GtkPaned has two panes, arranged either horizontally or vertically.
//
// !An example GtkPaned (panes.png)
//
// The division between the two panes is adjustable by the user by dragging a
// handle.
//
// Child widgets are added to the panes of the widget with
// gtk.Paned.SetStartChild() and gtk.Paned.SetEndChild(). The division between
// the two children is set by default from the size requests of the children,
// but it can be adjusted by the user.
//
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a gtk.Frame so that the gutter appears as a ridge. No separator is drawn if
// one of the children is missing.
//
// Each child has two options that can be set, resize and shrink. If resize is
// true, then when the GtkPaned is resized, that child will expand or shrink
// along with the paned widget. If shrink is true, then that child can be made
// smaller than its requisition by the user. Setting shrink to FALSE allows the
// application to set a minimum size. If resize is false for both children,
// then this is treated as if resize is true for both children.
//
// The application can set the position of the slider as if it were set by the
// user, by calling gtk.Paned.SetPosition().
//
// CSS nodes
//
//	paned
//	├── <child>
//	├── separator[.wide]
//	╰── <child>
//
// GtkPaned has a main CSS node with name paned, and a subnode for the separator
// with name separator. The subnode gets a .wide style class when the paned is
// supposed to be wide.
//
// In horizontal orientation, the nodes are arranged based on the text
// direction, so in left-to-right mode, :first-child will select the leftmost
// child, while it will select the rightmost child in RTL layouts.
//
// Creating a paned widget with minimum sizes.
//
//	GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL);
//	GtkWidget *frame1 = gtk_frame_new (NULL);
//	GtkWidget *frame2 = gtk_frame_new (NULL);
//
//	gtk_widget_set_size_request (hpaned, 200, -1);
//
//	gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
//	gtk_paned_set_start_child_resize (GTK_PANED (hpaned), TRUE);
//	gtk_paned_set_start_child_shrink (GTK_PANED (hpaned), FALSE);
//	gtk_widget_set_size_request (frame1, 50, -1);
//
//	gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
//	gtk_paned_set_end_child_resize (GTK_PANED (hpaned), FALSE);
//	gtk_paned_set_end_child_shrink (GTK_PANED (hpaned), FALSE);
//	gtk_widget_set_size_request (frame2, 50, -1);.
type Paned struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*Paned)(nil)
	_ coreglib.Objector = (*Paned)(nil)
)

func wrapPaned(obj *coreglib.Object) *Paned {
	return &Paned{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalPaned(p uintptr) (interface{}, error) {
	return wrapPaned(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAcceptPosition is emitted to accept the current position of the handle
// when moving it using key bindings.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is Return or Space.
func (paned *Paned) ConnectAcceptPosition(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paned, "accept-position", false, unsafe.Pointer(C._gotk4_gtk4_Paned_ConnectAcceptPosition), f)
}

// ConnectCancelPosition is emitted to cancel moving the position of the handle
// using key bindings.
//
// The position of the handle will be reset to the value prior to moving it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is Escape.
func (paned *Paned) ConnectCancelPosition(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paned, "cancel-position", false, unsafe.Pointer(C._gotk4_gtk4_Paned_ConnectCancelPosition), f)
}

// ConnectCycleChildFocus is emitted to cycle the focus between the children of
// the paned.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding is F6.
func (paned *Paned) ConnectCycleChildFocus(f func(reversed bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paned, "cycle-child-focus", false, unsafe.Pointer(C._gotk4_gtk4_Paned_ConnectCycleChildFocus), f)
}

// ConnectCycleHandleFocus is emitted to cycle whether the paned should grab
// focus to allow the user to change position of the handle by using key
// bindings.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is F8.
func (paned *Paned) ConnectCycleHandleFocus(f func(reversed bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paned, "cycle-handle-focus", false, unsafe.Pointer(C._gotk4_gtk4_Paned_ConnectCycleHandleFocus), f)
}

// ConnectMoveHandle is emitted to move the handle with key bindings.
//
// This is a keybinding signal (class.SignalAction.html).
func (paned *Paned) ConnectMoveHandle(f func(scrollType ScrollType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paned, "move-handle", false, unsafe.Pointer(C._gotk4_gtk4_Paned_ConnectMoveHandle), f)
}

// ConnectToggleHandleFocus is emitted to accept the current position of the
// handle and then move focus to the next widget in the focus chain.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding is Tab.
func (paned *Paned) ConnectToggleHandleFocus(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(paned, "toggle-handle-focus", false, unsafe.Pointer(C._gotk4_gtk4_Paned_ConnectToggleHandleFocus), f)
}

// NewPaned creates a new GtkPaned widget.
//
// The function takes the following parameters:
//
//   - orientation paned’s orientation.
//
// The function returns the following values:
//
//   - paned: new GtkPaned.
func NewPaned(orientation Orientation) *Paned {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_paned_new(_arg1)
	runtime.KeepAlive(orientation)

	var _paned *Paned // out

	_paned = wrapPaned(coreglib.Take(unsafe.Pointer(_cret)))

	return _paned
}

// EndChild retrieves the end child of the given GtkPaned.
//
// See also: GtkPaned:end-child.
//
// The function returns the following values:
//
//   - widget (optional): end child widget.
func (paned *Paned) EndChild() Widgetter {
	var _arg0 *C.GtkPaned  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_end_child(_arg0)
	runtime.KeepAlive(paned)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Position obtains the position of the divider between the two panes.
//
// The function returns the following values:
//
//   - gint: position of the divider.
func (paned *Paned) Position() int {
	var _arg0 *C.GtkPaned // out
	var _cret C.int       // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_position(_arg0)
	runtime.KeepAlive(paned)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ResizeEndChild returns whether the end child can be resized.
//
// The function returns the following values:
//
//   - ok: TRUE if the end child is resizable.
func (paned *Paned) ResizeEndChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_resize_end_child(_arg0)
	runtime.KeepAlive(paned)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResizeStartChild returns whether the start child can be resized.
//
// The function returns the following values:
//
//   - ok: TRUE if the start child is resizable.
func (paned *Paned) ResizeStartChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_resize_start_child(_arg0)
	runtime.KeepAlive(paned)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShrinkEndChild returns whether the end child can be shrunk.
//
// The function returns the following values:
//
//   - ok: TRUE if the end child is shrinkable.
func (paned *Paned) ShrinkEndChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_shrink_end_child(_arg0)
	runtime.KeepAlive(paned)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShrinkStartChild returns whether the start child can be shrunk.
//
// The function returns the following values:
//
//   - ok: TRUE if the start child is shrinkable.
func (paned *Paned) ShrinkStartChild() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_shrink_start_child(_arg0)
	runtime.KeepAlive(paned)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartChild retrieves the start child of the given GtkPaned.
//
// See also: GtkPaned:start-child.
//
// The function returns the following values:
//
//   - widget (optional): start child widget.
func (paned *Paned) StartChild() Widgetter {
	var _arg0 *C.GtkPaned  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_start_child(_arg0)
	runtime.KeepAlive(paned)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// WideHandle gets whether the separator should be wide.
//
// The function returns the following values:
//
//   - ok: TRUE if the paned should have a wide handle.
func (paned *Paned) WideHandle() bool {
	var _arg0 *C.GtkPaned // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))

	_cret = C.gtk_paned_get_wide_handle(_arg0)
	runtime.KeepAlive(paned)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetEndChild sets the end child of paned to child.
//
// The function takes the following parameters:
//
//   - child: widget to add.
func (paned *Paned) SetEndChild(child Widgetter) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_paned_set_end_child(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(child)
}

// SetPosition sets the position of the divider between the two panes.
//
// The function takes the following parameters:
//
//   - position: pixel position of divider, a negative value means that the
//     position is unset.
func (paned *Paned) SetPosition(position int) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	_arg1 = C.int(position)

	C.gtk_paned_set_position(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(position)
}

// SetResizeEndChild sets the GtkPaned:resize-end-child property.
//
// The function takes the following parameters:
//
//   - resize: TRUE to let the end child be resized.
func (paned *Paned) SetResizeEndChild(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_resize_end_child(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(resize)
}

// SetResizeStartChild sets the GtkPaned:resize-start-child property.
//
// The function takes the following parameters:
//
//   - resize: TRUE to let the start child be resized.
func (paned *Paned) SetResizeStartChild(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_resize_start_child(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(resize)
}

// SetShrinkEndChild sets the GtkPaned:shrink-end-child property.
//
// The function takes the following parameters:
//
//   - resize: TRUE to let the end child be shrunk.
func (paned *Paned) SetShrinkEndChild(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_shrink_end_child(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(resize)
}

// SetShrinkStartChild sets the GtkPaned:shrink-start-child property.
//
// The function takes the following parameters:
//
//   - resize: TRUE to let the start child be shrunk.
func (paned *Paned) SetShrinkStartChild(resize bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	if resize {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_shrink_start_child(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(resize)
}

// SetStartChild sets the start child of paned to child.
//
// The function takes the following parameters:
//
//   - child: widget to add.
func (paned *Paned) SetStartChild(child Widgetter) {
	var _arg0 *C.GtkPaned  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_paned_set_start_child(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(child)
}

// SetWideHandle sets whether the separator should be wide.
//
// The function takes the following parameters:
//
//   - wide: new value for the gtk.Paned:wide-handle property.
func (paned *Paned) SetWideHandle(wide bool) {
	var _arg0 *C.GtkPaned // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkPaned)(unsafe.Pointer(coreglib.InternObject(paned).Native()))
	if wide {
		_arg1 = C.TRUE
	}

	C.gtk_paned_set_wide_handle(_arg0, _arg1)
	runtime.KeepAlive(paned)
	runtime.KeepAlive(wide)
}

// PasswordEntry: GtkPasswordEntry is an entry that has been tailored for
// entering secrets.
//
// !An example GtkPasswordEntry (password-entry.png)
//
// It does not show its contents in clear text, does not allow to copy it to
// the clipboard, and it shows a warning when Caps Lock is engaged. If the
// underlying platform allows it, GtkPasswordEntry will also place the text in
// a non-pageable memory area, to avoid it being written out to disk by the
// operating system.
//
// Optionally, it can offer a way to reveal the contents in clear text.
//
// GtkPasswordEntry provides only minimal API and should be used with the
// gtk.Editable API.
//
// CSS Nodes
//
//	entry.password
//	╰── text
//	    ├── image.caps-lock-indicator
//	    ┊
//
// GtkPasswordEntry has a single CSS node with name entry that carries a
// .passwordstyle class. The text Css node below it has a child with name image
// and style class .caps-lock-indicator for the Caps Lock icon, and possibly
// other children.
//
// # Accessibility
//
// GtkPasswordEntry uses the GTK_ACCESSIBLE_ROLE_TEXT_BOX role.
type PasswordEntry struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	EditableTextWidget
}

var (
	_ Widgetter         = (*PasswordEntry)(nil)
	_ coreglib.Objector = (*PasswordEntry)(nil)
)

func wrapPasswordEntry(obj *coreglib.Object) *PasswordEntry {
	return &PasswordEntry{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		EditableTextWidget: EditableTextWidget{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalPasswordEntry(p uintptr) (interface{}, error) {
	return wrapPasswordEntry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when the entry is activated.
//
// The keybindings for this signal are all forms of the Enter key.
func (entry *PasswordEntry) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "activate", false, unsafe.Pointer(C._gotk4_gtk4_PasswordEntry_ConnectActivate), f)
}

// NewPasswordEntry creates a GtkPasswordEntry.
//
// The function returns the following values:
//
//   - passwordEntry: new GtkPasswordEntry.
func NewPasswordEntry() *PasswordEntry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_password_entry_new()

	var _passwordEntry *PasswordEntry // out

	_passwordEntry = wrapPasswordEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _passwordEntry
}

// ExtraMenu gets the menu model set with gtk_password_entry_set_extra_menu().
//
// The function returns the following values:
//
//   - menuModel: (nullable): the menu model.
func (entry *PasswordEntry) ExtraMenu() gio.MenuModeller {
	var _arg0 *C.GtkPasswordEntry // out
	var _cret *C.GMenuModel       // in

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_password_entry_get_extra_menu(_arg0)
	runtime.KeepAlive(entry)

	var _menuModel gio.MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.MenuModeller)
			return ok
		})
		rv, ok := casted.(gio.MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// ShowPeekIcon returns whether the entry is showing an icon to reveal the
// contents.
//
// The function returns the following values:
//
//   - ok: TRUE if an icon is shown.
func (entry *PasswordEntry) ShowPeekIcon() bool {
	var _arg0 *C.GtkPasswordEntry // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_password_entry_get_show_peek_icon(_arg0)
	runtime.KeepAlive(entry)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// entry.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel.
func (entry *PasswordEntry) SetExtraMenu(model gio.MenuModeller) {
	var _arg0 *C.GtkPasswordEntry // out
	var _arg1 *C.GMenuModel       // out

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_password_entry_set_extra_menu(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(model)
}

// SetShowPeekIcon sets whether the entry should have a clickable icon to reveal
// the contents.
//
// Setting this to FALSE also hides the text again.
//
// The function takes the following parameters:
//
//   - showPeekIcon: whether to show the peek icon.
func (entry *PasswordEntry) SetShowPeekIcon(showPeekIcon bool) {
	var _arg0 *C.GtkPasswordEntry // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if showPeekIcon {
		_arg1 = C.TRUE
	}

	C.gtk_password_entry_set_show_peek_icon(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(showPeekIcon)
}

// PictureOverrides contains methods that are overridable.
type PictureOverrides struct {
}

func defaultPictureOverrides(v *Picture) PictureOverrides {
	return PictureOverrides{}
}

// Picture: GtkPicture widget displays a GdkPaintable.
//
// !An example GtkPicture (picture.png)
//
// Many convenience functions are provided to make pictures simple to use.
// For example, if you want to load an image from a file, and then display it,
// there’s a convenience function to do this:
//
//	GtkWidget *widget = gtk_picture_new_for_filename ("myfile.png");
//
// If the file isn’t loaded successfully, the picture will contain a “broken
// image” icon similar to that used in many web browsers. If you want to handle
// errors in loading the file yourself, for example by displaying an error
// message, then load the image with gdk.Texture.NewFromFile, then create the
// GtkPicture with gtk.Picture.NewForPaintable.
//
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of GResource for details.
// In this case, gtk.Picture.NewForResource and gtk.Picture.SetResource() should
// be used.
//
// GtkPicture displays an image at its natural size. See gtk.Image if you want
// to display a fixed-size image, such as an icon.
//
// # Sizing the paintable
//
// You can influence how the paintable is displayed inside the GtkPicture. By
// turning off gtk.Picture:keep-aspect-ratio you can allow the paintable to get
// stretched. gtk.Picture:can-shrink can be unset to make sure that paintables
// are never made smaller than their ideal size - but be careful if you do not
// know the size of the paintable in use (like when displaying user-loaded
// images). This can easily cause the picture to grow larger than the screen.
// And gtkwidget:halign and gtkwidget:valign can be used to make sure the
// paintable doesn't fill all available space but is instead displayed at its
// original size.
//
// # CSS nodes
//
// GtkPicture has a single CSS node with the name picture.
//
// # Accessibility
//
// GtkPicture uses the GTK_ACCESSIBLE_ROLE_IMG role.
type Picture struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Picture)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Picture, *PictureClass, PictureOverrides](
		GTypePicture,
		initPictureClass,
		wrapPicture,
		defaultPictureOverrides,
	)
}

func initPictureClass(gclass unsafe.Pointer, overrides PictureOverrides, classInitFunc func(*PictureClass)) {
	if classInitFunc != nil {
		class := (*PictureClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPicture(obj *coreglib.Object) *Picture {
	return &Picture{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalPicture(p uintptr) (interface{}, error) {
	return wrapPicture(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPicture creates a new empty GtkPicture widget.
//
// The function returns the following values:
//
//   - picture: newly created GtkPicture widget.
func NewPicture() *Picture {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_picture_new()

	var _picture *Picture // out

	_picture = wrapPicture(coreglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForFile creates a new GtkPicture displaying the given file.
//
// If the file isn’t found or can’t be loaded, the resulting GtkPicture is
// empty.
//
// If you need to detect failures to load the file, use gdk.Texture.NewFromFile
// to load the file yourself, then create the GtkPicture from the texture.
//
// The function takes the following parameters:
//
//   - file (optional): GFile.
//
// The function returns the following values:
//
//   - picture: new GtkPicture.
func NewPictureForFile(file gio.Filer) *Picture {
	var _arg1 *C.GFile     // out
	var _cret *C.GtkWidget // in

	if file != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}

	_cret = C.gtk_picture_new_for_file(_arg1)
	runtime.KeepAlive(file)

	var _picture *Picture // out

	_picture = wrapPicture(coreglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForFilename creates a new GtkPicture displaying the file filename.
//
// This is a utility function that calls gtk.Picture.NewForFile. See that
// function for details.
//
// The function takes the following parameters:
//
//   - filename (optional): filename.
//
// The function returns the following values:
//
//   - picture: new GtkPicture.
func NewPictureForFilename(filename string) *Picture {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if filename != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_picture_new_for_filename(_arg1)
	runtime.KeepAlive(filename)

	var _picture *Picture // out

	_picture = wrapPicture(coreglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForPaintable creates a new GtkPicture displaying paintable.
//
// The GtkPicture will track changes to the paintable and update its size and
// contents in response to it.
//
// The function takes the following parameters:
//
//   - paintable (optional): GdkPaintable, or NULL.
//
// The function returns the following values:
//
//   - picture: new GtkPicture.
func NewPictureForPaintable(paintable gdk.Paintabler) *Picture {
	var _arg1 *C.GdkPaintable // out
	var _cret *C.GtkWidget    // in

	if paintable != nil {
		_arg1 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	}

	_cret = C.gtk_picture_new_for_paintable(_arg1)
	runtime.KeepAlive(paintable)

	var _picture *Picture // out

	_picture = wrapPicture(coreglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForPixbuf creates a new GtkPicture displaying pixbuf.
//
// This is a utility function that calls gtk.Picture.NewForPaintable, See that
// function for details.
//
// The pixbuf must not be modified after passing it to this function.
//
// The function takes the following parameters:
//
//   - pixbuf (optional): GdkPixbuf, or NULL.
//
// The function returns the following values:
//
//   - picture: new GtkPicture.
func NewPictureForPixbuf(pixbuf *gdkpixbuf.Pixbuf) *Picture {
	var _arg1 *C.GdkPixbuf // out
	var _cret *C.GtkWidget // in

	if pixbuf != nil {
		_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	}

	_cret = C.gtk_picture_new_for_pixbuf(_arg1)
	runtime.KeepAlive(pixbuf)

	var _picture *Picture // out

	_picture = wrapPicture(coreglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// NewPictureForResource creates a new GtkPicture displaying the resource at
// resource_path.
//
// This is a utility function that calls gtk.Picture.NewForFile. See that
// function for details.
//
// The function takes the following parameters:
//
//   - resourcePath (optional): resource path to play back.
//
// The function returns the following values:
//
//   - picture: new GtkPicture.
func NewPictureForResource(resourcePath string) *Picture {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if resourcePath != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_picture_new_for_resource(_arg1)
	runtime.KeepAlive(resourcePath)

	var _picture *Picture // out

	_picture = wrapPicture(coreglib.Take(unsafe.Pointer(_cret)))

	return _picture
}

// AlternativeText gets the alternative textual description of the picture.
//
// The returned string will be NULL if the picture cannot be described
// textually.
//
// The function returns the following values:
//
//   - utf8 (optional): alternative textual description of self.
func (self *Picture) AlternativeText() string {
	var _arg0 *C.GtkPicture // out
	var _cret *C.char       // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_picture_get_alternative_text(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// CanShrink returns whether the GtkPicture respects its contents size.
//
// The function returns the following values:
//
//   - ok: TRUE if the picture can be made smaller than its contents.
func (self *Picture) CanShrink() bool {
	var _arg0 *C.GtkPicture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_picture_get_can_shrink(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// File gets the GFile currently displayed if self is displaying a file.
//
// If self is not displaying a file, for example when gtk.Picture.SetPaintable()
// was used, then NULL is returned.
//
// The function returns the following values:
//
//   - file (optional): GFile displayed by self.
func (self *Picture) File() *gio.File {
	var _arg0 *C.GtkPicture // out
	var _cret *C.GFile      // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_picture_get_file(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_file = &gio.File{
				Object: obj,
			}
		}
	}

	return _file
}

// KeepAspectRatio returns whether the GtkPicture preserves its contents aspect
// ratio.
//
// The function returns the following values:
//
//   - ok: TRUE if the self tries to keep the contents' aspect ratio.
func (self *Picture) KeepAspectRatio() bool {
	var _arg0 *C.GtkPicture // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_picture_get_keep_aspect_ratio(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Paintable gets the GdkPaintable being displayed by the GtkPicture.
//
// The function returns the following values:
//
//   - paintable (optional): displayed paintable, or NULL if the picture is
//     empty.
func (self *Picture) Paintable() *gdk.Paintable {
	var _arg0 *C.GtkPicture   // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_picture_get_paintable(_arg0)
	runtime.KeepAlive(self)

	var _paintable *gdk.Paintable // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_paintable = &gdk.Paintable{
				Object: obj,
			}
		}
	}

	return _paintable
}

// SetAlternativeText sets an alternative textual description for the picture
// contents.
//
// It is equivalent to the "alt" attribute for images on websites.
//
// This text will be made available to accessibility tools.
//
// If the picture cannot be described textually, set this property to NULL.
//
// The function takes the following parameters:
//
//   - alternativeText (optional): textual description of the contents.
func (self *Picture) SetAlternativeText(alternativeText string) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if alternativeText != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(alternativeText)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_picture_set_alternative_text(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(alternativeText)
}

// SetCanShrink: if set to TRUE, the self can be made smaller than its contents.
//
// The contents will then be scaled down when rendering.
//
// If you want to still force a minimum size manually, consider using
// gtk.Widget.SetSizeRequest().
//
// Also of note is that a similar function for growing does not exist
// because the grow behavior can be controlled via gtk.Widget.SetHAlign() and
// gtk.Widget.SetVAlign().
//
// The function takes the following parameters:
//
//   - canShrink: if self can be made smaller than its contents.
func (self *Picture) SetCanShrink(canShrink bool) {
	var _arg0 *C.GtkPicture // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if canShrink {
		_arg1 = C.TRUE
	}

	C.gtk_picture_set_can_shrink(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canShrink)
}

// SetFile makes self load and display file.
//
// See gtk.Picture.NewForFile for details.
//
// The function takes the following parameters:
//
//   - file (optional): GFile or NULL.
func (self *Picture) SetFile(file gio.Filer) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.GFile      // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if file != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}

	C.gtk_picture_set_file(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(file)
}

// SetFilename makes self load and display the given filename.
//
// This is a utility function that calls gtk.Picture.SetFile().
//
// The function takes the following parameters:
//
//   - filename (optional) to play.
func (self *Picture) SetFilename(filename string) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if filename != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_picture_set_filename(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(filename)
}

// SetKeepAspectRatio: if set to TRUE, the self will render its contents
// according to their aspect ratio.
//
// That means that empty space may show up at the top/bottom or left/right of
// self.
//
// If set to FALSE or if the contents provide no aspect ratio, the contents will
// be stretched over the picture's whole area.
//
// The function takes the following parameters:
//
//   - keepAspectRatio: whether to keep aspect ratio.
func (self *Picture) SetKeepAspectRatio(keepAspectRatio bool) {
	var _arg0 *C.GtkPicture // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if keepAspectRatio {
		_arg1 = C.TRUE
	}

	C.gtk_picture_set_keep_aspect_ratio(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(keepAspectRatio)
}

// SetPaintable makes self display the given paintable.
//
// If paintable is NULL, nothing will be displayed.
//
// See gtk.Picture.NewForPaintable for details.
//
// The function takes the following parameters:
//
//   - paintable (optional): GdkPaintable or NULL.
func (self *Picture) SetPaintable(paintable gdk.Paintabler) {
	var _arg0 *C.GtkPicture   // out
	var _arg1 *C.GdkPaintable // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if paintable != nil {
		_arg1 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	}

	C.gtk_picture_set_paintable(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(paintable)
}

// SetPixbuf sets a GtkPicture to show a GdkPixbuf.
//
// See gtk.Picture.NewForPixbuf for details.
//
// This is a utility function that calls gtk.Picture.SetPaintable().
//
// The function takes the following parameters:
//
//   - pixbuf (optional): GdkPixbuf or NULL.
func (self *Picture) SetPixbuf(pixbuf *gdkpixbuf.Pixbuf) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.GdkPixbuf  // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if pixbuf != nil {
		_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(coreglib.InternObject(pixbuf).Native()))
	}

	C.gtk_picture_set_pixbuf(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(pixbuf)
}

// SetResource makes self load and display the resource at the given
// resource_path.
//
// This is a utility function that calls gtk.Picture.SetFile().
//
// The function takes the following parameters:
//
//   - resourcePath (optional): resource to set.
func (self *Picture) SetResource(resourcePath string) {
	var _arg0 *C.GtkPicture // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkPicture)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if resourcePath != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_picture_set_resource(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(resourcePath)
}

// PopoverOverrides contains methods that are overridable.
type PopoverOverrides struct {
	ActivateDefault func()
	Closed          func()
}

func defaultPopoverOverrides(v *Popover) PopoverOverrides {
	return PopoverOverrides{
		ActivateDefault: v.activateDefault,
		Closed:          v.closed,
	}
}

// Popover: GtkPopover is a bubble-like context popup.
//
// !An example GtkPopover (popover.png)
//
// It is primarily meant to provide context-dependent information or options.
// Popovers are attached to a parent widget. By default, they point to
// the whole widget area, although this behavior can be changed with
// gtk.Popover.SetPointingTo().
//
// The position of a popover relative to the widget it is attached to can also
// be changed with gtk.Popover.SetPosition()
//
// By default, GtkPopover performs a grab, in order to ensure input events get
// redirected to it while it is shown, and also so the popover is dismissed
// in the expected situations (clicks outside the popover, or the Escape
// key being pressed). If no such modal behavior is desired on a popover,
// gtk.Popover.SetAutohide() may be called on it to tweak its behavior.
//
// # GtkPopover as menu replacement
//
// GtkPopover is often used to replace menus. The best was to do this is to use
// the gtk.PopoverMenu subclass which supports being populated from a GMenuModel
// with gtk.PopoverMenu.NewFromModel.
//
//	<section>
//	  <attribute name="display-hint">horizontal-buttons</attribute>
//	  <item>
//	    <attribute name="label">Cut</attribute>
//	    <attribute name="action">app.cut</attribute>
//	    <attribute name="verb-icon">edit-cut-symbolic</attribute>
//	  </item>
//	  <item>
//	    <attribute name="label">Copy</attribute>
//	    <attribute name="action">app.copy</attribute>
//	    <attribute name="verb-icon">edit-copy-symbolic</attribute>
//	  </item>
//	  <item>
//	    <attribute name="label">Paste</attribute>
//	    <attribute name="action">app.paste</attribute>
//	    <attribute name="verb-icon">edit-paste-symbolic</attribute>
//	  </item>
//	</section>
//
// CSS nodes
//
//	popover[.menu]
//	├── arrow
//	╰── contents.background
//	    ╰── <child>
//
// The contents child node always gets the .background style class and the
// popover itself gets the .menu style class if the popover is menu-like (i.e.
// GtkPopoverMenu).
//
// Particular uses of GtkPopover, such as touch selection popups or magnifiers
// in GtkEntry or GtkTextView get style classes like .touch-selection or
// .magnifier to differentiate from plain popovers.
//
// When styling a popover directly, the popover node should usually not have any
// background. The visible part of the popover can have a shadow. To specify it
// in CSS, set the box-shadow of the contents node.
//
// Note that, in order to accomplish appropriate arrow visuals, GtkPopover uses
// custom drawing for the arrow node. This makes it possible for the arrow to
// change its shape dynamically, but it also limits the possibilities of styling
// it using CSS. In particular, the arrow gets drawn over the content node's
// border and shadow, so they look like one shape, which means that the border
// width of the content node and the arrow node should be the same. The arrow
// also does not support any border shape other than solid, no border-radius,
// only one border width (border-bottom-width is used) and no box-shadow.
type Popover struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	NativeSurface
	ShortcutManager
}

var (
	_ Widgetter         = (*Popover)(nil)
	_ coreglib.Objector = (*Popover)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Popover, *PopoverClass, PopoverOverrides](
		GTypePopover,
		initPopoverClass,
		wrapPopover,
		defaultPopoverOverrides,
	)
}

func initPopoverClass(gclass unsafe.Pointer, overrides PopoverOverrides, classInitFunc func(*PopoverClass)) {
	pclass := (*C.GtkPopoverClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypePopover))))

	if overrides.ActivateDefault != nil {
		pclass.activate_default = (*[0]byte)(C._gotk4_gtk4_PopoverClass_activate_default)
	}

	if overrides.Closed != nil {
		pclass.closed = (*[0]byte)(C._gotk4_gtk4_PopoverClass_closed)
	}

	if classInitFunc != nil {
		class := (*PopoverClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPopover(obj *coreglib.Object) *Popover {
	return &Popover{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		NativeSurface: NativeSurface{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
		ShortcutManager: ShortcutManager{
			Object: obj,
		},
	}
}

func marshalPopover(p uintptr) (interface{}, error) {
	return wrapPopover(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateDefault is emitted whend the user activates the default
// widget.
//
// This is a keybinding signal (class.SignalAction.html).
func (popover *Popover) ConnectActivateDefault(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(popover, "activate-default", false, unsafe.Pointer(C._gotk4_gtk4_Popover_ConnectActivateDefault), f)
}

// ConnectClosed is emitted when the popover is closed.
func (popover *Popover) ConnectClosed(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(popover, "closed", false, unsafe.Pointer(C._gotk4_gtk4_Popover_ConnectClosed), f)
}

// NewPopover creates a new GtkPopover.
//
// The function returns the following values:
//
//   - popover: new GtkPopover.
func NewPopover() *Popover {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_popover_new()

	var _popover *Popover // out

	_popover = wrapPopover(coreglib.Take(unsafe.Pointer(_cret)))

	return _popover
}

// Autohide returns whether the popover is modal.
//
// See gtk.Popover.SetAutohide() for the implications of this.
//
// The function returns the following values:
//
//   - ok: TRUE if popover is modal.
func (popover *Popover) Autohide() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_get_autohide(_arg0)
	runtime.KeepAlive(popover)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CascadePopdown returns whether the popover will close after a modal child is
// closed.
//
// The function returns the following values:
//
//   - ok: TRUE if popover will close after a modal child.
func (popover *Popover) CascadePopdown() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_get_cascade_popdown(_arg0)
	runtime.KeepAlive(popover)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Child gets the child widget of popover.
//
// The function returns the following values:
//
//   - widget (optional): child widget of popover.
func (popover *Popover) Child() Widgetter {
	var _arg0 *C.GtkPopover // out
	var _cret *C.GtkWidget  // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_get_child(_arg0)
	runtime.KeepAlive(popover)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// HasArrow gets whether this popover is showing an arrow pointing at the widget
// that it is relative to.
//
// The function returns the following values:
//
//   - ok: whether the popover has an arrow.
func (popover *Popover) HasArrow() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_get_has_arrow(_arg0)
	runtime.KeepAlive(popover)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MnemonicsVisible gets whether mnemonics are visible.
//
// The function returns the following values:
//
//   - ok: TRUE if mnemonics are supposed to be visible in this popover.
func (popover *Popover) MnemonicsVisible() bool {
	var _arg0 *C.GtkPopover // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_get_mnemonics_visible(_arg0)
	runtime.KeepAlive(popover)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Offset gets the offset previous set with gtk_popover_set_offset().
//
// The function returns the following values:
//
//   - xOffset (optional): location for the x_offset.
//   - yOffset (optional): location for the y_offset.
func (popover *Popover) Offset() (xOffset, yOffset int) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.int         // in
	var _arg2 C.int         // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	C.gtk_popover_get_offset(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(popover)

	var _xOffset int // out
	var _yOffset int // out

	_xOffset = int(_arg1)
	_yOffset = int(_arg2)

	return _xOffset, _yOffset
}

// PointingTo gets the rectangle that the popover points to.
//
// If a rectangle to point to has been set, this function will return TRUE and
// fill in rect with such rectangle, otherwise it will return FALSE and fill in
// rect with the parent widget coordinates.
//
// The function returns the following values:
//
//   - rect: location to store the rectangle.
//   - ok: TRUE if a rectangle to point to was set.
func (popover *Popover) PointingTo() (*gdk.Rectangle, bool) {
	var _arg0 *C.GtkPopover  // out
	var _arg1 C.GdkRectangle // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_get_pointing_to(_arg0, &_arg1)
	runtime.KeepAlive(popover)

	var _rect *gdk.Rectangle // out
	var _ok bool             // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _rect, _ok
}

// Position returns the preferred position of popover.
//
// The function returns the following values:
//
//   - positionType: preferred position.
func (popover *Popover) Position() PositionType {
	var _arg0 *C.GtkPopover     // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_get_position(_arg0)
	runtime.KeepAlive(popover)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// Popdown pops popover down.
//
// This is different from a gtk.Widget.Hide() call in that it may show the
// popover with a transition. If you want to hide the popover without a
// transition, just use gtk.Widget.Hide().
func (popover *Popover) Popdown() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	C.gtk_popover_popdown(_arg0)
	runtime.KeepAlive(popover)
}

// Popup pops popover up.
//
// This is different from a gtk.Widget.Show() call in that it may show the
// popover with a transition(). If you want to show the popover without a
// transition, just use [methodGtk.Widget.show.
func (popover *Popover) Popup() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	C.gtk_popover_popup(_arg0)
	runtime.KeepAlive(popover)
}

// Present presents the popover to the user.
func (popover *Popover) Present() {
	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	C.gtk_popover_present(_arg0)
	runtime.KeepAlive(popover)
}

// SetAutohide sets whether popover is modal.
//
// A modal popover will grab the keyboard focus on it when being displayed.
// Clicking outside the popover area or pressing Esc will dismiss the popover.
//
// Called this function on an already showing popup with a new autohide value
// different from the current one, will cause the popup to be hidden.
//
// The function takes the following parameters:
//
//   - autohide: TRUE to dismiss the popover on outside clicks.
func (popover *Popover) SetAutohide(autohide bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	if autohide {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_autohide(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(autohide)
}

// SetCascadePopdown: if cascade_popdown is TRUE, the popover will be closed
// when a child modal popover is closed.
//
// If FALSE, popover will stay visible.
//
// The function takes the following parameters:
//
//   - cascadePopdown: TRUE if the popover should follow a child closing.
func (popover *Popover) SetCascadePopdown(cascadePopdown bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	if cascadePopdown {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_cascade_popdown(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(cascadePopdown)
}

// SetChild sets the child widget of popover.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (popover *Popover) SetChild(child Widgetter) {
	var _arg0 *C.GtkPopover // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_popover_set_child(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(child)
}

// SetDefaultWidget sets the default widget of a GtkPopover.
//
// The default widget is the widget that’s activated when the user presses Enter
// in a dialog (for example). This function sets or unsets the default widget
// for a GtkPopover.
//
// The function takes the following parameters:
//
//   - widget (optional): child widget of popover to set as the default, or NULL
//     to unset the default widget for the popover.
func (popover *Popover) SetDefaultWidget(widget Widgetter) {
	var _arg0 *C.GtkPopover // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_popover_set_default_widget(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(widget)
}

// SetHasArrow sets whether this popover should draw an arrow pointing at the
// widget it is relative to.
//
// The function takes the following parameters:
//
//   - hasArrow: TRUE to draw an arrow.
func (popover *Popover) SetHasArrow(hasArrow bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	if hasArrow {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_has_arrow(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(hasArrow)
}

// SetMnemonicsVisible sets whether mnemonics should be visible.
//
// The function takes the following parameters:
//
//   - mnemonicsVisible: new value.
func (popover *Popover) SetMnemonicsVisible(mnemonicsVisible bool) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	if mnemonicsVisible {
		_arg1 = C.TRUE
	}

	C.gtk_popover_set_mnemonics_visible(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(mnemonicsVisible)
}

// SetOffset sets the offset to use when calculating the position of the
// popover.
//
// These values are used when preparing the gdk.PopupLayout for positioning the
// popover.
//
// The function takes the following parameters:
//
//   - xOffset: x offset to adjust the position by.
//   - yOffset: y offset to adjust the position by.
func (popover *Popover) SetOffset(xOffset, yOffset int) {
	var _arg0 *C.GtkPopover // out
	var _arg1 C.int         // out
	var _arg2 C.int         // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	_arg1 = C.int(xOffset)
	_arg2 = C.int(yOffset)

	C.gtk_popover_set_offset(_arg0, _arg1, _arg2)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(xOffset)
	runtime.KeepAlive(yOffset)
}

// SetPointingTo sets the rectangle that popover points to.
//
// This is in the coordinate space of the popover parent.
//
// The function takes the following parameters:
//
//   - rect: rectangle to point to.
func (popover *Popover) SetPointingTo(rect *gdk.Rectangle) {
	var _arg0 *C.GtkPopover   // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(rect)))

	C.gtk_popover_set_pointing_to(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(rect)
}

// SetPosition sets the preferred position for popover to appear.
//
// If the popover is currently visible, it will be immediately updated.
//
// This preference will be respected where possible, although on lack of space
// (eg. if close to the window edges), the GtkPopover may choose to appear on
// the opposite side.
//
// The function takes the following parameters:
//
//   - position: preferred popover position.
func (popover *Popover) SetPosition(position PositionType) {
	var _arg0 *C.GtkPopover     // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	_arg1 = C.GtkPositionType(position)

	C.gtk_popover_set_position(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(position)
}

func (popover *Popover) activateDefault() {
	gclass := (*C.GtkPopoverClass)(coreglib.PeekParentClass(popover))
	fnarg := gclass.activate_default

	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	C._gotk4_gtk4_Popover_virtual_activate_default(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(popover)
}

func (popover *Popover) closed() {
	gclass := (*C.GtkPopoverClass)(coreglib.PeekParentClass(popover))
	fnarg := gclass.closed

	var _arg0 *C.GtkPopover // out

	_arg0 = (*C.GtkPopover)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	C._gotk4_gtk4_Popover_virtual_closed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(popover)
}

// PopoverMenu: GtkPopoverMenu is a subclass of GtkPopover that implements menu
// behavior.
//
// !An example GtkPopoverMenu (menu.png)
//
// GtkPopoverMenu treats its children like menus and allows switching between
// them. It can open submenus as traditional, nested submenus, or in a more
// touch-friendly sliding fashion.
//
// GtkPopoverMenu is meant to be used primarily with menu models,
// using gtk.PopoverMenu.NewFromModel. If you need to put other widgets
// such as a GtkSpinButton or a GtkSwitch into a popover, you can use
// gtk.PopoverMenu.AddChild().
//
// For more dialog-like behavior, use a plain GtkPopover.
//
// # Menu models
//
// The XML format understood by GtkBuilder for GMenuModel consists of a toplevel
// <menu> element, which contains one or more <item> elements. Each <item>
// element contains <attribute> and <link> elements with a mandatory name
// attribute. <link> elements have the same content model as <menu>. Instead
// of <link name="submenu> or <link name="section">, you can use <submenu> or
// <section> elements.
//
//	<menu id='app-menu'>
//	  <section>
//	    <item>
//	      <attribute name='label' translatable='yes'>_New Window</attribute>
//	      <attribute name='action'>app.new</attribute>
//	    </item>
//	    <item>
//	      <attribute name='label' translatable='yes'>_About Sunny</attribute>
//	      <attribute name='action'>app.about</attribute>
//	    </item>
//	    <item>
//	      <attribute name='label' translatable='yes'>_Quit</attribute>
//	      <attribute name='action'>app.quit</attribute>
//	    </item>
//	  </section>
//	</menu>
//
// Attribute values can be translated using gettext, like other GtkBuilder
// content. <attribute> elements can be marked for translation with a
// translatable="yes" attribute. It is also possible to specify message context
// and translator comments, using the context and comments attributes. To make
// use of this, the Builder must have been given the gettext domain to use.
//
// The following attributes are used when constructing menu items:
//
// - "label": a user-visible string to display
//
// - "action": the prefixed name of the action to trigger
//
// - "target": the parameter to use when activating the action
//
// - "icon" and "verb-icon": names of icons that may be displayed
//
// - "submenu-action": name of an action that may be used to determine if a
// submenu can be opened
//
// - "hidden-when": a string used to determine when the item will be hidden.
// Possible values include "action-disabled", "action-missing", "macos-menubar".
// This is mainly useful for exported menus, see gtk.Application.SetMenubar().
//
// - "custom": a string used to match against the ID of a custom child added
// with gtk.PopoverMenu.AddChild(), gtk.PopoverMenuBar.AddChild(), or in the ui
// file with <child type="ID">.
//
// The following attributes are used when constructing sections:
//
// - "label": a user-visible string to use as section heading
//
// - "display-hint": a string used to determine special formatting for the
// section. Possible values include "horizontal-buttons", "circular-buttons"
// and "inline-buttons". They all indicate that section should be displayed as a
// horizontal row of buttons.
//
// - "text-direction": a string used to determine the GtkTextDirection to use
// when "display-hint" is set to "horizontal-buttons". Possible values include
// "rtl", "ltr", and "none".
//
// The following attributes are used when constructing submenus:
//
// - "label": a user-visible string to display
//
// - "icon": icon name to display
//
// Menu items will also show accelerators, which are usually
// associated with actions via gtk.Application.SetAccelsForAction(),
// gtk_widget_class_add_binding_action or gtk.ShortcutController.AddShortcut().
//
// # CSS Nodes
//
// GtkPopoverMenu is just a subclass of GtkPopover that adds custom content to
// it, therefore it has the same CSS nodes. It is one of the cases that add a
// .menu style class to the popover's main node.
//
// # Accessibility
//
// GtkPopoverMenu uses the GTK_ACCESSIBLE_ROLE_MENU role, and its items use
// the GTK_ACCESSIBLE_ROLE_MENU_ITEM, GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
type PopoverMenu struct {
	_ [0]func() // equal guard
	Popover
}

var (
	_ Widgetter         = (*PopoverMenu)(nil)
	_ coreglib.Objector = (*PopoverMenu)(nil)
)

func wrapPopoverMenu(obj *coreglib.Object) *PopoverMenu {
	return &PopoverMenu{
		Popover: Popover{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			NativeSurface: NativeSurface{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
	}
}

func marshalPopoverMenu(p uintptr) (interface{}, error) {
	return wrapPopoverMenu(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPopoverMenuFromModel creates a GtkPopoverMenu and populates it according
// to model.
//
// The created buttons are connected to actions found in the
// GtkApplicationWindow to which the popover belongs - typically by means of
// being attached to a widget that is contained within the GtkApplicationWindows
// widget hierarchy.
//
// Actions can also be added using gtk.Widget.InsertActionGroup() on the menus
// attach widget or on any of its parent widgets.
//
// This function creates menus with sliding submenus. See
// gtk.PopoverMenu.NewFromModelFull for a way to control this.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel, or NULL.
//
// The function returns the following values:
//
//   - popoverMenu: new GtkPopoverMenu.
func NewPopoverMenuFromModel(model gio.MenuModeller) *PopoverMenu {
	var _arg1 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_popover_menu_new_from_model(_arg1)
	runtime.KeepAlive(model)

	var _popoverMenu *PopoverMenu // out

	_popoverMenu = wrapPopoverMenu(coreglib.Take(unsafe.Pointer(_cret)))

	return _popoverMenu
}

// NewPopoverMenuFromModelFull creates a GtkPopoverMenu and populates it
// according to model.
//
// The created buttons are connected to actions found in the action
// groups that are accessible from the parent widget. This includes the
// GtkApplicationWindow to which the popover belongs. Actions can also be added
// using gtk.Widget.InsertActionGroup() on the parent widget or on any of its
// parent widgets.
//
// The only flag that is supported currently is GTK_POPOVER_MENU_NESTED, which
// makes GTK create traditional, nested submenus instead of the default sliding
// submenus.
//
// The function takes the following parameters:
//
//   - model: GMenuModel.
//   - flags that affect how the menu is created.
//
// The function returns the following values:
//
//   - popoverMenu: new GtkPopoverMenu.
func NewPopoverMenuFromModelFull(model gio.MenuModeller, flags PopoverMenuFlags) *PopoverMenu {
	var _arg1 *C.GMenuModel         // out
	var _arg2 C.GtkPopoverMenuFlags // out
	var _cret *C.GtkWidget          // in

	_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg2 = C.GtkPopoverMenuFlags(flags)

	_cret = C.gtk_popover_menu_new_from_model_full(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(flags)

	var _popoverMenu *PopoverMenu // out

	_popoverMenu = wrapPopoverMenu(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _popoverMenu
}

// AddChild adds a custom widget to a generated menu.
//
// For this to work, the menu model of popover must have an item with a custom
// attribute that matches id.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to add.
//   - id: ID to insert child at.
//
// The function returns the following values:
//
//   - ok: TRUE if id was found and the widget added.
func (popover *PopoverMenu) AddChild(child Widgetter, id string) bool {
	var _arg0 *C.GtkPopoverMenu // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 *C.char           // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_popover_menu_add_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(child)
	runtime.KeepAlive(id)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MenuModel returns the menu model used to populate the popover.
//
// The function returns the following values:
//
//   - menuModel: menu model of popover.
func (popover *PopoverMenu) MenuModel() gio.MenuModeller {
	var _arg0 *C.GtkPopoverMenu // out
	var _cret *C.GMenuModel     // in

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(coreglib.InternObject(popover).Native()))

	_cret = C.gtk_popover_menu_get_menu_model(_arg0)
	runtime.KeepAlive(popover)

	var _menuModel gio.MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.MenuModeller)
			return ok
		})
		rv, ok := casted.(gio.MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_add_child().
//
// The function takes the following parameters:
//
//   - child: GtkWidget to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget was removed.
func (popover *PopoverMenu) RemoveChild(child Widgetter) bool {
	var _arg0 *C.GtkPopoverMenu // out
	var _arg1 *C.GtkWidget      // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_popover_menu_remove_child(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetMenuModel sets a new menu model on popover.
//
// The existing contents of popover are removed, and the popover is populated
// with new contents according to model.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel, or NULL.
func (popover *PopoverMenu) SetMenuModel(model gio.MenuModeller) {
	var _arg0 *C.GtkPopoverMenu // out
	var _arg1 *C.GMenuModel     // out

	_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(coreglib.InternObject(popover).Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_popover_menu_set_menu_model(_arg0, _arg1)
	runtime.KeepAlive(popover)
	runtime.KeepAlive(model)
}

// PopoverMenuBar: GtkPopoverMenuBar presents a horizontal bar of items that pop
// up popover menus when clicked.
//
// !An example GtkPopoverMenuBar (menubar.png)
//
// The only way to create instances of GtkPopoverMenuBar is from a GMenuModel.
//
// CSS nodes
//
//	menubar
//	├── item[.active]
//	┊   ╰── popover
//	╰── item
//	    ╰── popover
//
// GtkPopoverMenuBar has a single CSS node with name menubar, below which each
// item has its CSS node, and below that the corresponding popover.
//
// The item whose popover is currently open gets the .active style class.
//
// # Accessibility
//
// GtkPopoverMenuBar uses the GTK_ACCESSIBLE_ROLE_MENU_BAR role, the menu
// items use the GTK_ACCESSIBLE_ROLE_MENU_ITEM role and the menus use the
// GTK_ACCESSIBLE_ROLE_MENU role.
type PopoverMenuBar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*PopoverMenuBar)(nil)
)

func wrapPopoverMenuBar(obj *coreglib.Object) *PopoverMenuBar {
	return &PopoverMenuBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalPopoverMenuBar(p uintptr) (interface{}, error) {
	return wrapPopoverMenuBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPopoverMenuBarFromModel creates a GtkPopoverMenuBar from a GMenuModel.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel, or NULL.
//
// The function returns the following values:
//
//   - popoverMenuBar: new GtkPopoverMenuBar.
func NewPopoverMenuBarFromModel(model gio.MenuModeller) *PopoverMenuBar {
	var _arg1 *C.GMenuModel // out
	var _cret *C.GtkWidget  // in

	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_popover_menu_bar_new_from_model(_arg1)
	runtime.KeepAlive(model)

	var _popoverMenuBar *PopoverMenuBar // out

	_popoverMenuBar = wrapPopoverMenuBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _popoverMenuBar
}

// AddChild adds a custom widget to a generated menubar.
//
// For this to work, the menu model of bar must have an item with a custom
// attribute that matches id.
//
// The function takes the following parameters:
//
//   - child: GtkWidget to add.
//   - id: ID to insert child at.
//
// The function returns the following values:
//
//   - ok: TRUE if id was found and the widget added.
func (bar *PopoverMenuBar) AddChild(child Widgetter, id string) bool {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _arg1 *C.GtkWidget         // out
	var _arg2 *C.char              // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(id)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_popover_menu_bar_add_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(child)
	runtime.KeepAlive(id)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MenuModel returns the model from which the contents of bar are taken.
//
// The function returns the following values:
//
//   - menuModel: GMenuModel.
func (bar *PopoverMenuBar) MenuModel() gio.MenuModeller {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _cret *C.GMenuModel        // in

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_popover_menu_bar_get_menu_model(_arg0)
	runtime.KeepAlive(bar)

	var _menuModel gio.MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.MenuModeller)
			return ok
		})
		rv, ok := casted.(gio.MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_bar_add_child().
//
// The function takes the following parameters:
//
//   - child to remove.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget was removed.
func (bar *PopoverMenuBar) RemoveChild(child Widgetter) bool {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _arg1 *C.GtkWidget         // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_popover_menu_bar_remove_child(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(child)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetMenuModel sets a menu model from which bar should take its contents.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel, or NULL.
func (bar *PopoverMenuBar) SetMenuModel(model gio.MenuModeller) {
	var _arg0 *C.GtkPopoverMenuBar // out
	var _arg1 *C.GMenuModel        // out

	_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_popover_menu_bar_set_menu_model(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(model)
}

// PrintContext: GtkPrintContext encapsulates context information that is
// required when drawing pages for printing.
//
// This includes the cairo context and important parameters like page size and
// resolution. It also lets you easily create pango.Layout and pango.Context
// objects that match the font metrics of the cairo surface.
//
// GtkPrintContext objects get passed to the gtk.PrintOperation::begin-print,
// gtk.PrintOperation::end-print, gtk.PrintOperation::request-page-setup and
// gtk.PrintOperation::draw-page signals on the gtk.PrintOperation object.
//
// Using GtkPrintContext in a ::draw-page callback
//
//	static void
//	draw_page (GtkPrintOperation *operation,
//	           GtkPrintContext   *context,
//	           int                page_nr)
//	{
//	  cairo_t *cr;
//	  PangoLayout *layout;
//	  PangoFontDescription *desc;
//
//	  cr = gtk_print_context_get_cairo_context (context);
//
//	  // Draw a red rectangle, as wide as the paper (inside the margins)
//	  cairo_set_source_rgb (cr, 1.0, 0, 0);
//	  cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
//
//	  cairo_fill (cr);
//
//	  // Draw some lines
//	  cairo_move_to (cr, 20, 10);
//	  cairo_line_to (cr, 40, 20);
//	  cairo_arc (cr, 60, 60, 20, 0, M_PI);
//	  cairo_line_to (cr, 80, 20);
//
//	  cairo_set_source_rgb (cr, 0, 0, 0);
//	  cairo_set_line_width (cr, 5);
//	  cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//	  cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
//
//	  cairo_stroke (cr);
//
//	  // Draw some text
//	  layout = gtk_print_context_create_pango_layout (context);
//	  pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//	  desc = pango_font_description_from_string ("sans 28");
//	  pango_layout_set_font_description (layout, desc);
//	  pango_font_description_free (desc);
//
//	  cairo_move_to (cr, 30, 20);
//	  pango_cairo_layout_path (cr, layout);
//
//	  // Font Outline
//	  cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//	  cairo_set_line_width (cr, 0.5);
//	  cairo_stroke_preserve (cr);
//
//	  // Font Fill
//	  cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//	  cairo_fill (cr);
//
//	  g_object_unref (layout);
//	}.
type PrintContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PrintContext)(nil)
)

func wrapPrintContext(obj *coreglib.Object) *PrintContext {
	return &PrintContext{
		Object: obj,
	}
}

func marshalPrintContext(p uintptr) (interface{}, error) {
	return wrapPrintContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// CreatePangoContext creates a new PangoContext that can be used with the
// GtkPrintContext.
//
// The function returns the following values:
//
//   - ret: new Pango context for context.
func (context *PrintContext) CreatePangoContext() *pango.Context {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoContext    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_create_pango_context(_arg0)
	runtime.KeepAlive(context)

	var _ret *pango.Context // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_ret = &pango.Context{
			Object: obj,
		}
	}

	return _ret
}

// CreatePangoLayout creates a new PangoLayout that is suitable for use with the
// GtkPrintContext.
//
// The function returns the following values:
//
//   - layout: new Pango layout for context.
func (context *PrintContext) CreatePangoLayout() *pango.Layout {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoLayout     // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_create_pango_layout(_arg0)
	runtime.KeepAlive(context)

	var _layout *pango.Layout // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// CairoContext obtains the cairo context that is associated with the
// GtkPrintContext.
//
// The function returns the following values:
//
//   - ret: cairo context of context.
func (context *PrintContext) CairoContext() *cairo.Context {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.cairo_t         // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_cairo_context(_arg0)
	runtime.KeepAlive(context)

	var _ret *cairo.Context // out

	_ret = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
	C.cairo_reference(_cret)
	runtime.SetFinalizer(_ret, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	return _ret
}

// DPIX obtains the horizontal resolution of the GtkPrintContext, in dots per
// inch.
//
// The function returns the following values:
//
//   - gdouble: horizontal resolution of context.
func (context *PrintContext) DPIX() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_dpi_x(_arg0)
	runtime.KeepAlive(context)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// DPIY obtains the vertical resolution of the GtkPrintContext, in dots per
// inch.
//
// The function returns the following values:
//
//   - gdouble: vertical resolution of context.
func (context *PrintContext) DPIY() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_dpi_y(_arg0)
	runtime.KeepAlive(context)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// HardMargins obtains the hardware printer margins of the GtkPrintContext,
// in units.
//
// The function returns the following values:
//
//   - top hardware printer margin.
//   - bottom hardware printer margin.
//   - left hardware printer margin.
//   - right hardware printer margin.
//   - ok: TRUE if the hard margins were retrieved.
func (context *PrintContext) HardMargins() (top, bottom, left, right float64, ok bool) {
	var _arg0 *C.GtkPrintContext // out
	var _arg1 C.double           // in
	var _arg2 C.double           // in
	var _arg3 C.double           // in
	var _arg4 C.double           // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(context)

	var _top float64    // out
	var _bottom float64 // out
	var _left float64   // out
	var _right float64  // out
	var _ok bool        // out

	_top = float64(_arg1)
	_bottom = float64(_arg2)
	_left = float64(_arg3)
	_right = float64(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _top, _bottom, _left, _right, _ok
}

// Height obtains the height of the GtkPrintContext, in pixels.
//
// The function returns the following values:
//
//   - gdouble: height of context.
func (context *PrintContext) Height() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_height(_arg0)
	runtime.KeepAlive(context)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PageSetup obtains the GtkPageSetup that determines the page dimensions of the
// GtkPrintContext.
//
// The function returns the following values:
//
//   - pageSetup: page setup of context.
func (context *PrintContext) PageSetup() *PageSetup {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.GtkPageSetup    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_page_setup(_arg0)
	runtime.KeepAlive(context)

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.Take(unsafe.Pointer(_cret)))

	return _pageSetup
}

// PangoFontmap returns a PangoFontMap that is suitable for use with the
// GtkPrintContext.
//
// The function returns the following values:
//
//   - fontMap: font map of context.
func (context *PrintContext) PangoFontmap() pango.FontMapper {
	var _arg0 *C.GtkPrintContext // out
	var _cret *C.PangoFontMap    // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_pango_fontmap(_arg0)
	runtime.KeepAlive(context)

	var _fontMap pango.FontMapper // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type pango.FontMapper is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(pango.FontMapper)
			return ok
		})
		rv, ok := casted.(pango.FontMapper)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
		}
		_fontMap = rv
	}

	return _fontMap
}

// Width obtains the width of the GtkPrintContext, in pixels.
//
// The function returns the following values:
//
//   - gdouble: width of context.
func (context *PrintContext) Width() float64 {
	var _arg0 *C.GtkPrintContext // out
	var _cret C.double           // in

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_print_context_get_width(_arg0)
	runtime.KeepAlive(context)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SetCairoContext sets a new cairo context on a print context.
//
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK itself creates a suitable
// cairo context in that case.
//
// The function takes the following parameters:
//
//   - cr: cairo context.
//   - dpiX: horizontal resolution to use with cr.
//   - dpiY: vertical resolution to use with cr.
func (context *PrintContext) SetCairoContext(cr *cairo.Context, dpiX, dpiY float64) {
	var _arg0 *C.GtkPrintContext // out
	var _arg1 *C.cairo_t         // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out

	_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
	_arg2 = C.double(dpiX)
	_arg3 = C.double(dpiY)

	C.gtk_print_context_set_cairo_context(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(context)
	runtime.KeepAlive(cr)
	runtime.KeepAlive(dpiX)
	runtime.KeepAlive(dpiY)
}

// PrintOperationOverrides contains methods that are overridable.
type PrintOperationOverrides struct {
	BeginPrint        func(context *PrintContext)
	CustomWidgetApply func(widget Widgetter)
	Done              func(result PrintOperationResult)
	// The function takes the following parameters:
	//
	//   - context
	//   - pageNr
	DrawPage func(context *PrintContext, pageNr int)
	EndPrint func(context *PrintContext)
	Paginate func(context *PrintContext) bool
	// The function takes the following parameters:
	//
	//   - preview
	//   - context
	//   - parent
	Preview func(preview PrintOperationPreviewer, context *PrintContext, parent *Window) bool
	// The function takes the following parameters:
	//
	//   - context
	//   - pageNr
	//   - setup
	RequestPageSetup func(context *PrintContext, pageNr int, setup *PageSetup)
	StatusChanged    func()
	// The function takes the following parameters:
	//
	//   - widget
	//   - setup
	//   - settings
	UpdateCustomWidget func(widget Widgetter, setup *PageSetup, settings *PrintSettings)
}

func defaultPrintOperationOverrides(v *PrintOperation) PrintOperationOverrides {
	return PrintOperationOverrides{
		BeginPrint:         v.beginPrint,
		CustomWidgetApply:  v.customWidgetApply,
		Done:               v.done,
		DrawPage:           v.drawPage,
		EndPrint:           v.endPrint,
		Paginate:           v.paginate,
		Preview:            v.preview,
		RequestPageSetup:   v.requestPageSetup,
		StatusChanged:      v.statusChanged,
		UpdateCustomWidget: v.updateCustomWidget,
	}
}

// PrintOperation: GtkPrintOperation is the high-level, portable printing API.
//
// It looks a bit different than other GTK dialogs such as the GtkFileChooser,
// since some platforms don’t expose enough infrastructure to implement a good
// print dialog. On such platforms, GtkPrintOperation uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK uses its
// own, see gtk.PrintUnixDialog.
//
// The typical way to use the high-level printing API is to create a
// GtkPrintOperation object with gtk.PrintOperation.New when the user
// selects to print. Then you set some properties on it, e.g. the page size,
// any gtk.PrintSettings from previous print operations, the number of pages,
// the current page, etc.
//
// Then you start the print operation by calling gtk.PrintOperation.Run().
// It will then show a dialog, let the user select a printer and options.
// When the user finished the dialog, various signals will be emitted on
// the GtkPrintOperation, the main one being gtk.PrintOperation::draw-page,
// which you are supposed to handle and render the page on the provided
// gtk.PrintContext using Cairo.
//
// The high-level printing API
//
//	static GtkPrintSettings *settings = NULL;
//
//	static void
//	do_print (void)
//	{
//	  GtkPrintOperation *print;
//	  GtkPrintOperationResult res;
//
//	  print = gtk_print_operation_new ();
//
//	  if (settings != NULL)
//	    gtk_print_operation_set_print_settings (print, settings);
//
//	  g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//	  g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
//
//	  res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//	                                 GTK_WINDOW (main_window), NULL);
//
//	  if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//	    {
//	      if (settings != NULL)
//	        g_object_unref (settings);
//	      settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//	    }
//
//	  g_object_unref (print);
//	}
//
// By default GtkPrintOperation uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions gtk.PrintOperationPreview.RenderPage(),
// gtk.PrintOperationPreview.EndPreview() and
// gtk.PrintOperationPreview.IsSelected() are useful when implementing a print
// preview.
type PrintOperation struct {
	_ [0]func() // equal guard
	*coreglib.Object

	PrintOperationPreview
}

var (
	_ coreglib.Objector = (*PrintOperation)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*PrintOperation, *PrintOperationClass, PrintOperationOverrides](
		GTypePrintOperation,
		initPrintOperationClass,
		wrapPrintOperation,
		defaultPrintOperationOverrides,
	)
}

func initPrintOperationClass(gclass unsafe.Pointer, overrides PrintOperationOverrides, classInitFunc func(*PrintOperationClass)) {
	pclass := (*C.GtkPrintOperationClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypePrintOperation))))

	if overrides.BeginPrint != nil {
		pclass.begin_print = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_begin_print)
	}

	if overrides.CustomWidgetApply != nil {
		pclass.custom_widget_apply = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_custom_widget_apply)
	}

	if overrides.Done != nil {
		pclass.done = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_done)
	}

	if overrides.DrawPage != nil {
		pclass.draw_page = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_draw_page)
	}

	if overrides.EndPrint != nil {
		pclass.end_print = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_end_print)
	}

	if overrides.Paginate != nil {
		pclass.paginate = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_paginate)
	}

	if overrides.Preview != nil {
		pclass.preview = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_preview)
	}

	if overrides.RequestPageSetup != nil {
		pclass.request_page_setup = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_request_page_setup)
	}

	if overrides.StatusChanged != nil {
		pclass.status_changed = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_status_changed)
	}

	if overrides.UpdateCustomWidget != nil {
		pclass.update_custom_widget = (*[0]byte)(C._gotk4_gtk4_PrintOperationClass_update_custom_widget)
	}

	if classInitFunc != nil {
		class := (*PrintOperationClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapPrintOperation(obj *coreglib.Object) *PrintOperation {
	return &PrintOperation{
		Object: obj,
		PrintOperationPreview: PrintOperationPreview{
			Object: obj,
		},
	}
}

func marshalPrintOperation(p uintptr) (interface{}, error) {
	return wrapPrintOperation(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectBeginPrint is emitted after the user has finished changing print
// settings in the dialog, before the actual rendering starts.
//
// A typical use for ::begin-print is to use the parameters from the
// gtk.PrintContext and paginate the document accordingly, and then set the
// number of pages with gtk.PrintOperation.SetNPages().
func (op *PrintOperation) ConnectBeginPrint(f func(context *PrintContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "begin-print", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectBeginPrint), f)
}

// ConnectCreateCustomWidget is emitted when displaying the print dialog.
//
// If you return a widget in a handler for this signal it will be added to a
// custom tab in the print dialog. You typically return a container widget with
// multiple widgets in it.
//
// The print dialog owns the returned widget, and its lifetime is not controlled
// by the application. However, the widget is guaranteed to stay around
// until the gtk.PrintOperation::custom-widget-apply signal is emitted on the
// operation. Then you can read out any information you need from the widgets.
func (op *PrintOperation) ConnectCreateCustomWidget(f func() (object *coreglib.Object)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "create-custom-widget", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectCreateCustomWidget), f)
}

// ConnectCustomWidgetApply is emitted right before ::begin-print if you added a
// custom widget in the ::create-custom-widget handler.
//
// When you get this signal you should read the information from the custom
// widgets, as the widgets are not guaranteed to be around at a later time.
func (op *PrintOperation) ConnectCustomWidgetApply(f func(widget Widgetter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "custom-widget-apply", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectCustomWidgetApply), f)
}

// ConnectDone is emitted when the print operation run has finished doing
// everything required for printing.
//
// result gives you information about what happened during the run.
// If result is GTK_PRINT_OPERATION_RESULT_ERROR then you can call
// gtk.PrintOperation.GetError() for more information.
//
// If you enabled print status tracking then gtk.PrintOperation.IsFinished() may
// still return FALSE after the ::done signal was emitted.
func (op *PrintOperation) ConnectDone(f func(result PrintOperationResult)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "done", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectDone), f)
}

// ConnectDrawPage is emitted for every page that is printed.
//
// The signal handler must render the page_nr's page onto the cairo context
// obtained from context using gtk.PrintContext.GetCairoContext().
//
//	static void
//	draw_page (GtkPrintOperation *operation,
//	           GtkPrintContext   *context,
//	           int                page_nr,
//	           gpointer           user_data)
//	{
//	  cairo_t *cr;
//	  PangoLayout *layout;
//	  double width, text_height;
//	  int layout_height;
//	  PangoFontDescription *desc;
//
//	  cr = gtk_print_context_get_cairo_context (context);
//	  width = gtk_print_context_get_width (context);
//
//	  cairo_rectangle (cr, 0, 0, width, HEADER_HEIGHT);
//
//	  cairo_set_source_rgb (cr, 0.8, 0.8, 0.8);
//	  cairo_fill (cr);
//
//	  layout = gtk_print_context_create_pango_layout (context);
//
//	  desc = pango_font_description_from_string ("sans 14");
//	  pango_layout_set_font_description (layout, desc);
//	  pango_font_description_free (desc);
//
//	  pango_layout_set_text (layout, "some text", -1);
//	  pango_layout_set_width (layout, width * PANGO_SCALE);
//	  pango_layout_set_alignment (layout, PANGO_ALIGN_CENTER);
//
//	  pango_layout_get_size (layout, NULL, &layout_height);
//	  text_height = (double)layout_height / PANGO_SCALE;
//
//	  cairo_move_to (cr, width / 2,  (HEADER_HEIGHT - text_height) / 2);
//	  pango_cairo_show_layout (cr, layout);
//
//	  g_object_unref (layout);
//	}
//
// Use gtk.PrintOperation.SetUseFullPage() and gtk.PrintOperation.SetUnit()
// before starting the print operation to set up the transformation of the cairo
// context according to your needs.
func (op *PrintOperation) ConnectDrawPage(f func(context *PrintContext, pageNr int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "draw-page", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectDrawPage), f)
}

// ConnectEndPrint is emitted after all pages have been rendered.
//
// A handler for this signal can clean up any resources that have been allocated
// in the gtk.PrintOperation::begin-print handler.
func (op *PrintOperation) ConnectEndPrint(f func(context *PrintContext)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "end-print", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectEndPrint), f)
}

// ConnectPaginate is emitted after the ::begin-print signal, but before the
// actual rendering starts.
//
// It keeps getting emitted until a connected signal handler returns TRUE.
//
// The ::paginate signal is intended to be used for paginating a document
// in small chunks, to avoid blocking the user interface for a long
// time. The signal handler should update the number of pages using
// gtk.PrintOperation.SetNPages(), and return TRUE if the document has been
// completely paginated.
//
// If you don't need to do pagination in chunks, you can simply do it all in the
// ::begin-print handler, and set the number of pages from there.
func (op *PrintOperation) ConnectPaginate(f func(context *PrintContext) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "paginate", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectPaginate), f)
}

// ConnectPreview gets emitted when a preview is requested from the native
// dialog.
//
// The default handler for this signal uses an external viewer application to
// preview.
//
// To implement a custom print preview, an application must return TRUE from
// its handler for this signal. In order to use the provided context for the
// preview implementation, it must be given a suitable cairo context with
// gtk.PrintContext.SetCairoContext().
//
// The custom preview implementation can use
// gtk.PrintOperationPreview.IsSelected() and
// gtk.PrintOperationPreview.RenderPage() to find pages which are selected
// for print and render them. The preview must be finished by calling
// gtk.PrintOperationPreview.EndPreview() (typically in response to the user
// clicking a close button).
func (op *PrintOperation) ConnectPreview(f func(preview PrintOperationPreviewer, context *PrintContext, parent *Window) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "preview", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectPreview), f)
}

// ConnectRequestPageSetup is emitted once for every page that is printed.
//
// This gives the application a chance to modify the page setup. Any changes
// done to setup will be in force only for printing this page.
func (op *PrintOperation) ConnectRequestPageSetup(f func(context *PrintContext, pageNr int, setup *PageSetup)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "request-page-setup", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectRequestPageSetup), f)
}

// ConnectStatusChanged is emitted at between the various phases of the print
// operation.
//
// See gtk.PrintStatus for the phases that are being discriminated. Use
// gtk.PrintOperation.GetStatus() to find out the current status.
func (op *PrintOperation) ConnectStatusChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "status-changed", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectStatusChanged), f)
}

// ConnectUpdateCustomWidget is emitted after change of selected printer.
//
// The actual page setup and print settings are passed to the custom widget,
// which can actualize itself according to this change.
func (op *PrintOperation) ConnectUpdateCustomWidget(f func(widget Widgetter, setup *PageSetup, settings *PrintSettings)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(op, "update-custom-widget", false, unsafe.Pointer(C._gotk4_gtk4_PrintOperation_ConnectUpdateCustomWidget), f)
}

// NewPrintOperation creates a new GtkPrintOperation.
//
// The function returns the following values:
//
//   - printOperation: new GtkPrintOperation.
func NewPrintOperation() *PrintOperation {
	var _cret *C.GtkPrintOperation // in

	_cret = C.gtk_print_operation_new()

	var _printOperation *PrintOperation // out

	_printOperation = wrapPrintOperation(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printOperation
}

// Cancel cancels a running print operation.
//
// This function may be called from a gtk.PrintOperation::begin-print,
// gtk.PrintOperation::paginate or gtk.PrintOperation::draw-page signal handler
// to stop the currently running print operation.
func (op *PrintOperation) Cancel() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	C.gtk_print_operation_cancel(_arg0)
	runtime.KeepAlive(op)
}

// DrawPageFinish: signal that drawing of particular page is complete.
//
// It is called after completion of page drawing (e.g. drawing in another
// thread). If gtk.PrintOperation.SetDeferDrawing() was called before, then
// this function has to be called by application. Otherwise it is called by GTK
// itself.
func (op *PrintOperation) DrawPageFinish() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	C.gtk_print_operation_draw_page_finish(_arg0)
	runtime.KeepAlive(op)
}

// DefaultPageSetup returns the default page setup.
//
// The function returns the following values:
//
//   - pageSetup: default page setup.
func (op *PrintOperation) DefaultPageSetup() *PageSetup {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.GtkPageSetup      // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_default_page_setup(_arg0)
	runtime.KeepAlive(op)

	var _pageSetup *PageSetup // out

	_pageSetup = wrapPageSetup(coreglib.Take(unsafe.Pointer(_cret)))

	return _pageSetup
}

// EmbedPageSetup gets whether page setup selection combos are embedded.
//
// The function returns the following values:
//
//   - ok: whether page setup selection combos are embedded.
func (op *PrintOperation) EmbedPageSetup() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_embed_page_setup(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR.
//
// It can be called either after gtk.PrintOperation.Run() returns, or in the
// gtk.PrintOperation::done signal handler.
//
// The returned GError will contain more details on what went wrong.
func (op *PrintOperation) Error() error {
	var _arg0 *C.GtkPrintOperation // out
	var _cerr *C.GError            // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	C.gtk_print_operation_get_error(_arg0, &_cerr)
	runtime.KeepAlive(op)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// HasSelection gets whether there is a selection.
//
// The function returns the following values:
//
//   - ok: whether there is a selection.
func (op *PrintOperation) HasSelection() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_has_selection(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NPagesToPrint returns the number of pages that will be printed.
//
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called
// before the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA).
// You can connect to the gtk.PrintOperation::status-changed signal and
// call gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA.
//
// This is typically used to track the progress of print operation.
//
// The function returns the following values:
//
//   - gint: number of pages that will be printed.
func (op *PrintOperation) NPagesToPrint() int {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.int                // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_n_pages_to_print(_arg0)
	runtime.KeepAlive(op)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PrintSettings returns the current print settings.
//
// Note that the return value is NULL until either
// gtk.PrintOperation.SetPrintSettings() or gtk.PrintOperation.Run() have been
// called.
//
// The function returns the following values:
//
//   - printSettings: current print settings of op.
func (op *PrintOperation) PrintSettings() *PrintSettings {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.GtkPrintSettings  // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_print_settings(_arg0)
	runtime.KeepAlive(op)

	var _printSettings *PrintSettings // out

	_printSettings = wrapPrintSettings(coreglib.Take(unsafe.Pointer(_cret)))

	return _printSettings
}

// Status returns the status of the print operation.
//
// Also see gtk.PrintOperation.GetStatusString().
//
// The function returns the following values:
//
//   - printStatus status of the print operation.
func (op *PrintOperation) Status() PrintStatus {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.GtkPrintStatus     // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_status(_arg0)
	runtime.KeepAlive(op)

	var _printStatus PrintStatus // out

	_printStatus = PrintStatus(_cret)

	return _printStatus
}

// StatusString returns a string representation of the status of the print
// operation.
//
// The string is translated and suitable for displaying the print status e.g.
// in a GtkStatusbar.
//
// Use gtk.PrintOperation.GetStatus() to obtain a status value that is suitable
// for programmatic use.
//
// The function returns the following values:
//
//   - utf8: string representation of the status of the print operation.
func (op *PrintOperation) StatusString() string {
	var _arg0 *C.GtkPrintOperation // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_status_string(_arg0)
	runtime.KeepAlive(op)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SupportSelection gets whether the application supports print of selection.
//
// The function returns the following values:
//
//   - ok: whether the application supports print of selection.
func (op *PrintOperation) SupportSelection() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_get_support_selection(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFinished: convenience function to find out if the print operation is
// finished.
//
// a print operation is finished if its status is either
// GTK_PRINT_STATUS_FINISHED or GTK_PRINT_STATUS_FINISHED_ABORTED.
//
// Note: when you enable print status tracking the print operation can be in a
// non-finished state even after done has been called, as the operation status
// then tracks the print job status on the printer.
//
// The function returns the following values:
//
//   - ok: TRUE, if the print operation is finished.
func (op *PrintOperation) IsFinished() bool {
	var _arg0 *C.GtkPrintOperation // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	_cret = C.gtk_print_operation_is_finished(_arg0)
	runtime.KeepAlive(op)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Run runs the print operation.
//
// Normally that this function does not return until the rendering of all pages
// is complete. You can connect to the gtk.PrintOperation::status-changed signal
// on op to obtain some information about the progress of the print operation.
//
// Furthermore, it may use a recursive mainloop to show the print dialog.
//
// If you set the [Gtk.PrintOperation:allow-async] property, the operation
// will run asynchronously if this is supported on the platform. The
// gtk.PrintOperation::done signal will be emitted with the result of the
// operation when the it is done (i.e. when the dialog is canceled, or when the
// print succeeds or fails).
//
//	if (settings != NULL)
//	  gtk_print_operation_set_print_settings (print, settings);
//
//	if (page_setup != NULL)
//	  gtk_print_operation_set_default_page_setup (print, page_setup);
//
//	g_signal_connect (print, "begin-print",
//	                  G_CALLBACK (begin_print), &data);
//	g_signal_connect (print, "draw-page",
//	                  G_CALLBACK (draw_page), &data);
//
//	res = gtk_print_operation_run (print,
//	                               GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//	                               parent,
//	                               &error);
//
//	if (res == GTK_PRINT_OPERATION_RESULT_ERROR)
//	 {
//	   error_dialog = gtk_message_dialog_new (GTK_WINDOW (parent),
//	  			                     GTK_DIALOG_DESTROY_WITH_PARENT,
//						     GTK_MESSAGE_ERROR,
//						     GTK_BUTTONS_CLOSE,
//						     "Error printing file:\ns",
//						     error->message);
//	   g_signal_connect (error_dialog, "response",
//	                     G_CALLBACK (gtk_window_destroy), NULL);
//	   gtk_widget_show (error_dialog);
//	   g_error_free (error);
//	 }
//	else if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//	 {
//	   if (settings != NULL)
//	g_object_unref (settings);
//	   settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//	 }
//
// Note that gtk_print_operation_run() can only be called once on a given
// GtkPrintOperation.
//
// The function takes the following parameters:
//
//   - action to start.
//   - parent (optional): transient parent of the dialog.
//
// The function returns the following values:
//
//   - printOperationResult: result of the print operation. A return value
//     of GTK_PRINT_OPERATION_RESULT_APPLY indicates that the printing was
//     completed successfully. In this case, it is a good idea to obtain
//     the used print settings with gtk.PrintOperation.GetPrintSettings()
//     and store them for reuse with the next print operation. A value of
//     GTK_PRINT_OPERATION_RESULT_IN_PROGRESS means the operation is running
//     asynchronously, and will emit the gtk.PrintOperation::done signal when
//     done.
func (op *PrintOperation) Run(action PrintOperationAction, parent *Window) (PrintOperationResult, error) {
	var _arg0 *C.GtkPrintOperation      // out
	var _arg1 C.GtkPrintOperationAction // out
	var _arg2 *C.GtkWindow              // out
	var _cret C.GtkPrintOperationResult // in
	var _cerr *C.GError                 // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.GtkPrintOperationAction(action)
	if parent != nil {
		_arg2 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	_cret = C.gtk_print_operation_run(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(op)
	runtime.KeepAlive(action)
	runtime.KeepAlive(parent)

	var _printOperationResult PrintOperationResult // out
	var _goerr error                               // out

	_printOperationResult = PrintOperationResult(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _printOperationResult, _goerr
}

// SetAllowAsync sets whether gtk_print_operation_run() may return before the
// print operation is completed.
//
// Note that some platforms may not allow asynchronous operation.
//
// The function takes the following parameters:
//
//   - allowAsync: TRUE to allow asynchronous operation.
func (op *PrintOperation) SetAllowAsync(allowAsync bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if allowAsync {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_allow_async(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(allowAsync)
}

// SetCurrentPage sets the current page.
//
// If this is called before gtk.PrintOperation.Run(), the user will be able to
// select to print only the current page.
//
// Note that this only makes sense for pre-paginated documents.
//
// The function takes the following parameters:
//
//   - currentPage: current page, 0-based.
func (op *PrintOperation) SetCurrentPage(currentPage int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.int(currentPage)

	C.gtk_print_operation_set_current_page(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(currentPage)
}

// SetCustomTabLabel sets the label for the tab holding custom widgets.
//
// The function takes the following parameters:
//
//   - label (optional) to use, or NULL to use the default label.
func (op *PrintOperation) SetCustomTabLabel(label string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if label != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_print_operation_set_custom_tab_label(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(label)
}

// SetDefaultPageSetup makes default_page_setup the default page setup for op.
//
// This page setup will be used by gtk.PrintOperation.Run(),
// but it can be overridden on a per-page basis by connecting to the
// gtk.PrintOperation::request-page-setup signal.
//
// The function takes the following parameters:
//
//   - defaultPageSetup (optional): GtkPageSetup, or NULL.
func (op *PrintOperation) SetDefaultPageSetup(defaultPageSetup *PageSetup) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPageSetup      // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if defaultPageSetup != nil {
		_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(defaultPageSetup).Native()))
	}

	C.gtk_print_operation_set_default_page_setup(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(defaultPageSetup)
}

// SetDeferDrawing sets up the GtkPrintOperation to wait for calling of
// [methodGtk.PrintOperation.draw_page_finish from application.
//
// This can be used for drawing page in another thread.
//
// This function must be called in the callback of the
// gtk.PrintOperation::draw-page signal.
func (op *PrintOperation) SetDeferDrawing() {
	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))

	C.gtk_print_operation_set_defer_drawing(_arg0)
	runtime.KeepAlive(op)
}

// SetEmbedPageSetup: embed page size combo box and orientation combo box into
// page setup page.
//
// Selected page setup is stored as default page setup in GtkPrintOperation.
//
// The function takes the following parameters:
//
//   - embed: TRUE to embed page setup selection in the GtkPrintUnixDialog.
func (op *PrintOperation) SetEmbedPageSetup(embed bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if embed {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_embed_page_setup(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(embed)
}

// SetExportFilename sets up the GtkPrintOperation to generate a file instead of
// showing the print dialog.
//
// The intended use of this function is for implementing “Export to PDF”
// actions. Currently, PDF is the only supported format.
//
// “Print to PDF” support is independent of this and is done by letting the user
// pick the “Print to PDF” item from the list of printers in the print dialog.
//
// The function takes the following parameters:
//
//   - filename for the exported file.
func (op *PrintOperation) SetExportFilename(filename string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_export_filename(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(filename)
}

// SetHasSelection sets whether there is a selection to print.
//
// Application has to set number of pages to which the selection
// will draw by gtk.PrintOperation.SetNPages() in a handler for the
// gtk.PrintOperation::begin-print signal.
//
// The function takes the following parameters:
//
//   - hasSelection: TRUE indicates that a selection exists.
func (op *PrintOperation) SetHasSelection(hasSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if hasSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_has_selection(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(hasSelection)
}

// SetJobName sets the name of the print job.
//
// The name is used to identify the job (e.g. in monitoring applications like
// eggcups).
//
// If you don’t set a job name, GTK picks a default one by numbering successive
// print jobs.
//
// The function takes the following parameters:
//
//   - jobName: string that identifies the print job.
func (op *PrintOperation) SetJobName(jobName string) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(jobName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_operation_set_job_name(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(jobName)
}

// SetNPages sets the number of pages in the document.
//
// This must be set to a positive number before the rendering starts. It may be
// set in a gtk.PrintOperation::begin-print signal handler.
//
// Note that the page numbers passed to the
// gtk.PrintOperation::request-page-setup and gtk.PrintOperation::draw-page
// signals are 0-based, i.e. if the user chooses to print all pages, the last
// ::draw-page signal will be for page n_pages - 1.
//
// The function takes the following parameters:
//
//   - nPages: number of pages.
func (op *PrintOperation) SetNPages(nPages int) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.int(nPages)

	C.gtk_print_operation_set_n_pages(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(nPages)
}

// SetPrintSettings sets the print settings for op.
//
// This is typically used to re-establish print settings from a previous print
// operation, see gtk.PrintOperation.Run().
//
// The function takes the following parameters:
//
//   - printSettings (optional): GtkPrintSettings.
func (op *PrintOperation) SetPrintSettings(printSettings *PrintSettings) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintSettings  // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if printSettings != nil {
		_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(printSettings).Native()))
	}

	C.gtk_print_operation_set_print_settings(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(printSettings)
}

// SetShowProgress: if show_progress is TRUE, the print operation will show a
// progress dialog during the print operation.
//
// The function takes the following parameters:
//
//   - showProgress: TRUE to show a progress dialog.
func (op *PrintOperation) SetShowProgress(showProgress bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if showProgress {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_show_progress(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(showProgress)
}

// SetSupportSelection sets whether selection is supported by GtkPrintOperation.
//
// The function takes the following parameters:
//
//   - supportSelection: TRUE to support selection.
func (op *PrintOperation) SetSupportSelection(supportSelection bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if supportSelection {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_support_selection(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(supportSelection)
}

// SetTrackPrintStatus: if track_status is TRUE, the print operation will try
// to continue report on the status of the print job in the printer queues and
// printer.
//
// This can allow your application to show things like “out of paper” issues,
// and when the print job actually reaches the printer.
//
// This function is often implemented using some form of polling, so it should
// not be enabled unless needed.
//
// The function takes the following parameters:
//
//   - trackStatus: TRUE to track status after printing.
func (op *PrintOperation) SetTrackPrintStatus(trackStatus bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if trackStatus {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_track_print_status(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(trackStatus)
}

// SetUnit sets up the transformation for the cairo context obtained from
// GtkPrintContext in such a way that distances are measured in units of unit.
//
// The function takes the following parameters:
//
//   - unit to use.
func (op *PrintOperation) SetUnit(unit Unit) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.GtkUnit            // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	_arg1 = C.GtkUnit(unit)

	C.gtk_print_operation_set_unit(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(unit)
}

// SetUseFullPage: if full_page is TRUE, the transformation for the cairo
// context obtained from GtkPrintContext puts the origin at the top left corner
// of the page.
//
// This may not be the top left corner of the sheet, depending on page
// orientation and the number of pages per sheet). Otherwise, the origin is at
// the top left corner of the imageable area (i.e. inside the margins).
//
// The function takes the following parameters:
//
//   - fullPage: TRUE to set up the GtkPrintContext for the full page.
func (op *PrintOperation) SetUseFullPage(fullPage bool) {
	var _arg0 *C.GtkPrintOperation // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(op).Native()))
	if fullPage {
		_arg1 = C.TRUE
	}

	C.gtk_print_operation_set_use_full_page(_arg0, _arg1)
	runtime.KeepAlive(op)
	runtime.KeepAlive(fullPage)
}

func (operation *PrintOperation) beginPrint(context *PrintContext) {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.begin_print

	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintContext   // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_PrintOperation_virtual_begin_print(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(context)
}

func (operation *PrintOperation) customWidgetApply(widget Widgetter) {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.custom_widget_apply

	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_PrintOperation_virtual_custom_widget_apply(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(widget)
}

func (operation *PrintOperation) done(result PrintOperationResult) {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.done

	var _arg0 *C.GtkPrintOperation      // out
	var _arg1 C.GtkPrintOperationResult // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = C.GtkPrintOperationResult(result)

	C._gotk4_gtk4_PrintOperation_virtual_done(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(result)
}

// The function takes the following parameters:
//
//   - context
//   - pageNr
func (operation *PrintOperation) drawPage(context *PrintContext, pageNr int) {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.draw_page

	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintContext   // out
	var _arg2 C.int                // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.int(pageNr)

	C._gotk4_gtk4_PrintOperation_virtual_draw_page(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(context)
	runtime.KeepAlive(pageNr)
}

func (operation *PrintOperation) endPrint(context *PrintContext) {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.end_print

	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintContext   // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_PrintOperation_virtual_end_print(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(context)
}

func (operation *PrintOperation) paginate(context *PrintContext) bool {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.paginate

	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintContext   // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C._gotk4_gtk4_PrintOperation_virtual_paginate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(context)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - preview
//   - context
//   - parent
func (operation *PrintOperation) preview(preview PrintOperationPreviewer, context *PrintContext, parent *Window) bool {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.preview

	var _arg0 *C.GtkPrintOperation        // out
	var _arg1 *C.GtkPrintOperationPreview // out
	var _arg2 *C.GtkPrintContext          // out
	var _arg3 *C.GtkWindow                // out
	var _cret C.gboolean                  // in

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(coreglib.InternObject(preview).Native()))
	_arg2 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg3 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	_cret = C._gotk4_gtk4_PrintOperation_virtual_preview(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(preview)
	runtime.KeepAlive(context)
	runtime.KeepAlive(parent)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - context
//   - pageNr
//   - setup
func (operation *PrintOperation) requestPageSetup(context *PrintContext, pageNr int, setup *PageSetup) {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.request_page_setup

	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkPrintContext   // out
	var _arg2 C.int                // out
	var _arg3 *C.GtkPageSetup      // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkPrintContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.int(pageNr)
	_arg3 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))

	C._gotk4_gtk4_PrintOperation_virtual_request_page_setup(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(context)
	runtime.KeepAlive(pageNr)
	runtime.KeepAlive(setup)
}

func (operation *PrintOperation) statusChanged() {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.status_changed

	var _arg0 *C.GtkPrintOperation // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))

	C._gotk4_gtk4_PrintOperation_virtual_status_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(operation)
}

// The function takes the following parameters:
//
//   - widget
//   - setup
//   - settings
func (operation *PrintOperation) updateCustomWidget(widget Widgetter, setup *PageSetup, settings *PrintSettings) {
	gclass := (*C.GtkPrintOperationClass)(coreglib.PeekParentClass(operation))
	fnarg := gclass.update_custom_widget

	var _arg0 *C.GtkPrintOperation // out
	var _arg1 *C.GtkWidget         // out
	var _arg2 *C.GtkPageSetup      // out
	var _arg3 *C.GtkPrintSettings  // out

	_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(coreglib.InternObject(operation).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(coreglib.InternObject(setup).Native()))
	_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	C._gotk4_gtk4_PrintOperation_virtual_update_custom_widget(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(operation)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(setup)
	runtime.KeepAlive(settings)
}

// PrintSettings: GtkPrintSettings object represents the settings of a print
// dialog in a system-independent way.
//
// The main use for this object is that once you’ve printed you can get a
// settings object that represents the settings the user chose, and the next
// time you print you can pass that object in so that the user doesn’t have to
// re-set all his settings.
//
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
type PrintSettings struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*PrintSettings)(nil)
)

func wrapPrintSettings(obj *coreglib.Object) *PrintSettings {
	return &PrintSettings{
		Object: obj,
	}
}

func marshalPrintSettings(p uintptr) (interface{}, error) {
	return wrapPrintSettings(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPrintSettings creates a new GtkPrintSettings object.
//
// The function returns the following values:
//
//   - printSettings: new GtkPrintSettings object.
func NewPrintSettings() *PrintSettings {
	var _cret *C.GtkPrintSettings // in

	_cret = C.gtk_print_settings_new()

	var _printSettings *PrintSettings // out

	_printSettings = wrapPrintSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printSettings
}

// NewPrintSettingsFromFile reads the print settings from file_name.
//
// Returns a new GtkPrintSettings object with the restored settings, or NULL
// if an error occurred. If the file could not be loaded then error is set to
// either a GFileError or GKeyFileError.
//
// See gtk.PrintSettings.ToFile().
//
// The function takes the following parameters:
//
//   - fileName: filename to read the settings from.
//
// The function returns the following values:
//
//   - printSettings: restored GtkPrintSettings.
func NewPrintSettingsFromFile(fileName string) (*PrintSettings, error) {
	var _arg1 *C.char             // out
	var _cret *C.GtkPrintSettings // in
	var _cerr *C.GError           // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_new_from_file(_arg1, &_cerr)
	runtime.KeepAlive(fileName)

	var _printSettings *PrintSettings // out
	var _goerr error                  // out

	_printSettings = wrapPrintSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _printSettings, _goerr
}

// NewPrintSettingsFromGVariant: deserialize print settings from an a{sv}
// variant.
//
// The variant must be in the format produced by gtk.PrintSettings.ToGVariant().
//
// The function takes the following parameters:
//
//   - variant: a{sv} GVariant.
//
// The function returns the following values:
//
//   - printSettings: new GtkPrintSettings object.
func NewPrintSettingsFromGVariant(variant *glib.Variant) *PrintSettings {
	var _arg1 *C.GVariant         // out
	var _cret *C.GtkPrintSettings // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(variant)))

	_cret = C.gtk_print_settings_new_from_gvariant(_arg1)
	runtime.KeepAlive(variant)

	var _printSettings *PrintSettings // out

	_printSettings = wrapPrintSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printSettings
}

// NewPrintSettingsFromKeyFile reads the print settings from the group
// group_name in key_file.
//
// Returns a new GtkPrintSettings object with the restored settings, or NULL
// if an error occurred. If the file could not be loaded then error is set to
// either GFileError or GKeyFileError.
//
// The function takes the following parameters:
//
//   - keyFile: GKeyFile to retrieve the settings from.
//   - groupName (optional): name of the group to use, or NULL to use the
//     default “Print Settings”.
//
// The function returns the following values:
//
//   - printSettings: restored GtkPrintSettings.
func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PrintSettings, error) {
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.char             // out
	var _cret *C.GtkPrintSettings // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_print_settings_new_from_key_file(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _printSettings *PrintSettings // out
	var _goerr error                  // out

	_printSettings = wrapPrintSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _printSettings, _goerr
}

// Copy copies a GtkPrintSettings object.
//
// The function returns the following values:
//
//   - printSettings: newly allocated copy of other.
func (other *PrintSettings) Copy() *PrintSettings {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GtkPrintSettings // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(other).Native()))

	_cret = C.gtk_print_settings_copy(_arg0)
	runtime.KeepAlive(other)

	var _printSettings *PrintSettings // out

	_printSettings = wrapPrintSettings(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _printSettings
}

// ForEach calls func for each key-value pair of settings.
//
// The function takes the following parameters:
//
//   - fn: function to call.
func (settings *PrintSettings) ForEach(fn PrintSettingsFunc) {
	var _arg0 *C.GtkPrintSettings    // out
	var _arg1 C.GtkPrintSettingsFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_PrintSettingsFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_print_settings_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(fn)
}

// Get looks up the string value associated with key.
//
// The function takes the following parameters:
//
//   - key: key.
//
// The function returns the following values:
//
//   - utf8: string value for key.
func (settings *PrintSettings) Get(key string) string {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Bool returns the boolean represented by the value that is associated with
// key.
//
// The string “true” represents TRUE, any other string FALSE.
//
// The function takes the following parameters:
//
//   - key: key.
//
// The function returns the following values:
//
//   - ok: TRUE, if key maps to a true value.
func (settings *PrintSettings) Bool(key string) bool {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_bool(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
//
// The function returns the following values:
//
//   - ok: whether to collate the printed pages.
func (settings *PrintSettings) Collate() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_collate(_arg0)
	runtime.KeepAlive(settings)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
//
// The function returns the following values:
//
//   - utf8: default source.
func (settings *PrintSettings) DefaultSource() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_default_source(_arg0)
	runtime.KeepAlive(settings)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
//
// The function returns the following values:
//
//   - utf8: dithering that is used.
func (settings *PrintSettings) Dither() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_dither(_arg0)
	runtime.KeepAlive(settings)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Double returns the double value associated with key, or 0.
//
// The function takes the following parameters:
//
//   - key: key.
//
// The function returns the following values:
//
//   - gdouble: double value of key.
func (settings *PrintSettings) Double(key string) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_double(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// DoubleWithDefault returns the floating point number represented by the value
// that is associated with key, or default_val if the value does not represent a
// floating point number.
//
// Floating point numbers are parsed with g_ascii_strtod().
//
// The function takes the following parameters:
//
//   - key: key.
//   - def: default value.
//
// The function returns the following values:
//
//   - gdouble: floating point number associated with key.
func (settings *PrintSettings) DoubleWithDefault(key string, def float64) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.double            // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(def)

	_cret = C.gtk_print_settings_get_double_with_default(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(def)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
//
// The function returns the following values:
//
//   - printDuplex: whether to print the output in duplex.
func (settings *PrintSettings) Duplex() PrintDuplex {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintDuplex    // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_duplex(_arg0)
	runtime.KeepAlive(settings)

	var _printDuplex PrintDuplex // out

	_printDuplex = PrintDuplex(_cret)

	return _printDuplex
}

// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
//
// The function returns the following values:
//
//   - utf8: finishings.
func (settings *PrintSettings) Finishings() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_finishings(_arg0)
	runtime.KeepAlive(settings)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Int returns the integer value of key, or 0.
//
// The function takes the following parameters:
//
//   - key: key.
//
// The function returns the following values:
//
//   - gint: integer value of key.
func (settings *PrintSettings) Int(key string) int {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_get_int(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IntWithDefault returns the value of key, interpreted as an integer, or the
// default value.
//
// The function takes the following parameters:
//
//   - key: key.
//   - def: default value.
//
// The function returns the following values:
//
//   - gint: integer value of key.
func (settings *PrintSettings) IntWithDefault(key string, def int) int {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.int               // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(def)

	_cret = C.gtk_print_settings_get_int_with_default(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(def)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Length returns the value associated with key, interpreted as a length.
//
// The returned value is converted to units.
//
// The function takes the following parameters:
//
//   - key: key.
//   - unit of the return value.
//
// The function returns the following values:
//
//   - gdouble: length value of key, converted to unit.
func (settings *PrintSettings) Length(key string, unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.GtkUnit           // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GtkUnit(unit)

	_cret = C.gtk_print_settings_get_length(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
//
// The function returns the following values:
//
//   - utf8: media type.
func (settings *PrintSettings) MediaType() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_media_type(_arg0)
	runtime.KeepAlive(settings)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
//
// The function returns the following values:
//
//   - gint: number of copies to print.
func (settings *PrintSettings) NCopies() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_n_copies(_arg0)
	runtime.KeepAlive(settings)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
//
// The function returns the following values:
//
//   - gint: number of pages per sheet.
func (settings *PrintSettings) NumberUp() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_number_up(_arg0)
	runtime.KeepAlive(settings)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
//
// The function returns the following values:
//
//   - numberUpLayout: layout of page in number-up mode.
func (settings *PrintSettings) NumberUpLayout() NumberUpLayout {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkNumberUpLayout // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_number_up_layout(_arg0)
	runtime.KeepAlive(settings)

	var _numberUpLayout NumberUpLayout // out

	_numberUpLayout = NumberUpLayout(_cret)

	return _numberUpLayout
}

// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted to a
// GtkPageOrientation.
//
// The function returns the following values:
//
//   - pageOrientation: orientation.
func (settings *PrintSettings) Orientation() PageOrientation {
	var _arg0 *C.GtkPrintSettings  // out
	var _cret C.GtkPageOrientation // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_orientation(_arg0)
	runtime.KeepAlive(settings)

	var _pageOrientation PageOrientation // out

	_pageOrientation = PageOrientation(_cret)

	return _pageOrientation
}

// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
//
// The function returns the following values:
//
//   - utf8: output bin.
func (settings *PrintSettings) OutputBin() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_output_bin(_arg0)
	runtime.KeepAlive(settings)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PageRanges gets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
//
// The function returns the following values:
//
//   - pageRanges: array of GtkPageRanges. Use g_free() to free the array when
//     it is no longer needed.
func (settings *PrintSettings) PageRanges() []PageRange {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GtkPageRange     // in
	var _arg1 C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_page_ranges(_arg0, &_arg1)
	runtime.KeepAlive(settings)

	var _pageRanges []PageRange // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((*C.GtkPageRange)(_cret), _arg1)
		_pageRanges = make([]PageRange, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_pageRanges[i] = *(*PageRange)(gextras.NewStructNative(unsafe.Pointer((&src[i]))))
			runtime.SetFinalizer(
				gextras.StructIntern(unsafe.Pointer(&_pageRanges[i])),
				func(intern *struct{ C unsafe.Pointer }) {
					C.free(intern.C)
				},
			)
		}
	}

	return _pageRanges
}

// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
//
// The function returns the following values:
//
//   - pageSet: set of pages to print.
func (settings *PrintSettings) PageSet() PageSet {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPageSet        // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_page_set(_arg0)
	runtime.KeepAlive(settings)

	var _pageSet PageSet // out

	_pageSet = PageSet(_cret)

	return _pageSet
}

// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted to
// unit.
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: paper height, in units of unit.
func (settings *PrintSettings) PaperHeight(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkUnit           // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_print_settings_get_paper_height(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to a
// GtkPaperSize.
//
// The function returns the following values:
//
//   - paperSize: paper size.
func (settings *PrintSettings) PaperSize() *PaperSize {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GtkPaperSize     // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_paper_size(_arg0)
	runtime.KeepAlive(settings)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)

	return _paperSize
}

// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// unit.
//
// The function takes the following parameters:
//
//   - unit for the return value.
//
// The function returns the following values:
//
//   - gdouble: paper width, in units of unit.
func (settings *PrintSettings) PaperWidth(unit Unit) float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkUnit           // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_print_settings_get_paper_width(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
//
// The function returns the following values:
//
//   - printPages: which pages to print.
func (settings *PrintSettings) PrintPages() PrintPages {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintPages     // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_print_pages(_arg0)
	runtime.KeepAlive(settings)

	var _printPages PrintPages // out

	_printPages = PrintPages(_cret)

	return _printPages
}

// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
//
// The function returns the following values:
//
//   - utf8: printer name.
func (settings *PrintSettings) Printer() string {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_printer(_arg0)
	runtime.KeepAlive(settings)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
//
// The function returns the following values:
//
//   - gdouble: resolution in lpi (lines per inch).
func (settings *PrintSettings) PrinterLpi() float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_printer_lpi(_arg0)
	runtime.KeepAlive(settings)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
//
// The function returns the following values:
//
//   - printQuality: print quality.
func (settings *PrintSettings) Quality() PrintQuality {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.GtkPrintQuality   // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_quality(_arg0)
	runtime.KeepAlive(settings)

	var _printQuality PrintQuality // out

	_printQuality = PrintQuality(_cret)

	return _printQuality
}

// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
//
// The function returns the following values:
//
//   - gint: resolution in dpi.
func (settings *PrintSettings) Resolution() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_resolution(_arg0)
	runtime.KeepAlive(settings)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
//
// The function returns the following values:
//
//   - gint: horizontal resolution in dpi.
func (settings *PrintSettings) ResolutionX() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_resolution_x(_arg0)
	runtime.KeepAlive(settings)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
//
// The function returns the following values:
//
//   - gint: vertical resolution in dpi.
func (settings *PrintSettings) ResolutionY() int {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.int               // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_resolution_y(_arg0)
	runtime.KeepAlive(settings)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
//
// The function returns the following values:
//
//   - ok: whether to reverse the order of the printed pages.
func (settings *PrintSettings) Reverse() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_reverse(_arg0)
	runtime.KeepAlive(settings)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
//
// The function returns the following values:
//
//   - gdouble: scale in percent.
func (settings *PrintSettings) Scale() float64 {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.double            // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_scale(_arg0)
	runtime.KeepAlive(settings)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
//
// The function returns the following values:
//
//   - ok: whether to use color.
func (settings *PrintSettings) UseColor() bool {
	var _arg0 *C.GtkPrintSettings // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_get_use_color(_arg0)
	runtime.KeepAlive(settings)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasKey returns TRUE, if a value is associated with key.
//
// The function takes the following parameters:
//
//   - key: key.
//
// The function returns the following values:
//
//   - ok: TRUE, if key has a value.
func (settings *PrintSettings) HasKey(key string) bool {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_print_settings_has_key(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LoadFile reads the print settings from file_name.
//
// If the file could not be loaded then error is set to either a GFileError or
// GKeyFileError.
//
// See gtk.PrintSettings.ToFile().
//
// The function takes the following parameters:
//
//   - fileName: filename to read the settings from.
func (settings *PrintSettings) LoadFile(fileName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_load_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(fileName)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadKeyFile reads the print settings from the group group_name in key_file.
//
// If the file could not be loaded then error is set to either a GFileError or
// GKeyFileError.
//
// The function takes the following parameters:
//
//   - keyFile: GKeyFile to retrieve the settings from.
//   - groupName (optional): name of the group to use, or NULL to use the
//     default “Print Settings”.
func (settings *PrintSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_print_settings_load_key_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Set associates value with key.
//
// The function takes the following parameters:
//
//   - key: key.
//   - value (optional): string value, or NULL.
func (settings *PrintSettings) Set(key, value string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	if value != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_print_settings_set(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetBool sets key to a boolean value.
//
// The function takes the following parameters:
//
//   - key: key.
//   - value: boolean.
func (settings *PrintSettings) SetBool(key string, value bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	if value {
		_arg2 = C.TRUE
	}

	C.gtk_print_settings_set_bool(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
//
// The function takes the following parameters:
//
//   - collate: whether to collate the output.
func (settings *PrintSettings) SetCollate(collate bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	if collate {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_collate(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(collate)
}

// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
//
// The function takes the following parameters:
//
//   - defaultSource: default source.
func (settings *PrintSettings) SetDefaultSource(defaultSource string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(defaultSource)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_default_source(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(defaultSource)
}

// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
//
// The function takes the following parameters:
//
//   - dither: dithering that is used.
func (settings *PrintSettings) SetDither(dither string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(dither)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_dither(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(dither)
}

// SetDouble sets key to a double value.
//
// The function takes the following parameters:
//
//   - key: key.
//   - value: double value.
func (settings *PrintSettings) SetDouble(key string, value float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.double            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(value)

	C.gtk_print_settings_set_double(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
//
// The function takes the following parameters:
//
//   - duplex: PrintDuplex value.
func (settings *PrintSettings) SetDuplex(duplex PrintDuplex) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintDuplex    // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkPrintDuplex(duplex)

	C.gtk_print_settings_set_duplex(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(duplex)
}

// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
//
// The function takes the following parameters:
//
//   - finishings: finishings.
func (settings *PrintSettings) SetFinishings(finishings string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(finishings)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_finishings(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(finishings)
}

// SetInt sets key to an integer value.
//
// The function takes the following parameters:
//
//   - key: key.
//   - value: integer.
func (settings *PrintSettings) SetInt(key string, value int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(value)

	C.gtk_print_settings_set_int(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
}

// SetLength associates a length in units of unit with key.
//
// The function takes the following parameters:
//
//   - key: key.
//   - value: length.
//   - unit of length.
func (settings *PrintSettings) SetLength(key string, value float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _arg2 C.double            // out
	var _arg3 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(value)
	_arg3 = C.GtkUnit(unit)

	C.gtk_print_settings_set_length(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)
	runtime.KeepAlive(unit)
}

// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
//
// The set of media types is defined in PWG 5101.1-2002 PWG.
//
// The function takes the following parameters:
//
//   - mediaType: media type.
func (settings *PrintSettings) SetMediaType(mediaType string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(mediaType)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_media_type(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(mediaType)
}

// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
//
// The function takes the following parameters:
//
//   - numCopies: number of copies.
func (settings *PrintSettings) SetNCopies(numCopies int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.int(numCopies)

	C.gtk_print_settings_set_n_copies(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(numCopies)
}

// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
//
// The function takes the following parameters:
//
//   - numberUp: number of pages per sheet.
func (settings *PrintSettings) SetNumberUp(numberUp int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.int(numberUp)

	C.gtk_print_settings_set_number_up(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(numberUp)
}

// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
//
// The function takes the following parameters:
//
//   - numberUpLayout: NumberUpLayout value.
func (settings *PrintSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkNumberUpLayout // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkNumberUpLayout(numberUpLayout)

	C.gtk_print_settings_set_number_up_layout(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(numberUpLayout)
}

// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
//
// The function takes the following parameters:
//
//   - orientation: page orientation.
func (settings *PrintSettings) SetOrientation(orientation PageOrientation) {
	var _arg0 *C.GtkPrintSettings  // out
	var _arg1 C.GtkPageOrientation // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkPageOrientation(orientation)

	C.gtk_print_settings_set_orientation(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(orientation)
}

// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
//
// The function takes the following parameters:
//
//   - outputBin: output bin.
func (settings *PrintSettings) SetOutputBin(outputBin string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(outputBin)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_output_bin(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(outputBin)
}

// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
//
// The function takes the following parameters:
//
//   - pageRanges: array of GtkPageRanges.
func (settings *PrintSettings) SetPageRanges(pageRanges []PageRange) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GtkPageRange     // out
	var _arg2 C.int

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg2 = (C.int)(len(pageRanges))
	_arg1 = (*C.GtkPageRange)(C.calloc(C.size_t(len(pageRanges)), C.size_t(C.sizeof_GtkPageRange)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.GtkPageRange)(_arg1), len(pageRanges))
		for i := range pageRanges {
			out[i] = *(*C.GtkPageRange)(gextras.StructNative(unsafe.Pointer((&pageRanges[i]))))
		}
	}

	C.gtk_print_settings_set_page_ranges(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(pageRanges)
}

// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
//
// The function takes the following parameters:
//
//   - pageSet: PageSet value.
func (settings *PrintSettings) SetPageSet(pageSet PageSet) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPageSet        // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkPageSet(pageSet)

	C.gtk_print_settings_set_page_set(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(pageSet)
}

// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
//
// The function takes the following parameters:
//
//   - height: paper height.
//   - unit units of height.
func (settings *PrintSettings) SetPaperHeight(height float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out
	var _arg2 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.double(height)
	_arg2 = C.GtkUnit(unit)

	C.gtk_print_settings_set_paper_height(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(height)
	runtime.KeepAlive(unit)
}

// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
//
// The function takes the following parameters:
//
//   - paperSize: paper size.
func (settings *PrintSettings) SetPaperSize(paperSize *PaperSize) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GtkPaperSize     // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(paperSize)))

	C.gtk_print_settings_set_paper_size(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(paperSize)
}

// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
//
// The function takes the following parameters:
//
//   - width: paper width.
//   - unit units of width.
func (settings *PrintSettings) SetPaperWidth(width float64, unit Unit) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out
	var _arg2 C.GtkUnit           // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.double(width)
	_arg2 = C.GtkUnit(unit)

	C.gtk_print_settings_set_paper_width(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(width)
	runtime.KeepAlive(unit)
}

// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
//
// The function takes the following parameters:
//
//   - pages PrintPages value.
func (settings *PrintSettings) SetPrintPages(pages PrintPages) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintPages     // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkPrintPages(pages)

	C.gtk_print_settings_set_print_pages(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(pages)
}

// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// printer.
//
// The function takes the following parameters:
//
//   - printer name.
func (settings *PrintSettings) SetPrinter(printer string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(printer)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_set_printer(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(printer)
}

// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
//
// The function takes the following parameters:
//
//   - lpi: resolution in lpi (lines per inch).
func (settings *PrintSettings) SetPrinterLpi(lpi float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.double(lpi)

	C.gtk_print_settings_set_printer_lpi(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(lpi)
}

// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
//
// The function takes the following parameters:
//
//   - quality: PrintQuality value.
func (settings *PrintSettings) SetQuality(quality PrintQuality) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.GtkPrintQuality   // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.GtkPrintQuality(quality)

	C.gtk_print_settings_set_quality(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(quality)
}

// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
//
// The function takes the following parameters:
//
//   - resolution in dpi.
func (settings *PrintSettings) SetResolution(resolution int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.int(resolution)

	C.gtk_print_settings_set_resolution(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(resolution)
}

// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
//
// The function takes the following parameters:
//
//   - resolutionX: horizontal resolution in dpi.
//   - resolutionY: vertical resolution in dpi.
func (settings *PrintSettings) SetResolutionXY(resolutionX, resolutionY int) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.int               // out
	var _arg2 C.int               // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.int(resolutionX)
	_arg2 = C.int(resolutionY)

	C.gtk_print_settings_set_resolution_xy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(resolutionX)
	runtime.KeepAlive(resolutionY)
}

// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
//
// The function takes the following parameters:
//
//   - reverse: whether to reverse the output.
func (settings *PrintSettings) SetReverse(reverse bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	if reverse {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_reverse(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(reverse)
}

// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
//
// The function takes the following parameters:
//
//   - scale in percent.
func (settings *PrintSettings) SetScale(scale float64) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.double            // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = C.double(scale)

	C.gtk_print_settings_set_scale(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(scale)
}

// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
//
// The function takes the following parameters:
//
//   - useColor: whether to use color.
func (settings *PrintSettings) SetUseColor(useColor bool) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	if useColor {
		_arg1 = C.TRUE
	}

	C.gtk_print_settings_set_use_color(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(useColor)
}

// ToFile: this function saves the print settings from settings to file_name.
//
// If the file could not be written then error is set to either a GFileError or
// GKeyFileError.
//
// The function takes the following parameters:
//
//   - fileName: file to save to.
func (settings *PrintSettings) ToFile(fileName string) error {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(fileName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_to_file(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(fileName)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// ToGVariant: serialize print settings to an a{sv} variant.
//
// The function returns the following values:
//
//   - variant: new, floating, GVariant.
func (settings *PrintSettings) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkPrintSettings // out
	var _cret *C.GVariant         // in

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))

	_cret = C.gtk_print_settings_to_gvariant(_arg0)
	runtime.KeepAlive(settings)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// ToKeyFile: this function adds the print settings from settings to key_file.
//
// The function takes the following parameters:
//
//   - keyFile: GKeyFile to save the print settings to.
//   - groupName (optional): group to add the settings to in key_file, or NULL
//     to use the default “Print Settings”.
func (settings *PrintSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.GKeyFile         // out
	var _arg2 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_print_settings_to_key_file(_arg0, _arg1, _arg2)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
}

// Unset removes any value associated with key.
//
// This has the same effect as setting the value to NULL.
//
// The function takes the following parameters:
//
//   - key: key.
func (settings *PrintSettings) Unset(key string) {
	var _arg0 *C.GtkPrintSettings // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_print_settings_unset(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(key)
}

// ProgressBar: GtkProgressBar is typically used to display the progress of a
// long running operation.
//
// It provides a visual clue that processing is underway. GtkProgressBar can be
// used in two different modes: percentage mode and activity mode.
//
// !An example GtkProgressBar (progressbar.png)
//
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress,
// it can use the GtkProgressBar in percentage mode and the user sees a growing
// bar indicating the percentage of the work that has been completed. In this
// mode, the application is required to call gtk.ProgressBar.SetFraction()
// periodically to update the progress bar.
//
// When an application has no accurate way of knowing the amount of work to do,
// it can use the GtkProgressBar in activity mode, which shows activity by
// a block moving back and forth within the progress area. In this mode,
// the application is required to call gtk.ProgressBar.Pulse() periodically to
// update the progress bar.
//
// There is quite a bit of flexibility provided to control the appearance of the
// GtkProgressBar. Functions are provided to control the orientation of the bar,
// optional text can be displayed along with the bar, and the step size used in
// activity mode can be set.
//
// CSS nodes
//
//	progressbar[.osd]
//	├── [text]
//	╰── trough[.empty][.full]
//	    ╰── progress[.pulse]
//
// GtkProgressBar has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
//
// # Accessibility
//
// GtkProgressBar uses the K_ACCESSIBLE_ROLE_PROGRESS_BAR role.
type ProgressBar struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*ProgressBar)(nil)
	_ coreglib.Objector = (*ProgressBar)(nil)
)

func wrapProgressBar(obj *coreglib.Object) *ProgressBar {
	return &ProgressBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalProgressBar(p uintptr) (interface{}, error) {
	return wrapProgressBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewProgressBar creates a new GtkProgressBar.
//
// The function returns the following values:
//
//   - progressBar: GtkProgressBar.
func NewProgressBar() *ProgressBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_progress_bar_new()

	var _progressBar *ProgressBar // out

	_progressBar = wrapProgressBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _progressBar
}

// Ellipsize returns the ellipsizing position of the progress bar.
//
// See gtk.ProgressBar.SetEllipsize().
//
// The function returns the following values:
//
//   - ellipsizeMode: PangoEllipsizeMode.
func (pbar *ProgressBar) Ellipsize() pango.EllipsizeMode {
	var _arg0 *C.GtkProgressBar    // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))

	_cret = C.gtk_progress_bar_get_ellipsize(_arg0)
	runtime.KeepAlive(pbar)

	var _ellipsizeMode pango.EllipsizeMode // out

	_ellipsizeMode = pango.EllipsizeMode(_cret)

	return _ellipsizeMode
}

// Fraction returns the current fraction of the task that’s been completed.
//
// The function returns the following values:
//
//   - gdouble: fraction from 0.0 to 1.0.
func (pbar *ProgressBar) Fraction() float64 {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.double          // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))

	_cret = C.gtk_progress_bar_get_fraction(_arg0)
	runtime.KeepAlive(pbar)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Inverted returns whether the progress bar is inverted.
//
// The function returns the following values:
//
//   - ok: TRUE if the progress bar is inverted.
func (pbar *ProgressBar) Inverted() bool {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))

	_cret = C.gtk_progress_bar_get_inverted(_arg0)
	runtime.KeepAlive(pbar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PulseStep retrieves the pulse step.
//
// See gtk.ProgressBar.SetPulseStep().
//
// The function returns the following values:
//
//   - gdouble: fraction from 0.0 to 1.0.
func (pbar *ProgressBar) PulseStep() float64 {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.double          // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))

	_cret = C.gtk_progress_bar_get_pulse_step(_arg0)
	runtime.KeepAlive(pbar)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ShowText returns whether the GtkProgressBar shows text.
//
// See gtk.ProgressBar.SetShowText().
//
// The function returns the following values:
//
//   - ok: TRUE if text is shown in the progress bar.
func (pbar *ProgressBar) ShowText() bool {
	var _arg0 *C.GtkProgressBar // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))

	_cret = C.gtk_progress_bar_get_show_text(_arg0)
	runtime.KeepAlive(pbar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Text retrieves the text that is displayed with the progress bar.
//
// The return value is a reference to the text, not a copy of it, so will become
// invalid if you change the text in the progress bar.
//
// The function returns the following values:
//
//   - utf8 (optional): text, or NULL; this string is owned by the widget and
//     should not be modified or freed.
func (pbar *ProgressBar) Text() string {
	var _arg0 *C.GtkProgressBar // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))

	_cret = C.gtk_progress_bar_get_text(_arg0)
	runtime.KeepAlive(pbar)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Pulse indicates that some progress has been made, but you don’t know how
// much.
//
// Causes the progress bar to enter “activity mode,” where a block bounces
// back and forth. Each call to gtk.ProgressBar.Pulse() causes the block to
// move by a little bit (the amount of movement per pulse is determined by
// gtk.ProgressBar.SetPulseStep()).
func (pbar *ProgressBar) Pulse() {
	var _arg0 *C.GtkProgressBar // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))

	C.gtk_progress_bar_pulse(_arg0)
	runtime.KeepAlive(pbar)
}

// SetEllipsize sets the mode used to ellipsize the text.
//
// The text is ellipsized if there is not enough space to render the entire
// string.
//
// The function takes the following parameters:
//
//   - mode: PangoEllipsizeMode.
func (pbar *ProgressBar) SetEllipsize(mode pango.EllipsizeMode) {
	var _arg0 *C.GtkProgressBar    // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))
	_arg1 = C.PangoEllipsizeMode(mode)

	C.gtk_progress_bar_set_ellipsize(_arg0, _arg1)
	runtime.KeepAlive(pbar)
	runtime.KeepAlive(mode)
}

// SetFraction causes the progress bar to “fill in” the given fraction of the
// bar.
//
// The fraction should be between 0.0 and 1.0, inclusive.
//
// The function takes the following parameters:
//
//   - fraction of the task that’s been completed.
func (pbar *ProgressBar) SetFraction(fraction float64) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))
	_arg1 = C.double(fraction)

	C.gtk_progress_bar_set_fraction(_arg0, _arg1)
	runtime.KeepAlive(pbar)
	runtime.KeepAlive(fraction)
}

// SetInverted sets whether the progress bar is inverted.
//
// Progress bars normally grow from top to bottom or left to right. Inverted
// progress bars grow in the opposite direction.
//
// The function takes the following parameters:
//
//   - inverted: TRUE to invert the progress bar.
func (pbar *ProgressBar) SetInverted(inverted bool) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))
	if inverted {
		_arg1 = C.TRUE
	}

	C.gtk_progress_bar_set_inverted(_arg0, _arg1)
	runtime.KeepAlive(pbar)
	runtime.KeepAlive(inverted)
}

// SetPulseStep sets the fraction of total progress bar length to move the
// bouncing block.
//
// The bouncing block is moved when gtk.ProgressBar.Pulse() is called.
//
// The function takes the following parameters:
//
//   - fraction between 0.0 and 1.0.
func (pbar *ProgressBar) SetPulseStep(fraction float64) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))
	_arg1 = C.double(fraction)

	C.gtk_progress_bar_set_pulse_step(_arg0, _arg1)
	runtime.KeepAlive(pbar)
	runtime.KeepAlive(fraction)
}

// SetShowText sets whether the progress bar will show text next to the bar.
//
// The shown text is either the value of the gtk.ProgressBar:text property or,
// if that is NULL, the gtk.ProgressBar:fraction value, as a percentage.
//
// To make a progress bar that is styled and sized suitably for containing text
// (even if the actual text is blank), set gtk.ProgressBar:show-text to TRUE and
// gtk.ProgressBar:text to the empty string (not NULL).
//
// The function takes the following parameters:
//
//   - showText: whether to show text.
func (pbar *ProgressBar) SetShowText(showText bool) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))
	if showText {
		_arg1 = C.TRUE
	}

	C.gtk_progress_bar_set_show_text(_arg0, _arg1)
	runtime.KeepAlive(pbar)
	runtime.KeepAlive(showText)
}

// SetText causes the given text to appear next to the progress bar.
//
// If text is NULL and gtk.ProgressBar:show-text is TRUE, the current value of
// gtk.ProgressBar:fraction will be displayed as a percentage.
//
// If text is non-NULL and gtk.ProgressBar:show-text is TRUE, the text will
// be displayed. In this case, it will not display the progress percentage.
// If text is the empty string, the progress bar will still be styled and sized
// suitably for containing text, as long as gtk.ProgressBar:show-text is TRUE.
//
// The function takes the following parameters:
//
//   - text (optional): UTF-8 string, or NULL.
func (pbar *ProgressBar) SetText(text string) {
	var _arg0 *C.GtkProgressBar // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(coreglib.InternObject(pbar).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_progress_bar_set_text(_arg0, _arg1)
	runtime.KeepAlive(pbar)
	runtime.KeepAlive(text)
}

// PropertyExpression: GObject property value in a GtkExpression.
type PropertyExpression struct {
	_ [0]func() // equal guard
	Expression
}

var (
	_ Expressioner = (*PropertyExpression)(nil)
)

func wrapPropertyExpression(obj *coreglib.Object) *PropertyExpression {
	return &PropertyExpression{
		Expression: Expression{
			Object: obj,
		},
	}
}

func marshalPropertyExpression(p uintptr) (interface{}, error) {
	return wrapPropertyExpression(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPropertyExpression creates an expression that looks up a property via the
// given expression or the this argument when expression is NULL.
//
// If the resulting object conforms to this_type, its property named
// property_name will be queried. Otherwise, this expression's evaluation will
// fail.
//
// The given this_type must have a property with property_name.
//
// The function takes the following parameters:
//
//   - thisType: type to expect for the this type.
//   - expression (optional): expression to evaluate to get the object to query
//     or NULL to query the this object.
//   - propertyName: name of the property.
//
// The function returns the following values:
//
//   - propertyExpression: new GtkExpression.
func NewPropertyExpression(thisType coreglib.Type, expression Expressioner, propertyName string) *PropertyExpression {
	var _arg1 C.GType          // out
	var _arg2 *C.GtkExpression // out
	var _arg3 *C.char          // out
	var _cret *C.GtkExpression // in

	_arg1 = C.GType(thisType)
	if expression != nil {
		_arg2 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_property_expression_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(thisType)
	runtime.KeepAlive(expression)
	runtime.KeepAlive(propertyName)

	var _propertyExpression *PropertyExpression // out

	_propertyExpression = wrapPropertyExpression(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _propertyExpression
}

// GetExpression gets the expression specifying the object of a property
// expression.
//
// The function returns the following values:
//
//   - ret: object expression.
func (expression *PropertyExpression) GetExpression() Expressioner {
	var _arg0 *C.GtkExpression // out
	var _cret *C.GtkExpression // in

	_arg0 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))

	_cret = C.gtk_property_expression_get_expression(_arg0)
	runtime.KeepAlive(expression)

	var _ret Expressioner // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Expressioner is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Expressioner)
			return ok
		})
		rv, ok := casted.(Expressioner)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
		}
		_ret = rv
	}

	return _ret
}

// RangeOverrides contains methods that are overridable.
type RangeOverrides struct {
	AdjustBounds func(newValue float64)
	// The function takes the following parameters:
	//
	//   - scroll
	//   - newValue
	ChangeValue  func(scroll ScrollType, newValue float64) bool
	RangeBorder  func(border_ *Border)
	MoveSlider   func(scroll ScrollType)
	ValueChanged func()
}

func defaultRangeOverrides(v *Range) RangeOverrides {
	return RangeOverrides{
		AdjustBounds: v.adjustBounds,
		ChangeValue:  v.changeValue,
		RangeBorder:  v.rangeBorder,
		MoveSlider:   v.moveSlider,
		ValueChanged: v.valueChanged,
	}
}

// Range: GtkRange is the common base class for widgets which visualize an
// adjustment.
//
// Widgets that are derived from GtkRange include gtk.Scale and gtk.Scrollbar.
//
// Apart from signals for monitoring the parameters of the adjustment, GtkRange
// provides properties and methods for setting a “fill level” on range widgets.
// See gtk.Range.SetFillLevel().
type Range struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*Range)(nil)
	_ coreglib.Objector = (*Range)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Range, *RangeClass, RangeOverrides](
		GTypeRange,
		initRangeClass,
		wrapRange,
		defaultRangeOverrides,
	)
}

func initRangeClass(gclass unsafe.Pointer, overrides RangeOverrides, classInitFunc func(*RangeClass)) {
	pclass := (*C.GtkRangeClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRange))))

	if overrides.AdjustBounds != nil {
		pclass.adjust_bounds = (*[0]byte)(C._gotk4_gtk4_RangeClass_adjust_bounds)
	}

	if overrides.ChangeValue != nil {
		pclass.change_value = (*[0]byte)(C._gotk4_gtk4_RangeClass_change_value)
	}

	if overrides.RangeBorder != nil {
		pclass.get_range_border = (*[0]byte)(C._gotk4_gtk4_RangeClass_get_range_border)
	}

	if overrides.MoveSlider != nil {
		pclass.move_slider = (*[0]byte)(C._gotk4_gtk4_RangeClass_move_slider)
	}

	if overrides.ValueChanged != nil {
		pclass.value_changed = (*[0]byte)(C._gotk4_gtk4_RangeClass_value_changed)
	}

	if classInitFunc != nil {
		class := (*RangeClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRange(obj *coreglib.Object) *Range {
	return &Range{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalRange(p uintptr) (interface{}, error) {
	return wrapRange(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectAdjustBounds is emitted before clamping a value, to give the
// application a chance to adjust the bounds.
func (_range *Range) ConnectAdjustBounds(f func(value float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(_range, "adjust-bounds", false, unsafe.Pointer(C._gotk4_gtk4_Range_ConnectAdjustBounds), f)
}

// ConnectChangeValue is emitted when a scroll action is performed on a range.
//
// It allows an application to determine the type of scroll event that occurred
// and the resultant new value. The application can handle the event itself and
// return TRUE to prevent further processing. Or, by returning FALSE, it can
// pass the event to other handlers until the default GTK handler is reached.
//
// The value parameter is unrounded. An application that overrides the
// ::change-value signal is responsible for clamping the value to the desired
// number of decimal digits; the default GTK handler clamps the value based on
// gtk.Range:round-digits.
func (_range *Range) ConnectChangeValue(f func(scroll ScrollType, value float64) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(_range, "change-value", false, unsafe.Pointer(C._gotk4_gtk4_Range_ConnectChangeValue), f)
}

// ConnectMoveSlider: virtual function that moves the slider.
//
// Used for keybindings.
func (_range *Range) ConnectMoveSlider(f func(step ScrollType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(_range, "move-slider", false, unsafe.Pointer(C._gotk4_gtk4_Range_ConnectMoveSlider), f)
}

// ConnectValueChanged is emitted when the range value changes.
func (_range *Range) ConnectValueChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(_range, "value-changed", false, unsafe.Pointer(C._gotk4_gtk4_Range_ConnectValueChanged), f)
}

// Adjustment: get the adjustment which is the “model” object for GtkRange.
//
// The function returns the following values:
//
//   - adjustment: GtkAdjustment.
func (_range *Range) Adjustment() *Adjustment {
	var _arg0 *C.GtkRange      // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_adjustment(_arg0)
	runtime.KeepAlive(_range)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// FillLevel gets the current position of the fill level indicator.
//
// The function returns the following values:
//
//   - gdouble: current fill level.
func (_range *Range) FillLevel() float64 {
	var _arg0 *C.GtkRange // out
	var _cret C.double    // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_fill_level(_arg0)
	runtime.KeepAlive(_range)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Flippable gets whether the GtkRange respects text direction.
//
// See gtk.Range.SetFlippable().
//
// The function returns the following values:
//
//   - ok: TRUE if the range is flippable.
func (_range *Range) Flippable() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_flippable(_arg0)
	runtime.KeepAlive(_range)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Inverted gets whether the range is inverted.
//
// See gtk.Range.SetInverted().
//
// The function returns the following values:
//
//   - ok: TRUE if the range is inverted.
func (_range *Range) Inverted() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_inverted(_arg0)
	runtime.KeepAlive(_range)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RangeRect: this function returns the area that contains the range’s trough,
// in coordinates relative to range's origin.
//
// This function is useful mainly for GtkRange subclasses.
//
// The function returns the following values:
//
//   - rangeRect: return location for the range rectangle.
func (_range *Range) RangeRect() *gdk.Rectangle {
	var _arg0 *C.GtkRange    // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	C.gtk_range_get_range_rect(_arg0, &_arg1)
	runtime.KeepAlive(_range)

	var _rangeRect *gdk.Rectangle // out

	_rangeRect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _rangeRect
}

// RestrictToFillLevel gets whether the range is restricted to the fill level.
//
// The function returns the following values:
//
//   - ok: TRUE if range is restricted to the fill level.
func (_range *Range) RestrictToFillLevel() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_restrict_to_fill_level(_arg0)
	runtime.KeepAlive(_range)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RoundDigits gets the number of digits to round the value to when it changes.
//
// See gtk.Range::change-value.
//
// The function returns the following values:
//
//   - gint: number of digits to round to.
func (_range *Range) RoundDigits() int {
	var _arg0 *C.GtkRange // out
	var _cret C.int       // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_round_digits(_arg0)
	runtime.KeepAlive(_range)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ShowFillLevel gets whether the range displays the fill level graphically.
//
// The function returns the following values:
//
//   - ok: TRUE if range shows the fill level.
func (_range *Range) ShowFillLevel() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_show_fill_level(_arg0)
	runtime.KeepAlive(_range)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SliderRange: this function returns sliders range along the long dimension,
// in widget->window coordinates.
//
// This function is useful mainly for GtkRange subclasses.
//
// The function returns the following values:
//
//   - sliderStart (optional): return location for the slider's start, or NULL.
//   - sliderEnd (optional): return location for the slider's end, or NULL.
func (_range *Range) SliderRange() (sliderStart, sliderEnd int) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	C.gtk_range_get_slider_range(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(_range)

	var _sliderStart int // out
	var _sliderEnd int   // out

	_sliderStart = int(_arg1)
	_sliderEnd = int(_arg2)

	return _sliderStart, _sliderEnd
}

// SliderSizeFixed: this function is useful mainly for GtkRange subclasses.
//
// See gtk.Range.SetSliderSizeFixed().
//
// The function returns the following values:
//
//   - ok: whether the range’s slider has a fixed size.
func (_range *Range) SliderSizeFixed() bool {
	var _arg0 *C.GtkRange // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_slider_size_fixed(_arg0)
	runtime.KeepAlive(_range)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Value gets the current value of the range.
//
// The function returns the following values:
//
//   - gdouble: current value of the range.
func (_range *Range) Value() float64 {
	var _arg0 *C.GtkRange // out
	var _cret C.double    // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	_cret = C.gtk_range_get_value(_arg0)
	runtime.KeepAlive(_range)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SetAdjustment sets the adjustment to be used as the “model” object for the
// GtkRange
//
// The adjustment indicates the current range value, the minimum and maximum
// range values, the step/page increments used for keybindings and scrolling,
// and the page size.
//
// The page size is normally 0 for GtkScale and nonzero for GtkScrollbar,
// and indicates the size of the visible area of the widget being scrolled.
// The page size affects the size of the scrollbar slider.
//
// The function takes the following parameters:
//
//   - adjustment: GtkAdjustment.
func (_range *Range) SetAdjustment(adjustment *Adjustment) {
	var _arg0 *C.GtkRange      // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	C.gtk_range_set_adjustment(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(adjustment)
}

// SetFillLevel: set the new position of the fill level indicator.
//
// The “fill level” is probably best described by its most prominent use case,
// which is an indicator for the amount of pre-buffering in a streaming media
// player. In that use case, the value of the range would indicate the current
// play position, and the fill level would be the position up to which the
// file/stream has been downloaded.
//
// This amount of prebuffering can be displayed on the range’s trough and
// is themeable separately from the trough. To enable fill level display,
// use gtk.Range.SetShowFillLevel(). The range defaults to not showing the fill
// level.
//
// Additionally, it’s possible to restrict the range’s slider position
// to values which are smaller than the fill level. This is controlled by
// gtk.Range.SetRestrictToFillLevel() and is by default enabled.
//
// The function takes the following parameters:
//
//   - fillLevel: new position of the fill level indicator.
func (_range *Range) SetFillLevel(fillLevel float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.double(fillLevel)

	C.gtk_range_set_fill_level(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(fillLevel)
}

// SetFlippable sets whether the GtkRange respects text direction.
//
// If a range is flippable, it will switch its direction if it is horizontal and
// its direction is GTK_TEXT_DIR_RTL.
//
// See gtk.Widget.GetDirection().
//
// The function takes the following parameters:
//
//   - flippable: TRUE to make the range flippable.
func (_range *Range) SetFlippable(flippable bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	if flippable {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_flippable(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(flippable)
}

// SetIncrements sets the step and page sizes for the range.
//
// The step size is used when the user clicks the GtkScrollbar arrows or moves
// a GtkScale via arrow keys. The page size is used for example when moving via
// Page Up or Page Down keys.
//
// The function takes the following parameters:
//
//   - step size.
//   - page size.
func (_range *Range) SetIncrements(step, page float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out
	var _arg2 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.double(step)
	_arg2 = C.double(page)

	C.gtk_range_set_increments(_arg0, _arg1, _arg2)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(step)
	runtime.KeepAlive(page)
}

// SetInverted sets whether to invert the range.
//
// Ranges normally move from lower to higher values as the slider moves from top
// to bottom or left to right. Inverted ranges have higher values at the top or
// on the right rather than on the bottom or left.
//
// The function takes the following parameters:
//
//   - setting: TRUE to invert the range.
func (_range *Range) SetInverted(setting bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_inverted(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(setting)
}

// SetRange sets the allowable values in the GtkRange.
//
// The range value is clamped to be between min and max. (If the range has a
// non-zero page size, it is clamped between min and max - page-size.).
//
// The function takes the following parameters:
//
//   - min: minimum range value.
//   - max: maximum range value.
func (_range *Range) SetRange(min, max float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out
	var _arg2 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.double(min)
	_arg2 = C.double(max)

	C.gtk_range_set_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
}

// SetRestrictToFillLevel sets whether the slider is restricted to the fill
// level.
//
// See gtk.Range.SetFillLevel() for a general description of the fill level
// concept.
//
// The function takes the following parameters:
//
//   - restrictToFillLevel: whether the fill level restricts slider movement.
func (_range *Range) SetRestrictToFillLevel(restrictToFillLevel bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	if restrictToFillLevel {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_restrict_to_fill_level(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(restrictToFillLevel)
}

// SetRoundDigits sets the number of digits to round the value to when it
// changes.
//
// See gtk.Range::change-value.
//
// The function takes the following parameters:
//
//   - roundDigits: precision in digits, or -1.
func (_range *Range) SetRoundDigits(roundDigits int) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.int(roundDigits)

	C.gtk_range_set_round_digits(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(roundDigits)
}

// SetShowFillLevel sets whether a graphical fill level is show on the trough.
//
// See gtk.Range.SetFillLevel() for a general description of the fill level
// concept.
//
// The function takes the following parameters:
//
//   - showFillLevel: whether a fill level indicator graphics is shown.
func (_range *Range) SetShowFillLevel(showFillLevel bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	if showFillLevel {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_show_fill_level(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(showFillLevel)
}

// SetSliderSizeFixed sets whether the range’s slider has a fixed size, or a
// size that depends on its adjustment’s page size.
//
// This function is useful mainly for GtkRange subclasses.
//
// The function takes the following parameters:
//
//   - sizeFixed: TRUE to make the slider size constant.
func (_range *Range) SetSliderSizeFixed(sizeFixed bool) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	if sizeFixed {
		_arg1 = C.TRUE
	}

	C.gtk_range_set_slider_size_fixed(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(sizeFixed)
}

// SetValue sets the current value of the range.
//
// If the value is outside the minimum or maximum range values, it will be
// clamped to fit inside them. The range emits the gtk.Range::value-changed
// signal if the value changes.
//
// The function takes the following parameters:
//
//   - value: new value of the range.
func (_range *Range) SetValue(value float64) {
	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.double(value)

	C.gtk_range_set_value(_arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(value)
}

func (_range *Range) adjustBounds(newValue float64) {
	gclass := (*C.GtkRangeClass)(coreglib.PeekParentClass(_range))
	fnarg := gclass.adjust_bounds

	var _arg0 *C.GtkRange // out
	var _arg1 C.double    // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.double(newValue)

	C._gotk4_gtk4_Range_virtual_adjust_bounds(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(newValue)
}

// The function takes the following parameters:
//
//   - scroll
//   - newValue
func (_range *Range) changeValue(scroll ScrollType, newValue float64) bool {
	gclass := (*C.GtkRangeClass)(coreglib.PeekParentClass(_range))
	fnarg := gclass.change_value

	var _arg0 *C.GtkRange     // out
	var _arg1 C.GtkScrollType // out
	var _arg2 C.double        // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.GtkScrollType(scroll)
	_arg2 = C.double(newValue)

	_cret = C._gotk4_gtk4_Range_virtual_change_value(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(scroll)
	runtime.KeepAlive(newValue)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (_range *Range) rangeBorder(border_ *Border) {
	gclass := (*C.GtkRangeClass)(coreglib.PeekParentClass(_range))
	fnarg := gclass.get_range_border

	var _arg0 *C.GtkRange  // out
	var _arg1 *C.GtkBorder // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = (*C.GtkBorder)(gextras.StructNative(unsafe.Pointer(border_)))

	C._gotk4_gtk4_Range_virtual_get_range_border(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(border_)
}

func (_range *Range) moveSlider(scroll ScrollType) {
	gclass := (*C.GtkRangeClass)(coreglib.PeekParentClass(_range))
	fnarg := gclass.move_slider

	var _arg0 *C.GtkRange     // out
	var _arg1 C.GtkScrollType // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))
	_arg1 = C.GtkScrollType(scroll)

	C._gotk4_gtk4_Range_virtual_move_slider(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(_range)
	runtime.KeepAlive(scroll)
}

func (_range *Range) valueChanged() {
	gclass := (*C.GtkRangeClass)(coreglib.PeekParentClass(_range))
	fnarg := gclass.value_changed

	var _arg0 *C.GtkRange // out

	_arg0 = (*C.GtkRange)(unsafe.Pointer(coreglib.InternObject(_range).Native()))

	C._gotk4_gtk4_Range_virtual_value_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(_range)
}

// RecentManagerOverrides contains methods that are overridable.
type RecentManagerOverrides struct {
	Changed func()
}

func defaultRecentManagerOverrides(v *RecentManager) RecentManagerOverrides {
	return RecentManagerOverrides{
		Changed: v.changed,
	}
}

// RecentManager: GtkRecentManager manages and looks up recently used files.
//
// Each recently used file is identified by its URI, and has meta-data
// associated to it, like the names and command lines of the applications that
// have registered it, the number of time each application has registered the
// same file, the mime type of the file and whether the file should be displayed
// only by the applications that have registered it.
//
// The recently used files list is per user.
//
// GtkRecentManager acts like a database of all the recently used files.
// You can create new GtkRecentManager objects, but it is more efficient to use
// the default manager created by GTK.
//
// Adding a new recently used file is as simple as:
//
//	GtkRecentManager *manager;
//
//	manager = gtk_recent_manager_get_default ();
//	gtk_recent_manager_add_item (manager, file_uri);
//
// The GtkRecentManager will try to gather all the needed information from the
// file itself through GIO.
//
// Looking up the meta-data associated with a recently used file given its URI
// requires calling gtk.RecentManager.LookupItem():
//
//	GtkRecentManager *manager;
//	GtkRecentInfo *info;
//	GError *error = NULL;
//
//	manager = gtk_recent_manager_get_default ();
//	info = gtk_recent_manager_lookup_item (manager, file_uri, &error);
//	if (error)
//	  {
//	    g_warning ("Could not find the file: s", error->message);
//	    g_error_free (error);
//	  }
//	else
//	 {
//	   // Use the info object
//	   gtk_recent_info_unref (info);
//	 }
//
// In order to retrieve the list of recently used files, you can use
// gtk.RecentManager.GetItems(), which returns a list of gtk.RecentInfo.
//
// Note that the maximum age of the recently used files list is controllable
// through the gtk.Settings:gtk-recent-files-max-age property.
type RecentManager struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*RecentManager)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*RecentManager, *RecentManagerClass, RecentManagerOverrides](
		GTypeRecentManager,
		initRecentManagerClass,
		wrapRecentManager,
		defaultRecentManagerOverrides,
	)
}

func initRecentManagerClass(gclass unsafe.Pointer, overrides RecentManagerOverrides, classInitFunc func(*RecentManagerClass)) {
	pclass := (*C.GtkRecentManagerClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeRecentManager))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gtk4_RecentManagerClass_changed)
	}

	if classInitFunc != nil {
		class := (*RecentManagerClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapRecentManager(obj *coreglib.Object) *RecentManager {
	return &RecentManager{
		Object: obj,
	}
}

func marshalRecentManager(p uintptr) (interface{}, error) {
	return wrapRecentManager(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted when the current recently used resources manager
// changes its contents.
//
// This can happen either by calling gtk.RecentManager.AddItem() or by another
// application.
func (manager *RecentManager) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(manager, "changed", false, unsafe.Pointer(C._gotk4_gtk4_RecentManager_ConnectChanged), f)
}

// NewRecentManager creates a new recent manager object.
//
// Recent manager objects are used to handle the list of recently used
// resources. A GtkRecentManager object monitors the recently used resources
// list, and emits the gtk.RecentManager::changed signal each time something
// inside the list changes.
//
// GtkRecentManager objects are expensive: be sure to create them only when
// needed. You should use gtk.RecentManager.GetDefault instead.
//
// The function returns the following values:
//
//   - recentManager: newly created GtkRecentManager object.
func NewRecentManager() *RecentManager {
	var _cret *C.GtkRecentManager // in

	_cret = C.gtk_recent_manager_new()

	var _recentManager *RecentManager // out

	_recentManager = wrapRecentManager(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _recentManager
}

// AddFull adds a new resource, pointed by uri, into the recently used resources
// list, using the metadata specified inside the GtkRecentData passed in
// recent_data.
//
// The passed URI will be used to identify this resource inside the list.
//
// In order to register the new recently used resource, metadata about the
// resource must be passed as well as the URI; the metadata is stored in a
// GtkRecentData, which must contain the MIME type of the resource pointed by
// the URI; the name of the application that is registering the item, and a
// command line to be used when launching the item.
//
// Optionally, a GtkRecentData might contain a UTF-8 string to be used
// when viewing the item instead of the last component of the URI; a short
// description of the item; whether the item should be considered private - that
// is, should be displayed only by the applications that have registered it.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//   - recentData: metadata of the resource.
//
// The function returns the following values:
//
//   - ok: TRUE if the new item was successfully added to the recently used
//     resources list, FALSE otherwise.
func (manager *RecentManager) AddFull(uri string, recentData *RecentData) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _arg2 *C.GtkRecentData    // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkRecentData)(gextras.StructNative(unsafe.Pointer(recentData)))

	_cret = C.gtk_recent_manager_add_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(recentData)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddItem adds a new resource, pointed by uri, into the recently used resources
// list.
//
// This function automatically retrieves some of the needed metadata and
// setting other metadata to common default values; it then feeds the data to
// gtk.RecentManager.AddFull().
//
// See gtk.RecentManager.AddFull() if you want to explicitly define the metadata
// for the resource pointed by uri.
//
// The function takes the following parameters:
//
//   - uri: valid URI.
//
// The function returns the following values:
//
//   - ok: TRUE if the new item was successfully added to the recently used
//     resources list.
func (manager *RecentManager) AddItem(uri string) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_add_item(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Items gets the list of recently used resources.
//
// The function returns the following values:
//
//   - list of newly allocated GtkRecentInfo objects. Use gtk.RecentInfo.Unref()
//     on each item inside the list, and then free the list itself using
//     g_list_free().
func (manager *RecentManager) Items() []*RecentInfo {
	var _arg0 *C.GtkRecentManager // out
	var _cret *C.GList            // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_recent_manager_get_items(_arg0)
	runtime.KeepAlive(manager)

	var _list []*RecentInfo // out

	_list = make([]*RecentInfo, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkRecentInfo)(v)
		var dst *RecentInfo // out
		dst = (*RecentInfo)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_recent_info_unref((*C.GtkRecentInfo)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// HasItem checks whether there is a recently used resource registered with uri
// inside the recent manager.
//
// The function takes the following parameters:
//
//   - uri: URI.
//
// The function returns the following values:
//
//   - ok: TRUE if the resource was found, FALSE otherwise.
func (manager *RecentManager) HasItem(uri string) bool {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_has_item(_arg0, _arg1)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(uri)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupItem searches for a URI inside the recently used resources list,
// and returns a GtkRecentInfo containing information about the resource like
// its MIME type, or its display name.
//
// The function takes the following parameters:
//
//   - uri: URI.
//
// The function returns the following values:
//
//   - recentInfo (optional): GtkRecentInfo containing information about the
//     resource pointed by uri, or NULL if the URI was not registered in the
//     recently used resources list. Free with gtk.RecentInfo.Unref().
func (manager *RecentManager) LookupItem(uri string) (*RecentInfo, error) {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cret *C.GtkRecentInfo    // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_manager_lookup_item(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(uri)

	var _recentInfo *RecentInfo // out
	var _goerr error            // out

	if _cret != nil {
		_recentInfo = (*RecentInfo)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_recentInfo)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_recent_info_unref((*C.GtkRecentInfo)(intern.C))
			},
		)
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _recentInfo, _goerr
}

// MoveItem changes the location of a recently used resource from uri to
// new_uri.
//
// Please note that this function will not affect the resource pointed by the
// URIs, but only the URI used in the recently used resources list.
//
// The function takes the following parameters:
//
//   - uri: URI of a recently used resource.
//   - newUri (optional): new URI of the recently used resource, or NULL to
//     remove the item pointed by uri in the list.
func (manager *RecentManager) MoveItem(uri, newUri string) error {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _arg2 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))
	if newUri != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(newUri)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	C.gtk_recent_manager_move_item(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(uri)
	runtime.KeepAlive(newUri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PurgeItems purges every item from the recently used resources list.
//
// The function returns the following values:
//
//   - gint: number of items that have been removed from the recently used
//     resources list.
func (manager *RecentManager) PurgeItems() (int, error) {
	var _arg0 *C.GtkRecentManager // out
	var _cret C.int               // in
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	_cret = C.gtk_recent_manager_purge_items(_arg0, &_cerr)
	runtime.KeepAlive(manager)

	var _gint int    // out
	var _goerr error // out

	_gint = int(_cret)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _gint, _goerr
}

// RemoveItem removes a resource pointed by uri from the recently used resources
// list handled by a recent manager.
//
// The function takes the following parameters:
//
//   - uri: URI of the item you wish to remove.
func (manager *RecentManager) RemoveItem(uri string) error {
	var _arg0 *C.GtkRecentManager // out
	var _arg1 *C.char             // out
	var _cerr *C.GError           // in

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(uri)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_recent_manager_remove_item(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(manager)
	runtime.KeepAlive(uri)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

func (manager *RecentManager) changed() {
	gclass := (*C.GtkRecentManagerClass)(coreglib.PeekParentClass(manager))
	fnarg := gclass.changed

	var _arg0 *C.GtkRecentManager // out

	_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(coreglib.InternObject(manager).Native()))

	C._gotk4_gtk4_RecentManager_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(manager)
}

// RecentManagerGetDefault gets a unique instance of GtkRecentManager that you
// can share in your application without caring about memory management.
//
// The function returns the following values:
//
//   - recentManager: unique GtkRecentManager. Do not ref or unref it.
func RecentManagerGetDefault() *RecentManager {
	var _cret *C.GtkRecentManager // in

	_cret = C.gtk_recent_manager_get_default()

	var _recentManager *RecentManager // out

	_recentManager = wrapRecentManager(coreglib.Take(unsafe.Pointer(_cret)))

	return _recentManager
}

// Revealer: GtkRevealer animates the transition of its child from invisible to
// visible.
//
// The style of transition can be controlled with
// gtk.Revealer.SetTransitionType().
//
// These animations respect the gtk.Settings:gtk-enable-animations setting.
//
// # CSS nodes
//
// GtkRevealer has a single CSS node with name revealer. When styling
// GtkRevealer using CSS, remember that it only hides its contents, not itself.
// That means applied margin, padding and borders will be visible even when the
// gtk.Revealer:reveal-child property is set to FALSE.
//
// # Accessibility
//
// GtkRevealer uses the GTK_ACCESSIBLE_ROLE_GROUP role.
//
// The child of GtkRevealer, if set, is always available in the accessibility
// tree, regardless of the state of the revealer widget.
type Revealer struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Revealer)(nil)
)

func wrapRevealer(obj *coreglib.Object) *Revealer {
	return &Revealer{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalRevealer(p uintptr) (interface{}, error) {
	return wrapRevealer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewRevealer creates a new GtkRevealer.
//
// The function returns the following values:
//
//   - revealer: newly created GtkRevealer.
func NewRevealer() *Revealer {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_revealer_new()

	var _revealer *Revealer // out

	_revealer = wrapRevealer(coreglib.Take(unsafe.Pointer(_cret)))

	return _revealer
}

// Child gets the child widget of revealer.
//
// The function returns the following values:
//
//   - widget (optional): child widget of revealer.
func (revealer *Revealer) Child() Widgetter {
	var _arg0 *C.GtkRevealer // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))

	_cret = C.gtk_revealer_get_child(_arg0)
	runtime.KeepAlive(revealer)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ChildRevealed returns whether the child is fully revealed.
//
// In other words, this returns whether the transition to the revealed state is
// completed.
//
// The function returns the following values:
//
//   - ok: TRUE if the child is fully revealed.
func (revealer *Revealer) ChildRevealed() bool {
	var _arg0 *C.GtkRevealer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))

	_cret = C.gtk_revealer_get_child_revealed(_arg0)
	runtime.KeepAlive(revealer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RevealChild returns whether the child is currently revealed.
//
// This function returns TRUE as soon as the transition is to the revealed state
// is started. To learn whether the child is fully revealed (ie the transition
// is completed), use gtk.Revealer.GetChildRevealed().
//
// The function returns the following values:
//
//   - ok: TRUE if the child is revealed.
func (revealer *Revealer) RevealChild() bool {
	var _arg0 *C.GtkRevealer // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))

	_cret = C.gtk_revealer_get_reveal_child(_arg0)
	runtime.KeepAlive(revealer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions will take.
//
// The function returns the following values:
//
//   - guint: transition duration.
func (revealer *Revealer) TransitionDuration() uint {
	var _arg0 *C.GtkRevealer // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))

	_cret = C.gtk_revealer_get_transition_duration(_arg0)
	runtime.KeepAlive(revealer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TransitionType gets the type of animation that will be used for transitions
// in revealer.
//
// The function returns the following values:
//
//   - revealerTransitionType: current transition type of revealer.
func (revealer *Revealer) TransitionType() RevealerTransitionType {
	var _arg0 *C.GtkRevealer              // out
	var _cret C.GtkRevealerTransitionType // in

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))

	_cret = C.gtk_revealer_get_transition_type(_arg0)
	runtime.KeepAlive(revealer)

	var _revealerTransitionType RevealerTransitionType // out

	_revealerTransitionType = RevealerTransitionType(_cret)

	return _revealerTransitionType
}

// SetChild sets the child widget of revealer.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (revealer *Revealer) SetChild(child Widgetter) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_revealer_set_child(_arg0, _arg1)
	runtime.KeepAlive(revealer)
	runtime.KeepAlive(child)
}

// SetRevealChild tells the GtkRevealer to reveal or conceal its child.
//
// The transition will be animated with the current transition type of revealer.
//
// The function takes the following parameters:
//
//   - revealChild: TRUE to reveal the child.
func (revealer *Revealer) SetRevealChild(revealChild bool) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))
	if revealChild {
		_arg1 = C.TRUE
	}

	C.gtk_revealer_set_reveal_child(_arg0, _arg1)
	runtime.KeepAlive(revealer)
	runtime.KeepAlive(revealChild)
}

// SetTransitionDuration sets the duration that transitions will take.
//
// The function takes the following parameters:
//
//   - duration: new duration, in milliseconds.
func (revealer *Revealer) SetTransitionDuration(duration uint) {
	var _arg0 *C.GtkRevealer // out
	var _arg1 C.guint        // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))
	_arg1 = C.guint(duration)

	C.gtk_revealer_set_transition_duration(_arg0, _arg1)
	runtime.KeepAlive(revealer)
	runtime.KeepAlive(duration)
}

// SetTransitionType sets the type of animation that will be used for
// transitions in revealer.
//
// Available types include various kinds of fades and slides.
//
// The function takes the following parameters:
//
//   - transition: new transition type.
func (revealer *Revealer) SetTransitionType(transition RevealerTransitionType) {
	var _arg0 *C.GtkRevealer              // out
	var _arg1 C.GtkRevealerTransitionType // out

	_arg0 = (*C.GtkRevealer)(unsafe.Pointer(coreglib.InternObject(revealer).Native()))
	_arg1 = C.GtkRevealerTransitionType(transition)

	C.gtk_revealer_set_transition_type(_arg0, _arg1)
	runtime.KeepAlive(revealer)
	runtime.KeepAlive(transition)
}

// ScaleOverrides contains methods that are overridable.
type ScaleOverrides struct {
	// LayoutOffsets obtains the coordinates where the scale will draw the
	// PangoLayout representing the text in the scale.
	//
	// Remember when using the PangoLayout function you need to convert to and
	// from pixels using PANGO_PIXELS() or PANGO_SCALE.
	//
	// If the gtkscale:draw-value property is FALSE, the return values are
	// undefined.
	//
	// The function returns the following values:
	//
	//   - x (optional): location to store X offset of layout, or NULL.
	//   - y (optional): location to store Y offset of layout, or NULL.
	LayoutOffsets func() (x, y int)
}

func defaultScaleOverrides(v *Scale) ScaleOverrides {
	return ScaleOverrides{
		LayoutOffsets: v.layoutOffsets,
	}
}

// Scale: GtkScale is a slider control used to select a numeric value.
//
// !An example GtkScale (scales.png)
//
// To use it, you’ll probably want to investigate the methods on its base class,
// gtkrange, in addition to the methods for GtkScale itself. To set the value
// of a scale, you would normally use gtk.Range.SetValue(). To detect changes to
// the value, you would normally use the gtk.Range::value-changed signal.
//
// Note that using the same upper and lower bounds for the GtkScale (through
// the GtkRange methods) will hide the slider itself. This is useful for
// applications that want to show an undeterminate value on the scale, without
// changing the layout of the application (such as movie or music players).
//
// # GtkScale as GtkBuildable
//
// GtkScale supports a custom <marks> element, which can contain multiple
// <mark\> elements. The “value” and “position” attributes have the same meaning
// as gtk.Scale.AddMark() parameters of the same name. If the element is not
// empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual ”translatable” and “context” attributes.
//
// CSS nodes
//
//	scale[.fine-tune][.marks-before][.marks-after]
//	├── [value][.top][.right][.bottom][.left]
//	├── marks.top
//	│   ├── mark
//	│   ┊    ├── [label]
//	│   ┊    ╰── indicator
//	┊   ┊
//	│   ╰── mark
//	├── marks.bottom
//	│   ├── mark
//	│   ┊    ├── indicator
//	│   ┊    ╰── [label]
//	┊   ┊
//	│   ╰── mark
//	╰── trough
//	    ├── [fill]
//	    ├── [highlight]
//	    ╰── slider
//
// GtkScale has a main CSS node with name scale and a subnode for its contents,
// with subnodes named trough and slider.
//
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
//
// If the scale has an origin (see gtk.Scale.SetHasOrigin()), there is a subnode
// with name highlight below the trough node that is used for rendering the
// highlighted part of the trough.
//
// If the scale is showing a fill level (see gtk.Range.SetShowFillLevel()),
// there is a subnode with name fill below the trough node that is used for
// rendering the filled in part of the trough.
//
// If marks are present, there is a marks subnode before or after the trough
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
//
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
//
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
//
// If the scale is displaying the value (see gtk.Scale:draw-value), there is
// subnode with name value. This node will get the .top or .bottom style classes
// similar to the marks node.
//
// # Accessibility
//
// GtkScale uses the GTK_ACCESSIBLE_ROLE_SLIDER role.
type Scale struct {
	_ [0]func() // equal guard
	Range
}

var (
	_ Widgetter         = (*Scale)(nil)
	_ coreglib.Objector = (*Scale)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Scale, *ScaleClass, ScaleOverrides](
		GTypeScale,
		initScaleClass,
		wrapScale,
		defaultScaleOverrides,
	)
}

func initScaleClass(gclass unsafe.Pointer, overrides ScaleOverrides, classInitFunc func(*ScaleClass)) {
	pclass := (*C.GtkScaleClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeScale))))

	if overrides.LayoutOffsets != nil {
		pclass.get_layout_offsets = (*[0]byte)(C._gotk4_gtk4_ScaleClass_get_layout_offsets)
	}

	if classInitFunc != nil {
		class := (*ScaleClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapScale(obj *coreglib.Object) *Scale {
	return &Scale{
		Range: Range{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalScale(p uintptr) (interface{}, error) {
	return wrapScale(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewScale creates a new GtkScale.
//
// The function takes the following parameters:
//
//   - orientation scale’s orientation.
//   - adjustment (optional): gtk.Adjustment which sets the range of the scale,
//     or NULL to create a new adjustment.
//
// The function returns the following values:
//
//   - scale: new GtkScale.
func NewScale(orientation Orientation, adjustment *Adjustment) *Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)
	if adjustment != nil {
		_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}

	_cret = C.gtk_scale_new(_arg1, _arg2)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(adjustment)

	var _scale *Scale // out

	_scale = wrapScale(coreglib.Take(unsafe.Pointer(_cret)))

	return _scale
}

// NewScaleWithRange creates a new scale widget with a range from min to max.
//
// The returns scale will have the given orientation and will let the user input
// a number between min and max (including min and max) with the increment step.
// step must be nonzero; it’s the distance the slider moves when using the arrow
// keys to adjust the scale value.
//
// Note that the way in which the precision is derived works best if step is
// a power of ten. If the resulting precision is not suitable for your needs,
// use gtk.Scale.SetDigits() to correct it.
//
// The function takes the following parameters:
//
//   - orientation scale’s orientation.
//   - min: minimum value.
//   - max: maximum value.
//   - step increment (tick size) used with keyboard shortcuts.
//
// The function returns the following values:
//
//   - scale: new Scale.
func NewScaleWithRange(orientation Orientation, min, max, step float64) *Scale {
	var _arg1 C.GtkOrientation // out
	var _arg2 C.double         // out
	var _arg3 C.double         // out
	var _arg4 C.double         // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.double(min)
	_arg3 = C.double(max)
	_arg4 = C.double(step)

	_cret = C.gtk_scale_new_with_range(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
	runtime.KeepAlive(step)

	var _scale *Scale // out

	_scale = wrapScale(coreglib.Take(unsafe.Pointer(_cret)))

	return _scale
}

// AddMark adds a mark at value.
//
// A mark is indicated visually by drawing a tick mark next to the scale,
// and GTK makes it easy for the user to position the scale exactly at the marks
// value.
//
// If markup is not NULL, text is shown next to the tick mark.
//
// To remove marks from a scale, use gtk.Scale.ClearMarks().
//
// The function takes the following parameters:
//
//   - value at which the mark is placed, must be between the lower and upper
//     limits of the scales’ adjustment.
//   - position: where to draw the mark. For a horizontal scale, K_POS_TOP
//     and GTK_POS_LEFT are drawn above the scale, anything else below. For a
//     vertical scale, K_POS_LEFT and GTK_POS_TOP are drawn to the left of the
//     scale, anything else to the right.
//   - markup (optional): text to be shown at the mark, using Pango markup,
//     or NULL.
func (scale *Scale) AddMark(value float64, position PositionType, markup string) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.double          // out
	var _arg2 C.GtkPositionType // out
	var _arg3 *C.char           // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	_arg1 = C.double(value)
	_arg2 = C.GtkPositionType(position)
	if markup != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(markup)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.gtk_scale_add_mark(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(value)
	runtime.KeepAlive(position)
	runtime.KeepAlive(markup)
}

// ClearMarks removes any marks that have been added.
func (scale *Scale) ClearMarks() {
	var _arg0 *C.GtkScale // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	C.gtk_scale_clear_marks(_arg0)
	runtime.KeepAlive(scale)
}

// Digits gets the number of decimal places that are displayed in the value.
//
// The function returns the following values:
//
//   - gint: number of decimal places that are displayed.
func (scale *Scale) Digits() int {
	var _arg0 *C.GtkScale // out
	var _cret C.int       // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_cret = C.gtk_scale_get_digits(_arg0)
	runtime.KeepAlive(scale)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// DrawValue returns whether the current value is displayed as a string next to
// the slider.
//
// The function returns the following values:
//
//   - ok: whether the current value is displayed as a string.
func (scale *Scale) DrawValue() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_cret = C.gtk_scale_get_draw_value(_arg0)
	runtime.KeepAlive(scale)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasOrigin returns whether the scale has an origin.
//
// The function returns the following values:
//
//   - ok: TRUE if the scale has an origin.
func (scale *Scale) HasOrigin() bool {
	var _arg0 *C.GtkScale // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_cret = C.gtk_scale_get_has_origin(_arg0)
	runtime.KeepAlive(scale)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Layout gets the PangoLayout used to display the scale.
//
// The returned object is owned by the scale so does not need to be freed by the
// caller.
//
// The function returns the following values:
//
//   - layout (optional): pango.Layout for this scale, or NULL if the
//     gtkscale:draw-value property is FALSE.
func (scale *Scale) Layout() *pango.Layout {
	var _arg0 *C.GtkScale    // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_cret = C.gtk_scale_get_layout(_arg0)
	runtime.KeepAlive(scale)

	var _layout *pango.Layout // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_layout = &pango.Layout{
				Object: obj,
			}
		}
	}

	return _layout
}

// LayoutOffsets obtains the coordinates where the scale will draw the
// PangoLayout representing the text in the scale.
//
// Remember when using the PangoLayout function you need to convert to and from
// pixels using PANGO_PIXELS() or PANGO_SCALE.
//
// If the gtkscale:draw-value property is FALSE, the return values are
// undefined.
//
// The function returns the following values:
//
//   - x (optional): location to store X offset of layout, or NULL.
//   - y (optional): location to store Y offset of layout, or NULL.
func (scale *Scale) LayoutOffsets() (x, y int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	C.gtk_scale_get_layout_offsets(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(scale)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// ValuePos gets the position in which the current value is displayed.
//
// The function returns the following values:
//
//   - positionType: position in which the current value is displayed.
func (scale *Scale) ValuePos() PositionType {
	var _arg0 *C.GtkScale       // out
	var _cret C.GtkPositionType // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	_cret = C.gtk_scale_get_value_pos(_arg0)
	runtime.KeepAlive(scale)

	var _positionType PositionType // out

	_positionType = PositionType(_cret)

	return _positionType
}

// SetDigits sets the number of decimal places that are displayed in the value.
//
// Also causes the value of the adjustment to be rounded to this
// number of digits, so the retrieved value matches the displayed one,
// if gtkscale:draw-value is TRUE when the value changes. If you want to
// enforce rounding the value when gtkscale:draw-value is FALSE, you can set
// gtkrange:round-digits instead.
//
// Note that rounding to a small number of digits can interfere with the smooth
// autoscrolling that is built into GtkScale. As an alternative, you can use
// gtk.Scale.SetFormatValueFunc() to format the displayed value yourself.
//
// The function takes the following parameters:
//
//   - digits: number of decimal places to display, e.g. use 1 to display 1.0,
//     2 to display 1.00, etc.
func (scale *Scale) SetDigits(digits int) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.int       // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	_arg1 = C.int(digits)

	C.gtk_scale_set_digits(_arg0, _arg1)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(digits)
}

// SetDrawValue specifies whether the current value is displayed as a string
// next to the slider.
//
// The function takes the following parameters:
//
//   - drawValue: TRUE to draw the value.
func (scale *Scale) SetDrawValue(drawValue bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if drawValue {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_draw_value(_arg0, _arg1)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(drawValue)
}

// SetFormatValueFunc: func allows you to change how the scale value is
// displayed.
//
// The given function will return an allocated string representing value.
// That string will then be used to display the scale's value.
//
// If LL is passed as func, the value will be displayed on its own, rounded
// according to the value of the gtkscale:digits property.
//
// The function takes the following parameters:
//
//   - fn (optional): function that formats the value.
func (scale *Scale) SetFormatValueFunc(fn ScaleFormatValueFunc) {
	var _arg0 *C.GtkScale               // out
	var _arg1 C.GtkScaleFormatValueFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_ScaleFormatValueFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_scale_set_format_value_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(fn)
}

// SetHasOrigin sets whether the scale has an origin.
//
// If gtkscale:has-origin is set to TRUE (the default), the scale will highlight
// the part of the trough between the origin (bottom or left side) and the
// current value.
//
// The function takes the following parameters:
//
//   - hasOrigin: TRUE if the scale has an origin.
func (scale *Scale) SetHasOrigin(hasOrigin bool) {
	var _arg0 *C.GtkScale // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	if hasOrigin {
		_arg1 = C.TRUE
	}

	C.gtk_scale_set_has_origin(_arg0, _arg1)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(hasOrigin)
}

// SetValuePos sets the position in which the current value is displayed.
//
// The function takes the following parameters:
//
//   - pos: position in which the current value is displayed.
func (scale *Scale) SetValuePos(pos PositionType) {
	var _arg0 *C.GtkScale       // out
	var _arg1 C.GtkPositionType // out

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))
	_arg1 = C.GtkPositionType(pos)

	C.gtk_scale_set_value_pos(_arg0, _arg1)
	runtime.KeepAlive(scale)
	runtime.KeepAlive(pos)
}

// layoutOffsets obtains the coordinates where the scale will draw the
// PangoLayout representing the text in the scale.
//
// Remember when using the PangoLayout function you need to convert to and from
// pixels using PANGO_PIXELS() or PANGO_SCALE.
//
// If the gtkscale:draw-value property is FALSE, the return values are
// undefined.
//
// The function returns the following values:
//
//   - x (optional): location to store X offset of layout, or NULL.
//   - y (optional): location to store Y offset of layout, or NULL.
func (scale *Scale) layoutOffsets() (x, y int) {
	gclass := (*C.GtkScaleClass)(coreglib.PeekParentClass(scale))
	fnarg := gclass.get_layout_offsets

	var _arg0 *C.GtkScale // out
	var _arg1 C.int       // in
	var _arg2 C.int       // in

	_arg0 = (*C.GtkScale)(unsafe.Pointer(coreglib.InternObject(scale).Native()))

	C._gotk4_gtk4_Scale_virtual_get_layout_offsets(unsafe.Pointer(fnarg), _arg0, &_arg1, &_arg2)
	runtime.KeepAlive(scale)

	var _x int // out
	var _y int // out

	_x = int(_arg1)
	_y = int(_arg2)

	return _x, _y
}

// ScaleButtonOverrides contains methods that are overridable.
type ScaleButtonOverrides struct {
	ValueChanged func(value float64)
}

func defaultScaleButtonOverrides(v *ScaleButton) ScaleButtonOverrides {
	return ScaleButtonOverrides{
		ValueChanged: v.valueChanged,
	}
}

// ScaleButton: GtkScaleButton provides a button which pops up a scale widget.
//
// This kind of widget is commonly used for volume controls in multimedia
// applications, and GTK provides a gtk.VolumeButton subclass that is tailored
// for this use case.
//
// # CSS nodes
//
// GtkScaleButton has a single CSS node with name button. To differentiate it
// from a plain GtkButton, it gets the .scale style class.
type ScaleButton struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*ScaleButton)(nil)
	_ coreglib.Objector = (*ScaleButton)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ScaleButton, *ScaleButtonClass, ScaleButtonOverrides](
		GTypeScaleButton,
		initScaleButtonClass,
		wrapScaleButton,
		defaultScaleButtonOverrides,
	)
}

func initScaleButtonClass(gclass unsafe.Pointer, overrides ScaleButtonOverrides, classInitFunc func(*ScaleButtonClass)) {
	pclass := (*C.GtkScaleButtonClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeScaleButton))))

	if overrides.ValueChanged != nil {
		pclass.value_changed = (*[0]byte)(C._gotk4_gtk4_ScaleButtonClass_value_changed)
	}

	if classInitFunc != nil {
		class := (*ScaleButtonClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapScaleButton(obj *coreglib.Object) *ScaleButton {
	return &ScaleButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalScaleButton(p uintptr) (interface{}, error) {
	return wrapScaleButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectPopdown is emitted to dismiss the popup.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is <kbd>Escape</kbd>.
func (button *ScaleButton) ConnectPopdown(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(button, "popdown", false, unsafe.Pointer(C._gotk4_gtk4_ScaleButton_ConnectPopdown), f)
}

// ConnectPopup is emitted to popup the scale widget.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Space</kbd>, <kbd>Enter</kbd>
// and <kbd>Return</kbd>.
func (button *ScaleButton) ConnectPopup(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(button, "popup", false, unsafe.Pointer(C._gotk4_gtk4_ScaleButton_ConnectPopup), f)
}

// ConnectValueChanged is emitted when the value field has changed.
func (button *ScaleButton) ConnectValueChanged(f func(value float64)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(button, "value-changed", false, unsafe.Pointer(C._gotk4_gtk4_ScaleButton_ConnectValueChanged), f)
}

// NewScaleButton creates a GtkScaleButton.
//
// The new scale button has a range between min and max, with a stepping of
// step.
//
// The function takes the following parameters:
//
//   - min: minimum value of the scale (usually 0).
//   - max: maximum value of the scale (usually 100).
//   - step: stepping of value when a scroll-wheel event, or up/down arrow event
//     occurs (usually 2).
//   - icons (optional): NULL-terminated array of icon names, or NULL if you
//     want to set the list later with gtk_scale_button_set_icons().
//
// The function returns the following values:
//
//   - scaleButton: new GtkScaleButton.
func NewScaleButton(min, max, step float64, icons []string) *ScaleButton {
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out
	var _arg4 **C.char     // out
	var _cret *C.GtkWidget // in

	_arg1 = C.double(min)
	_arg2 = C.double(max)
	_arg3 = C.double(step)
	{
		_arg4 = (**C.char)(C.calloc(C.size_t((len(icons) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg4))
		{
			out := unsafe.Slice(_arg4, len(icons)+1)
			var zero *C.char
			out[len(icons)] = zero
			for i := range icons {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(icons[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gtk_scale_button_new(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
	runtime.KeepAlive(step)
	runtime.KeepAlive(icons)

	var _scaleButton *ScaleButton // out

	_scaleButton = wrapScaleButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _scaleButton
}

// Adjustment gets the GtkAdjustment associated with the GtkScaleButton’s scale.
//
// See gtk.Range.GetAdjustment() for details.
//
// The function returns the following values:
//
//   - adjustment associated with the scale.
func (button *ScaleButton) Adjustment() *Adjustment {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkAdjustment  // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_scale_button_get_adjustment(_arg0)
	runtime.KeepAlive(button)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// MinusButton retrieves the minus button of the GtkScaleButton.
//
// The function returns the following values:
//
//   - ret minus button of the GtkScaleButton.
func (button *ScaleButton) MinusButton() *Button {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_scale_button_get_minus_button(_arg0)
	runtime.KeepAlive(button)

	var _ret *Button // out

	_ret = wrapButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _ret
}

// PlusButton retrieves the plus button of the GtkScaleButton.
//
// The function returns the following values:
//
//   - ret plus button of the GtkScaleButton.
func (button *ScaleButton) PlusButton() *Button {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_scale_button_get_plus_button(_arg0)
	runtime.KeepAlive(button)

	var _ret *Button // out

	_ret = wrapButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _ret
}

// Popup retrieves the popup of the GtkScaleButton.
//
// The function returns the following values:
//
//   - widget: popup of the GtkScaleButton.
func (button *ScaleButton) Popup() Widgetter {
	var _arg0 *C.GtkScaleButton // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_scale_button_get_popup(_arg0)
	runtime.KeepAlive(button)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// Value gets the current value of the scale button.
//
// The function returns the following values:
//
//   - gdouble: current value of the scale button.
func (button *ScaleButton) Value() float64 {
	var _arg0 *C.GtkScaleButton // out
	var _cret C.double          // in

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))

	_cret = C.gtk_scale_button_get_value(_arg0)
	runtime.KeepAlive(button)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// SetAdjustment sets the GtkAdjustment to be used as a model for the
// GtkScaleButton’s scale.
//
// See gtk.Range.SetAdjustment() for details.
//
// The function takes the following parameters:
//
//   - adjustment: GtkAdjustment.
func (button *ScaleButton) SetAdjustment(adjustment *Adjustment) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 *C.GtkAdjustment  // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	C.gtk_scale_button_set_adjustment(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(adjustment)
}

// SetIcons sets the icons to be used by the scale button.
//
// The function takes the following parameters:
//
//   - icons: NULL-terminated array of icon names.
func (button *ScaleButton) SetIcons(icons []string) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 **C.char          // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(icons) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(icons)+1)
			var zero *C.char
			out[len(icons)] = zero
			for i := range icons {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(icons[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_scale_button_set_icons(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(icons)
}

// SetValue sets the current value of the scale.
//
// If the value is outside the minimum or maximum range values, it will be
// clamped to fit inside them.
//
// The scale button emits the gtk.ScaleButton::value-changed signal if the value
// changes.
//
// The function takes the following parameters:
//
//   - value: new value of the scale button.
func (button *ScaleButton) SetValue(value float64) {
	var _arg0 *C.GtkScaleButton // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	_arg1 = C.double(value)

	C.gtk_scale_button_set_value(_arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(value)
}

func (button *ScaleButton) valueChanged(value float64) {
	gclass := (*C.GtkScaleButtonClass)(coreglib.PeekParentClass(button))
	fnarg := gclass.value_changed

	var _arg0 *C.GtkScaleButton // out
	var _arg1 C.double          // out

	_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(coreglib.InternObject(button).Native()))
	_arg1 = C.double(value)

	C._gotk4_gtk4_ScaleButton_virtual_value_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(button)
	runtime.KeepAlive(value)
}

// Scrollbar: GtkScrollbar widget is a horizontal or vertical scrollbar.
//
// !An example GtkScrollbar (scrollbar.png)
//
// Its position and movement are controlled by the adjustment that is passed
// to or created by gtk.Scrollbar.New. See [class.Gtk.Adjustment] for more
// details. The gtk.Adjustment:value field sets the position of the thumb
// and must be between gtk.Adjustment:lower and gtk.Adjustment:upper -
// gtk.Adjustment:page-size. The gtk.Adjustment:page-size represents the size of
// the visible scrollable area.
//
// The fields gtk.Adjustment:step-increment and gtk.Adjustment:page-increment
// fields are added to or subtracted from the gtk.Adjustment:value when the user
// asks to move by a step (using e.g. the cursor arrow keys) or by a page (using
// e.g. the Page Down/Up keys).
//
// CSS nodes
//
//	scrollbar
//	╰── range[.fine-tune]
//	    ╰── trough
//	        ╰── slider
//
// GtkScrollbar has a main CSS node with name scrollbar and a subnode for its
// contents. The main node gets the .horizontal or .vertical style classes
// applied, depending on the scrollbar's orientation.
//
// The range node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
//
// Other style classes that may be added to scrollbars inside gtk.ScrolledWindow
// include the positional classes (.left, .right, .top, .bottom) and style
// classes related to overlay scrolling (.overlay-indicator, .dragging,
// .hovering).
//
// # Accessibility
//
// GtkScrollbar uses the GTK_ACCESSIBLE_ROLE_SCROLLBAR role.
type Scrollbar struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*Scrollbar)(nil)
	_ coreglib.Objector = (*Scrollbar)(nil)
)

func wrapScrollbar(obj *coreglib.Object) *Scrollbar {
	return &Scrollbar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalScrollbar(p uintptr) (interface{}, error) {
	return wrapScrollbar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewScrollbar creates a new scrollbar with the given orientation.
//
// The function takes the following parameters:
//
//   - orientation scrollbar’s orientation.
//   - adjustment (optional): gtk.Adjustment to use, or NULL to create a new
//     adjustment.
//
// The function returns the following values:
//
//   - scrollbar: new GtkScrollbar.
func NewScrollbar(orientation Orientation, adjustment *Adjustment) *Scrollbar {
	var _arg1 C.GtkOrientation // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)
	if adjustment != nil {
		_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}

	_cret = C.gtk_scrollbar_new(_arg1, _arg2)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(adjustment)

	var _scrollbar *Scrollbar // out

	_scrollbar = wrapScrollbar(coreglib.Take(unsafe.Pointer(_cret)))

	return _scrollbar
}

// Adjustment returns the scrollbar's adjustment.
//
// The function returns the following values:
//
//   - adjustment scrollbar's adjustment.
func (self *Scrollbar) Adjustment() *Adjustment {
	var _arg0 *C.GtkScrollbar  // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkScrollbar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_scrollbar_get_adjustment(_arg0)
	runtime.KeepAlive(self)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// SetAdjustment makes the scrollbar use the given adjustment.
//
// The function takes the following parameters:
//
//   - adjustment (optional) to set.
func (self *Scrollbar) SetAdjustment(adjustment *Adjustment) {
	var _arg0 *C.GtkScrollbar  // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkScrollbar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if adjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}

	C.gtk_scrollbar_set_adjustment(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(adjustment)
}

// ScrolledWindow: GtkScrolledWindow is a container that makes its child
// scrollable.
//
// It does so using either internally added scrollbars or externally associated
// adjustments, and optionally draws a frame around the child.
//
// Widgets with native scrolling support, i.e. those whose classes implement the
// gtk.Scrollable interface, are added directly. For other types of widget, the
// class gtk.Viewport acts as an adaptor, giving scrollability to other widgets.
// gtk.ScrolledWindow.SetChild() intelligently accounts for whether or not the
// added child is a GtkScrollable. If it isn’t, then it wraps the child in a
// GtkViewport. Therefore, you can just add any child widget and not worry about
// the details.
//
// If gtk.ScrolledWindow.SetChild() has added a GtkViewport for you, you can
// remove both your added child widget from the GtkViewport, and the GtkViewport
// from the GtkScrolledWindow, like this:
//
//	GtkWidget *scrolled_window = gtk_scrolled_window_new ();
//	GtkWidget *child_widget = gtk_button_new ();
//
//	// GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
//	// add a GtkViewport.
//	gtk_box_append (GTK_BOX (scrolled_window), child_widget);
//
//	// Either of these will result in child_widget being unparented:
//	gtk_box_remove (GTK_BOX (scrolled_window), child_widget);
//	// or
//	gtk_box_remove (GTK_BOX (scrolled_window),
//	                      gtk_bin_get_child (GTK_BIN (scrolled_window)));
//
// Unless gtk.ScrolledWindow:hscrollbar-policy and
// gtk.ScrolledWindow:vscrollbar-policy are GTK_POLICY_NEVER or
// GTK_POLICY_EXTERNAL, GtkScrolledWindow adds internal GtkScrollbar widgets
// around its child. The scroll position of the child, and if applicable
// the scrollbars, is controlled by the gtk.ScrolledWindow:hadjustment
// and gtk.ScrolledWindow:vadjustment that are associated with the
// GtkScrolledWindow. See the docs on gtk.Scrollbar for the details, but note
// that the “step_increment” and “page_increment” fields are only effective if
// the policy causes scrollbars to be present.
//
// If a GtkScrolledWindow doesn’t behave quite as you would like, or doesn’t
// have exactly the right layout, it’s very possible to set up your own
// scrolling with GtkScrollbar and for example a GtkGrid.
//
// # Touch support
//
// GtkScrolledWindow has built-in support for touch devices.
// When a touchscreen is used, swiping will move the scrolled window,
// and will expose 'kinetic' behavior. This can be turned off with the
// gtk.ScrolledWindow:kinetic-scrolling property if it is undesired.
//
// GtkScrolledWindow also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// gtk.ScrolledWindow::edge-overshot signal.
//
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the gtk.ScrolledWindow:overlay-scrolling property.
//
// # CSS nodes
//
// GtkScrolledWindow has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when gtk.ScrolledWindow:has-frame is TRUE.
//
// It uses subnodes with names overshoot and undershoot to draw the overflow
// and underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
//
// GtkScrolledWindow also sets the positional style classes (.left,
// .right, .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
//
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
//
// # Accessibility
//
// GtkScrolledWindow uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type ScrolledWindow struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*ScrolledWindow)(nil)
)

func wrapScrolledWindow(obj *coreglib.Object) *ScrolledWindow {
	return &ScrolledWindow{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalScrolledWindow(p uintptr) (interface{}, error) {
	return wrapScrolledWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectEdgeOvershot is emitted whenever user initiated scrolling makes the
// scrolled window firmly surpass the limits defined by the adjustment in that
// orientation.
//
// A similar behavior without edge resistance is provided by the
// gtk.ScrolledWindow::edge-reached signal.
//
// Note: The pos argument is LTR/RTL aware, so callers should be aware too if
// intending to provide behavior on horizontal edges.
func (scrolledWindow *ScrolledWindow) ConnectEdgeOvershot(f func(pos PositionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "edge-overshot", false, unsafe.Pointer(C._gotk4_gtk4_ScrolledWindow_ConnectEdgeOvershot), f)
}

// ConnectEdgeReached is emitted whenever user-initiated scrolling makes the
// scrolled window exactly reach the lower or upper limits defined by the
// adjustment in that orientation.
//
// A similar behavior with edge resistance is provided by the
// gtk.ScrolledWindow::edge-overshot signal.
//
// Note: The pos argument is LTR/RTL aware, so callers should be aware too if
// intending to provide behavior on horizontal edges.
func (scrolledWindow *ScrolledWindow) ConnectEdgeReached(f func(pos PositionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "edge-reached", false, unsafe.Pointer(C._gotk4_gtk4_ScrolledWindow_ConnectEdgeReached), f)
}

// ConnectMoveFocusOut is emitted when focus is moved away from the scrolled
// window by a keybinding.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are Ctrl + Tab to move forward and Ctrl
// + Shift + Tab to move backward.
func (scrolledWindow *ScrolledWindow) ConnectMoveFocusOut(f func(directionType DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "move-focus-out", false, unsafe.Pointer(C._gotk4_gtk4_ScrolledWindow_ConnectMoveFocusOut), f)
}

// ConnectScrollChild is emitted when a keybinding that scrolls is pressed.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The horizontal or vertical adjustment is updated which triggers a signal that
// the scrolled window’s child may listen to and scroll itself.
func (scrolledWindow *ScrolledWindow) ConnectScrollChild(f func(scroll ScrollType, horizontal bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(scrolledWindow, "scroll-child", false, unsafe.Pointer(C._gotk4_gtk4_ScrolledWindow_ConnectScrollChild), f)
}

// NewScrolledWindow creates a new scrolled window.
//
// The function returns the following values:
//
//   - scrolledWindow: new scrolled window.
func NewScrolledWindow() *ScrolledWindow {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_scrolled_window_new()

	var _scrolledWindow *ScrolledWindow // out

	_scrolledWindow = wrapScrolledWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _scrolledWindow
}

// Child gets the child widget of scrolled_window.
//
// The function returns the following values:
//
//   - widget (optional): child widget of scrolled_window.
func (scrolledWindow *ScrolledWindow) Child() Widgetter {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_child(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// HAdjustment returns the horizontal scrollbar’s adjustment.
//
// This is the adjustment used to connect the horizontal scrollbar to the child
// widget’s horizontal scroll functionality.
//
// The function returns the following values:
//
//   - adjustment: horizontal GtkAdjustment.
func (scrolledWindow *ScrolledWindow) HAdjustment() *Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_hadjustment(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// HasFrame gets whether the scrolled window draws a frame.
//
// The function returns the following values:
//
//   - ok: TRUE if the scrolled_window has a frame.
func (scrolledWindow *ScrolledWindow) HasFrame() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_has_frame(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HScrollbar returns the horizontal scrollbar of scrolled_window.
//
// The function returns the following values:
//
//   - widget: horizontal scrollbar of the scrolled window.
func (scrolledWindow *ScrolledWindow) HScrollbar() Widgetter {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_hscrollbar(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// KineticScrolling returns the specified kinetic scrolling behavior.
//
// The function returns the following values:
//
//   - ok: scrolling behavior flags.
func (scrolledWindow *ScrolledWindow) KineticScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_kinetic_scrolling(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MaxContentHeight returns the maximum content height set.
//
// The function returns the following values:
//
//   - gint: maximum content height, or -1.
func (scrolledWindow *ScrolledWindow) MaxContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_max_content_height(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxContentWidth returns the maximum content width set.
//
// The function returns the following values:
//
//   - gint: maximum content width, or -1.
func (scrolledWindow *ScrolledWindow) MaxContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_max_content_width(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MinContentHeight gets the minimal content height of scrolled_window.
//
// The function returns the following values:
//
//   - gint: minimal content height.
func (scrolledWindow *ScrolledWindow) MinContentHeight() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_min_content_height(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MinContentWidth gets the minimum content width of scrolled_window.
//
// The function returns the following values:
//
//   - gint: minimum content width.
func (scrolledWindow *ScrolledWindow) MinContentWidth() int {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.int                // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_min_content_width(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// OverlayScrolling returns whether overlay scrolling is enabled for this
// scrolled window.
//
// The function returns the following values:
//
//   - ok: TRUE if overlay scrolling is enabled.
func (scrolledWindow *ScrolledWindow) OverlayScrolling() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_overlay_scrolling(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Placement gets the placement of the contents with respect to the scrollbars.
//
// The function returns the following values:
//
//   - cornerType: current placement value.
func (scrolledWindow *ScrolledWindow) Placement() CornerType {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.GtkCornerType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_placement(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _cornerType CornerType // out

	_cornerType = CornerType(_cret)

	return _cornerType
}

// Policy retrieves the current policy values for the horizontal and vertical
// scrollbars.
//
// See gtk.ScrolledWindow.SetPolicy().
//
// The function returns the following values:
//
//   - hscrollbarPolicy (optional): location to store the policy for the
//     horizontal scrollbar, or NULL.
//   - vscrollbarPolicy (optional): location to store the policy for the
//     vertical scrollbar, or NULL.
func (scrolledWindow *ScrolledWindow) Policy() (hscrollbarPolicy, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // in
	var _arg2 C.GtkPolicyType      // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	C.gtk_scrolled_window_get_policy(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(scrolledWindow)

	var _hscrollbarPolicy PolicyType // out
	var _vscrollbarPolicy PolicyType // out

	_hscrollbarPolicy = PolicyType(_arg1)
	_vscrollbarPolicy = PolicyType(_arg2)

	return _hscrollbarPolicy, _vscrollbarPolicy
}

// PropagateNaturalHeight reports whether the natural height of the child will
// be calculated and propagated through the scrolled window’s requested natural
// height.
//
// The function returns the following values:
//
//   - ok: whether natural height propagation is enabled.
func (scrolledWindow *ScrolledWindow) PropagateNaturalHeight() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_height(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PropagateNaturalWidth reports whether the natural width of the child will be
// calculated and propagated through the scrolled window’s requested natural
// width.
//
// The function returns the following values:
//
//   - ok: whether natural width propagation is enabled.
func (scrolledWindow *ScrolledWindow) PropagateNaturalWidth() bool {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_propagate_natural_width(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VAdjustment returns the vertical scrollbar’s adjustment.
//
// This is the adjustment used to connect the vertical scrollbar to the child
// widget’s vertical scroll functionality.
//
// The function returns the following values:
//
//   - adjustment: vertical GtkAdjustment.
func (scrolledWindow *ScrolledWindow) VAdjustment() *Adjustment {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkAdjustment     // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_vadjustment(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// VScrollbar returns the vertical scrollbar of scrolled_window.
//
// The function returns the following values:
//
//   - widget: vertical scrollbar of the scrolled window.
func (scrolledWindow *ScrolledWindow) VScrollbar() Widgetter {
	var _arg0 *C.GtkScrolledWindow // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	_cret = C.gtk_scrolled_window_get_vscrollbar(_arg0)
	runtime.KeepAlive(scrolledWindow)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// SetChild sets the child widget of scrolled_window.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (scrolledWindow *ScrolledWindow) SetChild(child Widgetter) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_scrolled_window_set_child(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(child)
}

// SetHAdjustment sets the GtkAdjustment for the horizontal scrollbar.
//
// The function takes the following parameters:
//
//   - hadjustment (optional): GtkAdjustment to use, or NULL to create a new
//     one.
func (scrolledWindow *ScrolledWindow) SetHAdjustment(hadjustment *Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if hadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(hadjustment).Native()))
	}

	C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(hadjustment)
}

// SetHasFrame changes the frame drawn around the contents of scrolled_window.
//
// The function takes the following parameters:
//
//   - hasFrame: whether to draw a frame around scrolled window contents.
func (scrolledWindow *ScrolledWindow) SetHasFrame(hasFrame bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if hasFrame {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_has_frame(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(hasFrame)
}

// SetKineticScrolling turns kinetic scrolling on or off.
//
// Kinetic scrolling only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
//
// The function takes the following parameters:
//
//   - kineticScrolling: TRUE to enable kinetic scrolling.
func (scrolledWindow *ScrolledWindow) SetKineticScrolling(kineticScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if kineticScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_kinetic_scrolling(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(kineticScrolling)
}

// SetMaxContentHeight sets the maximum height that scrolled_window should keep
// visible.
//
// The scrolled_window will grow up to this height before it starts scrolling
// the content.
//
// It is a programming error to set the maximum content height to a value
// smaller than gtk.ScrolledWindow:min-content-height.
//
// The function takes the following parameters:
//
//   - height: maximum content height.
func (scrolledWindow *ScrolledWindow) SetMaxContentHeight(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.int(height)

	C.gtk_scrolled_window_set_max_content_height(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(height)
}

// SetMaxContentWidth sets the maximum width that scrolled_window should keep
// visible.
//
// The scrolled_window will grow up to this width before it starts scrolling the
// content.
//
// It is a programming error to set the maximum content width to a value smaller
// than gtk.ScrolledWindow:min-content-width.
//
// The function takes the following parameters:
//
//   - width: maximum content width.
func (scrolledWindow *ScrolledWindow) SetMaxContentWidth(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.int(width)

	C.gtk_scrolled_window_set_max_content_width(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(width)
}

// SetMinContentHeight sets the minimum height that scrolled_window should keep
// visible.
//
// Note that this can and (usually will) be smaller than the minimum size of the
// content.
//
// It is a programming error to set the minimum content height to a value
// greater than gtk.ScrolledWindow:max-content-height.
//
// The function takes the following parameters:
//
//   - height: minimal content height.
func (scrolledWindow *ScrolledWindow) SetMinContentHeight(height int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.int(height)

	C.gtk_scrolled_window_set_min_content_height(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(height)
}

// SetMinContentWidth sets the minimum width that scrolled_window should keep
// visible.
//
// Note that this can and (usually will) be smaller than the minimum size of the
// content.
//
// It is a programming error to set the minimum content width to a value greater
// than gtk.ScrolledWindow:max-content-width.
//
// The function takes the following parameters:
//
//   - width: minimal content width.
func (scrolledWindow *ScrolledWindow) SetMinContentWidth(width int) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.int(width)

	C.gtk_scrolled_window_set_min_content_width(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(width)
}

// SetOverlayScrolling enables or disables overlay scrolling for this scrolled
// window.
//
// The function takes the following parameters:
//
//   - overlayScrolling: whether to enable overlay scrolling.
func (scrolledWindow *ScrolledWindow) SetOverlayScrolling(overlayScrolling bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if overlayScrolling {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_overlay_scrolling(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(overlayScrolling)
}

// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
//
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in
// gtk.CornerType are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
// GTK_CORNER_BOTTOM_RIGHT.
//
// See also gtk.ScrolledWindow.GetPlacement() and
// gtk.ScrolledWindow.UnsetPlacement().
//
// The function takes the following parameters:
//
//   - windowPlacement: position of the child window.
func (scrolledWindow *ScrolledWindow) SetPlacement(windowPlacement CornerType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkCornerType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.GtkCornerType(windowPlacement)

	C.gtk_scrolled_window_set_placement(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(windowPlacement)
}

// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
//
// The policy determines when the scrollbar should appear; it is a value
// from the gtk.PolicyType enumeration. If GTK_POLICY_ALWAYS, the scrollbar
// is always present; if GTK_POLICY_NEVER, the scrollbar is never present;
// if GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is,
// if the slider part of the bar would be smaller than the trough — the display
// is larger than the page size).
//
// The function takes the following parameters:
//
//   - hscrollbarPolicy: policy for horizontal bar.
//   - vscrollbarPolicy: policy for vertical bar.
func (scrolledWindow *ScrolledWindow) SetPolicy(hscrollbarPolicy, vscrollbarPolicy PolicyType) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.GtkPolicyType      // out
	var _arg2 C.GtkPolicyType      // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	_arg1 = C.GtkPolicyType(hscrollbarPolicy)
	_arg2 = C.GtkPolicyType(vscrollbarPolicy)

	C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(hscrollbarPolicy)
	runtime.KeepAlive(vscrollbarPolicy)
}

// SetPropagateNaturalHeight sets whether the natural height of the child should
// be calculated and propagated through the scrolled window’s requested natural
// height.
//
// The function takes the following parameters:
//
//   - propagate: whether to propagate natural height.
func (scrolledWindow *ScrolledWindow) SetPropagateNaturalHeight(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_height(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(propagate)
}

// SetPropagateNaturalWidth sets whether the natural width of the child should
// be calculated and propagated through the scrolled window’s requested natural
// width.
//
// The function takes the following parameters:
//
//   - propagate: whether to propagate natural width.
func (scrolledWindow *ScrolledWindow) SetPropagateNaturalWidth(propagate bool) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if propagate {
		_arg1 = C.TRUE
	}

	C.gtk_scrolled_window_set_propagate_natural_width(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(propagate)
}

// SetVAdjustment sets the GtkAdjustment for the vertical scrollbar.
//
// The function takes the following parameters:
//
//   - vadjustment (optional): GtkAdjustment to use, or NULL to create a new
//     one.
func (scrolledWindow *ScrolledWindow) SetVAdjustment(vadjustment *Adjustment) {
	var _arg0 *C.GtkScrolledWindow // out
	var _arg1 *C.GtkAdjustment     // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))
	if vadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(vadjustment).Native()))
	}

	C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
	runtime.KeepAlive(scrolledWindow)
	runtime.KeepAlive(vadjustment)
}

// UnsetPlacement unsets the placement of the contents with respect to the
// scrollbars.
//
// If no window placement is set for a scrolled window, it defaults to
// GTK_CORNER_TOP_LEFT.
func (scrolledWindow *ScrolledWindow) UnsetPlacement() {
	var _arg0 *C.GtkScrolledWindow // out

	_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(coreglib.InternObject(scrolledWindow).Native()))

	C.gtk_scrolled_window_unset_placement(_arg0)
	runtime.KeepAlive(scrolledWindow)
}

// SearchBar: GtkSearchBar is a container made to have a search entry.
//
// !An example GtkSearchBar (search-bar.png)
//
// It can also contain additional widgets, such as drop-down menus, or buttons.
// The search bar would appear when a search is started through typing on the
// keyboard, or the application’s search mode is toggled on.
//
// For keyboard presses to start a search, the search bar
// must be told of a widget to capture key events from through
// gtk.SearchBar.SetKeyCaptureWidget(). This widget will typically be the
// top-level window, or a parent container of the search bar. Common shortcuts
// such as Ctrl+F should be handled as an application action, or through the
// menu items.
//
// You will also need to tell the search bar about which entry you are using as
// your search entry using gtk.SearchBar.ConnectEntry().
//
// # Creating a search bar
//
// The following example shows you how to create a more complex search entry.
//
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
//
// CSS nodes
//
//	searchbar
//	╰── revealer
//	    ╰── box
//	         ├── [child]
//	         ╰── [button.close]
//
// GtkSearchBar has a main CSS node with name searchbar. It has a child node
// with name revealer that contains a node with name box. The box node contains
// both the CSS node of the child widget as well as an optional button node
// which gets the .close style class applied.
//
// # Accessibility
//
// GtkSearchBar uses the GTK_ACCESSIBLE_ROLE_SEARCH role.
type SearchBar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*SearchBar)(nil)
)

func wrapSearchBar(obj *coreglib.Object) *SearchBar {
	return &SearchBar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalSearchBar(p uintptr) (interface{}, error) {
	return wrapSearchBar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSearchBar creates a GtkSearchBar.
//
// You will need to tell it about which widget is going to be your text entry
// using gtk.SearchBar.ConnectEntry().
//
// The function returns the following values:
//
//   - searchBar: new GtkSearchBar.
func NewSearchBar() *SearchBar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_search_bar_new()

	var _searchBar *SearchBar // out

	_searchBar = wrapSearchBar(coreglib.Take(unsafe.Pointer(_cret)))

	return _searchBar
}

// ConnectEntry connects the `GtkEditable widget passed as the one to be used in
// this search bar.
//
// The entry should be a descendant of the search bar. Calling this function
// manually is only required if the entry isn’t the direct child of the search
// bar (as in our main example).
//
// The function takes the following parameters:
//
//   - entry: GtkEditable.
func (bar *SearchBar) ConnectEntry(entry EditableTextWidgetter) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 *C.GtkEditable  // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	_arg1 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	C.gtk_search_bar_connect_entry(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(entry)
}

// Child gets the child widget of bar.
//
// The function returns the following values:
//
//   - widget (optional): child widget of bar.
func (bar *SearchBar) Child() Widgetter {
	var _arg0 *C.GtkSearchBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_search_bar_get_child(_arg0)
	runtime.KeepAlive(bar)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// KeyCaptureWidget gets the widget that bar is capturing key events from.
//
// The function returns the following values:
//
//   - widget: key capture widget.
func (bar *SearchBar) KeyCaptureWidget() Widgetter {
	var _arg0 *C.GtkSearchBar // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_search_bar_get_key_capture_widget(_arg0)
	runtime.KeepAlive(bar)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// SearchMode returns whether the search mode is on or off.
//
// The function returns the following values:
//
//   - ok: whether search mode is toggled on.
func (bar *SearchBar) SearchMode() bool {
	var _arg0 *C.GtkSearchBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_search_bar_get_search_mode(_arg0)
	runtime.KeepAlive(bar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShowCloseButton returns whether the close button is shown.
//
// The function returns the following values:
//
//   - ok: whether the close button is shown.
func (bar *SearchBar) ShowCloseButton() bool {
	var _arg0 *C.GtkSearchBar // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))

	_cret = C.gtk_search_bar_get_show_close_button(_arg0)
	runtime.KeepAlive(bar)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of bar.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (bar *SearchBar) SetChild(child Widgetter) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_search_bar_set_child(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(child)
}

// SetKeyCaptureWidget sets widget as the widget that bar will capture key
// events from.
//
// If key events are handled by the search bar, the bar will be shown, and the
// entry populated with the entered text.
//
// Note that despite the name of this function, the events are only
// 'captured' in the bubble phase, which means that editable child widgets
// of widget will receive text input before it gets captured. If that
// is not desired, you can capture and forward the events yourself with
// gtk.EventControllerKey.Forward().
//
// The function takes the following parameters:
//
//   - widget (optional): GtkWidget.
func (bar *SearchBar) SetKeyCaptureWidget(widget Widgetter) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_search_bar_set_key_capture_widget(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(widget)
}

// SetSearchMode switches the search mode on or off.
//
// The function takes the following parameters:
//
//   - searchMode: new state of the search mode.
func (bar *SearchBar) SetSearchMode(searchMode bool) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if searchMode {
		_arg1 = C.TRUE
	}

	C.gtk_search_bar_set_search_mode(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(searchMode)
}

// SetShowCloseButton shows or hides the close button.
//
// Applications that already have a “search” toggle button should not show a
// close button in their search bar, as it duplicates the role of the toggle
// button.
//
// The function takes the following parameters:
//
//   - visible: whether the close button will be shown or not.
func (bar *SearchBar) SetShowCloseButton(visible bool) {
	var _arg0 *C.GtkSearchBar // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(coreglib.InternObject(bar).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_search_bar_set_show_close_button(_arg0, _arg1)
	runtime.KeepAlive(bar)
	runtime.KeepAlive(visible)
}

// SearchEntry: GtkSearchEntry is an entry widget that has been tailored for use
// as a search entry.
//
// The main API for interacting with a GtkSearchEntry as entry is the
// GtkEditable interface.
//
// !An example GtkSearchEntry (search-entry.png)
//
// It will show an inactive symbolic “find” icon when the search entry is empty,
// and a symbolic “clear” icon when there is text. Clicking on the “clear” icon
// will empty the search entry.
//
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay.
// To support this, GtkSearchEntry emits the gtk.SearchEntry::search-changed
// signal which can be used instead of the gtk.Editable::changed signal.
//
// The gtk.SearchEntry::previous-match, gtk.SearchEntry::next-match and
// gtk.SearchEntry::stop-search signals can be used to implement moving between
// search results and ending the search.
//
// Often, GtkSearchEntry will be fed events by means of being placed
// inside a gtk.SearchBar. If that is not the case, you can use
// gtk.SearchEntry.SetKeyCaptureWidget() to let it capture key input from
// another widget.
//
// GtkSearchEntry provides only minimal API and should be used with the
// gtk.Editable API.
//
// CSS Nodes
//
//	entry.search
//	╰── text
//
// GtkSearchEntry has a single CSS node with name entry that carries a .search
// style class, and the text node is a child of that.
//
// # Accessibility
//
// GtkSearchEntry uses the GTK_ACCESSIBLE_ROLE_SEARCH_BOX role.
type SearchEntry struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	EditableTextWidget
}

var (
	_ Widgetter         = (*SearchEntry)(nil)
	_ coreglib.Objector = (*SearchEntry)(nil)
)

func wrapSearchEntry(obj *coreglib.Object) *SearchEntry {
	return &SearchEntry{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		EditableTextWidget: EditableTextWidget{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalSearchEntry(p uintptr) (interface{}, error) {
	return wrapSearchEntry(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when the entry is activated.
//
// The keybindings for this signal are all forms of the Enter key.
func (entry *SearchEntry) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "activate", false, unsafe.Pointer(C._gotk4_gtk4_SearchEntry_ConnectActivate), f)
}

// ConnectNextMatch is emitted when the user initiates a move to the next match
// for the current search string.
//
// This is a keybinding signal (class.SignalAction.html).
//
// Applications should connect to it, to implement moving between matches.
//
// The default bindings for this signal is Ctrl-g.
func (entry *SearchEntry) ConnectNextMatch(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "next-match", false, unsafe.Pointer(C._gotk4_gtk4_SearchEntry_ConnectNextMatch), f)
}

// ConnectPreviousMatch is emitted when the user initiates a move to the
// previous match for the current search string.
//
// This is a keybinding signal (class.SignalAction.html).
//
// Applications should connect to it, to implement moving between matches.
//
// The default bindings for this signal is Ctrl-Shift-g.
func (entry *SearchEntry) ConnectPreviousMatch(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "previous-match", false, unsafe.Pointer(C._gotk4_gtk4_SearchEntry_ConnectPreviousMatch), f)
}

// ConnectSearchChanged is emitted with a short delay of 150 milliseconds after
// the last change to the entry text.
func (entry *SearchEntry) ConnectSearchChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "search-changed", false, unsafe.Pointer(C._gotk4_gtk4_SearchEntry_ConnectSearchChanged), f)
}

// ConnectSearchStarted is emitted when the user initiated a search on the
// entry.
func (entry *SearchEntry) ConnectSearchStarted(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "search-started", false, unsafe.Pointer(C._gotk4_gtk4_SearchEntry_ConnectSearchStarted), f)
}

// ConnectStopSearch is emitted when the user stops a search via keyboard input.
//
// This is a keybinding signal (class.SignalAction.html).
//
// Applications should connect to it, to implement hiding the search entry in
// this case.
//
// The default bindings for this signal is Escape.
func (entry *SearchEntry) ConnectStopSearch(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(entry, "stop-search", false, unsafe.Pointer(C._gotk4_gtk4_SearchEntry_ConnectStopSearch), f)
}

// NewSearchEntry creates a GtkSearchEntry.
//
// The function returns the following values:
//
//   - searchEntry: new GtkSearchEntry.
func NewSearchEntry() *SearchEntry {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_search_entry_new()

	var _searchEntry *SearchEntry // out

	_searchEntry = wrapSearchEntry(coreglib.Take(unsafe.Pointer(_cret)))

	return _searchEntry
}

// KeyCaptureWidget gets the widget that entry is capturing key events from.
//
// The function returns the following values:
//
//   - widget: key capture widget.
func (entry *SearchEntry) KeyCaptureWidget() Widgetter {
	var _arg0 *C.GtkSearchEntry // out
	var _cret *C.GtkWidget      // in

	_arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))

	_cret = C.gtk_search_entry_get_key_capture_widget(_arg0)
	runtime.KeepAlive(entry)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// SetKeyCaptureWidget sets widget as the widget that entry will capture key
// events from.
//
// Key events are consumed by the search entry to start or continue a search.
//
// If the entry is part of a GtkSearchBar, it is preferable to call
// gtk.SearchBar.SetKeyCaptureWidget() instead, which will reveal the entry in
// addition to triggering the search entry.
//
// Note that despite the name of this function, the events are only
// 'captured' in the bubble phase, which means that editable child widgets
// of widget will receive text input before it gets captured. If that
// is not desired, you can capture and forward the events yourself with
// gtk.EventControllerKey.Forward().
//
// The function takes the following parameters:
//
//   - widget (optional): Widget.
func (entry *SearchEntry) SetKeyCaptureWidget(widget Widgetter) {
	var _arg0 *C.GtkSearchEntry // out
	var _arg1 *C.GtkWidget      // out

	_arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_search_entry_set_key_capture_widget(_arg0, _arg1)
	runtime.KeepAlive(entry)
	runtime.KeepAlive(widget)
}

// SelectionFilterModelOverrides contains methods that are overridable.
type SelectionFilterModelOverrides struct {
}

func defaultSelectionFilterModelOverrides(v *SelectionFilterModel) SelectionFilterModelOverrides {
	return SelectionFilterModelOverrides{}
}

// SelectionFilterModel: GtkSelectionFilterModel is a list model that presents
// the selection from a GtkSelectionModel.
type SelectionFilterModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*SelectionFilterModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SelectionFilterModel, *SelectionFilterModelClass, SelectionFilterModelOverrides](
		GTypeSelectionFilterModel,
		initSelectionFilterModelClass,
		wrapSelectionFilterModel,
		defaultSelectionFilterModelOverrides,
	)
}

func initSelectionFilterModelClass(gclass unsafe.Pointer, overrides SelectionFilterModelOverrides, classInitFunc func(*SelectionFilterModelClass)) {
	if classInitFunc != nil {
		class := (*SelectionFilterModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSelectionFilterModel(obj *coreglib.Object) *SelectionFilterModel {
	return &SelectionFilterModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalSelectionFilterModel(p uintptr) (interface{}, error) {
	return wrapSelectionFilterModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSelectionFilterModel creates a new GtkSelectionFilterModel that will
// include the selected items from the underlying selection model.
//
// The function takes the following parameters:
//
//   - model (optional): selection model to filter, or NULL.
//
// The function returns the following values:
//
//   - selectionFilterModel: new GtkSelectionFilterModel.
func NewSelectionFilterModel(model SelectionModeller) *SelectionFilterModel {
	var _arg1 *C.GtkSelectionModel       // out
	var _cret *C.GtkSelectionFilterModel // in

	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_selection_filter_model_new(_arg1)
	runtime.KeepAlive(model)

	var _selectionFilterModel *SelectionFilterModel // out

	_selectionFilterModel = wrapSelectionFilterModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _selectionFilterModel
}

// Model gets the model currently filtered or NULL if none.
//
// The function returns the following values:
//
//   - selectionModel (optional): model that gets filtered.
func (self *SelectionFilterModel) Model() *SelectionModel {
	var _arg0 *C.GtkSelectionFilterModel // out
	var _cret *C.GtkSelectionModel       // in

	_arg0 = (*C.GtkSelectionFilterModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_selection_filter_model_get_model(_arg0)
	runtime.KeepAlive(self)

	var _selectionModel *SelectionModel // out

	if _cret != nil {
		_selectionModel = wrapSelectionModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _selectionModel
}

// SetModel sets the model to be filtered.
//
// Note that GTK makes no effort to ensure that model conforms to the item type
// of self. It assumes that the caller knows what they are doing and have set up
// an appropriate filter to ensure that item types match.
//
// The function takes the following parameters:
//
//   - model (optional) to be filtered.
func (self *SelectionFilterModel) SetModel(model SelectionModeller) {
	var _arg0 *C.GtkSelectionFilterModel // out
	var _arg1 *C.GtkSelectionModel       // out

	_arg0 = (*C.GtkSelectionFilterModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_selection_filter_model_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// Separator: GtkSeparator is a horizontal or vertical separator widget.
//
// !An example GtkSeparator (separators.png)
//
// A GtkSeparator can be used to group the widgets within a window. It displays
// a line with a shadow to make it appear sunken into the interface.
//
// # CSS nodes
//
// GtkSeparator has a single CSS node with name separator. The node gets one of
// the .horizontal or .vertical style classes.
//
// # Accessibility
//
// GtkSeparator uses the K_ACCESSIBLE_ROLE_SEPARATOR role.
type Separator struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Orientable
}

var (
	_ Widgetter         = (*Separator)(nil)
	_ coreglib.Objector = (*Separator)(nil)
)

func wrapSeparator(obj *coreglib.Object) *Separator {
	return &Separator{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalSeparator(p uintptr) (interface{}, error) {
	return wrapSeparator(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSeparator creates a new GtkSeparator with the given orientation.
//
// The function takes the following parameters:
//
//   - orientation separator’s orientation.
//
// The function returns the following values:
//
//   - separator: new GtkSeparator.
func NewSeparator(orientation Orientation) *Separator {
	var _arg1 C.GtkOrientation // out
	var _cret *C.GtkWidget     // in

	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_separator_new(_arg1)
	runtime.KeepAlive(orientation)

	var _separator *Separator // out

	_separator = wrapSeparator(coreglib.Take(unsafe.Pointer(_cret)))

	return _separator
}

// Settings: GtkSettings provides a mechanism to share global settings between
// applications.
//
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings.
//
// On Wayland, the settings are obtained either via a settings portal, or by
// reading desktop settings from DConf.
//
// In the absence of these sharing mechanisms, GTK reads default values for
// settings from settings.ini files in /etc/gtk-4.0, $XDG_CONFIG_DIRS/gtk-4.0
// and $XDG_CONFIG_HOME/gtk-4.0. These files must be valid key files (see
// GKeyFile), and have a section called Settings. Themes can also provide
// default values for settings by installing a settings.ini file next to their
// gtk.css file.
//
// Applications can override system-wide settings by setting the property of the
// GtkSettings object with g_object_set(). This should be restricted to special
// cases though; GtkSettings are not meant as an application configuration
// facility.
//
// There is one GtkSettings instance per display. It can be obtained with
// gtksettings.GetForDisplay, but in many cases, it is more convenient to use
// gtk.Widget.GetSettings().
type Settings struct {
	_ [0]func() // equal guard
	*coreglib.Object

	StyleProvider
}

var (
	_ coreglib.Objector = (*Settings)(nil)
)

func wrapSettings(obj *coreglib.Object) *Settings {
	return &Settings{
		Object: obj,
		StyleProvider: StyleProvider{
			Object: obj,
		},
	}
}

func marshalSettings(p uintptr) (interface{}, error) {
	return wrapSettings(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting.
//
// After this call, the setting will again follow the session-wide value for
// this setting.
//
// The function takes the following parameters:
//
//   - name of the setting to reset.
func (settings *Settings) ResetProperty(name string) {
	var _arg0 *C.GtkSettings // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkSettings)(unsafe.Pointer(coreglib.InternObject(settings).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_settings_reset_property(_arg0, _arg1)
	runtime.KeepAlive(settings)
	runtime.KeepAlive(name)
}

// SettingsGetDefault gets the GtkSettings object for the default display,
// creating it if necessary.
//
// See gtk.Settings.GetForDisplay.
//
// The function returns the following values:
//
//   - settings (optional): GtkSettings object. If there is no default display,
//     then returns NULL.
func SettingsGetDefault() *Settings {
	var _cret *C.GtkSettings // in

	_cret = C.gtk_settings_get_default()

	var _settings *Settings // out

	if _cret != nil {
		_settings = wrapSettings(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _settings
}

// SettingsGetForDisplay gets the GtkSettings object for display, creating it if
// necessary.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
//
// The function returns the following values:
//
//   - settings: GtkSettings object.
func SettingsGetForDisplay(display *gdk.Display) *Settings {
	var _arg1 *C.GdkDisplay  // out
	var _cret *C.GtkSettings // in

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gtk_settings_get_for_display(_arg1)
	runtime.KeepAlive(display)

	var _settings *Settings // out

	_settings = wrapSettings(coreglib.Take(unsafe.Pointer(_cret)))

	return _settings
}

// ShortcutOverrides contains methods that are overridable.
type ShortcutOverrides struct {
}

func defaultShortcutOverrides(v *Shortcut) ShortcutOverrides {
	return ShortcutOverrides{}
}

// Shortcut: GtkShortcut describes a keyboard shortcut.
//
// It contains a description of how to trigger the shortcut via a
// gtk.ShortcutTrigger and a way to activate the shortcut on a widget via a
// gtk.ShortcutAction.
//
// The actual work is usually done via gtk.ShortcutController, which decides if
// and when to activate a shortcut. Using that controller directly however is
// rarely necessary as various higher level convenience APIs exist on Widgets
// that make it easier to use shortcuts in GTK.
//
// GtkShortcut does provide functionality to make it easy for users to work with
// shortcuts, either by providing informational strings for display purposes or
// by allowing shortcuts to be configured.
type Shortcut struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Shortcut)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Shortcut, *ShortcutClass, ShortcutOverrides](
		GTypeShortcut,
		initShortcutClass,
		wrapShortcut,
		defaultShortcutOverrides,
	)
}

func initShortcutClass(gclass unsafe.Pointer, overrides ShortcutOverrides, classInitFunc func(*ShortcutClass)) {
	if classInitFunc != nil {
		class := (*ShortcutClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapShortcut(obj *coreglib.Object) *Shortcut {
	return &Shortcut{
		Object: obj,
	}
}

func marshalShortcut(p uintptr) (interface{}, error) {
	return wrapShortcut(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewShortcut creates a new GtkShortcut that is triggered by trigger and then
// activates action.
//
// The function takes the following parameters:
//
//   - trigger (optional) that will trigger the shortcut.
//   - action (optional) that will be activated upon triggering.
//
// The function returns the following values:
//
//   - shortcut: new GtkShortcut.
func NewShortcut(trigger ShortcutTriggerer, action ShortcutActioner) *Shortcut {
	var _arg1 *C.GtkShortcutTrigger // out
	var _arg2 *C.GtkShortcutAction  // out
	var _cret *C.GtkShortcut        // in

	if trigger != nil {
		_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(coreglib.InternObject(trigger).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(trigger).Native()))
	}
	if action != nil {
		_arg2 = (*C.GtkShortcutAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(action).Native()))
	}

	_cret = C.gtk_shortcut_new(_arg1, _arg2)
	runtime.KeepAlive(trigger)
	runtime.KeepAlive(action)

	var _shortcut *Shortcut // out

	_shortcut = wrapShortcut(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcut
}

// Action gets the action that is activated by this shortcut.
//
// The function returns the following values:
//
//   - shortcutAction (optional): action.
func (self *Shortcut) Action() ShortcutActioner {
	var _arg0 *C.GtkShortcut       // out
	var _cret *C.GtkShortcutAction // in

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_get_action(_arg0)
	runtime.KeepAlive(self)

	var _shortcutAction ShortcutActioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(ShortcutActioner)
				return ok
			})
			rv, ok := casted.(ShortcutActioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.ShortcutActioner")
			}
			_shortcutAction = rv
		}
	}

	return _shortcutAction
}

// Arguments gets the arguments that are passed when activating the shortcut.
//
// The function returns the following values:
//
//   - variant (optional): arguments.
func (self *Shortcut) Arguments() *glib.Variant {
	var _arg0 *C.GtkShortcut // out
	var _cret *C.GVariant    // in

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_get_arguments(_arg0)
	runtime.KeepAlive(self)

	var _variant *glib.Variant // out

	if _cret != nil {
		_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.g_variant_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_variant)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_unref((*C.GVariant)(intern.C))
			},
		)
	}

	return _variant
}

// Trigger gets the trigger used to trigger self.
//
// The function returns the following values:
//
//   - shortcutTrigger (optional): trigger used.
func (self *Shortcut) Trigger() ShortcutTriggerer {
	var _arg0 *C.GtkShortcut        // out
	var _cret *C.GtkShortcutTrigger // in

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_get_trigger(_arg0)
	runtime.KeepAlive(self)

	var _shortcutTrigger ShortcutTriggerer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(ShortcutTriggerer)
				return ok
			})
			rv, ok := casted.(ShortcutTriggerer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.ShortcutTriggerer")
			}
			_shortcutTrigger = rv
		}
	}

	return _shortcutTrigger
}

// SetAction sets the new action for self to be action.
//
// The function takes the following parameters:
//
//   - action (optional): new action. If the action is NULL, the nothing action
//     will be used.
func (self *Shortcut) SetAction(action ShortcutActioner) {
	var _arg0 *C.GtkShortcut       // out
	var _arg1 *C.GtkShortcutAction // out

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if action != nil {
		_arg1 = (*C.GtkShortcutAction)(unsafe.Pointer(coreglib.InternObject(action).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(action).Native()))
	}

	C.gtk_shortcut_set_action(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(action)
}

// SetArguments sets the arguments to pass when activating the shortcut.
//
// The function takes the following parameters:
//
//   - args (optional) arguments to pass when activating self.
func (self *Shortcut) SetArguments(args *glib.Variant) {
	var _arg0 *C.GtkShortcut // out
	var _arg1 *C.GVariant    // out

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if args != nil {
		_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(args)))
	}

	C.gtk_shortcut_set_arguments(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(args)
}

// SetTrigger sets the new trigger for self to be trigger.
//
// The function takes the following parameters:
//
//   - trigger (optional): new trigger. If the trigger is NULL, the never
//     trigger will be used.
func (self *Shortcut) SetTrigger(trigger ShortcutTriggerer) {
	var _arg0 *C.GtkShortcut        // out
	var _arg1 *C.GtkShortcutTrigger // out

	_arg0 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if trigger != nil {
		_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(coreglib.InternObject(trigger).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(trigger).Native()))
	}

	C.gtk_shortcut_set_trigger(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(trigger)
}

// ShortcutAction: GtkShortcutAction encodes an action that can be triggered by
// a keyboard shortcut.
//
// GtkShortcutActions contain functions that allow easy presentation to end
// users as well as being printed for debugging.
//
// All GtkShortcutActions are immutable, you can only specify their properties
// during construction. If you want to change a action, you have to replace
// it with a new one. If you need to pass arguments to an action, these are
// specified by the higher-level GtkShortcut object.
//
// To activate a GtkShortcutAction manually, gtk.ShortcutAction.Activate() can
// be called.
//
// GTK provides various actions:
//
//   - gtk.MnemonicAction: a shortcut action that calls
//     gtk_widget_mnemonic_activate()
//   - gtk.CallbackAction: a shortcut action that invokes a given callback
//   - gtk.SignalAction: a shortcut action that emits a given signal
//   - gtk.ActivateAction: a shortcut action that calls gtk_widget_activate()
//   - gtk.NamedAction: a shortcut action that calls
//     gtk_widget_activate_action()
//   - gtk.NothingAction: a shortcut action that does nothing.
type ShortcutAction struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ShortcutAction)(nil)
)

// ShortcutActioner describes types inherited from class ShortcutAction.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type ShortcutActioner interface {
	coreglib.Objector
	baseShortcutAction() *ShortcutAction
}

var _ ShortcutActioner = (*ShortcutAction)(nil)

func wrapShortcutAction(obj *coreglib.Object) *ShortcutAction {
	return &ShortcutAction{
		Object: obj,
	}
}

func marshalShortcutAction(p uintptr) (interface{}, error) {
	return wrapShortcutAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (self *ShortcutAction) baseShortcutAction() *ShortcutAction {
	return self
}

// BaseShortcutAction returns the underlying base object.
func BaseShortcutAction(obj ShortcutActioner) *ShortcutAction {
	return obj.baseShortcutAction()
}

// NewShortcutActionParseString tries to parse the given string into an action.
//
// On success, the parsed action is returned. When parsing failed, NULL is
// returned.
//
// The accepted strings are:
//
// - nothing, for GtkNothingAction
//
// - activate, for GtkActivateAction
//
// - mnemonic-activate, for GtkMnemonicAction
//
// - action(NAME), for a GtkNamedAction for the action named NAME
//
// - signal(NAME), for a GtkSignalAction for the signal NAME.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//
// The function returns the following values:
//
//   - shortcutAction (optional): new GtkShortcutAction or NULL on error.
func NewShortcutActionParseString(str string) *ShortcutAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_action_parse_string(_arg1)
	runtime.KeepAlive(str)

	var _shortcutAction *ShortcutAction // out

	if _cret != nil {
		_shortcutAction = wrapShortcutAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _shortcutAction
}

// Activate activates the action on the widget with the given args.
//
// Note that some actions ignore the passed in flags, widget or args.
//
// Activation of an action can fail for various reasons. If the action is
// not supported by the widget, if the args don't match the action or if the
// activation otherwise had no effect, FALSE will be returned.
//
// The function takes the following parameters:
//
//   - flags to activate with.
//   - widget: target of the activation.
//   - args (optional) arguments to pass.
//
// The function returns the following values:
//
//   - ok: TRUE if this action was activated successfully.
func (self *ShortcutAction) Activate(flags ShortcutActionFlags, widget Widgetter, args *glib.Variant) bool {
	var _arg0 *C.GtkShortcutAction     // out
	var _arg1 C.GtkShortcutActionFlags // out
	var _arg2 *C.GtkWidget             // out
	var _arg3 *C.GVariant              // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkShortcutActionFlags(flags)
	_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if args != nil {
		_arg3 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(args)))
	}

	_cret = C.gtk_shortcut_action_activate(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(args)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String prints the given action into a human-readable string.
//
// This is a small wrapper around gtk.ShortcutAction.Print() to help when
// debugging.
//
// The function returns the following values:
//
//   - utf8: new string.
func (self *ShortcutAction) String() string {
	var _arg0 *C.GtkShortcutAction // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_action_to_string(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ShortcutController: GtkShortcutController is an event controller that manages
// shortcuts.
//
// Most common shortcuts are using this controller implicitly, e.g. by adding
// a mnemonic underline to a GtkLabel, or by installing a key binding using
// gtk_widget_class_add_binding(), or by adding accelerators to global actions
// using gtk_application_set_accels_for_action().
//
// But it is possible to create your own shortcut controller, and add shortcuts
// to it.
//
// GtkShortcutController implements GListModel for querying the shortcuts that
// have been added to it.
//
// # GtkShortcutController as a GtkBuildable
//
// GtkShortcutControllers can be creates in ui files to set up shortcuts in the
// same place as the widgets.
//
// An example of a UI definition fragment with GtkShortcutController:
//
//	<object class='GtkButton'>
//	  <child>
//	    <object class='GtkShortcutController'>
//	      <property name='scope'>managed</property>
//	      <child>
//	        <object class='GtkShortcut'>
//	          <property name='trigger'>&amp;lt;Control&amp;gt;k</property>
//	          <property name='action'>activate</property>
//	        </object>
//	      </child>
//	    </object>
//	  </child>
//	</object>
//
// This example creates a gtk.ActivateAction for triggering the activate signal
// of the GtkButton. See gtk.ShortcutAction.ParseString for the syntax for other
// kinds of GtkShortcutAction. See gtk.ShortcutTrigger.ParseString to learn more
// about the syntax for triggers.
type ShortcutController struct {
	_ [0]func() // equal guard
	EventController

	*coreglib.Object
	gio.ListModel
	Buildable
}

var (
	_ EventControllerer = (*ShortcutController)(nil)
	_ coreglib.Objector = (*ShortcutController)(nil)
)

func wrapShortcutController(obj *coreglib.Object) *ShortcutController {
	return &ShortcutController{
		EventController: EventController{
			Object: obj,
		},
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalShortcutController(p uintptr) (interface{}, error) {
	return wrapShortcutController(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewShortcutController creates a new shortcut controller.
//
// The function returns the following values:
//
//   - shortcutController: newly created shortcut controller.
func NewShortcutController() *ShortcutController {
	var _cret *C.GtkEventController // in

	_cret = C.gtk_shortcut_controller_new()

	var _shortcutController *ShortcutController // out

	_shortcutController = wrapShortcutController(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcutController
}

// NewShortcutControllerForModel creates a new shortcut controller that takes
// its shortcuts from the given list model.
//
// A controller created by this function does not let you add or remove
// individual shortcuts using the shortcut controller api, but you can change
// the contents of the model.
//
// The function takes the following parameters:
//
//   - model: GListModel containing shortcuts.
//
// The function returns the following values:
//
//   - shortcutController: newly created shortcut controller.
func NewShortcutControllerForModel(model gio.ListModeller) *ShortcutController {
	var _arg1 *C.GListModel         // out
	var _cret *C.GtkEventController // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_shortcut_controller_new_for_model(_arg1)
	runtime.KeepAlive(model)

	var _shortcutController *ShortcutController // out

	_shortcutController = wrapShortcutController(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _shortcutController
}

// AddShortcut adds shortcut to the list of shortcuts handled by self.
//
// If this controller uses an external shortcut list, this function does
// nothing.
//
// The function takes the following parameters:
//
//   - shortcut: GtkShortcut.
func (self *ShortcutController) AddShortcut(shortcut *Shortcut) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 *C.GtkShortcut           // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(shortcut).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(shortcut).Native()))

	C.gtk_shortcut_controller_add_shortcut(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(shortcut)
}

// MnemonicsModifiers gets the mnemonics modifiers for when this controller
// activates its shortcuts.
//
// The function returns the following values:
//
//   - modifierType controller's mnemonics modifiers.
func (self *ShortcutController) MnemonicsModifiers() gdk.ModifierType {
	var _arg0 *C.GtkShortcutController // out
	var _cret C.GdkModifierType        // in

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_controller_get_mnemonics_modifiers(_arg0)
	runtime.KeepAlive(self)

	var _modifierType gdk.ModifierType // out

	_modifierType = gdk.ModifierType(_cret)

	return _modifierType
}

// Scope gets the scope for when this controller activates its shortcuts.
// See gtk_shortcut_controller_set_scope() for details.
//
// The function returns the following values:
//
//   - shortcutScope controller's scope.
func (self *ShortcutController) Scope() ShortcutScope {
	var _arg0 *C.GtkShortcutController // out
	var _cret C.GtkShortcutScope       // in

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_controller_get_scope(_arg0)
	runtime.KeepAlive(self)

	var _shortcutScope ShortcutScope // out

	_shortcutScope = ShortcutScope(_cret)

	return _shortcutScope
}

// RemoveShortcut removes shortcut from the list of shortcuts handled by self.
//
// If shortcut had not been added to controller or this controller uses an
// external shortcut list, this function does nothing.
//
// The function takes the following parameters:
//
//   - shortcut: GtkShortcut.
func (self *ShortcutController) RemoveShortcut(shortcut *Shortcut) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 *C.GtkShortcut           // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(shortcut).Native()))

	C.gtk_shortcut_controller_remove_shortcut(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(shortcut)
}

// SetMnemonicsModifiers sets the controller to have the given
// mnemonics_modifiers.
//
// The mnemonics modifiers determines which modifiers need to be pressed to
// allow activation of shortcuts with mnemonics triggers.
//
// GTK normally uses the Alt modifier for mnemonics, except in PopoverMenus,
// where mnemonics can be triggered without any modifiers. It should be very
// rarely necessary to change this, and doing so is likely to interfere with
// other shortcuts.
//
// This value is only relevant for local shortcut controllers. Global and
// managed shortcut controllers will have their shortcuts activated from other
// places which have their own modifiers for activating mnemonics.
//
// The function takes the following parameters:
//
//   - modifiers: new mnemonics_modifiers to use.
func (self *ShortcutController) SetMnemonicsModifiers(modifiers gdk.ModifierType) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 C.GdkModifierType        // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GdkModifierType(modifiers)

	C.gtk_shortcut_controller_set_mnemonics_modifiers(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(modifiers)
}

// SetScope sets the controller to have the given scope.
//
// The scope allows shortcuts to be activated outside of the normal event
// propagation. In particular, it allows installing global keyboard shortcuts
// that can be activated even when a widget does not have focus.
//
// With GTK_SHORTCUT_SCOPE_LOCAL, shortcuts will only be activated when the
// widget has focus.
//
// The function takes the following parameters:
//
//   - scope: new scope to use.
func (self *ShortcutController) SetScope(scope ShortcutScope) {
	var _arg0 *C.GtkShortcutController // out
	var _arg1 C.GtkShortcutScope       // out

	_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkShortcutScope(scope)

	C.gtk_shortcut_controller_set_scope(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(scope)
}

// ShortcutLabel: GtkShortcutLabel displays a single keyboard shortcut or
// gesture.
//
// The main use case for GtkShortcutLabel is inside a gtk.ShortcutsWindow.
type ShortcutLabel struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*ShortcutLabel)(nil)
)

func wrapShortcutLabel(obj *coreglib.Object) *ShortcutLabel {
	return &ShortcutLabel{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalShortcutLabel(p uintptr) (interface{}, error) {
	return wrapShortcutLabel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewShortcutLabel creates a new GtkShortcutLabel with accelerator set.
//
// The function takes the following parameters:
//
//   - accelerator: initial accelerator.
//
// The function returns the following values:
//
//   - shortcutLabel: newly-allocated GtkShortcutLabel.
func NewShortcutLabel(accelerator string) *ShortcutLabel {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_label_new(_arg1)
	runtime.KeepAlive(accelerator)

	var _shortcutLabel *ShortcutLabel // out

	_shortcutLabel = wrapShortcutLabel(coreglib.Take(unsafe.Pointer(_cret)))

	return _shortcutLabel
}

// Accelerator retrieves the current accelerator of self.
//
// The function returns the following values:
//
//   - utf8 (optional): current accelerator.
func (self *ShortcutLabel) Accelerator() string {
	var _arg0 *C.GtkShortcutLabel // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_label_get_accelerator(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// DisabledText retrieves the text that is displayed when no accelerator is set.
//
// The function returns the following values:
//
//   - utf8 (optional): current text displayed when no accelerator is set.
func (self *ShortcutLabel) DisabledText() string {
	var _arg0 *C.GtkShortcutLabel // out
	var _cret *C.char             // in

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_label_get_disabled_text(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SetAccelerator sets the accelerator to be displayed by self.
//
// The function takes the following parameters:
//
//   - accelerator: new accelerator.
func (self *ShortcutLabel) SetAccelerator(accelerator string) {
	var _arg0 *C.GtkShortcutLabel // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(accelerator)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_shortcut_label_set_accelerator(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(accelerator)
}

// SetDisabledText sets the text to be displayed by self when no accelerator is
// set.
//
// The function takes the following parameters:
//
//   - disabledText: text to be displayed when no accelerator is set.
func (self *ShortcutLabel) SetDisabledText(disabledText string) {
	var _arg0 *C.GtkShortcutLabel // out
	var _arg1 *C.char             // out

	_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(disabledText)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_shortcut_label_set_disabled_text(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(disabledText)
}

// ShortcutTrigger: GtkShortcutTrigger tracks how a GtkShortcut should be
// activated.
//
// To find out if a GtkShortcutTrigger triggers, you can call
// gtk.ShortcutTrigger.Trigger() on a GdkEvent.
//
// GtkShortcutTriggers contain functions that allow easy presentation to end
// users as well as being printed for debugging.
//
// All GtkShortcutTriggers are immutable, you can only specify their properties
// during construction. If you want to change a trigger, you have to replace it
// with a new one.
type ShortcutTrigger struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*ShortcutTrigger)(nil)
)

// ShortcutTriggerer describes types inherited from class ShortcutTrigger.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type ShortcutTriggerer interface {
	coreglib.Objector
	baseShortcutTrigger() *ShortcutTrigger
}

var _ ShortcutTriggerer = (*ShortcutTrigger)(nil)

func wrapShortcutTrigger(obj *coreglib.Object) *ShortcutTrigger {
	return &ShortcutTrigger{
		Object: obj,
	}
}

func marshalShortcutTrigger(p uintptr) (interface{}, error) {
	return wrapShortcutTrigger(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (trigger1 *ShortcutTrigger) baseShortcutTrigger() *ShortcutTrigger {
	return trigger1
}

// BaseShortcutTrigger returns the underlying base object.
func BaseShortcutTrigger(obj ShortcutTriggerer) *ShortcutTrigger {
	return obj.baseShortcutTrigger()
}

// NewShortcutTriggerParseString tries to parse the given string into a trigger.
//
// On success, the parsed trigger is returned. When parsing failed, NULL is
// returned.
//
// The accepted strings are:
//
//   - never, for GtkNeverTrigger
//   - a string parsed by gtk_accelerator_parse(), for a GtkKeyvalTrigger, e.g.
//     <Control>C
//   - underscore, followed by a single character, for GtkMnemonicTrigger, e.g.
//     _l
//   - two valid trigger strings, separated by a | character, for a
//     GtkAlternativeTrigger: <Control>q|<Control>w
//
// Note that you will have to escape the < and > characters when specifying
// triggers in XML files, such as GtkBuilder ui files. Use &lt; instead of < and
// &gt; instead of >.
//
// The function takes the following parameters:
//
//   - str: string to parse.
//
// The function returns the following values:
//
//   - shortcutTrigger (optional): new GtkShortcutTrigger or NULL on error.
func NewShortcutTriggerParseString(str string) *ShortcutTrigger {
	var _arg1 *C.char               // out
	var _cret *C.GtkShortcutTrigger // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_shortcut_trigger_parse_string(_arg1)
	runtime.KeepAlive(str)

	var _shortcutTrigger *ShortcutTrigger // out

	if _cret != nil {
		_shortcutTrigger = wrapShortcutTrigger(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _shortcutTrigger
}

// Compare types of trigger1 and trigger2 are #gconstpointer only to allow use
// of this function as a Func.
//
// They must each be a GtkShortcutTrigger.
//
// The function takes the following parameters:
//
//   - trigger2: GtkShortcutTrigger.
//
// The function returns the following values:
//
//   - gint: integer less than, equal to, or greater than zero if trigger1
//     is found, respectively, to be less than, to match, or be greater than
//     trigger2.
func (trigger1 *ShortcutTrigger) Compare(trigger2 ShortcutTriggerer) int {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.int           // in

	_arg0 = *(*C.gconstpointer)(unsafe.Pointer(coreglib.InternObject(trigger1).Native()))
	_arg1 = *(*C.gconstpointer)(unsafe.Pointer(coreglib.InternObject(trigger2).Native()))

	_cret = C.gtk_shortcut_trigger_compare(_arg0, _arg1)
	runtime.KeepAlive(trigger1)
	runtime.KeepAlive(trigger2)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Equal checks if trigger1 and trigger2 trigger under the same conditions.
//
// The types of one and two are #gconstpointer only to allow use of this
// function with Table. They must each be a GtkShortcutTrigger.
//
// The function takes the following parameters:
//
//   - trigger2: GtkShortcutTrigger.
//
// The function returns the following values:
//
//   - ok: TRUE if trigger1 and trigger2 are equal.
func (trigger1 *ShortcutTrigger) Equal(trigger2 ShortcutTriggerer) bool {
	var _arg0 C.gconstpointer // out
	var _arg1 C.gconstpointer // out
	var _cret C.gboolean      // in

	_arg0 = *(*C.gconstpointer)(unsafe.Pointer(coreglib.InternObject(trigger1).Native()))
	_arg1 = *(*C.gconstpointer)(unsafe.Pointer(coreglib.InternObject(trigger2).Native()))

	_cret = C.gtk_shortcut_trigger_equal(_arg0, _arg1)
	runtime.KeepAlive(trigger1)
	runtime.KeepAlive(trigger2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hash generates a hash value for a GtkShortcutTrigger.
//
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures
// or even different versions of GTK. Do not use this function as a basis for
// building protocols or file formats.
//
// The types of trigger is #gconstpointer only to allow use of this function
// with Table. They must each be a GtkShortcutTrigger.
//
// The function returns the following values:
//
//   - guint: hash value corresponding to trigger.
func (trigger *ShortcutTrigger) Hash() uint {
	var _arg0 C.gconstpointer // out
	var _cret C.guint         // in

	_arg0 = *(*C.gconstpointer)(unsafe.Pointer(coreglib.InternObject(trigger).Native()))

	_cret = C.gtk_shortcut_trigger_hash(_arg0)
	runtime.KeepAlive(trigger)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// ToLabel gets textual representation for the given trigger.
//
// This function is returning a translated string for presentation to end users
// for example in menu items or in help texts.
//
// The display in use may influence the resulting string in various forms, such
// as resolving hardware keycodes or by causing display-specific modifier names.
//
// The form of the representation may change at any time and is not guaranteed
// to stay identical.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay to print for.
//
// The function returns the following values:
//
//   - utf8: new string.
func (self *ShortcutTrigger) ToLabel(display *gdk.Display) string {
	var _arg0 *C.GtkShortcutTrigger // out
	var _arg1 *C.GdkDisplay         // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	_cret = C.gtk_shortcut_trigger_to_label(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(display)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String prints the given trigger into a human-readable string.
//
// This is a small wrapper around gtk.ShortcutTrigger.Print() to help when
// debugging.
//
// The function returns the following values:
//
//   - utf8: new string.
func (self *ShortcutTrigger) String() string {
	var _arg0 *C.GtkShortcutTrigger // out
	var _cret *C.char               // in

	_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_shortcut_trigger_to_string(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Trigger checks if the given event triggers self.
//
// The function takes the following parameters:
//
//   - event to check.
//   - enableMnemonics: TRUE if mnemonics should trigger. Usually the value of
//     this property is determined by checking that the passed in event is a Key
//     event and has the right modifiers set.
//
// The function returns the following values:
//
//   - keyMatch: whether the event triggered the shortcut.
func (self *ShortcutTrigger) Trigger(event gdk.Eventer, enableMnemonics bool) gdk.KeyMatch {
	var _arg0 *C.GtkShortcutTrigger // out
	var _arg1 *C.GdkEvent           // out
	var _arg2 C.gboolean            // out
	var _cret C.GdkKeyMatch         // in

	_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))
	if enableMnemonics {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_shortcut_trigger_trigger(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(event)
	runtime.KeepAlive(enableMnemonics)

	var _keyMatch gdk.KeyMatch // out

	_keyMatch = gdk.KeyMatch(_cret)

	return _keyMatch
}

// ShortcutsGroup: GtkShortcutsGroup represents a group of related keyboard
// shortcuts or gestures.
//
// The group has a title. It may optionally be associated with a view of the
// application, which can be used to show only relevant shortcuts depending on
// the application context.
//
// This widget is only meant to be used with gtk.ShortcutsWindow.
type ShortcutsGroup struct {
	_ [0]func() // equal guard
	Box
}

var (
	_ Widgetter         = (*ShortcutsGroup)(nil)
	_ coreglib.Objector = (*ShortcutsGroup)(nil)
)

func wrapShortcutsGroup(obj *coreglib.Object) *ShortcutsGroup {
	return &ShortcutsGroup{
		Box: Box{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalShortcutsGroup(p uintptr) (interface{}, error) {
	return wrapShortcutsGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ShortcutsSection: GtkShortcutsSection collects all the keyboard shortcuts and
// gestures for a major application mode.
//
// If your application needs multiple sections, you should give each section a
// unique gtk.ShortcutsSection:section-name and a gtk.ShortcutsSection:title
// that can be shown in the section selector of the gtk.ShortcutsWindow.
//
// The gtk.ShortcutsSection:max-height property can be used to influence how the
// groups in the section are distributed over pages and columns.
//
// This widget is only meant to be used with gtk.ShortcutsWindow.
type ShortcutsSection struct {
	_ [0]func() // equal guard
	Box
}

var (
	_ Widgetter         = (*ShortcutsSection)(nil)
	_ coreglib.Objector = (*ShortcutsSection)(nil)
)

func wrapShortcutsSection(obj *coreglib.Object) *ShortcutsSection {
	return &ShortcutsSection{
		Box: Box{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalShortcutsSection(p uintptr) (interface{}, error) {
	return wrapShortcutsSection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (v *ShortcutsSection) ConnectChangeCurrentPage(f func(object int) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "change-current-page", false, unsafe.Pointer(C._gotk4_gtk4_ShortcutsSection_ConnectChangeCurrentPage), f)
}

// ShortcutsShortcut: GtkShortcutsShortcut represents a single keyboard shortcut
// or gesture with a short text.
//
// This widget is only meant to be used with GtkShortcutsWindow.
type ShortcutsShortcut struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*ShortcutsShortcut)(nil)
)

func wrapShortcutsShortcut(obj *coreglib.Object) *ShortcutsShortcut {
	return &ShortcutsShortcut{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalShortcutsShortcut(p uintptr) (interface{}, error) {
	return wrapShortcutsShortcut(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ShortcutsWindow: GtkShortcutsWindow shows information about the keyboard
// shortcuts and gestures of an application.
//
// The shortcuts can be grouped, and you can have multiple sections in this
// window, corresponding to the major modes of your application.
//
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
//
// The recommended way to construct a GtkShortcutsWindow is with gtk.Builder, by
// populating a GtkShortcutsWindow with one or more GtkShortcutsSection objects,
// which contain GtkShortcutsGroups that in turn contain objects of class
// GtkShortcutsShortcut.
//
// A simple example:
//
// ! (gedit-shortcuts.png)
//
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
//
// An example with multiple views:
//
// ! (clocks-shortcuts.png)
//
// This example shows a GtkShortcutsWindow that has been configured to show only
// the shortcuts relevant to the "stopwatch" view.
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
//
// An example with multiple sections:
//
// ! (builder-shortcuts.png)
//
// This example shows a GtkShortcutsWindow with two sections, "Editor Shortcuts"
// and "Terminal Shortcuts".
//
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
type ShortcutsWindow struct {
	_ [0]func() // equal guard
	Window
}

var (
	_ Widgetter         = (*ShortcutsWindow)(nil)
	_ coreglib.Objector = (*ShortcutsWindow)(nil)
)

func wrapShortcutsWindow(obj *coreglib.Object) *ShortcutsWindow {
	return &ShortcutsWindow{
		Window: Window{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Root: Root{
				NativeSurface: NativeSurface{
					Widget: Widget{
						InitiallyUnowned: coreglib.InitiallyUnowned{
							Object: obj,
						},
						Object: obj,
						Accessible: Accessible{
							Object: obj,
						},
						Buildable: Buildable{
							Object: obj,
						},
						ConstraintTarget: ConstraintTarget{
							Object: obj,
						},
					},
				},
			},
			ShortcutManager: ShortcutManager{
				Object: obj,
			},
		},
	}
}

func marshalShortcutsWindow(p uintptr) (interface{}, error) {
	return wrapShortcutsWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClose is emitted when the user uses a keybinding to close the window.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is the Escape key.
func (v *ShortcutsWindow) ConnectClose(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "close", false, unsafe.Pointer(C._gotk4_gtk4_ShortcutsWindow_ConnectClose), f)
}

// ConnectSearch is emitted when the user uses a keybinding to start a search.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default binding for this signal is Control-F.
func (v *ShortcutsWindow) ConnectSearch(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "search", false, unsafe.Pointer(C._gotk4_gtk4_ShortcutsWindow_ConnectSearch), f)
}

// SignalAction: GtkShortcutAction that emits a signal.
//
// Signals that are used in this way are referred to as keybinding signals,
// and they are expected to be defined with the G_SIGNAL_ACTION flag.
type SignalAction struct {
	_ [0]func() // equal guard
	ShortcutAction
}

var (
	_ ShortcutActioner = (*SignalAction)(nil)
)

func wrapSignalAction(obj *coreglib.Object) *SignalAction {
	return &SignalAction{
		ShortcutAction: ShortcutAction{
			Object: obj,
		},
	}
}

func marshalSignalAction(p uintptr) (interface{}, error) {
	return wrapSignalAction(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSignalAction creates an action that when activated, emits the given action
// signal on the provided widget.
//
// It will also unpack the args into arguments passed to the signal.
//
// The function takes the following parameters:
//
//   - signalName: name of the signal to emit.
//
// The function returns the following values:
//
//   - signalAction: new GtkShortcutAction.
func NewSignalAction(signalName string) *SignalAction {
	var _arg1 *C.char              // out
	var _cret *C.GtkShortcutAction // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(signalName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_signal_action_new(_arg1)
	runtime.KeepAlive(signalName)

	var _signalAction *SignalAction // out

	_signalAction = wrapSignalAction(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _signalAction
}

// SignalName returns the name of the signal that will be emitted.
//
// The function returns the following values:
//
//   - utf8: name of the signal to emit.
func (self *SignalAction) SignalName() string {
	var _arg0 *C.GtkSignalAction // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkSignalAction)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_signal_action_get_signal_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// SignalListItemFactory: GtkSignalListItemFactory is a GtkListItemFactory that
// emits signals to to manage listitems.
//
// Signals are emitted for every listitem in the same order:
//
//  1. gtk.SignalListItemFactory::setup is emitted to set up permanent things on
//     the listitem. This usually means constructing the widgets used in the row
//     and adding them to the listitem.
//
//  2. gtk.SignalListItemFactory::bind is emitted to bind the item passed via
//     gtk.ListItem:item to the widgets that have been created in step 1 or to
//     add item-specific widgets. Signals are connected to listen to changes
//     - both to changes in the item to update the widgets or to changes in
//     the widgets to update the item. After this signal has been called,
//     the listitem may be shown in a list widget.
//
//  3. gtk.SignalListItemFactory::unbind is emitted to undo everything done
//     in step 2. Usually this means disconnecting signal handlers. Once this
//     signal has been called, the listitem will no longer be used in a list
//     widget.
//
//  4. gtk.SignalListItemFactory::bind and gtk.SignalListItemFactory::unbind
//     may be emitted multiple times again to bind the listitem for use with new
//     items. By reusing listitems, potentially costly setup can be avoided.
//     However, it means code needs to make sure to properly clean up the
//     listitem in step 3 so that no information from the previous use leaks
//     into the next use.
//
// 5. gtk.SignalListItemFactory::teardown is emitted to allow undoing the
// effects of gtk.SignalListItemFactory::setup. After this signal was emitted on
// a listitem, the listitem will be destroyed and not be used again.
//
// Note that during the signal emissions, changing properties on the ListItems
// passed will not trigger notify signals as the listitem's notifications are
// frozen. See g_object_freeze_notify() for details.
//
// For tracking changes in other properties in the GtkListItem,
// the ::notify signal is recommended. The signal can be connected in
// the gtk.SignalListItemFactory::setup signal and removed again during
// gtk.SignalListItemFactory::teardown.
type SignalListItemFactory struct {
	_ [0]func() // equal guard
	ListItemFactory
}

var (
	_ coreglib.Objector = (*SignalListItemFactory)(nil)
)

func wrapSignalListItemFactory(obj *coreglib.Object) *SignalListItemFactory {
	return &SignalListItemFactory{
		ListItemFactory: ListItemFactory{
			Object: obj,
		},
	}
}

func marshalSignalListItemFactory(p uintptr) (interface{}, error) {
	return wrapSignalListItemFactory(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectBind is emitted when a new gtk.ListItem:item has been set on the
// listitem and should be bound for use.
//
// After this signal was emitted, the listitem might be shown in a gtk.ListView
// or other list widget.
//
// The gtk.SignalListItemFactory::unbind signal is the opposite of this signal
// and can be used to undo everything done in this signal.
func (v *SignalListItemFactory) ConnectBind(f func(listitem *ListItem)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "bind", false, unsafe.Pointer(C._gotk4_gtk4_SignalListItemFactory_ConnectBind), f)
}

// ConnectSetup is emitted when a new listitem has been created and needs to be
// setup for use.
//
// It is the first signal emitted for every listitem.
//
// The gtk.SignalListItemFactory::teardown signal is the opposite of this signal
// and can be used to undo everything done in this signal.
func (v *SignalListItemFactory) ConnectSetup(f func(listitem *ListItem)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "setup", false, unsafe.Pointer(C._gotk4_gtk4_SignalListItemFactory_ConnectSetup), f)
}

// ConnectTeardown is emitted when a listitem is about to be destroyed.
//
// It is the last signal ever emitted for this listitem.
//
// This signal is the opposite of the gtk.SignalListItemFactory::setup signal
// and should be used to undo everything done in that signal.
func (v *SignalListItemFactory) ConnectTeardown(f func(listitem *ListItem)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "teardown", false, unsafe.Pointer(C._gotk4_gtk4_SignalListItemFactory_ConnectTeardown), f)
}

// ConnectUnbind is emitted when a listitem has been removed from use in a list
// widget and its new gtk.ListItem:item is about to be unset.
//
// This signal is the opposite of the gtk.SignalListItemFactory::bind signal and
// should be used to undo everything done in that signal.
func (v *SignalListItemFactory) ConnectUnbind(f func(listitem *ListItem)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(v, "unbind", false, unsafe.Pointer(C._gotk4_gtk4_SignalListItemFactory_ConnectUnbind), f)
}

// NewSignalListItemFactory creates a new GtkSignalListItemFactory.
//
// You need to connect signal handlers before you use it.
//
// The function returns the following values:
//
//   - signalListItemFactory: new GtkSignalListItemFactory.
func NewSignalListItemFactory() *SignalListItemFactory {
	var _cret *C.GtkListItemFactory // in

	_cret = C.gtk_signal_list_item_factory_new()

	var _signalListItemFactory *SignalListItemFactory // out

	_signalListItemFactory = wrapSignalListItemFactory(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _signalListItemFactory
}

// SingleSelectionOverrides contains methods that are overridable.
type SingleSelectionOverrides struct {
}

func defaultSingleSelectionOverrides(v *SingleSelection) SingleSelectionOverrides {
	return SingleSelectionOverrides{}
}

// SingleSelection: GtkSingleSelection is a GtkSelectionModel that allows
// selecting a single item.
//
// Note that the selection is *persistent* -- if the selected item is removed
// and re-added in the same ::items-changed emission, it stays selected.
// In particular, this means that changing the sort order of an underlying sort
// model will preserve the selection.
type SingleSelection struct {
	_ [0]func() // equal guard
	*coreglib.Object

	SelectionModel
}

var (
	_ coreglib.Objector = (*SingleSelection)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SingleSelection, *SingleSelectionClass, SingleSelectionOverrides](
		GTypeSingleSelection,
		initSingleSelectionClass,
		wrapSingleSelection,
		defaultSingleSelectionOverrides,
	)
}

func initSingleSelectionClass(gclass unsafe.Pointer, overrides SingleSelectionOverrides, classInitFunc func(*SingleSelectionClass)) {
	if classInitFunc != nil {
		class := (*SingleSelectionClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSingleSelection(obj *coreglib.Object) *SingleSelection {
	return &SingleSelection{
		Object: obj,
		SelectionModel: SelectionModel{
			ListModel: gio.ListModel{
				Object: obj,
			},
		},
	}
}

func marshalSingleSelection(p uintptr) (interface{}, error) {
	return wrapSingleSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSingleSelection creates a new selection to handle model.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to manage, or NULL.
//
// The function returns the following values:
//
//   - singleSelection: new GtkSingleSelection.
func NewSingleSelection(model gio.ListModeller) *SingleSelection {
	var _arg1 *C.GListModel         // out
	var _cret *C.GtkSingleSelection // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}

	_cret = C.gtk_single_selection_new(_arg1)
	runtime.KeepAlive(model)

	var _singleSelection *SingleSelection // out

	_singleSelection = wrapSingleSelection(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _singleSelection
}

// Autoselect checks if autoselect has been enabled or disabled via
// gtk_single_selection_set_autoselect().
//
// The function returns the following values:
//
//   - ok: TRUE if autoselect is enabled.
func (self *SingleSelection) Autoselect() bool {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_single_selection_get_autoselect(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUnselect: if TRUE, gtk_selection_model_unselect_item() is supported and
// allows unselecting the selected item.
//
// The function returns the following values:
//
//   - ok: TRUE to support unselecting.
func (self *SingleSelection) CanUnselect() bool {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_single_selection_get_can_unselect(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Model gets the model that self is wrapping.
//
// The function returns the following values:
//
//   - listModel: model being wrapped.
func (self *SingleSelection) Model() *gio.ListModel {
	var _arg0 *C.GtkSingleSelection // out
	var _cret *C.GListModel         // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_single_selection_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// Selected gets the position of the selected item.
//
// If no item is selected, GTK_INVALID_LIST_POSITION is returned.
//
// The function returns the following values:
//
//   - guint: position of the selected item.
func (self *SingleSelection) Selected() uint {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.guint               // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_single_selection_get_selected(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SelectedItem gets the selected item.
//
// If no item is selected, NULL is returned.
//
// The function returns the following values:
//
//   - object (optional): selected item.
func (self *SingleSelection) SelectedItem() *coreglib.Object {
	var _arg0 *C.GtkSingleSelection // out
	var _cret C.gpointer            // in

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_single_selection_get_selected_item(_arg0)
	runtime.KeepAlive(self)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// SetAutoselect enables or disables autoselect.
//
// If autoselect is TRUE, self will enforce that an item is always selected.
// It will select a new item when the currently selected item is deleted and it
// will disallow unselecting the current item.
//
// The function takes the following parameters:
//
//   - autoselect: TRUE to always select an item.
func (self *SingleSelection) SetAutoselect(autoselect bool) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if autoselect {
		_arg1 = C.TRUE
	}

	C.gtk_single_selection_set_autoselect(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(autoselect)
}

// SetCanUnselect: if TRUE, unselecting the current item via
// gtk_selection_model_unselect_item() is supported.
//
// Note that setting gtk.SingleSelection:autoselect will cause unselecting to
// not work, so it practically makes no sense to set both at the same time the
// same time.
//
// The function takes the following parameters:
//
//   - canUnselect: TRUE to allow unselecting.
func (self *SingleSelection) SetCanUnselect(canUnselect bool) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if canUnselect {
		_arg1 = C.TRUE
	}

	C.gtk_single_selection_set_can_unselect(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(canUnselect)
}

// SetModel sets the model that self should wrap.
//
// If model is NULL, self will be empty.
//
// The function takes the following parameters:
//
//   - model (optional): GListModel to wrap.
func (self *SingleSelection) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 *C.GListModel         // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_single_selection_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetSelected selects the item at the given position.
//
// If the list does not have an item at position or GTK_INVALID_LIST_POSITION
// is given, the behavior depends on the value of the
// gtk.SingleSelection:autoselect property: If it is set, no change will occur
// and the old item will stay selected. If it is unset, the selection will be
// unset and no item will be selected.
//
// The function takes the following parameters:
//
//   - position: item to select or GTK_INVALID_LIST_POSITION.
func (self *SingleSelection) SetSelected(position uint) {
	var _arg0 *C.GtkSingleSelection // out
	var _arg1 C.guint               // out

	_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	C.gtk_single_selection_set_selected(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// SizeGroup: GtkSizeGroup groups widgets together so they all request the same
// size.
//
// This is typically useful when you want a column of widgets to have the same
// size, but you can’t use a GtkGrid.
//
// In detail, the size requested for each widget in a GtkSizeGroup is the
// maximum of the sizes that would have been requested for each widget in
// the size group if they were not in the size group. The mode of the size
// group (see gtk.SizeGroup.SetMode()) determines whether this applies to the
// horizontal size, the vertical size, or both sizes.
//
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a GtkSizeGroup
// to actually be the same size, you need to pack them in such a way that they
// get the size they request and not more.
//
// GtkSizeGroup objects are referenced by each widget in the size group, so
// once you have added all widgets to a GtkSizeGroup, you can drop the initial
// reference to the size group with g_object_unref(). If the widgets in the size
// group are subsequently destroyed, then they will be removed from the size
// group and drop their references on the size group; when all widgets have been
// removed, the size group will be freed.
//
// Widgets can be part of multiple size groups; GTK will compute the
// horizontal size of a widget from the horizontal requisition of all widgets
// that can be reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size
// from the vertical requisition of all widgets that can be reached from
// the widget by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
//
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
//
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of gtk.Label:width-chars for instance. Widgets with static
// sizes as well as widgets that grow (such as ellipsizing text) need no such
// considerations.
//
// # GtkSizeGroup as GtkBuildable
//
// Size groups can be specified in a UI definition by placing an <object>
// element with class="GtkSizeGroup" somewhere in the UI definition. The widgets
// that belong to the size group are specified by a <widgets> element that may
// contain multiple <widget> elements, one for each member of the size group.
// The ”name” attribute gives the id of the widget.
//
// An example of a UI definition fragment with GtkSizeGroup:
//
//	<object class="GtkSizeGroup">
//	  <property name="mode">horizontal</property>
//	  <widgets>
//	    <widget name="radio1"/>
//	    <widget name="radio2"/>
//	  </widgets>
//	</object>.
type SizeGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
}

var (
	_ coreglib.Objector = (*SizeGroup)(nil)
)

func wrapSizeGroup(obj *coreglib.Object) *SizeGroup {
	return &SizeGroup{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalSizeGroup(p uintptr) (interface{}, error) {
	return wrapSizeGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSizeGroup: create a new GtkSizeGroup.
//
// The function takes the following parameters:
//
//   - mode for the new size group.
//
// The function returns the following values:
//
//   - sizeGroup: newly created GtkSizeGroup.
func NewSizeGroup(mode SizeGroupMode) *SizeGroup {
	var _arg1 C.GtkSizeGroupMode // out
	var _cret *C.GtkSizeGroup    // in

	_arg1 = C.GtkSizeGroupMode(mode)

	_cret = C.gtk_size_group_new(_arg1)
	runtime.KeepAlive(mode)

	var _sizeGroup *SizeGroup // out

	_sizeGroup = wrapSizeGroup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _sizeGroup
}

// AddWidget adds a widget to a GtkSizeGroup.
//
// In the future, the requisition of the widget will be determined as the
// maximum of its requisition and the requisition of the other widgets
// in the size group. Whether this applies horizontally, vertically,
// or in both directions depends on the mode of the size group. See
// gtk.SizeGroup.SetMode().
//
// When the widget is destroyed or no longer referenced elsewhere, it will be
// removed from the size group.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget to add.
func (sizeGroup *SizeGroup) AddWidget(widget Widgetter) {
	var _arg0 *C.GtkSizeGroup // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(coreglib.InternObject(sizeGroup).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_size_group_add_widget(_arg0, _arg1)
	runtime.KeepAlive(sizeGroup)
	runtime.KeepAlive(widget)
}

// Mode gets the current mode of the size group.
//
// The function returns the following values:
//
//   - sizeGroupMode: current mode of the size group.
func (sizeGroup *SizeGroup) Mode() SizeGroupMode {
	var _arg0 *C.GtkSizeGroup    // out
	var _cret C.GtkSizeGroupMode // in

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(coreglib.InternObject(sizeGroup).Native()))

	_cret = C.gtk_size_group_get_mode(_arg0)
	runtime.KeepAlive(sizeGroup)

	var _sizeGroupMode SizeGroupMode // out

	_sizeGroupMode = SizeGroupMode(_cret)

	return _sizeGroupMode
}

// Widgets returns the list of widgets associated with size_group.
//
// The function returns the following values:
//
//   - sList: GSList of widgets. The list is owned by GTK and should not be
//     modified.
func (sizeGroup *SizeGroup) Widgets() []Widgetter {
	var _arg0 *C.GtkSizeGroup // out
	var _cret *C.GSList       // in

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(coreglib.InternObject(sizeGroup).Native()))

	_cret = C.gtk_size_group_get_widgets(_arg0)
	runtime.KeepAlive(sizeGroup)

	var _sList []Widgetter // out

	_sList = make([]Widgetter, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), false, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_sList = append(_sList, dst)
	})

	return _sList
}

// RemoveWidget removes a widget from a GtkSizeGroup.
//
// The function takes the following parameters:
//
//   - widget: GtkWidget to remove.
func (sizeGroup *SizeGroup) RemoveWidget(widget Widgetter) {
	var _arg0 *C.GtkSizeGroup // out
	var _arg1 *C.GtkWidget    // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(coreglib.InternObject(sizeGroup).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_size_group_remove_widget(_arg0, _arg1)
	runtime.KeepAlive(sizeGroup)
	runtime.KeepAlive(widget)
}

// SetMode sets the GtkSizeGroupMode of the size group.
//
// The mode of the size group determines whether the widgets in the size group
// should all have the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL)
// all have the same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should
// all have the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
//
// The function takes the following parameters:
//
//   - mode to set for the size group.
func (sizeGroup *SizeGroup) SetMode(mode SizeGroupMode) {
	var _arg0 *C.GtkSizeGroup    // out
	var _arg1 C.GtkSizeGroupMode // out

	_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(coreglib.InternObject(sizeGroup).Native()))
	_arg1 = C.GtkSizeGroupMode(mode)

	C.gtk_size_group_set_mode(_arg0, _arg1)
	runtime.KeepAlive(sizeGroup)
	runtime.KeepAlive(mode)
}

// SliceListModelOverrides contains methods that are overridable.
type SliceListModelOverrides struct {
}

func defaultSliceListModelOverrides(v *SliceListModel) SliceListModelOverrides {
	return SliceListModelOverrides{}
}

// SliceListModel: GtkSliceListModel is a list model that presents a slice of
// another model.
//
// This is useful when implementing paging by setting the size to the number
// of elements per page and updating the offset whenever a different page is
// opened.
type SliceListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*SliceListModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SliceListModel, *SliceListModelClass, SliceListModelOverrides](
		GTypeSliceListModel,
		initSliceListModelClass,
		wrapSliceListModel,
		defaultSliceListModelOverrides,
	)
}

func initSliceListModelClass(gclass unsafe.Pointer, overrides SliceListModelOverrides, classInitFunc func(*SliceListModelClass)) {
	if classInitFunc != nil {
		class := (*SliceListModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSliceListModel(obj *coreglib.Object) *SliceListModel {
	return &SliceListModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalSliceListModel(p uintptr) (interface{}, error) {
	return wrapSliceListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSliceListModel creates a new slice model.
//
// It presents the slice from offset to offset + size of the given model.
//
// The function takes the following parameters:
//
//   - model (optional) to use, or NULL.
//   - offset of the slice.
//   - size: maximum size of the slice.
//
// The function returns the following values:
//
//   - sliceListModel: new GtkSliceListModel.
func NewSliceListModel(model gio.ListModeller, offset, size uint) *SliceListModel {
	var _arg1 *C.GListModel        // out
	var _arg2 C.guint              // out
	var _arg3 C.guint              // out
	var _cret *C.GtkSliceListModel // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	_arg2 = C.guint(offset)
	_arg3 = C.guint(size)

	_cret = C.gtk_slice_list_model_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(model)
	runtime.KeepAlive(offset)
	runtime.KeepAlive(size)

	var _sliceListModel *SliceListModel // out

	_sliceListModel = wrapSliceListModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _sliceListModel
}

// Model gets the model that is currently being used or NULL if none.
//
// The function returns the following values:
//
//   - listModel (optional): model in use.
func (self *SliceListModel) Model() *gio.ListModel {
	var _arg0 *C.GtkSliceListModel // out
	var _cret *C.GListModel        // in

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_slice_list_model_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// Offset gets the offset set via gtk_slice_list_model_set_offset().
//
// The function returns the following values:
//
//   - guint: offset.
func (self *SliceListModel) Offset() uint {
	var _arg0 *C.GtkSliceListModel // out
	var _cret C.guint              // in

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_slice_list_model_get_offset(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Size gets the size set via gtk_slice_list_model_set_size().
//
// The function returns the following values:
//
//   - guint: size.
func (self *SliceListModel) Size() uint {
	var _arg0 *C.GtkSliceListModel // out
	var _cret C.guint              // in

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_slice_list_model_get_size(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// SetModel sets the model to show a slice of.
//
// The model's item type must conform to self's item type.
//
// The function takes the following parameters:
//
//   - model (optional) to be sliced.
func (self *SliceListModel) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkSliceListModel // out
	var _arg1 *C.GListModel        // out

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_slice_list_model_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetOffset sets the offset into the original model for this slice.
//
// If the offset is too large for the sliced model, self will end up empty.
//
// The function takes the following parameters:
//
//   - offset: new offset to use.
func (self *SliceListModel) SetOffset(offset uint) {
	var _arg0 *C.GtkSliceListModel // out
	var _arg1 C.guint              // out

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(offset)

	C.gtk_slice_list_model_set_offset(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(offset)
}

// SetSize sets the maximum size. self will never have more items than size.
//
// It can however have fewer items if the offset is too large or the model
// sliced from doesn't have enough items.
//
// The function takes the following parameters:
//
//   - size: maximum size.
func (self *SliceListModel) SetSize(size uint) {
	var _arg0 *C.GtkSliceListModel // out
	var _arg1 C.guint              // out

	_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(size)

	C.gtk_slice_list_model_set_size(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(size)
}

// Snapshot: GtkSnapshot assists in creating GskRenderNodes for widgets.
//
// It functions in a similar way to a cairo context, and maintains a stack of
// render nodes and their associated transformations.
//
// The node at the top of the stack is the the one that gtk_snapshot_append_…
// functions operate on. Use the gtk_snapshot_push_… functions and
// gtk_snapshot_pop() to change the current node.
//
// The typical way to obtain a GtkSnapshot object is as an argument to the
// GtkWidgetClass.snapshot() vfunc. If you need to create your own GtkSnapshot,
// use gtk.Snapshot.New.
type Snapshot struct {
	_ [0]func() // equal guard
	gdk.Snapshot
}

var (
	_ gdk.Snapshotter = (*Snapshot)(nil)
)

func wrapSnapshot(obj *coreglib.Object) *Snapshot {
	return &Snapshot{
		Snapshot: gdk.Snapshot{
			Object: obj,
		},
	}
}

func marshalSnapshot(p uintptr) (interface{}, error) {
	return wrapSnapshot(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSnapshot creates a new GtkSnapshot.
//
// The function returns the following values:
//
//   - snapshot: newly-allocated GtkSnapshot.
func NewSnapshot() *Snapshot {
	var _cret *C.GtkSnapshot // in

	_cret = C.gtk_snapshot_new()

	var _snapshot *Snapshot // out

	_snapshot = wrapSnapshot(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _snapshot
}

// AppendBorder appends a stroked border rectangle inside the given outline.
//
// The four sides of the border can have different widths and colors.
//
// The function takes the following parameters:
//
//   - outline: GskRoundedRect describing the outline of the border.
//   - borderWidth: stroke width of the border on the top, right, bottom and
//     left side respectively.
//   - borderColor: color used on the top, right, bottom and left side.
func (snapshot *Snapshot) AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.float          // out
	var _arg3 *C.GdkRGBA        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
	{
		var out [4]C.GdkRGBA
		_arg3 = &out[0]
		for i := 0; i < 4; i++ {
			out[i] = *(*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer((&borderColor[i]))))
		}
	}

	C.gtk_snapshot_append_border(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(borderWidth)
	runtime.KeepAlive(borderColor)
}

// AppendCairo creates a new GskCairoNode and appends it to the current render
// node of snapshot, without changing the current node.
//
// The function takes the following parameters:
//
//   - bounds for the new node.
//
// The function returns the following values:
//
//   - context: cairo_t suitable for drawing the contents of the newly created
//     render node.
func (snapshot *Snapshot) AppendCairo(bounds *graphene.Rect) *cairo.Context {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_rect_t // out
	var _cret *C.cairo_t         // in

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	_cret = C.gtk_snapshot_append_cairo(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)

	var _context *cairo.Context // out

	_context = cairo.WrapContext(uintptr(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_context, func(v *cairo.Context) {
		C.cairo_destroy((*C.cairo_t)(unsafe.Pointer(v.Native())))
	})

	return _context
}

// AppendColor creates a new render node drawing the color into the given bounds
// and appends it to the current render node of snapshot.
//
// You should try to avoid calling this function if color is transparent.
//
// The function takes the following parameters:
//
//   - color: GdkRGBA to draw.
//   - bounds for the new node.
func (snapshot *Snapshot) AppendColor(color *gdk.RGBA, bounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GdkRGBA         // out
	var _arg2 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	C.gtk_snapshot_append_color(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(color)
	runtime.KeepAlive(bounds)
}

// AppendConicGradient appends a conic gradient node with the given stops to
// snapshot.
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render the gradient into.
//   - center point of the conic gradient.
//   - rotation: clockwise rotation in degrees of the starting angle. 0 means
//     the starting angle is the top.
//   - stops: pointer to an array of GskColorStop defining the gradient.
func (snapshot *Snapshot) AppendConicGradient(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(rotation)
	_arg5 = (C.gsize)(len(stops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(stops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(stops))
		for i := range stops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&stops[i]))))
		}
	}

	C.gtk_snapshot_append_conic_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(rotation)
	runtime.KeepAlive(stops)
}

// AppendInsetShadow appends an inset shadow into the box given by outline.
//
// The function takes the following parameters:
//
//   - outline of the region surrounded by shadow.
//   - color of the shadow.
//   - dx: horizontal offset of shadow.
//   - dy: vertical offset of shadow.
//   - spread: how far the shadow spreads towards the inside.
//   - blurRadius: how much blur to apply to the shadow.
func (snapshot *Snapshot) AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	C.gtk_snapshot_append_inset_shadow(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)
}

// The function takes the following parameters:
//
//   - layout
//   - color
func (snapshot *Snapshot) AppendLayout(layout *pango.Layout, color *gdk.RGBA) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 *C.PangoLayout // out
	var _arg2 *C.GdkRGBA     // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))

	C.gtk_snapshot_append_layout(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(color)
}

// AppendLinearGradient appends a linear gradient node with the given stops to
// snapshot.
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render the linear gradient into.
//   - startPoint: point at which the linear gradient will begin.
//   - endPoint: point at which the linear gradient will finish.
//   - stops: pointer to an array of GskColorStop defining the gradient.
func (snapshot *Snapshot) AppendLinearGradient(bounds *graphene.Rect, startPoint, endPoint *graphene.Point, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(startPoint)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(endPoint)))
	_arg5 = (C.gsize)(len(stops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(stops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(stops))
		for i := range stops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&stops[i]))))
		}
	}

	C.gtk_snapshot_append_linear_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(startPoint)
	runtime.KeepAlive(endPoint)
	runtime.KeepAlive(stops)
}

// AppendNode appends node to the current render node of snapshot, without
// changing the current node.
//
// If snapshot does not have a current node yet, node will become the initial
// node.
//
// The function takes the following parameters:
//
//   - node: RenderNode.
func (snapshot *Snapshot) AppendNode(node gsk.RenderNoder) {
	var _arg0 *C.GtkSnapshot   // out
	var _arg1 *C.GskRenderNode // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GskRenderNode)(unsafe.Pointer(coreglib.InternObject(node).Native()))

	C.gtk_snapshot_append_node(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(node)
}

// AppendOutsetShadow appends an outset shadow node around the box given by
// outline.
//
// The function takes the following parameters:
//
//   - outline of the region surrounded by shadow.
//   - color of the shadow.
//   - dx: horizontal offset of shadow.
//   - dy: vertical offset of shadow.
//   - spread: how far the shadow spreads towards the outside.
//   - blurRadius: how much blur to apply to the shadow.
func (snapshot *Snapshot) AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx, dy, spread, blurRadius float32) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out
	var _arg2 *C.GdkRGBA        // out
	var _arg3 C.float           // out
	var _arg4 C.float           // out
	var _arg5 C.float           // out
	var _arg6 C.float           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(outline)))
	_arg2 = (*C.GdkRGBA)(gextras.StructNative(unsafe.Pointer(color)))
	_arg3 = C.float(dx)
	_arg4 = C.float(dy)
	_arg5 = C.float(spread)
	_arg6 = C.float(blurRadius)

	C.gtk_snapshot_append_outset_shadow(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(outline)
	runtime.KeepAlive(color)
	runtime.KeepAlive(dx)
	runtime.KeepAlive(dy)
	runtime.KeepAlive(spread)
	runtime.KeepAlive(blurRadius)
}

// AppendRadialGradient appends a radial gradient node with the given stops to
// snapshot.
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render the readial gradient into.
//   - center point for the radial gradient.
//   - hradius: horizontal radius.
//   - vradius: vertical radius.
//   - start position (on the horizontal axis).
//   - end position (on the horizontal axis).
//   - stops: pointer to an array of GskColorStop defining the gradient.
func (snapshot *Snapshot) AppendRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius, vradius, start, end float32, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(stops))
	_arg7 = (*C.GskColorStop)(C.calloc(C.size_t(len(stops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg7))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg7), len(stops))
		for i := range stops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&stops[i]))))
		}
	}

	C.gtk_snapshot_append_radial_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(stops)
}

// AppendRepeatingLinearGradient appends a repeating linear gradient node with
// the given stops to snapshot.
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render the linear gradient into.
//   - startPoint: point at which the linear gradient will begin.
//   - endPoint: point at which the linear gradient will finish.
//   - stops: pointer to an array of GskColorStop defining the gradient.
func (snapshot *Snapshot) AppendRepeatingLinearGradient(bounds *graphene.Rect, startPoint, endPoint *graphene.Point, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 *C.graphene_point_t // out
	var _arg4 *C.GskColorStop     // out
	var _arg5 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(startPoint)))
	_arg3 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(endPoint)))
	_arg5 = (C.gsize)(len(stops))
	_arg4 = (*C.GskColorStop)(C.calloc(C.size_t(len(stops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg4), len(stops))
		for i := range stops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&stops[i]))))
		}
	}

	C.gtk_snapshot_append_repeating_linear_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(startPoint)
	runtime.KeepAlive(endPoint)
	runtime.KeepAlive(stops)
}

// AppendRepeatingRadialGradient appends a repeating radial gradient node with
// the given stops to snapshot.
//
// The function takes the following parameters:
//
//   - bounds: rectangle to render the readial gradient into.
//   - center point for the radial gradient.
//   - hradius: horizontal radius.
//   - vradius: vertical radius.
//   - start position (on the horizontal axis).
//   - end position (on the horizontal axis).
//   - stops: pointer to an array of GskColorStop defining the gradient.
func (snapshot *Snapshot) AppendRepeatingRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius, vradius, start, end float32, stops []gsk.ColorStop) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_rect_t  // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.float             // out
	var _arg4 C.float             // out
	var _arg5 C.float             // out
	var _arg6 C.float             // out
	var _arg7 *C.GskColorStop     // out
	var _arg8 C.gsize

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(center)))
	_arg3 = C.float(hradius)
	_arg4 = C.float(vradius)
	_arg5 = C.float(start)
	_arg6 = C.float(end)
	_arg8 = (C.gsize)(len(stops))
	_arg7 = (*C.GskColorStop)(C.calloc(C.size_t(len(stops)), C.size_t(C.sizeof_GskColorStop)))
	defer C.free(unsafe.Pointer(_arg7))
	{
		out := unsafe.Slice((*C.GskColorStop)(_arg7), len(stops))
		for i := range stops {
			out[i] = *(*C.GskColorStop)(gextras.StructNative(unsafe.Pointer((&stops[i]))))
		}
	}

	C.gtk_snapshot_append_repeating_radial_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(center)
	runtime.KeepAlive(hradius)
	runtime.KeepAlive(vradius)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(stops)
}

// AppendTexture creates a new render node drawing the texture into the given
// bounds and appends it to the current render node of snapshot.
//
// The function takes the following parameters:
//
//   - texture: GdkTexture to render.
//   - bounds for the new node.
func (snapshot *Snapshot) AppendTexture(texture gdk.Texturer, bounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GdkTexture      // out
	var _arg2 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GdkTexture)(unsafe.Pointer(coreglib.InternObject(texture).Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	C.gtk_snapshot_append_texture(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(texture)
	runtime.KeepAlive(bounds)
}

// GLShaderPopTexture removes the top element from the stack of render nodes and
// adds it to the nearest GskGLShaderNode below it.
//
// This must be called the same number of times as the number of textures is
// needed for the shader in gtk.Snapshot.PushGLShader().
func (snapshot *Snapshot) GLShaderPopTexture() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C.gtk_snapshot_gl_shader_pop_texture(_arg0)
	runtime.KeepAlive(snapshot)
}

// Perspective applies a perspective projection transform.
//
// See gsk.Transform.Perspective() for a discussion on the details.
//
// The function takes the following parameters:
//
//   - depth: distance of the z=0 plane.
func (snapshot *Snapshot) Perspective(depth float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.float(depth)

	C.gtk_snapshot_perspective(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(depth)
}

// Pop removes the top element from the stack of render nodes, and appends it to
// the node underneath it.
func (snapshot *Snapshot) Pop() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C.gtk_snapshot_pop(_arg0)
	runtime.KeepAlive(snapshot)
}

// PushBlend blends together two images with the given blend mode.
//
// Until the first call to gtk.Snapshot.Pop(), the bottom image for the blend
// operation will be recorded. After that call, the top image to be blended will
// be recorded until the second call to gtk.Snapshot.Pop().
//
// Calling this function requires two subsequent calls to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - blendMode: blend mode to use.
func (snapshot *Snapshot) PushBlend(blendMode gsk.BlendMode) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.GskBlendMode // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.GskBlendMode(blendMode)

	C.gtk_snapshot_push_blend(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(blendMode)
}

// PushBlur blurs an image.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - radius: blur radius to use.
func (snapshot *Snapshot) PushBlur(radius float64) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.double(radius)

	C.gtk_snapshot_push_blur(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(radius)
}

// PushClip clips an image to a rectangle.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - bounds: rectangle to clip to.
func (snapshot *Snapshot) PushClip(bounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))

	C.gtk_snapshot_push_clip(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
}

// PushColorMatrix modifies the colors of an image by applying an affine
// transformation in RGB space.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - colorMatrix: color matrix to use.
//   - colorOffset: color offset to use.
func (snapshot *Snapshot) PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4) {
	var _arg0 *C.GtkSnapshot       // out
	var _arg1 *C.graphene_matrix_t // out
	var _arg2 *C.graphene_vec4_t   // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(colorMatrix)))
	_arg2 = (*C.graphene_vec4_t)(gextras.StructNative(unsafe.Pointer(colorOffset)))

	C.gtk_snapshot_push_color_matrix(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(colorMatrix)
	runtime.KeepAlive(colorOffset)
}

// PushCrossFade snapshots a cross-fade operation between two images with the
// given progress.
//
// Until the first call to gtk.Snapshot.Pop(), the start image will be snapshot.
// After that call, the end image will be recorded until the second call to
// gtk.Snapshot.Pop().
//
// Calling this function requires two subsequent calls to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - progress between 0.0 and 1.0.
func (snapshot *Snapshot) PushCrossFade(progress float64) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.double(progress)

	C.gtk_snapshot_push_cross_fade(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(progress)
}

// PushGLShader: push a GskGLShaderNode.
//
// The node uses the given gsk.GLShader and uniform values Additionally
// this takes a list of n_children other nodes which will be passed to the
// GskGLShaderNode.
//
// The take_args argument is a block of data to use for uniform arguments,
// as per types and offsets defined by the shader. Normally this is generated by
// gsk.GLShader.FormatArgs() or gsk.ShaderArgsBuilder.
//
// The snapshotter takes ownership of take_args, so the caller should not free
// it after this.
//
// If the renderer doesn't support GL shaders, or if there is any problem
// when compiling the shader, then the node will draw pink. You should use
// gsk.GLShader.Compile() to ensure the shader will work for the renderer before
// using it.
//
// If the shader requires textures (see gsk.GLShader.GetNTextures()), then it is
// expected that you call gtk.Snapshot.GLShaderPopTexture() the number of times
// that are required. Each of these calls will generate a node that is added as
// a child to the GskGLShaderNode, which in turn will render these offscreen and
// pass as a texture to the shader.
//
// Once all textures (if any) are pop:ed, you must call the regular
// gtk.Snapshot.Pop().
//
// If you want to use pre-existing textures as input to the shader rather than
// rendering new ones, use gtk.Snapshot.AppendTexture() to push a texture node.
// These will be used directly rather than being re-rendered.
//
// For details on how to write shaders, see gsk.GLShader.
//
// The function takes the following parameters:
//
//   - shader: code to run.
//   - bounds: rectangle to render into.
//   - takeArgs: data block with arguments for the shader.
func (snapshot *Snapshot) PushGLShader(shader *gsk.GLShader, bounds *graphene.Rect, takeArgs *glib.Bytes) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GskGLShader     // out
	var _arg2 *C.graphene_rect_t // out
	var _arg3 *C.GBytes          // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GskGLShader)(unsafe.Pointer(coreglib.InternObject(shader).Native()))
	_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	_arg3 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(takeArgs)))

	C.gtk_snapshot_push_gl_shader(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(shader)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(takeArgs)
}

// PushOpacity modifies the opacity of an image.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - opacity to use.
func (snapshot *Snapshot) PushOpacity(opacity float64) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.double       // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.double(opacity)

	C.gtk_snapshot_push_opacity(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(opacity)
}

// PushRepeat creates a node that repeats the child node.
//
// The child is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - bounds within which to repeat.
//   - childBounds (optional) bounds of the child or NULL to use the full size
//     of the collected child node.
func (snapshot *Snapshot) PushRepeat(bounds, childBounds *graphene.Rect) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_rect_t // out
	var _arg2 *C.graphene_rect_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(bounds)))
	if childBounds != nil {
		_arg2 = (*C.graphene_rect_t)(gextras.StructNative(unsafe.Pointer(childBounds)))
	}

	C.gtk_snapshot_push_repeat(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
	runtime.KeepAlive(childBounds)
}

// PushRoundedClip clips an image to a rounded rectangle.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - bounds: rounded rectangle to clip to.
func (snapshot *Snapshot) PushRoundedClip(bounds *gsk.RoundedRect) {
	var _arg0 *C.GtkSnapshot    // out
	var _arg1 *C.GskRoundedRect // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GskRoundedRect)(gextras.StructNative(unsafe.Pointer(bounds)))

	C.gtk_snapshot_push_rounded_clip(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(bounds)
}

// PushShadow applies a shadow to an image.
//
// The image is recorded until the next call to gtk.Snapshot.Pop().
//
// The function takes the following parameters:
//
//   - shadow: first shadow specification.
//   - nShadows: number of shadow specifications.
func (snapshot *Snapshot) PushShadow(shadow *gsk.Shadow, nShadows uint) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 *C.GskShadow   // out
	var _arg2 C.gsize        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GskShadow)(gextras.StructNative(unsafe.Pointer(shadow)))
	_arg2 = C.gsize(nShadows)

	C.gtk_snapshot_push_shadow(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(shadow)
	runtime.KeepAlive(nShadows)
}

// RenderBackground creates a render node for the CSS background according to
// context, and appends it to the current node of snapshot, without changing the
// current node.
//
// The function takes the following parameters:
//
//   - context: GtkStyleContext to use.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func (snapshot *Snapshot) RenderBackground(context *StyleContext, x, y, width, height float64) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)
	_arg4 = C.double(width)
	_arg5 = C.double(height)

	C.gtk_snapshot_render_background(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderFocus creates a render node for the focus outline according to context,
// and appends it to the current node of snapshot, without changing the current
// node.
//
// The function takes the following parameters:
//
//   - context: GtkStyleContext to use.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func (snapshot *Snapshot) RenderFocus(context *StyleContext, x, y, width, height float64) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)
	_arg4 = C.double(width)
	_arg5 = C.double(height)

	C.gtk_snapshot_render_focus(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderFrame creates a render node for the CSS border according to context,
// and appends it to the current node of snapshot, without changing the current
// node.
//
// The function takes the following parameters:
//
//   - context: GtkStyleContext to use.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - width: rectangle width.
//   - height: rectangle height.
func (snapshot *Snapshot) RenderFrame(context *StyleContext, x, y, width, height float64) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 C.double           // out
	var _arg5 C.double           // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)
	_arg4 = C.double(width)
	_arg5 = C.double(height)

	C.gtk_snapshot_render_frame(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// RenderInsertionCursor draws a text caret using snapshot at the specified
// index of layout.
//
// The function takes the following parameters:
//
//   - context: GtkStyleContext.
//   - x: x origin.
//   - y: y origin.
//   - layout: PangoLayout of the text.
//   - index in the Layout.
//   - direction of the text.
func (snapshot *Snapshot) RenderInsertionCursor(context *StyleContext, x, y float64, layout *pango.Layout, index int, direction pango.Direction) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 *C.PangoLayout     // out
	var _arg5 C.int              // out
	var _arg6 C.PangoDirection   // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)
	_arg4 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))
	_arg5 = C.int(index)
	_arg6 = C.PangoDirection(direction)

	C.gtk_snapshot_render_insertion_cursor(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(layout)
	runtime.KeepAlive(index)
	runtime.KeepAlive(direction)
}

// RenderLayout creates a render node for rendering layout according to the
// style information in context, and appends it to the current node of snapshot,
// without changing the current node.
//
// The function takes the following parameters:
//
//   - context: GtkStyleContext to use.
//   - x: x origin of the rectangle.
//   - y: y origin of the rectangle.
//   - layout to render.
func (snapshot *Snapshot) RenderLayout(context *StyleContext, x, y float64, layout *pango.Layout) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.GtkStyleContext // out
	var _arg2 C.double           // out
	var _arg3 C.double           // out
	var _arg4 *C.PangoLayout     // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg2 = C.double(x)
	_arg3 = C.double(y)
	_arg4 = (*C.PangoLayout)(unsafe.Pointer(coreglib.InternObject(layout).Native()))

	C.gtk_snapshot_render_layout(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(context)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(layout)
}

// Restore restores snapshot to the state saved by a preceding call to
// gtk_snapshot_save() and removes that state from the stack of saved states.
func (snapshot *Snapshot) Restore() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C.gtk_snapshot_restore(_arg0)
	runtime.KeepAlive(snapshot)
}

// Rotate rotates @snapshot's coordinate system by angle degrees in 2D space -
// or in 3D speak, rotates around the Z axis.
//
// To rotate around other axes, use gsk.Transform.Rotate3D().
//
// The function takes the following parameters:
//
//   - angle: rotation angle, in degrees (clockwise).
func (snapshot *Snapshot) Rotate(angle float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.float(angle)

	C.gtk_snapshot_rotate(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(angle)
}

// Rotate3D rotates snapshot's coordinate system by angle degrees around axis.
//
// For a rotation in 2D space, use gsk.Transform.Rotate().
//
// The function takes the following parameters:
//
//   - angle: rotation angle, in degrees (clockwise).
//   - axis: rotation axis.
func (snapshot *Snapshot) Rotate3D(angle float32, axis *graphene.Vec3) {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 C.float            // out
	var _arg2 *C.graphene_vec3_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.float(angle)
	_arg2 = (*C.graphene_vec3_t)(gextras.StructNative(unsafe.Pointer(axis)))

	C.gtk_snapshot_rotate_3d(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(angle)
	runtime.KeepAlive(axis)
}

// Save makes a copy of the current state of snapshot and saves it on an
// internal stack.
//
// When gtk.Snapshot.Restore() is called, snapshot will be restored to the saved
// state. Multiple calls to gtk_snapshot_save() and gtk_snapshot_restore() can
// be nested; each call to gtk_snapshot_restore() restores the state from the
// matching paired gtk_snapshot_save().
//
// It is necessary to clear all saved states with corresponding calls to
// gtk_snapshot_restore().
func (snapshot *Snapshot) Save() {
	var _arg0 *C.GtkSnapshot // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C.gtk_snapshot_save(_arg0)
	runtime.KeepAlive(snapshot)
}

// Scale scales snapshot's coordinate system in 2-dimensional space by the given
// factors.
//
// Use gtk.Snapshot.Scale3D() to scale in all 3 dimensions.
//
// The function takes the following parameters:
//
//   - factorX: scaling factor on the X axis.
//   - factorY: scaling factor on the Y axis.
func (snapshot *Snapshot) Scale(factorX, factorY float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out
	var _arg2 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)

	C.gtk_snapshot_scale(_arg0, _arg1, _arg2)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)
}

// Scale3D scales snapshot's coordinate system by the given factors.
//
// The function takes the following parameters:
//
//   - factorX: scaling factor on the X axis.
//   - factorY: scaling factor on the Y axis.
//   - factorZ: scaling factor on the Z axis.
func (snapshot *Snapshot) Scale3D(factorX, factorY, factorZ float32) {
	var _arg0 *C.GtkSnapshot // out
	var _arg1 C.float        // out
	var _arg2 C.float        // out
	var _arg3 C.float        // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = C.float(factorX)
	_arg2 = C.float(factorY)
	_arg3 = C.float(factorZ)

	C.gtk_snapshot_scale_3d(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(factorX)
	runtime.KeepAlive(factorY)
	runtime.KeepAlive(factorZ)
}

// ToNode returns the render node that was constructed by snapshot.
//
// After calling this function, it is no longer possible to add more nodes
// to snapshot. The only function that should be called after this is
// g_object_unref().
//
// The function returns the following values:
//
//   - renderNode: constructed GskRenderNode.
func (snapshot *Snapshot) ToNode() gsk.RenderNoder {
	var _arg0 *C.GtkSnapshot   // out
	var _cret *C.GskRenderNode // in

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	_cret = C.gtk_snapshot_to_node(_arg0)
	runtime.KeepAlive(snapshot)

	var _renderNode gsk.RenderNoder // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gsk.RenderNoder is nil")
		}

		object := coreglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gsk.RenderNoder)
			return ok
		})
		rv, ok := casted.(gsk.RenderNoder)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gsk.RenderNoder")
		}
		_renderNode = rv
	}

	return _renderNode
}

// ToPaintable returns a paintable encapsulating the render node that was
// constructed by snapshot.
//
// After calling this function, it is no longer possible to add more nodes
// to snapshot. The only function that should be called after this is
// g_object_unref().
//
// The function takes the following parameters:
//
//   - size (optional) of the resulting paintable or NULL to use the bounds of
//     the snapshot.
//
// The function returns the following values:
//
//   - paintable: new Paintable.
func (snapshot *Snapshot) ToPaintable(size *graphene.Size) *gdk.Paintable {
	var _arg0 *C.GtkSnapshot     // out
	var _arg1 *C.graphene_size_t // out
	var _cret *C.GdkPaintable    // in

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	if size != nil {
		_arg1 = (*C.graphene_size_t)(gextras.StructNative(unsafe.Pointer(size)))
	}

	_cret = C.gtk_snapshot_to_paintable(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(size)

	var _paintable *gdk.Paintable // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_paintable = &gdk.Paintable{
			Object: obj,
		}
	}

	return _paintable
}

// Transform transforms snapshot's coordinate system with the given transform.
//
// The function takes the following parameters:
//
//   - transform (optional) to apply.
func (snapshot *Snapshot) Transform(transform *gsk.Transform) {
	var _arg0 *C.GtkSnapshot  // out
	var _arg1 *C.GskTransform // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	if transform != nil {
		_arg1 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))
	}

	C.gtk_snapshot_transform(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(transform)
}

// TransformMatrix transforms snapshot's coordinate system with the given
// matrix.
//
// The function takes the following parameters:
//
//   - matrix to multiply the transform with.
func (snapshot *Snapshot) TransformMatrix(matrix *graphene.Matrix) {
	var _arg0 *C.GtkSnapshot       // out
	var _arg1 *C.graphene_matrix_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_matrix_t)(gextras.StructNative(unsafe.Pointer(matrix)))

	C.gtk_snapshot_transform_matrix(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(matrix)
}

// Translate translates snapshot's coordinate system by point in 2-dimensional
// space.
//
// The function takes the following parameters:
//
//   - point to translate the snapshot by.
func (snapshot *Snapshot) Translate(point *graphene.Point) {
	var _arg0 *C.GtkSnapshot      // out
	var _arg1 *C.graphene_point_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	C.gtk_snapshot_translate(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(point)
}

// Translate3D translates snapshot's coordinate system by point.
//
// The function takes the following parameters:
//
//   - point to translate the snapshot by.
func (snapshot *Snapshot) Translate3D(point *graphene.Point3D) {
	var _arg0 *C.GtkSnapshot        // out
	var _arg1 *C.graphene_point3d_t // out

	_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))
	_arg1 = (*C.graphene_point3d_t)(gextras.StructNative(unsafe.Pointer(point)))

	C.gtk_snapshot_translate_3d(_arg0, _arg1)
	runtime.KeepAlive(snapshot)
	runtime.KeepAlive(point)
}

// SortListModelOverrides contains methods that are overridable.
type SortListModelOverrides struct {
}

func defaultSortListModelOverrides(v *SortListModel) SortListModelOverrides {
	return SortListModelOverrides{}
}

// SortListModel: GtkSortListModel is a list model that sorts the elements of
// the underlying model according to a GtkSorter.
//
// The model can be set up to do incremental sorting, so that sorting long lists
// doesn't block the UI. See gtk.SortListModel.SetIncremental() for details.
//
// GtkSortListModel is a generic model and because of that it cannot take
// advantage of any external knowledge when sorting. If you run into performance
// issues with GtkSortListModel, it is strongly recommended that you write your
// own sorting list model.
type SortListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*SortListModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*SortListModel, *SortListModelClass, SortListModelOverrides](
		GTypeSortListModel,
		initSortListModelClass,
		wrapSortListModel,
		defaultSortListModelOverrides,
	)
}

func initSortListModelClass(gclass unsafe.Pointer, overrides SortListModelOverrides, classInitFunc func(*SortListModelClass)) {
	if classInitFunc != nil {
		class := (*SortListModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSortListModel(obj *coreglib.Object) *SortListModel {
	return &SortListModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalSortListModel(p uintptr) (interface{}, error) {
	return wrapSortListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSortListModel creates a new sort list model that uses the sorter to sort
// model.
//
// The function takes the following parameters:
//
//   - model (optional) to sort, or NULL.
//   - sorter (optional): GtkSorter to sort model with, or NULL.
//
// The function returns the following values:
//
//   - sortListModel: new GtkSortListModel.
func NewSortListModel(model gio.ListModeller, sorter *Sorter) *SortListModel {
	var _arg1 *C.GListModel       // out
	var _arg2 *C.GtkSorter        // out
	var _cret *C.GtkSortListModel // in

	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(model).Native()))
	}
	if sorter != nil {
		_arg2 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(sorter).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(sorter).Native()))
	}

	_cret = C.gtk_sort_list_model_new(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(sorter)

	var _sortListModel *SortListModel // out

	_sortListModel = wrapSortListModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _sortListModel
}

// Incremental returns whether incremental sorting is enabled.
//
// See gtk.SortListModel.SetIncremental().
//
// The function returns the following values:
//
//   - ok: TRUE if incremental sorting is enabled.
func (self *SortListModel) Incremental() bool {
	var _arg0 *C.GtkSortListModel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_sort_list_model_get_incremental(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Model gets the model currently sorted or NULL if none.
//
// The function returns the following values:
//
//   - listModel (optional): model that gets sorted.
func (self *SortListModel) Model() *gio.ListModel {
	var _arg0 *C.GtkSortListModel // out
	var _cret *C.GListModel       // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_sort_list_model_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// Pending estimates progress of an ongoing sorting operation.
//
// The estimate is the number of items that would still need to be sorted to
// finish the sorting operation if this was a linear algorithm. So this number
// is not related to how many items are already correctly sorted.
//
// If you want to estimate the progress, you can use code like this:
//
//	pending = gtk_sort_list_model_get_pending (self);
//	model = gtk_sort_list_model_get_model (self);
//	progress = 1.0 - pending / (double) MAX (1, g_list_model_get_n_items (model));
//
// If no sort operation is ongoing - in particular when
// gtk.SortListModel:incremental is FALSE - this function returns 0.
//
// The function returns the following values:
//
//   - guint progress estimate of remaining items to sort.
func (self *SortListModel) Pending() uint {
	var _arg0 *C.GtkSortListModel // out
	var _cret C.guint             // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_sort_list_model_get_pending(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Sorter gets the sorter that is used to sort self.
//
// The function returns the following values:
//
//   - sorter (optional) of #self.
func (self *SortListModel) Sorter() *Sorter {
	var _arg0 *C.GtkSortListModel // out
	var _cret *C.GtkSorter        // in

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_sort_list_model_get_sorter(_arg0)
	runtime.KeepAlive(self)

	var _sorter *Sorter // out

	if _cret != nil {
		_sorter = wrapSorter(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sorter
}

// SetIncremental sets the sort model to do an incremental sort.
//
// When incremental sorting is enabled, the GtkSortListModel will not do a
// complete sort immediately, but will instead queue an idle handler that
// incrementally sorts the items towards their correct position. This of course
// means that items do not instantly appear in the right place. It also means
// that the total sorting time is a lot slower.
//
// When your filter blocks the UI while sorting, you might consider turning this
// on. Depending on your model and sorters, this may become interesting around
// 10,000 to 100,000 items.
//
// By default, incremental sorting is disabled.
//
// See gtk.SortListModel.GetPending() for progress information about an ongoing
// incremental sorting operation.
//
// The function takes the following parameters:
//
//   - incremental: TRUE to sort incrementally.
func (self *SortListModel) SetIncremental(incremental bool) {
	var _arg0 *C.GtkSortListModel // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if incremental {
		_arg1 = C.TRUE
	}

	C.gtk_sort_list_model_set_incremental(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(incremental)
}

// SetModel sets the model to be sorted.
//
// The model's item type must conform to the item type of self.
//
// The function takes the following parameters:
//
//   - model (optional) to be sorted.
func (self *SortListModel) SetModel(model gio.ListModeller) {
	var _arg0 *C.GtkSortListModel // out
	var _arg1 *C.GListModel       // out

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_sort_list_model_set_model(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetSorter sets a new sorter on self.
//
// The function takes the following parameters:
//
//   - sorter (optional): GtkSorter to sort model with.
func (self *SortListModel) SetSorter(sorter *Sorter) {
	var _arg0 *C.GtkSortListModel // out
	var _arg1 *C.GtkSorter        // out

	_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if sorter != nil {
		_arg1 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(sorter).Native()))
	}

	C.gtk_sort_list_model_set_sorter(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sorter)
}

// SorterOverrides contains methods that are overridable.
type SorterOverrides struct {
	// Compare compares two given items according to the sort order implemented
	// by the sorter.
	//
	// Sorters implement a partial order:
	//
	// * It is reflexive, ie a = a * It is antisymmetric, ie if a < b and b < a,
	// then a = b * It is transitive, ie given any 3 items with a ≤ b and b ≤ c,
	// then a ≤ c
	//
	// The sorter may signal it conforms to additional constraints via the
	// return value of gtk.Sorter.GetOrder().
	//
	// The function takes the following parameters:
	//
	//   - item1 (optional): first item to compare.
	//   - item2 (optional): second item to compare.
	//
	// The function returns the following values:
	//
	//   - ordering: GTK_ORDERING_EQUAL if item1 == item2, GTK_ORDERING_SMALLER
	//     if item1 < item2, GTK_ORDERING_LARGER if item1 > item2.
	Compare func(item1, item2 *coreglib.Object) Ordering
	// Order gets the order that self conforms to.
	//
	// See gtk.SorterOrder for details of the possible return values.
	//
	// This function is intended to allow optimizations.
	//
	// The function returns the following values:
	//
	//   - sorterOrder: order.
	Order func() SorterOrder
}

func defaultSorterOverrides(v *Sorter) SorterOverrides {
	return SorterOverrides{
		Compare: v.compare,
		Order:   v.order,
	}
}

// Sorter: GtkSorter is an object to describe sorting criteria.
//
// # Its primary user is gtk.SortListModel
//
// The model will use a sorter to determine the order in which its items should
// appear by calling gtk.Sorter.Compare() for pairs of items.
//
// Sorters may change their sorting behavior through their lifetime.
// In that case, they will emit the gtk.Sorter::changed signal to notify
// that the sort order is no longer valid and should be updated by calling
// gtk_sorter_compare() again.
//
// GTK provides various pre-made sorter implementations for common sorting
// operations. gtk.ColumnView has built-in support for sorting lists via the
// gtk.ColumnViewColumn:sorter property, where the user can change the sorting
// by clicking on list headers.
//
// Of course, in particular for large lists, it is also possible to subclass
// GtkSorter and provide one's own sorter.
type Sorter struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Sorter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Sorter, *SorterClass, SorterOverrides](
		GTypeSorter,
		initSorterClass,
		wrapSorter,
		defaultSorterOverrides,
	)
}

func initSorterClass(gclass unsafe.Pointer, overrides SorterOverrides, classInitFunc func(*SorterClass)) {
	pclass := (*C.GtkSorterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeSorter))))

	if overrides.Compare != nil {
		pclass.compare = (*[0]byte)(C._gotk4_gtk4_SorterClass_compare)
	}

	if overrides.Order != nil {
		pclass.get_order = (*[0]byte)(C._gotk4_gtk4_SorterClass_get_order)
	}

	if classInitFunc != nil {
		class := (*SorterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapSorter(obj *coreglib.Object) *Sorter {
	return &Sorter{
		Object: obj,
	}
}

func marshalSorter(p uintptr) (interface{}, error) {
	return wrapSorter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted whenever the sorter changed.
//
// Users of the sorter should then update the sort order again via
// gtk_sorter_compare().
//
// gtk.SortListModel handles this signal automatically.
//
// Depending on the change parameter, it may be possible to update the sort
// order without a full resorting. Refer to the gtk.SorterChange documentation
// for details.
func (self *Sorter) ConnectChanged(f func(change SorterChange)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "changed", false, unsafe.Pointer(C._gotk4_gtk4_Sorter_ConnectChanged), f)
}

// Changed emits the gtk.Sorter::changed signal to notify all users of the
// sorter that it has changed.
//
// Users of the sorter should then update the sort order via
// gtk_sorter_compare().
//
// Depending on the change parameter, it may be possible to update the sort
// order without a full resorting. Refer to the gtk.SorterChange documentation
// for details.
//
// This function is intended for implementors of GtkSorter subclasses and should
// not be called from other functions.
//
// The function takes the following parameters:
//
//   - change: how the sorter changed.
func (self *Sorter) Changed(change SorterChange) {
	var _arg0 *C.GtkSorter      // out
	var _arg1 C.GtkSorterChange // out

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkSorterChange(change)

	C.gtk_sorter_changed(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(change)
}

// Compare compares two given items according to the sort order implemented by
// the sorter.
//
// Sorters implement a partial order:
//
// * It is reflexive, ie a = a * It is antisymmetric, ie if a < b and b < a,
// then a = b * It is transitive, ie given any 3 items with a ≤ b and b ≤ c,
// then a ≤ c
//
// The sorter may signal it conforms to additional constraints via the return
// value of gtk.Sorter.GetOrder().
//
// The function takes the following parameters:
//
//   - item1: first item to compare.
//   - item2: second item to compare.
//
// The function returns the following values:
//
//   - ordering: GTK_ORDERING_EQUAL if item1 == item2, GTK_ORDERING_SMALLER if
//     item1 < item2, GTK_ORDERING_LARGER if item1 > item2.
func (self *Sorter) Compare(item1, item2 *coreglib.Object) Ordering {
	var _arg0 *C.GtkSorter  // out
	var _arg1 C.gpointer    // out
	var _arg2 C.gpointer    // out
	var _cret C.GtkOrdering // in

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item1.Native()))
	_arg2 = C.gpointer(unsafe.Pointer(item2.Native()))

	_cret = C.gtk_sorter_compare(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(item1)
	runtime.KeepAlive(item2)

	var _ordering Ordering // out

	_ordering = Ordering(_cret)

	return _ordering
}

// Order gets the order that self conforms to.
//
// See gtk.SorterOrder for details of the possible return values.
//
// This function is intended to allow optimizations.
//
// The function returns the following values:
//
//   - sorterOrder: order.
func (self *Sorter) Order() SorterOrder {
	var _arg0 *C.GtkSorter     // out
	var _cret C.GtkSorterOrder // in

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_sorter_get_order(_arg0)
	runtime.KeepAlive(self)

	var _sorterOrder SorterOrder // out

	_sorterOrder = SorterOrder(_cret)

	return _sorterOrder
}

// Compare compares two given items according to the sort order implemented by
// the sorter.
//
// Sorters implement a partial order:
//
// * It is reflexive, ie a = a * It is antisymmetric, ie if a < b and b < a,
// then a = b * It is transitive, ie given any 3 items with a ≤ b and b ≤ c,
// then a ≤ c
//
// The sorter may signal it conforms to additional constraints via the return
// value of gtk.Sorter.GetOrder().
//
// The function takes the following parameters:
//
//   - item1 (optional): first item to compare.
//   - item2 (optional): second item to compare.
//
// The function returns the following values:
//
//   - ordering: GTK_ORDERING_EQUAL if item1 == item2, GTK_ORDERING_SMALLER if
//     item1 < item2, GTK_ORDERING_LARGER if item1 > item2.
func (self *Sorter) compare(item1, item2 *coreglib.Object) Ordering {
	gclass := (*C.GtkSorterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.compare

	var _arg0 *C.GtkSorter  // out
	var _arg1 C.gpointer    // out
	var _arg2 C.gpointer    // out
	var _cret C.GtkOrdering // in

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gpointer(unsafe.Pointer(item1.Native()))
	_arg2 = C.gpointer(unsafe.Pointer(item2.Native()))

	_cret = C._gotk4_gtk4_Sorter_virtual_compare(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(item1)
	runtime.KeepAlive(item2)

	var _ordering Ordering // out

	_ordering = Ordering(_cret)

	return _ordering
}

// Order gets the order that self conforms to.
//
// See gtk.SorterOrder for details of the possible return values.
//
// This function is intended to allow optimizations.
//
// The function returns the following values:
//
//   - sorterOrder: order.
func (self *Sorter) order() SorterOrder {
	gclass := (*C.GtkSorterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.get_order

	var _arg0 *C.GtkSorter     // out
	var _cret C.GtkSorterOrder // in

	_arg0 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C._gotk4_gtk4_Sorter_virtual_get_order(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(self)

	var _sorterOrder SorterOrder // out

	_sorterOrder = SorterOrder(_cret)

	return _sorterOrder
}

// SpinButton: GtkSpinButton is an ideal way to allow the user to set the value
// of some attribute.
//
// !An example GtkSpinButton (spinbutton.png)
//
// Rather than having to directly type a number into a GtkEntry, GtkSpinButton
// allows the user to click on one of two arrows to increment or decrement the
// displayed value. A value can still be typed in, with the bonus that it can be
// checked to ensure it is in a given range.
//
// The main properties of a GtkSpinButton are through an adjustment.
// See the gtk.Adjustment documentation for more details about an adjustment's
// properties.
//
// Note that GtkSpinButton will by default make its entry large enough to
// accommodate the lower and upper bounds of the adjustment. If this is not
// desired, the automatic sizing can be turned off by explicitly setting
// gtk.Editable:width-chars to a value != -1.
//
// Using a GtkSpinButton to get an integer
//
//	// Provides a function to retrieve an integer value from a GtkSpinButton
//	// and creates a spin button to model percentage values.
//
//	int
//	grab_int_value (GtkSpinButton *button,
//	                gpointer       user_data)
//	{
//	  return gtk_spin_button_get_value_as_int (button);
//	}
//
//	void
//	create_integer_spin_button (void)
//	{
//
//	  GtkWidget *window, *button;
//	  GtkAdjustment *adjustment;
//
//	  adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
//
//	  window = gtk_window_new ();
//
//	  // creates the spinbutton, with no decimal places
//	  button = gtk_spin_button_new (adjustment, 1.0, 0);
//	  gtk_window_set_child (GTK_WINDOW (window), button);
//
//	  gtk_widget_show (window);
//	}
//
// Using a GtkSpinButton to get a floating point value
//
//	// Provides a function to retrieve a floating point value from a
//	// GtkSpinButton, and creates a high precision spin button.
//
//	float
//	grab_float_value (GtkSpinButton *button,
//	                  gpointer       user_data)
//	{
//	  return gtk_spin_button_get_value (button);
//	}
//
//	void
//	create_floating_spin_button (void)
//	{
//	  GtkWidget *window, *button;
//	  GtkAdjustment *adjustment;
//
//	  adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
//
//	  window = gtk_window_new ();
//
//	  // creates the spinbutton, with three decimal places
//	  button = gtk_spin_button_new (adjustment, 0.001, 3);
//	  gtk_window_set_child (GTK_WINDOW (window), button);
//
//	  gtk_widget_show (window);
//	}
//
// CSS nodes
//
//	spinbutton.horizontal
//	├── text
//	│    ├── undershoot.left
//	│    ╰── undershoot.right
//	├── button.down
//	╰── button.up
//
//
//
//
//	spinbutton.vertical
//	├── button.up
//	├── text
//	│    ├── undershoot.left
//	│    ╰── undershoot.right
//	╰── button.down
//
// GtkSpinButtons main CSS node has the name spinbutton. It creates subnodes
// for the entry and the two buttons, with these names. The button nodes have
// the style classes .up and .down. The GtkText subnodes (if present) are put
// below the text node. The orientation of the spin button is reflected in the
// .vertical or .horizontal style class on the main node.
//
// # Accessiblity
//
// GtkSpinButton uses the GTK_ACCESSIBLE_ROLE_SPIN_BUTTON role.
type SpinButton struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	coreglib.InitiallyUnowned
	Accessible
	Buildable
	CellEditable
	ConstraintTarget
	EditableTextWidget
	Orientable
}

var (
	_ Widgetter         = (*SpinButton)(nil)
	_ coreglib.Objector = (*SpinButton)(nil)
)

func wrapSpinButton(obj *coreglib.Object) *SpinButton {
	return &SpinButton{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Accessible: Accessible{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
		CellEditable: CellEditable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
		ConstraintTarget: ConstraintTarget{
			Object: obj,
		},
		EditableTextWidget: EditableTextWidget{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
		Orientable: Orientable{
			Object: obj,
		},
	}
}

func marshalSpinButton(p uintptr) (interface{}, error) {
	return wrapSpinButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChangeValue is emitted when the user initiates a value change.
//
// This is a keybinding signal (class.SignalAction.html).
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
// The default bindings for this signal are Up/Down and PageUp/PageDown.
func (spinButton *SpinButton) ConnectChangeValue(f func(scroll ScrollType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(spinButton, "change-value", false, unsafe.Pointer(C._gotk4_gtk4_SpinButton_ConnectChangeValue), f)
}

// ConnectOutput is emitted to tweak the formatting of the value for display.
//
//	// show leading zeros
//	static gboolean
//	on_output (GtkSpinButton *spin,
//	           gpointer       data)
//	{
//	   GtkAdjustment *adjustment;
//	   char *text;
//	   int value;
//
//	   adjustment = gtk_spin_button_get_adjustment (spin);
//	   value = (int)gtk_adjustment_get_value (adjustment);
//	   text = g_strdup_printf ("02d", value);
//	   gtk_spin_button_set_text (spin, text):
//	   g_free (text);
//
//	   return TRUE;
//	}.
func (spinButton *SpinButton) ConnectOutput(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(spinButton, "output", false, unsafe.Pointer(C._gotk4_gtk4_SpinButton_ConnectOutput), f)
}

// ConnectValueChanged is emitted when the value is changed.
//
// Also see the gtk.SpinButton::output signal.
func (spinButton *SpinButton) ConnectValueChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(spinButton, "value-changed", false, unsafe.Pointer(C._gotk4_gtk4_SpinButton_ConnectValueChanged), f)
}

// ConnectWrapped is emitted right after the spinbutton wraps from its maximum
// to its minimum value or vice-versa.
func (spinButton *SpinButton) ConnectWrapped(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(spinButton, "wrapped", false, unsafe.Pointer(C._gotk4_gtk4_SpinButton_ConnectWrapped), f)
}

// NewSpinButton creates a new GtkSpinButton.
//
// The function takes the following parameters:
//
//   - adjustment (optional): GtkAdjustment that this spin button should use,
//     or NULL.
//   - climbRate specifies by how much the rate of change in the value will
//     accelerate if you continue to hold down an up/down button or arrow key.
//   - digits: number of decimal places to display.
//
// The function returns the following values:
//
//   - spinButton: new GtkSpinButton.
func NewSpinButton(adjustment *Adjustment, climbRate float64, digits uint) *SpinButton {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.double         // out
	var _arg3 C.guint          // out
	var _cret *C.GtkWidget     // in

	if adjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}
	_arg2 = C.double(climbRate)
	_arg3 = C.guint(digits)

	_cret = C.gtk_spin_button_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(climbRate)
	runtime.KeepAlive(digits)

	var _spinButton *SpinButton // out

	_spinButton = wrapSpinButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _spinButton
}

// NewSpinButtonWithRange creates a new GtkSpinButton with the given properties.
//
// This is a convenience constructor that allows creation of a numeric
// GtkSpinButton without manually creating an adjustment. The value is initially
// set to the minimum value and a page increment of 10 * step is the default.
// The precision of the spin button is equivalent to the precision of step.
//
// Note that the way in which the precision is derived works best if step is
// a power of ten. If the resulting precision is not suitable for your needs,
// use gtk.SpinButton.SetDigits() to correct it.
//
// The function takes the following parameters:
//
//   - min: minimum allowable value.
//   - max: maximum allowable value.
//   - step: increment added or subtracted by spinning the widget.
//
// The function returns the following values:
//
//   - spinButton: new GtkSpinButton.
func NewSpinButtonWithRange(min, max, step float64) *SpinButton {
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out
	var _cret *C.GtkWidget // in

	_arg1 = C.double(min)
	_arg2 = C.double(max)
	_arg3 = C.double(step)

	_cret = C.gtk_spin_button_new_with_range(_arg1, _arg2, _arg3)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
	runtime.KeepAlive(step)

	var _spinButton *SpinButton // out

	_spinButton = wrapSpinButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _spinButton
}

// Configure changes the properties of an existing spin button.
//
// The adjustment, climb rate, and number of decimal places are updated
// accordingly.
//
// The function takes the following parameters:
//
//   - adjustment (optional): GtkAdjustment to replace the spin button’s
//     existing adjustment, or NULL to leave its current adjustment unchanged.
//   - climbRate: new climb rate.
//   - digits: number of decimal places to display in the spin button.
func (spinButton *SpinButton) Configure(adjustment *Adjustment, climbRate float64, digits uint) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 *C.GtkAdjustment // out
	var _arg2 C.double         // out
	var _arg3 C.guint          // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	if adjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))
	}
	_arg2 = C.double(climbRate)
	_arg3 = C.guint(digits)

	C.gtk_spin_button_configure(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(adjustment)
	runtime.KeepAlive(climbRate)
	runtime.KeepAlive(digits)
}

// Adjustment: get the adjustment associated with a GtkSpinButton.
//
// The function returns the following values:
//
//   - adjustment: GtkAdjustment of spin_button.
func (spinButton *SpinButton) Adjustment() *Adjustment {
	var _arg0 *C.GtkSpinButton // out
	var _cret *C.GtkAdjustment // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_adjustment(_arg0)
	runtime.KeepAlive(spinButton)

	var _adjustment *Adjustment // out

	_adjustment = wrapAdjustment(coreglib.Take(unsafe.Pointer(_cret)))

	return _adjustment
}

// ClimbRate returns the acceleration rate for repeated changes.
//
// The function returns the following values:
//
//   - gdouble: acceleration rate.
func (spinButton *SpinButton) ClimbRate() float64 {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_climb_rate(_arg0)
	runtime.KeepAlive(spinButton)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Digits fetches the precision of spin_button.
//
// The function returns the following values:
//
//   - guint: current precision.
func (spinButton *SpinButton) Digits() uint {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_digits(_arg0)
	runtime.KeepAlive(spinButton)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Increments gets the current step and page the increments used by spin_button.
//
// See gtk.SpinButton.SetIncrements().
//
// The function returns the following values:
//
//   - step (optional): location to store step increment, or NULL.
//   - page (optional): location to store page increment, or NULL.
func (spinButton *SpinButton) Increments() (step, page float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // in
	var _arg2 C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	C.gtk_spin_button_get_increments(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(spinButton)

	var _step float64 // out
	var _page float64 // out

	_step = float64(_arg1)
	_page = float64(_arg2)

	return _step, _page
}

// Numeric returns whether non-numeric text can be typed into the spin button.
//
// The function returns the following values:
//
//   - ok: TRUE if only numeric text can be entered.
func (spinButton *SpinButton) Numeric() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_numeric(_arg0)
	runtime.KeepAlive(spinButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Range gets the range allowed for spin_button.
//
// See gtk.SpinButton.SetRange().
//
// The function returns the following values:
//
//   - min (optional): location to store minimum allowed value, or NULL.
//   - max (optional): location to store maximum allowed value, or NULL.
func (spinButton *SpinButton) Range() (min, max float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // in
	var _arg2 C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	C.gtk_spin_button_get_range(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(spinButton)

	var _min float64 // out
	var _max float64 // out

	_min = float64(_arg1)
	_max = float64(_arg2)

	return _min, _max
}

// SnapToTicks returns whether the values are corrected to the nearest step.
//
// The function returns the following values:
//
//   - ok: TRUE if values are snapped to the nearest step.
func (spinButton *SpinButton) SnapToTicks() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_snap_to_ticks(_arg0)
	runtime.KeepAlive(spinButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// UpdatePolicy gets the update behavior of a spin button.
//
// See gtk.SpinButton.SetUpdatePolicy().
//
// The function returns the following values:
//
//   - spinButtonUpdatePolicy: current update policy.
func (spinButton *SpinButton) UpdatePolicy() SpinButtonUpdatePolicy {
	var _arg0 *C.GtkSpinButton            // out
	var _cret C.GtkSpinButtonUpdatePolicy // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_update_policy(_arg0)
	runtime.KeepAlive(spinButton)

	var _spinButtonUpdatePolicy SpinButtonUpdatePolicy // out

	_spinButtonUpdatePolicy = SpinButtonUpdatePolicy(_cret)

	return _spinButtonUpdatePolicy
}

// Value: get the value in the spin_button.
//
// The function returns the following values:
//
//   - gdouble: value of spin_button.
func (spinButton *SpinButton) Value() float64 {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.double         // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_value(_arg0)
	runtime.KeepAlive(spinButton)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// ValueAsInt: get the value spin_button represented as an integer.
//
// The function returns the following values:
//
//   - gint: value of spin_button.
func (spinButton *SpinButton) ValueAsInt() int {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.int            // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_value_as_int(_arg0)
	runtime.KeepAlive(spinButton)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Wrap returns whether the spin button’s value wraps around to the opposite
// limit when the upper or lower limit of the range is exceeded.
//
// The function returns the following values:
//
//   - ok: TRUE if the spin button wraps around.
func (spinButton *SpinButton) Wrap() bool {
	var _arg0 *C.GtkSpinButton // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	_cret = C.gtk_spin_button_get_wrap(_arg0)
	runtime.KeepAlive(spinButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetAdjustment replaces the GtkAdjustment associated with spin_button.
//
// The function takes the following parameters:
//
//   - adjustment: GtkAdjustment to replace the existing adjustment.
func (spinButton *SpinButton) SetAdjustment(adjustment *Adjustment) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 *C.GtkAdjustment // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(adjustment).Native()))

	C.gtk_spin_button_set_adjustment(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(adjustment)
}

// SetClimbRate sets the acceleration rate for repeated changes when you hold
// down a button or key.
//
// The function takes the following parameters:
//
//   - climbRate: rate of acceleration, must be >= 0.
func (spinButton *SpinButton) SetClimbRate(climbRate float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = C.double(climbRate)

	C.gtk_spin_button_set_climb_rate(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(climbRate)
}

// SetDigits: set the precision to be displayed by spin_button.
//
// Up to 20 digit precision is allowed.
//
// The function takes the following parameters:
//
//   - digits: number of digits after the decimal point to be displayed for the
//     spin button’s value.
func (spinButton *SpinButton) SetDigits(digits uint) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = C.guint(digits)

	C.gtk_spin_button_set_digits(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(digits)
}

// SetIncrements sets the step and page increments for spin_button.
//
// This affects how quickly the value changes when the spin button’s arrows are
// activated.
//
// The function takes the following parameters:
//
//   - step: increment applied for a button 1 press.
//   - page: increment applied for a button 2 press.
func (spinButton *SpinButton) SetIncrements(step, page float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = C.double(step)
	_arg2 = C.double(page)

	C.gtk_spin_button_set_increments(_arg0, _arg1, _arg2)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(step)
	runtime.KeepAlive(page)
}

// SetNumeric sets the flag that determines if non-numeric text can be typed
// into the spin button.
//
// The function takes the following parameters:
//
//   - numeric: flag indicating if only numeric entry is allowed.
func (spinButton *SpinButton) SetNumeric(numeric bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	if numeric {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_numeric(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(numeric)
}

// SetRange sets the minimum and maximum allowable values for spin_button.
//
// If the current value is outside this range, it will be adjusted to fit within
// the range, otherwise it will remain unchanged.
//
// The function takes the following parameters:
//
//   - min: minimum allowable value.
//   - max: maximum allowable value.
func (spinButton *SpinButton) SetRange(min, max float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = C.double(min)
	_arg2 = C.double(max)

	C.gtk_spin_button_set_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(min)
	runtime.KeepAlive(max)
}

// SetSnapToTicks sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after providing an
// invalid value.
//
// The function takes the following parameters:
//
//   - snapToTicks: flag indicating if invalid values should be corrected.
func (spinButton *SpinButton) SetSnapToTicks(snapToTicks bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	if snapToTicks {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_snap_to_ticks(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(snapToTicks)
}

// SetUpdatePolicy sets the update behavior of a spin button.
//
// This determines whether the spin button is always updated or only when a
// valid value is set.
//
// The function takes the following parameters:
//
//   - policy: GtkSpinButtonUpdatePolicy value.
func (spinButton *SpinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy) {
	var _arg0 *C.GtkSpinButton            // out
	var _arg1 C.GtkSpinButtonUpdatePolicy // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = C.GtkSpinButtonUpdatePolicy(policy)

	C.gtk_spin_button_set_update_policy(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(policy)
}

// SetValue sets the value of spin_button.
//
// The function takes the following parameters:
//
//   - value: new value.
func (spinButton *SpinButton) SetValue(value float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = C.double(value)

	C.gtk_spin_button_set_value(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(value)
}

// SetWrap sets the flag that determines if a spin button value wraps around to
// the opposite limit when the upper or lower limit of the range is exceeded.
//
// The function takes the following parameters:
//
//   - wrap: flag indicating if wrapping behavior is performed.
func (spinButton *SpinButton) SetWrap(wrap bool) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	if wrap {
		_arg1 = C.TRUE
	}

	C.gtk_spin_button_set_wrap(_arg0, _arg1)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(wrap)
}

// Spin: increment or decrement a spin button’s value in a specified direction
// by a specified amount.
//
// The function takes the following parameters:
//
//   - direction: GtkSpinType indicating the direction to spin.
//   - increment: step increment to apply in the specified direction.
func (spinButton *SpinButton) Spin(direction SpinType, increment float64) {
	var _arg0 *C.GtkSpinButton // out
	var _arg1 C.GtkSpinType    // out
	var _arg2 C.double         // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))
	_arg1 = C.GtkSpinType(direction)
	_arg2 = C.double(increment)

	C.gtk_spin_button_spin(_arg0, _arg1, _arg2)
	runtime.KeepAlive(spinButton)
	runtime.KeepAlive(direction)
	runtime.KeepAlive(increment)
}

// Update: manually force an update of the spin button.
func (spinButton *SpinButton) Update() {
	var _arg0 *C.GtkSpinButton // out

	_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(coreglib.InternObject(spinButton).Native()))

	C.gtk_spin_button_update(_arg0)
	runtime.KeepAlive(spinButton)
}

// Spinner: GtkSpinner widget displays an icon-size spinning animation.
//
// It is often used as an alternative to a gtk.ProgressBar for displaying
// indefinite activity, instead of actual progress.
//
// !An example GtkSpinner (spinner.png)
//
// To start the animation, use gtk.Spinner.Start(), to stop it use
// gtk.Spinner.Stop().
//
// # CSS nodes
//
// GtkSpinner has a single CSS node with the name spinner. When the animation is
// active, the :checked pseudoclass is added to this node.
type Spinner struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Spinner)(nil)
)

func wrapSpinner(obj *coreglib.Object) *Spinner {
	return &Spinner{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalSpinner(p uintptr) (interface{}, error) {
	return wrapSpinner(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewSpinner returns a new spinner widget. Not yet started.
//
// The function returns the following values:
//
//   - spinner: new GtkSpinner.
func NewSpinner() *Spinner {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_spinner_new()

	var _spinner *Spinner // out

	_spinner = wrapSpinner(coreglib.Take(unsafe.Pointer(_cret)))

	return _spinner
}

// Spinning returns whether the spinner is spinning.
//
// The function returns the following values:
//
//   - ok: TRUE if the spinner is active.
func (spinner *Spinner) Spinning() bool {
	var _arg0 *C.GtkSpinner // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(coreglib.InternObject(spinner).Native()))

	_cret = C.gtk_spinner_get_spinning(_arg0)
	runtime.KeepAlive(spinner)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSpinning sets the activity of the spinner.
//
// The function takes the following parameters:
//
//   - spinning: whether the spinner should be spinning.
func (spinner *Spinner) SetSpinning(spinning bool) {
	var _arg0 *C.GtkSpinner // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(coreglib.InternObject(spinner).Native()))
	if spinning {
		_arg1 = C.TRUE
	}

	C.gtk_spinner_set_spinning(_arg0, _arg1)
	runtime.KeepAlive(spinner)
	runtime.KeepAlive(spinning)
}

// Start starts the animation of the spinner.
func (spinner *Spinner) Start() {
	var _arg0 *C.GtkSpinner // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(coreglib.InternObject(spinner).Native()))

	C.gtk_spinner_start(_arg0)
	runtime.KeepAlive(spinner)
}

// Stop stops the animation of the spinner.
func (spinner *Spinner) Stop() {
	var _arg0 *C.GtkSpinner // out

	_arg0 = (*C.GtkSpinner)(unsafe.Pointer(coreglib.InternObject(spinner).Native()))

	C.gtk_spinner_stop(_arg0)
	runtime.KeepAlive(spinner)
}

// Stack: GtkStack is a container which only shows one of its children at a
// time.
//
// In contrast to GtkNotebook, GtkStack does not provide a means for
// users to change the visible child. Instead, a separate widget such as
// gtk.StackSwitcher or gtk.StackSidebar can be used with GtkStack to provide
// this functionality.
//
// Transitions between pages can be animated as slides or fades. This can be
// controlled with gtk.Stack.SetTransitionType(). These animations respect the
// gtk.Settings:gtk-enable-animations setting.
//
// GtkStack maintains a gtk.StackPage object for each added child, which holds
// additional per-child properties. You obtain the GtkStackPage for a child with
// gtk.Stack.GetPage() and you can obtain a GtkSelectionModel containing all the
// pages with gtk.Stack.GetPages().
//
// # GtkStack as GtkBuildable
//
// To set child-specific properties in a .ui file, create GtkStackPage objects
// explicitly, and set the child widget as a property on it:
//
//	<object class="GtkStack" id="stack">
//	  <child>
//	    <object class="GtkStackPage">
//	      <property name="name">page1</property>
//	      <property name="title">In the beginning…</property>
//	      <property name="child">
//	        <object class="GtkLabel">
//	          <property name="label">It was dark</property>
//	        </object>
//	      </property>
//	    </object>
//	  </child>
//
// # CSS nodes
//
// GtkStack has a single CSS node named stack.
//
// # Accessibility
//
// GtkStack uses the GTK_ACCESSIBLE_ROLE_TAB_PANEL for the stack pages, which
// are the accessible parent objects of the child widgets.
type Stack struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Stack)(nil)
)

func wrapStack(obj *coreglib.Object) *Stack {
	return &Stack{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalStack(p uintptr) (interface{}, error) {
	return wrapStack(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStack creates a new GtkStack.
//
// The function returns the following values:
//
//   - stack: new GtkStack.
func NewStack() *Stack {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_new()

	var _stack *Stack // out

	_stack = wrapStack(coreglib.Take(unsafe.Pointer(_cret)))

	return _stack
}

// AddChild adds a child to stack.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//
// The function returns the following values:
//
//   - stackPage: GtkStackPage for child.
func (stack *Stack) AddChild(child Widgetter) *StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_stack_add_child(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(child)

	var _stackPage *StackPage // out

	_stackPage = wrapStackPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _stackPage
}

// AddNamed adds a child to stack.
//
// The child is identified by the name.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//   - name (optional) for child or NULL.
//
// The function returns the following values:
//
//   - stackPage: GtkStackPage for child.
func (stack *Stack) AddNamed(child Widgetter, name string) *StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.char         // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if name != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_stack_add_named(_arg0, _arg1, _arg2)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(child)
	runtime.KeepAlive(name)

	var _stackPage *StackPage // out

	_stackPage = wrapStackPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _stackPage
}

// AddTitled adds a child to stack.
//
// The child is identified by the name. The title will be used by
// GtkStackSwitcher to represent child in a tab bar, so it should be short.
//
// The function takes the following parameters:
//
//   - child: widget to add.
//   - name (optional) for child.
//   - title: human-readable title for child.
//
// The function returns the following values:
//
//   - stackPage: GtkStackPage for child.
func (stack *Stack) AddTitled(child Widgetter, name, title string) *StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _arg2 *C.char         // out
	var _arg3 *C.char         // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	if name != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg3))

	_cret = C.gtk_stack_add_titled(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(child)
	runtime.KeepAlive(name)
	runtime.KeepAlive(title)

	var _stackPage *StackPage // out

	_stackPage = wrapStackPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _stackPage
}

// ChildByName finds the child with the name given as the argument.
//
// Returns NULL if there is no child with this name.
//
// The function takes the following parameters:
//
//   - name of the child to find.
//
// The function returns the following values:
//
//   - widget (optional): requested child of the GtkStack.
func (stack *Stack) ChildByName(name string) Widgetter {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_stack_get_child_by_name(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(name)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Hhomogeneous gets whether stack is horizontally homogeneous.
//
// The function returns the following values:
//
//   - ok: whether stack is horizontally homogeneous.
func (stack *Stack) Hhomogeneous() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_hhomogeneous(_arg0)
	runtime.KeepAlive(stack)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InterpolateSize returns whether the Stack is set up to interpolate between
// the sizes of children on page switch.
//
// The function returns the following values:
//
//   - ok: TRUE if child sizes are interpolated.
func (stack *Stack) InterpolateSize() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_interpolate_size(_arg0)
	runtime.KeepAlive(stack)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Page returns the GtkStackPage object for child.
//
// The function takes the following parameters:
//
//   - child of stack.
//
// The function returns the following values:
//
//   - stackPage: GtkStackPage for child.
func (stack *Stack) Page(child Widgetter) *StackPage {
	var _arg0 *C.GtkStack     // out
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GtkStackPage // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	_cret = C.gtk_stack_get_page(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(child)

	var _stackPage *StackPage // out

	_stackPage = wrapStackPage(coreglib.Take(unsafe.Pointer(_cret)))

	return _stackPage
}

// Pages returns a GListModel that contains the pages of the stack.
//
// This can be used to keep an up-to-date view. The model also implements
// gtk.SelectionModel and can be used to track and modify the visible page.
//
// The function returns the following values:
//
//   - selectionModel: GtkSelectionModel for the stack's children.
func (stack *Stack) Pages() *SelectionModel {
	var _arg0 *C.GtkStack          // out
	var _cret *C.GtkSelectionModel // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_pages(_arg0)
	runtime.KeepAlive(stack)

	var _selectionModel *SelectionModel // out

	_selectionModel = wrapSelectionModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _selectionModel
}

// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between pages in stack will take.
//
// The function returns the following values:
//
//   - guint: transition duration.
func (stack *Stack) TransitionDuration() uint {
	var _arg0 *C.GtkStack // out
	var _cret C.guint     // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_transition_duration(_arg0)
	runtime.KeepAlive(stack)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// TransitionRunning returns whether the stack is currently in a transition from
// one page to another.
//
// The function returns the following values:
//
//   - ok: TRUE if the transition is currently running, FALSE otherwise.
func (stack *Stack) TransitionRunning() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_transition_running(_arg0)
	runtime.KeepAlive(stack)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TransitionType gets the type of animation that will be used for transitions
// between pages in stack.
//
// The function returns the following values:
//
//   - stackTransitionType: current transition type of stack.
func (stack *Stack) TransitionType() StackTransitionType {
	var _arg0 *C.GtkStack              // out
	var _cret C.GtkStackTransitionType // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_transition_type(_arg0)
	runtime.KeepAlive(stack)

	var _stackTransitionType StackTransitionType // out

	_stackTransitionType = StackTransitionType(_cret)

	return _stackTransitionType
}

// Vhomogeneous gets whether stack is vertically homogeneous.
//
// The function returns the following values:
//
//   - ok: whether stack is vertically homogeneous.
func (stack *Stack) Vhomogeneous() bool {
	var _arg0 *C.GtkStack // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_vhomogeneous(_arg0)
	runtime.KeepAlive(stack)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VisibleChild gets the currently visible child of stack.
//
// Returns NULL if there are no visible children.
//
// The function returns the following values:
//
//   - widget (optional): visible child of the GtkStack.
func (stack *Stack) VisibleChild() Widgetter {
	var _arg0 *C.GtkStack  // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_visible_child(_arg0)
	runtime.KeepAlive(stack)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// VisibleChildName returns the name of the currently visible child of stack.
//
// Returns NULL if there is no visible child.
//
// The function returns the following values:
//
//   - utf8 (optional): name of the visible child of the GtkStack.
func (stack *Stack) VisibleChildName() string {
	var _arg0 *C.GtkStack // out
	var _cret *C.char     // in

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	_cret = C.gtk_stack_get_visible_child_name(_arg0)
	runtime.KeepAlive(stack)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Remove removes a child widget from stack.
//
// The function takes the following parameters:
//
//   - child to remove.
func (stack *Stack) Remove(child Widgetter) {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_stack_remove(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(child)
}

// SetHhomogeneous sets the GtkStack to be horizontally homogeneous or not.
//
// If it is homogeneous, the GtkStack will request the same width for all its
// children. If it isn't, the stack may change width when a different child
// becomes visible.
//
// The function takes the following parameters:
//
//   - hhomogeneous: TRUE to make stack horizontally homogeneous.
func (stack *Stack) SetHhomogeneous(hhomogeneous bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	if hhomogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_hhomogeneous(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(hhomogeneous)
}

// SetInterpolateSize sets whether or not stack will interpolate its size when
// changing the visible child.
//
// If the gtk.Stack:interpolate-size property is set to TRUE, stack will
// interpolate its size between the current one and the one it'll take after
// changing the visible child, according to the set transition duration.
//
// The function takes the following parameters:
//
//   - interpolateSize: new value.
func (stack *Stack) SetInterpolateSize(interpolateSize bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	if interpolateSize {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_interpolate_size(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(interpolateSize)
}

// SetTransitionDuration sets the duration that transitions between pages in
// stack will take.
//
// The function takes the following parameters:
//
//   - duration: new duration, in milliseconds.
func (stack *Stack) SetTransitionDuration(duration uint) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.guint     // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = C.guint(duration)

	C.gtk_stack_set_transition_duration(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(duration)
}

// SetTransitionType sets the type of animation that will be used for
// transitions between pages in stack.
//
// Available types include various kinds of fades and slides.
//
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the page that is about to become
// current.
//
// The function takes the following parameters:
//
//   - transition: new transition type.
func (stack *Stack) SetTransitionType(transition StackTransitionType) {
	var _arg0 *C.GtkStack              // out
	var _arg1 C.GtkStackTransitionType // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = C.GtkStackTransitionType(transition)

	C.gtk_stack_set_transition_type(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(transition)
}

// SetVhomogeneous sets the Stack to be vertically homogeneous or not.
//
// If it is homogeneous, the GtkStack will request the same height for all its
// children. If it isn't, the stack may change height when a different child
// becomes visible.
//
// The function takes the following parameters:
//
//   - vhomogeneous: TRUE to make stack vertically homogeneous.
func (stack *Stack) SetVhomogeneous(vhomogeneous bool) {
	var _arg0 *C.GtkStack // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	if vhomogeneous {
		_arg1 = C.TRUE
	}

	C.gtk_stack_set_vhomogeneous(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(vhomogeneous)
}

// SetVisibleChild makes child the visible child of stack.
//
// If child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of stack.
//
// Note that the child widget has to be visible itself (see gtk.Widget.Show())
// in order to become the visible child of stack.
//
// The function takes the following parameters:
//
//   - child of stack.
func (stack *Stack) SetVisibleChild(child Widgetter) {
	var _arg0 *C.GtkStack  // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_stack_set_visible_child(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(child)
}

// SetVisibleChildFull makes the child with the given name visible.
//
// Note that the child widget has to be visible itself (see gtk.Widget.Show())
// in order to become the visible child of stack.
//
// The function takes the following parameters:
//
//   - name of the child to make visible.
//   - transition type to use.
func (stack *Stack) SetVisibleChildFull(name string, transition StackTransitionType) {
	var _arg0 *C.GtkStack              // out
	var _arg1 *C.char                  // out
	var _arg2 C.GtkStackTransitionType // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GtkStackTransitionType(transition)

	C.gtk_stack_set_visible_child_full(_arg0, _arg1, _arg2)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(name)
	runtime.KeepAlive(transition)
}

// SetVisibleChildName makes the child with the given name visible.
//
// If child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of stack.
//
// Note that the child widget has to be visible itself (see gtk.Widget.Show())
// in order to become the visible child of stack.
//
// The function takes the following parameters:
//
//   - name of the child to make visible.
func (stack *Stack) SetVisibleChildName(name string) {
	var _arg0 *C.GtkStack // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_set_visible_child_name(_arg0, _arg1)
	runtime.KeepAlive(stack)
	runtime.KeepAlive(name)
}

// StackPage: GtkStackPage is an auxiliary class used by GtkStack.
type StackPage struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Accessible
}

var (
	_ coreglib.Objector = (*StackPage)(nil)
)

func wrapStackPage(obj *coreglib.Object) *StackPage {
	return &StackPage{
		Object: obj,
		Accessible: Accessible{
			Object: obj,
		},
	}
}

func marshalStackPage(p uintptr) (interface{}, error) {
	return wrapStackPage(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// Child returns the stack child to which self belongs.
//
// The function returns the following values:
//
//   - widget: child to which self belongs.
func (self *StackPage) Child() Widgetter {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.GtkWidget    // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_page_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// IconName returns the icon name of the page.
//
// The function returns the following values:
//
//   - utf8 (optional): value of the gtk.StackPage:icon-name property.
func (self *StackPage) IconName() string {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_page_get_icon_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Name returns the name of the page.
//
// The function returns the following values:
//
//   - utf8 (optional): value of the gtk.StackPage:name property.
func (self *StackPage) Name() string {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_page_get_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// NeedsAttention returns whether the page is marked as “needs attention”.
//
// The function returns the following values:
//
//   - ok: value of the gtk.StackPage:needs-attention property.
func (self *StackPage) NeedsAttention() bool {
	var _arg0 *C.GtkStackPage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_page_get_needs_attention(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title gets the page title.
//
// The function returns the following values:
//
//   - utf8 (optional): value of the gtk.StackPage:title property.
func (self *StackPage) Title() string {
	var _arg0 *C.GtkStackPage // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_page_get_title(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// UseUnderline gets whether underlines in the page title indicate mnemonics.
//
// The function returns the following values:
//
//   - ok: value of the gtk.StackPage:use-underline property.
func (self *StackPage) UseUnderline() bool {
	var _arg0 *C.GtkStackPage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_page_get_use_underline(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visible returns whether page is visible in its GtkStack.
//
// This is independent from the gtk.Widget:visible property of its widget.
//
// The function returns the following values:
//
//   - ok: TRUE if page is visible.
func (self *StackPage) Visible() bool {
	var _arg0 *C.GtkStackPage // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_page_get_visible(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetIconName sets the icon name of the page.
//
// The function takes the following parameters:
//
//   - setting: new value to set.
func (self *StackPage) SetIconName(setting string) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(setting)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetName sets the name of the page.
//
// The function takes the following parameters:
//
//   - setting: new value to set.
func (self *StackPage) SetName(setting string) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(setting)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_name(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetNeedsAttention sets whether the page is marked as “needs attention”.
//
// The function takes the following parameters:
//
//   - setting: new value to set.
func (self *StackPage) SetNeedsAttention(setting bool) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_stack_page_set_needs_attention(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetTitle sets the page title.
//
// The function takes the following parameters:
//
//   - setting: new value to set.
func (self *StackPage) SetTitle(setting string) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 *C.char         // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(setting)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_stack_page_set_title(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetUseUnderline sets whether underlines in the page title indicate mnemonics.
//
// The function takes the following parameters:
//
//   - setting: new value to set.
func (self *StackPage) SetUseUnderline(setting bool) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_stack_page_set_use_underline(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(setting)
}

// SetVisible sets whether page is visible in its GtkStack.
//
// The function takes the following parameters:
//
//   - visible: new property value.
func (self *StackPage) SetVisible(visible bool) {
	var _arg0 *C.GtkStackPage // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.GtkStackPage)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_stack_page_set_visible(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(visible)
}

// StackSidebar: GtkStackSidebar uses a sidebar to switch between GtkStack
// pages.
//
// In order to use a GtkStackSidebar, you simply use a GtkStack to organize
// your UI flow, and add the sidebar to your sidebar area. You can use
// gtk.StackSidebar.SetStack() to connect the GtkStackSidebar to the GtkStack.
//
// # CSS nodes
//
// GtkStackSidebar has a single CSS node with name stacksidebar and style class
// .sidebar.
//
// When circumstances require it, GtkStackSidebar adds the .needs-attention
// style class to the widgets representing the stack pages.
type StackSidebar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*StackSidebar)(nil)
)

func wrapStackSidebar(obj *coreglib.Object) *StackSidebar {
	return &StackSidebar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalStackSidebar(p uintptr) (interface{}, error) {
	return wrapStackSidebar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStackSidebar creates a new GtkStackSidebar.
//
// The function returns the following values:
//
//   - stackSidebar: new GtkStackSidebar.
func NewStackSidebar() *StackSidebar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_sidebar_new()

	var _stackSidebar *StackSidebar // out

	_stackSidebar = wrapStackSidebar(coreglib.Take(unsafe.Pointer(_cret)))

	return _stackSidebar
}

// Stack retrieves the stack.
//
// The function returns the following values:
//
//   - stack (optional): associated Stack or NULL if none has been set
//     explicitly.
func (self *StackSidebar) Stack() *Stack {
	var _arg0 *C.GtkStackSidebar // out
	var _cret *C.GtkStack        // in

	_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_stack_sidebar_get_stack(_arg0)
	runtime.KeepAlive(self)

	var _stack *Stack // out

	if _cret != nil {
		_stack = wrapStack(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _stack
}

// SetStack: set the GtkStack associated with this GtkStackSidebar.
//
// The sidebar widget will automatically update according to the order and items
// within the given GtkStack.
//
// The function takes the following parameters:
//
//   - stack: GtkStack.
func (self *StackSidebar) SetStack(stack *Stack) {
	var _arg0 *C.GtkStackSidebar // out
	var _arg1 *C.GtkStack        // out

	_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))

	C.gtk_stack_sidebar_set_stack(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(stack)
}

// StackSwitcher: GtkStackSwitcher shows a row of buttons to switch between
// GtkStack pages.
//
// !An example GtkStackSwitcher (stackswitcher.png)
//
// It acts as a controller for the associated GtkStack.
//
// All the content for the buttons comes from the properties of the stacks
// gtk.StackPage objects; the button visibility in a GtkStackSwitcher widget is
// controlled by the visibility of the child in the GtkStack.
//
// It is possible to associate multiple GtkStackSwitcher widgets with the same
// GtkStack widget.
//
// # CSS nodes
//
// GtkStackSwitcher has a single CSS node named stackswitcher and style class
// .stack-switcher.
//
// When circumstances require it, GtkStackSwitcher adds the .needs-attention
// style class to the widgets representing the stack pages.
//
// # Accessibility
//
// GtkStackSwitcher uses the GTK_ACCESSIBLE_ROLE_TAB_LIST role and uses the
// GTK_ACCESSIBLE_ROLE_TAB for its buttons.
type StackSwitcher struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*StackSwitcher)(nil)
)

func wrapStackSwitcher(obj *coreglib.Object) *StackSwitcher {
	return &StackSwitcher{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalStackSwitcher(p uintptr) (interface{}, error) {
	return wrapStackSwitcher(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStackSwitcher: create a new GtkStackSwitcher.
//
// The function returns the following values:
//
//   - stackSwitcher: new GtkStackSwitcher.
func NewStackSwitcher() *StackSwitcher {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_stack_switcher_new()

	var _stackSwitcher *StackSwitcher // out

	_stackSwitcher = wrapStackSwitcher(coreglib.Take(unsafe.Pointer(_cret)))

	return _stackSwitcher
}

// Stack retrieves the stack.
//
// The function returns the following values:
//
//   - stack (optional): stack, or NULL if none has been set explicitly.
func (switcher *StackSwitcher) Stack() *Stack {
	var _arg0 *C.GtkStackSwitcher // out
	var _cret *C.GtkStack         // in

	_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(coreglib.InternObject(switcher).Native()))

	_cret = C.gtk_stack_switcher_get_stack(_arg0)
	runtime.KeepAlive(switcher)

	var _stack *Stack // out

	if _cret != nil {
		_stack = wrapStack(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _stack
}

// SetStack sets the stack to control.
//
// The function takes the following parameters:
//
//   - stack (optional): GtkStack.
func (switcher *StackSwitcher) SetStack(stack *Stack) {
	var _arg0 *C.GtkStackSwitcher // out
	var _arg1 *C.GtkStack         // out

	_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(coreglib.InternObject(switcher).Native()))
	if stack != nil {
		_arg1 = (*C.GtkStack)(unsafe.Pointer(coreglib.InternObject(stack).Native()))
	}

	C.gtk_stack_switcher_set_stack(_arg0, _arg1)
	runtime.KeepAlive(switcher)
	runtime.KeepAlive(stack)
}

// Statusbar: GtkStatusbar widget is usually placed along the bottom of an
// application's main gtk.Window.
//
// !An example GtkStatusbar (statusbar.png)
//
// A GtkStatusBar may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
//
// Status bars in GTK maintain a stack of messages. The message at the top of
// the each bar’s stack is the one that will currently be displayed.
//
// Any messages added to a statusbar’s stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by gtk.Statusbar.GetContextID(), given a message and the statusbar
// that it will be added to. Note that messages are stored in a stack, and
// when choosing which message to display, the stack structure is adhered to,
// regardless of the context identifier of a message.
//
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
//
// Status bars are created using gtk.Statusbar.New.
//
// Messages are added to the bar’s stack with gtk.Statusbar.Push().
//
// The message at the top of the stack can be removed using gtk.Statusbar.Pop().
// A message can be removed from anywhere in the stack if its message id was
// recorded at the time it was added. This is done using gtk.Statusbar.Remove().
//
// # CSS node
//
// GtkStatusbar has a single CSS node with name statusbar.
type Statusbar struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Statusbar)(nil)
)

func wrapStatusbar(obj *coreglib.Object) *Statusbar {
	return &Statusbar{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalStatusbar(p uintptr) (interface{}, error) {
	return wrapStatusbar(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectTextPopped is emitted whenever a new message is popped off a
// statusbar's stack.
func (statusbar *Statusbar) ConnectTextPopped(f func(contextId uint, text string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusbar, "text-popped", false, unsafe.Pointer(C._gotk4_gtk4_Statusbar_ConnectTextPopped), f)
}

// ConnectTextPushed is emitted whenever a new message gets pushed onto a
// statusbar's stack.
func (statusbar *Statusbar) ConnectTextPushed(f func(contextId uint, text string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(statusbar, "text-pushed", false, unsafe.Pointer(C._gotk4_gtk4_Statusbar_ConnectTextPushed), f)
}

// NewStatusbar creates a new GtkStatusbar ready for messages.
//
// The function returns the following values:
//
//   - statusbar: new GtkStatusbar.
func NewStatusbar() *Statusbar {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_statusbar_new()

	var _statusbar *Statusbar // out

	_statusbar = wrapStatusbar(coreglib.Take(unsafe.Pointer(_cret)))

	return _statusbar
}

// ContextID returns a new context identifier, given a description of the actual
// context.
//
// Note that the description is not shown in the UI.
//
// The function takes the following parameters:
//
//   - contextDescription: textual description of what context the new message
//     is being used in.
//
// The function returns the following values:
//
//   - guint: integer id.
func (statusbar *Statusbar) ContextID(contextDescription string) uint {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 *C.char         // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(coreglib.InternObject(statusbar).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(contextDescription)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_statusbar_get_context_id(_arg0, _arg1)
	runtime.KeepAlive(statusbar)
	runtime.KeepAlive(contextDescription)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Pop removes the first message in the GtkStatusbar’s stack with the given
// context id.
//
// Note that this may not change the displayed message, if the message at the
// top of the stack has a different context id.
//
// The function takes the following parameters:
//
//   - contextId: context identifier.
func (statusbar *Statusbar) Pop(contextId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(coreglib.InternObject(statusbar).Native()))
	_arg1 = C.guint(contextId)

	C.gtk_statusbar_pop(_arg0, _arg1)
	runtime.KeepAlive(statusbar)
	runtime.KeepAlive(contextId)
}

// Push pushes a new message onto a statusbar’s stack.
//
// The function takes the following parameters:
//
//   - contextId message’s context id, as returned by
//     gtk_statusbar_get_context_id().
//   - text: message to add to the statusbar.
//
// The function returns the following values:
//
//   - guint: message id that can be used with gtk.Statusbar.Remove().
func (statusbar *Statusbar) Push(contextId uint, text string) uint {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out
	var _arg2 *C.char         // out
	var _cret C.guint         // in

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(coreglib.InternObject(statusbar).Native()))
	_arg1 = C.guint(contextId)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_statusbar_push(_arg0, _arg1, _arg2)
	runtime.KeepAlive(statusbar)
	runtime.KeepAlive(contextId)
	runtime.KeepAlive(text)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Remove forces the removal of a message from a statusbar’s stack. The exact
// context_id and message_id must be specified.
//
// The function takes the following parameters:
//
//   - contextId: context identifier.
//   - messageId: message identifier, as returned by gtk.Statusbar.Push().
func (statusbar *Statusbar) Remove(contextId, messageId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out
	var _arg2 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(coreglib.InternObject(statusbar).Native()))
	_arg1 = C.guint(contextId)
	_arg2 = C.guint(messageId)

	C.gtk_statusbar_remove(_arg0, _arg1, _arg2)
	runtime.KeepAlive(statusbar)
	runtime.KeepAlive(contextId)
	runtime.KeepAlive(messageId)
}

// RemoveAll forces the removal of all messages from a statusbar's stack with
// the exact context_id.
//
// The function takes the following parameters:
//
//   - contextId: context identifier.
func (statusbar *Statusbar) RemoveAll(contextId uint) {
	var _arg0 *C.GtkStatusbar // out
	var _arg1 C.guint         // out

	_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(coreglib.InternObject(statusbar).Native()))
	_arg1 = C.guint(contextId)

	C.gtk_statusbar_remove_all(_arg0, _arg1)
	runtime.KeepAlive(statusbar)
	runtime.KeepAlive(contextId)
}

// StringFilterOverrides contains methods that are overridable.
type StringFilterOverrides struct {
}

func defaultStringFilterOverrides(v *StringFilter) StringFilterOverrides {
	return StringFilterOverrides{}
}

// StringFilter: GtkStringFilter determines whether to include items by
// comparing strings to a fixed search term.
//
// The strings are obtained from the items by evaluating a GtkExpression set
// with gtk.StringFilter.SetExpression(), and they are compared against a search
// term set with gtk.StringFilter.SetSearch().
//
// GtkStringFilter has several different modes of comparison - it
// can match the whole string, just a prefix, or any substring. Use
// gtk.StringFilter.SetMatchMode() choose a mode.
//
// It is also possible to make case-insensitive comparisons, with
// gtk.StringFilter.SetIgnoreCase().
type StringFilter struct {
	_ [0]func() // equal guard
	Filter
}

var (
	_ coreglib.Objector = (*StringFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StringFilter, *StringFilterClass, StringFilterOverrides](
		GTypeStringFilter,
		initStringFilterClass,
		wrapStringFilter,
		defaultStringFilterOverrides,
	)
}

func initStringFilterClass(gclass unsafe.Pointer, overrides StringFilterOverrides, classInitFunc func(*StringFilterClass)) {
	if classInitFunc != nil {
		class := (*StringFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStringFilter(obj *coreglib.Object) *StringFilter {
	return &StringFilter{
		Filter: Filter{
			Object: obj,
		},
	}
}

func marshalStringFilter(p uintptr) (interface{}, error) {
	return wrapStringFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStringFilter creates a new string filter.
//
// You will want to set up the filter by providing a string to search for and by
// providing a property to look up on the item.
//
// The function takes the following parameters:
//
//   - expression (optional) to evaluate or NULL for none.
//
// The function returns the following values:
//
//   - stringFilter: new GtkStringFilter.
func NewStringFilter(expression Expressioner) *StringFilter {
	var _arg1 *C.GtkExpression   // out
	var _cret *C.GtkStringFilter // in

	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}

	_cret = C.gtk_string_filter_new(_arg1)
	runtime.KeepAlive(expression)

	var _stringFilter *StringFilter // out

	_stringFilter = wrapStringFilter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stringFilter
}

// Expression gets the expression that the string filter uses to obtain strings
// from items.
//
// The function returns the following values:
//
//   - expression (optional): GtkExpression.
func (self *StringFilter) Expression() Expressioner {
	var _arg0 *C.GtkStringFilter // out
	var _cret *C.GtkExpression   // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_string_filter_get_expression(_arg0)
	runtime.KeepAlive(self)

	var _expression Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// IgnoreCase returns whether the filter ignores case differences.
//
// The function returns the following values:
//
//   - ok: TRUE if the filter ignores case.
func (self *StringFilter) IgnoreCase() bool {
	var _arg0 *C.GtkStringFilter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_string_filter_get_ignore_case(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MatchMode returns the match mode that the filter is using.
//
// The function returns the following values:
//
//   - stringFilterMatchMode: match mode of the filter.
func (self *StringFilter) MatchMode() StringFilterMatchMode {
	var _arg0 *C.GtkStringFilter         // out
	var _cret C.GtkStringFilterMatchMode // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_string_filter_get_match_mode(_arg0)
	runtime.KeepAlive(self)

	var _stringFilterMatchMode StringFilterMatchMode // out

	_stringFilterMatchMode = StringFilterMatchMode(_cret)

	return _stringFilterMatchMode
}

// Search gets the search term.
//
// The function returns the following values:
//
//   - utf8 (optional): search term.
func (self *StringFilter) Search() string {
	var _arg0 *C.GtkStringFilter // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_string_filter_get_search(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// SetExpression sets the expression that the string filter uses to obtain
// strings from items.
//
// The expression must have a value type of G_TYPE_STRING.
//
// The function takes the following parameters:
//
//   - expression (optional): GtkExpression.
func (self *StringFilter) SetExpression(expression Expressioner) {
	var _arg0 *C.GtkStringFilter // out
	var _arg1 *C.GtkExpression   // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
	}

	C.gtk_string_filter_set_expression(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expression)
}

// SetIgnoreCase sets whether the filter ignores case differences.
//
// The function takes the following parameters:
//
//   - ignoreCase: TRUE to ignore case.
func (self *StringFilter) SetIgnoreCase(ignoreCase bool) {
	var _arg0 *C.GtkStringFilter // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if ignoreCase {
		_arg1 = C.TRUE
	}

	C.gtk_string_filter_set_ignore_case(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ignoreCase)
}

// SetMatchMode sets the match mode for the filter.
//
// The function takes the following parameters:
//
//   - mode: new match mode.
func (self *StringFilter) SetMatchMode(mode StringFilterMatchMode) {
	var _arg0 *C.GtkStringFilter         // out
	var _arg1 C.GtkStringFilterMatchMode // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkStringFilterMatchMode(mode)

	C.gtk_string_filter_set_match_mode(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(mode)
}

// SetSearch sets the string to search for.
//
// The function takes the following parameters:
//
//   - search (optional): string to search for or NULL to clear the search.
func (self *StringFilter) SetSearch(search string) {
	var _arg0 *C.GtkStringFilter // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if search != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(search)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_string_filter_set_search(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(search)
}

// StringListOverrides contains methods that are overridable.
type StringListOverrides struct {
}

func defaultStringListOverrides(v *StringList) StringListOverrides {
	return StringListOverrides{}
}

// StringList: GtkStringList is a list model that wraps an array of strings.
//
// The objects in the model have a "string" property.
//
// GtkStringList is well-suited for any place where you would typically use a
// char*[], but need a list model.
//
// # GtkStringList as GtkBuildable
//
// The GtkStringList implementation of the GtkBuildable interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element supports the regular translation
// attributes “translatable”, “context” and “comments”.
//
// Here is a UI definition fragment specifying a GtkStringList
//
//	<object class="GtkStringList">
//	  <items>
//	    <item translatable="yes">Factory</item>
//	    <item translatable="yes">Home</item>
//	    <item translatable="yes">Subway</item>
//	  </items>
//	</object>.
type StringList struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
	Buildable
}

var (
	_ coreglib.Objector = (*StringList)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StringList, *StringListClass, StringListOverrides](
		GTypeStringList,
		initStringListClass,
		wrapStringList,
		defaultStringListOverrides,
	)
}

func initStringListClass(gclass unsafe.Pointer, overrides StringListOverrides, classInitFunc func(*StringListClass)) {
	if classInitFunc != nil {
		class := (*StringListClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStringList(obj *coreglib.Object) *StringList {
	return &StringList{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalStringList(p uintptr) (interface{}, error) {
	return wrapStringList(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStringList creates a new GtkStringList with the given strings.
//
// The function takes the following parameters:
//
//   - strings (optional) to put in the model.
//
// The function returns the following values:
//
//   - stringList: new GtkStringList.
func NewStringList(strings []string) *StringList {
	var _arg1 **C.char         // out
	var _cret *C.GtkStringList // in

	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(strings) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(strings)+1)
			var zero *C.char
			out[len(strings)] = zero
			for i := range strings {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(strings[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	_cret = C.gtk_string_list_new(_arg1)
	runtime.KeepAlive(strings)

	var _stringList *StringList // out

	_stringList = wrapStringList(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stringList
}

// Append appends string to self.
//
// The string will be copied. See gtk.StringList.Take() for a way to avoid that.
//
// The function takes the following parameters:
//
//   - str: string to insert.
func (self *StringList) Append(str string) {
	var _arg0 *C.GtkStringList // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkStringList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_string_list_append(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// String gets the string that is at position in self.
//
// If self does not contain position items, NULL is returned.
//
// This function returns the const char *. To get the object wrapping it,
// use g_list_model_get_item().
//
// The function takes the following parameters:
//
//   - position to get the string for.
//
// The function returns the following values:
//
//   - utf8 (optional): string at the given position.
func (self *StringList) String(position uint) string {
	var _arg0 *C.GtkStringList // out
	var _arg1 C.guint          // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkStringList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	_cret = C.gtk_string_list_get_string(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Remove removes the string at position from self.
//
// position must be smaller than the current length of the list.
//
// The function takes the following parameters:
//
//   - position of the string that is to be removed.
func (self *StringList) Remove(position uint) {
	var _arg0 *C.GtkStringList // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkStringList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	C.gtk_string_list_remove(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
}

// Splice changes self by removing n_removals strings and adding additions to
// it.
//
// This function is more efficient than gtk.StringList.Append() and
// gtk.StringList.Remove(), because it only emits the ::items-changed signal
// once for the change.
//
// This function copies the strings in additions.
//
// The parameters position and n_removals must be correct (ie: position +
// n_removals must be less than or equal to the length of the list at the time
// this function is called).
//
// The function takes the following parameters:
//
//   - position at which to make the change.
//   - nRemovals: number of strings to remove.
//   - additions (optional) strings to add.
func (self *StringList) Splice(position, nRemovals uint, additions []string) {
	var _arg0 *C.GtkStringList // out
	var _arg1 C.guint          // out
	var _arg2 C.guint          // out
	var _arg3 **C.char         // out

	_arg0 = (*C.GtkStringList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)
	_arg2 = C.guint(nRemovals)
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(additions) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(additions)+1)
			var zero *C.char
			out[len(additions)] = zero
			for i := range additions {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(additions[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_string_list_splice(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
	runtime.KeepAlive(nRemovals)
	runtime.KeepAlive(additions)
}

// Take adds string to self at the end, and takes ownership of it.
//
// This variant of gtk.StringList.Append() is convenient for formatting strings:
//
//	gtk_string_list_take (self, g_strdup_print ("d dollars", lots));.
//
// The function takes the following parameters:
//
//   - str: string to insert.
func (self *StringList) Take(str string) {
	var _arg0 *C.GtkStringList // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkStringList)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))

	C.gtk_string_list_take(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(str)
}

// StringObjectOverrides contains methods that are overridable.
type StringObjectOverrides struct {
}

func defaultStringObjectOverrides(v *StringObject) StringObjectOverrides {
	return StringObjectOverrides{}
}

// StringObject: GtkStringObject is the type of items in a GtkStringList.
//
// A GtkStringObject is a wrapper around a const char*; it has a
// gtk.StringObject:string property.
type StringObject struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StringObject)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StringObject, *StringObjectClass, StringObjectOverrides](
		GTypeStringObject,
		initStringObjectClass,
		wrapStringObject,
		defaultStringObjectOverrides,
	)
}

func initStringObjectClass(gclass unsafe.Pointer, overrides StringObjectOverrides, classInitFunc func(*StringObjectClass)) {
	if classInitFunc != nil {
		class := (*StringObjectClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStringObject(obj *coreglib.Object) *StringObject {
	return &StringObject{
		Object: obj,
	}
}

func marshalStringObject(p uintptr) (interface{}, error) {
	return wrapStringObject(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStringObject wraps a string in an object for use with GListModel.
//
// The function takes the following parameters:
//
//   - str: string to wrap.
//
// The function returns the following values:
//
//   - stringObject: new GtkStringObject.
func NewStringObject(str string) *StringObject {
	var _arg1 *C.char            // out
	var _cret *C.GtkStringObject // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_string_object_new(_arg1)
	runtime.KeepAlive(str)

	var _stringObject *StringObject // out

	_stringObject = wrapStringObject(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stringObject
}

// String returns the string contained in a GtkStringObject.
//
// The function returns the following values:
//
//   - utf8: string of self.
func (self *StringObject) String() string {
	var _arg0 *C.GtkStringObject // out
	var _cret *C.char            // in

	_arg0 = (*C.GtkStringObject)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_string_object_get_string(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// StringSorterOverrides contains methods that are overridable.
type StringSorterOverrides struct {
}

func defaultStringSorterOverrides(v *StringSorter) StringSorterOverrides {
	return StringSorterOverrides{}
}

// StringSorter: GtkStringSorter is a GtkSorter that compares strings.
//
// It does the comparison in a linguistically correct way using the current
// locale by normalizing Unicode strings and possibly case-folding them before
// performing the comparison.
//
// To obtain the strings to compare, this sorter evaluates a gtk.Expression.
type StringSorter struct {
	_ [0]func() // equal guard
	Sorter
}

var (
	_ coreglib.Objector = (*StringSorter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StringSorter, *StringSorterClass, StringSorterOverrides](
		GTypeStringSorter,
		initStringSorterClass,
		wrapStringSorter,
		defaultStringSorterOverrides,
	)
}

func initStringSorterClass(gclass unsafe.Pointer, overrides StringSorterOverrides, classInitFunc func(*StringSorterClass)) {
	if classInitFunc != nil {
		class := (*StringSorterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStringSorter(obj *coreglib.Object) *StringSorter {
	return &StringSorter{
		Sorter: Sorter{
			Object: obj,
		},
	}
}

func marshalStringSorter(p uintptr) (interface{}, error) {
	return wrapStringSorter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewStringSorter creates a new string sorter that compares items using the
// given expression.
//
// Unless an expression is set on it, this sorter will always compare items as
// invalid.
//
// The function takes the following parameters:
//
//   - expression (optional) to evaluate.
//
// The function returns the following values:
//
//   - stringSorter: new GtkStringSorter.
func NewStringSorter(expression Expressioner) *StringSorter {
	var _arg1 *C.GtkExpression   // out
	var _cret *C.GtkStringSorter // in

	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(expression).Native()))
	}

	_cret = C.gtk_string_sorter_new(_arg1)
	runtime.KeepAlive(expression)

	var _stringSorter *StringSorter // out

	_stringSorter = wrapStringSorter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _stringSorter
}

// Expression gets the expression that is evaluated to obtain strings from
// items.
//
// The function returns the following values:
//
//   - expression (optional): GtkExpression, or NULL.
func (self *StringSorter) Expression() Expressioner {
	var _arg0 *C.GtkStringSorter // out
	var _cret *C.GtkExpression   // in

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_string_sorter_get_expression(_arg0)
	runtime.KeepAlive(self)

	var _expression Expressioner // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Expressioner)
				return ok
			})
			rv, ok := casted.(Expressioner)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Expressioner")
			}
			_expression = rv
		}
	}

	return _expression
}

// IgnoreCase gets whether the sorter ignores case differences.
//
// The function returns the following values:
//
//   - ok: TRUE if self is ignoring case differences.
func (self *StringSorter) IgnoreCase() bool {
	var _arg0 *C.GtkStringSorter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_string_sorter_get_ignore_case(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetExpression sets the expression that is evaluated to obtain strings from
// items.
//
// The expression must have the type G_TYPE_STRING.
//
// The function takes the following parameters:
//
//   - expression (optional): GtkExpression, or NULL.
func (self *StringSorter) SetExpression(expression Expressioner) {
	var _arg0 *C.GtkStringSorter // out
	var _arg1 *C.GtkExpression   // out

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expression != nil {
		_arg1 = (*C.GtkExpression)(unsafe.Pointer(coreglib.InternObject(expression).Native()))
	}

	C.gtk_string_sorter_set_expression(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expression)
}

// SetIgnoreCase sets whether the sorter will ignore case differences.
//
// The function takes the following parameters:
//
//   - ignoreCase: TRUE to ignore case differences.
func (self *StringSorter) SetIgnoreCase(ignoreCase bool) {
	var _arg0 *C.GtkStringSorter // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if ignoreCase {
		_arg1 = C.TRUE
	}

	C.gtk_string_sorter_set_ignore_case(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ignoreCase)
}

// StyleContextOverrides contains methods that are overridable.
type StyleContextOverrides struct {
	Changed func()
}

func defaultStyleContextOverrides(v *StyleContext) StyleContextOverrides {
	return StyleContextOverrides{
		Changed: v.changed,
	}
}

// StyleContext: GtkStyleContext stores styling information affecting a widget.
//
// In order to construct the final style information, GtkStyleContext
// queries information from all attached GtkStyleProviders.
// Style providers can be either attached explicitly to the context
// through gtk.StyleContext.AddProvider(), or to the display through
// gtk.StyleContext().AddProviderForDisplay. The resulting style is a
// combination of all providers’ information in priority order.
//
// For GTK widgets, any GtkStyleContext returned by gtk.Widget.GetStyleContext()
// will already have a GdkDisplay and RTL/LTR information set. The style context
// will also be updated automatically if any of these settings change on the
// widget.
//
// # Style Classes
//
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
//
// # Custom styling in UI libraries and applications
//
// If you are developing a library with custom widgets that render differently
// than standard components, you may need to add a GtkStyleProvider
// yourself with the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either
// a GtkCssProvider or a custom object implementing the GtkStyleProvider
// interface. This way themes may still attempt to style your UI elements in a
// different way if needed so.
//
// If you are using custom styling on an applications, you probably want then
// to make your style information prevail to the theme’s, so you must use a
// GtkStyleProvider with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority,
// keep in mind that the user settings in XDG_CONFIG_HOME/gtk-4.0/gtk.css
// will still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
type StyleContext struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*StyleContext)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*StyleContext, *StyleContextClass, StyleContextOverrides](
		GTypeStyleContext,
		initStyleContextClass,
		wrapStyleContext,
		defaultStyleContextOverrides,
	)
}

func initStyleContextClass(gclass unsafe.Pointer, overrides StyleContextOverrides, classInitFunc func(*StyleContextClass)) {
	pclass := (*C.GtkStyleContextClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeStyleContext))))

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gtk4_StyleContextClass_changed)
	}

	if classInitFunc != nil {
		class := (*StyleContextClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapStyleContext(obj *coreglib.Object) *StyleContext {
	return &StyleContext{
		Object: obj,
	}
}

func marshalStyleContext(p uintptr) (interface{}, error) {
	return wrapStyleContext(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// AddClass adds a style class to context, so later uses of the style context
// will make use of this new class for styling.
//
// In the CSS file format, a GtkEntry defining a “search” class, would be
// matched by:
//
//	entry.search { ... }
//
// While any widget defining a “search” class would be matched by:
//
//	.search { ... }.
//
// The function takes the following parameters:
//
//   - className class name to use in styling.
func (context *StyleContext) AddClass(className string) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(className)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_style_context_add_class(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(className)
}

// AddProvider adds a style provider to context, to be used in style
// construction.
//
// Note that a style provider added by this function only affects the style of
// the widget to which context belongs. If you want to affect the style of all
// widgets, use gtk.StyleContext().AddProviderForDisplay.
//
// Note: If both priorities are the same, a GtkStyleProvider added
// through this function takes precedence over another added through
// gtk.StyleContext().AddProviderForDisplay.
//
// The function takes the following parameters:
//
//   - provider: GtkStyleProvider.
//   - priority of the style provider. The lower it is, the earlier it
//     will be used in the style construction. Typically this will be
//     in the range between GTK_STYLE_PROVIDER_PRIORITY_FALLBACK and
//     GTK_STYLE_PROVIDER_PRIORITY_USER.
func (context *StyleContext) AddProvider(provider StyleProviderer, priority uint) {
	var _arg0 *C.GtkStyleContext  // out
	var _arg1 *C.GtkStyleProvider // out
	var _arg2 C.guint             // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg2 = C.guint(priority)

	C.gtk_style_context_add_provider(_arg0, _arg1, _arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(priority)
}

// Border gets the border for a given state as a GtkBorder.
//
// The function returns the following values:
//
//   - border: return value for the border settings.
func (context *StyleContext) Border() *Border {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkBorder        // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_style_context_get_border(_arg0, &_arg1)
	runtime.KeepAlive(context)

	var _border *Border // out

	_border = (*Border)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _border
}

// Color gets the foreground color for a given state.
//
// The function returns the following values:
//
//   - color: return value for the foreground color.
func (context *StyleContext) Color() *gdk.RGBA {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GdkRGBA          // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_style_context_get_color(_arg0, &_arg1)
	runtime.KeepAlive(context)

	var _color *gdk.RGBA // out

	_color = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _color
}

// Display returns the GdkDisplay to which context is attached.
//
// The function returns the following values:
//
//   - display: GdkDisplay.
func (context *StyleContext) Display() *gdk.Display {
	var _arg0 *C.GtkStyleContext // out
	var _cret *C.GdkDisplay      // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_style_context_get_display(_arg0)
	runtime.KeepAlive(context)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// Margin gets the margin for a given state as a GtkBorder.
//
// The function returns the following values:
//
//   - margin: return value for the margin settings.
func (context *StyleContext) Margin() *Border {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkBorder        // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_style_context_get_margin(_arg0, &_arg1)
	runtime.KeepAlive(context)

	var _margin *Border // out

	_margin = (*Border)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _margin
}

// Padding gets the padding for a given state as a GtkBorder.
//
// The function returns the following values:
//
//   - padding: return value for the padding settings.
func (context *StyleContext) Padding() *Border {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkBorder        // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_style_context_get_padding(_arg0, &_arg1)
	runtime.KeepAlive(context)

	var _padding *Border // out

	_padding = (*Border)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _padding
}

// Scale returns the scale used for assets.
//
// The function returns the following values:
//
//   - gint: scale.
func (context *StyleContext) Scale() int {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.int              // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_style_context_get_scale(_arg0)
	runtime.KeepAlive(context)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// State returns the state used for style matching.
//
// This method should only be used to retrieve the GtkStateFlags to pass to
// GtkStyleContext methods, like gtk.StyleContext.GetPadding(). If you need to
// retrieve the current state of a GtkWidget, use gtk.Widget.GetStateFlags().
//
// The function returns the following values:
//
//   - stateFlags: state flags.
func (context *StyleContext) State() StateFlags {
	var _arg0 *C.GtkStyleContext // out
	var _cret C.GtkStateFlags    // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	_cret = C.gtk_style_context_get_state(_arg0)
	runtime.KeepAlive(context)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// HasClass returns TRUE if context currently has defined the given class name.
//
// The function takes the following parameters:
//
//   - className class name.
//
// The function returns the following values:
//
//   - ok: TRUE if context has class_name defined.
func (context *StyleContext) HasClass(className string) bool {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(className)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_has_class(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(className)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LookupColor looks up and resolves a color name in the context color map.
//
// The function takes the following parameters:
//
//   - colorName: color name to lookup.
//
// The function returns the following values:
//
//   - color: return location for the looked up color.
//   - ok: TRUE if color_name was found and resolved, FALSE otherwise.
func (context *StyleContext) LookupColor(colorName string) (*gdk.RGBA, bool) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out
	var _arg2 C.GdkRGBA          // in
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(colorName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_style_context_lookup_color(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(context)
	runtime.KeepAlive(colorName)

	var _color *gdk.RGBA // out
	var _ok bool         // out

	_color = (*gdk.RGBA)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _color, _ok
}

// RemoveClass removes class_name from context.
//
// The function takes the following parameters:
//
//   - className class name to remove.
func (context *StyleContext) RemoveClass(className string) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.char            // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(className)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_style_context_remove_class(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(className)
}

// RemoveProvider removes provider from the style providers list in context.
//
// The function takes the following parameters:
//
//   - provider: GtkStyleProvider.
func (context *StyleContext) RemoveProvider(provider StyleProviderer) {
	var _arg0 *C.GtkStyleContext  // out
	var _arg1 *C.GtkStyleProvider // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C.gtk_style_context_remove_provider(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(provider)
}

// Restore restores context state to a previous stage.
//
// See gtk.StyleContext.Save().
func (context *StyleContext) Restore() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_style_context_restore(_arg0)
	runtime.KeepAlive(context)
}

// Save saves the context state.
//
// This allows temporary modifications done through gtk.StyleContext.AddClass(),
// gtk.StyleContext.RemoveClass(), gtk.StyleContext.SetState() to be quickly
// reverted in one go through gtk.StyleContext.Restore().
//
// The matching call to gtk.StyleContext.Restore() must be done before GTK
// returns to the main loop.
func (context *StyleContext) Save() {
	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C.gtk_style_context_save(_arg0)
	runtime.KeepAlive(context)
}

// SetDisplay attaches context to the given display.
//
// The display is used to add style information from “global” style providers,
// such as the display's GtkSettings instance.
//
// If you are using a GtkStyleContext returned from
// gtk.Widget.GetStyleContext(), you do not need to call this yourself.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
func (context *StyleContext) SetDisplay(display *gdk.Display) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 *C.GdkDisplay      // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gtk_style_context_set_display(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(display)
}

// SetScale sets the scale to use when getting image assets for the style.
//
// The function takes the following parameters:
//
//   - scale: scale.
func (context *StyleContext) SetScale(scale int) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.int              // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.int(scale)

	C.gtk_style_context_set_scale(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(scale)
}

// SetState sets the state to be used for style matching.
//
// The function takes the following parameters:
//
//   - flags: state to represent.
func (context *StyleContext) SetState(flags StateFlags) {
	var _arg0 *C.GtkStyleContext // out
	var _arg1 C.GtkStateFlags    // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GtkStateFlags(flags)

	C.gtk_style_context_set_state(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)
}

// String converts the style context into a string representation.
//
// The string representation always includes information about the name, state,
// id, visibility and style classes of the CSS node that is backing context.
// Depending on the flags, more information may be included.
//
// This function is intended for testing and debugging of the CSS implementation
// in GTK. There are no guarantees about the format of the returned string,
// it may change.
//
// The function takes the following parameters:
//
//   - flags flags that determine what to print.
//
// The function returns the following values:
//
//   - utf8: newly allocated string representing context.
func (context *StyleContext) String(flags StyleContextPrintFlags) string {
	var _arg0 *C.GtkStyleContext          // out
	var _arg1 C.GtkStyleContextPrintFlags // out
	var _cret *C.char                     // in

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))
	_arg1 = C.GtkStyleContextPrintFlags(flags)

	_cret = C.gtk_style_context_to_string(_arg0, _arg1)
	runtime.KeepAlive(context)
	runtime.KeepAlive(flags)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

func (context *StyleContext) changed() {
	gclass := (*C.GtkStyleContextClass)(coreglib.PeekParentClass(context))
	fnarg := gclass.changed

	var _arg0 *C.GtkStyleContext // out

	_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(coreglib.InternObject(context).Native()))

	C._gotk4_gtk4_StyleContext_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(context)
}

// StyleContextAddProviderForDisplay adds a global style provider to display,
// which will be used in style construction for all GtkStyleContexts under
// display.
//
// GTK uses this to make styling information from GtkSettings available.
//
// Note: If both priorities are the same, A GtkStyleProvider added through
// gtk.StyleContext.AddProvider() takes precedence over another added through
// this function.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
//   - provider: GtkStyleProvider.
//   - priority of the style provider. The lower it is, the earlier it
//     will be used in the style construction. Typically this will be
//     in the range between GTK_STYLE_PROVIDER_PRIORITY_FALLBACK and
//     GTK_STYLE_PROVIDER_PRIORITY_USER.
func StyleContextAddProviderForDisplay(display *gdk.Display, provider StyleProviderer, priority uint) {
	var _arg1 *C.GdkDisplay       // out
	var _arg2 *C.GtkStyleProvider // out
	var _arg3 C.guint             // out

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg2 = (*C.GtkStyleProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))
	_arg3 = C.guint(priority)

	C.gtk_style_context_add_provider_for_display(_arg1, _arg2, _arg3)
	runtime.KeepAlive(display)
	runtime.KeepAlive(provider)
	runtime.KeepAlive(priority)
}

// StyleContextRemoveProviderForDisplay removes provider from the global style
// providers list in display.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
//   - provider: GtkStyleProvider.
func StyleContextRemoveProviderForDisplay(display *gdk.Display, provider StyleProviderer) {
	var _arg1 *C.GdkDisplay       // out
	var _arg2 *C.GtkStyleProvider // out

	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))
	_arg2 = (*C.GtkStyleProvider)(unsafe.Pointer(coreglib.InternObject(provider).Native()))

	C.gtk_style_context_remove_provider_for_display(_arg1, _arg2)
	runtime.KeepAlive(display)
	runtime.KeepAlive(provider)
}

// Switch: GtkSwitch is a "light switch" that has two states: on or off.
//
// !An example GtkSwitch (switch.png)
//
// The user can control which state should be active by clicking the empty area,
// or by dragging the handle.
//
// GtkSwitch can also handle situations where the underlying state changes with
// a delay. See gtkswitch::state-set for details.
//
// CSS nodes
//
//	switch
//	├── label
//	├── label
//	╰── slider
//
// GtkSwitch has four css nodes, the main node with the name switch and subnodes
// for the slider and the on and off labels. Neither of them is using any style
// classes.
//
// # Accessibility
//
// GtkSwitch uses the GTK_ACCESSIBLE_ROLE_SWITCH role.
type Switch struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Actionable
}

var (
	_ Widgetter         = (*Switch)(nil)
	_ coreglib.Objector = (*Switch)(nil)
)

func wrapSwitch(obj *coreglib.Object) *Switch {
	return &Switch{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Actionable: Actionable{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalSwitch(p uintptr) (interface{}, error) {
	return wrapSwitch(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted to animate the switch.
//
// Applications should never connect to this signal, but use the
// gtk.Switch:active property.
func (self *Switch) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate", false, unsafe.Pointer(C._gotk4_gtk4_Switch_ConnectActivate), f)
}

// ConnectStateSet is emitted to change the underlying state.
//
// The ::state-set signal is emitted when the user changes the switch position.
// The default handler keeps the state in sync with the gtk.Switch:active
// property.
//
// To implement delayed state change, applications can connect to this signal,
// initiate the change of the underlying state, and call gtk.Switch.SetState()
// when the underlying state change is complete. The signal handler should
// return TRUE to prevent the default handler from running.
//
// Visually, the underlying state is represented by the trough color of the
// switch, while the gtk.Switch`:active property is represented by the position
// of the switch.
func (self *Switch) ConnectStateSet(f func(state bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "state-set", false, unsafe.Pointer(C._gotk4_gtk4_Switch_ConnectStateSet), f)
}

// NewSwitch creates a new GtkSwitch widget.
//
// The function returns the following values:
//
//   - _switch: newly created GtkSwitch instance.
func NewSwitch() *Switch {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_switch_new()

	var __switch *Switch // out

	__switch = wrapSwitch(coreglib.Take(unsafe.Pointer(_cret)))

	return __switch
}

// Active gets whether the GtkSwitch is in its “on” or “off” state.
//
// The function returns the following values:
//
//   - ok: TRUE if the GtkSwitch is active, and FALSE otherwise.
func (self *Switch) Active() bool {
	var _arg0 *C.GtkSwitch // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_switch_get_active(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// State gets the underlying state of the GtkSwitch.
//
// The function returns the following values:
//
//   - ok: underlying state.
func (self *Switch) State() bool {
	var _arg0 *C.GtkSwitch // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_switch_get_state(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive changes the state of self to the desired one.
//
// The function takes the following parameters:
//
//   - isActive: TRUE if self should be active, and FALSE otherwise.
func (self *Switch) SetActive(isActive bool) {
	var _arg0 *C.GtkSwitch // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_switch_set_active(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(isActive)
}

// SetState sets the underlying state of the GtkSwitch.
//
// Normally, this is the same as gtk.Switch:active, unless the switch is set
// up for delayed state changes. This function is typically called from a
// gtk.Switch`::state-set signal handler.
//
// See gtk.Switch::state-set for details.
//
// The function takes the following parameters:
//
//   - state: new state.
func (self *Switch) SetState(state bool) {
	var _arg0 *C.GtkSwitch // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkSwitch)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if state {
		_arg1 = C.TRUE
	}

	C.gtk_switch_set_state(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(state)
}

// Text: GtkText widget is a single-line text entry widget.
//
// GtkText is the common implementation of single-line text editing that is
// shared between GtkEntry, GtkPasswordEntry, GtkSpinButton and other widgets.
// In all of these, GtkText` is used as the delegate for the gtk.Editable
// implementation.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can
// be put into “password mode” using gtk.Text.SetVisibility(). In this mode,
// entered text is displayed using a “invisible” character. By default,
// GTK picks the best invisible character that is available in the current font,
// but it can be changed with gtk.Text.SetInvisibleChar().
//
// If you are looking to add icons or progress display in an entry, look at
// GtkEntry. There other alternatives for more specialized use cases, such as
// GtkSearchEntry.
//
// If you need multi-line editable text, look at GtkTextView.
//
// CSS nodes
//
//	text[.read-only]
//	├── placeholder
//	├── undershoot.left
//	├── undershoot.right
//	├── [selection]
//	├── [block-cursor]
//	╰── [window.popup]
//
// GtkText has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using
// CSS nodes with name cursor-handle. They get the .top or .bottom style
// class depending on where they are shown in relation to the selection.
// If there is just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
// # Accessibility
//
// GtkText uses the GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be
// skipped for accessibility. This is because GtkText is expected to be used
// as a delegate for a GtkEditable implementation that will be represented to
// accessibility.
type Text struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	EditableTextWidget
}

var (
	_ Widgetter         = (*Text)(nil)
	_ coreglib.Objector = (*Text)(nil)
)

func wrapText(obj *coreglib.Object) *Text {
	return &Text{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		EditableTextWidget: EditableTextWidget{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalText(p uintptr) (interface{}, error) {
	return wrapText(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivate is emitted when the user hits the Enter key.
//
// The default bindings for this signal are all forms of the <kbd>Enter</kbd>
// key.
func (self *Text) ConnectActivate(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "activate", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectActivate), f)
}

// ConnectBackspace is emitted when the user asks for it.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Backspace</kbd> and
// <kbd>Shift</kbd>-<kbd>Backspace</kbd>.
func (self *Text) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "backspace", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectBackspace), f)
}

// ConnectCopyClipboard is emitted to copy the selection to the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>c</kbd> and
// <kbd>Ctrl</kbd>-<kbd>Insert</kbd>.
func (self *Text) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectCopyClipboard), f)
}

// ConnectCutClipboard is emitted to cut the selection to the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>x</kbd> and
// <kbd>Shift</kbd>-<kbd>Delete</kbd>.
func (self *Text) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectCutClipboard), f)
}

// ConnectDeleteFromCursor is emitted when the user initiates a text deletion.
//
// This is a keybinding signal (class.SignalAction.html).
//
// If the type is GTK_DELETE_CHARS, GTK deletes the selection if there is one,
// otherwise it deletes the requested number of characters.
//
// The default bindings for this signal are <kbd>Delete</kbd> for deleting a
// character and <kbd>Ctrl</kbd>-<kbd>Delete</kbd> for deleting a word.
func (self *Text) ConnectDeleteFromCursor(f func(typ DeleteType, count int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "delete-from-cursor", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectDeleteFromCursor), f)
}

// ConnectInsertAtCursor is emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// This is a keybinding signal (class.SignalAction.html).
//
// This signal has no default bindings.
func (self *Text) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectInsertAtCursor), f)
}

// ConnectInsertEmoji is emitted to present the Emoji chooser for the self.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>.</kbd> and
// <kbd>Ctrl</kbd>-<kbd>;</kbd>.
func (self *Text) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectInsertEmoji), f)
}

// ConnectMoveCursor is emitted when the user initiates a cursor movement.
//
// If the cursor is not visible in self, this signal causes the viewport to be
// moved instead.
//
// This is a keybinding signal (class.SignalAction.html).
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
// The default bindings for this signal come in two variants, the variant with
// the <kbd>Shift</kbd> modifier extends the selection, the variant without it
// does not. There are too many key combinations to list them all here.
//
// - <kbd>←</kbd>, <kbd>→</kbd>, <kbd>↑</kbd>, <kbd>↓</kbd> move by individual
// characters/lines
//
// - <kbd>Ctrl</kbd>-<kbd>→</kbd>, etc. move by words/paragraphs
//
// - <kbd>Home</kbd>, <kbd>End</kbd> move to the ends of the buffer.
func (self *Text) ConnectMoveCursor(f func(step MovementStep, count int, extend bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectMoveCursor), f)
}

// ConnectPasteClipboard is emitted to paste the contents of the clipboard.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>v</kbd> and
// <kbd>Shift</kbd>-<kbd>Insert</kbd>.
func (self *Text) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectPasteClipboard), f)
}

// ConnectPreeditChanged is emitted when the preedit text changes.
//
// If an input method is used, the typed text will not immediately be committed
// to the buffer. So if you are interested in the text, connect to this signal.
func (self *Text) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectPreeditChanged), f)
}

// ConnectToggleOverwrite is emitted to toggle the overwrite mode of the
// GtkText.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal is <kbd>Insert</kbd>.
func (self *Text) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(self, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk4_Text_ConnectToggleOverwrite), f)
}

// NewText creates a new GtkText.
//
// The function returns the following values:
//
//   - text: new GtkText.
func NewText() *Text {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_new()

	var _text *Text // out

	_text = wrapText(coreglib.Take(unsafe.Pointer(_cret)))

	return _text
}

// NewTextWithBuffer creates a new GtkText with the specified text buffer.
//
// The function takes the following parameters:
//
//   - buffer to use for the new GtkText.
//
// The function returns the following values:
//
//   - text: new GtkText.
func NewTextWithBuffer(buffer *EntryBuffer) *Text {
	var _arg1 *C.GtkEntryBuffer // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_new_with_buffer(_arg1)
	runtime.KeepAlive(buffer)

	var _text *Text // out

	_text = wrapText(coreglib.Take(unsafe.Pointer(_cret)))

	return _text
}

// ActivatesDefault retrieves the value set by gtk_text_set_activates_default().
//
// The function returns the following values:
//
//   - ok: TRUE if the GtkText will activate the default widget.
func (self *Text) ActivatesDefault() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_activates_default(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Attributes gets the attribute list that was set on the GtkText using
// gtk_text_set_attributes().
//
// The function returns the following values:
//
//   - attrList (optional): attribute list, or NULL if none was set.
func (self *Text) Attributes() *pango.AttrList {
	var _arg0 *C.GtkText       // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_attributes(_arg0)
	runtime.KeepAlive(self)

	var _attrList *pango.AttrList // out

	if _cret != nil {
		_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.pango_attr_list_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_attrList)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_attr_list_unref((*C.PangoAttrList)(intern.C))
			},
		)
	}

	return _attrList
}

// Buffer: get the GtkEntryBuffer object which holds the text for this self.
//
// The function returns the following values:
//
//   - entryBuffer: GtkEntryBuffer object.
func (self *Text) Buffer() *EntryBuffer {
	var _arg0 *C.GtkText        // out
	var _cret *C.GtkEntryBuffer // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_buffer(_arg0)
	runtime.KeepAlive(self)

	var _entryBuffer *EntryBuffer // out

	_entryBuffer = wrapEntryBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _entryBuffer
}

// EnableEmojiCompletion returns whether Emoji completion is enabled for this
// GtkText widget.
//
// The function returns the following values:
//
//   - ok: TRUE if Emoji completion is enabled.
func (self *Text) EnableEmojiCompletion() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_enable_emoji_completion(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
//
// The function returns the following values:
//
//   - menuModel (optional): menu model.
func (self *Text) ExtraMenu() gio.MenuModeller {
	var _arg0 *C.GtkText    // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_extra_menu(_arg0)
	runtime.KeepAlive(self)

	var _menuModel gio.MenuModeller // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gio.MenuModeller)
				return ok
			})
			rv, ok := casted.(gio.MenuModeller)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
			}
			_menuModel = rv
		}
	}

	return _menuModel
}

// InputHints gets the input hints of the GtkText.
func (self *Text) InputHints() InputHints {
	var _arg0 *C.GtkText      // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_input_hints(_arg0)
	runtime.KeepAlive(self)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the input purpose of the GtkText.
func (self *Text) InputPurpose() InputPurpose {
	var _arg0 *C.GtkText        // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_input_purpose(_arg0)
	runtime.KeepAlive(self)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false.
//
// Note that GTK does not compute this value unless it needs it, so the value
// returned by this function is not very useful unless it has been explicitly
// set with gtk.Text.SetInvisibleChar().
//
// The function returns the following values:
//
//   - gunichar: current invisible char, or 0, if text does not show invisible
//     text at all.
func (self *Text) InvisibleChar() uint32 {
	var _arg0 *C.GtkText // out
	var _cret C.gunichar // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_invisible_char(_arg0)
	runtime.KeepAlive(self)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// MaxLength retrieves the maximum allowed length of the text in self.
//
// See gtk.Text.SetMaxLength().
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.GetMaxLength() on it.
//
// The function returns the following values:
//
//   - gint: maximum allowed number of characters in GtkText, or 0 if there is
//     no maximum.
func (self *Text) MaxLength() int {
	var _arg0 *C.GtkText // out
	var _cret C.int      // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_max_length(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
//
// The function returns the following values:
//
//   - ok: whether the text is overwritten when typing.
func (self *Text) OverwriteMode() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_overwrite_mode(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceholderText retrieves the text that will be displayed when self is empty
// and unfocused.
//
// The function returns the following values:
//
//   - utf8 (optional): pointer to the placeholder text as a string. This
//     string points to internally allocated storage in the widget and must
//     not be freed, modified or stored. If no placeholder text has been set,
//     NULL will be returned.
func (self *Text) PlaceholderText() string {
	var _arg0 *C.GtkText // out
	var _cret *C.char    // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_placeholder_text(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// PropagateTextWidth returns whether the GtkText will grow and shrink with the
// content.
//
// The function returns the following values:
//
//   - ok: TRUE if self will propagate the text width.
func (self *Text) PropagateTextWidth() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_propagate_text_width(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Tabs gets the tabstops that were set on the GtkText using
// gtk_text_set_tabs().
//
// The function returns the following values:
//
//   - tabArray (optional): tabstops, or NULL if none was set.
func (self *Text) Tabs() *pango.TabArray {
	var _arg0 *C.GtkText       // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_tabs(_arg0)
	runtime.KeepAlive(self)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _tabArray
}

// TextLength retrieves the current length of the text in self.
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.GetLength() on it.
//
// The function returns the following values:
//
//   - guint16: current number of characters in GtkText, or 0 if there are none.
func (self *Text) TextLength() uint16 {
	var _arg0 *C.GtkText // out
	var _cret C.guint16  // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_text_length(_arg0)
	runtime.KeepAlive(self)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// TruncateMultiline returns whether the GtkText will truncate multi-line text
// that is pasted into the widget.
//
// The function returns the following values:
//
//   - ok: TRUE if self will truncate multi-line text.
func (self *Text) TruncateMultiline() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_truncate_multiline(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visibility retrieves whether the text in self is visible.
//
// The function returns the following values:
//
//   - ok: TRUE if the text is currently visible.
func (self *Text) Visibility() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_get_visibility(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GrabFocusWithoutSelecting causes self to have keyboard focus.
//
// It behaves like gtk.Widget.GrabFocus(), except that it doesn't select
// the contents of self. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
//
// The function returns the following values:
//
//   - ok: TRUE if focus is now inside self.
func (self *Text) GrabFocusWithoutSelecting() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_text_grab_focus_without_selecting(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatesDefault: if activates is TRUE, pressing Enter in the self will
// activate the default widget for the window containing self.
//
// This usually means that the dialog containing the GtkText will be closed,
// since the default widget is usually one of the dialog buttons.
//
// The function takes the following parameters:
//
//   - activates: TRUE to activate window’s default widget on Enter keypress.
func (self *Text) SetActivatesDefault(activates bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if activates {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_activates_default(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(activates)
}

// SetAttributes sets attributes that are applied to the text.
//
// The function takes the following parameters:
//
//   - attrs (optional): PangoAttrList or NULL to unset.
func (self *Text) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkText       // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if attrs != nil {
		_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))
	}

	C.gtk_text_set_attributes(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(attrs)
}

// SetBuffer: set the GtkEntryBuffer object which holds the text for this
// widget.
//
// The function takes the following parameters:
//
//   - buffer: GtkEntryBuffer.
func (self *Text) SetBuffer(buffer *EntryBuffer) {
	var _arg0 *C.GtkText        // out
	var _arg1 *C.GtkEntryBuffer // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_set_buffer(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(buffer)
}

// SetEnableEmojiCompletion sets whether Emoji completion is enabled.
//
// If it is, typing ':', followed by a recognized keyword, will pop up a window
// with suggested Emojis matching the keyword.
//
// The function takes the following parameters:
//
//   - enableEmojiCompletion: TRUE to enable Emoji completion.
func (self *Text) SetEnableEmojiCompletion(enableEmojiCompletion bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if enableEmojiCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_enable_emoji_completion(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(enableEmojiCompletion)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// self.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel.
func (self *Text) SetExtraMenu(model gio.MenuModeller) {
	var _arg0 *C.GtkText    // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_text_set_extra_menu(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(model)
}

// SetInputHints sets input hints that allow input methods to fine-tune their
// behaviour.
//
// The function takes the following parameters:
//
//   - hints: hints.
func (self *Text) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkText      // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkInputHints(hints)

	C.gtk_text_set_input_hints(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(hints)
}

// SetInputPurpose sets the input purpose of the GtkText.
//
// This can be used by on-screen keyboards and other input methods to adjust
// their behaviour.
//
// The function takes the following parameters:
//
//   - purpose: purpose.
func (self *Text) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkText        // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkInputPurpose(purpose)

	C.gtk_text_set_input_purpose(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(purpose)
}

// SetInvisibleChar sets the character to use in place of the actual text when
// in “password mode”.
//
// By default, GTK picks the best invisible char available in the current font.
// If you set the invisible char to 0, then the user will get no feedback at
// all; there will be no text on the screen as they type.
//
// The function takes the following parameters:
//
//   - ch: unicode character.
func (self *Text) SetInvisibleChar(ch uint32) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gunichar // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.gunichar(ch)

	C.gtk_text_set_invisible_char(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ch)
}

// SetMaxLength sets the maximum allowed length of the contents of the widget.
//
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.SetMaxLength() on it.
//
// The function takes the following parameters:
//
//   - length: maximum length of the GtkText, or 0 for no maximum. (other than
//     the maximum length of entries.) The value passed in will be clamped to
//     the range 0-65536.
func (self *Text) SetMaxLength(length int) {
	var _arg0 *C.GtkText // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.int(length)

	C.gtk_text_set_max_length(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(length)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// GtkText.
//
// The function takes the following parameters:
//
//   - overwrite: new value.
func (self *Text) SetOverwriteMode(overwrite bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_overwrite_mode(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(overwrite)
}

// SetPlaceholderText sets text to be displayed in self when it is empty.
//
// This can be used to give a visual hint of the expected contents of the
// GtkText.
//
// The function takes the following parameters:
//
//   - text (optional): string to be displayed when self is empty and unfocused,
//     or NULL.
func (self *Text) SetPlaceholderText(text string) {
	var _arg0 *C.GtkText // out
	var _arg1 *C.char    // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_text_set_placeholder_text(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(text)
}

// SetPropagateTextWidth sets whether the GtkText should grow and shrink with
// the content.
//
// The function takes the following parameters:
//
//   - propagateTextWidth: TRUE to propagate the text width.
func (self *Text) SetPropagateTextWidth(propagateTextWidth bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if propagateTextWidth {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_propagate_text_width(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(propagateTextWidth)
}

// SetTabs sets tabstops that are applied to the text.
//
// The function takes the following parameters:
//
//   - tabs (optional): PangoTabArray.
func (self *Text) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkText       // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if tabs != nil {
		_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))
	}

	C.gtk_text_set_tabs(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(tabs)
}

// SetTruncateMultiline sets whether the GtkText should truncate multi-line text
// that is pasted into the widget.
//
// The function takes the following parameters:
//
//   - truncateMultiline: TRUE to truncate multi-line text.
func (self *Text) SetTruncateMultiline(truncateMultiline bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if truncateMultiline {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_truncate_multiline(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(truncateMultiline)
}

// SetVisibility sets whether the contents of the GtkText are visible or not.
//
// When visibility is set to FALSE, characters are displayed as the invisible
// char, and will also appear that way when the text in the widget is copied to
// the clipboard.
//
// By default, GTK picks the best invisible character available in the current
// font, but it can be changed with gtk.Text.SetInvisibleChar().
//
// Note that you probably want to set gtk.Text:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this self, in addition to setting visibility to FALSE.
//
// The function takes the following parameters:
//
//   - visible: TRUE if the contents of the GtkText are displayed as plaintext.
func (self *Text) SetVisibility(visible bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_visibility(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(visible)
}

// UnsetInvisibleChar unsets the invisible char.
//
// After calling this, the default invisible char is used again.
func (self *Text) UnsetInvisibleChar() {
	var _arg0 *C.GtkText // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	C.gtk_text_unset_invisible_char(_arg0)
	runtime.KeepAlive(self)
}

// TextBufferOverrides contains methods that are overridable.
type TextBufferOverrides struct {
	// ApplyTag emits the “apply-tag” signal on buffer.
	//
	// The default handler for the signal applies tag to the given range.
	// start and end do not have to be in order.
	//
	// The function takes the following parameters:
	//
	//   - tag: GtkTextTag.
	//   - start: one bound of range to be tagged.
	//   - end: other bound of range to be tagged.
	ApplyTag func(tag *TextTag, start, end *TextIter)
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation.
	//
	// The operations between gtk_text_buffer_begin_user_action() and
	// gtk_text_buffer_end_user_action() can then be grouped when
	// creating an undo stack. GtkTextBuffer maintains a count of calls to
	// gtk_text_buffer_begin_user_action() that have not been closed with a call
	// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
	// and “end-user-action” signals only for the outermost pair of calls.
	// This allows you to build user actions from other user actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction func()
	Changed         func()
	// The function takes the following parameters:
	//
	//   - start
	//   - end
	DeleteRange func(start, end *TextIter)
	// EndUserAction ends a user-visible operation.
	//
	// Should be paired with a call to gtk.TextBuffer.BeginUserAction().
	// See that function for a full explanation.
	EndUserAction func()
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// iter.
	//
	// The anchor will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for child anchors, but the “text” variants do not. E.g.
	// see gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	//
	// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient
	// alternative to this function. The buffer will add a reference to the
	// anchor, so you can unref it after insertion.
	//
	// The function takes the following parameters:
	//
	//   - iter: location to insert the anchor.
	//   - anchor: GtkTextChildAnchor.
	InsertChildAnchor func(iter *TextIter, anchor *TextChildAnchor)
	// InsertPaintable inserts an image into the text buffer at iter.
	//
	// The image will be counted as one character in character counts,
	// and when obtaining the buffer contents as a string, will be represented
	// by the Unicode “object replacement character” 0xFFFC. Note that the
	// “slice” variants for obtaining portions of the buffer as a string include
	// this character for paintable, but the “text” variants do not. e.g.
	// see gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	//
	// The function takes the following parameters:
	//
	//   - iter: location to insert the paintable.
	//   - paintable: GdkPaintable.
	InsertPaintable func(iter *TextIter, paintable gdk.Paintabler)
	// The function takes the following parameters:
	//
	//   - pos
	//   - newText
	//   - newTextLength
	InsertText  func(pos *TextIter, newText string, newTextLength int)
	MarkDeleted func(mark *TextMark)
	// The function takes the following parameters:
	//
	//   - location
	//   - mark
	MarkSet         func(location *TextIter, mark *TextMark)
	ModifiedChanged func()
	PasteDone       func(clipboard *gdk.Clipboard)
	// Redo redoes the next redoable action on the buffer, if there is one.
	Redo func()
	// RemoveTag emits the “remove-tag” signal.
	//
	// The default handler for the signal removes all occurrences of tag from
	// the given range. start and end don’t have to be in order.
	//
	// The function takes the following parameters:
	//
	//   - tag: GtkTextTag.
	//   - start: one bound of range to be untagged.
	//   - end: other bound of range to be untagged.
	RemoveTag func(tag *TextTag, start, end *TextIter)
	// Undo undoes the last undoable action on the buffer, if there is one.
	Undo func()
}

func defaultTextBufferOverrides(v *TextBuffer) TextBufferOverrides {
	return TextBufferOverrides{
		ApplyTag:          v.applyTag,
		BeginUserAction:   v.beginUserAction,
		Changed:           v.changed,
		DeleteRange:       v.deleteRange,
		EndUserAction:     v.endUserAction,
		InsertChildAnchor: v.insertChildAnchor,
		InsertPaintable:   v.insertPaintable,
		InsertText:        v.insertText,
		MarkDeleted:       v.markDeleted,
		MarkSet:           v.markSet,
		ModifiedChanged:   v.modifiedChanged,
		PasteDone:         v.pasteDone,
		Redo:              v.redo,
		RemoveTag:         v.removeTag,
		Undo:              v.undo,
	}
}

// TextBuffer stores text and attributes for display in a GtkTextView.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextBuffer struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextBuffer)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextBuffer, *TextBufferClass, TextBufferOverrides](
		GTypeTextBuffer,
		initTextBufferClass,
		wrapTextBuffer,
		defaultTextBufferOverrides,
	)
}

func initTextBufferClass(gclass unsafe.Pointer, overrides TextBufferOverrides, classInitFunc func(*TextBufferClass)) {
	pclass := (*C.GtkTextBufferClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTextBuffer))))

	if overrides.ApplyTag != nil {
		pclass.apply_tag = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_apply_tag)
	}

	if overrides.BeginUserAction != nil {
		pclass.begin_user_action = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_begin_user_action)
	}

	if overrides.Changed != nil {
		pclass.changed = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_changed)
	}

	if overrides.DeleteRange != nil {
		pclass.delete_range = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_delete_range)
	}

	if overrides.EndUserAction != nil {
		pclass.end_user_action = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_end_user_action)
	}

	if overrides.InsertChildAnchor != nil {
		pclass.insert_child_anchor = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_insert_child_anchor)
	}

	if overrides.InsertPaintable != nil {
		pclass.insert_paintable = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_insert_paintable)
	}

	if overrides.InsertText != nil {
		pclass.insert_text = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_insert_text)
	}

	if overrides.MarkDeleted != nil {
		pclass.mark_deleted = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_mark_deleted)
	}

	if overrides.MarkSet != nil {
		pclass.mark_set = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_mark_set)
	}

	if overrides.ModifiedChanged != nil {
		pclass.modified_changed = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_modified_changed)
	}

	if overrides.PasteDone != nil {
		pclass.paste_done = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_paste_done)
	}

	if overrides.Redo != nil {
		pclass.redo = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_redo)
	}

	if overrides.RemoveTag != nil {
		pclass.remove_tag = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_remove_tag)
	}

	if overrides.Undo != nil {
		pclass.undo = (*[0]byte)(C._gotk4_gtk4_TextBufferClass_undo)
	}

	if classInitFunc != nil {
		class := (*TextBufferClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextBuffer(obj *coreglib.Object) *TextBuffer {
	return &TextBuffer{
		Object: obj,
	}
}

func marshalTextBuffer(p uintptr) (interface{}, error) {
	return wrapTextBuffer(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectApplyTag is emitted to apply a tag to a range of text in a
// GtkTextBuffer.
//
// Applying actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk.TextBuffer.ApplyTag(), gtk.TextBuffer.InsertWithTags(),
// gtk.TextBuffer.InsertRange().
func (buffer *TextBuffer) ConnectApplyTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "apply-tag", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectApplyTag), f)
}

// ConnectBeginUserAction is emitted at the beginning of a single user-visible
// operation on a GtkTextBuffer.
//
// See also: gtk.TextBuffer.BeginUserAction(),
// gtk.TextBuffer.InsertInteractive(), gtk.TextBuffer.InsertRangeInteractive(),
// gtk.TextBuffer.DeleteInteractive(), gtk.TextBuffer.Backspace(),
// gtk.TextBuffer.DeleteSelection().
func (buffer *TextBuffer) ConnectBeginUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "begin-user-action", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectBeginUserAction), f)
}

// ConnectChanged is emitted when the content of a GtkTextBuffer has changed.
func (buffer *TextBuffer) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "changed", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectChanged), f)
}

// ConnectDeleteRange is emitted to delete a range from a GtkTextBuffer.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them). The default
// signal handler revalidates the start and end iters to both point to the
// location where text was deleted. Handlers which run after the default handler
// (see g_signal_connect_after()) do not have access to the deleted text.
//
// See also: gtk.TextBuffer.Delete().
func (buffer *TextBuffer) ConnectDeleteRange(f func(start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "delete-range", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectDeleteRange), f)
}

// ConnectEndUserAction is emitted at the end of a single user-visible operation
// on the GtkTextBuffer.
//
// See also: gtk.TextBuffer.EndUserAction(), gtk.TextBuffer.InsertInteractive(),
// gtk.TextBuffer.InsertRangeInteractive(), gtk.TextBuffer.DeleteInteractive(),
// gtk.TextBuffer.Backspace(), gtk.TextBuffer.DeleteSelection(),
// gtk.TextBuffer.Backspace().
func (buffer *TextBuffer) ConnectEndUserAction(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "end-user-action", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectEndUserAction), f)
}

// ConnectInsertChildAnchor is emitted to insert a GtkTextChildAnchor in a
// GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted anchor.
//
// See also: gtk.TextBuffer.InsertChildAnchor().
func (buffer *TextBuffer) ConnectInsertChildAnchor(f func(location *TextIter, anchor *TextChildAnchor)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-child-anchor", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertChildAnchor), f)
}

// ConnectInsertPaintable is emitted to insert a GdkPaintable in a
// GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to be placed after the inserted paintable.
//
// See also: gtk.TextBuffer.InsertPaintable().
func (buffer *TextBuffer) ConnectInsertPaintable(f func(location *TextIter, paintable gdk.Paintabler)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-paintable", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertPaintable), f)
}

// ConnectInsertText is emitted to insert text in a GtkTextBuffer.
//
// Insertion actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the location iter (or has to revalidate it). The default signal
// handler revalidates it to point to the end of the inserted text.
//
// See also: gtk,textbuffer.Insert, gtk.TextBuffer.InsertRange().
func (buffer *TextBuffer) ConnectInsertText(f func(location *TextIter, text string, len int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "insert-text", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectInsertText), f)
}

// ConnectMarkDeleted is emitted as notification after a GtkTextMark is deleted.
//
// See also: gtk.TextBuffer.DeleteMark().
func (buffer *TextBuffer) ConnectMarkDeleted(f func(mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-deleted", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectMarkDeleted), f)
}

// ConnectMarkSet is emitted as notification after a GtkTextMark is set.
//
// See also: gtk.TextBuffer.CreateMark(), gtk.TextBuffer.MoveMark().
func (buffer *TextBuffer) ConnectMarkSet(f func(location *TextIter, mark *TextMark)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "mark-set", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectMarkSet), f)
}

// ConnectModifiedChanged is emitted when the modified bit of a GtkTextBuffer
// flips.
//
// See also: gtk.TextBuffer.SetModified().
func (buffer *TextBuffer) ConnectModifiedChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "modified-changed", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectModifiedChanged), f)
}

// ConnectPasteDone is emitted after paste operation has been completed.
//
// This is useful to properly scroll the view to the end of the pasted text.
// See gtk.TextBuffer.PasteClipboard() for more details.
func (buffer *TextBuffer) ConnectPasteDone(f func(clipboard *gdk.Clipboard)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "paste-done", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectPasteDone), f)
}

// ConnectRedo is emitted when a request has been made to redo the previously
// undone operation.
func (buffer *TextBuffer) ConnectRedo(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "redo", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectRedo), f)
}

// ConnectRemoveTag is emitted to remove all occurrences of tag from a range of
// text in a GtkTextBuffer.
//
// Removal actually occurs in the default handler.
//
// Note that if your handler runs before the default handler it must not
// invalidate the start and end iters (or has to revalidate them).
//
// See also: gtk.TextBuffer.RemoveTag().
func (buffer *TextBuffer) ConnectRemoveTag(f func(tag *TextTag, start, end *TextIter)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "remove-tag", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectRemoveTag), f)
}

// ConnectUndo is emitted when a request has been made to undo the previous
// operation or set of operations that have been grouped together.
func (buffer *TextBuffer) ConnectUndo(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(buffer, "undo", false, unsafe.Pointer(C._gotk4_gtk4_TextBuffer_ConnectUndo), f)
}

// NewTextBuffer creates a new text buffer.
//
// The function takes the following parameters:
//
//   - table (optional): tag table, or NULL to create a new one.
//
// The function returns the following values:
//
//   - textBuffer: new text buffer.
func NewTextBuffer(table *TextTagTable) *TextBuffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkTextBuffer   // in

	if table != nil {
		_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	}

	_cret = C.gtk_text_buffer_new(_arg1)
	runtime.KeepAlive(table)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

// AddMark adds the mark at position where.
//
// The mark must not be added to another buffer, and if its name is not NULL
// then there must not be another mark in the buffer with the same name.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
//
// The function takes the following parameters:
//
//   - mark to add.
//   - where: location to place mark.
func (buffer *TextBuffer) AddMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// AddSelectionClipboard adds clipboard to the list of clipboards in which the
// selection contents of buffer are available.
//
// In most cases, clipboard will be the GdkClipboard returned by
// gtk.Widget.GetPrimaryClipboard() for a view of buffer.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard.
func (buffer *TextBuffer) AddSelectionClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// ApplyTag emits the “apply-tag” signal on buffer.
//
// The default handler for the signal applies tag to the given range. start and
// end do not have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be tagged.
//   - end: other bound of range to be tagged.
func (buffer *TextBuffer) ApplyTag(tag *TextTag, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ApplyTagByName emits the “apply-tag” signal on buffer.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.ApplyTag().
//
// The function takes the following parameters:
//
//   - name of a named GtkTextTag.
//   - start: one bound of range to be tagged.
//   - end: other bound of range to be tagged.
func (buffer *TextBuffer) ApplyTagByName(name string, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by iter.
//
// In the normal case a single character will be deleted, but when combining
// accents are involved, more than one character can be deleted, and when
// precomposed character and accent combinations are involved, less than one
// character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the iter will be re-initialized to
// point to the location where text was deleted.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - interactive: whether the deletion is caused by user interaction.
//   - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//   - ok: TRUE if the buffer was modified.
func (buffer *TextBuffer) Backspace(iter *TextIter, interactive, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginIrreversibleAction denotes the beginning of an action that may not be
// undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be paired with a call to gtk.TextBuffer.EndIrreversibleAction()
// after the irreversible action has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) BeginIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_begin_irreversible_action(_arg0)
	runtime.KeepAlive(buffer)
}

// BeginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when
// creating an undo stack. GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call
// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action” and
// “end-user-action” signals only for the outermost pair of calls. This allows
// you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user action
// around the buffer operations they perform, so there's no need to add extra
// calls if you user action consists solely of a single call to one of those
// functions.
func (buffer *TextBuffer) BeginUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// CopyClipboard copies the currently-selected text to a clipboard.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard object to copy to.
func (buffer *TextBuffer) CopyClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// CreateChildAnchor creates and inserts a child anchor.
//
// This is a convenience function which simply creates a child anchor
// with gtk.TextChildAnchor.New and inserts it into the buffer with
// gtk.TextBuffer.InsertChildAnchor().
//
// The new anchor is owned by the buffer; no reference count is returned to the
// caller of this function.
//
// The function takes the following parameters:
//
//   - iter: location in the buffer.
//
// The function returns the following values:
//
//   - textChildAnchor: created child anchor.
func (buffer *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// CreateMark creates a mark at position where.
//
// If mark_name is NULL, the mark is anonymous; otherwise, the mark can be
// retrieved by name using gtk.TextBuffer.GetMark(). If a mark has left gravity,
// and text is inserted at the mark’s current location, the mark will be
// moved to the left of the newly-inserted text. If the mark has right gravity
// (left_gravity = FALSE), the mark will end up on the right of newly-inserted
// text. The standard left-to-right cursor is a mark with right gravity (when
// you type, the cursor stays on the right side of the text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
//
// The function takes the following parameters:
//
//   - markName (optional): name for mark, or NULL.
//   - where: location to place mark.
//   - leftGravity: whether the mark has left gravity.
//
// The function returns the following values:
//
//   - textMark: new TextMark object.
func (buffer *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if markName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(markName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))
	if leftGravity {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(markName)
	runtime.KeepAlive(where)
	runtime.KeepAlive(leftGravity)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard object to cut to.
//   - defaultEditable: default editability of the buffer.
func (buffer *TextBuffer) CutClipboard(clipboard *gdk.Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(defaultEditable)
}

// Delete deletes text between start and end.
//
// The order of start and end is not actually relevant; gtk_text_buffer_delete()
// will reorder them.
//
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified, all
// outstanding iterators become invalid after calling this function; however,
// the start and end will be re-initialized to point to the location where text
// was deleted.
//
// The function takes the following parameters:
//
//   - start: position in buffer.
//   - end: another position in buffer.
func (buffer *TextBuffer) Delete(start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// DeleteInteractive deletes all editable text in the given range.
//
// Calls gtk.TextBuffer.Delete() for each editable sub-range of [start,end).
// start and end are revalidated to point to the location of the last deleted
// range, or left untouched if no text was deleted.
//
// The function takes the following parameters:
//
//   - startIter: start of range to delete.
//   - endIter: end of range.
//   - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//   - ok: whether some text was actually deleted.
func (buffer *TextBuffer) DeleteInteractive(startIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(startIter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(endIter)))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startIter)
	runtime.KeepAlive(endIter)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes mark, so that it’s no longer located anywhere in the
// buffer.
//
// Removes the reference the buffer holds to the mark, so if you haven’t called
// g_object_ref() on the mark, it will be freed. Even if the mark isn’t freed,
// most operations on mark become invalid, until it gets added to a buffer again
// with gtk.TextBuffer.AddMark(). Use gtk.TextMark.GetDeleted() to find out if a
// mark has been removed from its buffer.
//
// The gtk.TextBuffer::mark-deleted signal will be emitted as notification after
// the mark is deleted.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark in buffer.
func (buffer *TextBuffer) DeleteMark(mark *TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// DeleteMarkByName deletes the mark named name; the mark must exist.
//
// See gtk.TextBuffer.DeleteMark() for details.
//
// The function takes the following parameters:
//
//   - name of a mark in buffer.
func (buffer *TextBuffer) DeleteMarkByName(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
}

// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text.
//
// If interactive is TRUE, the editability of the selection will be considered
// (users can’t delete uneditable text).
//
// The function takes the following parameters:
//
//   - interactive: whether the deletion is caused by user interaction.
//   - defaultEditable: whether the buffer is editable by default.
//
// The function returns the following values:
//
//   - ok: whether there was a non-empty selection to delete.
func (buffer *TextBuffer) DeleteSelection(interactive, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndIrreversibleAction denotes the end of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be called after completing modifications to the text buffer after
// gtk_text_buffer_begin_irreversible_action() was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) EndIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_end_irreversible_action(_arg0)
	runtime.KeepAlive(buffer)
}

// EndUserAction ends a user-visible operation.
//
// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See that
// function for a full explanation.
func (buffer *TextBuffer) EndUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [start,end).
//
// The function returns the following values:
//
//   - start: iterator to initialize with first position in the buffer.
//   - end: iterator to initialize with the end iterator.
func (buffer *TextBuffer) Bounds() (start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_get_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start *TextIter // out
	var _end *TextIter   // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _start, _end
}

// CanRedo gets whether there is a redoable action in the history.
//
// The function returns the following values:
//
//   - ok: TRUE if there is an redoable action.
func (buffer *TextBuffer) CanRedo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_can_redo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUndo gets whether there is an undoable action in the history.
//
// The function returns the following values:
//
//   - ok: TRUE if there is an undoable action.
func (buffer *TextBuffer) CanUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_can_undo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CharCount gets the number of characters in the buffer.
//
// Note that characters and bytes are not the same, you can’t e.g. expect the
// contents of the buffer in string form to be this many bytes long.
//
// The character count is cached, so this function is very fast.
//
// The function returns the following values:
//
//   - gint: number of characters in the buffer.
func (buffer *TextBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_char_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// EnableUndo gets whether the buffer is saving modifications to the buffer to
// allow for undo and redo actions.
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
func (buffer *TextBuffer) EnableUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_enable_undo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndIter initializes iter with the “end iterator,” one past the last valid
// character in the text buffer.
//
// If dereferenced with gtk.TextIter.GetChar(), the end iterator has a character
// value of 0. The entire buffer lies in the range from the first position in
// the buffer (call gtk.TextBuffer.GetStartIter() to get character position 0)
// to the end iterator.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
func (buffer *TextBuffer) EndIter() *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_get_end_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// HasSelection indicates whether the buffer has some text currently selected.
//
// The function returns the following values:
//
//   - ok: TRUE if the there is text selected.
func (buffer *TextBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
//
// The function returns the following values:
//
//   - textMark: insertion point mark.
func (buffer *TextBuffer) GetInsert() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_insert(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// IterAtChildAnchor obtains the location of anchor within buffer.
//
// The function takes the following parameters:
//
//   - anchor: child anchor that appears in buffer.
//
// The function returns the following values:
//
//   - iter: iterator to be initialized.
func (buffer *TextBuffer) IterAtChildAnchor(anchor *TextChildAnchor) *TextIter {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 C.GtkTextIter         // in
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(anchor)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtLine initializes iter to the start of the given line.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned.
//
// The function takes the following parameters:
//
//   - lineNumber: line number counting from 0.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//   - ok: whether the exact position has been found.
func (buffer *TextBuffer) IterAtLine(lineNumber int) (*TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(lineNumber)

	_cret = C.gtk_text_buffer_get_iter_at_line(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineIndex obtains an iterator pointing to byte_index within the given
// line.
//
// byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if byte_index is off the end of the line,
// the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//   - lineNumber: line number counting from 0.
//   - byteIndex: byte index from start of line.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//   - ok: whether the exact position has been found.
func (buffer *TextBuffer) IterAtLineIndex(lineNumber, byteIndex int) (*TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(byteIndex)

	_cret = C.gtk_text_buffer_get_iter_at_line_index(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(byteIndex)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineOffset obtains an iterator pointing to char_offset within the given
// line.
//
// Note characters, not bytes; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if char_offset is off the end of the line,
// the iterator at the end of the line is returned.
//
// The function takes the following parameters:
//
//   - lineNumber: line number counting from 0.
//   - charOffset: char offset from start of line.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
//   - ok: whether the exact position has been found.
func (buffer *TextBuffer) IterAtLineOffset(lineNumber, charOffset int) (*TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(charOffset)

	_cret = C.gtk_text_buffer_get_iter_at_line_offset(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(charOffset)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtMark initializes iter with the current position of mark.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark in buffer.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
func (buffer *TextBuffer) IterAtMark(mark *TextMark) *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C.gtk_text_buffer_get_iter_at_mark(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtOffset initializes iter to a position char_offset chars from the start
// of the entire buffer.
//
// If char_offset is -1 or greater than the number of characters in the buffer,
// iter is initialized to the end iterator, the iterator one past the last valid
// character in the buffer.
//
// The function takes the following parameters:
//
//   - charOffset: char offset from start of buffer, counting from 0, or -1.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
func (buffer *TextBuffer) IterAtOffset(charOffset int) *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = C.int(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(charOffset)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// LineCount obtains the number of lines in the buffer.
//
// This value is cached, so the function is very fast.
//
// The function returns the following values:
//
//   - gint: number of lines in the buffer.
func (buffer *TextBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_line_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Mark returns the mark named name in buffer buffer, or NULL if no such mark
// exists in the buffer.
//
// The function takes the following parameters:
//
//   - name: mark name.
//
// The function returns the following values:
//
//   - textMark (optional) or NULL.
func (buffer *TextBuffer) Mark(name string) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _textMark *TextMark // out

	if _cret != nil {
		_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _textMark
}

// MaxUndoLevels gets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
func (buffer *TextBuffer) MaxUndoLevels() uint {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_max_undo_levels(_arg0)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Modified indicates whether the buffer has been modified since the last call
// to gtk.TextBuffer.SetModified() set the modification flag to FALSE.
//
// Used for example to enable a “save” function in a text editor.
//
// The function returns the following values:
//
//   - ok: TRUE if the buffer has been modified.
func (buffer *TextBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_modified(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionBound returns the mark that represents the selection bound.
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and
// “insert” are in the same place, then there is no current selection.
// gtk.TextBuffer.GetSelectionBounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
//
// The function returns the following values:
//
//   - textMark: selection bound mark.
func (buffer *TextBuffer) SelectionBound() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_selection_bound(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// SelectionBounds returns TRUE if some text is selected; places the bounds of
// the selection in start and end.
//
// If the selection has length 0, then start and end are filled in with the same
// value. start and end will be in ascending order. If start and end are NULL,
// then they are not filled in, but the return value still indicates whether
// text is selected.
//
// The function returns the following values:
//
//   - start: iterator to initialize with selection start.
//   - end: iterator to initialize with selection end.
//   - ok: whether the selection has nonzero length.
func (buffer *TextBuffer) SelectionBounds() (start, end *TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start *TextIter // out
	var _end *TextIter   // out
	var _ok bool         // out

	_start = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// SelectionContent: get a content provider for this buffer.
//
// It can be used to make the content of buffer available in a GdkClipboard,
// see gdk.Clipboard.SetContent().
//
// The function returns the following values:
//
//   - contentProvider: new GdkContentProvider.
func (buffer *TextBuffer) SelectionContent() *gdk.ContentProvider {
	var _arg0 *C.GtkTextBuffer      // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_selection_content(_arg0)
	runtime.KeepAlive(buffer)

	var _contentProvider *gdk.ContentProvider // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_contentProvider = &gdk.ContentProvider{
			Object: obj,
		}
	}

	return _contentProvider
}

// Slice returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. The returned string includes
// a 0xFFFC character whenever the buffer contains embedded images, so byte
// and character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with gtk.TextBuffer.GetText().
// Note that 0xFFFC can occur in normal text as well, so it is not a reliable
// indicator that a paintable or widget is in the buffer.
//
// The function takes the following parameters:
//
//   - start of a range.
//   - end of a range.
//   - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//   - utf8: allocated UTF-8 string.
func (buffer *TextBuffer) Slice(start, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StartIter: initialized iter with the first position in the text buffer.
//
// This is the same as using gtk.TextBuffer.GetIterAtOffset() to get the iter at
// character offset 0.
//
// The function returns the following values:
//
//   - iter: iterator to initialize.
func (buffer *TextBuffer) StartIter() *TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_get_start_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter *TextIter // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// TagTable: get the GtkTextTagTable associated with this buffer.
//
// The function returns the following values:
//
//   - textTagTable buffer’s tag table.
func (buffer *TextBuffer) TagTable() *TextTagTable {
	var _arg0 *C.GtkTextBuffer   // out
	var _cret *C.GtkTextTagTable // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_buffer_get_tag_table(_arg0)
	runtime.KeepAlive(buffer)

	var _textTagTable *TextTagTable // out

	_textTagTable = wrapTextTagTable(coreglib.Take(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Text returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. Does not include characters
// representing embedded images, so byte and character indexes into the returned
// string do not correspond to byte and character indexes into the buffer.
// Contrast with gtk.TextBuffer.GetSlice().
//
// The function takes the following parameters:
//
//   - start of a range.
//   - end of a range.
//   - includeHiddenChars: whether to include invisible text.
//
// The function returns the following values:
//
//   - utf8: allocated UTF-8 string.
func (buffer *TextBuffer) Text(start, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts len bytes of text at position iter.
//
// If len is -1, text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs in
// the default handler for the signal. iter is invalidated when insertion
// occurs (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
//
// The function takes the following parameters:
//
//   - iter: position in the buffer.
//   - text in UTF-8 format.
func (buffer *TextBuffer) Insert(iter *TextIter, text string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.int)(len(text))
	_arg2 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
}

// InsertAtCursor inserts text in buffer.
//
// Simply calls gtk.TextBuffer.Insert(), using the current cursor position as
// the insertion point.
//
// The function takes the following parameters:
//
//   - text in UTF-8 format.
func (buffer *TextBuffer) InsertAtCursor(text string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at iter.
//
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient alternative
// to this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
//
// The function takes the following parameters:
//
//   - iter: location to insert the anchor.
//   - anchor: GtkTextChildAnchor.
func (buffer *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// InsertInteractive inserts text in buffer.
//
// Like gtk.TextBuffer.Insert(), but the insertion will not occur if iter is at
// a non-editable location in the buffer. Usually you want to prevent insertions
// at ineditable locations if the insertion results from a user action (is
// interactive).
//
// default_editable indicates the editability of text that doesn't have
// a tag affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - text: some UTF-8 text.
//   - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//   - ok: whether text was actually inserted.
func (buffer *TextBuffer) InsertInteractive(iter *TextIter, text string, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int
	var _arg4 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.int)(len(text))
	_arg2 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg2))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor inserts text in buffer.
//
// Calls gtk.TextBuffer.InsertInteractive() at the cursor position.
//
// default_editable indicates the editability of text that doesn't have
// a tag affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//   - text in UTF-8 format.
//   - defaultEditable: default editability of buffer.
//
// The function returns the following values:
//
//   - ok: whether text was actually inserted.
func (buffer *TextBuffer) InsertInteractiveAtCursor(text string, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int
	var _arg3 C.gboolean // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in markup at position iter.
//
// markup will be inserted in its entirety and must be nul-terminated and valid
// UTF-8. Emits the gtk.TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. iter will
// point to the end of the inserted text on return.
//
// The function takes the following parameters:
//
//   - iter: location to insert the markup.
//   - markup: nul-terminated UTF-8 string containing Pango markup.
func (buffer *TextBuffer) InsertMarkup(iter *TextIter, markup string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (C.int)(len(markup))
	_arg2 = (*C.char)(C.calloc(C.size_t((len(markup) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg2)), len(markup)), markup)
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(markup)
}

// InsertPaintable inserts an image into the text buffer at iter.
//
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// The function takes the following parameters:
//
//   - iter: location to insert the paintable.
//   - paintable: GdkPaintable.
func (buffer *TextBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintabler) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	C.gtk_text_buffer_insert_paintable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(paintable)
}

// InsertRange copies text, tags, and paintables between start and end and
// inserts the copy at iter.
//
// The order of start and end doesn’t matter.
//
// Used instead of simply getting/inserting text because it preserves images and
// tags. If start and end are in a different buffer from buffer, the two buffers
// must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - start: position in a GtkTextBuffer.
//   - end: another position in the same buffer as start.
func (buffer *TextBuffer) InsertRange(iter, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// InsertRangeInteractive copies text, tags, and paintables between start and
// end and inserts the copy at iter.
//
// Same as gtk.TextBuffer.InsertRange(), but does nothing if the insertion point
// isn’t editable. The default_editable parameter indicates whether the text is
// editable at iter if no tags enclosing iter affect editability. Typically the
// result of gtk.TextView.GetEditable() is appropriate here.
//
// The function takes the following parameters:
//
//   - iter: position in buffer.
//   - start: position in a GtkTextBuffer.
//   - end: another position in the same buffer as start.
//   - defaultEditable: default editability of the buffer.
//
// The function returns the following values:
//
//   - ok: whether an insertion was possible at iter.
func (buffer *TextBuffer) InsertRangeInteractive(iter, start, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMark moves mark to the new location where.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the move.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark.
//   - where: new location for mark in buffer.
func (buffer *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// MoveMarkByName moves the mark named name (which must exist) to location
// where.
//
// See gtk.TextBuffer.MoveMark() for details.
//
// The function takes the following parameters:
//
//   - name of a mark.
//   - where: new location for mark.
func (buffer *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(where)
}

// PasteClipboard pastes the contents of a clipboard.
//
// If override_location is NULL, the pasted text will be inserted at the cursor
// position, or the buffer selection will be replaced if the selection is
// non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard to paste from.
//   - overrideLocation (optional): location to insert pasted text, or NULL.
//   - defaultEditable: whether the buffer is editable by default.
func (buffer *TextBuffer) PasteClipboard(clipboard *gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))
	if overrideLocation != nil {
		_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(overrideLocation)))
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(overrideLocation)
	runtime.KeepAlive(defaultEditable)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them to the same place in two steps with
// gtk.TextBuffer.MoveMark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
//
// The function takes the following parameters:
//
//   - where to put the cursor.
func (buffer *TextBuffer) PlaceCursor(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(where)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (buffer *TextBuffer) Redo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_redo(_arg0)
	runtime.KeepAlive(buffer)
}

// RemoveAllTags removes all tags in the range between start and end.
//
// Be careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that add
// tags.
//
// The function takes the following parameters:
//
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
func (buffer *TextBuffer) RemoveAllTags(start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveSelectionClipboard removes a GdkClipboard added with
// gtk_text_buffer_add_selection_clipboard().
//
// The function takes the following parameters:
//
//   - clipboard: GdkClipboard added to buffer by
//     gtk.TextBuffer.AddSelectionClipboard().
func (buffer *TextBuffer) RemoveSelectionClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// RemoveTag emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences of tag from the
// given range. start and end don’t have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
func (buffer *TextBuffer) RemoveTag(tag *TextTag, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveTagByName emits the “remove-tag” signal.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.RemoveTag().
//
// The function takes the following parameters:
//
//   - name of a GtkTextTag.
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
func (buffer *TextBuffer) RemoveTagByName(name string, start, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them in two steps with gtk.TextBuffer.MoveMark(), you will
// temporarily select a region in between their old and new locations, which
// can be pretty inefficient since the temporarily-selected region will force
// stuff to be recalculated. This function moves them as a unit, which can be
// optimized.
//
// The function takes the following parameters:
//
//   - ins: where to put the “insert” mark.
//   - bound: where to put the “selection_bound” mark.
func (buffer *TextBuffer) SelectRange(ins, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(ins)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(bound)))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ins)
	runtime.KeepAlive(bound)
}

// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer.
//
// If enabled, the user will be able to undo the last number of actions up to
// gtk.TextBuffer.GetMaxUndoLevels().
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
//
// The function takes the following parameters:
//
//   - enableUndo: TRUE to enable undo.
func (buffer *TextBuffer) SetEnableUndo(enableUndo bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_enable_undo(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(enableUndo)
}

// SetMaxUndoLevels sets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
//
// The function takes the following parameters:
//
//   - maxUndoLevels: maximum number of undo actions to perform.
func (buffer *TextBuffer) SetMaxUndoLevels(maxUndoLevels uint) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = C.guint(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(maxUndoLevels)
}

// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved.
//
// Whenever the buffer is saved to disk, call gtk_text_buffer_set_modified
// (buffer, FALSE). When the buffer is modified, it will automatically toggled
// on the modified bit again. When the modified bit flips, the buffer emits the
// gtk.TextBuffer::modified-changed signal.
//
// The function takes the following parameters:
//
//   - setting: modification flag setting.
func (buffer *TextBuffer) SetModified(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(setting)
}

// SetText deletes current contents of buffer, and inserts text instead.
//
// If len is -1, text must be nul-terminated. text must be valid UTF-8.
//
// The function takes the following parameters:
//
//   - text: UTF-8 text to insert.
func (buffer *TextBuffer) SetText(text string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg2 = (C.int)(len(text))
	_arg1 = (*C.char)(C.calloc(C.size_t((len(text) + 1)), C.size_t(C.sizeof_char)))
	copy(unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), len(text)), text)
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (buffer *TextBuffer) Undo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C.gtk_text_buffer_undo(_arg0)
	runtime.KeepAlive(buffer)
}

// applyTag emits the “apply-tag” signal on buffer.
//
// The default handler for the signal applies tag to the given range. start and
// end do not have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be tagged.
//   - end: other bound of range to be tagged.
func (buffer *TextBuffer) applyTag(tag *TextTag, start, end *TextIter) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.apply_tag

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C._gotk4_gtk4_TextBuffer_virtual_apply_tag(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// beginUserAction: called to indicate that the buffer operations between
// here and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when
// creating an undo stack. GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call
// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action” and
// “end-user-action” signals only for the outermost pair of calls. This allows
// you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user action
// around the buffer operations they perform, so there's no need to add extra
// calls if you user action consists solely of a single call to one of those
// functions.
func (buffer *TextBuffer) beginUserAction() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.begin_user_action

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_begin_user_action(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

func (buffer *TextBuffer) changed() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.changed

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// The function takes the following parameters:
//
//   - start
//   - end
func (buffer *TextBuffer) deleteRange(start, end *TextIter) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.delete_range

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C._gotk4_gtk4_TextBuffer_virtual_delete_range(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// endUserAction ends a user-visible operation.
//
// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See that
// function for a full explanation.
func (buffer *TextBuffer) endUserAction() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.end_user_action

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_end_user_action(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// insertChildAnchor inserts a child widget anchor into the text buffer at iter.
//
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient alternative
// to this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
//
// The function takes the following parameters:
//
//   - iter: location to insert the anchor.
//   - anchor: GtkTextChildAnchor.
func (buffer *TextBuffer) insertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.insert_child_anchor

	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_insert_child_anchor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// insertPaintable inserts an image into the text buffer at iter.
//
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// The function takes the following parameters:
//
//   - iter: location to insert the paintable.
//   - paintable: GdkPaintable.
func (buffer *TextBuffer) insertPaintable(iter *TextIter, paintable gdk.Paintabler) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.insert_paintable

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_insert_paintable(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(paintable)
}

// The function takes the following parameters:
//
//   - pos
//   - newText
//   - newTextLength
func (buffer *TextBuffer) insertText(pos *TextIter, newText string, newTextLength int) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.insert_text

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(pos)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(newText)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(newTextLength)

	C._gotk4_gtk4_TextBuffer_virtual_insert_text(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(pos)
	runtime.KeepAlive(newText)
	runtime.KeepAlive(newTextLength)
}

func (buffer *TextBuffer) markDeleted(mark *TextMark) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.mark_deleted

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_mark_deleted(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// The function takes the following parameters:
//
//   - location
//   - mark
func (buffer *TextBuffer) markSet(location *TextIter, mark *TextMark) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.mark_set

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(location)))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_mark_set(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(location)
	runtime.KeepAlive(mark)
}

func (buffer *TextBuffer) modifiedChanged() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.modified_changed

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_modified_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

func (buffer *TextBuffer) pasteDone(clipboard *gdk.Clipboard) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.paste_done

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(coreglib.InternObject(clipboard).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_paste_done(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (buffer *TextBuffer) redo() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.redo

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_redo(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// removeTag emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences of tag from the
// given range. start and end don’t have to be in order.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//   - start: one bound of range to be untagged.
//   - end: other bound of range to be untagged.
func (buffer *TextBuffer) removeTag(tag *TextTag, start, end *TextIter) {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.remove_tag

	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C._gotk4_gtk4_TextBuffer_virtual_remove_tag(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (buffer *TextBuffer) undo() {
	gclass := (*C.GtkTextBufferClass)(coreglib.PeekParentClass(buffer))
	fnarg := gclass.undo

	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	C._gotk4_gtk4_TextBuffer_virtual_undo(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(buffer)
}

// TextChildAnchorOverrides contains methods that are overridable.
type TextChildAnchorOverrides struct {
}

func defaultTextChildAnchorOverrides(v *TextChildAnchor) TextChildAnchorOverrides {
	return TextChildAnchorOverrides{}
}

// TextChildAnchor: GtkTextChildAnchor is a spot in a GtkTextBuffer where child
// widgets can be “anchored”.
//
// The anchor can have multiple widgets anchored, to allow for multiple views.
type TextChildAnchor struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextChildAnchor)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextChildAnchor, *TextChildAnchorClass, TextChildAnchorOverrides](
		GTypeTextChildAnchor,
		initTextChildAnchorClass,
		wrapTextChildAnchor,
		defaultTextChildAnchorOverrides,
	)
}

func initTextChildAnchorClass(gclass unsafe.Pointer, overrides TextChildAnchorOverrides, classInitFunc func(*TextChildAnchorClass)) {
	if classInitFunc != nil {
		class := (*TextChildAnchorClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextChildAnchor(obj *coreglib.Object) *TextChildAnchor {
	return &TextChildAnchor{
		Object: obj,
	}
}

func marshalTextChildAnchor(p uintptr) (interface{}, error) {
	return wrapTextChildAnchor(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTextChildAnchor creates a new GtkTextChildAnchor.
//
// Usually you would then insert it into a GtkTextBuffer with
// gtk.TextBuffer.InsertChildAnchor(). To perform the creation and insertion in
// one step, use the convenience function gtk.TextBuffer.CreateChildAnchor().
//
// The function returns the following values:
//
//   - textChildAnchor: new GtkTextChildAnchor.
func NewTextChildAnchor() *TextChildAnchor {
	var _cret *C.GtkTextChildAnchor // in

	_cret = C.gtk_text_child_anchor_new()

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// Deleted determines whether a child anchor has been deleted from the buffer.
//
// Keep in mind that the child anchor will be unreferenced when removed from the
// buffer, so you need to hold your own reference (with g_object_ref()) if you
// plan to use this function — otherwise all deleted child anchors will also be
// finalized.
//
// The function returns the following values:
//
//   - ok: TRUE if the child anchor has been deleted from its buffer.
func (anchor *TextChildAnchor) Deleted() bool {
	var _arg0 *C.GtkTextChildAnchor // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	_cret = C.gtk_text_child_anchor_get_deleted(_arg0)
	runtime.KeepAlive(anchor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Widgets gets a list of all widgets anchored at this child anchor.
//
// The order in which the widgets are returned is not defined.
//
// The function returns the following values:
//
//   - widgets: an array of widgets anchored at anchor.
func (anchor *TextChildAnchor) Widgets() []Widgetter {
	var _arg0 *C.GtkTextChildAnchor // out
	var _cret **C.GtkWidget         // in
	var _arg1 C.guint               // in

	_arg0 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	_cret = C.gtk_text_child_anchor_get_widgets(_arg0, &_arg1)
	runtime.KeepAlive(anchor)

	var _widgets []Widgetter // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.GtkWidget)(_cret), _arg1)
		_widgets = make([]Widgetter, _arg1)
		for i := 0; i < int(_arg1); i++ {
			{
				objptr := unsafe.Pointer(src[i])
				if objptr == nil {
					panic("object of type gtk.Widgetter is nil")
				}

				object := coreglib.Take(objptr)
				casted := object.WalkCast(func(obj coreglib.Objector) bool {
					_, ok := obj.(Widgetter)
					return ok
				})
				rv, ok := casted.(Widgetter)
				if !ok {
					panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
				}
				_widgets[i] = rv
			}
		}
	}

	return _widgets
}

// TextMarkOverrides contains methods that are overridable.
type TextMarkOverrides struct {
}

func defaultTextMarkOverrides(v *TextMark) TextMarkOverrides {
	return TextMarkOverrides{}
}

// TextMark: GtkTextMark is a position in a GtkTextbuffer that is preserved
// across modifications.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// A GtkTextMark is like a bookmark in a text buffer; it preserves a
// position in the text. You can convert the mark to an iterator using
// gtk.TextBuffer.GetIterAtMark(). Unlike iterators, marks remain valid across
// buffer mutations, because their behavior is defined when text is inserted
// or deleted. When text containing a mark is deleted, the mark remains in the
// position originally occupied by the deleted text. When text is inserted at
// a mark, a mark with “left gravity” will be moved to the beginning of the
// newly-inserted text, and a mark with “right gravity” will be moved to the
// end.
//
// Note that “left” and “right” here refer to logical direction (left is
// the toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
//
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time
// with gtk.TextBuffer.DeleteMark(). Once deleted from the buffer, a mark is
// essentially useless.
//
// Marks optionally have names; these can be convenient to avoid passing the
// GtkTextMark object around.
//
// Marks are typically created using the gtk.TextBuffer.CreateMark() function.
type TextMark struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextMark)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextMark, *TextMarkClass, TextMarkOverrides](
		GTypeTextMark,
		initTextMarkClass,
		wrapTextMark,
		defaultTextMarkOverrides,
	)
}

func initTextMarkClass(gclass unsafe.Pointer, overrides TextMarkOverrides, classInitFunc func(*TextMarkClass)) {
	if classInitFunc != nil {
		class := (*TextMarkClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextMark(obj *coreglib.Object) *TextMark {
	return &TextMark{
		Object: obj,
	}
}

func marshalTextMark(p uintptr) (interface{}, error) {
	return wrapTextMark(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTextMark creates a text mark.
//
// Add it to a buffer using gtk.TextBuffer.AddMark(). If name is NULL,
// the mark is anonymous; otherwise, the mark can be retrieved by name using
// gtk.TextBuffer.GetMark(). If a mark has left gravity, and text is inserted
// at the mark’s current location, the mark will be moved to the left of the
// newly-inserted text. If the mark has right gravity (left_gravity = FALSE),
// the mark will end up on the right of newly-inserted text. The standard
// left-to-right cursor is a mark with right gravity (when you type, the cursor
// stays on the right side of the text you’re typing).
//
// The function takes the following parameters:
//
//   - name (optional): mark name or NULL.
//   - leftGravity: whether the mark should have left gravity.
//
// The function returns the following values:
//
//   - textMark: new GtkTextMark.
func NewTextMark(name string, leftGravity bool) *TextMark {
	var _arg1 *C.char        // out
	var _arg2 C.gboolean     // out
	var _cret *C.GtkTextMark // in

	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	if leftGravity {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_mark_new(_arg1, _arg2)
	runtime.KeepAlive(name)
	runtime.KeepAlive(leftGravity)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textMark
}

// Buffer gets the buffer this mark is located inside.
//
// Returns NULL if the mark is deleted.
//
// The function returns the following values:
//
//   - textBuffer mark’s GtkTextBuffer.
func (mark *TextMark) Buffer() *TextBuffer {
	var _arg0 *C.GtkTextMark   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	_cret = C.gtk_text_mark_get_buffer(_arg0)
	runtime.KeepAlive(mark)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// Deleted returns TRUE if the mark has been removed from its buffer.
//
// See gtk.TextBuffer.AddMark() for a way to add it to a buffer again.
//
// The function returns the following values:
//
//   - ok: whether the mark is deleted.
func (mark *TextMark) Deleted() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	_cret = C.gtk_text_mark_get_deleted(_arg0)
	runtime.KeepAlive(mark)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LeftGravity determines whether the mark has left gravity.
//
// The function returns the following values:
//
//   - ok: TRUE if the mark has left gravity, FALSE otherwise.
func (mark *TextMark) LeftGravity() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	_cret = C.gtk_text_mark_get_left_gravity(_arg0)
	runtime.KeepAlive(mark)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Name returns the mark name.
//
// Returns NULL for anonymous marks.
//
// The function returns the following values:
//
//   - utf8 (optional): mark name.
func (mark *TextMark) Name() string {
	var _arg0 *C.GtkTextMark // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	_cret = C.gtk_text_mark_get_name(_arg0)
	runtime.KeepAlive(mark)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Visible returns TRUE if the mark is visible.
//
// A cursor is displayed for visible marks.
//
// The function returns the following values:
//
//   - ok: TRUE if visible.
func (mark *TextMark) Visible() bool {
	var _arg0 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	_cret = C.gtk_text_mark_get_visible(_arg0)
	runtime.KeepAlive(mark)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (mark *TextMark) SetVisible(setting bool) {
	var _arg0 *C.GtkTextMark // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_mark_set_visible(_arg0, _arg1)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(setting)
}

// TextTagOverrides contains methods that are overridable.
type TextTagOverrides struct {
}

func defaultTextTagOverrides(v *TextTag) TextTagOverrides {
	return TextTagOverrides{}
}

// TextTag: tag that can be applied to text contained in a GtkTextBuffer.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// Tags should be in the gtk.TextTagTable for a given GtkTextBuffer before using
// them with that buffer.
//
// gtk.TextBuffer.CreateTag() is the best way to create tags. See “gtk4-demo”
// for numerous examples.
//
// For each property of GtkTextTag, there is a “set” property, e.g. “font-set”
// corresponds to “font”. These “set” properties reflect whether a property has
// been set or not.
//
// They are maintained by GTK and you should not set them independently.
type TextTag struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TextTag)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextTag, *TextTagClass, TextTagOverrides](
		GTypeTextTag,
		initTextTagClass,
		wrapTextTag,
		defaultTextTagOverrides,
	)
}

func initTextTagClass(gclass unsafe.Pointer, overrides TextTagOverrides, classInitFunc func(*TextTagClass)) {
	if classInitFunc != nil {
		class := (*TextTagClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextTag(obj *coreglib.Object) *TextTag {
	return &TextTag{
		Object: obj,
	}
}

func marshalTextTag(p uintptr) (interface{}, error) {
	return wrapTextTag(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTextTag creates a GtkTextTag.
//
// The function takes the following parameters:
//
//   - name (optional): tag name, or NULL.
//
// The function returns the following values:
//
//   - textTag: new GtkTextTag.
func NewTextTag(name string) *TextTag {
	var _arg1 *C.char       // out
	var _cret *C.GtkTextTag // in

	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_text_tag_new(_arg1)
	runtime.KeepAlive(name)

	var _textTag *TextTag // out

	_textTag = wrapTextTag(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textTag
}

// Changed emits the gtk.TextTagTable::tag-changed signal on the GtkTextTagTable
// where the tag is included.
//
// The signal is already emitted when setting a GtkTextTag property. This
// function is useful for a GtkTextTag subclass.
//
// The function takes the following parameters:
//
//   - sizeChanged: whether the change affects the GtkTextView layout.
func (tag *TextTag) Changed(sizeChanged bool) {
	var _arg0 *C.GtkTextTag // out
	var _arg1 C.gboolean    // out

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	if sizeChanged {
		_arg1 = C.TRUE
	}

	C.gtk_text_tag_changed(_arg0, _arg1)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(sizeChanged)
}

// Priority: get the tag priority.
//
// The function returns the following values:
//
//   - gint tag’s priority.
func (tag *TextTag) Priority() int {
	var _arg0 *C.GtkTextTag // out
	var _cret C.int         // in

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))

	_cret = C.gtk_text_tag_get_priority(_arg0)
	runtime.KeepAlive(tag)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SetPriority sets the priority of a GtkTextTag.
//
// Valid priorities start at 0 and go to one less than
// gtk.TextTagTable.GetSize(). Each tag in a table has a unique priority;
// setting the priority of one tag shifts the priorities of all the other tags
// in the table to maintain a unique priority for each tag.
//
// Higher priority tags “win” if two tags both set the same text attribute.
// When adding a tag to a tag table, it will be assigned the highest priority
// in the table by default; so normally the precedence of a set of tags
// is the order in which they were added to the table, or created with
// gtk.TextBuffer.CreateTag(), which adds the tag to the buffer’s table
// automatically.
//
// The function takes the following parameters:
//
//   - priority: new priority.
func (tag *TextTag) SetPriority(priority int) {
	var _arg0 *C.GtkTextTag // out
	var _arg1 C.int         // out

	_arg0 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	_arg1 = C.int(priority)

	C.gtk_text_tag_set_priority(_arg0, _arg1)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(priority)
}

// TextTagTable: collection of tags in a GtkTextBuffer
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// # GtkTextTagTables as GtkBuildable
//
// The GtkTextTagTable implementation of the GtkBuildable interface supports
// adding tags by specifying “tag” as the “type” attribute of a <child> element.
//
// An example of a UI definition fragment specifying tags:
//
//	<object class="GtkTextTagTable">
//	 <child type="tag">
//	   <object class="GtkTextTag"/>
//	 </child>
//	</object>.
type TextTagTable struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
}

var (
	_ coreglib.Objector = (*TextTagTable)(nil)
)

func wrapTextTagTable(obj *coreglib.Object) *TextTagTable {
	return &TextTagTable{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
	}
}

func marshalTextTagTable(p uintptr) (interface{}, error) {
	return wrapTextTagTable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectTagAdded is emitted every time a new tag is added in the
// GtkTextTagTable.
func (table *TextTagTable) ConnectTagAdded(f func(tag *TextTag)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(table, "tag-added", false, unsafe.Pointer(C._gotk4_gtk4_TextTagTable_ConnectTagAdded), f)
}

// ConnectTagChanged is emitted every time a tag in the GtkTextTagTable changes.
func (table *TextTagTable) ConnectTagChanged(f func(tag *TextTag, sizeChanged bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(table, "tag-changed", false, unsafe.Pointer(C._gotk4_gtk4_TextTagTable_ConnectTagChanged), f)
}

// ConnectTagRemoved is emitted every time a tag is removed from the
// GtkTextTagTable.
//
// The tag is still valid by the time the signal is emitted, but it is not
// associated with a tag table any more.
func (table *TextTagTable) ConnectTagRemoved(f func(tag *TextTag)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(table, "tag-removed", false, unsafe.Pointer(C._gotk4_gtk4_TextTagTable_ConnectTagRemoved), f)
}

// NewTextTagTable creates a new GtkTextTagTable.
//
// The table contains no tags by default.
//
// The function returns the following values:
//
//   - textTagTable: new GtkTextTagTable.
func NewTextTagTable() *TextTagTable {
	var _cret *C.GtkTextTagTable // in

	_cret = C.gtk_text_tag_table_new()

	var _textTagTable *TextTagTable // out

	_textTagTable = wrapTextTagTable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Add a tag to the table.
//
// The tag is assigned the highest priority in the table.
//
// tag must not be in a tag table already, and may not have the same name as an
// already-added tag.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//
// The function returns the following values:
//
//   - ok: TRUE on success.
func (table *TextTagTable) Add(tag *TextTag) bool {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.GtkTextTag      // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))

	_cret = C.gtk_text_tag_table_add(_arg0, _arg1)
	runtime.KeepAlive(table)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForEach calls func on each tag in table, with user data data.
//
// Note that the table may not be modified while iterating over it (you can’t
// add/remove tags).
//
// The function takes the following parameters:
//
//   - fn: function to call on each tag.
func (table *TextTagTable) ForEach(fn TextTagTableForEach) {
	var _arg0 *C.GtkTextTagTable       // out
	var _arg1 C.GtkTextTagTableForeach // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TextTagTableForEach)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_text_tag_table_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(table)
	runtime.KeepAlive(fn)
}

// Size returns the size of the table (number of tags).
//
// The function returns the following values:
//
//   - gint: number of tags in table.
func (table *TextTagTable) Size() int {
	var _arg0 *C.GtkTextTagTable // out
	var _cret C.int              // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(coreglib.InternObject(table).Native()))

	_cret = C.gtk_text_tag_table_get_size(_arg0)
	runtime.KeepAlive(table)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Lookup: look up a named tag.
//
// The function takes the following parameters:
//
//   - name of a tag.
//
// The function returns the following values:
//
//   - textTag (optional): tag, or NULL if none by that name is in the table.
func (table *TextTagTable) Lookup(name string) *TextTag {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.char            // out
	var _cret *C.GtkTextTag      // in

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_tag_table_lookup(_arg0, _arg1)
	runtime.KeepAlive(table)
	runtime.KeepAlive(name)

	var _textTag *TextTag // out

	if _cret != nil {
		_textTag = wrapTextTag(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _textTag
}

// Remove a tag from the table.
//
// If a GtkTextBuffer has table as its tag table, the tag is removed from the
// buffer. The table’s reference to the tag is removed, so the tag will end up
// destroyed if you don’t have a reference to it.
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
func (table *TextTagTable) Remove(tag *TextTag) {
	var _arg0 *C.GtkTextTagTable // out
	var _arg1 *C.GtkTextTag      // out

	_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(coreglib.InternObject(table).Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))

	C.gtk_text_tag_table_remove(_arg0, _arg1)
	runtime.KeepAlive(table)
	runtime.KeepAlive(tag)
}

// TextViewOverrides contains methods that are overridable.
type TextViewOverrides struct {
	Backspace     func()
	CopyClipboard func()
	CutClipboard  func()
	// The function takes the following parameters:
	//
	//   - typ
	//   - count
	DeleteFromCursor func(typ DeleteType, count int)
	// The function takes the following parameters:
	//
	//   - granularity
	//   - location
	//   - start
	//   - end
	ExtendSelection func(granularity TextExtendSelection, location, start, end *TextIter) bool
	InsertAtCursor  func(str string)
	InsertEmoji     func()
	// The function takes the following parameters:
	//
	//   - step
	//   - count
	//   - extendSelection
	MoveCursor     func(step MovementStep, count int, extendSelection bool)
	PasteClipboard func()
	SetAnchor      func()
	// The function takes the following parameters:
	//
	//   - layer
	//   - snapshot
	SnapshotLayer   func(layer TextViewLayer, snapshot *Snapshot)
	ToggleOverwrite func()
}

func defaultTextViewOverrides(v *TextView) TextViewOverrides {
	return TextViewOverrides{
		Backspace:        v.backspace,
		CopyClipboard:    v.copyClipboard,
		CutClipboard:     v.cutClipboard,
		DeleteFromCursor: v.deleteFromCursor,
		ExtendSelection:  v.extendSelection,
		InsertAtCursor:   v.insertAtCursor,
		InsertEmoji:      v.insertEmoji,
		MoveCursor:       v.moveCursor,
		PasteClipboard:   v.pasteClipboard,
		SetAnchor:        v.setAnchor,
		SnapshotLayer:    v.snapshotLayer,
		ToggleOverwrite:  v.toggleOverwrite,
	}
}

// TextView: widget that displays the contents of a gtk.TextBuffer.
//
// !An example GtkTextview (multiline-text.png)
//
// You may wish to begin by reading the conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// CSS nodes
//
//	textview.view
//	├── border.top
//	├── border.left
//	├── text
//	│   ╰── [selection]
//	├── border.right
//	├── border.bottom
//	╰── [window.popup]
//
// GtkTextView has a main css node with name textview and style class .view,
// and subnodes for each of the border windows, and the main text area,
// with names border and text, respectively. The border nodes each get one of
// the style classes .left, .right, .top or .bottom.
//
// A node representing the selection will appear below the text node.
//
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
//
// # Accessibility
//
// GtkTextView uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
type TextView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*TextView)(nil)
	_ coreglib.Objector = (*TextView)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TextView, *TextViewClass, TextViewOverrides](
		GTypeTextView,
		initTextViewClass,
		wrapTextView,
		defaultTextViewOverrides,
	)
}

func initTextViewClass(gclass unsafe.Pointer, overrides TextViewOverrides, classInitFunc func(*TextViewClass)) {
	pclass := (*C.GtkTextViewClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTextView))))

	if overrides.Backspace != nil {
		pclass.backspace = (*[0]byte)(C._gotk4_gtk4_TextViewClass_backspace)
	}

	if overrides.CopyClipboard != nil {
		pclass.copy_clipboard = (*[0]byte)(C._gotk4_gtk4_TextViewClass_copy_clipboard)
	}

	if overrides.CutClipboard != nil {
		pclass.cut_clipboard = (*[0]byte)(C._gotk4_gtk4_TextViewClass_cut_clipboard)
	}

	if overrides.DeleteFromCursor != nil {
		pclass.delete_from_cursor = (*[0]byte)(C._gotk4_gtk4_TextViewClass_delete_from_cursor)
	}

	if overrides.ExtendSelection != nil {
		pclass.extend_selection = (*[0]byte)(C._gotk4_gtk4_TextViewClass_extend_selection)
	}

	if overrides.InsertAtCursor != nil {
		pclass.insert_at_cursor = (*[0]byte)(C._gotk4_gtk4_TextViewClass_insert_at_cursor)
	}

	if overrides.InsertEmoji != nil {
		pclass.insert_emoji = (*[0]byte)(C._gotk4_gtk4_TextViewClass_insert_emoji)
	}

	if overrides.MoveCursor != nil {
		pclass.move_cursor = (*[0]byte)(C._gotk4_gtk4_TextViewClass_move_cursor)
	}

	if overrides.PasteClipboard != nil {
		pclass.paste_clipboard = (*[0]byte)(C._gotk4_gtk4_TextViewClass_paste_clipboard)
	}

	if overrides.SetAnchor != nil {
		pclass.set_anchor = (*[0]byte)(C._gotk4_gtk4_TextViewClass_set_anchor)
	}

	if overrides.SnapshotLayer != nil {
		pclass.snapshot_layer = (*[0]byte)(C._gotk4_gtk4_TextViewClass_snapshot_layer)
	}

	if overrides.ToggleOverwrite != nil {
		pclass.toggle_overwrite = (*[0]byte)(C._gotk4_gtk4_TextViewClass_toggle_overwrite)
	}

	if classInitFunc != nil {
		class := (*TextViewClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTextView(obj *coreglib.Object) *TextView {
	return &TextView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTextView(p uintptr) (interface{}, error) {
	return wrapTextView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectBackspace gets emitted when the user asks for it.
//
// The ::backspace signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Backspace</kbd> and
// <kbd>Shift</kbd>-<kbd>Backspace</kbd>.
func (textView *TextView) ConnectBackspace(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "backspace", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectBackspace), f)
}

// ConnectCopyClipboard gets emitted to copy the selection to the clipboard.
//
// The ::copy-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>c</kbd> and
// <kbd>Ctrl</kbd>-<kbd>Insert</kbd>.
func (textView *TextView) ConnectCopyClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "copy-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectCopyClipboard), f)
}

// ConnectCutClipboard gets emitted to cut the selection to the clipboard.
//
// The ::cut-clipboard signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>x</kbd> and
// <kbd>Shift</kbd>-<kbd>Delete</kbd>.
func (textView *TextView) ConnectCutClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "cut-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectCutClipboard), f)
}

// ConnectDeleteFromCursor gets emitted when the user initiates a text deletion.
//
// The ::delete-from-cursor signal is a keybinding signal
// (class.SignalAction.html).
//
// If the type is GTK_DELETE_CHARS, GTK deletes the selection if there is one,
// otherwise it deletes the requested number of characters.
//
// The default bindings for this signal are <kbd>Delete</kbd> for deleting
// a character, <kbd>Ctrl</kbd>-<kbd>Delete</kbd> for deleting a word and
// <kbd>Ctrl</kbd>-<kbd>Backspace</kbd> for deleting a word backwards.
func (textView *TextView) ConnectDeleteFromCursor(f func(typ DeleteType, count int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "delete-from-cursor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectDeleteFromCursor), f)
}

// ConnectExtendSelection is emitted when the selection needs to be extended at
// location.
func (textView *TextView) ConnectExtendSelection(f func(granularity TextExtendSelection, location, start, end *TextIter) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "extend-selection", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectExtendSelection), f)
}

// ConnectInsertAtCursor gets emitted when the user initiates the insertion of a
// fixed string at the cursor.
//
// The ::insert-at-cursor signal is a keybinding signal
// (class.SignalAction.html).
//
// This signal has no default bindings.
func (textView *TextView) ConnectInsertAtCursor(f func(str string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "insert-at-cursor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectInsertAtCursor), f)
}

// ConnectInsertEmoji gets emitted to present the Emoji chooser for the
// text_view.
//
// The ::insert-emoji signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>.</kbd> and
// <kbd>Ctrl</kbd>-<kbd>;</kbd>.
func (textView *TextView) ConnectInsertEmoji(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "insert-emoji", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectInsertEmoji), f)
}

// ConnectMoveCursor gets emitted when the user initiates a cursor movement.
//
// The ::move-cursor signal is a keybinding signal (class.SignalAction.html).
// If the cursor is not visible in text_view, this signal causes the viewport to
// be moved instead.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor programmatically.
//
//	The default bindings for this signal come in two variants, the variant with the <kbd>Shift</kbd> modifier extends the selection, the variant without it does not. There are too many key combinations to list them all here.
//
// - <kbd>←</kbd>, <kbd>→</kbd>, <kbd>↑</kbd>, <kbd>↓</kbd> move by individual
// characters/lines
//
// - <kbd>Ctrl</kbd>-<kbd>→</kbd>, etc. move by words/paragraphs
//
// - <kbd>Home</kbd>, <kbd>End</kbd> move to the ends of the buffer
//
// - <kbd>PgUp</kbd>, <kbd>PgDn</kbd> move vertically by pages
//
// - <kbd>Ctrl</kbd>-<kbd>PgUp</kbd>, <kbd>Ctrl</kbd>-<kbd>PgDn</kbd> move
// horizontally by pages.
func (textView *TextView) ConnectMoveCursor(f func(step MovementStep, count int, extendSelection bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectMoveCursor), f)
}

// ConnectMoveViewport gets emitted to move the viewport.
//
// The ::move-viewport signal is a keybinding signal (class.SignalAction.html),
// which can be bound to key combinations to allow the user to move the
// viewport, i.e. change what part of the text view is visible in a containing
// scrolled window.
//
// There are no default bindings for this signal.
func (textView *TextView) ConnectMoveViewport(f func(step ScrollStep, count int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "move-viewport", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectMoveViewport), f)
}

// ConnectPasteClipboard gets emitted to paste the contents of the clipboard
// into the text view.
//
// The ::paste-clipboard signal is a keybinding signal
// (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>v</kbd> and
// <kbd>Shift</kbd>-<kbd>Insert</kbd>.
func (textView *TextView) ConnectPasteClipboard(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "paste-clipboard", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectPasteClipboard), f)
}

// ConnectPreeditChanged is emitted when preedit text of the active IM changes.
//
// If an input method is used, the typed text will not immediately be committed
// to the buffer. So if you are interested in the text, connect to this signal.
//
// This signal is only emitted if the text at the given position is actually
// editable.
func (textView *TextView) ConnectPreeditChanged(f func(preedit string)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "preedit-changed", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectPreeditChanged), f)
}

// ConnectSelectAll gets emitted to select or unselect the complete contents of
// the text view.
//
// The ::select-all signal is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are <kbd>Ctrl</kbd>-<kbd>a</kbd>
// and <kbd>Ctrl</kbd>-<kbd>/</kbd> for selecting and
// <kbd>Shift</kbd>-<kbd>Ctrl</kbd>-<kbd>a</kbd> and
// <kbd>Ctrl</kbd>-<kbd>\</kbd> for unselecting.
func (textView *TextView) ConnectSelectAll(f func(sel bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectSelectAll), f)
}

// ConnectSetAnchor gets emitted when the user initiates settings the "anchor"
// mark.
//
// The ::set-anchor signal is a keybinding signal (class.SignalAction.html)
// which gets emitted when the user initiates setting the "anchor" mark.
// The "anchor" mark gets placed at the same position as the "insert" mark.
//
// This signal has no default bindings.
func (textView *TextView) ConnectSetAnchor(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "set-anchor", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectSetAnchor), f)
}

// ConnectToggleCursorVisible gets emitted to toggle the cursor-visible
// property.
//
// The ::toggle-cursor-visible signal is a keybinding signal
// (class.SignalAction.html).
//
// The default binding for this signal is <kbd>F7</kbd>.
func (textView *TextView) ConnectToggleCursorVisible(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "toggle-cursor-visible", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectToggleCursorVisible), f)
}

// ConnectToggleOverwrite gets emitted to toggle the overwrite mode of the text
// view.
//
// The ::toggle-overwrite signal is a keybinding signal
// (class.SignalAction.html).
//
// The default binding for this signal is <kbd>Insert</kbd>.
func (textView *TextView) ConnectToggleOverwrite(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(textView, "toggle-overwrite", false, unsafe.Pointer(C._gotk4_gtk4_TextView_ConnectToggleOverwrite), f)
}

// NewTextView creates a new GtkTextView.
//
// If you don’t call gtk.TextView.SetBuffer() before using the text view,
// an empty default buffer will be created for you. Get the buffer with
// gtk.TextView.GetBuffer(). If you want to specify your own buffer, consider
// gtk.TextView.NewWithBuffer.
//
// The function returns the following values:
//
//   - textView: new GtkTextView.
func NewTextView() *TextView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_view_new()

	var _textView *TextView // out

	_textView = wrapTextView(coreglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// NewTextViewWithBuffer creates a new GtkTextView widget displaying the buffer
// buffer.
//
// One buffer can be shared among many widgets. buffer may be NULL to
// create a default buffer, in which case this function is equivalent to
// gtk.TextView.New. The text view adds its own reference count to the buffer;
// it does not take over an existing reference.
//
// The function takes the following parameters:
//
//   - buffer: GtkTextBuffer.
//
// The function returns the following values:
//
//   - textView: new GtkTextView.
func NewTextViewWithBuffer(buffer *TextBuffer) *TextView {
	var _arg1 *C.GtkTextBuffer // out
	var _cret *C.GtkWidget     // in

	_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))

	_cret = C.gtk_text_view_new_with_buffer(_arg1)
	runtime.KeepAlive(buffer)

	var _textView *TextView // out

	_textView = wrapTextView(coreglib.Take(unsafe.Pointer(_cret)))

	return _textView
}

// AddChildAtAnchor adds a child widget in the text buffer, at the given anchor.
//
// The function takes the following parameters:
//
//   - child: GtkWidget.
//   - anchor: GtkTextChildAnchor in the GtkTextBuffer for text_view.
func (textView *TextView) AddChildAtAnchor(child Widgetter, anchor *TextChildAnchor) {
	var _arg0 *C.GtkTextView        // out
	var _arg1 *C.GtkWidget          // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(coreglib.InternObject(anchor).Native()))

	C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(anchor)
}

// AddOverlay adds child at a fixed coordinate in the GtkTextView's text window.
//
// The xpos and ypos must be in buffer coordinates (see
// gtk.TextView.GetIterLocation() to convert to buffer coordinates).
//
// child will scroll with the text view.
//
// If instead you want a widget that will not move with the GtkTextView contents
// see Overlay.
//
// The function takes the following parameters:
//
//   - child: Widget.
//   - xpos: x position of child in window coordinates.
//   - ypos: y position of child in window coordinates.
func (textView *TextView) AddOverlay(child Widgetter, xpos, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)

	C.gtk_text_view_add_overlay(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// BackwardDisplayLine moves the given iter backward by one display (wrapped)
// line.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//
// The function returns the following values:
//
//   - ok: TRUE if iter was moved and is not on the end iterator.
func (textView *TextView) BackwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardDisplayLineStart moves the given iter backward to the next display
// line start.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//
// The function returns the following values:
//
//   - ok: TRUE if iter was moved and is not on the end iterator.
func (textView *TextView) BackwardDisplayLineStart(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BufferToWindowCoords converts buffer coordinates to window coordinates.
//
// The function takes the following parameters:
//
//   - win: TextWindowType.
//   - bufferX: buffer x coordinate.
//   - bufferY: buffer y coordinate.
//
// The function returns the following values:
//
//   - windowX (optional): window x coordinate return location or NULL.
//   - windowY (optional): window y coordinate return location or NULL.
func (textView *TextView) BufferToWindowCoords(win TextWindowType, bufferX, bufferY int) (windowX, windowY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.int(bufferX)
	_arg3 = C.int(bufferY)

	C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(bufferX)
	runtime.KeepAlive(bufferY)

	var _windowX int // out
	var _windowY int // out

	_windowX = int(_arg4)
	_windowY = int(_arg5)

	return _windowX, _windowY
}

// ForwardDisplayLine moves the given iter forward by one display (wrapped)
// line.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//
// The function returns the following values:
//
//   - ok: TRUE if iter was moved and is not on the end iterator.
func (textView *TextView) ForwardDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardDisplayLineEnd moves the given iter forward to the next display line
// end.
//
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the view’s width; paragraphs are the same in all
// views, since they depend on the contents of the GtkTextBuffer.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//
// The function returns the following values:
//
//   - ok: TRUE if iter was moved and is not on the end iterator.
func (textView *TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
//
// See gtk.TextView.SetAcceptsTab().
//
// The function returns the following values:
//
//   - ok: TRUE if pressing the Tab key inserts a tab character, FALSE if
//     pressing the Tab key moves the keyboard focus.
func (textView *TextView) AcceptsTab() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_accepts_tab(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BottomMargin gets the bottom margin for text in the text_view.
//
// The function returns the following values:
//
//   - gint: bottom margin in pixels.
func (textView *TextView) BottomMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_bottom_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Buffer returns the GtkTextBuffer being displayed by this text view.
//
// The reference count on the buffer is not incremented; the caller of this
// function won’t own a new reference.
//
// The function returns the following values:
//
//   - textBuffer: GtkTextBuffer.
func (textView *TextView) Buffer() *TextBuffer {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_buffer(_arg0)
	runtime.KeepAlive(textView)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// CursorLocations: determine the positions of the strong and weak cursors if
// the insertion point is at iter.
//
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the paragraph are inserted. The weak cursor location
// is the location where characters of the directionality opposite to the base
// direction of the paragraph are inserted.
//
// If iter is NULL, the actual cursor position is used.
//
// Note that if iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations will
// be adjusted to account for the preedit cursor’s offset within the preedit
// sequence.
//
// The rectangle position is in buffer coordinates; use
// gtk.TextView.BufferToWindowCoords() to convert these coordinates to
// coordinates for one of the windows in the text view.
//
// The function takes the following parameters:
//
//   - iter (optional): GtkTextIter.
//
// The function returns the following values:
//
//   - strong (optional): location to store the strong cursor position (may be
//     NULL).
//   - weak (optional): location to store the weak cursor position (may be
//     NULL).
func (textView *TextView) CursorLocations(iter *TextIter) (strong, weak *gdk.Rectangle) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in
	var _arg3 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if iter != nil {
		_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	}

	C.gtk_text_view_get_cursor_locations(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _strong *gdk.Rectangle // out
	var _weak *gdk.Rectangle   // out

	_strong = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	_weak = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _strong, _weak
}

// CursorVisible: find out whether the cursor should be displayed.
//
// The function returns the following values:
//
//   - ok: whether the insertion mark is visible.
func (textView *TextView) CursorVisible() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_cursor_visible(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Editable returns the default editability of the GtkTextView.
//
// Tags in the buffer may override this setting for some ranges of text.
//
// The function returns the following values:
//
//   - ok: whether text is editable by default.
func (textView *TextView) Editable() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_editable(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtraMenu gets the menu model that gets added to the context menu or NULL if
// none has been set.
//
// The function returns the following values:
//
//   - menuModel: menu model.
func (textView *TextView) ExtraMenu() gio.MenuModeller {
	var _arg0 *C.GtkTextView // out
	var _cret *C.GMenuModel  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_extra_menu(_arg0)
	runtime.KeepAlive(textView)

	var _menuModel gio.MenuModeller // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.MenuModeller is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(gio.MenuModeller)
			return ok
		})
		rv, ok := casted.(gio.MenuModeller)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.MenuModeller")
		}
		_menuModel = rv
	}

	return _menuModel
}

// Gutter gets a GtkWidget that has previously been set as gutter.
//
// See gtk.TextView.SetGutter().
//
// win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
//
// The function takes the following parameters:
//
//   - win: GtkTextWindowType.
//
// The function returns the following values:
//
//   - widget (optional): GtkWidget or NULL.
func (textView *TextView) Gutter(win TextWindowType) Widgetter {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _cret *C.GtkWidget        // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(win)

	_cret = C.gtk_text_view_get_gutter(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Indent gets the default indentation of paragraphs in text_view.
//
// Tags in the view’s buffer may override the default. The indentation may be
// negative.
//
// The function returns the following values:
//
//   - gint: number of pixels of indentation.
func (textView *TextView) Indent() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_indent(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InputHints gets the input-hints of the GtkTextView.
func (textView *TextView) InputHints() InputHints {
	var _arg0 *C.GtkTextView  // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_input_hints(_arg0)
	runtime.KeepAlive(textView)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the input-purpose of the GtkTextView.
func (textView *TextView) InputPurpose() InputPurpose {
	var _arg0 *C.GtkTextView    // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_input_purpose(_arg0)
	runtime.KeepAlive(textView)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// IterAtLocation retrieves the iterator at buffer coordinates x and y.
//
// Buffer coordinates are coordinates for the entire buffer,
// not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk.TextView.WindowToBufferCoords().
//
// The function takes the following parameters:
//
//   - x position, in buffer coordinates.
//   - y position, in buffer coordinates.
//
// The function returns the following values:
//
//   - iter: GtkTextIter.
//   - ok: TRUE if the position is over text.
func (textView *TextView) IterAtLocation(x, y int) (*TextIter, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // out
	var _arg3 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg2 = C.int(x)
	_arg3 = C.int(y)

	_cret = C.gtk_text_view_get_iter_at_location(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _iter *TextIter // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates x and y.
//
// Buffer coordinates are coordinates for the entire buffer,
// not just the currently-displayed portion. If you have coordinates
// from an event, you have to convert those to buffer coordinates with
// gtk.TextView.WindowToBufferCoords().
//
// Note that this is different from gtk.TextView.GetIterAtLocation(), which
// returns cursor locations, i.e. positions between characters.
//
// The function takes the following parameters:
//
//   - x position, in buffer coordinates.
//   - y position, in buffer coordinates.
//
// The function returns the following values:
//
//   - iter: GtkTextIter.
//   - trailing (optional): if non-NULL, location to store an integer indicating
//     where in the grapheme the user clicked. It will either be zero, or the
//     number of characters in the grapheme. 0 represents the trailing edge of
//     the grapheme.
//   - ok: TRUE if the position is over text.
func (textView *TextView) IterAtPosition(x, y int) (*TextIter, int, bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // in
	var _arg3 C.int          // out
	var _arg4 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg3 = C.int(x)
	_arg4 = C.int(y)

	_cret = C.gtk_text_view_get_iter_at_position(_arg0, &_arg1, &_arg2, _arg3, _arg4)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _iter *TextIter // out
	var _trailing int   // out
	var _ok bool        // out

	_iter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_trailing = int(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _trailing, _ok
}

// IterLocation gets a rectangle which roughly contains the character at iter.
//
// The rectangle position is in buffer coordinates; use
// gtk.TextView.BufferToWindowCoords() to convert these coordinates to
// coordinates for one of the windows in the text view.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//
// The function returns the following values:
//
//   - location bounds of the character at iter.
func (textView *TextView) IterLocation(iter *TextIter) *gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_text_view_get_iter_location(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _location *gdk.Rectangle // out

	_location = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _location
}

// Justification gets the default justification of paragraphs in text_view.
//
// Tags in the buffer may override the default.
//
// The function returns the following values:
//
//   - justification: default justification.
func (textView *TextView) Justification() Justification {
	var _arg0 *C.GtkTextView     // out
	var _cret C.GtkJustification // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_justification(_arg0)
	runtime.KeepAlive(textView)

	var _justification Justification // out

	_justification = Justification(_cret)

	return _justification
}

// LeftMargin gets the default left margin size of paragraphs in the text_view.
//
// Tags in the buffer may override the default.
//
// The function returns the following values:
//
//   - gint: left margin in pixels.
func (textView *TextView) LeftMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_left_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineAtY gets the GtkTextIter at the start of the line containing the
// coordinate y.
//
// y is in buffer coordinates, convert from window coordinates with
// gtk.TextView.WindowToBufferCoords(). If non-NULL, line_top will be filled
// with the coordinate of the top edge of the line.
//
// The function takes the following parameters:
//
//   - y coordinate.
//
// The function returns the following values:
//
//   - targetIter: GtkTextIter.
//   - lineTop: return location for top coordinate of the line.
func (textView *TextView) LineAtY(y int) (*TextIter, int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkTextIter  // in
	var _arg2 C.int          // out
	var _arg3 C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg2 = C.int(y)

	C.gtk_text_view_get_line_at_y(_arg0, &_arg1, _arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(y)

	var _targetIter *TextIter // out
	var _lineTop int          // out

	_targetIter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_lineTop = int(_arg3)

	return _targetIter, _lineTop
}

// LineYrange gets the y coordinate of the top of the line containing iter,
// and the height of the line.
//
// The coordinate is a buffer coordinate; convert to window coordinates with
// gtk.TextView.BufferToWindowCoords().
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//
// The function returns the following values:
//
//   - y: return location for a y coordinate.
//   - height: return location for a height.
func (textView *TextView) LineYrange(iter *TextIter) (y, height int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // in
	var _arg3 C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _y int      // out
	var _height int // out

	_y = int(_arg2)
	_height = int(_arg3)

	return _y, _height
}

// Monospace gets whether the GtkTextView uses monospace styling.
//
// The function returns the following values:
//
//   - ok: TRUE if monospace fonts are desired.
func (textView *TextView) Monospace() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_monospace(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Overwrite returns whether the GtkTextView is in overwrite mode or not.
//
// The function returns the following values:
//
//   - ok: whether text_view is in overwrite mode or not.
func (textView *TextView) Overwrite() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_overwrite(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PixelsAboveLines gets the default number of pixels to put above paragraphs.
//
// Adding this function with gtk.TextView.GetPixelsBelowLines() is equal to the
// line space between each paragraph.
//
// The function returns the following values:
//
//   - gint: default number of pixels above paragraphs.
func (textView *TextView) PixelsAboveLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsBelowLines gets the default number of pixels to put below paragraphs.
//
// The line space is the sum of the value returned by this function and the
// value returned by gtk.TextView.GetPixelsAboveLines().
//
// The function returns the following values:
//
//   - gint: default number of blank pixels below paragraphs.
func (textView *TextView) PixelsBelowLines() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PixelsInsideWrap gets the default number of pixels to put between wrapped
// lines inside a paragraph.
//
// The function returns the following values:
//
//   - gint: default number of pixels of blank space between wrapped lines.
func (textView *TextView) PixelsInsideWrap() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RightMargin gets the default right margin for text in text_view.
//
// Tags in the buffer may override the default.
//
// The function returns the following values:
//
//   - gint: right margin in pixels.
func (textView *TextView) RightMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_right_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Tabs gets the default tabs for text_view.
//
// Tags in the buffer may override the defaults. The returned array will be
// NULL if “standard” (8-space) tabs are used. Free the return value with
// pango.TabArray.Free().
//
// The function returns the following values:
//
//   - tabArray (optional): copy of default tab array, or NULL if standard tabs
//     are used; must be freed with pango.TabArray.Free().
func (textView *TextView) Tabs() *pango.TabArray {
	var _arg0 *C.GtkTextView   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_tabs(_arg0)
	runtime.KeepAlive(textView)

	var _tabArray *pango.TabArray // out

	if _cret != nil {
		_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_tabArray)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.pango_tab_array_free((*C.PangoTabArray)(intern.C))
			},
		)
	}

	return _tabArray
}

// TopMargin gets the top margin for text in the text_view.
//
// The function returns the following values:
//
//   - gint: top margin in pixels.
func (textView *TextView) TopMargin() int {
	var _arg0 *C.GtkTextView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_top_margin(_arg0)
	runtime.KeepAlive(textView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VisibleRect fills visible_rect with the currently-visible region of the
// buffer, in buffer coordinates.
//
// Convert to window coordinates with gtk.TextView.BufferToWindowCoords().
//
// The function returns the following values:
//
//   - visibleRect: rectangle to fill.
func (textView *TextView) VisibleRect() *gdk.Rectangle {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C.gtk_text_view_get_visible_rect(_arg0, &_arg1)
	runtime.KeepAlive(textView)

	var _visibleRect *gdk.Rectangle // out

	_visibleRect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _visibleRect
}

// WrapMode gets the line wrapping for the view.
//
// The function returns the following values:
//
//   - wrapMode: line wrap setting.
func (textView *TextView) WrapMode() WrapMode {
	var _arg0 *C.GtkTextView // out
	var _cret C.GtkWrapMode  // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_get_wrap_mode(_arg0)
	runtime.KeepAlive(textView)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

// IMContextFilterKeypress: allow the GtkTextView input method to internally
// handle key press and release events.
//
// If this function returns TRUE, then no further processing should be done for
// this key event. See gtk.IMContext.FilterKeypress().
//
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the GtkTextView.
//
//	static gboolean
//	gtk_foo_bar_key_press_event (GtkWidget *widget,
//	                             GdkEvent  *event)
//	{
//	  guint keyval;
//
//	  gdk_event_get_keyval ((GdkEvent*)event, &keyval);
//
//	  if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//	    {
//	      if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//	        return TRUE;
//	    }
//
//	  // Do some stuff
//
//	  return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
//	}.
//
// The function takes the following parameters:
//
//   - event: key event.
//
// The function returns the following values:
//
//   - ok: TRUE if the input method handled the key event.
func (textView *TextView) IMContextFilterKeypress(event gdk.Eventer) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GdkEvent    // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GdkEvent)(unsafe.Pointer(coreglib.InternObject(event).Native()))

	_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(event)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark.
//
// The function returns the following values:
//
//   - ok: TRUE if the mark moved (wasn’t already onscreen).
func (textView *TextView) MoveMarkOnscreen(mark *TextMark) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveOverlay updates the position of a child.
//
// See gtk.TextView.AddOverlay().
//
// The function takes the following parameters:
//
//   - child: widget already added with gtk.TextView.AddOverlay().
//   - xpos: new X position in buffer coordinates.
//   - ypos: new Y position in buffer coordinates.
func (textView *TextView) MoveOverlay(child Widgetter, xpos, ypos int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = C.int(xpos)
	_arg3 = C.int(ypos)

	C.gtk_text_view_move_overlay(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
	runtime.KeepAlive(xpos)
	runtime.KeepAlive(ypos)
}

// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position.
//
// If count is positive, then the new strong cursor position will be count
// positions to the right of the old cursor position. If count is negative then
// the new strong cursor position will be count positions to the left of the old
// cursor position.
//
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//   - count: number of characters to move (negative moves left, positive moves
//     right).
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not on the end iterator.
func (textView *TextView) MoveVisually(iter *TextIter, count int) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.int(count)

	_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer.
//
// The function returns the following values:
//
//   - ok: TRUE if the cursor had to be moved.
func (textView *TextView) PlaceCursorOnscreen() bool {
	var _arg0 *C.GtkTextView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)
	runtime.KeepAlive(textView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes a child widget from text_view.
//
// The function takes the following parameters:
//
//   - child to remove.
func (textView *TextView) Remove(child Widgetter) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))

	C.gtk_text_view_remove(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(child)
}

// ResetCursorBlink ensures that the cursor is shown.
//
// This also resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
//
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's event handlers).
func (textView *TextView) ResetCursorBlink() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C.gtk_text_view_reset_cursor_blink(_arg0)
	runtime.KeepAlive(textView)
}

// ResetIMContext: reset the input method context of the text view if needed.
//
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
func (textView *TextView) ResetIMContext() {
	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C.gtk_text_view_reset_im_context(_arg0)
	runtime.KeepAlive(textView)
}

// ScrollMarkOnscreen scrolls text_view the minimum distance such that mark is
// contained within the visible area of the widget.
//
// The function takes the following parameters:
//
//   - mark in the buffer for text_view.
func (textView *TextView) ScrollMarkOnscreen(mark *TextMark) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))

	C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
}

// ScrollToIter scrolls text_view so that iter is on the screen in the position
// indicated by xalign and yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If use_align is FALSE, the text scrolls the minimal distance
// to get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size within_margin.
//
// Note that this function uses the currently-computed height of the lines
// in the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if it’s called before the height
// computations. To avoid oddness, consider using gtk.TextView.ScrollToMark()
// which saves a point to be scrolled to after line validation.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//   - withinMargin: margin as a [0.0,0.5) fraction of screen size.
//   - useAlign: whether to use alignment arguments (if FALSE, just get the mark
//     onscreen).
//   - xalign: horizontal alignment of mark within visible area.
//   - yalign: vertical alignment of mark within visible area.
//
// The function returns the following values:
//
//   - ok: TRUE if scrolling occurred.
func (textView *TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign, yalign float64) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)

	_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToMark scrolls text_view so that mark is on the screen in the position
// indicated by xalign and yalign.
//
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If use_align is FALSE, the text scrolls the minimal distance
// to get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size within_margin.
//
// The function takes the following parameters:
//
//   - mark: GtkTextMark.
//   - withinMargin: margin as a [0.0,0.5) fraction of screen size.
//   - useAlign: whether to use alignment arguments (if FALSE, just get the mark
//     onscreen).
//   - xalign: horizontal alignment of mark within visible area.
//   - yalign: vertical alignment of mark within visible area.
func (textView *TextView) ScrollToMark(mark *TextMark, withinMargin float64, useAlign bool, xalign, yalign float64) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextMark // out
	var _arg2 C.double       // out
	var _arg3 C.gboolean     // out
	var _arg4 C.double       // out
	var _arg5 C.double       // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(coreglib.InternObject(mark).Native()))
	_arg2 = C.double(withinMargin)
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.double(xalign)
	_arg5 = C.double(yalign)

	C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(withinMargin)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(xalign)
	runtime.KeepAlive(yalign)
}

// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed.
//
// If accepts_tab is TRUE, a tab character is inserted. If accepts_tab is FALSE
// the keyboard focus is moved to the next widget in the focus chain.
//
// The function takes the following parameters:
//
//   - acceptsTab: TRUE if pressing the Tab key should insert a tab character,
//     FALSE, if pressing the Tab key should move the keyboard focus.
func (textView *TextView) SetAcceptsTab(acceptsTab bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if acceptsTab {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(acceptsTab)
}

// SetBottomMargin sets the bottom margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//   - bottomMargin: bottom margin in pixels.
func (textView *TextView) SetBottomMargin(bottomMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(bottomMargin)

	C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(bottomMargin)
}

// SetBuffer sets buffer as the buffer being displayed by text_view.
//
// The previous buffer displayed by the text view is unreferenced, and a
// reference is added to buffer. If you owned a reference to buffer before
// passing it to this function, you must remove that reference yourself;
// GtkTextView will not “adopt” it.
//
// The function takes the following parameters:
//
//   - buffer (optional): GtkTextBuffer.
func (textView *TextView) SetBuffer(buffer *TextBuffer) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if buffer != nil {
		_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(coreglib.InternObject(buffer).Native()))
	}

	C.gtk_text_view_set_buffer(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(buffer)
}

// SetCursorVisible toggles whether the insertion point should be displayed.
//
// A buffer with no editable text probably shouldn’t have a visible cursor,
// so you may want to turn the cursor off.
//
// Note that this property may be overridden by the
// gtksettings:gtk-keynav-use-caret setting.
//
// The function takes the following parameters:
//
//   - setting: whether to show the insertion cursor.
func (textView *TextView) SetCursorVisible(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetEditable sets the default editability of the GtkTextView.
//
// You can override this default setting with tags in the buffer, using the
// “editable” attribute of tags.
//
// The function takes the following parameters:
//
//   - setting: whether it’s editable.
func (textView *TextView) SetEditable(setting bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_editable(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(setting)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// text_view.
//
// You can pass NULL to remove a previously set extra menu.
//
// The function takes the following parameters:
//
//   - model (optional): GMenuModel.
func (textView *TextView) SetExtraMenu(model gio.MenuModeller) {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GMenuModel  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if model != nil {
		_arg1 = (*C.GMenuModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_text_view_set_extra_menu(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(model)
}

// SetGutter places widget into the gutter specified by win.
//
// win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
//
// The function takes the following parameters:
//
//   - win: GtkTextWindowType.
//   - widget (optional): GtkWidget or NULL.
func (textView *TextView) SetGutter(win TextWindowType, widget Widgetter) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 *C.GtkWidget        // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(win)
	if widget != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_text_view_set_gutter(_arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(widget)
}

// SetIndent sets the default indentation for paragraphs in text_view.
//
// Tags in the buffer may override the default.
//
// The function takes the following parameters:
//
//   - indent: indentation in pixels.
func (textView *TextView) SetIndent(indent int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(indent)

	C.gtk_text_view_set_indent(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(indent)
}

// SetInputHints sets the input-hints of the GtkTextView.
//
// The input-hints allow input methods to fine-tune their behaviour.
//
// The function takes the following parameters:
//
//   - hints: hints.
func (textView *TextView) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkTextView  // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkInputHints(hints)

	C.gtk_text_view_set_input_hints(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(hints)
}

// SetInputPurpose sets the input-purpose of the GtkTextView.
//
// The input-purpose can be used by on-screen keyboards and other input methods
// to adjust their behaviour.
//
// The function takes the following parameters:
//
//   - purpose: purpose.
func (textView *TextView) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkTextView    // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkInputPurpose(purpose)

	C.gtk_text_view_set_input_purpose(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(purpose)
}

// SetJustification sets the default justification of text in text_view.
//
// Tags in the view’s buffer may override the default.
//
// The function takes the following parameters:
//
//   - justification: justification.
func (textView *TextView) SetJustification(justification Justification) {
	var _arg0 *C.GtkTextView     // out
	var _arg1 C.GtkJustification // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkJustification(justification)

	C.gtk_text_view_set_justification(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(justification)
}

// SetLeftMargin sets the default left margin for text in text_view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//   - leftMargin: left margin in pixels.
func (textView *TextView) SetLeftMargin(leftMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(leftMargin)

	C.gtk_text_view_set_left_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(leftMargin)
}

// SetMonospace sets whether the GtkTextView should display text in monospace
// styling.
//
// The function takes the following parameters:
//
//   - monospace: TRUE to request monospace styling.
func (textView *TextView) SetMonospace(monospace bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if monospace {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_monospace(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(monospace)
}

// SetOverwrite changes the GtkTextView overwrite mode.
//
// The function takes the following parameters:
//
//   - overwrite: TRUE to turn on overwrite mode, FALSE to turn it off.
func (textView *TextView) SetOverwrite(overwrite bool) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_view_set_overwrite(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(overwrite)
}

// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in text_view.
//
// Tags in the buffer for text_view may override the defaults.
//
// The function takes the following parameters:
//
//   - pixelsAboveLines pixels above paragraphs.
func (textView *TextView) SetPixelsAboveLines(pixelsAboveLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(pixelsAboveLines)

	C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsAboveLines)
}

// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in text_view.
//
// May be overridden by tags applied to text_view’s buffer.
//
// The function takes the following parameters:
//
//   - pixelsBelowLines pixels below paragraphs.
func (textView *TextView) SetPixelsBelowLines(pixelsBelowLines int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(pixelsBelowLines)

	C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsBelowLines)
}

// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph.
//
// May be overridden by tags in text_view’s buffer.
//
// The function takes the following parameters:
//
//   - pixelsInsideWrap: default number of pixels between wrapped lines.
func (textView *TextView) SetPixelsInsideWrap(pixelsInsideWrap int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(pixelsInsideWrap)

	C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(pixelsInsideWrap)
}

// SetRightMargin sets the default right margin for text in the text view.
//
// Tags in the buffer may override the default.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//   - rightMargin: right margin in pixels.
func (textView *TextView) SetRightMargin(rightMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(rightMargin)

	C.gtk_text_view_set_right_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(rightMargin)
}

// SetTabs sets the default tab stops for paragraphs in text_view.
//
// Tags in the buffer may override the default.
//
// The function takes the following parameters:
//
//   - tabs as a TabArray.
func (textView *TextView) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkTextView   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))

	C.gtk_text_view_set_tabs(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(tabs)
}

// SetTopMargin sets the top margin for text in text_view.
//
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
//
// The function takes the following parameters:
//
//   - topMargin: top margin in pixels.
func (textView *TextView) SetTopMargin(topMargin int) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.int(topMargin)

	C.gtk_text_view_set_top_margin(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(topMargin)
}

// SetWrapMode sets the line wrapping for the view.
//
// The function takes the following parameters:
//
//   - wrapMode: GtkWrapMode.
func (textView *TextView) SetWrapMode(wrapMode WrapMode) {
	var _arg0 *C.GtkTextView // out
	var _arg1 C.GtkWrapMode  // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkWrapMode(wrapMode)

	C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(wrapMode)
}

// StartsDisplayLine determines whether iter is at the start of a display line.
//
// See gtk.TextView.ForwardDisplayLine() for an explanation of display lines vs.
// paragraphs.
//
// The function takes the following parameters:
//
//   - iter: GtkTextIter.
//
// The function returns the following values:
//
//   - ok: TRUE if iter begins a wrapped line.
func (textView *TextView) StartsDisplayLine(iter *TextIter) bool {
	var _arg0 *C.GtkTextView // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// WindowToBufferCoords converts coordinates on the window identified by win to
// buffer coordinates.
//
// The function takes the following parameters:
//
//   - win: TextWindowType.
//   - windowX: window x coordinate.
//   - windowY: window y coordinate.
//
// The function returns the following values:
//
//   - bufferX (optional): buffer x coordinate return location or NULL.
//   - bufferY (optional): buffer y coordinate return location or NULL.
func (textView *TextView) WindowToBufferCoords(win TextWindowType, windowX, windowY int) (bufferX, bufferY int) {
	var _arg0 *C.GtkTextView      // out
	var _arg1 C.GtkTextWindowType // out
	var _arg2 C.int               // out
	var _arg3 C.int               // out
	var _arg4 C.int               // in
	var _arg5 C.int               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextWindowType(win)
	_arg2 = C.int(windowX)
	_arg3 = C.int(windowY)

	C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(win)
	runtime.KeepAlive(windowX)
	runtime.KeepAlive(windowY)

	var _bufferX int // out
	var _bufferY int // out

	_bufferX = int(_arg4)
	_bufferY = int(_arg5)

	return _bufferX, _bufferY
}

func (textView *TextView) backspace() {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.backspace

	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C._gotk4_gtk4_TextView_virtual_backspace(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(textView)
}

func (textView *TextView) copyClipboard() {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.copy_clipboard

	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C._gotk4_gtk4_TextView_virtual_copy_clipboard(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(textView)
}

func (textView *TextView) cutClipboard() {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.cut_clipboard

	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C._gotk4_gtk4_TextView_virtual_cut_clipboard(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(textView)
}

// The function takes the following parameters:
//
//   - typ
//   - count
func (textView *TextView) deleteFromCursor(typ DeleteType, count int) {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.delete_from_cursor

	var _arg0 *C.GtkTextView  // out
	var _arg1 C.GtkDeleteType // out
	var _arg2 C.int           // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkDeleteType(typ)
	_arg2 = C.int(count)

	C._gotk4_gtk4_TextView_virtual_delete_from_cursor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(typ)
	runtime.KeepAlive(count)
}

// The function takes the following parameters:
//
//   - granularity
//   - location
//   - start
//   - end
func (textView *TextView) extendSelection(granularity TextExtendSelection, location, start, end *TextIter) bool {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.extend_selection

	var _arg0 *C.GtkTextView           // out
	var _arg1 C.GtkTextExtendSelection // out
	var _arg2 *C.GtkTextIter           // out
	var _arg3 *C.GtkTextIter           // out
	var _arg4 *C.GtkTextIter           // out
	var _cret C.gboolean               // in

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextExtendSelection(granularity)
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(location)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg4 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = C._gotk4_gtk4_TextView_virtual_extend_selection(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(granularity)
	runtime.KeepAlive(location)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (textView *TextView) insertAtCursor(str string) {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.insert_at_cursor

	var _arg0 *C.GtkTextView // out
	var _arg1 *C.char        // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))

	C._gotk4_gtk4_TextView_virtual_insert_at_cursor(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(str)
}

func (textView *TextView) insertEmoji() {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.insert_emoji

	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C._gotk4_gtk4_TextView_virtual_insert_emoji(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(textView)
}

// The function takes the following parameters:
//
//   - step
//   - count
//   - extendSelection
func (textView *TextView) moveCursor(step MovementStep, count int, extendSelection bool) {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.move_cursor

	var _arg0 *C.GtkTextView    // out
	var _arg1 C.GtkMovementStep // out
	var _arg2 C.int             // out
	var _arg3 C.gboolean        // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkMovementStep(step)
	_arg2 = C.int(count)
	if extendSelection {
		_arg3 = C.TRUE
	}

	C._gotk4_gtk4_TextView_virtual_move_cursor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(step)
	runtime.KeepAlive(count)
	runtime.KeepAlive(extendSelection)
}

func (textView *TextView) pasteClipboard() {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.paste_clipboard

	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C._gotk4_gtk4_TextView_virtual_paste_clipboard(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(textView)
}

func (textView *TextView) setAnchor() {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.set_anchor

	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C._gotk4_gtk4_TextView_virtual_set_anchor(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(textView)
}

// The function takes the following parameters:
//
//   - layer
//   - snapshot
func (textView *TextView) snapshotLayer(layer TextViewLayer, snapshot *Snapshot) {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.snapshot_layer

	var _arg0 *C.GtkTextView     // out
	var _arg1 C.GtkTextViewLayer // out
	var _arg2 *C.GtkSnapshot     // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))
	_arg1 = C.GtkTextViewLayer(layer)
	_arg2 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C._gotk4_gtk4_TextView_virtual_snapshot_layer(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(textView)
	runtime.KeepAlive(layer)
	runtime.KeepAlive(snapshot)
}

func (textView *TextView) toggleOverwrite() {
	gclass := (*C.GtkTextViewClass)(coreglib.PeekParentClass(textView))
	fnarg := gclass.toggle_overwrite

	var _arg0 *C.GtkTextView // out

	_arg0 = (*C.GtkTextView)(unsafe.Pointer(coreglib.InternObject(textView).Native()))

	C._gotk4_gtk4_TextView_virtual_toggle_overwrite(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(textView)
}

// ToggleButtonOverrides contains methods that are overridable.
type ToggleButtonOverrides struct {
	// Toggled emits the ::toggled signal on the GtkToggleButton.
	//
	// There is no good reason for an application ever to call this function.
	Toggled func()
}

func defaultToggleButtonOverrides(v *ToggleButton) ToggleButtonOverrides {
	return ToggleButtonOverrides{
		Toggled: v.toggled,
	}
}

// ToggleButton: GtkToggleButton is a button which remains “pressed-in” when
// clicked.
//
// Clicking again will cause the toggle button to return to its normal state.
//
// A toggle button is created by calling either gtk.ToggleButton.New or
// gtk.ToggleButton.NewWithLabel. If using the former, it is advisable to pack
// a widget, (such as a GtkLabel and/or a GtkImage), into the toggle button’s
// container. (See gtk.Button for more information).
//
// The state of a GtkToggleButton can be set specifically
// using gtk.ToggleButton.SetActive(), and retrieved using
// gtk.ToggleButton.GetActive().
//
// To simply switch the state of a toggle button, use
// gtk.ToggleButton.Toggled().
//
// # Grouping
//
// Toggle buttons can be grouped together, to form mutually exclusive groups -
// only one of the buttons can be toggled at a time, and toggling another one
// will switch the currently toggled one off.
//
// To add a GtkToggleButton to a group, use gtk.ToggleButton.SetGroup().
//
// # CSS nodes
//
// GtkToggleButton has a single CSS node with name button. To differentiate it
// from a plain GtkButton, it gets the .toggle style class.
//
// Creating two GtkToggleButton widgets.
//
//	static void output_state (GtkToggleButton *source, gpointer user_data)
//	{
//	  printf ("Active: d\n", gtk_toggle_button_get_active (source));
//	}
//
//	void make_toggles (void)
//	{
//	  GtkWidget *window, *toggle1, *toggle2;
//	  GtkWidget *box;
//	  const char *text;
//
//	  window = gtk_window_new ();
//	  box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
//
//	  text = "Hi, I’m a toggle button.";
//	  toggle1 = gtk_toggle_button_new_with_label (text);
//
//	  g_signal_connect (toggle1, "toggled",
//	                    G_CALLBACK (output_state),
//	                    NULL);
//	  gtk_box_append (GTK_BOX (box), toggle1);
//
//	  text = "Hi, I’m a toggle button.";
//	  toggle2 = gtk_toggle_button_new_with_label (text);
//	  g_signal_connect (toggle2, "toggled",
//	                    G_CALLBACK (output_state),
//	                    NULL);
//	  gtk_box_append (GTK_BOX (box), toggle2);
//
//	  gtk_window_set_child (GTK_WINDOW (window), box);
//	  gtk_widget_show (window);
//	}.
type ToggleButton struct {
	_ [0]func() // equal guard
	Button
}

var (
	_ Widgetter         = (*ToggleButton)(nil)
	_ coreglib.Objector = (*ToggleButton)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*ToggleButton, *ToggleButtonClass, ToggleButtonOverrides](
		GTypeToggleButton,
		initToggleButtonClass,
		wrapToggleButton,
		defaultToggleButtonOverrides,
	)
}

func initToggleButtonClass(gclass unsafe.Pointer, overrides ToggleButtonOverrides, classInitFunc func(*ToggleButtonClass)) {
	pclass := (*C.GtkToggleButtonClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeToggleButton))))

	if overrides.Toggled != nil {
		pclass.toggled = (*[0]byte)(C._gotk4_gtk4_ToggleButtonClass_toggled)
	}

	if classInitFunc != nil {
		class := (*ToggleButtonClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapToggleButton(obj *coreglib.Object) *ToggleButton {
	return &ToggleButton{
		Button: Button{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Actionable: Actionable{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
		},
	}
}

func marshalToggleButton(p uintptr) (interface{}, error) {
	return wrapToggleButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectToggled is emitted whenever the GtkToggleButton's state is changed.
func (toggleButton *ToggleButton) ConnectToggled(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(toggleButton, "toggled", false, unsafe.Pointer(C._gotk4_gtk4_ToggleButton_ConnectToggled), f)
}

// NewToggleButton creates a new toggle button.
//
// A widget should be packed into the button, as in gtk.Button.New.
//
// The function returns the following values:
//
//   - toggleButton: new toggle button.
func NewToggleButton() *ToggleButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_toggle_button_new()

	var _toggleButton *ToggleButton // out

	_toggleButton = wrapToggleButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// NewToggleButtonWithLabel creates a new toggle button with a text label.
//
// The function takes the following parameters:
//
//   - label: string containing the message to be placed in the toggle button.
//
// The function returns the following values:
//
//   - toggleButton: new toggle button.
func NewToggleButtonWithLabel(label string) *ToggleButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_toggle_button_new_with_label(_arg1)
	runtime.KeepAlive(label)

	var _toggleButton *ToggleButton // out

	_toggleButton = wrapToggleButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// NewToggleButtonWithMnemonic creates a new GtkToggleButton containing a label.
//
// The label will be created using gtk.Label.NewWithMnemonic, so underscores in
// label indicate the mnemonic for the button.
//
// The function takes the following parameters:
//
//   - label: text of the button, with an underscore in front of the mnemonic
//     character.
//
// The function returns the following values:
//
//   - toggleButton: new GtkToggleButton.
func NewToggleButtonWithMnemonic(label string) *ToggleButton {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(label)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_toggle_button_new_with_mnemonic(_arg1)
	runtime.KeepAlive(label)

	var _toggleButton *ToggleButton // out

	_toggleButton = wrapToggleButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _toggleButton
}

// Active queries a GtkToggleButton and returns its current state.
//
// Returns TRUE if the toggle button is pressed in and FALSE if it is raised.
//
// The function returns the following values:
//
//   - ok: whether the button is pressed.
func (toggleButton *ToggleButton) Active() bool {
	var _arg0 *C.GtkToggleButton // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(coreglib.InternObject(toggleButton).Native()))

	_cret = C.gtk_toggle_button_get_active(_arg0)
	runtime.KeepAlive(toggleButton)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActive sets the status of the toggle button.
//
// Set to TRUE if you want the GtkToggleButton to be “pressed in”, and FALSE to
// raise it.
//
// If the status of the button changes, this action causes the
// gtktogglebutton::toggled signal to be emitted.
//
// The function takes the following parameters:
//
//   - isActive: TRUE or FALSE.
func (toggleButton *ToggleButton) SetActive(isActive bool) {
	var _arg0 *C.GtkToggleButton // out
	var _arg1 C.gboolean         // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(coreglib.InternObject(toggleButton).Native()))
	if isActive {
		_arg1 = C.TRUE
	}

	C.gtk_toggle_button_set_active(_arg0, _arg1)
	runtime.KeepAlive(toggleButton)
	runtime.KeepAlive(isActive)
}

// SetGroup adds self to the group of group.
//
// In a group of multiple toggle buttons, only one button can be active at a
// time.
//
// Setting up groups in a cycle leads to undefined behavior.
//
// Note that the same effect can be achieved via the gtk.Actionable API, by
// using the same action with parameter type and state type 's' for all buttons
// in the group, and giving each button its own target value.
//
// The function takes the following parameters:
//
//   - group (optional): another GtkToggleButton to form a group with.
func (toggleButton *ToggleButton) SetGroup(group *ToggleButton) {
	var _arg0 *C.GtkToggleButton // out
	var _arg1 *C.GtkToggleButton // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(coreglib.InternObject(toggleButton).Native()))
	if group != nil {
		_arg1 = (*C.GtkToggleButton)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	}

	C.gtk_toggle_button_set_group(_arg0, _arg1)
	runtime.KeepAlive(toggleButton)
	runtime.KeepAlive(group)
}

// Toggled emits the ::toggled signal on the GtkToggleButton.
//
// There is no good reason for an application ever to call this function.
func (toggleButton *ToggleButton) Toggled() {
	var _arg0 *C.GtkToggleButton // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(coreglib.InternObject(toggleButton).Native()))

	C.gtk_toggle_button_toggled(_arg0)
	runtime.KeepAlive(toggleButton)
}

// Toggled emits the ::toggled signal on the GtkToggleButton.
//
// There is no good reason for an application ever to call this function.
func (toggleButton *ToggleButton) toggled() {
	gclass := (*C.GtkToggleButtonClass)(coreglib.PeekParentClass(toggleButton))
	fnarg := gclass.toggled

	var _arg0 *C.GtkToggleButton // out

	_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(coreglib.InternObject(toggleButton).Native()))

	C._gotk4_gtk4_ToggleButton_virtual_toggled(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(toggleButton)
}

// Tooltip: GtkTooltip is an object representing a widget tooltip.
//
// Basic tooltips can be realized simply by using gtk.Widget.SetTooltipText() or
// gtk.Widget.SetTooltipMarkup() without any explicit tooltip object.
//
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per GtkTreeView row
// or cell, you will have to do a little more work:
//
// - Set the gtk.Widget:has-tooltip property to TRUE. This will make GTK monitor
// the widget for motion and related events which are needed to determine when
// and where to show a tooltip.
//
// - Connect to the gtk.Widget::query-tooltip signal. This signal will be
// emitted when a tooltip is supposed to be shown. One of the arguments passed
// to the signal handler is a GtkTooltip object. This is the object that we are
// about to display as a tooltip, and can be manipulated in your callback using
// functions like gtk.Tooltip.SetIcon(). There are functions for setting the
// tooltip’s markup, setting an image from a named icon, or even putting in a
// custom widget.
//
// - Return TRUE from your ::query-tooltip handler. This causes the tooltip to
// be show. If you return FALSE, it will not be shown.
type Tooltip struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*Tooltip)(nil)
)

func wrapTooltip(obj *coreglib.Object) *Tooltip {
	return &Tooltip{
		Object: obj,
	}
}

func marshalTooltip(p uintptr) (interface{}, error) {
	return wrapTooltip(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// SetCustom replaces the widget packed into the tooltip with custom_widget.
// custom_widget does not get destroyed when the tooltip goes away. By default
// a box with a Image and Label is embedded in the tooltip, which can be
// configured using gtk_tooltip_set_markup() and gtk_tooltip_set_icon().
//
// The function takes the following parameters:
//
//   - customWidget (optional) or NULL to unset the old custom widget.
func (tooltip *Tooltip) SetCustom(customWidget Widgetter) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GtkWidget  // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if customWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(customWidget).Native()))
	}

	C.gtk_tooltip_set_custom(_arg0, _arg1)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(customWidget)
}

// SetIcon sets the icon of the tooltip (which is in front of the text) to be
// paintable. If paintable is NULL, the image will be hidden.
//
// The function takes the following parameters:
//
//   - paintable (optional) or NULL.
func (tooltip *Tooltip) SetIcon(paintable gdk.Paintabler) {
	var _arg0 *C.GtkTooltip   // out
	var _arg1 *C.GdkPaintable // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if paintable != nil {
		_arg1 = (*C.GdkPaintable)(unsafe.Pointer(coreglib.InternObject(paintable).Native()))
	}

	C.gtk_tooltip_set_icon(_arg0, _arg1)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(paintable)
}

// SetIconFromGIcon sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by gicon with the size indicated by size.
// If gicon is NULL, the image will be hidden.
//
// The function takes the following parameters:
//
//   - gicon (optional) representing the icon, or NULL.
func (tooltip *Tooltip) SetIconFromGIcon(gicon gio.Iconner) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.GIcon      // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if gicon != nil {
		_arg1 = (*C.GIcon)(unsafe.Pointer(coreglib.InternObject(gicon).Native()))
	}

	C.gtk_tooltip_set_icon_from_gicon(_arg0, _arg1)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(gicon)
}

// SetIconFromIconName sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by icon_name with the size indicated by size.
// If icon_name is NULL, the image will be hidden.
//
// The function takes the following parameters:
//
//   - iconName (optional): icon name, or NULL.
func (tooltip *Tooltip) SetIconFromIconName(iconName string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if iconName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(iconName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_tooltip_set_icon_from_icon_name(_arg0, _arg1)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(iconName)
}

// SetMarkup sets the text of the tooltip to be markup.
//
// The string must be marked up with Pango markup. If markup is NULL, the label
// will be hidden.
//
// The function takes the following parameters:
//
//   - markup (optional): string with Pango markup or NLL.
func (tooltip *Tooltip) SetMarkup(markup string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if markup != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(markup)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_tooltip_set_markup(_arg0, _arg1)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(markup)
}

// SetText sets the text of the tooltip to be text.
//
// If text is NULL, the label will be hidden. See also gtk.Tooltip.SetMarkup().
//
// The function takes the following parameters:
//
//   - text (optional) string or NULL.
func (tooltip *Tooltip) SetText(text string) {
	var _arg0 *C.GtkTooltip // out
	var _arg1 *C.char       // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_tooltip_set_text(_arg0, _arg1)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(text)
}

// SetTipArea sets the area of the widget, where the contents of this tooltip
// apply, to be rect (in widget coordinates). This is especially useful for
// properly setting tooltips on TreeView rows and cells, IconViews, etc.
//
// For setting tooltips on TreeView, please refer to the convenience
// functions for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
//
// The function takes the following parameters:
//
//   - rect: Rectangle.
func (tooltip *Tooltip) SetTipArea(rect *gdk.Rectangle) {
	var _arg0 *C.GtkTooltip   // out
	var _arg1 *C.GdkRectangle // out

	_arg0 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(rect)))

	C.gtk_tooltip_set_tip_area(_arg0, _arg1)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(rect)
}

// TreeExpanderOverrides contains methods that are overridable.
type TreeExpanderOverrides struct {
}

func defaultTreeExpanderOverrides(v *TreeExpander) TreeExpanderOverrides {
	return TreeExpanderOverrides{}
}

// TreeExpander: GtkTreeExpander is a widget that provides an expander for a
// list.
//
// It is typically placed as a bottommost child into a GtkListView to allow
// users to expand and collapse children in a list with a gtk.TreeListModel.
// GtkTreeExpander provides the common UI elements, gestures and keybindings for
// this purpose.
//
// On top of this, the "listitem.expand", "listitem.collapse" and
// "listitem.toggle-expand" actions are provided to allow adding custom UI for
// managing expanded state.
//
// The GtkTreeListModel must be set to not be passthrough. Then it will provide
// gtk.TreeListRow items which can be set via gtk.TreeExpander.SetListRow()
// on the expander. The expander will then watch that row item automatically.
// gtk.TreeExpander.SetChild() sets the widget that displays the actual row
// contents.
//
// CSS nodes
//
//	treeexpander
//	├── [indent]*
//	├── [expander]
//	╰── <child>
//
// GtkTreeExpander has zero or one CSS nodes with the name "expander" that
// should display the expander icon. The node will be :checked when it is
// expanded. If the node is not expandable, an "indent" node will be displayed
// instead.
//
// For every level of depth, another "indent" node is prepended.
//
// # Accessibility
//
// GtkTreeExpander uses the GTK_ACCESSIBLE_ROLE_GROUP role. The expander icon
// is represented as a GTK_ACCESSIBLE_ROLE_BUTTON, labelled by the expander's
// child, and toggling it will change the GTK_ACCESSIBLE_STATE_EXPANDED state.
type TreeExpander struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*TreeExpander)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeExpander, *TreeExpanderClass, TreeExpanderOverrides](
		GTypeTreeExpander,
		initTreeExpanderClass,
		wrapTreeExpander,
		defaultTreeExpanderOverrides,
	)
}

func initTreeExpanderClass(gclass unsafe.Pointer, overrides TreeExpanderOverrides, classInitFunc func(*TreeExpanderClass)) {
	if classInitFunc != nil {
		class := (*TreeExpanderClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeExpander(obj *coreglib.Object) *TreeExpander {
	return &TreeExpander{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalTreeExpander(p uintptr) (interface{}, error) {
	return wrapTreeExpander(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTreeExpander creates a new GtkTreeExpander.
//
// The function returns the following values:
//
//   - treeExpander: new GtkTreeExpander.
func NewTreeExpander() *TreeExpander {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tree_expander_new()

	var _treeExpander *TreeExpander // out

	_treeExpander = wrapTreeExpander(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeExpander
}

// Child gets the child widget displayed by self.
//
// The function returns the following values:
//
//   - widget (optional): child displayed by self.
func (self *TreeExpander) Child() Widgetter {
	var _arg0 *C.GtkTreeExpander // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_expander_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Item forwards the item set on the GtkTreeListRow that self is managing.
//
// This call is essentially equivalent to calling:
//
//	gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (self));.
//
// The function returns the following values:
//
//   - object (optional): item of the row.
func (self *TreeExpander) Item() *coreglib.Object {
	var _arg0 *C.GtkTreeExpander // out
	var _cret C.gpointer         // in

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_expander_get_item(_arg0)
	runtime.KeepAlive(self)

	var _object *coreglib.Object // out

	_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))

	return _object
}

// ListRow gets the list row managed by self.
//
// The function returns the following values:
//
//   - treeListRow (optional): list row displayed by self.
func (self *TreeExpander) ListRow() *TreeListRow {
	var _arg0 *C.GtkTreeExpander // out
	var _cret *C.GtkTreeListRow  // in

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_expander_get_list_row(_arg0)
	runtime.KeepAlive(self)

	var _treeListRow *TreeListRow // out

	if _cret != nil {
		_treeListRow = wrapTreeListRow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeListRow
}

// SetChild sets the content widget to display.
//
// The function takes the following parameters:
//
//   - child (optional): GtkWidget, or NULL.
func (self *TreeExpander) SetChild(child Widgetter) {
	var _arg0 *C.GtkTreeExpander // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_tree_expander_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// SetListRow sets the tree list row that this expander should manage.
//
// The function takes the following parameters:
//
//   - listRow (optional): GtkTreeListRow, or NULL.
func (self *TreeExpander) SetListRow(listRow *TreeListRow) {
	var _arg0 *C.GtkTreeExpander // out
	var _arg1 *C.GtkTreeListRow  // out

	_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if listRow != nil {
		_arg1 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(listRow).Native()))
	}

	C.gtk_tree_expander_set_list_row(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(listRow)
}

// TreeListModelOverrides contains methods that are overridable.
type TreeListModelOverrides struct {
}

func defaultTreeListModelOverrides(v *TreeListModel) TreeListModelOverrides {
	return TreeListModelOverrides{}
}

// TreeListModel: GtkTreeListModel is a list model that can create child models
// on demand.
type TreeListModel struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.ListModel
}

var (
	_ coreglib.Objector = (*TreeListModel)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeListModel, *TreeListModelClass, TreeListModelOverrides](
		GTypeTreeListModel,
		initTreeListModelClass,
		wrapTreeListModel,
		defaultTreeListModelOverrides,
	)
}

func initTreeListModelClass(gclass unsafe.Pointer, overrides TreeListModelOverrides, classInitFunc func(*TreeListModelClass)) {
	if classInitFunc != nil {
		class := (*TreeListModelClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeListModel(obj *coreglib.Object) *TreeListModel {
	return &TreeListModel{
		Object: obj,
		ListModel: gio.ListModel{
			Object: obj,
		},
	}
}

func marshalTreeListModel(p uintptr) (interface{}, error) {
	return wrapTreeListModel(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTreeListModel creates a new empty GtkTreeListModel displaying root with
// all rows collapsed.
//
// The function takes the following parameters:
//
//   - root: GListModel to use as root.
//   - passthrough: TRUE to pass through items from the models.
//   - autoexpand: TRUE to set the autoexpand property and expand the root
//     model.
//   - createFunc: function to call to create the GListModel for the children of
//     an item.
//
// The function returns the following values:
//
//   - treeListModel: newly created GtkTreeListModel.
func NewTreeListModel(root gio.ListModeller, passthrough, autoexpand bool, createFunc TreeListModelCreateModelFunc) *TreeListModel {
	var _arg1 *C.GListModel                     // out
	var _arg2 C.gboolean                        // out
	var _arg3 C.gboolean                        // out
	var _arg4 C.GtkTreeListModelCreateModelFunc // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify
	var _cret *C.GtkTreeListModel // in

	_arg1 = (*C.GListModel)(unsafe.Pointer(coreglib.InternObject(root).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(root).Native()))
	if passthrough {
		_arg2 = C.TRUE
	}
	if autoexpand {
		_arg3 = C.TRUE
	}
	_arg4 = (*[0]byte)(C._gotk4_gtk4_TreeListModelCreateModelFunc)
	_arg5 = C.gpointer(gbox.Assign(createFunc))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gtk_tree_list_model_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(root)
	runtime.KeepAlive(passthrough)
	runtime.KeepAlive(autoexpand)
	runtime.KeepAlive(createFunc)

	var _treeListModel *TreeListModel // out

	_treeListModel = wrapTreeListModel(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeListModel
}

// Autoexpand gets whether the model is set to automatically expand new rows
// that get added.
//
// This can be either rows added by changes to the underlying models or via
// gtk.TreeListRow.SetExpanded().
//
// The function returns the following values:
//
//   - ok: TRUE if the model is set to autoexpand.
func (self *TreeListModel) Autoexpand() bool {
	var _arg0 *C.GtkTreeListModel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_model_get_autoexpand(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildRow gets the row item corresponding to the child at index position for
// self's root model.
//
// If position is greater than the number of children in the root model,
// NULL is returned.
//
// Do not confuse this function with gtk.TreeListModel.GetRow().
//
// The function takes the following parameters:
//
//   - position of the child to get.
//
// The function returns the following values:
//
//   - treeListRow (optional): child in position.
func (self *TreeListModel) ChildRow(position uint) *TreeListRow {
	var _arg0 *C.GtkTreeListModel // out
	var _arg1 C.guint             // out
	var _cret *C.GtkTreeListRow   // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	_cret = C.gtk_tree_list_model_get_child_row(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)

	var _treeListRow *TreeListRow // out

	if _cret != nil {
		_treeListRow = wrapTreeListRow(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _treeListRow
}

// Model gets the root model that self was created with.
//
// The function returns the following values:
//
//   - listModel: root model.
func (self *TreeListModel) Model() *gio.ListModel {
	var _arg0 *C.GtkTreeListModel // out
	var _cret *C.GListModel       // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_model_get_model(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// Passthrough gets whether the model is passing through original row items.
//
// If this function returns FALSE, the GListModel functions for self return
// custom GtkTreeListRow objects. You need to call gtk.TreeListRow.GetItem() on
// these objects to get the original item.
//
// If TRUE, the values of the child models are passed through in their original
// state. You then need to call gtk.TreeListModel.GetRow() to get the custom
// GtkTreeListRows.
//
// The function returns the following values:
//
//   - ok: TRUE if the model is passing through original row items.
func (self *TreeListModel) Passthrough() bool {
	var _arg0 *C.GtkTreeListModel // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_model_get_passthrough(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Row gets the row object for the given row.
//
// If position is greater than the number of items in self, NULL is returned.
//
// The row object can be used to expand and collapse rows as well as to inspect
// its position in the tree. See its documentation for details.
//
// This row object is persistent and will refer to the current item as long as
// the row is present in self, independent of other rows being added or removed.
//
// If self is set to not be passthrough, this function is equivalent to calling
// g_list_model_get_item().
//
// Do not confuse this function with gtk.TreeListModel.GetChildRow().
//
// The function takes the following parameters:
//
//   - position of the row to fetch.
//
// The function returns the following values:
//
//   - treeListRow (optional): row item.
func (self *TreeListModel) Row(position uint) *TreeListRow {
	var _arg0 *C.GtkTreeListModel // out
	var _arg1 C.guint             // out
	var _cret *C.GtkTreeListRow   // in

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	_cret = C.gtk_tree_list_model_get_row(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)

	var _treeListRow *TreeListRow // out

	if _cret != nil {
		_treeListRow = wrapTreeListRow(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _treeListRow
}

// SetAutoexpand sets whether the model should autoexpand.
//
// If set to TRUE, the model will recursively expand all rows that get added to
// the model. This can be either rows added by changes to the underlying models
// or via gtk.TreeListRow.SetExpanded().
//
// The function takes the following parameters:
//
//   - autoexpand: TRUE to make the model autoexpand its rows.
func (self *TreeListModel) SetAutoexpand(autoexpand bool) {
	var _arg0 *C.GtkTreeListModel // out
	var _arg1 C.gboolean          // out

	_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if autoexpand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_list_model_set_autoexpand(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(autoexpand)
}

// TreeListRowOverrides contains methods that are overridable.
type TreeListRowOverrides struct {
}

func defaultTreeListRowOverrides(v *TreeListRow) TreeListRowOverrides {
	return TreeListRowOverrides{}
}

// TreeListRow: GtkTreeListRow is used by GtkTreeListModel to represent items.
//
// It allows navigating the model as a tree and modify the state of rows.
//
// GtkTreeListRow instances are created by a GtkTreeListModel only when the
// gtk.TreeListModel:passthrough property is not set.
//
// There are various support objects that can make use of GtkTreeListRow
// objects, such as the gtk.TreeExpander widget that allows displaying an icon
// to expand or collapse a row or gtk.TreeListRowSorter that makes it possible
// to sort trees properly.
type TreeListRow struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TreeListRow)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeListRow, *TreeListRowClass, TreeListRowOverrides](
		GTypeTreeListRow,
		initTreeListRowClass,
		wrapTreeListRow,
		defaultTreeListRowOverrides,
	)
}

func initTreeListRowClass(gclass unsafe.Pointer, overrides TreeListRowOverrides, classInitFunc func(*TreeListRowClass)) {
	if classInitFunc != nil {
		class := (*TreeListRowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeListRow(obj *coreglib.Object) *TreeListRow {
	return &TreeListRow{
		Object: obj,
	}
}

func marshalTreeListRow(p uintptr) (interface{}, error) {
	return wrapTreeListRow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ChildRow: if self is not expanded or position is greater than the number of
// children, NULL is returned.
//
// The function takes the following parameters:
//
//   - position of the child to get.
//
// The function returns the following values:
//
//   - treeListRow (optional): child in position.
func (self *TreeListRow) ChildRow(position uint) *TreeListRow {
	var _arg0 *C.GtkTreeListRow // out
	var _arg1 C.guint           // out
	var _cret *C.GtkTreeListRow // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.guint(position)

	_cret = C.gtk_tree_list_row_get_child_row(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)

	var _treeListRow *TreeListRow // out

	if _cret != nil {
		_treeListRow = wrapTreeListRow(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _treeListRow
}

// Children: if the row is expanded, gets the model holding the children of
// self.
//
// This model is the model created by the gtk.TreeListModelCreateModelFunc
// and contains the original items, no matter what value
// gtk.TreeListModel:passthrough is set to.
//
// The function returns the following values:
//
//   - listModel (optional): model containing the children.
func (self *TreeListRow) Children() *gio.ListModel {
	var _arg0 *C.GtkTreeListRow // out
	var _cret *C.GListModel     // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_get_children(_arg0)
	runtime.KeepAlive(self)

	var _listModel *gio.ListModel // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_listModel = &gio.ListModel{
				Object: obj,
			}
		}
	}

	return _listModel
}

// Depth gets the depth of this row.
//
// Rows that correspond to items in the root model have a depth of zero,
// rows corresponding to items of models of direct children of the root model
// have a depth of 1 and so on.
//
// The depth of a row never changes until the row is destroyed.
//
// The function returns the following values:
//
//   - guint: depth of this row.
func (self *TreeListRow) Depth() uint {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_get_depth(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Expanded gets if a row is currently expanded.
//
// The function returns the following values:
//
//   - ok: TRUE if the row is expanded.
func (self *TreeListRow) Expanded() bool {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_get_expanded(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Item gets the item corresponding to this row,
//
// The value returned by this function never changes until the row is destroyed.
//
// The function returns the following values:
//
//   - object (optional): item of this row or NULL when the row was destroyed.
func (self *TreeListRow) Item() *coreglib.Object {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.gpointer        // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_get_item(_arg0)
	runtime.KeepAlive(self)

	var _object *coreglib.Object // out

	_object = coreglib.AssumeOwnership(unsafe.Pointer(_cret))

	return _object
}

// Parent gets the row representing the parent for self.
//
// That is the row that would need to be collapsed to make this row disappear.
//
// If self is a row corresponding to the root model, NULL is returned.
//
// The value returned by this function never changes until the row is destroyed.
//
// The function returns the following values:
//
//   - treeListRow (optional): parent of self.
func (self *TreeListRow) Parent() *TreeListRow {
	var _arg0 *C.GtkTreeListRow // out
	var _cret *C.GtkTreeListRow // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_get_parent(_arg0)
	runtime.KeepAlive(self)

	var _treeListRow *TreeListRow // out

	if _cret != nil {
		_treeListRow = wrapTreeListRow(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	}

	return _treeListRow
}

// Position returns the position in the GtkTreeListModel that self occupies at
// the moment.
//
// The function returns the following values:
//
//   - guint: position in the model.
func (self *TreeListRow) Position() uint {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_get_position(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsExpandable checks if a row can be expanded.
//
// This does not mean that the row is actually expanded, this can be checked
// with gtk.TreeListRow.GetExpanded().
//
// If a row is expandable never changes until the row is destroyed.
//
// The function returns the following values:
//
//   - ok: TRUE if the row is expandable.
func (self *TreeListRow) IsExpandable() bool {
	var _arg0 *C.GtkTreeListRow // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_is_expandable(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetExpanded expands or collapses a row.
//
// If a row is expanded, the model of calling the
// gtk.TreeListModelCreateModelFunc for the row's item will be inserted after
// this row. If a row is collapsed, those items will be removed from the model.
//
// If the row is not expandable, this function does nothing.
//
// The function takes the following parameters:
//
//   - expanded: TRUE if the row should be expanded.
func (self *TreeListRow) SetExpanded(expanded bool) {
	var _arg0 *C.GtkTreeListRow // out
	var _arg1 C.gboolean        // out

	_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if expanded {
		_arg1 = C.TRUE
	}

	C.gtk_tree_list_row_set_expanded(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(expanded)
}

// TreeListRowSorterOverrides contains methods that are overridable.
type TreeListRowSorterOverrides struct {
}

func defaultTreeListRowSorterOverrides(v *TreeListRowSorter) TreeListRowSorterOverrides {
	return TreeListRowSorterOverrides{}
}

// TreeListRowSorter: GtkTreeListRowSorter is a special-purpose sorter that will
// apply a given sorter to the levels in a tree.
//
// Here is an example for setting up a column view with a tree model and a
// GtkTreeListSorter:
//
//	column_sorter = gtk_column_view_get_sorter (view);
//	sorter = gtk_tree_list_row_sorter_new (g_object_ref (column_sorter));
//	sort_model = gtk_sort_list_model_new (tree_model, sorter);
//	selection = gtk_single_selection_new (sort_model);
//	gtk_column_view_set_model (view, G_LIST_MODEL (selection));.
type TreeListRowSorter struct {
	_ [0]func() // equal guard
	Sorter
}

var (
	_ coreglib.Objector = (*TreeListRowSorter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeListRowSorter, *TreeListRowSorterClass, TreeListRowSorterOverrides](
		GTypeTreeListRowSorter,
		initTreeListRowSorterClass,
		wrapTreeListRowSorter,
		defaultTreeListRowSorterOverrides,
	)
}

func initTreeListRowSorterClass(gclass unsafe.Pointer, overrides TreeListRowSorterOverrides, classInitFunc func(*TreeListRowSorterClass)) {
	if classInitFunc != nil {
		class := (*TreeListRowSorterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeListRowSorter(obj *coreglib.Object) *TreeListRowSorter {
	return &TreeListRowSorter{
		Sorter: Sorter{
			Object: obj,
		},
	}
}

func marshalTreeListRowSorter(p uintptr) (interface{}, error) {
	return wrapTreeListRowSorter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTreeListRowSorter: create a special-purpose sorter that applies the
// sorting of sorter to the levels of a GtkTreeListModel.
//
// Note that this sorter relies on gtk.TreeListModel:passthrough being FALSE as
// it can only sort gtk.TreeListRows.
//
// The function takes the following parameters:
//
//   - sorter (optional): GtkSorter, or NULL.
//
// The function returns the following values:
//
//   - treeListRowSorter: new GtkTreeListRowSorter.
func NewTreeListRowSorter(sorter *Sorter) *TreeListRowSorter {
	var _arg1 *C.GtkSorter            // out
	var _cret *C.GtkTreeListRowSorter // in

	if sorter != nil {
		_arg1 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(sorter).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(sorter).Native()))
	}

	_cret = C.gtk_tree_list_row_sorter_new(_arg1)
	runtime.KeepAlive(sorter)

	var _treeListRowSorter *TreeListRowSorter // out

	_treeListRowSorter = wrapTreeListRowSorter(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeListRowSorter
}

// GetSorter returns the sorter used by self.
//
// The function returns the following values:
//
//   - sorter (optional) used.
func (self *TreeListRowSorter) GetSorter() *Sorter {
	var _arg0 *C.GtkTreeListRowSorter // out
	var _cret *C.GtkSorter            // in

	_arg0 = (*C.GtkTreeListRowSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_tree_list_row_sorter_get_sorter(_arg0)
	runtime.KeepAlive(self)

	var _sorter *Sorter // out

	if _cret != nil {
		_sorter = wrapSorter(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _sorter
}

// SetSorter sets the sorter to use for items with the same parent.
//
// This sorter will be passed the gtk.TreeListRow:item of the tree list rows
// passed to self.
//
// The function takes the following parameters:
//
//   - sorter (optional) to use, or NULL.
func (self *TreeListRowSorter) SetSorter(sorter *Sorter) {
	var _arg0 *C.GtkTreeListRowSorter // out
	var _arg1 *C.GtkSorter            // out

	_arg0 = (*C.GtkTreeListRowSorter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if sorter != nil {
		_arg1 = (*C.GtkSorter)(unsafe.Pointer(coreglib.InternObject(sorter).Native()))
	}

	C.gtk_tree_list_row_sorter_set_sorter(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(sorter)
}

// TreeModelFilterOverrides contains methods that are overridable.
type TreeModelFilterOverrides struct {
	// The function takes the following parameters:
	//
	//   - childModel
	//   - iter
	//   - value
	//   - column
	Modify func(childModel TreeModeller, iter *TreeIter, value *coreglib.Value, column int)
	// The function takes the following parameters:
	//
	//   - childModel
	//   - iter
	Visible func(childModel TreeModeller, iter *TreeIter) bool
}

func defaultTreeModelFilterOverrides(v *TreeModelFilter) TreeModelFilterOverrides {
	return TreeModelFilterOverrides{
		Modify:  v.modify,
		Visible: v.visible,
	}
}

// TreeModelFilter: gtkTreeModel which hides parts of an underlying tree model
//
// A TreeModelFilter is a tree model which wraps another tree model, and can do
// the following things:
//
// - Filter specific rows, based on data from a “visible column”, a column
// storing booleans indicating whether the row should be filtered or not,
// or based on the return value of a “visible function”, which gets a model,
// iter and user_data and returns a boolean indicating whether the row should be
// filtered or not.
//
// - Modify the “appearance” of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
//
// - Set a different root node, also known as a “virtual root”. You can pass in
// a TreePath indicating the root node for the filter at construction time.
//
// The basic API is similar to TreeModelSort. For an example on its usage,
// see the section on TreeModelSort.
//
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary
// to not compromise the caching mechanism that is exposed by the reference
// counting scheme. If the child model implements reference counting,
// unnecessary signals may not be emitted because of reference counting rule 3,
// see the TreeModel documentation. (Note that e.g. TreeStore does not implement
// reference counting and will always emit all signals, even when the receiving
// node is not visible).
//
// Because of this, limitations for possible visible functions do apply.
// In general, visible functions should only use data or properties from the
// node for which the visibility state must be determined, its siblings or
// its parents. Usually, having a dependency on the state of any child node
// is not possible, unless references are taken on these explicitly. When no
// such reference exists, no signals may be received for these child nodes (see
// reference counting rule number 3 in the TreeModel section).
//
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first
// row is added to the node’s child level (or the last row removed), the node’s
// visibility should be updated.
//
// This introduces a dependency from the node on its child nodes. In order
// to accommodate this, TreeModelFilter must make sure the necessary signals
// are received from the child model. This is achieved by building, for all
// nodes which are exposed as visible nodes to TreeModelFilter's clients,
// the child level (if any) and take a reference on the first node in this
// level. Furthermore, for every row-inserted, row-changed or row-deleted
// signal (also these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
//
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a child’s
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
type TreeModelFilter struct {
	_ [0]func() // equal guard
	*coreglib.Object

	TreeDragSource
	TreeModel
}

var (
	_ coreglib.Objector = (*TreeModelFilter)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeModelFilter, *TreeModelFilterClass, TreeModelFilterOverrides](
		GTypeTreeModelFilter,
		initTreeModelFilterClass,
		wrapTreeModelFilter,
		defaultTreeModelFilterOverrides,
	)
}

func initTreeModelFilterClass(gclass unsafe.Pointer, overrides TreeModelFilterOverrides, classInitFunc func(*TreeModelFilterClass)) {
	pclass := (*C.GtkTreeModelFilterClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTreeModelFilter))))

	if overrides.Modify != nil {
		pclass.modify = (*[0]byte)(C._gotk4_gtk4_TreeModelFilterClass_modify)
	}

	if overrides.Visible != nil {
		pclass.visible = (*[0]byte)(C._gotk4_gtk4_TreeModelFilterClass_visible)
	}

	if classInitFunc != nil {
		class := (*TreeModelFilterClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeModelFilter(obj *coreglib.Object) *TreeModelFilter {
	return &TreeModelFilter{
		Object: obj,
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeModel: TreeModel{
			Object: obj,
		},
	}
}

func marshalTreeModelFilter(p uintptr) (interface{}, error) {
	return wrapTreeModelFilter(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ClearCache: this function should almost never be called. It clears
// the filter of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (filter *TreeModelFilter) ClearCache() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gtk_tree_model_filter_clear_cache(_arg0)
	runtime.KeepAlive(filter)
}

// ConvertChildIterToIter sets filter_iter to point to the row in filter that
// corresponds to the row pointed at by child_iter. If filter_iter was not set,
// FALSE is returned.
//
// The function takes the following parameters:
//
//   - childIter: valid TreeIter pointing to a row on the child model.
//
// The function returns the following values:
//
//   - filterIter: uninitialized TreeIter.
//   - ok: TRUE, if filter_iter was set, i.e. if child_iter is a valid iterator
//     pointing to a visible row in child model.
func (filter *TreeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.GtkTreeIter         // in
	var _arg2 *C.GtkTreeIter        // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(childIter)))

	_cret = C.gtk_tree_model_filter_convert_child_iter_to_iter(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(childIter)

	var _filterIter *TreeIter // out
	var _ok bool              // out

	_filterIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _filterIter, _ok
}

// ConvertChildPathToPath converts child_path to a path relative to filter.
// That is, child_path points to a path in the child model. The rerturned path
// will point to the same row in the filtered model. If child_path isn’t a valid
// path on the child model or points to a row which is not visible in filter,
// then NULL is returned.
//
// The function takes the following parameters:
//
//   - childPath to convert.
//
// The function returns the following values:
//
//   - treePath (optional): newly allocated TreePath, or NULL.
func (filter *TreeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(childPath)))

	_cret = C.gtk_tree_model_filter_convert_child_path_to_path(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(childPath)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// ConvertIterToChildIter sets child_iter to point to the row pointed to by
// filter_iter.
//
// The function takes the following parameters:
//
//   - filterIter: valid TreeIter pointing to a row on filter.
//
// The function returns the following values:
//
//   - childIter: uninitialized TreeIter.
func (filter *TreeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) *TreeIter {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.GtkTreeIter         // in
	var _arg2 *C.GtkTreeIter        // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(filterIter)))

	C.gtk_tree_model_filter_convert_iter_to_child_iter(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(filterIter)

	var _childIter *TreeIter // out

	_childIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _childIter
}

// ConvertPathToChildPath converts filter_path to a path on the child model of
// filter. That is, filter_path points to a location in filter. The returned
// path will point to the same location in the model not being filtered.
// If filter_path does not point to a location in the child model, NULL is
// returned.
//
// The function takes the following parameters:
//
//   - filterPath to convert.
//
// The function returns the following values:
//
//   - treePath (optional): newly allocated TreePath, or NULL.
func (filter *TreeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreePath        // out
	var _cret *C.GtkTreePath        // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(filterPath)))

	_cret = C.gtk_tree_model_filter_convert_path_to_child_path(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(filterPath)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// Model returns a pointer to the child model of filter.
//
// The function returns the following values:
//
//   - treeModel: pointer to a TreeModel.
func (filter *TreeModelFilter) Model() *TreeModel {
	var _arg0 *C.GtkTreeModelFilter // out
	var _cret *C.GtkTreeModel       // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	_cret = C.gtk_tree_model_filter_get_model(_arg0)
	runtime.KeepAlive(filter)

	var _treeModel *TreeModel // out

	_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeModel
}

// Refilter emits ::row_changed for each row in the child model, which causes
// the filter to re-evaluate whether a row is visible or not.
func (filter *TreeModelFilter) Refilter() {
	var _arg0 *C.GtkTreeModelFilter // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))

	C.gtk_tree_model_filter_refilter(_arg0)
	runtime.KeepAlive(filter)
}

// SetModifyFunc: with the n_columns and types parameters, you give an array of
// column types for this model (which will be exposed to the parent model/view).
// The func, data and destroy parameters are for specifying the modify function.
// The modify function will get called for each data access, the goal of the
// modify function is to return the data which should be displayed at the
// location specified using the parameters of the modify function.
//
// Note that gtk_tree_model_filter_set_modify_func() can only be called once for
// a given filter model.
//
// The function takes the following parameters:
//
//   - types of the columns.
//   - fn: TreeModelFilterModifyFunc.
func (filter *TreeModelFilter) SetModifyFunc(types []coreglib.Type, fn TreeModelFilterModifyFunc) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg2 *C.GType              // out
	var _arg1 C.int
	var _arg3 C.GtkTreeModelFilterModifyFunc // out
	var _arg4 C.gpointer
	var _arg5 C.GDestroyNotify

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (C.int)(len(types))
	_arg2 = (*C.GType)(C.calloc(C.size_t(len(types)), C.size_t(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GType)(_arg2), len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}
	_arg3 = (*[0]byte)(C._gotk4_gtk4_TreeModelFilterModifyFunc)
	_arg4 = C.gpointer(gbox.Assign(fn))
	_arg5 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_tree_model_filter_set_modify_func(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(types)
	runtime.KeepAlive(fn)
}

// SetVisibleColumn sets column of the child_model to be the column where filter
// should look for visibility information. columns should be a column of type
// G_TYPE_BOOLEAN, where TRUE means that a row is visible, and FALSE if not.
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
//
// The function takes the following parameters:
//
//   - column which is the column containing the visible information.
func (filter *TreeModelFilter) SetVisibleColumn(column int) {
	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 C.int                 // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = C.int(column)

	C.gtk_tree_model_filter_set_visible_column(_arg0, _arg1)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(column)
}

// SetVisibleFunc sets the visible function used when filtering the filter to be
// func. The function should return TRUE if the given row should be visible and
// FALSE otherwise.
//
// If the condition calculated by the function changes over time (e.g.
// because it depends on some global parameters), you must call
// gtk_tree_model_filter_refilter() to keep the visibility information of the
// model up-to-date.
//
// Note that func is called whenever a row is inserted, when it may still be
// empty. The visible function should therefore take special care of empty rows,
// like in the example below.
//
//	static gboolean
//	visible_func (GtkTreeModel *model,
//	              GtkTreeIter  *iter,
//	              gpointer      data)
//	{
//	  // Visible if row is non-empty and first column is “HI”
//	  char *str;
//	  gboolean visible = FALSE;
//
//	  gtk_tree_model_get (model, iter, 0, &str, -1);
//	  if (str && strcmp (str, "HI") == 0)
//	    visible = TRUE;
//	  g_free (str);
//
//	  return visible;
//	}
//
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
//
// The function takes the following parameters:
//
//   - fn the visible function.
func (filter *TreeModelFilter) SetVisibleFunc(fn TreeModelFilterVisibleFunc) {
	var _arg0 *C.GtkTreeModelFilter           // out
	var _arg1 C.GtkTreeModelFilterVisibleFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(filter).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeModelFilterVisibleFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_tree_model_filter_set_visible_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(filter)
	runtime.KeepAlive(fn)
}

// The function takes the following parameters:
//
//   - childModel
//   - iter
//   - value
//   - column
func (self *TreeModelFilter) modify(childModel TreeModeller, iter *TreeIter, value *coreglib.Value, column int) {
	gclass := (*C.GtkTreeModelFilterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.modify

	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreeModel       // out
	var _arg2 *C.GtkTreeIter        // out
	var _arg3 *C.GValue             // out
	var _arg4 C.int                 // out

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(childModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))
	_arg4 = C.int(column)

	C._gotk4_gtk4_TreeModelFilter_virtual_modify(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(childModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(value)
	runtime.KeepAlive(column)
}

// The function takes the following parameters:
//
//   - childModel
//   - iter
func (self *TreeModelFilter) visible(childModel TreeModeller, iter *TreeIter) bool {
	gclass := (*C.GtkTreeModelFilterClass)(coreglib.PeekParentClass(self))
	fnarg := gclass.visible

	var _arg0 *C.GtkTreeModelFilter // out
	var _arg1 *C.GtkTreeModel       // out
	var _arg2 *C.GtkTreeIter        // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(childModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C._gotk4_gtk4_TreeModelFilter_virtual_visible(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(childModel)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeModelSortOverrides contains methods that are overridable.
type TreeModelSortOverrides struct {
}

func defaultTreeModelSortOverrides(v *TreeModelSort) TreeModelSortOverrides {
	return TreeModelSortOverrides{}
}

// TreeModelSort: gtkTreeModel which makes an underlying tree model sortable
//
// The TreeModelSort is a model which implements the TreeSortable interface.
// It does not hold any data itself, but rather is created with a child model
// and proxies its data. It has identical column types to this child model, and
// the changes in the child are propagated. The primary purpose of this model
// is to provide a way to sort a different model without modifying it. Note that
// the sort function used by TreeModelSort is not guaranteed to be stable.
//
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can
// each sort their view of the data without affecting the other. By contrast,
// if we simply put the same model in each widget, then sorting the first would
// sort the second.
//
// Using a TreeModelSort
//
//	void
//	selection_changed (GtkTreeSelection *selection, gpointer data)
//	{
//	  GtkTreeModel *sort_model = NULL;
//	  GtkTreeModel *child_model;
//	  GtkTreeIter sort_iter;
//	  GtkTreeIter child_iter;
//	  char *some_data = NULL;
//	  char *modified_data;
//
//	  // Get the current selected row and the model.
//	  if (! gtk_tree_selection_get_selected (selection,
//	                                         &sort_model,
//	                                         &sort_iter))
//	    return;
//
//	  // Look up the current value on the selected row and get
//	  // a new value to change it to.
//	  gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//	                      COLUMN_1, &some_data,
//	                      -1);
//
//	  modified_data = change_the_data (some_data);
//	  g_free (some_data);
//
//	  // Get an iterator on the child model, instead of the sort model.
//	  gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//	                                                  &child_iter,
//	                                                  &sort_iter);
//
//	  // Get the child model and change the value of the row. In this
//	  // example, the child model is a GtkListStore. It could be any other
//	  // type of model, though.
//	  child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//	  gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//	                      COLUMN_1, &modified_data,
//	                      -1);
//	  g_free (modified_data);
//	}.
type TreeModelSort struct {
	_ [0]func() // equal guard
	*coreglib.Object

	TreeDragSource
	TreeSortable
}

var (
	_ coreglib.Objector = (*TreeModelSort)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeModelSort, *TreeModelSortClass, TreeModelSortOverrides](
		GTypeTreeModelSort,
		initTreeModelSortClass,
		wrapTreeModelSort,
		defaultTreeModelSortOverrides,
	)
}

func initTreeModelSortClass(gclass unsafe.Pointer, overrides TreeModelSortOverrides, classInitFunc func(*TreeModelSortClass)) {
	if classInitFunc != nil {
		class := (*TreeModelSortClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeModelSort(obj *coreglib.Object) *TreeModelSort {
	return &TreeModelSort{
		Object: obj,
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeSortable: TreeSortable{
			TreeModel: TreeModel{
				Object: obj,
			},
		},
	}
}

func marshalTreeModelSort(p uintptr) (interface{}, error) {
	return wrapTreeModelSort(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTreeModelSortWithModel creates a new TreeModelSort, with child_model as
// the child model.
//
// The function takes the following parameters:
//
//   - childModel: TreeModel.
//
// The function returns the following values:
//
//   - treeModelSort: new TreeModelSort.
func NewTreeModelSortWithModel(childModel TreeModeller) *TreeModelSort {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkTreeModel // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(childModel).Native()))

	_cret = C.gtk_tree_model_sort_new_with_model(_arg1)
	runtime.KeepAlive(childModel)

	var _treeModelSort *TreeModelSort // out

	_treeModelSort = wrapTreeModelSort(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeModelSort
}

// ClearCache: this function should almost never be called. It clears the
// tree_model_sort of any cached iterators that haven’t been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// sorted is static (and doesn’t change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
func (treeModelSort *TreeModelSort) ClearCache() {
	var _arg0 *C.GtkTreeModelSort // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModelSort).Native()))

	C.gtk_tree_model_sort_clear_cache(_arg0)
	runtime.KeepAlive(treeModelSort)
}

// ConvertChildIterToIter sets sort_iter to point to the row in tree_model_sort
// that corresponds to the row pointed at by child_iter. If sort_iter was not
// set, FALSE is returned. Note: a boolean is only returned since 2.14.
//
// The function takes the following parameters:
//
//   - childIter: valid TreeIter pointing to a row on the child model.
//
// The function returns the following values:
//
//   - sortIter: uninitialized TreeIter.
//   - ok: TRUE, if sort_iter was set, i.e. if sort_iter is a valid iterator
//     pointer to a visible row in the child model.
func (treeModelSort *TreeModelSort) ConvertChildIterToIter(childIter *TreeIter) (*TreeIter, bool) {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 C.GtkTreeIter       // in
	var _arg2 *C.GtkTreeIter      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModelSort).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(childIter)))

	_cret = C.gtk_tree_model_sort_convert_child_iter_to_iter(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModelSort)
	runtime.KeepAlive(childIter)

	var _sortIter *TreeIter // out
	var _ok bool            // out

	_sortIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _sortIter, _ok
}

// ConvertChildPathToPath converts child_path to a path relative to
// tree_model_sort. That is, child_path points to a path in the child model. The
// returned path will point to the same row in the sorted model. If child_path
// isn’t a valid path on the child model, then NULL is returned.
//
// The function takes the following parameters:
//
//   - childPath to convert.
//
// The function returns the following values:
//
//   - treePath (optional): newly allocated TreePath, or NULL.
func (treeModelSort *TreeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreePath      // out
	var _cret *C.GtkTreePath      // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModelSort).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(childPath)))

	_cret = C.gtk_tree_model_sort_convert_child_path_to_path(_arg0, _arg1)
	runtime.KeepAlive(treeModelSort)
	runtime.KeepAlive(childPath)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// ConvertIterToChildIter sets child_iter to point to the row pointed to by
// sorted_iter.
//
// The function takes the following parameters:
//
//   - sortedIter: valid TreeIter pointing to a row on tree_model_sort.
//
// The function returns the following values:
//
//   - childIter: uninitialized TreeIter.
func (treeModelSort *TreeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) *TreeIter {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 C.GtkTreeIter       // in
	var _arg2 *C.GtkTreeIter      // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModelSort).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(sortedIter)))

	C.gtk_tree_model_sort_convert_iter_to_child_iter(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeModelSort)
	runtime.KeepAlive(sortedIter)

	var _childIter *TreeIter // out

	_childIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _childIter
}

// ConvertPathToChildPath converts sorted_path to a path on the child
// model of tree_model_sort. That is, sorted_path points to a location in
// tree_model_sort. The returned path will point to the same location in the
// model not being sorted. If sorted_path does not point to a location in the
// child model, NULL is returned.
//
// The function takes the following parameters:
//
//   - sortedPath to convert.
//
// The function returns the following values:
//
//   - treePath (optional): newly allocated TreePath, or NULL.
func (treeModelSort *TreeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreePath      // out
	var _cret *C.GtkTreePath      // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModelSort).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(sortedPath)))

	_cret = C.gtk_tree_model_sort_convert_path_to_child_path(_arg0, _arg1)
	runtime.KeepAlive(treeModelSort)
	runtime.KeepAlive(sortedPath)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// Model returns the model the TreeModelSort is sorting.
//
// The function returns the following values:
//
//   - treeModel: "child model" being sorted.
func (treeModel *TreeModelSort) Model() *TreeModel {
	var _arg0 *C.GtkTreeModelSort // out
	var _cret *C.GtkTreeModel     // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))

	_cret = C.gtk_tree_model_sort_get_model(_arg0)
	runtime.KeepAlive(treeModel)

	var _treeModel *TreeModel // out

	_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeModel
}

// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
//
// Checks if the given iter is a valid iter for this TreeModelSort.
//
// The function takes the following parameters:
//
//   - iter: TreeIter.
//
// The function returns the following values:
//
//   - ok: TRUE if the iter is valid, FALSE if the iter is invalid.
func (treeModelSort *TreeModelSort) IterIsValid(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeModelSort // out
	var _arg1 *C.GtkTreeIter      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModelSort).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_model_sort_iter_is_valid(_arg0, _arg1)
	runtime.KeepAlive(treeModelSort)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ResetDefaultSortFunc: this resets the default sort function to be in the
// “unsorted” state. That is, it is in the same order as the child model.
// It will re-sort the model to be in the same order as the child model only if
// the TreeModelSort is in “unsorted” state.
func (treeModelSort *TreeModelSort) ResetDefaultSortFunc() {
	var _arg0 *C.GtkTreeModelSort // out

	_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(coreglib.InternObject(treeModelSort).Native()))

	C.gtk_tree_model_sort_reset_default_sort_func(_arg0)
	runtime.KeepAlive(treeModelSort)
}

// TreeSelection: selection object for GtkTreeView
//
// The TreeSelection object is a helper object to manage the selection for a
// TreeView widget. The TreeSelection object is automatically created when a new
// TreeView widget is created, and cannot exist independently of this widget.
// The primary reason the TreeSelection objects exists is for cleanliness of
// code and API. That is, there is no conceptual reason all these functions
// could not be methods on the TreeView widget instead of a separate function.
//
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
//
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is,
// it may only emit one signal when a range of rows is selected. Additionally,
// it may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
type TreeSelection struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*TreeSelection)(nil)
)

func wrapTreeSelection(obj *coreglib.Object) *TreeSelection {
	return &TreeSelection{
		Object: obj,
	}
}

func marshalTreeSelection(p uintptr) (interface{}, error) {
	return wrapTreeSelection(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectChanged is emitted whenever the selection has (possibly) changed.
// Please note that this signal is mostly a hint. It may only be emitted once
// when a range of rows are selected, and it may occasionally be emitted when
// nothing has happened.
func (selection *TreeSelection) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(selection, "changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeSelection_ConnectChanged), f)
}

// CountSelectedRows returns the number of rows that have been selected in tree.
//
// The function returns the following values:
//
//   - gint: number of rows selected.
func (selection *TreeSelection) CountSelectedRows() int {
	var _arg0 *C.GtkTreeSelection // out
	var _cret C.int               // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))

	_cret = C.gtk_tree_selection_count_selected_rows(_arg0)
	runtime.KeepAlive(selection)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Mode gets the selection mode for selection. See
// gtk_tree_selection_set_mode().
//
// The function returns the following values:
//
//   - selectionMode: current selection mode.
func (selection *TreeSelection) Mode() SelectionMode {
	var _arg0 *C.GtkTreeSelection // out
	var _cret C.GtkSelectionMode  // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))

	_cret = C.gtk_tree_selection_get_mode(_arg0)
	runtime.KeepAlive(selection)

	var _selectionMode SelectionMode // out

	_selectionMode = SelectionMode(_cret)

	return _selectionMode
}

// Selected sets iter to the currently selected node if selection is set to
// K_SELECTION_SINGLE or K_SELECTION_BROWSE. iter may be NULL if you just want
// to test if selection has any selected nodes. model is filled with the current
// model as a convenience. This function will not work if you use selection is
// K_SELECTION_MULTIPLE.
//
// The function returns the following values:
//
//   - model (optional): pointer to set to the TreeModel, or NULL.
//   - iter (optional) or NULL.
//   - ok: TRUE, if there is a selected node.
func (selection *TreeSelection) Selected() (*TreeModel, *TreeIter, bool) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeModel     // in
	var _arg2 C.GtkTreeIter       // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))

	_cret = C.gtk_tree_selection_get_selected(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(selection)

	var _model *TreeModel // out
	var _iter *TreeIter   // out
	var _ok bool          // out

	if _arg1 != nil {
		_model = wrapTreeModel(coreglib.Take(unsafe.Pointer(_arg1)))
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _model, _iter, _ok
}

// SelectedRows creates a list of path of all selected rows. Additionally,
// if you are planning on modifying the model after calling this function,
// you may want to convert the returned list into a list of TreeRowReferences.
// To do this, you can use gtk_tree_row_reference_new().
//
// To free the return value, use:
//
//	g_list_free_full (list, (GDestroyNotify) gtk_tree_path_free);.
//
// The function returns the following values:
//
//   - model (optional): pointer to set to the TreeModel, or NULL.
//   - list containing a TreePath for each selected row.
func (selection *TreeSelection) SelectedRows() (*TreeModel, []*TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeModel     // in
	var _cret *C.GList            // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))

	_cret = C.gtk_tree_selection_get_selected_rows(_arg0, &_arg1)
	runtime.KeepAlive(selection)

	var _model *TreeModel // out
	var _list []*TreePath // out

	if _arg1 != nil {
		_model = wrapTreeModel(coreglib.Take(unsafe.Pointer(_arg1)))
	}
	_list = make([]*TreePath, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkTreePath)(v)
		var dst *TreePath // out
		dst = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _model, _list
}

// TreeView returns the tree view associated with selection.
//
// The function returns the following values:
//
//   - treeView: TreeView.
func (selection *TreeSelection) TreeView() *TreeView {
	var _arg0 *C.GtkTreeSelection // out
	var _cret *C.GtkTreeView      // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))

	_cret = C.gtk_tree_selection_get_tree_view(_arg0)
	runtime.KeepAlive(selection)

	var _treeView *TreeView // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// IterIsSelected returns TRUE if the row at iter is currently selected.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter.
//
// The function returns the following values:
//
//   - ok: TRUE, if iter is selected.
func (selection *TreeSelection) IterIsSelected(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_selection_iter_is_selected(_arg0, _arg1)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PathIsSelected returns TRUE if the row pointed to by path is currently
// selected. If path does not point to a valid location, FALSE is returned.
//
// The function takes the following parameters:
//
//   - path to check selection on.
//
// The function returns the following values:
//
//   - ok: TRUE if path is selected.
func (selection *TreeSelection) PathIsSelected(path *TreePath) bool {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_selection_path_is_selected(_arg0, _arg1)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectAll selects all the nodes. selection must be set to
// K_SELECTION_MULTIPLE mode.
func (selection *TreeSelection) SelectAll() {
	var _arg0 *C.GtkTreeSelection // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))

	C.gtk_tree_selection_select_all(_arg0)
	runtime.KeepAlive(selection)
}

// SelectIter selects the specified iterator.
//
// The function takes the following parameters:
//
//   - iter to be selected.
func (selection *TreeSelection) SelectIter(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_selection_select_iter(_arg0, _arg1)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(iter)
}

// SelectPath: select the row at path.
//
// The function takes the following parameters:
//
//   - path to be selected.
func (selection *TreeSelection) SelectPath(path *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_selection_select_path(_arg0, _arg1)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(path)
}

// SelectRange selects a range of nodes, determined by start_path and end_path
// inclusive. selection must be set to K_SELECTION_MULTIPLE mode.
//
// The function takes the following parameters:
//
//   - startPath: initial node of the range.
//   - endPath: final node of the range.
func (selection *TreeSelection) SelectRange(startPath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(startPath)))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(endPath)))

	C.gtk_tree_selection_select_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(startPath)
	runtime.KeepAlive(endPath)
}

// SelectedForEach calls a function for each selected node. Note that you
// cannot modify the tree or selection from within this function. As a result,
// gtk_tree_selection_get_selected_rows() might be more useful.
//
// The function takes the following parameters:
//
//   - fn: function to call for each selected node.
func (selection *TreeSelection) SelectedForEach(fn TreeSelectionForEachFunc) {
	var _arg0 *C.GtkTreeSelection           // out
	var _arg1 C.GtkTreeSelectionForeachFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeSelectionForEachFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_tree_selection_selected_foreach(_arg0, _arg1, _arg2)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(fn)
}

// SetMode sets the selection mode of the selection. If the previous type was
// K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was previously
// selected.
//
// The function takes the following parameters:
//
//   - typ: selection mode.
func (selection *TreeSelection) SetMode(typ SelectionMode) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 C.GtkSelectionMode  // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = C.GtkSelectionMode(typ)

	C.gtk_tree_selection_set_mode(_arg0, _arg1)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(typ)
}

// SetSelectFunction sets the selection function.
//
// If set, this function is called before any node is selected or unselected,
// giving some control over which nodes are selected. The select function should
// return TRUE if the state of the node may be toggled, and FALSE if the state
// of the node should be left unchanged.
//
// The function takes the following parameters:
//
//   - fn (optional): selection function. May be NULL.
func (selection *TreeSelection) SetSelectFunction(fn TreeSelectionFunc) {
	var _arg0 *C.GtkTreeSelection    // out
	var _arg1 C.GtkTreeSelectionFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeSelectionFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_tree_selection_set_select_function(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(fn)
}

// UnselectAll unselects all the nodes.
func (selection *TreeSelection) UnselectAll() {
	var _arg0 *C.GtkTreeSelection // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))

	C.gtk_tree_selection_unselect_all(_arg0)
	runtime.KeepAlive(selection)
}

// UnselectIter unselects the specified iterator.
//
// The function takes the following parameters:
//
//   - iter to be unselected.
func (selection *TreeSelection) UnselectIter(iter *TreeIter) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreeIter      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_tree_selection_unselect_iter(_arg0, _arg1)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(iter)
}

// UnselectPath unselects the row at path.
//
// The function takes the following parameters:
//
//   - path to be unselected.
func (selection *TreeSelection) UnselectPath(path *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_selection_unselect_path(_arg0, _arg1)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(path)
}

// UnselectRange unselects a range of nodes, determined by start_path and
// end_path inclusive.
//
// The function takes the following parameters:
//
//   - startPath: initial node of the range.
//   - endPath: initial node of the range.
func (selection *TreeSelection) UnselectRange(startPath, endPath *TreePath) {
	var _arg0 *C.GtkTreeSelection // out
	var _arg1 *C.GtkTreePath      // out
	var _arg2 *C.GtkTreePath      // out

	_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(coreglib.InternObject(selection).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(startPath)))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(endPath)))

	C.gtk_tree_selection_unselect_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(selection)
	runtime.KeepAlive(startPath)
	runtime.KeepAlive(endPath)
}

// TreeStoreOverrides contains methods that are overridable.
type TreeStoreOverrides struct {
}

func defaultTreeStoreOverrides(v *TreeStore) TreeStoreOverrides {
	return TreeStoreOverrides{}
}

// TreeStore: tree-like data structure that can be used with the GtkTreeView
//
// The TreeStore object is a list model for use with a TreeView widget.
// It implements the TreeModel interface, and consequently, can use all of the
// methods available there. It also implements the TreeSortable interface so
// it can be sorted by the view. Finally, it also implements the tree [drag and
// drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
//
// # GtkTreeStore as GtkBuildable
//
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The “type” attribute specifies
// the data type for the column.
//
// An example of a UI Definition fragment for a tree store:
//
//	<object class="GtkTreeStore">
//	  <columns>
//	    <column type="gchararray"/>
//	    <column type="gchararray"/>
//	    <column type="gint"/>
//	  </columns>
//	</object>.
type TreeStore struct {
	_ [0]func() // equal guard
	*coreglib.Object

	Buildable
	TreeDragDest
	TreeDragSource
	TreeSortable
}

var (
	_ coreglib.Objector = (*TreeStore)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeStore, *TreeStoreClass, TreeStoreOverrides](
		GTypeTreeStore,
		initTreeStoreClass,
		wrapTreeStore,
		defaultTreeStoreOverrides,
	)
}

func initTreeStoreClass(gclass unsafe.Pointer, overrides TreeStoreOverrides, classInitFunc func(*TreeStoreClass)) {
	if classInitFunc != nil {
		class := (*TreeStoreClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeStore(obj *coreglib.Object) *TreeStore {
	return &TreeStore{
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		TreeDragDest: TreeDragDest{
			Object: obj,
		},
		TreeDragSource: TreeDragSource{
			Object: obj,
		},
		TreeSortable: TreeSortable{
			TreeModel: TreeModel{
				Object: obj,
			},
		},
	}
}

func marshalTreeStore(p uintptr) (interface{}, error) {
	return wrapTreeStore(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewTreeStore: non vararg creation function. Used primarily by language
// bindings.
//
// The function takes the following parameters:
//
//   - types: array of #GType types for the columns, from first to last.
//
// The function returns the following values:
//
//   - treeStore: new TreeStore.
func NewTreeStore(types []coreglib.Type) *TreeStore {
	var _arg2 *C.GType // out
	var _arg1 C.int
	var _cret *C.GtkTreeStore // in

	_arg1 = (C.int)(len(types))
	_arg2 = (*C.GType)(C.calloc(C.size_t(len(types)), C.size_t(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GType)(_arg2), len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	_cret = C.gtk_tree_store_newv(_arg1, _arg2)
	runtime.KeepAlive(types)

	var _treeStore *TreeStore // out

	_treeStore = wrapTreeStore(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _treeStore
}

// Append appends a new row to tree_store. If parent is non-NULL, then it will
// append the new row after the last child of parent, otherwise it will append
// a row to the top level. iter will be changed to point to this new row.
// The row will be empty after this function is called. To fill in values,
// you need to call gtk_tree_store_set() or gtk_tree_store_set_value().
//
// The function takes the following parameters:
//
//   - parent (optional): valid TreeIter, or NULL.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the appended row.
func (treeStore *TreeStore) Append(parent *TreeIter) *TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}

	C.gtk_tree_store_append(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(parent)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// Clear removes all rows from tree_store.
func (treeStore *TreeStore) Clear() {
	var _arg0 *C.GtkTreeStore // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))

	C.gtk_tree_store_clear(_arg0)
	runtime.KeepAlive(treeStore)
}

// Insert creates a new row at position. If parent is non-NULL, then the row
// will be made a child of parent. Otherwise, the row will be created at the
// toplevel. If position is -1 or is larger than the number of rows at that
// level, then the new row will be inserted to the end of the list. iter will be
// changed to point to this new row. The row will be empty after this function
// is called. To fill in values, you need to call gtk_tree_store_set() or
// gtk_tree_store_set_value().
//
// The function takes the following parameters:
//
//   - parent (optional): valid TreeIter, or NULL.
//   - position to insert the new row, or -1 for last.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the new row.
func (treeStore *TreeStore) Insert(parent *TreeIter, position int) *TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.int           // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	_arg3 = C.int(position)

	C.gtk_tree_store_insert(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(position)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// InsertAfter inserts a new row after sibling. If sibling is NULL, then the
// row will be prepended to parent ’s children. If parent and sibling are NULL,
// then the row will be prepended to the toplevel. If both sibling and parent
// are set, then parent must be the parent of sibling. When sibling is set,
// parent is optional.
//
// iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
//
// The function takes the following parameters:
//
//   - parent (optional): valid TreeIter, or NULL.
//   - sibling (optional): valid TreeIter, or NULL.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the new row.
func (treeStore *TreeStore) InsertAfter(parent, sibling *TreeIter) *TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	if sibling != nil {
		_arg3 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(sibling)))
	}

	C.gtk_tree_store_insert_after(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(sibling)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// InsertBefore inserts a new row before sibling. If sibling is NULL, then the
// row will be appended to parent ’s children. If parent and sibling are NULL,
// then the row will be appended to the toplevel. If both sibling and parent
// are set, then parent must be the parent of sibling. When sibling is set,
// parent is optional.
//
// iter will be changed to point to this new row. The row will be empty
// after this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
//
// The function takes the following parameters:
//
//   - parent (optional): valid TreeIter, or NULL.
//   - sibling (optional): valid TreeIter, or NULL.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the new row.
func (treeStore *TreeStore) InsertBefore(parent, sibling *TreeIter) *TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	if sibling != nil {
		_arg3 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(sibling)))
	}

	C.gtk_tree_store_insert_before(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(sibling)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// InsertWithValues: variant of gtk_tree_store_insert_with_values() which takes
// the columns and values as two arrays, instead of varargs. This function is
// mainly intended for language bindings.
//
// The function takes the following parameters:
//
//   - parent (optional): valid TreeIter, or NULL.
//   - position to insert the new row, or -1 for last.
//   - columns: array of column numbers.
//   - values: array of GValues.
//
// The function returns the following values:
//
//   - iter (optional): unset TreeIter to set the new row, or NULL.
func (treeStore *TreeStore) InsertWithValues(parent *TreeIter, position int, columns []int, values []coreglib.Value) *TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out
	var _arg3 C.int           // out
	var _arg4 *C.int          // out
	var _arg6 C.int
	var _arg5 *C.GValue // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}
	_arg3 = C.int(position)
	_arg6 = (C.int)(len(columns))
	_arg4 = (*C.int)(C.calloc(C.size_t(len(columns)), C.size_t(C.sizeof_int)))
	defer C.free(unsafe.Pointer(_arg4))
	{
		out := unsafe.Slice((*C.int)(_arg4), len(columns))
		for i := range columns {
			out[i] = C.int(columns[i])
		}
	}
	_arg6 = (C.int)(len(values))
	_arg5 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg5))
	{
		out := unsafe.Slice((*C.GValue)(_arg5), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	C.gtk_tree_store_insert_with_valuesv(_arg0, &_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(position)
	runtime.KeepAlive(columns)
	runtime.KeepAlive(values)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IsAncestor returns TRUE if iter is an ancestor of descendant. That is,
// iter is the parent (or grandparent or great-grandparent) of descendant.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter.
//   - descendant: valid TreeIter.
//
// The function returns the following values:
//
//   - ok: TRUE, if iter is an ancestor of descendant.
func (treeStore *TreeStore) IsAncestor(iter, descendant *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(descendant)))

	_cret = C.gtk_tree_store_is_ancestor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(descendant)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IterDepth returns the depth of iter. This will be 0 for anything on the root
// level, 1 for anything down a level, etc.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter.
//
// The function returns the following values:
//
//   - gint: depth of iter.
func (treeStore *TreeStore) IterDepth(iter *TreeIter) int {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.int           // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_store_iter_depth(_arg0, _arg1)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IterIsValid: WARNING: This function is slow. Only use it for debugging and/or
// testing purposes.
//
// Checks if the given iter is a valid iter for this TreeStore.
//
// The function takes the following parameters:
//
//   - iter: TreeIter.
//
// The function returns the following values:
//
//   - ok: TRUE if the iter is valid, FALSE if the iter is invalid.
func (treeStore *TreeStore) IterIsValid(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_store_iter_is_valid(_arg0, _arg1)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveAfter moves iter in tree_store to the position after position. iter and
// position should be in the same level. Note that this function only works with
// unsorted stores. If position is NULL, iter will be moved to the start of the
// level.
//
// The function takes the following parameters:
//
//   - iter: TreeIter.
//   - position (optional): TreeIter.
func (treeStore *TreeStore) MoveAfter(iter, position *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if position != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(position)))
	}

	C.gtk_tree_store_move_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(position)
}

// MoveBefore moves iter in tree_store to the position before position. iter and
// position should be in the same level. Note that this function only works with
// unsorted stores. If position is NULL, iter will be moved to the end of the
// level.
//
// The function takes the following parameters:
//
//   - iter: TreeIter.
//   - position (optional) or NULL.
func (treeStore *TreeStore) MoveBefore(iter, position *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if position != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(position)))
	}

	C.gtk_tree_store_move_before(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(position)
}

// Prepend prepends a new row to tree_store. If parent is non-NULL, then it
// will prepend the new row before the first child of parent, otherwise it will
// prepend a row to the top level. iter will be changed to point to this new
// row. The row will be empty after this function is called. To fill in values,
// you need to call gtk_tree_store_set() or gtk_tree_store_set_value().
//
// The function takes the following parameters:
//
//   - parent (optional): valid TreeIter, or NULL.
//
// The function returns the following values:
//
//   - iter: unset TreeIter to set to the prepended row.
func (treeStore *TreeStore) Prepend(parent *TreeIter) *TreeIter {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 C.GtkTreeIter   // in
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	if parent != nil {
		_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(parent)))
	}

	C.gtk_tree_store_prepend(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(parent)

	var _iter *TreeIter // out

	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// Remove removes iter from tree_store. After being removed, iter is set to the
// next valid row at that level, or invalidated if it previously pointed to the
// last one.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is still valid, FALSE if not.
func (treeStore *TreeStore) Remove(iter *TreeIter) bool {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_store_remove(_arg0, _arg1)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from TreeStore, and should only be used when constructing a new TreeStore.
// It will not function after a row has been added, or a method on the TreeModel
// interface is called.
//
// The function takes the following parameters:
//
//   - types: array of #GType types, one for each column.
func (treeStore *TreeStore) SetColumnTypes(types []coreglib.Type) {
	var _arg0 *C.GtkTreeStore // out
	var _arg2 *C.GType        // out
	var _arg1 C.int

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (C.int)(len(types))
	_arg2 = (*C.GType)(C.calloc(C.size_t(len(types)), C.size_t(C.sizeof_GType)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.GType)(_arg2), len(types))
		for i := range types {
			out[i] = C.GType(types[i])
		}
	}

	C.gtk_tree_store_set_column_types(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(types)
}

// SetValue sets the data in the cell specified by iter and column. The type of
// value must be convertible to the type of the column.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter for the row being modified.
//   - column number to modify.
//   - value: new value for the cell.
func (treeStore *TreeStore) SetValue(iter *TreeIter, column int, value *coreglib.Value) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 C.int           // out
	var _arg3 *C.GValue       // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = C.int(column)
	_arg3 = (*C.GValue)(unsafe.Pointer(value.Native()))

	C.gtk_tree_store_set_value(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(column)
	runtime.KeepAlive(value)
}

// Set: variant of gtk_tree_store_set_valist() which takes the columns and
// values as two arrays, instead of varargs. This function is mainly intended
// for language bindings or in case the number of columns to change is not known
// until run-time.
//
// The function takes the following parameters:
//
//   - iter: valid TreeIter for the row being modified.
//   - columns: array of column numbers.
//   - values: array of GValues.
func (treeStore *TreeStore) Set(iter *TreeIter, columns []int, values []coreglib.Value) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.int          // out
	var _arg4 C.int
	var _arg3 *C.GValue // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg4 = (C.int)(len(columns))
	_arg2 = (*C.int)(C.calloc(C.size_t(len(columns)), C.size_t(C.sizeof_int)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		out := unsafe.Slice((*C.int)(_arg2), len(columns))
		for i := range columns {
			out[i] = C.int(columns[i])
		}
	}
	_arg4 = (C.int)(len(values))
	_arg3 = (*C.GValue)(C.calloc(C.size_t(len(values)), C.size_t(C.sizeof_GValue)))
	defer C.free(unsafe.Pointer(_arg3))
	{
		out := unsafe.Slice((*C.GValue)(_arg3), len(values))
		for i := range values {
			out[i] = *(*C.GValue)(unsafe.Pointer((&values[i]).Native()))
		}
	}

	C.gtk_tree_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(columns)
	runtime.KeepAlive(values)
}

// Swap swaps a and b in the same level of tree_store. Note that this function
// only works with unsorted stores.
//
// The function takes the following parameters:
//
//   - a: TreeIter.
//   - b: another TreeIter.
func (treeStore *TreeStore) Swap(a, b *TreeIter) {
	var _arg0 *C.GtkTreeStore // out
	var _arg1 *C.GtkTreeIter  // out
	var _arg2 *C.GtkTreeIter  // out

	_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(coreglib.InternObject(treeStore).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(a)))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(b)))

	C.gtk_tree_store_swap(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeStore)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)
}

// TreeViewOverrides contains methods that are overridable.
type TreeViewOverrides struct {
	ColumnsChanged func()
	CursorChanged  func()
	// The function takes the following parameters:
	//
	//   - logical
	//   - expand
	//   - openAll
	ExpandCollapseCursorRow func(logical, expand, openAll bool) bool
	// The function takes the following parameters:
	//
	//   - step
	//   - count
	//   - extend
	//   - modify
	MoveCursor func(step MovementStep, count int, extend, modify bool) bool
	// RowActivated activates the cell determined by path and column.
	//
	// The function takes the following parameters:
	//
	//   - path to be activated.
	//   - column to be activated.
	RowActivated func(path *TreePath, column *TreeViewColumn)
	// The function takes the following parameters:
	//
	//   - iter
	//   - path
	RowCollapsed func(iter *TreeIter, path *TreePath)
	// The function takes the following parameters:
	//
	//   - iter
	//   - path
	RowExpanded            func(iter *TreeIter, path *TreePath)
	SelectAll              func() bool
	SelectCursorParent     func() bool
	SelectCursorRow        func(startEditing bool) bool
	StartInteractiveSearch func() bool
	// The function takes the following parameters:
	//
	//   - iter
	//   - path
	TestCollapseRow func(iter *TreeIter, path *TreePath) bool
	// The function takes the following parameters:
	//
	//   - iter
	//   - path
	TestExpandRow   func(iter *TreeIter, path *TreePath) bool
	ToggleCursorRow func() bool
	UnselectAll     func() bool
}

func defaultTreeViewOverrides(v *TreeView) TreeViewOverrides {
	return TreeViewOverrides{
		ColumnsChanged:          v.columnsChanged,
		CursorChanged:           v.cursorChanged,
		ExpandCollapseCursorRow: v.expandCollapseCursorRow,
		MoveCursor:              v.moveCursor,
		RowActivated:            v.rowActivated,
		RowCollapsed:            v.rowCollapsed,
		RowExpanded:             v.rowExpanded,
		SelectAll:               v.selectAll,
		SelectCursorParent:      v.selectCursorParent,
		SelectCursorRow:         v.selectCursorRow,
		StartInteractiveSearch:  v.startInteractiveSearch,
		TestCollapseRow:         v.testCollapseRow,
		TestExpandRow:           v.testExpandRow,
		ToggleCursorRow:         v.toggleCursorRow,
		UnselectAll:             v.unselectAll,
	}
}

// TreeView: widget for displaying both trees and lists
//
// Widget that displays any object that implements the gtk.TreeModel interface.
//
// Please refer to the tree widget conceptual overview
// (section-tree-widget.html) for an overview of all the objects and data types
// related to the tree widget and how they work together.
//
// # Coordinate systems in GtkTreeView API
//
// Several different coordinate systems are exposed in the GtkTreeView API.
// These are:
//
// ! (tree-view-coordinates.png)
//
// - Widget coordinates: Coordinates relative to the widget (usually
// widget->window).
//
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
//
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
//
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and
// bin window coordinates and between bin window and tree coordinates. For the
// former you can use gtk.TreeView.ConvertWidgetToBinWindowCoords() (and vice
// versa), for the latter gtk.TreeView.ConvertBinWindowToTreeCoords() (and vice
// versa).
//
// # GtkTreeView as GtkBuildable
//
// The GtkTreeView implementation of the GtkBuildable interface accepts
// gtk.TreeViewColumn objects as <child> elements and exposes the internal
// gtk.TreeSelection in UI definitions.
//
// An example of a UI definition fragment with GtkTreeView:
//
//	<object class="GtkTreeView" id="treeview">
//	  <property name="model">liststore1</property>
//	  <child>
//	    <object class="GtkTreeViewColumn" id="test-column">
//	      <property name="title">Test</property>
//	      <child>
//	        <object class="GtkCellRendererText" id="test-renderer"/>
//	        <attributes>
//	          <attribute name="text">1</attribute>
//	        </attributes>
//	      </child>
//	    </object>
//	  </child>
//	  <child internal-child="selection">
//	    <object class="GtkTreeSelection" id="selection">
//	      <signal name="changed" handler="on_treeview_selection_changed"/>
//	    </object>
//	  </child>
//	</object>
//
// CSS nodes
//
//	treeview.view
//	├── header
//	│   ├── button
//	│   │   ╰── [sort-indicator]
//	┊   ┊
//	│   ╰── button
//	│       ╰── [sort-indicator]
//	│
//	├── [rubberband]
//	╰── [dndtarget]
//
// GtkTreeView has a main CSS node with name treeview and style class .view.
// It has a subnode with name header, which is the parent for all the column
// header widgets' CSS nodes.
//
// Each column header consists of a button, which among other content, has a
// child with name sort-indicator, which carries the .ascending or .descending
// style classes when the column header should show a sort indicator. The CSS is
// expected to provide a suitable image using the -gtk-icon-source property.
//
// For rubberband selection, a subnode with name rubberband is used.
//
// For the drop target location during DND, a subnode with name dndtarget is
// used.
type TreeView struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*TreeView)(nil)
	_ coreglib.Objector = (*TreeView)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*TreeView, *TreeViewClass, TreeViewOverrides](
		GTypeTreeView,
		initTreeViewClass,
		wrapTreeView,
		defaultTreeViewOverrides,
	)
}

func initTreeViewClass(gclass unsafe.Pointer, overrides TreeViewOverrides, classInitFunc func(*TreeViewClass)) {
	pclass := (*C.GtkTreeViewClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeTreeView))))

	if overrides.ColumnsChanged != nil {
		pclass.columns_changed = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_columns_changed)
	}

	if overrides.CursorChanged != nil {
		pclass.cursor_changed = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_cursor_changed)
	}

	if overrides.ExpandCollapseCursorRow != nil {
		pclass.expand_collapse_cursor_row = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_expand_collapse_cursor_row)
	}

	if overrides.MoveCursor != nil {
		pclass.move_cursor = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_move_cursor)
	}

	if overrides.RowActivated != nil {
		pclass.row_activated = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_row_activated)
	}

	if overrides.RowCollapsed != nil {
		pclass.row_collapsed = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_row_collapsed)
	}

	if overrides.RowExpanded != nil {
		pclass.row_expanded = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_row_expanded)
	}

	if overrides.SelectAll != nil {
		pclass.select_all = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_select_all)
	}

	if overrides.SelectCursorParent != nil {
		pclass.select_cursor_parent = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_select_cursor_parent)
	}

	if overrides.SelectCursorRow != nil {
		pclass.select_cursor_row = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_select_cursor_row)
	}

	if overrides.StartInteractiveSearch != nil {
		pclass.start_interactive_search = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_start_interactive_search)
	}

	if overrides.TestCollapseRow != nil {
		pclass.test_collapse_row = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_test_collapse_row)
	}

	if overrides.TestExpandRow != nil {
		pclass.test_expand_row = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_test_expand_row)
	}

	if overrides.ToggleCursorRow != nil {
		pclass.toggle_cursor_row = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_toggle_cursor_row)
	}

	if overrides.UnselectAll != nil {
		pclass.unselect_all = (*[0]byte)(C._gotk4_gtk4_TreeViewClass_unselect_all)
	}

	if classInitFunc != nil {
		class := (*TreeViewClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapTreeView(obj *coreglib.Object) *TreeView {
	return &TreeView{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalTreeView(p uintptr) (interface{}, error) {
	return wrapTreeView(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectColumnsChanged: number of columns of the treeview has changed.
func (treeView *TreeView) ConnectColumnsChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "columns-changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectColumnsChanged), f)
}

// ConnectCursorChanged: position of the cursor (focused cell) has changed.
func (treeView *TreeView) ConnectCursorChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "cursor-changed", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectCursorChanged), f)
}

func (treeView *TreeView) ConnectExpandCollapseCursorRow(f func(object, p0, p1 bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "expand-collapse-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectExpandCollapseCursorRow), f)
}

// ConnectMoveCursor signal is a [keybinding signal][GtkSignalAction] which gets
// emitted when the user presses one of the cursor keys.
//
// Applications should not connect to it, but may emit it with
// g_signal_emit_by_name() if they need to control the cursor
// programmatically. In contrast to gtk_tree_view_set_cursor()
// and gtk_tree_view_set_cursor_on_cell() when moving horizontally
// TreeView::move-cursor does not reset the current selection.
func (treeView *TreeView) ConnectMoveCursor(f func(step MovementStep, direction int, extend, modify bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "move-cursor", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectMoveCursor), f)
}

// ConnectRowActivated: "row-activated" signal is emitted when the method
// gtk_tree_view_row_activated() is called, when the user double clicks a
// treeview row with the "activate-on-single-click" property set to FALSE,
// or when the user single clicks a row when the "activate-on-single-click"
// property set to TRUE. It is also emitted when a non-editable row is selected
// and one of the keys: Space, Shift+Space, Return or Enter is pressed.
//
// For selection handling refer to the [tree widget conceptual
// overview][TreeWidget] as well as TreeSelection.
func (treeView *TreeView) ConnectRowActivated(f func(path *TreePath, column *TreeViewColumn)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "row-activated", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectRowActivated), f)
}

// ConnectRowCollapsed: given row has been collapsed (child nodes are hidden).
func (treeView *TreeView) ConnectRowCollapsed(f func(iter *TreeIter, path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "row-collapsed", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectRowCollapsed), f)
}

// ConnectRowExpanded: given row has been expanded (child nodes are shown).
func (treeView *TreeView) ConnectRowExpanded(f func(iter *TreeIter, path *TreePath)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "row-expanded", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectRowExpanded), f)
}

func (treeView *TreeView) ConnectSelectAll(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "select-all", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectSelectAll), f)
}

func (treeView *TreeView) ConnectSelectCursorParent(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "select-cursor-parent", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectSelectCursorParent), f)
}

func (treeView *TreeView) ConnectSelectCursorRow(f func(object bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "select-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectSelectCursorRow), f)
}

func (treeView *TreeView) ConnectStartInteractiveSearch(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "start-interactive-search", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectStartInteractiveSearch), f)
}

// ConnectTestCollapseRow: given row is about to be collapsed (hide its
// children nodes). Use this signal if you need to control the collapsibility of
// individual rows.
func (treeView *TreeView) ConnectTestCollapseRow(f func(iter *TreeIter, path *TreePath) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "test-collapse-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectTestCollapseRow), f)
}

// ConnectTestExpandRow: given row is about to be expanded (show its children
// nodes). Use this signal if you need to control the expandability of
// individual rows.
func (treeView *TreeView) ConnectTestExpandRow(f func(iter *TreeIter, path *TreePath) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "test-expand-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectTestExpandRow), f)
}

func (treeView *TreeView) ConnectToggleCursorRow(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "toggle-cursor-row", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectToggleCursorRow), f)
}

func (treeView *TreeView) ConnectUnselectAll(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeView, "unselect-all", false, unsafe.Pointer(C._gotk4_gtk4_TreeView_ConnectUnselectAll), f)
}

// NewTreeView creates a new TreeView widget.
//
// The function returns the following values:
//
//   - treeView: newly created TreeView widget.
func NewTreeView() *TreeView {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_tree_view_new()

	var _treeView *TreeView // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// NewTreeViewWithModel creates a new TreeView widget with the model initialized
// to model.
//
// The function takes the following parameters:
//
//   - model: model.
//
// The function returns the following values:
//
//   - treeView: newly created TreeView widget.
func NewTreeViewWithModel(model TreeModeller) *TreeView {
	var _arg1 *C.GtkTreeModel // out
	var _cret *C.GtkWidget    // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))

	_cret = C.gtk_tree_view_new_with_model(_arg1)
	runtime.KeepAlive(model)

	var _treeView *TreeView // out

	_treeView = wrapTreeView(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeView
}

// AppendColumn appends column to the list of columns. If tree_view has
// “fixed_height” mode enabled, then column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
//
// The function takes the following parameters:
//
//   - column to add.
//
// The function returns the following values:
//
//   - gint: number of columns in tree_view after appending.
func (treeView *TreeView) AppendColumn(column *TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))

	_cret = C.gtk_tree_view_append_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// CollapseAll: recursively collapses all visible, expanded nodes in tree_view.
func (treeView *TreeView) CollapseAll() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_collapse_all(_arg0)
	runtime.KeepAlive(treeView)
}

// CollapseRow collapses a row (hides its child rows, if they exist).
//
// The function takes the following parameters:
//
//   - path to a row in the tree_view.
//
// The function returns the following values:
//
//   - ok: TRUE if the row was collapsed.
func (treeView *TreeView) CollapseRow(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_view_collapse_row(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ColumnsAutosize resizes all columns to their optimal width. Only works after
// the treeview has been realized.
func (treeView *TreeView) ColumnsAutosize() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_columns_autosize(_arg0)
	runtime.KeepAlive(treeView)
}

// ConvertBinWindowToTreeCoords converts bin_window coordinates to coordinates
// for the tree (the full scrollable area of the tree).
//
// The function takes the following parameters:
//
//   - bx: x coordinate relative to bin_window.
//   - by: y coordinate relative to bin_window.
//
// The function returns the following values:
//
//   - tx: return location for tree X coordinate.
//   - ty: return location for tree Y coordinate.
func (treeView *TreeView) ConvertBinWindowToTreeCoords(bx, by int) (tx, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(bx)
	_arg2 = C.int(by)

	C.gtk_tree_view_convert_bin_window_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(bx)
	runtime.KeepAlive(by)

	var _tx int // out
	var _ty int // out

	_tx = int(_arg3)
	_ty = int(_arg4)

	return _tx, _ty
}

// ConvertBinWindowToWidgetCoords converts bin_window coordinates to widget
// relative coordinates.
//
// The function takes the following parameters:
//
//   - bx: bin_window X coordinate.
//   - by: bin_window Y coordinate.
//
// The function returns the following values:
//
//   - wx: return location for widget X coordinate.
//   - wy: return location for widget Y coordinate.
func (treeView *TreeView) ConvertBinWindowToWidgetCoords(bx, by int) (wx, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(bx)
	_arg2 = C.int(by)

	C.gtk_tree_view_convert_bin_window_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(bx)
	runtime.KeepAlive(by)

	var _wx int // out
	var _wy int // out

	_wx = int(_arg3)
	_wy = int(_arg4)

	return _wx, _wy
}

// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to bin_window coordinates.
//
// The function takes the following parameters:
//
//   - tx: tree X coordinate.
//   - ty: tree Y coordinate.
//
// The function returns the following values:
//
//   - bx: return location for X coordinate relative to bin_window.
//   - by: return location for Y coordinate relative to bin_window.
func (treeView *TreeView) ConvertTreeToBinWindowCoords(tx, ty int) (bx, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(tx)
	_arg2 = C.int(ty)

	C.gtk_tree_view_convert_tree_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tx)
	runtime.KeepAlive(ty)

	var _bx int // out
	var _by int // out

	_bx = int(_arg3)
	_by = int(_arg4)

	return _bx, _by
}

// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to widget coordinates.
//
// The function takes the following parameters:
//
//   - tx: x coordinate relative to the tree.
//   - ty: y coordinate relative to the tree.
//
// The function returns the following values:
//
//   - wx: return location for widget X coordinate.
//   - wy: return location for widget Y coordinate.
func (treeView *TreeView) ConvertTreeToWidgetCoords(tx, ty int) (wx, wy int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(tx)
	_arg2 = C.int(ty)

	C.gtk_tree_view_convert_tree_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tx)
	runtime.KeepAlive(ty)

	var _wx int // out
	var _wy int // out

	_wx = int(_arg3)
	_wy = int(_arg4)

	return _wx, _wy
}

// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates for
// the bin_window.
//
// The function takes the following parameters:
//
//   - wx: x coordinate relative to the widget.
//   - wy: y coordinate relative to the widget.
//
// The function returns the following values:
//
//   - bx: return location for bin_window X coordinate.
//   - by: return location for bin_window Y coordinate.
func (treeView *TreeView) ConvertWidgetToBinWindowCoords(wx, wy int) (bx, by int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(wx)
	_arg2 = C.int(wy)

	C.gtk_tree_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(wx)
	runtime.KeepAlive(wy)

	var _bx int // out
	var _by int // out

	_bx = int(_arg3)
	_by = int(_arg4)

	return _bx, _by
}

// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for the
// tree (the full scrollable area of the tree).
//
// The function takes the following parameters:
//
//   - wx: x coordinate relative to the widget.
//   - wy: y coordinate relative to the widget.
//
// The function returns the following values:
//
//   - tx: return location for tree X coordinate.
//   - ty: return location for tree Y coordinate.
func (treeView *TreeView) ConvertWidgetToTreeCoords(wx, wy int) (tx, ty int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(wx)
	_arg2 = C.int(wy)

	C.gtk_tree_view_convert_widget_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(wx)
	runtime.KeepAlive(wy)

	var _tx int // out
	var _ty int // out

	_tx = int(_arg3)
	_ty = int(_arg4)

	return _tx, _ty
}

// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// path. This image is used for a drag icon.
//
// The function takes the following parameters:
//
//   - path in tree_view.
//
// The function returns the following values:
//
//   - paintable (optional): newly-allocated surface of the drag icon.
func (treeView *TreeView) CreateRowDragIcon(path *TreePath) *gdk.Paintable {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 *C.GtkTreePath  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_view_create_row_drag_icon(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _paintable *gdk.Paintable // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_paintable = &gdk.Paintable{
				Object: obj,
			}
		}
	}

	return _paintable
}

// EnableModelDragDest turns tree_view into a drop destination for automatic
// DND. Calling this method sets TreeView:reorderable to FALSE.
//
// The function takes the following parameters:
//
//   - formats: target formats that the drag will support.
//   - actions: bitmask of possible actions for a drag from this widget.
func (treeView *TreeView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GdkContentFormats // out
	var _arg2 C.GdkDragAction      // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg2 = C.GdkDragAction(actions)

	C.gtk_tree_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(actions)
}

// EnableModelDragSource turns tree_view into a drag source for automatic DND.
// Calling this method sets TreeView:reorderable to FALSE.
//
// The function takes the following parameters:
//
//   - startButtonMask: mask of allowed buttons to start drag.
//   - formats: target formats that the drag will support.
//   - actions: bitmask of possible actions for a drag from this widget.
func (treeView *TreeView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.GdkModifierType    // out
	var _arg2 *C.GdkContentFormats // out
	var _arg3 C.GdkDragAction      // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.GdkModifierType(startButtonMask)
	_arg2 = (*C.GdkContentFormats)(gextras.StructNative(unsafe.Pointer(formats)))
	_arg3 = C.GdkDragAction(actions)

	C.gtk_tree_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(startButtonMask)
	runtime.KeepAlive(formats)
	runtime.KeepAlive(actions)
}

// ExpandAll: recursively expands all nodes in the tree_view.
func (treeView *TreeView) ExpandAll() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_expand_all(_arg0)
	runtime.KeepAlive(treeView)
}

// ExpandRow opens the row so its children are visible.
//
// The function takes the following parameters:
//
//   - path to a row.
//   - openAll: whether to recursively expand, or just expand immediate
//     children.
//
// The function returns the following values:
//
//   - ok: TRUE if the row existed and had children.
func (treeView *TreeView) ExpandRow(path *TreePath, openAll bool) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _arg2 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if openAll {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_tree_view_expand_row(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(openAll)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpandToPath expands the row at path. This will also expand all parent rows
// of path as necessary.
//
// The function takes the following parameters:
//
//   - path to a row.
func (treeView *TreeView) ExpandToPath(path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_view_expand_to_path(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
}

// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
//
// The function returns the following values:
//
//   - ok: TRUE if row-activated will be emitted on a single click.
func (treeView *TreeView) ActivateOnSingleClick() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_activate_on_single_click(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackgroundArea fills the bounding rectangle in bin_window coordinates for
// the cell at the row specified by path and the column specified by column.
// If path is NULL, or points to a node not found in the tree, the y and
// height fields of the rectangle will be filled with 0. If column is NULL,
// the x and width fields will be filled with 0. The returned rectangle is
// equivalent to the background_area passed to gtk_cell_renderer_render().
// These background areas tile to cover the entire bin window. Contrast with the
// cell_area, returned by gtk_tree_view_get_cell_area(), which returns only the
// cell itself, excluding surrounding borders and the tree expander area.
//
// The function takes the following parameters:
//
//   - path (optional) for the row, or NULL to get only horizontal coordinates.
//   - column (optional) for the column, or NULL to get only vertical
//     coordinates.
//
// The function returns the following values:
//
//   - rect: rectangle to fill with cell background rect.
func (treeView *TreeView) BackgroundArea(path *TreePath, column *TreeViewColumn) *gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.GdkRectangle       // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}

	C.gtk_tree_view_get_background_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)

	var _rect *gdk.Rectangle // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rect
}

// CellArea fills the bounding rectangle in bin_window coordinates for the
// cell at the row specified by path and the column specified by column.
// If path is NULL, or points to a path not currently displayed, the y and
// height fields of the rectangle will be filled with 0. If column is NULL,
// the x and width fields will be filled with 0. The sum of all cell rects
// does not cover the entire tree; there are extra pixels in between rows,
// for example. The returned rectangle is equivalent to the cell_area passed
// to gtk_cell_renderer_render(). This function is only valid if tree_view is
// realized.
//
// The function takes the following parameters:
//
//   - path (optional) for the row, or NULL to get only horizontal coordinates.
//   - column (optional) for the column, or NULL to get only vertical
//     coordinates.
//
// The function returns the following values:
//
//   - rect: rectangle to fill with cell rect.
func (treeView *TreeView) CellArea(path *TreePath, column *TreeViewColumn) *gdk.Rectangle {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.GdkRectangle       // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}

	C.gtk_tree_view_get_cell_area(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)

	var _rect *gdk.Rectangle // out

	_rect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))

	return _rect
}

// Column gets the TreeViewColumn at the given position in the #tree_view.
//
// The function takes the following parameters:
//
//   - n of the column, counting from 0.
//
// The function returns the following values:
//
//   - treeViewColumn (optional) or NULL if the position is outside the range of
//     columns.
func (treeView *TreeView) Column(n int) *TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.int                // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(n)

	_cret = C.gtk_tree_view_get_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(n)

	var _treeViewColumn *TreeViewColumn // out

	if _cret != nil {
		_treeViewColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeViewColumn
}

// Columns returns a #GList of all the TreeViewColumn s currently in tree_view.
// The returned list must be freed with g_list_free ().
//
// The function returns the following values:
//
//   - list of TreeViewColumn s.
func (treeView *TreeView) Columns() []*TreeViewColumn {
	var _arg0 *C.GtkTreeView // out
	var _cret *C.GList       // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_columns(_arg0)
	runtime.KeepAlive(treeView)

	var _list []*TreeViewColumn // out

	_list = make([]*TreeViewColumn, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkTreeViewColumn)(v)
		var dst *TreeViewColumn // out
		dst = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// Cursor fills in path and focus_column with the current path and focus column.
// If the cursor isn’t currently set, then *path will be NULL. If no column
// currently has focus, then *focus_column will be NULL.
//
// The returned TreePath must be freed with gtk_tree_path_free() when you are
// done with it.
//
// The function returns the following values:
//
//   - path (optional): pointer to be filled with the current cursor path,
//     or NULL.
//   - focusColumn (optional): a pointer to be filled with the current focus
//     column, or NULL.
func (treeView *TreeView) Cursor() (*TreePath, *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // in
	var _arg2 *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_get_cursor(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(treeView)

	var _path *TreePath              // out
	var _focusColumn *TreeViewColumn // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		_focusColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_arg2)))
	}

	return _path, _focusColumn
}

// DestRowAtPos determines the destination row for a given position. drag_x
// and drag_y are expected to be in widget coordinates. This function is only
// meaningful if tree_view is realized. Therefore this function will always
// return FALSE if tree_view is not realized or does not have a model.
//
// The function takes the following parameters:
//
//   - dragX: position to determine the destination row for.
//   - dragY: position to determine the destination row for.
//
// The function returns the following values:
//
//   - path (optional): return location for the path of the highlighted row,
//     or NULL.
//   - pos (optional): return location for the drop position, or NULL.
//   - ok: whether there is a row at the given position, TRUE if this is indeed
//     the case.
func (treeView *TreeView) DestRowAtPos(dragX, dragY int) (*TreePath, TreeViewDropPosition, bool) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 C.int                     // out
	var _arg2 C.int                     // out
	var _arg3 *C.GtkTreePath            // in
	var _arg4 C.GtkTreeViewDropPosition // in
	var _cret C.gboolean                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(dragX)
	_arg2 = C.int(dragY)

	_cret = C.gtk_tree_view_get_dest_row_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(dragX)
	runtime.KeepAlive(dragY)

	var _path *TreePath           // out
	var _pos TreeViewDropPosition // out
	var _ok bool                  // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = TreeViewDropPosition(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _path, _pos, _ok
}

// DragDestRow gets information about the row that is highlighted for feedback.
//
// The function returns the following values:
//
//   - path (optional): return location for the path of the highlighted row,
//     or NULL.
//   - pos (optional): return location for the drop position, or NULL.
func (treeView *TreeView) DragDestRow() (*TreePath, TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 *C.GtkTreePath            // in
	var _arg2 C.GtkTreeViewDropPosition // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_get_drag_dest_row(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(treeView)

	var _path *TreePath           // out
	var _pos TreeViewDropPosition // out

	if _arg1 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_pos = TreeViewDropPosition(_arg2)

	return _path, _pos
}

// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
//
// The function returns the following values:
//
//   - ok: whether or not to let the user search interactively.
func (treeView *TreeView) EnableSearch() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_enable_search(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnableTreeLines returns whether or not tree lines are drawn in tree_view.
//
// The function returns the following values:
//
//   - ok: TRUE if tree lines are drawn in tree_view, FALSE otherwise.
func (treeView *TreeView) EnableTreeLines() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_enable_tree_lines(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExpanderColumn returns the column that is the current expander column,
// or NULL if none has been set. This column has the expander arrow drawn next
// to it.
//
// The function returns the following values:
//
//   - treeViewColumn (optional): expander column.
func (treeView *TreeView) ExpanderColumn() *TreeViewColumn {
	var _arg0 *C.GtkTreeView       // out
	var _cret *C.GtkTreeViewColumn // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_expander_column(_arg0)
	runtime.KeepAlive(treeView)

	var _treeViewColumn *TreeViewColumn // out

	if _cret != nil {
		_treeViewColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeViewColumn
}

// FixedHeightMode returns whether fixed height mode is turned on for tree_view.
//
// The function returns the following values:
//
//   - ok: TRUE if tree_view is in fixed height mode.
func (treeView *TreeView) FixedHeightMode() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_fixed_height_mode(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GridLines returns which grid lines are enabled in tree_view.
//
// The function returns the following values:
//
//   - treeViewGridLines value indicating which grid lines are enabled.
func (treeView *TreeView) GridLines() TreeViewGridLines {
	var _arg0 *C.GtkTreeView         // out
	var _cret C.GtkTreeViewGridLines // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_grid_lines(_arg0)
	runtime.KeepAlive(treeView)

	var _treeViewGridLines TreeViewGridLines // out

	_treeViewGridLines = TreeViewGridLines(_cret)

	return _treeViewGridLines
}

// HeadersClickable returns whether all header columns are clickable.
//
// The function returns the following values:
//
//   - ok: TRUE if all header columns are clickable, otherwise FALSE.
func (treeView *TreeView) HeadersClickable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_headers_clickable(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HeadersVisible returns TRUE if the headers on the tree_view are visible.
//
// The function returns the following values:
//
//   - ok: whether the headers are visible or not.
func (treeView *TreeView) HeadersVisible() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_headers_visible(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverExpand returns whether hover expansion mode is turned on for tree_view.
//
// The function returns the following values:
//
//   - ok: TRUE if tree_view is in hover expansion mode.
func (treeView *TreeView) HoverExpand() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_hover_expand(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HoverSelection returns whether hover selection mode is turned on for
// tree_view.
//
// The function returns the following values:
//
//   - ok: TRUE if tree_view is in hover selection mode.
func (treeView *TreeView) HoverSelection() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_hover_selection(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in tree_view.
//
// The function returns the following values:
//
//   - gint: amount of extra indentation for child levels in tree_view. A return
//     value of 0 means that this feature is disabled.
func (treeView *TreeView) LevelIndentation() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_level_indentation(_arg0)
	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Model returns the model the TreeView is based on. Returns NULL if the model
// is unset.
//
// The function returns the following values:
//
//   - treeModel (optional) or NULL if none is currently being used.
func (treeView *TreeView) Model() *TreeModel {
	var _arg0 *C.GtkTreeView  // out
	var _cret *C.GtkTreeModel // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_model(_arg0)
	runtime.KeepAlive(treeView)

	var _treeModel *TreeModel // out

	if _cret != nil {
		_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _treeModel
}

// NColumns queries the number of columns in the given tree_view.
//
// The function returns the following values:
//
//   - guint: number of columns in the tree_view.
func (treeView *TreeView) NColumns() uint {
	var _arg0 *C.GtkTreeView // out
	var _cret C.guint        // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_n_columns(_arg0)
	runtime.KeepAlive(treeView)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// PathAtPos finds the path at the point (x, y), relative to
// bin_window coordinates. That is, x and y are relative to an events
// coordinates. Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
// things like popup menus. If path is non-NULL, then it will be filled with the
// TreePath at that point. This path should be freed with gtk_tree_path_free().
// If column is non-NULL, then it will be filled with the column at that point.
// cell_x and cell_y return the coordinates relative to the cell background
// (i.e. the background_area passed to gtk_cell_renderer_render()). This
// function is only meaningful if tree_view is realized. Therefore this function
// will always return FALSE if tree_view is not realized or does not have a
// model.
//
// For converting widget coordinates (eg. the ones
// you get from GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The function takes the following parameters:
//
//   - x position to be identified (relative to bin_window).
//   - y position to be identified (relative to bin_window).
//
// The function returns the following values:
//
//   - path (optional): pointer to a TreePath pointer to be filled in, or NULL.
//   - column (optional): pointer to a TreeViewColumn pointer to be filled in,
//     or NULL.
//   - cellX (optional): pointer where the X coordinate relative to the cell can
//     be placed, or NULL.
//   - cellY (optional): pointer where the Y coordinate relative to the cell can
//     be placed, or NULL.
//   - ok: TRUE if a row exists at that coordinate.
func (treeView *TreeView) PathAtPos(x, y int) (path *TreePath, column *TreeViewColumn, cellX, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.int                // out
	var _arg2 C.int                // out
	var _arg3 *C.GtkTreePath       // in
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.int                // in
	var _arg6 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_tree_view_get_path_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _path *TreePath         // out
	var _column *TreeViewColumn // out
	var _cellX int              // out
	var _cellY int              // out
	var _ok bool                // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg4 != nil {
		_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_arg4)))
	}
	_cellX = int(_arg5)
	_cellY = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
//
// The function returns the following values:
//
//   - ok: TRUE if the tree can be reordered.
func (treeView *TreeView) Reorderable() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_reorderable(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RubberBanding returns whether rubber banding is turned on for tree_view.
// If the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
//
// The function returns the following values:
//
//   - ok: TRUE if rubber banding in tree_view is enabled.
func (treeView *TreeView) RubberBanding() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_rubber_banding(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SearchColumn gets the column searched on by the interactive search code.
//
// The function returns the following values:
//
//   - gint: column the interactive search code searches in.
func (treeView *TreeView) SearchColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_search_column(_arg0)
	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SearchEntry returns the Entry which is currently in use as interactive search
// entry for tree_view. In case the built-in entry is being used, NULL will be
// returned.
//
// The function returns the following values:
//
//   - editable (optional): entry currently in use as search entry.
func (treeView *TreeView) SearchEntry() *EditableTextWidget {
	var _arg0 *C.GtkTreeView // out
	var _cret *C.GtkEditable // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_search_entry(_arg0)
	runtime.KeepAlive(treeView)

	var _editable *EditableTextWidget // out

	if _cret != nil {
		_editable = wrapEditableTextWidget(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _editable
}

// Selection gets the TreeSelection associated with tree_view.
//
// The function returns the following values:
//
//   - treeSelection: TreeSelection object.
func (treeView *TreeView) Selection() *TreeSelection {
	var _arg0 *C.GtkTreeView      // out
	var _cret *C.GtkTreeSelection // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_selection(_arg0)
	runtime.KeepAlive(treeView)

	var _treeSelection *TreeSelection // out

	_treeSelection = wrapTreeSelection(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeSelection
}

// ShowExpanders returns whether or not expanders are drawn in tree_view.
//
// The function returns the following values:
//
//   - ok: TRUE if expanders are drawn in tree_view, FALSE otherwise.
func (treeView *TreeView) ShowExpanders() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_show_expanders(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TooltipColumn returns the column of tree_view’s model which is being used for
// displaying tooltips on tree_view’s rows.
//
// The function returns the following values:
//
//   - gint: index of the tooltip column that is currently being used, or -1 if
//     this is disabled.
func (treeView *TreeView) TooltipColumn() int {
	var _arg0 *C.GtkTreeView // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_tooltip_column(_arg0)
	runtime.KeepAlive(treeView)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for TreeView. The x, y and keyboard_tip
// values which are received in the signal handler, should be passed to this
// function without modification.
//
// The return value indicates whether there is a tree view row at the given
// coordinates (TRUE) or not (FALSE) for mouse tooltips. For keyboard tooltips
// the row returned will be the cursor row. When TRUE, then any of model,
// path and iter which have been provided will be set to point to that row and
// the corresponding model. x and y will always be converted to be relative to
// tree_view’s bin_window if keyboard_tooltip is FALSE.
//
// The function takes the following parameters:
//
//   - x coordinate (relative to widget coordinates).
//   - y coordinate (relative to widget coordinates).
//   - keyboardTip: whether this is a keyboard tooltip or not.
//
// The function returns the following values:
//
//   - model (optional): pointer to receive a TreeModel or NULL.
//   - path (optional): pointer to receive a TreePath or NULL.
//   - iter (optional): pointer to receive a TreeIter or NULL.
//   - ok: whether or not the given tooltip context points to a row.
func (treeView *TreeView) TooltipContext(x, y int, keyboardTip bool) (*TreeModel, *TreePath, *TreeIter, bool) {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.gboolean      // out
	var _arg4 *C.GtkTreeModel // in
	var _arg5 *C.GtkTreePath  // in
	var _arg6 C.GtkTreeIter   // in
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	if keyboardTip {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_tree_view_get_tooltip_context(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(keyboardTip)

	var _model *TreeModel // out
	var _path *TreePath   // out
	var _iter *TreeIter   // out
	var _ok bool          // out

	if _arg4 != nil {
		_model = wrapTreeModel(coreglib.Take(unsafe.Pointer(_arg4)))
	}
	if _arg5 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg5)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	_iter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer((&_arg6))))
	if _cret != 0 {
		_ok = true
	}

	return _model, _path, _iter, _ok
}

// VisibleRange sets start_path and end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
//
// The paths should be freed with gtk_tree_path_free() after use.
//
// The function returns the following values:
//
//   - startPath (optional): return location for start of region, or NULL.
//   - endPath (optional): return location for end of region, or NULL.
//   - ok: TRUE, if valid paths were placed in start_path and end_path.
func (treeView *TreeView) VisibleRange() (startPath, endPath *TreePath, ok bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // in
	var _arg2 *C.GtkTreePath // in
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_get_visible_range(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(treeView)

	var _startPath *TreePath // out
	var _endPath *TreePath   // out
	var _ok bool             // out

	if _arg1 != nil {
		_startPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg1)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_startPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg2 != nil {
		_endPath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg2)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_endPath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _cret != 0 {
		_ok = true
	}

	return _startPath, _endPath, _ok
}

// VisibleRect fills visible_rect with the currently-visible region of
// the buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start at
// 0,0 for row 0 of the tree, and cover the entire scrollable area of the tree.
//
// The function returns the following values:
//
//   - visibleRect: rectangle to fill.
func (treeView *TreeView) VisibleRect() *gdk.Rectangle {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.GdkRectangle // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_get_visible_rect(_arg0, &_arg1)
	runtime.KeepAlive(treeView)

	var _visibleRect *gdk.Rectangle // out

	_visibleRect = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _visibleRect
}

// InsertColumn: this inserts the column into the tree_view at position.
// If position is -1, then the column is inserted at the end. If tree_view has
// “fixed_height” mode enabled, then column must have its “sizing” property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
//
// The function takes the following parameters:
//
//   - column to be inserted.
//   - position to insert column in.
//
// The function returns the following values:
//
//   - gint: number of columns in tree_view after insertion.
func (treeView *TreeView) InsertColumn(column *TreeViewColumn, position int) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 C.int                // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	_arg2 = C.int(position)

	_cret = C.gtk_tree_view_insert_column(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
	runtime.KeepAlive(position)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// InsertColumnWithDataFunc: convenience function that inserts a new column
// into the TreeView with the given cell renderer and a TreeCellDataFunc to
// set cell renderer attributes (normally using data from the model). See also
// gtk_tree_view_column_set_cell_data_func(), gtk_tree_view_column_pack_start().
// If tree_view has “fixed_height” mode enabled, then the new column will have
// its “sizing” property set to be GTK_TREE_VIEW_COLUMN_FIXED.
//
// The function takes the following parameters:
//
//   - position: position to insert, -1 for append.
//   - title: column title.
//   - cell renderer for column.
//   - fn: function to set attributes of cell renderer.
//
// The function returns the following values:
//
//   - gint: number of columns in the tree view post-insert.
func (treeView *TreeView) InsertColumnWithDataFunc(position int, title string, cell CellRendererer, fn TreeCellDataFunc) int {
	var _arg0 *C.GtkTreeView        // out
	var _arg1 C.int                 // out
	var _arg2 *C.char               // out
	var _arg3 *C.GtkCellRenderer    // out
	var _arg4 C.GtkTreeCellDataFunc // out
	var _arg5 C.gpointer
	var _arg6 C.GDestroyNotify
	var _cret C.int // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(position)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	_arg4 = (*[0]byte)(C._gotk4_gtk4_TreeCellDataFunc)
	_arg5 = C.gpointer(gbox.Assign(fn))
	_arg6 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gtk_tree_view_insert_column_with_data_func(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(position)
	runtime.KeepAlive(title)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(fn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// IsBlankAtPos: determine whether the point (x, y) in tree_view is blank, that
// is no cell content nor an expander arrow is drawn at the location. If so, the
// location can be considered as the background. You might wish to take special
// action on clicks on the background, such as clearing a current selection,
// having a custom context menu or starting rubber banding.
//
// The x and y coordinate that are provided must be relative to bin_window
// coordinates. Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// For converting widget coordinates (eg. the ones
// you get from GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
//
// The path, column, cell_x and cell_y arguments will be filled
// in likewise as for gtk_tree_view_get_path_at_pos(). Please see
// gtk_tree_view_get_path_at_pos() for more information.
//
// The function takes the following parameters:
//
//   - x position to be identified (relative to bin_window).
//   - y position to be identified (relative to bin_window).
//
// The function returns the following values:
//
//   - path (optional): pointer to a TreePath pointer to be filled in, or NULL.
//   - column (optional): pointer to a TreeViewColumn pointer to be filled in,
//     or NULL.
//   - cellX (optional): pointer where the X coordinate relative to the cell can
//     be placed, or NULL.
//   - cellY (optional): pointer where the Y coordinate relative to the cell can
//     be placed, or NULL.
//   - ok: TRUE if the area at the given coordinates is blank, FALSE otherwise.
func (treeView *TreeView) IsBlankAtPos(x, y int) (path *TreePath, column *TreeViewColumn, cellX, cellY int, ok bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 C.int                // out
	var _arg2 C.int                // out
	var _arg3 *C.GtkTreePath       // in
	var _arg4 *C.GtkTreeViewColumn // in
	var _arg5 C.int                // in
	var _arg6 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)

	_cret = C.gtk_tree_view_is_blank_at_pos(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _path *TreePath         // out
	var _column *TreeViewColumn // out
	var _cellX int              // out
	var _cellY int              // out
	var _ok bool                // out

	if _arg3 != nil {
		_path = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_arg3)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_path)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}
	if _arg4 != nil {
		_column = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_arg4)))
	}
	_cellX = int(_arg5)
	_cellY = int(_arg6)
	if _cret != 0 {
		_ok = true
	}

	return _path, _column, _cellX, _cellY, _ok
}

// IsRubberBandingActive returns whether a rubber banding operation is currently
// being done in tree_view.
//
// The function returns the following values:
//
//   - ok: TRUE if a rubber banding operation is currently being done in
//     tree_view.
func (treeView *TreeView) IsRubberBandingActive() bool {
	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C.gtk_tree_view_is_rubber_banding_active(_arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MapExpandedRows calls func on all expanded rows.
//
// The function takes the following parameters:
//
//   - fn: function to be called.
func (treeView *TreeView) MapExpandedRows(fn TreeViewMappingFunc) {
	var _arg0 *C.GtkTreeView           // out
	var _arg1 C.GtkTreeViewMappingFunc // out
	var _arg2 C.gpointer

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewMappingFunc)
	_arg2 = C.gpointer(gbox.Assign(fn))
	defer gbox.Delete(uintptr(_arg2))

	C.gtk_tree_view_map_expanded_rows(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(fn)
}

// MoveColumnAfter moves column to be after to base_column. If base_column is
// NULL, then column is placed in the first position.
//
// The function takes the following parameters:
//
//   - column to be moved.
//   - baseColumn (optional) to be moved relative to, or NULL.
func (treeView *TreeView) MoveColumnAfter(column, baseColumn *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	if baseColumn != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(baseColumn).Native()))
	}

	C.gtk_tree_view_move_column_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
	runtime.KeepAlive(baseColumn)
}

// RemoveColumn removes column from tree_view.
//
// The function takes the following parameters:
//
//   - column to remove.
//
// The function returns the following values:
//
//   - gint: number of columns in tree_view after removing.
func (treeView *TreeView) RemoveColumn(column *TreeViewColumn) int {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))

	_cret = C.gtk_tree_view_remove_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RowActivated activates the cell determined by path and column.
//
// The function takes the following parameters:
//
//   - path to be activated.
//   - column to be activated.
func (treeView *TreeView) RowActivated(path *TreePath, column *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))

	C.gtk_tree_view_row_activated(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
}

// RowExpanded returns TRUE if the node pointed to by path is expanded in
// tree_view.
//
// The function takes the following parameters:
//
//   - path to test expansion state.
//
// The function returns the following values:
//
//   - ok: TRUE if #path is expanded.
func (treeView *TreeView) RowExpanded(path *TreePath) bool {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_view_row_expanded(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ScrollToCell moves the alignments of tree_view to the position specified
// by column and path. If column is NULL, then no horizontal scrolling occurs.
// Likewise, if path is NULL no vertical scrolling occurs. At a minimum, one of
// column or path need to be non-NULL. row_align determines where the row is
// placed, and col_align determines where column is placed. Both are expected to
// be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means right/bottom
// alignment, 0.5 means center.
//
// If use_align is FALSE, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen.
// This means that the cell will be scrolled to the edge closest to its current
// position. If the cell is currently visible on the screen, nothing is done.
//
// This function only works if the model is set, and path is a valid row on the
// model. If the model changes before the tree_view is realized, the centered
// path will be modified to reflect this change.
//
// The function takes the following parameters:
//
//   - path (optional) of the row to move to, or NULL.
//   - column (optional) to move horizontally to, or NULL.
//   - useAlign: whether to use alignment arguments, or FALSE.
//   - rowAlign: vertical alignment of the row specified by path.
//   - colAlign: horizontal alignment of the column specified by column.
func (treeView *TreeView) ScrollToCell(path *TreePath, column *TreeViewColumn, useAlign bool, rowAlign, colAlign float32) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out
	var _arg4 C.float              // out
	var _arg5 C.float              // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}
	if useAlign {
		_arg3 = C.TRUE
	}
	_arg4 = C.float(rowAlign)
	_arg5 = C.float(colAlign)

	C.gtk_tree_view_scroll_to_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
	runtime.KeepAlive(useAlign)
	runtime.KeepAlive(rowAlign)
	runtime.KeepAlive(colAlign)
}

// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is tree_x, tree_y, where tree_x and tree_y are specified in tree
// coordinates. The tree_view must be realized before this function is called.
// If it isn't, you probably want to be using gtk_tree_view_scroll_to_cell().
//
// If either tree_x or tree_y are -1, then that direction isn’t scrolled.
//
// The function takes the following parameters:
//
//   - treeX: x coordinate of new top-left pixel of visible area, or -1.
//   - treeY: y coordinate of new top-left pixel of visible area, or -1.
func (treeView *TreeView) ScrollToPoint(treeX, treeY int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(treeX)
	_arg2 = C.int(treeY)

	C.gtk_tree_view_scroll_to_point(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(treeX)
	runtime.KeepAlive(treeY)
}

// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
//
// The function takes the following parameters:
//
//   - single: TRUE to emit row-activated on a single click.
func (treeView *TreeView) SetActivateOnSingleClick(single bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if single {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_activate_on_single_click(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(single)
}

// SetColumnDragFunction sets a user function for determining where a column may
// be dropped when dragged. This function is called on every column pair in turn
// at the beginning of a column drag to determine where a drop can take place.
// The arguments passed to func are: the tree_view, the TreeViewColumn being
// dragged, the two TreeViewColumn s determining the drop spot, and user_data.
// If either of the TreeViewColumn arguments for the drop spot are NULL,
// then they indicate an edge. If func is set to be NULL, then tree_view reverts
// to the default behavior of allowing all columns to be dropped everywhere.
//
// The function takes the following parameters:
//
//   - fn (optional): function to determine which columns are reorderable,
//     or NULL.
func (treeView *TreeView) SetColumnDragFunction(fn TreeViewColumnDropFunc) {
	var _arg0 *C.GtkTreeView              // out
	var _arg1 C.GtkTreeViewColumnDropFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewColumnDropFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_tree_view_set_column_drag_function(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(fn)
}

// SetCursor sets the current keyboard focus to be at path, and selects it. This
// is useful when you want to focus the user’s attention on a particular row.
// If focus_column is not NULL, then focus is given to the column specified by
// it. Additionally, if focus_column is specified, and start_editing is TRUE,
// then editing should be started in the specified cell. This function is often
// followed by gtk_widget_grab_focus (tree_view) in order to give keyboard focus
// to the widget. Please note that editing can only happen when the widget is
// realized.
//
// If path is invalid for model, the current cursor (if any) will be unset and
// the function will return without failing.
//
// The function takes the following parameters:
//
//   - path: TreePath.
//   - focusColumn (optional) or NULL.
//   - startEditing: TRUE if the specified cell should start being edited.
func (treeView *TreeView) SetCursor(path *TreePath, focusColumn *TreeViewColumn, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if focusColumn != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(focusColumn).Native()))
	}
	if startEditing {
		_arg3 = C.TRUE
	}

	C.gtk_tree_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(focusColumn)
	runtime.KeepAlive(startEditing)
}

// SetCursorOnCell sets the current keyboard focus to be at path, and
// selects it. This is useful when you want to focus the user’s attention
// on a particular row. If focus_column is not NULL, then focus is given to
// the column specified by it. If focus_column and focus_cell are not NULL,
// and focus_column contains 2 or more editable or activatable cells, then focus
// is given to the cell specified by focus_cell. Additionally, if focus_column
// is specified, and start_editing is TRUE, then editing should be started in
// the specified cell. This function is often followed by gtk_widget_grab_focus
// (tree_view) in order to give keyboard focus to the widget. Please note that
// editing can only happen when the widget is realized.
//
// If path is invalid for model, the current cursor (if any) will be unset and
// the function will return without failing.
//
// The function takes the following parameters:
//
//   - path: TreePath.
//   - focusColumn (optional) or NULL.
//   - focusCell (optional) or NULL.
//   - startEditing: TRUE if the specified cell should start being edited.
func (treeView *TreeView) SetCursorOnCell(path *TreePath, focusColumn *TreeViewColumn, focusCell CellRendererer, startEditing bool) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out
	var _arg3 *C.GtkCellRenderer   // out
	var _arg4 C.gboolean           // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	if focusColumn != nil {
		_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(focusColumn).Native()))
	}
	if focusCell != nil {
		_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(focusCell).Native()))
	}
	if startEditing {
		_arg4 = C.TRUE
	}

	C.gtk_tree_view_set_cursor_on_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(focusColumn)
	runtime.KeepAlive(focusCell)
	runtime.KeepAlive(startEditing)
}

// SetDragDestRow sets the row that is highlighted for feedback. If path is
// NULL, an existing highlight is removed.
//
// The function takes the following parameters:
//
//   - path (optional) of the row to highlight, or NULL.
//   - pos specifies whether to drop before, after or into the row.
func (treeView *TreeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition) {
	var _arg0 *C.GtkTreeView            // out
	var _arg1 *C.GtkTreePath            // out
	var _arg2 C.GtkTreeViewDropPosition // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if path != nil {
		_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	_arg2 = C.GtkTreeViewDropPosition(pos)

	C.gtk_tree_view_set_drag_dest_row(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(pos)
}

// SetEnableSearch: if enable_search is set, then the user can type in text to
// search through the tree interactively (this is sometimes called "typeahead
// find").
//
// Note that even if this is FALSE, the user can still initiate a search using
// the “start-interactive-search” key binding.
//
// The function takes the following parameters:
//
//   - enableSearch: TRUE, if the user can search interactively.
func (treeView *TreeView) SetEnableSearch(enableSearch bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enableSearch {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_search(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enableSearch)
}

// SetEnableTreeLines sets whether to draw lines interconnecting the expanders
// in tree_view. This does not have any visible effects for lists.
//
// The function takes the following parameters:
//
//   - enabled: TRUE to enable tree line drawing, FALSE otherwise.
func (treeView *TreeView) SetEnableTreeLines(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_enable_tree_lines(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enabled)
}

// SetExpanderColumn sets the column to draw the expander arrow at. It must be
// in tree_view. If column is NULL, then the expander arrow is always at the
// first visible column.
//
// If you do not want expander arrow to appear in your tree, set the expander
// column to a hidden column.
//
// The function takes the following parameters:
//
//   - column (optional): NULL, or the column to draw the expander arrow at.
func (treeView *TreeView) SetExpanderColumn(column *TreeViewColumn) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if column != nil {
		_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}

	C.gtk_tree_view_set_expander_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetFixedHeightMode enables or disables the fixed height mode of tree_view.
// Fixed height mode speeds up TreeView by assuming that all rows have the
// same height. Only enable this option if all rows are the same height and all
// columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
//
// The function takes the following parameters:
//
//   - enable: TRUE to enable fixed height mode.
func (treeView *TreeView) SetFixedHeightMode(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_fixed_height_mode(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enable)
}

// SetGridLines sets which grid lines to draw in tree_view.
//
// The function takes the following parameters:
//
//   - gridLines value indicating which grid lines to enable.
func (treeView *TreeView) SetGridLines(gridLines TreeViewGridLines) {
	var _arg0 *C.GtkTreeView         // out
	var _arg1 C.GtkTreeViewGridLines // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.GtkTreeViewGridLines(gridLines)

	C.gtk_tree_view_set_grid_lines(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(gridLines)
}

// SetHeadersClickable: allow the column title buttons to be clicked.
//
// The function takes the following parameters:
//
//   - setting: TRUE if the columns are clickable.
func (treeView *TreeView) SetHeadersClickable(setting bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_clickable(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(setting)
}

// SetHeadersVisible sets the visibility state of the headers.
//
// The function takes the following parameters:
//
//   - headersVisible: TRUE if the headers are visible.
func (treeView *TreeView) SetHeadersVisible(headersVisible bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if headersVisible {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_headers_visible(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(headersVisible)
}

// SetHoverExpand enables or disables the hover expansion mode of tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves over them.
//
// The function takes the following parameters:
//
//   - expand: TRUE to enable hover selection mode.
func (treeView *TreeView) SetHoverExpand(expand bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_expand(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(expand)
}

// SetHoverSelection enables or disables the hover selection mode of tree_view.
// Hover selection makes the selected row follow the pointer. Currently,
// this works only for the selection modes GTK_SELECTION_SINGLE and
// GTK_SELECTION_BROWSE.
//
// The function takes the following parameters:
//
//   - hover: TRUE to enable hover selection mode.
func (treeView *TreeView) SetHoverSelection(hover bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if hover {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_hover_selection(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(hover)
}

// SetLevelIndentation sets the amount of extra indentation for child levels to
// use in tree_view in addition to the default indentation. The value should be
// specified in pixels, a value of 0 disables this feature and in this case only
// the default indentation will be used. This does not have any visible effects
// for lists.
//
// The function takes the following parameters:
//
//   - indentation: amount, in pixels, of extra indentation in tree_view.
func (treeView *TreeView) SetLevelIndentation(indentation int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(indentation)

	C.gtk_tree_view_set_level_indentation(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(indentation)
}

// SetModel sets the model for a TreeView. If the tree_view already has a model
// set, it will remove it before setting the new model. If model is NULL,
// then it will unset the old model.
//
// The function takes the following parameters:
//
//   - model (optional): model.
func (treeView *TreeView) SetModel(model TreeModeller) {
	var _arg0 *C.GtkTreeView  // out
	var _arg1 *C.GtkTreeModel // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if model != nil {
		_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	}

	C.gtk_tree_view_set_model(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(model)
}

// SetReorderable: this function is a convenience function to allow
// you to reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If reorderable
// is TRUE, then the user can reorder the model by dragging and dropping rows.
// The developer can listen to these changes by connecting to the model’s
// TreeModel::row-inserted and TreeModel::row-deleted signals. The reordering
// is implemented by setting up the tree view as a drag source and destination.
// Therefore, drag and drop can not be used in a reorderable view for any other
// purpose.
//
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
//
// The function takes the following parameters:
//
//   - reorderable: TRUE, if the tree can be reordered.
func (treeView *TreeView) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_reorderable(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(reorderable)
}

// SetRowSeparatorFunc sets the row separator function, which is used to
// determine whether a row should be drawn as a separator. If the row separator
// function is NULL, no separators are drawn. This is the default value.
//
// The function takes the following parameters:
//
//   - fn (optional): TreeViewRowSeparatorFunc.
func (treeView *TreeView) SetRowSeparatorFunc(fn TreeViewRowSeparatorFunc) {
	var _arg0 *C.GtkTreeView                // out
	var _arg1 C.GtkTreeViewRowSeparatorFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if fn != nil {
		_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewRowSeparatorFunc)
		_arg2 = C.gpointer(gbox.Assign(fn))
		_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_tree_view_set_row_separator_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(fn)
}

// SetRubberBanding enables or disables rubber banding in tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the user to
// select multiple rows by dragging the mouse.
//
// The function takes the following parameters:
//
//   - enable: TRUE to enable rubber banding.
func (treeView *TreeView) SetRubberBanding(enable bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_rubber_banding(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enable)
}

// SetSearchColumn sets column as the column where the interactive search code
// should search in for the current model.
//
// If the search column is set, users can use the “start-interactive-search” key
// binding to bring up search popup. The enable-search property controls whether
// simply typing text will also start an interactive search.
//
// Note that column refers to a column of the current model. The search column
// is reset to -1 when the model is changed.
//
// The function takes the following parameters:
//
//   - column of the model to search in, or -1 to disable searching.
func (treeView *TreeView) SetSearchColumn(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(column)

	C.gtk_tree_view_set_search_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetSearchEntry sets the entry which the interactive search code will use for
// this tree_view. This is useful when you want to provide a search entry in our
// interface at all time at a fixed position. Passing NULL for entry will make
// the interactive search code use the built-in popup entry again.
//
// The function takes the following parameters:
//
//   - entry (optional) the interactive search code of tree_view should use or
//     NULL.
func (treeView *TreeView) SetSearchEntry(entry EditableTextWidgetter) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkEditable // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if entry != nil {
		_arg1 = (*C.GtkEditable)(unsafe.Pointer(coreglib.InternObject(entry).Native()))
	}

	C.gtk_tree_view_set_search_entry(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(entry)
}

// SetSearchEqualFunc sets the compare function for the interactive search
// capabilities; note that somewhat like strcmp() returning 0 for equality
// TreeViewSearchEqualFunc returns FALSE on matches.
//
// The function takes the following parameters:
//
//   - searchEqualFunc: compare function to use during the search.
func (treeView *TreeView) SetSearchEqualFunc(searchEqualFunc TreeViewSearchEqualFunc) {
	var _arg0 *C.GtkTreeView               // out
	var _arg1 C.GtkTreeViewSearchEqualFunc // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TreeViewSearchEqualFunc)
	_arg2 = C.gpointer(gbox.Assign(searchEqualFunc))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	C.gtk_tree_view_set_search_equal_func(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(searchEqualFunc)
}

// SetShowExpanders sets whether to draw and enable expanders and indent child
// rows in tree_view. When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default. Also note
// that hiding the expanders will disable the default indentation. You can set a
// custom indentation in this case using gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
//
// The function takes the following parameters:
//
//   - enabled: TRUE to enable expander drawing, FALSE otherwise.
func (treeView *TreeView) SetShowExpanders(enabled bool) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if enabled {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_set_show_expanders(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(enabled)
}

// SetTooltipCell sets the tip area of tooltip to the area path, column
// and cell have in common. For example if path is NULL and column is set,
// the tip area will be set to the full area covered by column. See also
// gtk_tooltip_set_tip_area().
//
// Note that if path is not specified and cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position. In such cases path must be set to the current node under the mouse
// cursor for this function to operate correctly.
//
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
//
// The function takes the following parameters:
//
//   - tooltip: Tooltip.
//   - path (optional) or NULL.
//   - column (optional) or NULL.
//   - cell (optional) or NULL.
func (treeView *TreeView) SetTooltipCell(tooltip *Tooltip, path *TreePath, column *TreeViewColumn, cell CellRendererer) {
	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTooltip        // out
	var _arg2 *C.GtkTreePath       // out
	var _arg3 *C.GtkTreeViewColumn // out
	var _arg4 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	if path != nil {
		_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	}
	if column != nil {
		_arg3 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))
	}
	if cell != nil {
		_arg4 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	}

	C.gtk_tree_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
	runtime.KeepAlive(cell)
}

// SetTooltipColumn: if you only plan to have simple (text-only) tooltips
// on full rows, you can use this function to have TreeView handle these
// automatically for you. column should be set to the column in tree_view’s
// model containing the tooltip texts, or -1 to disable this feature.
//
// When enabled, Widget:has-tooltip will be set to TRUE and tree_view will
// connect a Widget::query-tooltip signal handler.
//
// Note that the signal handler sets the text with gtk_tooltip_set_markup(),
// so &, <, etc have to be escaped in the text.
//
// The function takes the following parameters:
//
//   - column: integer, which is a valid column number for tree_view’s model.
func (treeView *TreeView) SetTooltipColumn(column int) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.int(column)

	C.gtk_tree_view_set_tooltip_column(_arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(column)
}

// SetTooltipRow sets the tip area of tooltip to be the area covered by the
// row at path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
//
// The function takes the following parameters:
//
//   - tooltip: Tooltip.
//   - path: TreePath.
func (treeView *TreeView) SetTooltipRow(tooltip *Tooltip, path *TreePath) {
	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTooltip  // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_view_set_tooltip_row(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(tooltip)
	runtime.KeepAlive(path)
}

// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to FALSE.
func (treeView *TreeView) UnsetRowsDragDest() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_unset_rows_drag_dest(_arg0)
	runtime.KeepAlive(treeView)
}

// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to FALSE.
func (treeView *TreeView) UnsetRowsDragSource() {
	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C.gtk_tree_view_unset_rows_drag_source(_arg0)
	runtime.KeepAlive(treeView)
}

func (treeView *TreeView) columnsChanged() {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.columns_changed

	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C._gotk4_gtk4_TreeView_virtual_columns_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeView)
}

func (treeView *TreeView) cursorChanged() {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.cursor_changed

	var _arg0 *C.GtkTreeView // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	C._gotk4_gtk4_TreeView_virtual_cursor_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeView)
}

// The function takes the following parameters:
//
//   - logical
//   - expand
//   - openAll
func (treeView *TreeView) expandCollapseCursorRow(logical, expand, openAll bool) bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.expand_collapse_cursor_row

	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out
	var _arg2 C.gboolean     // out
	var _arg3 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if logical {
		_arg1 = C.TRUE
	}
	if expand {
		_arg2 = C.TRUE
	}
	if openAll {
		_arg3 = C.TRUE
	}

	_cret = C._gotk4_gtk4_TreeView_virtual_expand_collapse_cursor_row(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(logical)
	runtime.KeepAlive(expand)
	runtime.KeepAlive(openAll)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - step
//   - count
//   - extend
//   - modify
func (treeView *TreeView) moveCursor(step MovementStep, count int, extend, modify bool) bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.move_cursor

	var _arg0 *C.GtkTreeView    // out
	var _arg1 C.GtkMovementStep // out
	var _arg2 C.int             // out
	var _arg3 C.gboolean        // out
	var _arg4 C.gboolean        // out
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = C.GtkMovementStep(step)
	_arg2 = C.int(count)
	if extend {
		_arg3 = C.TRUE
	}
	if modify {
		_arg4 = C.TRUE
	}

	_cret = C._gotk4_gtk4_TreeView_virtual_move_cursor(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(step)
	runtime.KeepAlive(count)
	runtime.KeepAlive(extend)
	runtime.KeepAlive(modify)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// rowActivated activates the cell determined by path and column.
//
// The function takes the following parameters:
//
//   - path to be activated.
//   - column to be activated.
func (treeView *TreeView) rowActivated(path *TreePath, column *TreeViewColumn) {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.row_activated

	var _arg0 *C.GtkTreeView       // out
	var _arg1 *C.GtkTreePath       // out
	var _arg2 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(column).Native()))

	C._gotk4_gtk4_TreeView_virtual_row_activated(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(path)
	runtime.KeepAlive(column)
}

// The function takes the following parameters:
//
//   - iter
//   - path
func (treeView *TreeView) rowCollapsed(iter *TreeIter, path *TreePath) {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.row_collapsed

	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreeIter // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C._gotk4_gtk4_TreeView_virtual_row_collapsed(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(path)
}

// The function takes the following parameters:
//
//   - iter
//   - path
func (treeView *TreeView) rowExpanded(iter *TreeIter, path *TreePath) {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.row_expanded

	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreeIter // out
	var _arg2 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C._gotk4_gtk4_TreeView_virtual_row_expanded(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(path)
}

func (treeView *TreeView) selectAll() bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.select_all

	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C._gotk4_gtk4_TreeView_virtual_select_all(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (treeView *TreeView) selectCursorParent() bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.select_cursor_parent

	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C._gotk4_gtk4_TreeView_virtual_select_cursor_parent(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (treeView *TreeView) selectCursorRow(startEditing bool) bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.select_cursor_row

	var _arg0 *C.GtkTreeView // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	if startEditing {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gtk4_TreeView_virtual_select_cursor_row(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(startEditing)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (treeView *TreeView) startInteractiveSearch() bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.start_interactive_search

	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C._gotk4_gtk4_TreeView_virtual_start_interactive_search(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - iter
//   - path
func (treeView *TreeView) testCollapseRow(iter *TreeIter, path *TreePath) bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.test_collapse_row

	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreeIter // out
	var _arg2 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C._gotk4_gtk4_TreeView_virtual_test_collapse_row(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// The function takes the following parameters:
//
//   - iter
//   - path
func (treeView *TreeView) testExpandRow(iter *TreeIter, path *TreePath) bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.test_expand_row

	var _arg0 *C.GtkTreeView // out
	var _arg1 *C.GtkTreeIter // out
	var _arg2 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))
	_arg1 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C._gotk4_gtk4_TreeView_virtual_test_expand_row(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(treeView)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (treeView *TreeView) toggleCursorRow() bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.toggle_cursor_row

	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C._gotk4_gtk4_TreeView_virtual_toggle_cursor_row(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (treeView *TreeView) unselectAll() bool {
	gclass := (*C.GtkTreeViewClass)(coreglib.PeekParentClass(treeView))
	fnarg := gclass.unselect_all

	var _arg0 *C.GtkTreeView // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreeView)(unsafe.Pointer(coreglib.InternObject(treeView).Native()))

	_cret = C._gotk4_gtk4_TreeView_virtual_unselect_all(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(treeView)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeViewColumn: visible column in a GtkTreeView widget
//
// The GtkTreeViewColumn object represents a visible column in a TreeView
// widget. It allows to set properties of the column header, and functions as a
// holding pen for the cell renderers which determine how the data in the column
// is displayed.
//
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together, and to the TreeView documentation for specifics about the
// CSS node structure for treeviews and their headers.
type TreeViewColumn struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	Buildable
	CellLayout
}

var (
	_ coreglib.Objector = (*TreeViewColumn)(nil)
)

func wrapTreeViewColumn(obj *coreglib.Object) *TreeViewColumn {
	return &TreeViewColumn{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		Buildable: Buildable{
			Object: obj,
		},
		CellLayout: CellLayout{
			Object: obj,
		},
	}
}

func marshalTreeViewColumn(p uintptr) (interface{}, error) {
	return wrapTreeViewColumn(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectClicked is emitted when the column's header has been clicked.
func (treeColumn *TreeViewColumn) ConnectClicked(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(treeColumn, "clicked", false, unsafe.Pointer(C._gotk4_gtk4_TreeViewColumn_ConnectClicked), f)
}

// NewTreeViewColumn creates a new TreeViewColumn.
//
// The function returns the following values:
//
//   - treeViewColumn: newly created TreeViewColumn.
func NewTreeViewColumn() *TreeViewColumn {
	var _cret *C.GtkTreeViewColumn // in

	_cret = C.gtk_tree_view_column_new()

	var _treeViewColumn *TreeViewColumn // out

	_treeViewColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeViewColumn
}

// NewTreeViewColumnWithArea creates a new TreeViewColumn using area to render
// its cells.
//
// The function takes the following parameters:
//
//   - area that the newly created column should use to layout cells.
//
// The function returns the following values:
//
//   - treeViewColumn: newly created TreeViewColumn.
func NewTreeViewColumnWithArea(area CellAreaer) *TreeViewColumn {
	var _arg1 *C.GtkCellArea       // out
	var _cret *C.GtkTreeViewColumn // in

	_arg1 = (*C.GtkCellArea)(unsafe.Pointer(coreglib.InternObject(area).Native()))

	_cret = C.gtk_tree_view_column_new_with_area(_arg1)
	runtime.KeepAlive(area)

	var _treeViewColumn *TreeViewColumn // out

	_treeViewColumn = wrapTreeViewColumn(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeViewColumn
}

// AddAttribute adds an attribute mapping to the list in tree_column. The column
// is the column of the model to get a value from, and the attribute is the
// parameter on cell_renderer to be set from the value. So for example if column
// 2 of the model contains strings, you could have the “text” attribute of a
// CellRendererText get its values from column 2.
//
// The function takes the following parameters:
//
//   - cellRenderer to set attributes on.
//   - attribute on the renderer.
//   - column position on the model to get the attribute from.
func (treeColumn *TreeViewColumn) AddAttribute(cellRenderer CellRendererer, attribute string, column int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 *C.char              // out
	var _arg3 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cellRenderer).Native()))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(attribute)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(column)

	C.gtk_tree_view_column_add_attribute(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(cellRenderer)
	runtime.KeepAlive(attribute)
	runtime.KeepAlive(column)
}

// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, start_pos and width are not
// changed and FALSE is returned.
//
// The function takes the following parameters:
//
//   - cellRenderer: CellRenderer.
//
// The function returns the following values:
//
//   - xOffset (optional): return location for the horizontal position of cell
//     within tree_column, may be NULL.
//   - width (optional): return location for the width of cell, may be NULL.
//   - ok: TRUE if cell belongs to tree_column.
func (treeColumn *TreeViewColumn) CellGetPosition(cellRenderer CellRendererer) (xOffset, width int, ok bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.int                // in
	var _arg3 C.int                // in
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cellRenderer).Native()))

	_cret = C.gtk_tree_view_column_cell_get_position(_arg0, _arg1, &_arg2, &_arg3)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(cellRenderer)

	var _xOffset int // out
	var _width int   // out
	var _ok bool     // out

	_xOffset = int(_arg2)
	_width = int(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _xOffset, _width, _ok
}

// CellGetSize obtains the width and height needed to render the column. This is
// used primarily by the TreeView.
//
// The function returns the following values:
//
//   - xOffset (optional): location to return x offset of a cell relative to
//     cell_area, or NULL.
//   - yOffset (optional): location to return y offset of a cell relative to
//     cell_area, or NULL.
//   - width (optional): location to return width needed to render a cell,
//     or NULL.
//   - height (optional): location to return height needed to render a cell,
//     or NULL.
func (treeColumn *TreeViewColumn) CellGetSize() (xOffset, yOffset, width, height int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // in
	var _arg2 C.int                // in
	var _arg3 C.int                // in
	var _arg4 C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	C.gtk_tree_view_column_cell_get_size(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(treeColumn)

	var _xOffset int // out
	var _yOffset int // out
	var _width int   // out
	var _height int  // out

	_xOffset = int(_arg1)
	_yOffset = int(_arg2)
	_width = int(_arg3)
	_height = int(_arg4)

	return _xOffset, _yOffset, _width, _height
}

// CellIsVisible returns TRUE if any of the cells packed into the tree_column
// are visible. For this to be meaningful, you must first initialize the cells
// with gtk_tree_view_column_cell_set_cell_data().
//
// The function returns the following values:
//
//   - ok: TRUE, if any of the cells packed into the tree_column are currently
//     visible.
func (treeColumn *TreeViewColumn) CellIsVisible() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_cell_is_visible(_arg0)
	runtime.KeepAlive(treeColumn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CellSetCellData sets the cell renderer based on the tree_model and iter.
// That is, for every attribute mapping in tree_column, it will get a value from
// the set column on the iter, and use that value to set the attribute on the
// cell renderer. This is used primarily by the TreeView.
//
// The function takes the following parameters:
//
//   - treeModel to get the cell renderers attributes from.
//   - iter to get the cell renderer’s attributes from.
//   - isExpander: TRUE, if the row has children.
//   - isExpanded: TRUE, if the row has visible children.
func (treeColumn *TreeViewColumn) CellSetCellData(treeModel TreeModeller, iter *TreeIter, isExpander, isExpanded bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkTreeModel      // out
	var _arg2 *C.GtkTreeIter       // out
	var _arg3 C.gboolean           // out
	var _arg4 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(treeModel).Native()))
	_arg2 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if isExpander {
		_arg3 = C.TRUE
	}
	if isExpanded {
		_arg4 = C.TRUE
	}

	C.gtk_tree_view_column_cell_set_cell_data(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(treeModel)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(isExpander)
	runtime.KeepAlive(isExpanded)
}

// Clear unsets all the mappings on all renderers on the tree_column.
func (treeColumn *TreeViewColumn) Clear() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	C.gtk_tree_view_column_clear(_arg0)
	runtime.KeepAlive(treeColumn)
}

// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
//
// The function takes the following parameters:
//
//   - cellRenderer to clear the attribute mapping on.
func (treeColumn *TreeViewColumn) ClearAttributes(cellRenderer CellRendererer) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cellRenderer).Native()))

	C.gtk_tree_view_column_clear_attributes(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(cellRenderer)
}

// Clicked emits the “clicked” signal on the column. This function will only
// work if tree_column is clickable.
func (treeColumn *TreeViewColumn) Clicked() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	C.gtk_tree_view_column_clicked(_arg0)
	runtime.KeepAlive(treeColumn)
}

// FocusCell sets the current keyboard focus to be at cell, if the column
// contains 2 or more editable and activatable cells.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
func (treeColumn *TreeViewColumn) FocusCell(cell CellRendererer) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))

	C.gtk_tree_view_column_focus_cell(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(cell)
}

// Alignment returns the current x alignment of tree_column. This value can
// range between 0.0 and 1.0.
//
// The function returns the following values:
//
//   - gfloat: current alignent of tree_column.
func (treeColumn *TreeViewColumn) Alignment() float32 {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.float              // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_alignment(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gfloat float32 // out

	_gfloat = float32(_cret)

	return _gfloat
}

// Button returns the button used in the treeview column header.
//
// The function returns the following values:
//
//   - widget: button for the column header.
func (treeColumn *TreeViewColumn) Button() Widgetter {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_button(_arg0)
	runtime.KeepAlive(treeColumn)

	var _widget Widgetter // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gtk.Widgetter is nil")
		}

		object := coreglib.Take(objptr)
		casted := object.WalkCast(func(obj coreglib.Objector) bool {
			_, ok := obj.(Widgetter)
			return ok
		})
		rv, ok := casted.(Widgetter)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
		}
		_widget = rv
	}

	return _widget
}

// Clickable returns TRUE if the user can click on the header for the column.
//
// The function returns the following values:
//
//   - ok: TRUE if user can click the column header.
func (treeColumn *TreeViewColumn) Clickable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_clickable(_arg0)
	runtime.KeepAlive(treeColumn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Expand returns TRUE if the column expands to fill available space.
//
// The function returns the following values:
//
//   - ok: TRUE if the column expands to fill available space.
func (treeColumn *TreeViewColumn) Expand() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_expand(_arg0)
	runtime.KeepAlive(treeColumn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FixedWidth gets the fixed width of the column. This may not
// be the actual displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
//
// The function returns the following values:
//
//   - gint: fixed width of the column.
func (treeColumn *TreeViewColumn) FixedWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_fixed_width(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MaxWidth returns the maximum width in pixels of the tree_column, or -1 if no
// maximum width is set.
//
// The function returns the following values:
//
//   - gint: maximum width of the tree_column.
func (treeColumn *TreeViewColumn) MaxWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_max_width(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MinWidth returns the minimum width in pixels of the tree_column, or -1 if no
// minimum width is set.
//
// The function returns the following values:
//
//   - gint: minimum width of the tree_column.
func (treeColumn *TreeViewColumn) MinWidth() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_min_width(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Reorderable returns TRUE if the tree_column can be reordered by the user.
//
// The function returns the following values:
//
//   - ok: TRUE if the tree_column can be reordered by the user.
func (treeColumn *TreeViewColumn) Reorderable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_reorderable(_arg0)
	runtime.KeepAlive(treeColumn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Resizable returns TRUE if the tree_column can be resized by the end user.
//
// The function returns the following values:
//
//   - ok: TRUE, if the tree_column can be resized.
func (treeColumn *TreeViewColumn) Resizable() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_resizable(_arg0)
	runtime.KeepAlive(treeColumn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Sizing returns the current type of tree_column.
//
// The function returns the following values:
//
//   - treeViewColumnSizing: type of tree_column.
func (treeColumn *TreeViewColumn) Sizing() TreeViewColumnSizing {
	var _arg0 *C.GtkTreeViewColumn      // out
	var _cret C.GtkTreeViewColumnSizing // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_sizing(_arg0)
	runtime.KeepAlive(treeColumn)

	var _treeViewColumnSizing TreeViewColumnSizing // out

	_treeViewColumnSizing = TreeViewColumnSizing(_cret)

	return _treeViewColumnSizing
}

// SortColumnID gets the logical sort_column_id that the model
// sorts on when this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
//
// The function returns the following values:
//
//   - gint: current sort_column_id for this column, or -1 if this column can’t
//     be used for sorting.
func (treeColumn *TreeViewColumn) SortColumnID() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_sort_column_id(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
//
// The function returns the following values:
//
//   - ok: whether the sort indicator arrow is displayed.
func (treeColumn *TreeViewColumn) SortIndicator() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_sort_indicator(_arg0)
	runtime.KeepAlive(treeColumn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
//
// The function returns the following values:
//
//   - sortType: sort order the sort indicator is indicating.
func (treeColumn *TreeViewColumn) SortOrder() SortType {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.GtkSortType        // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_sort_order(_arg0)
	runtime.KeepAlive(treeColumn)

	var _sortType SortType // out

	_sortType = SortType(_cret)

	return _sortType
}

// Spacing returns the spacing of tree_column.
//
// The function returns the following values:
//
//   - gint: spacing of tree_column.
func (treeColumn *TreeViewColumn) Spacing() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_spacing(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Title returns the title of the widget.
//
// The function returns the following values:
//
//   - utf8: title of the column. This string should not be modified or freed.
func (treeColumn *TreeViewColumn) Title() string {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_title(_arg0)
	runtime.KeepAlive(treeColumn)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TreeView returns the TreeView wherein tree_column has been inserted.
// If column is currently not inserted in any tree view, NULL is returned.
//
// The function returns the following values:
//
//   - widget (optional): tree view wherein column has been inserted if any,
//     NULL otherwise.
func (treeColumn *TreeViewColumn) TreeView() Widgetter {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_tree_view(_arg0)
	runtime.KeepAlive(treeColumn)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Visible returns TRUE if tree_column is visible.
//
// The function returns the following values:
//
//   - ok: whether the column is visible or not. If it is visible, then the tree
//     will show the column.
func (treeColumn *TreeViewColumn) Visible() bool {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_visible(_arg0)
	runtime.KeepAlive(treeColumn)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Widget returns the Widget in the button on the column header. If a custom
// widget has not been set then NULL is returned.
//
// The function returns the following values:
//
//   - widget (optional) in the column header, or NULL.
func (treeColumn *TreeViewColumn) Widget() Widgetter {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret *C.GtkWidget         // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_widget(_arg0)
	runtime.KeepAlive(treeColumn)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Width returns the current size of tree_column in pixels.
//
// The function returns the following values:
//
//   - gint: current width of tree_column.
func (treeColumn *TreeViewColumn) Width() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_width(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// XOffset returns the current X offset of tree_column in pixels.
//
// The function returns the following values:
//
//   - gint: current X offset of tree_column.
func (treeColumn *TreeViewColumn) XOffset() int {
	var _arg0 *C.GtkTreeViewColumn // out
	var _cret C.int                // in

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	_cret = C.gtk_tree_view_column_get_x_offset(_arg0)
	runtime.KeepAlive(treeColumn)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// PackEnd adds the cell to end of the column. If expand is FALSE, then the cell
// is allocated no more space than it needs. Any unused space is divided evenly
// between cells for which expand is TRUE.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - expand: TRUE if cell is to be given extra space allocated to tree_column.
func (treeColumn *TreeViewColumn) PackEnd(cell CellRendererer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_end(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(expand)
}

// PackStart packs the cell into the beginning of the column. If expand is
// FALSE, then the cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which expand is TRUE.
//
// The function takes the following parameters:
//
//   - cell: CellRenderer.
//   - expand: TRUE if cell is to be given extra space allocated to tree_column.
func (treeColumn *TreeViewColumn) PackStart(cell CellRendererer, expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkCellRenderer   // out
	var _arg2 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cell).Native()))
	if expand {
		_arg2 = C.TRUE
	}

	C.gtk_tree_view_column_pack_start(_arg0, _arg1, _arg2)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(cell)
	runtime.KeepAlive(expand)
}

// QueueResize flags the column, and the cell renderers added to this column,
// to have their sizes renegotiated.
func (treeColumn *TreeViewColumn) QueueResize() {
	var _arg0 *C.GtkTreeViewColumn // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))

	C.gtk_tree_view_column_queue_resize(_arg0)
	runtime.KeepAlive(treeColumn)
}

// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button -- 0.0
// for left, 0.5 for center, 1.0 for right.
//
// The function takes the following parameters:
//
//   - xalign: alignment, which is between [0.0 and 1.0] inclusive.
func (treeColumn *TreeViewColumn) SetAlignment(xalign float32) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.float              // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.float(xalign)

	C.gtk_tree_view_column_set_alignment(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(xalign)
}

// SetCellDataFunc sets the TreeCellDataFunc to use for the column. This
// function is used instead of the standard attributes mapping for setting the
// column value, and should set the value of tree_column's cell renderer as
// appropriate. func may be NULL to remove an older one.
//
// The function takes the following parameters:
//
//   - cellRenderer: CellRenderer.
//   - fn (optional) to use.
func (treeColumn *TreeViewColumn) SetCellDataFunc(cellRenderer CellRendererer, fn TreeCellDataFunc) {
	var _arg0 *C.GtkTreeViewColumn  // out
	var _arg1 *C.GtkCellRenderer    // out
	var _arg2 C.GtkTreeCellDataFunc // out
	var _arg3 C.gpointer
	var _arg4 C.GDestroyNotify

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(coreglib.InternObject(cellRenderer).Native()))
	if fn != nil {
		_arg2 = (*[0]byte)(C._gotk4_gtk4_TreeCellDataFunc)
		_arg3 = C.gpointer(gbox.Assign(fn))
		_arg4 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))
	}

	C.gtk_tree_view_column_set_cell_data_func(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(cellRenderer)
	runtime.KeepAlive(fn)
}

// SetClickable sets the header to be active if clickable is TRUE. When the
// header is active, then it can take keyboard focus, and can be clicked.
//
// The function takes the following parameters:
//
//   - clickable: TRUE if the header is active.
func (treeColumn *TreeViewColumn) SetClickable(clickable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	if clickable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_clickable(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(clickable)
}

// SetExpand sets the column to take available extra space. This space is shared
// equally amongst all columns that have the expand set to TRUE. If no column
// has this option set, then the last column gets all extra space. By default,
// every column is created with this FALSE.
//
// Along with “fixed-width”, the “expand” property changes when the column is
// resized by the user.
//
// The function takes the following parameters:
//
//   - expand: TRUE if the column should expand to fill available space.
func (treeColumn *TreeViewColumn) SetExpand(expand bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_expand(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(expand)
}

// SetFixedWidth: if fixed_width is not -1, sets the fixed width of tree_column;
// otherwise unsets it. The effective value of fixed_width is clamped between
// the minimum and maximum width of the column; however, the value stored
// in the “fixed-width” property is not clamped. If the column sizing is
// K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE, setting a fixed
// width overrides the automatically calculated width. Note that fixed_width is
// only a hint to GTK; the width actually allocated to the column may be greater
// or less than requested.
//
// Along with “expand”, the “fixed-width” property changes when the column is
// resized by the user.
//
// The function takes the following parameters:
//
//   - fixedWidth: new fixed width, in pixels, or -1.
func (treeColumn *TreeViewColumn) SetFixedWidth(fixedWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.int(fixedWidth)

	C.gtk_tree_view_column_set_fixed_width(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(fixedWidth)
}

// SetMaxWidth sets the maximum width of the tree_column. If max_width is -1,
// then the maximum width is unset. Note, the column can actually be wider than
// max width if it’s the last column in a view. In this case, the column expands
// to fill any extra space.
//
// The function takes the following parameters:
//
//   - maxWidth: maximum width of the column in pixels, or -1.
func (treeColumn *TreeViewColumn) SetMaxWidth(maxWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.int(maxWidth)

	C.gtk_tree_view_column_set_max_width(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(maxWidth)
}

// SetMinWidth sets the minimum width of the tree_column. If min_width is -1,
// then the minimum width is unset.
//
// The function takes the following parameters:
//
//   - minWidth: minimum width of the column in pixels, or -1.
func (treeColumn *TreeViewColumn) SetMinWidth(minWidth int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.int(minWidth)

	C.gtk_tree_view_column_set_min_width(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(minWidth)
}

// SetReorderable: if reorderable is TRUE, then the column can be reordered by
// the end user dragging the header.
//
// The function takes the following parameters:
//
//   - reorderable: TRUE, if the column can be reordered.
func (treeColumn *TreeViewColumn) SetReorderable(reorderable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	if reorderable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_reorderable(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(reorderable)
}

// SetResizable: if resizable is TRUE, then the user can explicitly resize the
// column by grabbing the outer edge of the column button. If resizable is TRUE
// and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE, then the sizing
// mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
//
// The function takes the following parameters:
//
//   - resizable: TRUE, if the column can be resized.
func (treeColumn *TreeViewColumn) SetResizable(resizable bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_resizable(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(resizable)
}

// SetSizing sets the growth behavior of tree_column to type.
//
// The function takes the following parameters:
//
//   - typ: TreeViewColumnSizing.
func (treeColumn *TreeViewColumn) SetSizing(typ TreeViewColumnSizing) {
	var _arg0 *C.GtkTreeViewColumn      // out
	var _arg1 C.GtkTreeViewColumnSizing // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.GtkTreeViewColumnSizing(typ)

	C.gtk_tree_view_column_set_sizing(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(typ)
}

// SetSortColumnID sets the logical sort_column_id that this column sorts on
// when this column is selected for sorting. Doing so makes the column header
// clickable.
//
// The function takes the following parameters:
//
//   - sortColumnId: sort_column_id of the model to sort on.
func (treeColumn *TreeViewColumn) SetSortColumnID(sortColumnId int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.int(sortColumnId)

	C.gtk_tree_view_column_set_sort_column_id(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(sortColumnId)
}

// SetSortIndicator: call this function with a setting of TRUE to display
// an arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the arrow.
//
// The function takes the following parameters:
//
//   - setting: TRUE to display an indicator that the column is sorted.
func (treeColumn *TreeViewColumn) SetSortIndicator(setting bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_sort_indicator(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(setting)
}

// SetSortOrder changes the appearance of the sort indicator.
//
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and should
// be used in conjunction with gtk_tree_sortable_set_sort_column_id() to do
// that. For custom models, the mechanism will vary.
//
// The sort indicator changes direction to indicate normal sort or reverse sort.
// Note that you must have the sort indicator enabled to see anything when
// calling this function; see gtk_tree_view_column_set_sort_indicator().
//
// The function takes the following parameters:
//
//   - order: sort order that the sort indicator should indicate.
func (treeColumn *TreeViewColumn) SetSortOrder(order SortType) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.GtkSortType        // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.GtkSortType(order)

	C.gtk_tree_view_column_set_sort_order(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(order)
}

// SetSpacing sets the spacing field of tree_column, which is the number of
// pixels to place between cell renderers packed into it.
//
// The function takes the following parameters:
//
//   - spacing: distance between cell renderers in pixels.
func (treeColumn *TreeViewColumn) SetSpacing(spacing int) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.int                // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = C.int(spacing)

	C.gtk_tree_view_column_set_spacing(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(spacing)
}

// SetTitle sets the title of the tree_column. If a custom widget has been set,
// then this value is ignored.
//
// The function takes the following parameters:
//
//   - title of the tree_column.
func (treeColumn *TreeViewColumn) SetTitle(title string) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_tree_view_column_set_title(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(title)
}

// SetVisible sets the visibility of tree_column.
//
// The function takes the following parameters:
//
//   - visible: TRUE if the tree_column is visible.
func (treeColumn *TreeViewColumn) SetVisible(visible bool) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 C.gboolean           // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_tree_view_column_set_visible(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(visible)
}

// SetWidget sets the widget in the header to be widget. If widget is NULL,
// then the header button is set with a Label set to the title of tree_column.
//
// The function takes the following parameters:
//
//   - widget (optional): child Widget, or NULL.
func (treeColumn *TreeViewColumn) SetWidget(widget Widgetter) {
	var _arg0 *C.GtkTreeViewColumn // out
	var _arg1 *C.GtkWidget         // out

	_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(coreglib.InternObject(treeColumn).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_tree_view_column_set_widget(_arg0, _arg1)
	runtime.KeepAlive(treeColumn)
	runtime.KeepAlive(widget)
}

// VideoOverrides contains methods that are overridable.
type VideoOverrides struct {
}

func defaultVideoOverrides(v *Video) VideoOverrides {
	return VideoOverrides{}
}

// Video: GtkVideo is a widget to show a GtkMediaStream with media controls.
//
// !An example GtkVideo (video.png)
//
// The controls are available separately as gtk.MediaControls. If you just
// want to display a video without controls, you can treat it like any other
// paintable and for example put it into a gtk.Picture.
//
// GtkVideo aims to cover use cases such as previews, embedded animations, etc.
// It supports autoplay, looping, and simple media controls. It does not have
// support for video overlays, multichannel audio, device selection, or input.
// If you are writing a full-fledged video player, you may want to use the
// gdk.Paintable API and a media framework such as Gstreamer directly.
type Video struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Video)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Video, *VideoClass, VideoOverrides](
		GTypeVideo,
		initVideoClass,
		wrapVideo,
		defaultVideoOverrides,
	)
}

func initVideoClass(gclass unsafe.Pointer, overrides VideoOverrides, classInitFunc func(*VideoClass)) {
	if classInitFunc != nil {
		class := (*VideoClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapVideo(obj *coreglib.Object) *Video {
	return &Video{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalVideo(p uintptr) (interface{}, error) {
	return wrapVideo(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewVideo creates a new empty GtkVideo.
//
// The function returns the following values:
//
//   - video: new GtkVideo.
func NewVideo() *Video {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_video_new()

	var _video *Video // out

	_video = wrapVideo(coreglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForFile creates a GtkVideo to play back the given file.
//
// The function takes the following parameters:
//
//   - file (optional): GFile.
//
// The function returns the following values:
//
//   - video: new GtkVideo.
func NewVideoForFile(file gio.Filer) *Video {
	var _arg1 *C.GFile     // out
	var _cret *C.GtkWidget // in

	if file != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}

	_cret = C.gtk_video_new_for_file(_arg1)
	runtime.KeepAlive(file)

	var _video *Video // out

	_video = wrapVideo(coreglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForFilename creates a GtkVideo to play back the given filename.
//
// This is a utility function that calls gtk.Video.NewForFile, See that function
// for details.
//
// The function takes the following parameters:
//
//   - filename (optional) to play back.
//
// The function returns the following values:
//
//   - video: new GtkVideo.
func NewVideoForFilename(filename string) *Video {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if filename != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_video_new_for_filename(_arg1)
	runtime.KeepAlive(filename)

	var _video *Video // out

	_video = wrapVideo(coreglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForMediaStream creates a GtkVideo to play back the given stream.
//
// The function takes the following parameters:
//
//   - stream (optional): GtkMediaStream.
//
// The function returns the following values:
//
//   - video: new GtkVideo.
func NewVideoForMediaStream(stream MediaStreamer) *Video {
	var _arg1 *C.GtkMediaStream // out
	var _cret *C.GtkWidget      // in

	if stream != nil {
		_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	}

	_cret = C.gtk_video_new_for_media_stream(_arg1)
	runtime.KeepAlive(stream)

	var _video *Video // out

	_video = wrapVideo(coreglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// NewVideoForResource creates a GtkVideo to play back the resource at the given
// resource_path.
//
// This is a utility function that calls gtk.Video.NewForFile.
//
// The function takes the following parameters:
//
//   - resourcePath (optional): resource path to play back.
//
// The function returns the following values:
//
//   - video: new GtkVideo.
func NewVideoForResource(resourcePath string) *Video {
	var _arg1 *C.char      // out
	var _cret *C.GtkWidget // in

	if resourcePath != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_video_new_for_resource(_arg1)
	runtime.KeepAlive(resourcePath)

	var _video *Video // out

	_video = wrapVideo(coreglib.Take(unsafe.Pointer(_cret)))

	return _video
}

// Autoplay returns TRUE if videos have been set to loop.
//
// The function returns the following values:
//
//   - ok: TRUE if streams should autoplay.
func (self *Video) Autoplay() bool {
	var _arg0 *C.GtkVideo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_video_get_autoplay(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// File gets the file played by self or NULL if not playing back a file.
//
// The function returns the following values:
//
//   - file (optional) played by self.
func (self *Video) File() *gio.File {
	var _arg0 *C.GtkVideo // out
	var _cret *C.GFile    // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_video_get_file(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_file = &gio.File{
				Object: obj,
			}
		}
	}

	return _file
}

// Loop returns TRUE if videos have been set to loop.
//
// The function returns the following values:
//
//   - ok: TRUE if streams should loop.
func (self *Video) Loop() bool {
	var _arg0 *C.GtkVideo // out
	var _cret C.gboolean  // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_video_get_loop(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MediaStream gets the media stream managed by self or NULL if none.
//
// The function returns the following values:
//
//   - mediaStream (optional): media stream managed by self.
func (self *Video) MediaStream() MediaStreamer {
	var _arg0 *C.GtkVideo       // out
	var _cret *C.GtkMediaStream // in

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_video_get_media_stream(_arg0)
	runtime.KeepAlive(self)

	var _mediaStream MediaStreamer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(MediaStreamer)
				return ok
			})
			rv, ok := casted.(MediaStreamer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.MediaStreamer")
			}
			_mediaStream = rv
		}
	}

	return _mediaStream
}

// SetAutoplay sets whether self automatically starts playback when it becomes
// visible or when a new file gets loaded.
//
// The function takes the following parameters:
//
//   - autoplay: whether media streams should autoplay.
func (self *Video) SetAutoplay(autoplay bool) {
	var _arg0 *C.GtkVideo // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if autoplay {
		_arg1 = C.TRUE
	}

	C.gtk_video_set_autoplay(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(autoplay)
}

// SetFile makes self play the given file.
//
// The function takes the following parameters:
//
//   - file (optional) to play.
func (self *Video) SetFile(file gio.Filer) {
	var _arg0 *C.GtkVideo // out
	var _arg1 *C.GFile    // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if file != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}

	C.gtk_video_set_file(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(file)
}

// SetFilename makes self play the given filename.
//
// This is a utility function that calls gtk_video_set_file(),.
//
// The function takes the following parameters:
//
//   - filename (optional) to play.
func (self *Video) SetFilename(filename string) {
	var _arg0 *C.GtkVideo // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if filename != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(filename)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_video_set_filename(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(filename)
}

// SetLoop sets whether new files loaded by self should be set to loop.
//
// The function takes the following parameters:
//
//   - loop: whether media streams should loop.
func (self *Video) SetLoop(loop bool) {
	var _arg0 *C.GtkVideo // out
	var _arg1 C.gboolean  // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if loop {
		_arg1 = C.TRUE
	}

	C.gtk_video_set_loop(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(loop)
}

// SetMediaStream sets the media stream to be played back.
//
// self will take full control of managing the media stream. If you want to
// manage a media stream yourself, consider using a gtk.Picture for display.
//
// If you want to display a file, consider using gtk.Video.SetFile() instead.
//
// The function takes the following parameters:
//
//   - stream (optional): media stream to play or NULL to unset.
func (self *Video) SetMediaStream(stream MediaStreamer) {
	var _arg0 *C.GtkVideo       // out
	var _arg1 *C.GtkMediaStream // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if stream != nil {
		_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(coreglib.InternObject(stream).Native()))
	}

	C.gtk_video_set_media_stream(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(stream)
}

// SetResource makes self play the resource at the given resource_path.
//
// This is a utility function that calls gtk.Video.SetFile().
//
// The function takes the following parameters:
//
//   - resourcePath (optional): resource to set.
func (self *Video) SetResource(resourcePath string) {
	var _arg0 *C.GtkVideo // out
	var _arg1 *C.char     // out

	_arg0 = (*C.GtkVideo)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if resourcePath != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourcePath)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_video_set_resource(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(resourcePath)
}

// Viewport: GtkViewport implements scrollability for widgets that lack their
// own scrolling capabilities.
//
// Use GtkViewport to scroll child widgets such as GtkGrid, GtkBox, and so on.
//
// The GtkViewport will start scrolling content only if allocated less than the
// child widget’s minimum size in a given orientation.
//
// # CSS nodes
//
// GtkViewport has a single CSS node with name viewport.
//
// # Accessibility
//
// GtkViewport uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type Viewport struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Scrollable
}

var (
	_ Widgetter         = (*Viewport)(nil)
	_ coreglib.Objector = (*Viewport)(nil)
)

func wrapViewport(obj *coreglib.Object) *Viewport {
	return &Viewport{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Scrollable: Scrollable{
			Object: obj,
		},
	}
}

func marshalViewport(p uintptr) (interface{}, error) {
	return wrapViewport(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewViewport creates a new GtkViewport.
//
// The new viewport uses the given adjustments, or default adjustments if none
// are given.
//
// The function takes the following parameters:
//
//   - hadjustment (optional): horizontal adjustment.
//   - vadjustment (optional): vertical adjustment.
//
// The function returns the following values:
//
//   - viewport: new GtkViewport.
func NewViewport(hadjustment, vadjustment *Adjustment) *Viewport {
	var _arg1 *C.GtkAdjustment // out
	var _arg2 *C.GtkAdjustment // out
	var _cret *C.GtkWidget     // in

	if hadjustment != nil {
		_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(hadjustment).Native()))
	}
	if vadjustment != nil {
		_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(coreglib.InternObject(vadjustment).Native()))
	}

	_cret = C.gtk_viewport_new(_arg1, _arg2)
	runtime.KeepAlive(hadjustment)
	runtime.KeepAlive(vadjustment)

	var _viewport *Viewport // out

	_viewport = wrapViewport(coreglib.Take(unsafe.Pointer(_cret)))

	return _viewport
}

// Child gets the child widget of viewport.
//
// The function returns the following values:
//
//   - widget (optional): child widget of viewport.
func (viewport *Viewport) Child() Widgetter {
	var _arg0 *C.GtkViewport // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(coreglib.InternObject(viewport).Native()))

	_cret = C.gtk_viewport_get_child(_arg0)
	runtime.KeepAlive(viewport)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// ScrollToFocus gets whether the viewport is scrolling to keep the focused
// child in view.
//
// The function returns the following values:
//
//   - ok: TRUE if the viewport keeps the focus child scrolled to view.
func (viewport *Viewport) ScrollToFocus() bool {
	var _arg0 *C.GtkViewport // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(coreglib.InternObject(viewport).Native()))

	_cret = C.gtk_viewport_get_scroll_to_focus(_arg0)
	runtime.KeepAlive(viewport)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetChild sets the child widget of viewport.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (viewport *Viewport) SetChild(child Widgetter) {
	var _arg0 *C.GtkViewport // out
	var _arg1 *C.GtkWidget   // out

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(coreglib.InternObject(viewport).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_viewport_set_child(_arg0, _arg1)
	runtime.KeepAlive(viewport)
	runtime.KeepAlive(child)
}

// SetScrollToFocus sets whether the viewport should automatically scroll to
// keep the focused child in view.
//
// The function takes the following parameters:
//
//   - scrollToFocus: whether to keep the focus widget scrolled to view.
func (viewport *Viewport) SetScrollToFocus(scrollToFocus bool) {
	var _arg0 *C.GtkViewport // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.GtkViewport)(unsafe.Pointer(coreglib.InternObject(viewport).Native()))
	if scrollToFocus {
		_arg1 = C.TRUE
	}

	C.gtk_viewport_set_scroll_to_focus(_arg0, _arg1)
	runtime.KeepAlive(viewport)
	runtime.KeepAlive(scrollToFocus)
}

// VolumeButton: GtkVolumeButton is a GtkScaleButton subclass tailored for
// volume control.
//
// !An example GtkVolumeButton (volumebutton.png).
type VolumeButton struct {
	_ [0]func() // equal guard
	ScaleButton
}

var (
	_ Widgetter         = (*VolumeButton)(nil)
	_ coreglib.Objector = (*VolumeButton)(nil)
)

func wrapVolumeButton(obj *coreglib.Object) *VolumeButton {
	return &VolumeButton{
		ScaleButton: ScaleButton{
			Widget: Widget{
				InitiallyUnowned: coreglib.InitiallyUnowned{
					Object: obj,
				},
				Object: obj,
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
			Object: obj,
			Orientable: Orientable{
				Object: obj,
			},
		},
	}
}

func marshalVolumeButton(p uintptr) (interface{}, error) {
	return wrapVolumeButton(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewVolumeButton creates a GtkVolumeButton.
//
// The button has a range between 0.0 and 1.0, with a stepping of 0.02. Volume
// values can be obtained and modified using the functions from gtk.ScaleButton.
//
// The function returns the following values:
//
//   - volumeButton: new GtkVolumeButton.
func NewVolumeButton() *VolumeButton {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_volume_button_new()

	var _volumeButton *VolumeButton // out

	_volumeButton = wrapVolumeButton(coreglib.Take(unsafe.Pointer(_cret)))

	return _volumeButton
}

// WidgetOverrides contains methods that are overridable.
type WidgetOverrides struct {
	// Contains tests if the point at (x, y) is contained in widget.
	//
	// The coordinates for (x, y) must be in widget coordinates, so (0, 0) is
	// assumed to be the top left of widget's content area.
	//
	// The function takes the following parameters:
	//
	//   - x: x coordinate to test, relative to widget's origin.
	//   - y: y coordinate to test, relative to widget's origin.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if widget contains (x, y).
	Contains         func(x, y float64) bool
	DirectionChanged func(previousDirection TextDirection)
	Focus            func(direction DirectionType) bool
	// RequestMode gets whether the widget prefers a height-for-width layout or
	// a width-for-height layout.
	//
	// Single-child widgets generally propagate the preference of their child,
	// more complex widgets need to request something either in context of their
	// children or in context of their allocation capabilities.
	//
	// The function returns the following values:
	//
	//   - sizeRequestMode: GtkSizeRequestMode preferred by widget.
	RequestMode func() SizeRequestMode
	// GrabFocus causes widget to have the keyboard focus for the GtkWindow it's
	// inside.
	//
	// If widget is not focusable, or its ::grab_focus implementation cannot
	// transfer the focus to a descendant of widget that is focusable, it will
	// not take focus and FALSE will be returned.
	//
	// Calling gtk.Widget.GrabFocus() on an already focused widget is allowed,
	// should not have an effect, and return TRUE.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if focus is now inside widget.
	GrabFocus func() bool
	// Hide reverses the effects of gtk_widget_show().
	//
	// This is causing the widget to be hidden (invisible to the user).
	Hide func()
	// KeynavFailed emits the ::keynav-failed signal on the widget.
	//
	// This function should be called whenever keyboard navigation within a
	// single widget hits a boundary.
	//
	// The return value of this function should be interpreted in a way similar
	// to the return value of gtk.Widget.ChildFocus(). When TRUE is returned,
	// stay in the widget, the failed keyboard navigation is OK and/or there
	// is nowhere we can/should move the focus to. When FALSE is returned,
	// the caller should continue with keyboard navigation outside the widget,
	// e.g. by calling gtk.Widget.ChildFocus() on the widget’s toplevel.
	//
	// The default gtk.Widget::keynav-failed handler returns FALSE for
	// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
	// DirectionType it returns TRUE.
	//
	// Whenever the default handler returns TRUE, it also calls
	// gtk.Widget.ErrorBell() to notify the user of the failed keyboard
	// navigation.
	//
	// A use case for providing an own implementation of ::keynav-failed (either
	// by connecting to it or by overriding it) would be a row of gtk.Entry
	// widgets where the user should be able to navigate the entire row with the
	// cursor keys, as e.g. known from user interfaces that require entering
	// license keys.
	//
	// The function takes the following parameters:
	//
	//   - direction of focus movement.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if stopping keyboard navigation is fine, FALSE if the
	//     emitting widget should try to handle the keyboard navigation attempt
	//     in its parent container(s).
	KeynavFailed func(direction DirectionType) bool
	// Map causes a widget to be mapped if it isn’t already.
	//
	// This function is only for use in widget implementations.
	Map func()
	// Measure measures widget in the orientation orientation and for the given
	// for_size.
	//
	// As an example, if orientation is GTK_ORIENTATION_HORIZONTAL and for_size
	// is 300, this functions will compute the minimum and natural width of
	// widget if it is allocated at a height of 300 pixels.
	//
	// See GtkWidget’s geometry management section
	// (class.Widget.html#height-for-width-geometry-management) for a more
	// details on implementing WidgetClass.measure().
	//
	// The function takes the following parameters:
	//
	//   - orientation to measure.
	//   - forSize: size for the opposite of orientation, i.e. if orientation
	//     is GTK_ORIENTATION_HORIZONTAL, this is the height the widget should
	//     be measured with. The GTK_ORIENTATION_VERTICAL case is analogous.
	//     This way, both height-for-width and width-for-height requests can be
	//     implemented. If no size is known, -1 can be passed.
	//
	// The function returns the following values:
	//
	//   - minimum (optional): location to store the minimum size, or NULL.
	//   - natural (optional): location to store the natural size, or NULL.
	//   - minimumBaseline (optional): location to store the baseline position
	//     for the minimum size, or NULL.
	//   - naturalBaseline (optional): location to store the baseline position
	//     for the natural size, or NULL.
	Measure func(orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int)
	// MnemonicActivate emits the GtkWidget::mnemonic-activate signal.
	//
	// The function takes the following parameters:
	//
	//   - groupCycling: TRUE if there are other widgets with the same mnemonic.
	//
	// The function returns the following values:
	//
	//   - ok: TRUE if the signal has been handled.
	MnemonicActivate func(groupCycling bool) bool
	MoveFocus        func(direction DirectionType)
	// The function takes the following parameters:
	//
	//   - x
	//   - y
	//   - keyboardTooltip
	//   - tooltip
	QueryTooltip func(x, y int, keyboardTooltip bool, tooltip *Tooltip) bool
	// Realize creates the GDK resources associated with a widget.
	//
	// Normally realization happens implicitly; if you show a widget and all
	// its parent containers, then the widget will be realized and mapped
	// automatically.
	//
	// Realizing a widget requires all the widget’s parent widgets to be
	// realized; calling this function realizes the widget’s parents in addition
	// to widget itself. If a widget is not yet inside a toplevel window when
	// you realize it, bad things will happen.
	//
	// This function is primarily used in widget implementations, and isn’t
	// very useful otherwise. Many times when you think you might need it,
	// a better approach is to connect to a signal that will be called after the
	// widget is realized automatically, such as gtk.Widget::realize.
	Realize func()
	Root    func()
	// SetFocusChild: set child as the current focus child of widget.
	//
	// The previous focus child will be unset.
	//
	// This function is only suitable for widget implementations. If you want a
	// certain widget to get the input focus, call gtk.Widget.GrabFocus() on it.
	//
	// The function takes the following parameters:
	//
	//   - child (optional): direct child widget of widget or NULL to unset the
	//     focus child of widget.
	SetFocusChild func(child Widgetter)
	// Show flags a widget to be displayed.
	//
	// Any widget that isn’t shown will not appear on the screen.
	//
	// Remember that you have to show the containers containing a widget,
	// in addition to the widget itself, before it will appear onscreen.
	//
	// When a toplevel container is shown, it is immediately realized and
	// mapped; other shown widgets are realized and mapped when their toplevel
	// container is realized and mapped.
	Show func()
	// The function takes the following parameters:
	//
	//   - width
	//   - height
	//   - baseline
	SizeAllocate         func(width, height, baseline int)
	Snapshot             func(snapshot *Snapshot)
	StateFlagsChanged    func(previousStateFlags StateFlags)
	SystemSettingChanged func(settings SystemSetting)
	// Unmap causes a widget to be unmapped if it’s currently mapped.
	//
	// This function is only for use in widget implementations.
	Unmap func()
	// Unrealize causes a widget to be unrealized (frees all GDK resources
	// associated with the widget).
	//
	// This function is only useful in widget implementations.
	Unrealize func()
	Unroot    func()
}

func defaultWidgetOverrides(v *Widget) WidgetOverrides {
	return WidgetOverrides{
		Contains:             v.contains,
		DirectionChanged:     v.directionChanged,
		Focus:                v.focus,
		RequestMode:          v.requestMode,
		GrabFocus:            v.grabFocus,
		Hide:                 v.hide,
		KeynavFailed:         v.keynavFailed,
		Map:                  v._map,
		Measure:              v.measure,
		MnemonicActivate:     v.mnemonicActivate,
		MoveFocus:            v.moveFocus,
		QueryTooltip:         v.queryTooltip,
		Realize:              v.realize,
		Root:                 v.root,
		SetFocusChild:        v.setFocusChild,
		Show:                 v.show,
		SizeAllocate:         v.sizeAllocate,
		Snapshot:             v.snapshot,
		StateFlagsChanged:    v.stateFlagsChanged,
		SystemSettingChanged: v.systemSettingChanged,
		Unmap:                v.unmap,
		Unrealize:            v.unrealize,
		Unroot:               v.unroot,
	}
}

// Widget: base class for all widgets.
//
// GtkWidget is the base class all widgets in GTK derive from. It manages the
// widget lifecycle, layout, states and style.
//
// # Height-for-width Geometry Management
//
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
//
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
//
// - gtk.Widget.GetRequestMode()
//
// - gtk.Widget.Measure()
//
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
//
// If you implement a direct GtkWidget subclass that supports height-for-width
// or width-for-height geometry management for itself or its child widgets,
// the gtk.Widget.GetRequestMode() virtual function must be implemented as well
// and return the widget's preferred request mode. The default implementation
// of this virtual function returns GTK_SIZE_REQUEST_CONSTANT_SIZE, which means
// that the widget will only ever get -1 passed as the for_size value to its
// gtk.Widget.Measure() implementation.
//
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the gtk.SizeRequestMode
// chosen by the toplevel.
//
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode:
//
// First, the default minimum and natural width for each widget in the
// interface will be computed using gtk_widget_measure with an orientation
// of GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred
// widths for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use
// the minimum width to query for the minimum height contextual to that width
// using gtk_widget_measure with an orientation of GTK_ORIENTATION_VERTICAL and
// a for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
//
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with gtk.Window.SetDefaultSize()). During the recursive allocation
// process it’s important to note that request cycles will be recursively
// executed while widgets allocate their children. Each widget, once allocated
// a size, will go on to first share the space in one orientation among its
// children and then request each child's height for its target allocated width
// or its width for allocated height, depending. In this way a GtkWidget will
// typically be requested its size a number of times before actually being
// allocated a size. The size a widget is finally allocated can of course differ
// from the size it has requested. For this reason, GtkWidget caches a small
// number of results to avoid re-querying for the same sizes in one allocation
// cycle.
//
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both GtkSizeRequestModes even if the
// widget in question only trades sizes in a single orientation.
//
// For instance, a gtk.Label that does height-for-width word wrapping
// will not expect to have gtk.Widget.Measure() with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
//
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
//
//	static void
//	foo_widget_measure (GtkWidget      *widget,
//	                    GtkOrientation  orientation,
//	                    int             for_size,
//	                    int            *minimum_size,
//	                    int            *natural_size,
//	                    int            *minimum_baseline,
//	                    int            *natural_baseline)
//	{
//	  if (orientation == GTK_ORIENTATION_HORIZONTAL)
//	    {
//	      // Calculate minimum and natural width
//	    }
//	  else // VERTICAL
//	    {
//	      if (i_am_in_height_for_width_mode)
//	        {
//	          int min_width, dummy;
//
//	          // First, get the minimum width of our widget
//	          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//	                                                  &min_width, &dummy, &dummy, &dummy);
//
//	          // Now use the minimum width to retrieve the minimum and natural height to display
//	          // that width.
//	          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//	                                                  minimum_size, natural_size, &dummy, &dummy);
//	        }
//	      else
//	        {
//	          // ... some widgets do both.
//	        }
//	    }
//	}
//
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also compute
// width. Or when deciding how to use an allocation, the widget may need to know
// its natural size. In these cases, the widget should be careful to call its
// virtual methods directly, like in the code example above.
//
// It will not work to use the wrapper function gtk.Widget.Measure() inside your
// own gtk.Widget.SizeAllocate() implementation. These return a request adjusted
// by gtk.SizeGroup, the widget's align and expand flags, as well as its CSS
// style.
//
// If a widget used the wrappers inside its virtual method implementations,
// then the adjustments (such as widget margins) would be applied twice.
// GTK therefore does not allow this and will warn if you try to do it.
//
// Of course if you are getting the size request for another widget, such as
// a child widget, you must use gtk_widget_measure; otherwise, you would not
// properly consider widget margins, gtk.SizeGroup, and so forth.
//
// GTK also supports baseline vertical alignment of widgets. This means that
// widgets are positioned such that the typographical baseline of widgets in
// the same row are aligned. This happens if a widget supports baselines,
// has a vertical alignment of GTK_ALIGN_BASELINE, and is inside a widget that
// supports baselines and has a natural “row” that it aligns to the baseline,
// or a baseline assigned to it by the grandparent.
//
// Baseline alignment support for a widget is also done by the
// gtk.Widget.Measure() virtual function. It allows you to report both a minimum
// and natural size.
//
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was GTK_ALIGN_FILL, but the selected baseline can be
// found via gtk_widget_get_allocated_baseline. If the baseline has a value
// other than -1 you need to align the widget such that the baseline appears at
// the position.
//
// # GtkWidget as GtkBuildable
//
// The GtkWidget implementation of the GtkBuildable interface supports various
// custom elements to specify additional aspects of widgets that are not
// directly expressed as properties.
//
// If the widget uses a gtk.LayoutManager, GtkWidget supports a custom <layout>
// element, used to define layout properties:
//
//	<object class="GtkGrid" id="my_grid">
//	  <child>
//	    <object class="GtkLabel" id="label1">
//	      <property name="label">Description</property>
//	      <layout>
//	        <property name="column">0</property>
//	        <property name="row">0</property>
//	        <property name="row-span">1</property>
//	        <property name="column-span">1</property>
//	      </layout>
//	    </object>
//	  </child>
//	  <child>
//	    <object class="GtkEntry" id="description_entry">
//	      <layout>
//	        <property name="column">1</property>
//	        <property name="row">0</property>
//	        <property name="row-span">1</property>
//	        <property name="column-span">1</property>
//	      </layout>
//	    </object>
//	  </child>
//	</object>
//
// GtkWidget allows style information such as style classes to be associated
// with widgets, using the custom <style> element:
//
//	<object class="GtkButton" id="button1">
//	  <style>
//	    <class name="my-special-button-class"/>
//	    <class name="dark-button"/>
//	  </style>
//	</object>
//
// GtkWidget allows defining accessibility information, such as properties,
// relations, and states, using the custom <accessibility> element:
//
//	<object class="GtkButton" id="button1">
//	  <accessibility>
//	    <property name="label">Download</property>
//	    <relation name="labelled-by">label1</relation>
//	  </accessibility>
//	</object>
//
// # Building composite widgets from template XML
//
// GtkWidget exposes some facilities to automate the procedure of creating
// composite widgets using "templates".
//
// To create composite widgets with GtkBuilder XML, one must associate the
// interface description with the widget class at class initialization time
// using gtk.WidgetClass.SetTemplate().
//
// The interface description semantics expected in composite template
// descriptions is slightly different from regular gtk.Builder XML.
//
// Unlike regular interface descriptions, gtk.WidgetClass.SetTemplate() will
// expect a <template> tag as a direct child of the toplevel <interface> tag.
// The <template> tag must specify the “class” attribute which must be
// the type name of the widget. Optionally, the “parent” attribute may
// be specified to specify the direct parent type of the widget type,
// this is ignored by GtkBuilder but required for UI design tools like Glade
// (https://glade.gnome.org/) to introspect what kind of properties and internal
// children exist for a given type when the actual type does not exist.
//
// The XML which is contained inside the <template> tag behaves as if it were
// added to the <object> tag defining the widget itself. You may set properties
// on a widget by inserting <property> tags into the <template> tag, and also
// add <child> tags to add children and extend a widget in the normal way you
// would with <object> tags.
//
// Additionally, <object> tags can also be added before and after the initial
// <template> tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// <template> tag.
//
// An example of a template definition:
//
//	<interface>
//	  <template class="FooWidget" parent="GtkBox">
//	    <property name="orientation">horizontal</property>
//	    <property name="spacing">4</property>
//	    <child>
//	      <object class="GtkButton" id="hello_button">
//	        <property name="label">Hello World</property>
//	        <signal name="clicked" handler="hello_button_clicked" object="FooWidget" swapped="yes"/>
//	      </object>
//	    </child>
//	    <child>
//	      <object class="GtkButton" id="goodbye_button">
//	        <property name="label">Goodbye World</property>
//	      </object>
//	    </child>
//	  </template>
//	</interface>
//
// Typically, you'll place the template fragment into a file that is bundled
// with your project, using GResource. In order to load the template,
// you need to call gtk.WidgetClass.SetTemplateFromResource() from the class
// initialization of your GtkWidget type:
//
//	static void
//	foo_widget_class_init (FooWidgetClass *klass)
//	{
//	  // ...
//
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	}
//
// You will also need to call gtk.Widget.InitTemplate() from the instance
// initialization function:
//
//	static void
//	foo_widget_init (FooWidget *self)
//	{
//	  // ...
//	  gtk_widget_init_template (GTK_WIDGET (self));
//	}
//
// You can access widgets defined in the template using the
// gtk_widget_get_template_child function, but you will typically
// declare a pointer in the instance private data structure of your
// type using the same name as the widget in the template definition,
// and call gtk.WidgetClass.BindTemplateChildFull() (or one of
// its wrapper macros gtk.WidgetClassBindTemplateChild() and
// gtk.WidgetClassBindTemplateChildPrivate()) with that name, e.g.
//
//	typedef struct {
//	  GtkWidget *hello_button;
//	  GtkWidget *goodbye_button;
//	} FooWidgetPrivate;
//
//	G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
//
//	static void
//	foo_widget_class_init (FooWidgetClass *klass)
//	{
//	  // ...
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	  gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//	                                                FooWidget, hello_button);
//	  gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
//	                                                FooWidget, goodbye_button);
//	}
//
//	static void
//	foo_widget_init (FooWidget *widget)
//	{
//
//	}
//
// You can also use gtk.WidgetClass.BindTemplateCallbackFull() (or is wrapper
// macro gtk.WidgetClassBindTemplateCallback()) to connect a signal callback
// defined in the template with a function visible in the scope of the class,
// e.g.
//
//	// the signal handler has the instance and user data swapped
//	// because of the swapped="yes" attribute in the template XML
//	static void
//	hello_button_clicked (FooWidget *self,
//	                      GtkButton *button)
//	{
//	  g_print ("Hello, world!\n");
//	}
//
//	static void
//	foo_widget_class_init (FooWidgetClass *klass)
//	{
//	  // ...
//	  gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//	                                               "/com/example/ui/foowidget.ui");
//	  gtk_widget_class_bind_template_callback (GTK_WIDGET_CLASS (klass), hello_button_clicked);
//	}.
type Widget struct {
	_ [0]func() // equal guard
	coreglib.InitiallyUnowned

	*coreglib.Object
	Accessible
	Buildable
	ConstraintTarget
}

var (
	_ coreglib.Objector = (*Widget)(nil)
)

// Widgetter describes types inherited from class Widget.
//
// To get the original type, the caller must assert this to an interface or
// another type.
type Widgetter interface {
	coreglib.Objector
	baseWidget() *Widget
}

var _ Widgetter = (*Widget)(nil)

func init() {
	coreglib.RegisterClassInfo[*Widget, *WidgetClass, WidgetOverrides](
		GTypeWidget,
		initWidgetClass,
		wrapWidget,
		defaultWidgetOverrides,
	)
}

func initWidgetClass(gclass unsafe.Pointer, overrides WidgetOverrides, classInitFunc func(*WidgetClass)) {
	pclass := (*C.GtkWidgetClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeWidget))))

	if overrides.Contains != nil {
		pclass.contains = (*[0]byte)(C._gotk4_gtk4_WidgetClass_contains)
	}

	if overrides.DirectionChanged != nil {
		pclass.direction_changed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_direction_changed)
	}

	if overrides.Focus != nil {
		pclass.focus = (*[0]byte)(C._gotk4_gtk4_WidgetClass_focus)
	}

	if overrides.RequestMode != nil {
		pclass.get_request_mode = (*[0]byte)(C._gotk4_gtk4_WidgetClass_get_request_mode)
	}

	if overrides.GrabFocus != nil {
		pclass.grab_focus = (*[0]byte)(C._gotk4_gtk4_WidgetClass_grab_focus)
	}

	if overrides.Hide != nil {
		pclass.hide = (*[0]byte)(C._gotk4_gtk4_WidgetClass_hide)
	}

	if overrides.KeynavFailed != nil {
		pclass.keynav_failed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_keynav_failed)
	}

	if overrides.Map != nil {
		pclass._map = (*[0]byte)(C._gotk4_gtk4_WidgetClass_map)
	}

	if overrides.Measure != nil {
		pclass.measure = (*[0]byte)(C._gotk4_gtk4_WidgetClass_measure)
	}

	if overrides.MnemonicActivate != nil {
		pclass.mnemonic_activate = (*[0]byte)(C._gotk4_gtk4_WidgetClass_mnemonic_activate)
	}

	if overrides.MoveFocus != nil {
		pclass.move_focus = (*[0]byte)(C._gotk4_gtk4_WidgetClass_move_focus)
	}

	if overrides.QueryTooltip != nil {
		pclass.query_tooltip = (*[0]byte)(C._gotk4_gtk4_WidgetClass_query_tooltip)
	}

	if overrides.Realize != nil {
		pclass.realize = (*[0]byte)(C._gotk4_gtk4_WidgetClass_realize)
	}

	if overrides.Root != nil {
		pclass.root = (*[0]byte)(C._gotk4_gtk4_WidgetClass_root)
	}

	if overrides.SetFocusChild != nil {
		pclass.set_focus_child = (*[0]byte)(C._gotk4_gtk4_WidgetClass_set_focus_child)
	}

	if overrides.Show != nil {
		pclass.show = (*[0]byte)(C._gotk4_gtk4_WidgetClass_show)
	}

	if overrides.SizeAllocate != nil {
		pclass.size_allocate = (*[0]byte)(C._gotk4_gtk4_WidgetClass_size_allocate)
	}

	if overrides.Snapshot != nil {
		pclass.snapshot = (*[0]byte)(C._gotk4_gtk4_WidgetClass_snapshot)
	}

	if overrides.StateFlagsChanged != nil {
		pclass.state_flags_changed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_state_flags_changed)
	}

	if overrides.SystemSettingChanged != nil {
		pclass.system_setting_changed = (*[0]byte)(C._gotk4_gtk4_WidgetClass_system_setting_changed)
	}

	if overrides.Unmap != nil {
		pclass.unmap = (*[0]byte)(C._gotk4_gtk4_WidgetClass_unmap)
	}

	if overrides.Unrealize != nil {
		pclass.unrealize = (*[0]byte)(C._gotk4_gtk4_WidgetClass_unrealize)
	}

	if overrides.Unroot != nil {
		pclass.unroot = (*[0]byte)(C._gotk4_gtk4_WidgetClass_unroot)
	}

	if classInitFunc != nil {
		class := (*WidgetClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWidget(obj *coreglib.Object) *Widget {
	return &Widget{
		InitiallyUnowned: coreglib.InitiallyUnowned{
			Object: obj,
		},
		Object: obj,
		Accessible: Accessible{
			Object: obj,
		},
		Buildable: Buildable{
			Object: obj,
		},
		ConstraintTarget: ConstraintTarget{
			Object: obj,
		},
	}
}

func marshalWidget(p uintptr) (interface{}, error) {
	return wrapWidget(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

func (widget *Widget) baseWidget() *Widget {
	return widget
}

// BaseWidget returns the underlying base object.
func BaseWidget(obj Widgetter) *Widget {
	return obj.baseWidget()
}

// ConnectDestroy signals that all holders of a reference to the widget should
// release the reference that they hold.
//
// May result in finalization of the widget if all references are released.
//
// This signal is not suitable for saving widget state.
func (widget *Widget) ConnectDestroy(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "destroy", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectDestroy), f)
}

// ConnectDirectionChanged is emitted when the text direction of a widget
// changes.
func (widget *Widget) ConnectDirectionChanged(f func(previousDirection TextDirection)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "direction-changed", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectDirectionChanged), f)
}

// ConnectHide is emitted when widget is hidden.
func (widget *Widget) ConnectHide(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "hide", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectHide), f)
}

// ConnectKeynavFailed is emitted if keyboard navigation fails.
//
// See gtk.Widget.KeynavFailed() for details.
func (widget *Widget) ConnectKeynavFailed(f func(direction DirectionType) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "keynav-failed", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectKeynavFailed), f)
}

// ConnectMap is emitted when widget is going to be mapped.
//
// A widget is mapped when the widget is visible (which is controlled with
// gtk.Widget:visible) and all its parents up to the toplevel widget are also
// visible.
//
// The ::map signal can be used to determine whether a widget will be drawn,
// for instance it can resume an animation that was stopped during the emission
// of gtk.Widget::unmap.
func (widget *Widget) ConnectMap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "map", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMap), f)
}

// ConnectMnemonicActivate is emitted when a widget is activated via a mnemonic.
//
// The default handler for this signal activates widget if group_cycling is
// FALSE, or just makes widget grab focus if group_cycling is TRUE.
func (widget *Widget) ConnectMnemonicActivate(f func(groupCycling bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "mnemonic-activate", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMnemonicActivate), f)
}

// ConnectMoveFocus is emitted when the focus is moved.
func (widget *Widget) ConnectMoveFocus(f func(direction DirectionType)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "move-focus", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectMoveFocus), f)
}

// ConnectQueryTooltip is emitted when the widgets tooltip is about to be shown.
//
// This happens when the gtk.Widget:has-tooltip property is TRUE and the hover
// timeout has expired with the cursor hovering "above" widget; or emitted when
// widget got focus in keyboard mode.
//
// Using the given coordinates, the signal handler should determine whether
// a tooltip should be shown for widget. If this is the case TRUE should be
// returned, FALSE otherwise. Note that if keyboard_mode is TRUE, the values of
// x and y are undefined and should not be used.
//
// The signal handler is free to manipulate tooltip with the therefore destined
// function calls.
func (widget *Widget) ConnectQueryTooltip(f func(x, y int, keyboardMode bool, tooltip *Tooltip) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "query-tooltip", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectQueryTooltip), f)
}

// ConnectRealize is emitted when widget is associated with a GdkSurface.
//
// This means that gtk.Widget.Realize() has been called or the widget has been
// mapped (that is, it is going to be drawn).
func (widget *Widget) ConnectRealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "realize", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectRealize), f)
}

// ConnectShow is emitted when widget is shown.
func (widget *Widget) ConnectShow(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "show", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectShow), f)
}

// ConnectStateFlagsChanged is emitted when the widget state changes.
//
// See gtk.Widget.GetStateFlags().
func (widget *Widget) ConnectStateFlagsChanged(f func(flags StateFlags)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "state-flags-changed", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectStateFlagsChanged), f)
}

// ConnectUnmap is emitted when widget is going to be unmapped.
//
// A widget is unmapped when either it or any of its parents up to the toplevel
// widget have been set as hidden.
//
// As ::unmap indicates that a widget will not be shown any longer, it can be
// used to, for example, stop an animation on the widget.
func (widget *Widget) ConnectUnmap(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unmap", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectUnmap), f)
}

// ConnectUnrealize is emitted when the GdkSurface associated with widget is
// destroyed.
//
// This means that gtk.Widget.Unrealize() has been called or the widget has been
// unmapped (that is, it is going to be hidden).
func (widget *Widget) ConnectUnrealize(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(widget, "unrealize", false, unsafe.Pointer(C._gotk4_gtk4_Widget_ConnectUnrealize), f)
}

// ActionSetEnabled: enable or disable an action installed with
// gtk_widget_class_install_action().
//
// The function takes the following parameters:
//
//   - actionName: action name, such as "clipboard.paste".
//   - enabled: whether the action is now enabled.
func (widget *Widget) ActionSetEnabled(actionName string, enabled bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _arg2 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	if enabled {
		_arg2 = C.TRUE
	}

	C.gtk_widget_action_set_enabled(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(enabled)
}

// Activate: for widgets that can be “activated” (buttons, menu items, etc.)
// this function activates them.
//
// The activation will emit the signal set using
// gtk_widget_class_set_activate_signal() during class initialization.
//
// Activation is what happens when you press Enter on a widget during key
// navigation.
//
// If you wish to handle the activation keybinding yourself, it is recommended
// to use gtk_widget_class_add_shortcut() with an action created with
// gtk_signal_action_new().
//
// If widget isn't activatable, the function returns FALSE.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget was activatable.
func (widget *Widget) Activate() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_activate(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateAction looks up the action in the action groups associated with
// widget and its ancestors, and activates it.
//
// If the action is in an action group added with
// gtk.Widget.InsertActionGroup(), the name is expected to be prefixed with the
// prefix that was used when the group was inserted.
//
// The arguments must match the actions expected parameter type, as returned by
// g_action_get_parameter_type().
//
// The function takes the following parameters:
//
//   - name of the action to activate.
//   - args (optional) parameters to use, or NULL.
//
// The function returns the following values:
//
//   - ok: TRUE if the action was activated, FALSE if the action does not exist.
func (widget *Widget) ActivateAction(name string, args *glib.Variant) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _arg2 *C.GVariant  // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if args != nil {
		_arg2 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(args)))
	}

	_cret = C.gtk_widget_activate_action_variant(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
	runtime.KeepAlive(args)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ActivateDefault activates the default.activate action from widget.
func (widget *Widget) ActivateDefault() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_activate_default(_arg0)
	runtime.KeepAlive(widget)
}

// AddController adds controller to widget so that it will receive events.
//
// You will usually want to call this function right after creating any kind of
// gtk.EventController.
//
// The function takes the following parameters:
//
//   - controller that hasn't been added to a widget yet.
func (widget *Widget) AddController(controller EventControllerer) {
	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GtkEventController // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))
	C.g_object_ref(C.gpointer(coreglib.InternObject(controller).Native()))

	C.gtk_widget_add_controller(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(controller)
}

// AddCSSClass adds a style class to widget.
//
// After calling this function, the widgets style will match for css_class,
// according to CSS matching rules.
//
// Use gtk.Widget.RemoveCSSClass() to remove the style again.
//
// The function takes the following parameters:
//
//   - cssClass: style class to add to widget, without the leading '.' used for
//     notation of style classes.
func (widget *Widget) AddCSSClass(cssClass string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(cssClass)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_add_css_class(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cssClass)
}

// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget.
//
// See gtk.Widget.ListMnemonicLabels(). Note the list of mnemonic labels for the
// widget is cleared when the widget is destroyed, so the caller must make sure
// to update its internal state at this point as well, by using a connection to
// the gtk.Widget::destroy signal or a weak notifier.
//
// The function takes the following parameters:
//
//   - label: GtkWidget that acts as a mnemonic label for widget.
func (widget *Widget) AddMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// AddTickCallback queues an animation frame update and adds a callback to be
// called before each frame.
//
// Until the tick callback is removed, it will be called frequently (usually
// at the frame rate of the output device or as quickly as the application
// can be repainted, whichever is slower). For this reason, is most suitable
// for handling graphics that change every frame or every few frames. The tick
// callback does not automatically imply a relayout or repaint. If you want a
// repaint or relayout, and aren’t changing widget properties that would trigger
// that (for example, changing the text of a Label), then you will have to call
// gtk.Widget.QueueResize() or gtk.Widget.QueueDraw() yourself.
//
// gdk.FrameClock.GetFrameTime() should generally be used for timing continuous
// animations and gdk.FrameTimings.GetPredictedPresentationTime() if you are
// trying to display isolated frames at particular times.
//
// This is a more convenient alternative to connecting directly to the
// gdk.FrameClock::update signal of GdkFrameClock, since you don't have to worry
// about when a GdkFrameClock is assigned to a widget.
//
// The function takes the following parameters:
//
//   - callback: function to call for updating animations.
//
// The function returns the following values:
//
//   - guint: id for the connection of this callback. Remove the
//     callback by passing the id returned from this function to
//     gtk.Widget.RemoveTickCallback().
func (widget *Widget) AddTickCallback(callback TickCallback) uint {
	var _arg0 *C.GtkWidget      // out
	var _arg1 C.GtkTickCallback // out
	var _arg2 C.gpointer
	var _arg3 C.GDestroyNotify
	var _cret C.guint // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TickCallback)
	_arg2 = C.gpointer(gbox.Assign(callback))
	_arg3 = (C.GDestroyNotify)((*[0]byte)(C.callbackDelete))

	_cret = C.gtk_widget_add_tick_callback(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(callback)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Allocate: this function is only used by GtkWidget subclasses, to assign a
// size, position and (optionally) baseline to their child widgets.
//
// In this function, the allocation and baseline may be adjusted. The given
// allocation will be forced to be bigger than the widget's minimum size,
// as well as at least 0×0 in size.
//
// For a version that does not take a transform, see gtk.Widget.SizeAllocate().
//
// The function takes the following parameters:
//
//   - width: new width of widget.
//   - height: new height of widget.
//   - baseline: new baseline of widget, or -1.
//   - transform (optional): transformation to be applied to widget.
func (widget *Widget) Allocate(width, height, baseline int, transform *gsk.Transform) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.int           // out
	var _arg2 C.int           // out
	var _arg3 C.int           // out
	var _arg4 *C.GskTransform // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)
	_arg3 = C.int(baseline)
	if transform != nil {
		_arg4 = (*C.GskTransform)(gextras.StructNative(unsafe.Pointer(transform)))
	}

	C.gtk_widget_allocate(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(baseline)
	runtime.KeepAlive(transform)
}

// ChildFocus: called by widgets as the user moves around the window using
// keyboard shortcuts.
//
// The direction argument indicates what kind of motion is taking place (up,
// down, left, right, tab forward, tab backward).
//
// This function calls the gtk.Widget.Focus() virtual function; widgets can
// override the virtual function in order to implement appropriate focus
// behavior.
//
// The default focus() virtual function for a widget should return TRUE if
// moving in direction left the focus on a focusable location inside that
// widget, and FALSE if moving in direction moved the focus outside the widget.
// When returning TRUE, widgets normallycall gtk.Widget.GrabFocus() to place the
// focus accordingly; when returning FALSE, they don’t modify the current focus
// location.
//
// This function is used by custom widget implementations; if you're writing
// an app, you’d use gtk.Widget.GrabFocus() to move the focus to a particular
// widget.
//
// The function takes the following parameters:
//
//   - direction of focus movement.
//
// The function returns the following values:
//
//   - ok: TRUE if focus ended up inside widget.
func (widget *Widget) ChildFocus(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_child_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ComputeBounds computes the bounds for widget in the coordinate space of
// target.
//
// FIXME: Explain what "bounds" are.
//
// If the operation is successful, TRUE is returned. If widget has no bounds or
// the bounds cannot be expressed in target's coordinate space (for example if
// both widgets are in different windows), FALSE is returned and bounds is set
// to the zero rectangle.
//
// It is valid for widget and target to be the same widget.
//
// The function takes the following parameters:
//
//   - target: GtkWidget.
//
// The function returns the following values:
//
//   - outBounds: rectangle taking the bounds.
//   - ok: TRUE if the bounds could be computed.
func (widget *Widget) ComputeBounds(target Widgetter) (*graphene.Rect, bool) {
	var _arg0 *C.GtkWidget      // out
	var _arg1 *C.GtkWidget      // out
	var _arg2 C.graphene_rect_t // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gtk_widget_compute_bounds(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(target)

	var _outBounds *graphene.Rect // out
	var _ok bool                  // out

	_outBounds = (*graphene.Rect)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _outBounds, _ok
}

// ComputeExpand computes whether a container should give this widget extra
// space when possible.
//
// Containers should check this, rather than looking at gtk.Widget.GetHExpand()
// or gtk.Widget.GetVExpand().
//
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not expanded.
//
// The computed expand value uses either the expand setting explicitly set on
// the widget itself, or, if none has been explicitly set, the widget may expand
// if some of its children do.
//
// The function takes the following parameters:
//
//   - orientation: expand direction.
//
// The function returns the following values:
//
//   - ok: whether widget tree rooted here should be expanded.
func (widget *Widget) ComputeExpand(orientation Orientation) bool {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_widget_compute_expand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ComputePoint translates the given point in widget's coordinates to
// coordinates relative to target’s coordinate system.
//
// In order to perform this operation, both widgets must share a common
// ancestor.
//
// The function takes the following parameters:
//
//   - target: GtkWidget to transform into.
//   - point in widget's coordinate system.
//
// The function returns the following values:
//
//   - outPoint: set to the corresponding coordinates in target's coordinate
//     system.
//   - ok: TRUE if the point could be determined, FALSE on failure. In this
//     case, 0 is stored in out_point.
func (widget *Widget) ComputePoint(target Widgetter, point *graphene.Point) (*graphene.Point, bool) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 *C.graphene_point_t // out
	var _arg3 C.graphene_point_t  // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(target).Native()))
	_arg2 = (*C.graphene_point_t)(gextras.StructNative(unsafe.Pointer(point)))

	_cret = C.gtk_widget_compute_point(_arg0, _arg1, _arg2, &_arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(target)
	runtime.KeepAlive(point)

	var _outPoint *graphene.Point // out
	var _ok bool                  // out

	_outPoint = (*graphene.Point)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	if _cret != 0 {
		_ok = true
	}

	return _outPoint, _ok
}

// ComputeTransform computes a matrix suitable to describe a transformation from
// widget's coordinate system into target's coordinate system.
//
// The function takes the following parameters:
//
//   - target widget that the matrix will transform to.
//
// The function returns the following values:
//
//   - outTransform: location to store the final transformation.
//   - ok: TRUE if the transform could be computed, FALSE otherwise. The
//     transform can not be computed in certain cases, for example when widget
//     and target do not share a common ancestor. In that case out_transform
//     gets set to the identity matrix.
func (widget *Widget) ComputeTransform(target Widgetter) (*graphene.Matrix, bool) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkWidget        // out
	var _arg2 C.graphene_matrix_t // in
	var _cret C.gboolean          // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(target).Native()))

	_cret = C.gtk_widget_compute_transform(_arg0, _arg1, &_arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(target)

	var _outTransform *graphene.Matrix // out
	var _ok bool                       // out

	_outTransform = (*graphene.Matrix)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _outTransform, _ok
}

// Contains tests if the point at (x, y) is contained in widget.
//
// The coordinates for (x, y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of widget's content area.
//
// The function takes the following parameters:
//
//   - x: x coordinate to test, relative to widget's origin.
//   - y: y coordinate to test, relative to widget's origin.
//
// The function returns the following values:
//
//   - ok: TRUE if widget contains (x, y).
func (widget *Widget) Contains(x, y float64) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(x)
	_arg2 = C.double(y)

	_cret = C.gtk_widget_contains(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CreatePangoContext creates a new PangoContext with the appropriate font map,
// font options, font description, and base direction for drawing text for this
// widget.
//
// See also gtk.Widget.GetPangoContext().
//
// The function returns the following values:
//
//   - context: new PangoContext.
func (widget *Widget) CreatePangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_create_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// CreatePangoLayout creates a new PangoLayout with the appropriate font map,
// font description, and base direction for drawing text for this widget.
//
// If you keep a PangoLayout created in this way around, you need to re-create
// it when the widget PangoContext is replaced. This can be tracked by listening
// to changes of the gtk.Widget:root property on the widget.
//
// The function takes the following parameters:
//
//   - text (optional) to set on the layout (can be NULL).
//
// The function returns the following values:
//
//   - layout: new PangoLayout.
func (widget *Widget) CreatePangoLayout(text string) *pango.Layout {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.char        // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)

	var _layout *pango.Layout // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_layout = &pango.Layout{
			Object: obj,
		}
	}

	return _layout
}

// DragCheckThreshold checks to see if a drag movement has passed the GTK drag
// threshold.
//
// The function takes the following parameters:
//
//   - startX: x coordinate of start of drag.
//   - startY: y coordinate of start of drag.
//   - currentX: current X coordinate.
//   - currentY: current Y coordinate.
//
// The function returns the following values:
//
//   - ok: TRUE if the drag threshold has been passed.
func (widget *Widget) DragCheckThreshold(startX, startY, currentX, currentY int) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out
	var _arg4 C.int        // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(startX)
	_arg2 = C.int(startY)
	_arg3 = C.int(currentX)
	_arg4 = C.int(currentY)

	_cret = C.gtk_drag_check_threshold(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(startX)
	runtime.KeepAlive(startY)
	runtime.KeepAlive(currentX)
	runtime.KeepAlive(currentY)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ErrorBell notifies the user about an input-related error on this widget.
//
// If the gtk.Settings:gtk-error-bell setting is TRUE, it calls
// gdk.Surface.Beep(), otherwise it does nothing.
//
// Note that the effect of gdk.Surface.Beep() can be configured in many ways,
// depending on the windowing backend and the desktop environment or window
// manager that is used.
func (widget *Widget) ErrorBell() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_error_bell(_arg0)
	runtime.KeepAlive(widget)
}

// AllocatedBaseline returns the baseline that has currently been allocated to
// widget.
//
// This function is intended to be used when implementing handlers for the
// GtkWidgetClass.snapshot() function, and when allocating child widgets in
// GtkWidgetClass.size_allocate().
//
// The function returns the following values:
//
//   - gint: baseline of the widget, or -1 if none.
func (widget *Widget) AllocatedBaseline() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_baseline(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AllocatedHeight returns the height that has currently been allocated to
// widget.
//
// The function returns the following values:
//
//   - gint: height of the widget.
func (widget *Widget) AllocatedHeight() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_height(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// AllocatedWidth returns the width that has currently been allocated to widget.
//
// The function returns the following values:
//
//   - gint: width of the widget.
func (widget *Widget) AllocatedWidth() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_allocated_width(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Allocation retrieves the widget’s allocation.
//
// Note, when implementing a layout container: a widget’s allocation will be
// its “adjusted” allocation, that is, the widget’s parent typically calls
// gtk.Widget.SizeAllocate() with an allocation, and that allocation is then
// adjusted (to handle margin and alignment for example) before assignment to
// the widget. gtk.Widget.GetAllocation() returns the adjusted allocation that
// was actually assigned to the widget. The adjusted allocation is guaranteed
// to be completely contained within the gtk.Widget.SizeAllocate() allocation,
// however.
//
// So a layout container is guaranteed that its children stay inside the
// assigned bounds, but not that they have exactly the bounds the container
// assigned.
//
// The function returns the following values:
//
//   - allocation: pointer to a GtkAllocation to copy to.
func (widget *Widget) Allocation() *Allocation {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkAllocation // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_allocation(_arg0, &_arg1)
	runtime.KeepAlive(widget)

	var _allocation *Allocation // out

	_allocation = (*gdk.Rectangle)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	type _ = *Allocation
	type _ = *gdk.Rectangle

	return _allocation
}

// Ancestor gets the first ancestor of widget with type widget_type.
//
// For example, gtk_widget_get_ancestor (widget, GTK_TYPE_BOX) gets the first
// GtkBox that’s an ancestor of widget. No reference will be added to the
// returned widget; it should not be unreferenced.
//
// Note that unlike gtk.Widget.IsAncestor(), this function considers widget to
// be an ancestor of itself.
//
// The function takes the following parameters:
//
//   - widgetType: ancestor type.
//
// The function returns the following values:
//
//   - ret (optional): ancestor widget, or NULL if not found.
func (widget *Widget) Ancestor(widgetType coreglib.Type) Widgetter {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)

	_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// CanFocus determines whether the input focus can enter widget or any of its
// children.
//
// See gtk.Widget.SetFocusable().
//
// The function returns the following values:
//
//   - ok: TRUE if the input focus can enter widget, FALSE otherwise.
func (widget *Widget) CanFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanTarget queries whether widget can be the target of pointer events.
//
// The function returns the following values:
//
//   - ok: TRUE if widget can receive pointer events.
func (widget *Widget) CanTarget() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_can_target(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ChildVisible gets the value set with gtk_widget_set_child_visible().
//
// If you feel a need to use this function, your code probably needs
// reorganization.
//
// This function is only useful for container implementations and should never
// be called by an application.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget is mapped with the parent.
func (widget *Widget) ChildVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_child_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Clipboard gets the clipboard object for widget.
//
// This is a utility function to get the clipboard object for the GdkDisplay
// that widget is using.
//
// Note that this function always works, even when widget is not realized yet.
//
// The function returns the following values:
//
//   - clipboard: appropriate clipboard object.
func (widget *Widget) Clipboard() *gdk.Clipboard {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_clipboard(_arg0)
	runtime.KeepAlive(widget)

	var _clipboard *gdk.Clipboard // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_clipboard = &gdk.Clipboard{
			Object: obj,
		}
	}

	return _clipboard
}

// CSSClasses returns the list of style classes applied to widget.
//
// The function returns the following values:
//
//   - utf8s: NULL-terminated list of css classes currently applied to widget.
//     The returned list can be freed using g_strfreev().
func (widget *Widget) CSSClasses() []string {
	var _arg0 *C.GtkWidget // out
	var _cret **C.char     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_css_classes(_arg0)
	runtime.KeepAlive(widget)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// CSSName returns the CSS name that is used for self.
//
// The function returns the following values:
//
//   - utf8: CSS name.
func (self *Widget) CSSName() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_widget_get_css_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Cursor queries the cursor set on widget.
//
// See gtk.Widget.SetCursor() for details.
//
// The function returns the following values:
//
//   - cursor (optional): cursor currently in use or NULL to use the default.
func (widget *Widget) Cursor() *gdk.Cursor {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GdkCursor // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_cursor(_arg0)
	runtime.KeepAlive(widget)

	var _cursor *gdk.Cursor // out

	if _cret != nil {
		{
			obj := coreglib.Take(unsafe.Pointer(_cret))
			_cursor = &gdk.Cursor{
				Object: obj,
			}
		}
	}

	return _cursor
}

// Direction gets the reading direction for a particular widget.
//
// See gtk.Widget.SetDirection().
//
// The function returns the following values:
//
//   - textDirection: reading direction for the widget.
func (widget *Widget) Direction() TextDirection {
	var _arg0 *C.GtkWidget       // out
	var _cret C.GtkTextDirection // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_direction(_arg0)
	runtime.KeepAlive(widget)

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// Display: get the GdkDisplay for the toplevel window associated with this
// widget.
//
// This function can only be called after the widget has been added to a widget
// hierarchy with a GtkWindow at the top.
//
// In general, you should only create display specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
//
// The function returns the following values:
//
//   - display: GdkDisplay for the toplevel for this widget.
func (widget *Widget) Display() *gdk.Display {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GdkDisplay // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_display(_arg0)
	runtime.KeepAlive(widget)

	var _display *gdk.Display // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_display = &gdk.Display{
			Object: obj,
		}
	}

	return _display
}

// FirstChild returns the widgets first child.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//   - ret (optional) widget's first child.
func (widget *Widget) FirstChild() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_first_child(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// FocusChild returns the current focus child of widget.
//
// The function returns the following values:
//
//   - ret (optional): current focus child of widget, or NULL in case the focus
//     child is unset.
func (widget *Widget) FocusChild() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_focus_child(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// FocusOnClick returns whether the widget should grab focus when it is clicked
// with the mouse.
//
// See gtk.Widget.SetFocusOnClick().
//
// The function returns the following values:
//
//   - ok: TRUE if the widget should grab focus when it is clicked with the
//     mouse.
func (widget *Widget) FocusOnClick() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_focus_on_click(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Focusable determines whether widget can own the input focus.
//
// See gtk.Widget.SetFocusable().
//
// The function returns the following values:
//
//   - ok: TRUE if widget can own the input focus, FALSE otherwise.
func (widget *Widget) Focusable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_focusable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FontMap gets the font map of widget.
//
// See gtk.Widget.SetFontMap().
//
// The function returns the following values:
//
//   - fontMap (optional): PangoFontMap, or NULL.
func (widget *Widget) FontMap() pango.FontMapper {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_font_map(_arg0)
	runtime.KeepAlive(widget)

	var _fontMap pango.FontMapper // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(pango.FontMapper)
				return ok
			})
			rv, ok := casted.(pango.FontMapper)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching pango.FontMapper")
			}
			_fontMap = rv
		}
	}

	return _fontMap
}

// FontOptions returns the cairo_font_options_t used for Pango rendering.
//
// When not set, the defaults font options for the GdkDisplay will be used.
//
// The function returns the following values:
//
//   - fontOptions (optional): cairo_font_options_t or NULL if not set.
func (widget *Widget) FontOptions() *cairo.FontOptions {
	var _arg0 *C.GtkWidget            // out
	var _cret *C.cairo_font_options_t // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_font_options(_arg0)
	runtime.KeepAlive(widget)

	var _fontOptions *cairo.FontOptions // out

	if _cret != nil {
		_fontOptions = (*cairo.FontOptions)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	}

	return _fontOptions
}

// FrameClock obtains the frame clock for a widget.
//
// The frame clock is a global “ticker” that can be used to drive animations
// and repaints. The most common reason to get the frame clock is to call
// gdk.FrameClock.GetFrameTime(), in order to get a time to use for animating.
// For example you might record the start of the animation with an initial value
// from gdk.FrameClock.GetFrameTime(), and then update the animation by calling
// gdk.FrameClock.GetFrameTime() again during each repaint.
//
// gdk.FrameClock.RequestPhase() will result in a new frame on the clock,
// but won’t necessarily repaint any widgets. To repaint a widget, you have to
// use gtk.Widget.QueueDraw() which invalidates the widget (thus scheduling it
// to receive a draw on the next frame). gtk_widget_queue_draw() will also end
// up requesting a frame on the appropriate frame clock.
//
// A widget’s frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widget’s frame clock.
//
// Unrealized widgets do not have a frame clock.
//
// The function returns the following values:
//
//   - frameClock (optional): GdkFrameClock, or NULL if widget is unrealized.
func (widget *Widget) FrameClock() gdk.FrameClocker {
	var _arg0 *C.GtkWidget     // out
	var _cret *C.GdkFrameClock // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_frame_clock(_arg0)
	runtime.KeepAlive(widget)

	var _frameClock gdk.FrameClocker // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(gdk.FrameClocker)
				return ok
			})
			rv, ok := casted.(gdk.FrameClocker)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gdk.FrameClocker")
			}
			_frameClock = rv
		}
	}

	return _frameClock
}

// HAlign gets the horizontal alignment of widget.
//
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
//
// The function returns the following values:
//
//   - align: horizontal alignment of widget.
func (widget *Widget) HAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_halign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// HasTooltip returns the current value of the has-tooltip property.
//
// The function returns the following values:
//
//   - ok: current value of has-tooltip on widget.
func (widget *Widget) HasTooltip() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_has_tooltip(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Height returns the content height of the widget.
//
// This function returns the size passed to its size-allocate implementation,
// which is the size you should be using in GtkWidgetClass.snapshot().
//
// For pointer events, see gtk.Widget.Contains().
//
// The function returns the following values:
//
//   - gint: height of widget.
func (widget *Widget) Height() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_height(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// HExpand gets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a GtkWindow, widgets with expand=TRUE generally receive
// the extra space. For example, a list or scrollable area or document in your
// window would often be set to expand.
//
// Containers should use gtk.Widget.ComputeExpand() rather than this function,
// to see whether a widget, or any of its children, has the expand flag set.
// If any child of a widget wants to expand, the parent may ask to expand also.
//
// This function only looks at the widget’s own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
//
// The function returns the following values:
//
//   - ok: whether hexpand flag is set.
func (widget *Widget) HExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HExpandSet gets whether gtk_widget_set_hexpand() has been used to explicitly
// set the expand flag on this widget.
//
// If gtk.Widget:hexpand property is set, then it overrides any computed expand
// value based on child widgets. If hexpand is not set, then the expand value
// depends on whether any children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function returns the following values:
//
//   - ok: whether hexpand has been explicitly set.
func (widget *Widget) HExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_hexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LastChild returns the widgets last child.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//   - ret (optional) widget's last child.
func (widget *Widget) LastChild() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_last_child(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// LayoutManager retrieves the layout manager used by widget
//
// See gtk.Widget.SetLayoutManager().
//
// The function returns the following values:
//
//   - layoutManager (optional): GtkLayoutManager.
func (widget *Widget) LayoutManager() LayoutManagerer {
	var _arg0 *C.GtkWidget        // out
	var _cret *C.GtkLayoutManager // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_layout_manager(_arg0)
	runtime.KeepAlive(widget)

	var _layoutManager LayoutManagerer // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(LayoutManagerer)
				return ok
			})
			rv, ok := casted.(LayoutManagerer)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.LayoutManagerer")
			}
			_layoutManager = rv
		}
	}

	return _layoutManager
}

// Mapped: whether the widget is mapped.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget is mapped, FALSE otherwise.
func (widget *Widget) Mapped() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_mapped(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MarginBottom gets the bottom margin of widget.
//
// The function returns the following values:
//
//   - gint: bottom margin of widget.
func (widget *Widget) MarginBottom() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_bottom(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginEnd gets the end margin of widget.
//
// The function returns the following values:
//
//   - gint: end margin of widget.
func (widget *Widget) MarginEnd() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_end(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginStart gets the start margin of widget.
//
// The function returns the following values:
//
//   - gint: start margin of widget.
func (widget *Widget) MarginStart() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_start(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// MarginTop gets the top margin of widget.
//
// The function returns the following values:
//
//   - gint: top margin of widget.
func (widget *Widget) MarginTop() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_margin_top(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Name retrieves the name of a widget.
//
// See gtk.Widget.SetName() for the significance of widget names.
//
// The function returns the following values:
//
//   - utf8: name of the widget. This string is owned by GTK and should not be
//     modified or freed.
func (widget *Widget) Name() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_name(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Native returns the GtkNative widget that contains widget.
//
// This function will return NULL if the widget is not contained inside a widget
// tree with a native ancestor.
//
// GtkNative widgets will return themselves here.
//
// The function returns the following values:
//
//   - native (optional): GtkNative widget of widget, or NULL.
func (widget *Widget) Native() *NativeSurface {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkNative // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_native(_arg0)
	runtime.KeepAlive(widget)

	var _native *NativeSurface // out

	if _cret != nil {
		_native = wrapNativeSurface(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _native
}

// NextSibling returns the widgets next sibling.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//   - ret (optional) widget's next sibling.
func (widget *Widget) NextSibling() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_next_sibling(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// Opacity the requested opacity for this widget.
//
// See gtk.Widget.SetOpacity().
//
// The function returns the following values:
//
//   - gdouble: requested opacity for this widget.
func (widget *Widget) Opacity() float64 {
	var _arg0 *C.GtkWidget // out
	var _cret C.double     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_opacity(_arg0)
	runtime.KeepAlive(widget)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Overflow returns the widgets overflow value.
//
// The function returns the following values:
//
//   - overflow widget's overflow.
func (widget *Widget) Overflow() Overflow {
	var _arg0 *C.GtkWidget  // out
	var _cret C.GtkOverflow // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_overflow(_arg0)
	runtime.KeepAlive(widget)

	var _overflow Overflow // out

	_overflow = Overflow(_cret)

	return _overflow
}

// PangoContext gets a PangoContext with the appropriate font map, font
// description, and base direction for this widget.
//
// Unlike the context returned by gtk.Widget.CreatePangoContext(), this context
// is owned by the widget (it can be used until the screen for the widget
// changes or the widget is removed from its toplevel), and will be updated
// to match any changes to the widget’s attributes. This can be tracked by
// listening to changes of the gtk.Widget:root property on the widget.
//
// The function returns the following values:
//
//   - context: PangoContext for the widget.
func (widget *Widget) PangoContext() *pango.Context {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_pango_context(_arg0)
	runtime.KeepAlive(widget)

	var _context *pango.Context // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_context = &pango.Context{
			Object: obj,
		}
	}

	return _context
}

// Parent returns the parent widget of widget.
//
// The function returns the following values:
//
//   - ret (optional): parent widget of widget, or NULL.
func (widget *Widget) Parent() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_parent(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// PreferredSize retrieves the minimum and natural size of a widget, taking into
// account the widget’s preference for height-for-width management.
//
// This is used to retrieve a suitable size by container widgets which do not
// impose any restrictions on the child placement. It can be used to deduce
// toplevel window and menu sizes as well as child widgets in free-form
// containers such as GtkFixed.
//
// Handle with care. Note that the natural height of a height-for-width widget
// will generally be a smaller size than the minimum height, since the required
// height for the natural width is generally smaller than the required height
// for the minimum width.
//
// Use gtk_widget_measure if you want to support baseline alignment.
//
// The function returns the following values:
//
//   - minimumSize (optional): location for storing the minimum size, or NULL.
//   - naturalSize (optional): location for storing the natural size, or NULL.
func (widget *Widget) PreferredSize() (minimumSize, naturalSize *Requisition) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkRequisition // in
	var _arg2 C.GtkRequisition // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_preferred_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _minimumSize *Requisition // out
	var _naturalSize *Requisition // out

	_minimumSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_naturalSize = (*Requisition)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _minimumSize, _naturalSize
}

// PrevSibling returns the widgets previous sibling.
//
// This API is primarily meant for widget implementations.
//
// The function returns the following values:
//
//   - ret (optional) widget's previous sibling.
func (widget *Widget) PrevSibling() Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_prev_sibling(_arg0)
	runtime.KeepAlive(widget)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// PrimaryClipboard gets the primary clipboard of widget.
//
// This is a utility function to get the primary clipboard object for the
// GdkDisplay that widget is using.
//
// Note that this function always works, even when widget is not realized yet.
//
// The function returns the following values:
//
//   - clipboard: appropriate clipboard object.
func (widget *Widget) PrimaryClipboard() *gdk.Clipboard {
	var _arg0 *C.GtkWidget    // out
	var _cret *C.GdkClipboard // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_primary_clipboard(_arg0)
	runtime.KeepAlive(widget)

	var _clipboard *gdk.Clipboard // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_clipboard = &gdk.Clipboard{
			Object: obj,
		}
	}

	return _clipboard
}

// Realized determines whether widget is realized.
//
// The function returns the following values:
//
//   - ok: TRUE if widget is realized, FALSE otherwise.
func (widget *Widget) Realized() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_realized(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ReceivesDefault determines whether widget is always treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// See gtk.Widget.SetReceivesDefault().
//
// The function returns the following values:
//
//   - ok: TRUE if widget acts as the default widget when focused, FALSE
//     otherwise.
func (widget *Widget) ReceivesDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_receives_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RequestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Single-child widgets generally propagate the preference of their child,
// more complex widgets need to request something either in context of their
// children or in context of their allocation capabilities.
//
// The function returns the following values:
//
//   - sizeRequestMode: GtkSizeRequestMode preferred by widget.
func (widget *Widget) RequestMode() SizeRequestMode {
	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_request_mode(_arg0)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// Root returns the GtkRoot widget of widget.
//
// This function will return NULL if the widget is not contained inside a widget
// tree with a root widget.
//
// GtkRoot widgets will return themselves here.
//
// The function returns the following values:
//
//   - root (optional) widget of widget, or NULL.
func (widget *Widget) Root() *Root {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GtkRoot   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_root(_arg0)
	runtime.KeepAlive(widget)

	var _root *Root // out

	if _cret != nil {
		_root = wrapRoot(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _root
}

// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels.
//
// On traditional systems this is 1, on high density outputs, it can be a higher
// value (typically 2).
//
// See gdk.Surface.GetScaleFactor().
//
// The function returns the following values:
//
//   - gint: scale factor for widget.
func (widget *Widget) ScaleFactor() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_scale_factor(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Sensitive returns the widget’s sensitivity.
//
// This function returns the value that has been set using
// gtk.Widget.SetSensitive()).
//
// The effective sensitivity of a widget is however determined by both its own
// and its parent widget’s sensitivity. See gtk.Widget.IsSensitive().
//
// The function returns the following values:
//
//   - ok: TRUE if the widget is sensitive.
func (widget *Widget) Sensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Settings gets the settings object holding the settings used for this widget.
//
// Note that this function can only be called when the GtkWidget is attached to
// a toplevel, since the settings object is specific to a particular GdkDisplay.
// If you want to monitor the widget for changes in its settings, connect to
// notify::display.
//
// The function returns the following values:
//
//   - settings: relevant Settings object.
func (widget *Widget) Settings() *Settings {
	var _arg0 *C.GtkWidget   // out
	var _cret *C.GtkSettings // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_settings(_arg0)
	runtime.KeepAlive(widget)

	var _settings *Settings // out

	_settings = wrapSettings(coreglib.Take(unsafe.Pointer(_cret)))

	return _settings
}

// Size returns the content width or height of the widget.
//
// Which dimension is returned depends on orientation.
//
// This is equivalent to calling gtk.Widget.GetWidth() for
// GTK_ORIENTATION_HORIZONTAL or gtk.Widget.GetHeight() for
// GTK_ORIENTATION_VERTICAL, but can be used when writing
// orientation-independent code, such as when implementing gtk.Orientable
// widgets.
//
// The function takes the following parameters:
//
//   - orientation to query.
//
// The function returns the following values:
//
//   - gint: size of widget in orientation.
func (widget *Widget) Size(orientation Orientation) int {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _cret C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)

	_cret = C.gtk_widget_get_size(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// SizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request().
//
// A value of -1 stored in width or height indicates that that dimension has
// not been set explicitly and the natural requisition of the widget will be
// used instead. See gtk.Widget.SetSizeRequest(). To get the size a widget will
// actually request, call gtk.Widget.Measure() instead of this function.
//
// The function returns the following values:
//
//   - width (optional): return location for width, or NULL.
//   - height (optional): return location for height, or NULL.
func (widget *Widget) SizeRequest() (width, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(widget)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// StateFlags returns the widget state as a flag set.
//
// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE state
// will be returned, that is, also based on parent insensitivity, even if widget
// itself is sensitive.
//
// Also note that if you are looking for a way to obtain the
// gtk.StateFlags to pass to a gtk.StyleContext method, you should look at
// gtk.StyleContext.GetState().
//
// The function returns the following values:
//
//   - stateFlags: state flags for widget.
func (widget *Widget) StateFlags() StateFlags {
	var _arg0 *C.GtkWidget    // out
	var _cret C.GtkStateFlags // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_state_flags(_arg0)
	runtime.KeepAlive(widget)

	var _stateFlags StateFlags // out

	_stateFlags = StateFlags(_cret)

	return _stateFlags
}

// StyleContext returns the style context associated to widget.
//
// The returned object is guaranteed to be the same for the lifetime of widget.
//
// The function returns the following values:
//
//   - styleContext: GtkStyleContext. This memory is owned by widget and must
//     not be freed.
func (widget *Widget) StyleContext() *StyleContext {
	var _arg0 *C.GtkWidget       // out
	var _cret *C.GtkStyleContext // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_style_context(_arg0)
	runtime.KeepAlive(widget)

	var _styleContext *StyleContext // out

	_styleContext = wrapStyleContext(coreglib.Take(unsafe.Pointer(_cret)))

	return _styleContext
}

// TemplateChild: fetch an object build from the template XML for widget_type in
// this widget instance.
//
// This will only report children which were previously declared with
// gtk.WidgetClass.BindTemplateChildFull() or one of its variants.
//
// This function is only meant to be called for code which is private to the
// widget_type which declared the child and is meant for language bindings which
// cannot easily make use of the GObject structure offsets.
//
// The function takes the following parameters:
//
//   - widgetType to get a template child for.
//   - name: “id” of the child defined in the template XML.
//
// The function returns the following values:
//
//   - object built in the template XML with the id name.
func (widget *Widget) TemplateChild(widgetType coreglib.Type, name string) *coreglib.Object {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GType      // out
	var _arg2 *C.char      // out
	var _cret *C.GObject   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GType(widgetType)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(widgetType)
	runtime.KeepAlive(name)

	var _object *coreglib.Object // out

	_object = coreglib.Take(unsafe.Pointer(_cret))

	return _object
}

// TooltipMarkup gets the contents of the tooltip for widget.
//
// If the tooltip has not been set using gtk.Widget.SetTooltipMarkup(), this
// function returns NULL.
//
// The function returns the following values:
//
//   - utf8 (optional): tooltip text.
func (widget *Widget) TooltipMarkup() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_markup(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// TooltipText gets the contents of the tooltip for widget.
//
// If the widget's tooltip was set using gtk.Widget.SetTooltipMarkup(), this
// function will return the escaped text.
//
// The function returns the following values:
//
//   - utf8 (optional): tooltip text.
func (widget *Widget) TooltipText() string {
	var _arg0 *C.GtkWidget // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_tooltip_text(_arg0)
	runtime.KeepAlive(widget)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// VAlign gets the vertical alignment of widget.
//
// The function returns the following values:
//
//   - align: vertical alignment of widget.
func (widget *Widget) VAlign() Align {
	var _arg0 *C.GtkWidget // out
	var _cret C.GtkAlign   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_valign(_arg0)
	runtime.KeepAlive(widget)

	var _align Align // out

	_align = Align(_cret)

	return _align
}

// VExpand gets whether the widget would like any available extra vertical
// space.
//
// See gtk.Widget.GetHExpand() for more detail.
//
// The function returns the following values:
//
//   - ok: whether vexpand flag is set.
func (widget *Widget) VExpand() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// VExpandSet gets whether gtk_widget_set_vexpand() has been used to explicitly
// set the expand flag on this widget.
//
// See gtk.Widget.GetHExpandSet() for more detail.
//
// The function returns the following values:
//
//   - ok: whether vexpand has been explicitly set.
func (widget *Widget) VExpandSet() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_vexpand_set(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visible determines whether the widget is visible.
//
// If you want to take into account whether the widget’s parent is also marked
// as visible, use gtk.Widget.IsVisible() instead.
//
// This function does not check if the widget is obscured in any way.
//
// See gtk.Widget.SetVisible().
//
// The function returns the following values:
//
//   - ok: TRUE if the widget is visible.
func (widget *Widget) Visible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Width returns the content width of the widget.
//
// This function returns the size passed to its size-allocate implementation,
// which is the size you should be using in GtkWidgetClass.snapshot().
//
// For pointer events, see gtk.Widget.Contains().
//
// The function returns the following values:
//
//   - gint: width of widget.
func (widget *Widget) Width() int {
	var _arg0 *C.GtkWidget // out
	var _cret C.int        // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_get_width(_arg0)
	runtime.KeepAlive(widget)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// GrabFocus causes widget to have the keyboard focus for the GtkWindow it's
// inside.
//
// If widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of widget that is focusable, it will not
// take focus and FALSE will be returned.
//
// Calling gtk.Widget.GrabFocus() on an already focused widget is allowed,
// should not have an effect, and return TRUE.
//
// The function returns the following values:
//
//   - ok: TRUE if focus is now inside widget.
func (widget *Widget) GrabFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_grab_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasCSSClass returns whether css_class is currently applied to widget.
//
// The function takes the following parameters:
//
//   - cssClass: style class, without the leading '.' used for notation of style
//     classes.
//
// The function returns the following values:
//
//   - ok: TRUE if css_class is currently applied to widget, FALSE otherwise.
func (widget *Widget) HasCSSClass(cssClass string) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(cssClass)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_widget_has_css_class(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cssClass)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasDefault determines whether widget is the current default widget within its
// toplevel.
//
// The function returns the following values:
//
//   - ok: TRUE if widget is the current default widget within its toplevel,
//     FALSE otherwise.
func (widget *Widget) HasDefault() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_default(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasFocus determines if the widget has the global input focus.
//
// See gtk.Widget.IsFocus() for the difference between having the global input
// focus, and only having the focus within a toplevel.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget has the global input focus.
func (widget *Widget) HasFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus.
//
// This is a convenience function that takes into account whether focus
// indication should currently be shown in the toplevel window of widget.
// See gtk.Window.GetFocusVisible() for more information about focus indication.
//
// To find out if the widget has the global input focus, use
// gtk.Widget.HasFocus().
//
// The function returns the following values:
//
//   - ok: TRUE if the widget should display a “focus rectangle”.
func (widget *Widget) HasVisibleFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_has_visible_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide reverses the effects of gtk_widget_show().
//
// This is causing the widget to be hidden (invisible to the user).
func (widget *Widget) Hide() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_hide(_arg0)
	runtime.KeepAlive(widget)
}

// InDestruction returns whether the widget is currently being destroyed.
//
// This information can sometimes be used to avoid doing unnecessary work.
//
// The function returns the following values:
//
//   - ok: TRUE if widget is being destroyed.
func (widget *Widget) InDestruction() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_in_destruction(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InitTemplate creates and initializes child widgets defined in templates.
//
// This function must be called in the instance initializer for any class which
// assigned itself a template using gtk.WidgetClass.SetTemplate().
//
// It is important to call this function in the instance initializer of a
// GtkWidget subclass and not in GObject.constructed() or GObject.constructor()
// for two reasons:
//
//   - derived widgets will assume that the composite widgets defined by its
//     parent classes have been created in their relative instance initializers
//   - when calling g_object_new() on a widget with composite templates, it’s
//     important to build the composite widgets before the construct properties
//     are set. Properties passed to g_object_new() should take precedence over
//     properties set in the private template XML
//
// A good rule of thumb is to call this function as the first thing in an
// instance initialization function.
func (widget *Widget) InitTemplate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_init_template(_arg0)
	runtime.KeepAlive(widget)
}

// InsertActionGroup inserts group into widget.
//
// Children of widget that implement gtk.Actionable can then be associated with
// actions in group by setting their “action-name” to prefix.action-name.
//
// Note that inheritance is defined for individual actions. I.e. even if you
// insert a group with prefix prefix, actions with the same prefix will still be
// inherited from the parent, unless the group contains an action with the same
// name.
//
// If group is NULL, a previously inserted group for name is removed from
// widget.
//
// The function takes the following parameters:
//
//   - name: prefix for actions in group.
//   - group (optional) or NULL.
func (widget *Widget) InsertActionGroup(name string, group gio.ActionGrouper) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.char         // out
	var _arg2 *C.GActionGroup // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if group != nil {
		_arg2 = (*C.GActionGroup)(unsafe.Pointer(coreglib.InternObject(group).Native()))
	}

	C.gtk_widget_insert_action_group(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
	runtime.KeepAlive(group)
}

// InsertAfter inserts widget into the child widget list of parent.
//
// It will be placed after previous_sibling, or at the beginning if
// previous_sibling is NULL.
//
// After calling this function, gtk_widget_get_prev_sibling(widget) will return
// previous_sibling.
//
// If parent is already set as the parent widget of widget, this function can
// also be used to reorder widget in the child widget list of parent.
//
// This API is primarily meant for widget implementations; if you are just using
// a widget, you *must* use its own API for adding children.
//
// The function takes the following parameters:
//
//   - parent GtkWidget to insert widget into.
//   - previousSibling (optional): new previous sibling of widget or NULL.
func (widget *Widget) InsertAfter(parent, previousSibling Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	if previousSibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(previousSibling).Native()))
	}

	C.gtk_widget_insert_after(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(previousSibling)
}

// InsertBefore inserts widget into the child widget list of parent.
//
// It will be placed before next_sibling, or at the end if next_sibling is NULL.
//
// After calling this function, gtk_widget_get_next_sibling(widget) will return
// next_sibling.
//
// If parent is already set as the parent widget of widget, this function can
// also be used to reorder widget in the child widget list of parent.
//
// This API is primarily meant for widget implementations; if you are just using
// a widget, you *must* use its own API for adding children.
//
// The function takes the following parameters:
//
//   - parent GtkWidget to insert widget into.
//   - nextSibling (optional): new next sibling of widget or NULL.
func (widget *Widget) InsertBefore(parent, nextSibling Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	if nextSibling != nil {
		_arg2 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(nextSibling).Native()))
	}

	C.gtk_widget_insert_before(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
	runtime.KeepAlive(nextSibling)
}

// IsAncestor determines whether widget is somewhere inside ancestor, possibly
// with intermediate containers.
//
// The function takes the following parameters:
//
//   - ancestor: another GtkWidget.
//
// The function returns the following values:
//
//   - ok: TRUE if ancestor contains widget as a child, grandchild, great
//     grandchild, etc.
func (widget *Widget) IsAncestor(ancestor Widgetter) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(ancestor).Native()))

	_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDrawable determines whether widget can be drawn to.
//
// A widget can be drawn if it is mapped and visible.
//
// The function returns the following values:
//
//   - ok: TRUE if widget is drawable, FALSE otherwise.
func (widget *Widget) IsDrawable() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_drawable(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFocus determines if the widget is the focus widget within its toplevel.
//
// This does not mean that the gtk.Widget:has-focus property is necessarily set;
// gtk,widget:has-focus will only be set if the toplevel widget additionally has
// the global input focus.).
//
// The function returns the following values:
//
//   - ok: TRUE if the widget is the focus widget.
func (widget *Widget) IsFocus() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_focus(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsSensitive returns the widget’s effective sensitivity.
//
// This means it is sensitive itself and also its parent widget is sensitive.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget is effectively sensitive.
func (widget *Widget) IsSensitive() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_sensitive(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsVisible determines whether the widget and all its parents are marked as
// visible.
//
// This function does not check if the widget is obscured in any way.
//
// See also gtk.Widget.GetVisible() and gtk.Widget.SetVisible().
//
// The function returns the following values:
//
//   - ok: TRUE if the widget and all its parents are visible.
func (widget *Widget) IsVisible() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_is_visible(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// KeynavFailed emits the ::keynav-failed signal on the widget.
//
// This function should be called whenever keyboard navigation within a single
// widget hits a boundary.
//
// The return value of this function should be interpreted in a way similar
// to the return value of gtk.Widget.ChildFocus(). When TRUE is returned,
// stay in the widget, the failed keyboard navigation is OK and/or there is
// nowhere we can/should move the focus to. When FALSE is returned, the caller
// should continue with keyboard navigation outside the widget, e.g. by calling
// gtk.Widget.ChildFocus() on the widget’s toplevel.
//
// The default gtk.Widget::keynav-failed handler returns FALSE for
// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
// DirectionType it returns TRUE.
//
// Whenever the default handler returns TRUE, it also calls
// gtk.Widget.ErrorBell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either
// by connecting to it or by overriding it) would be a row of gtk.Entry widgets
// where the user should be able to navigate the entire row with the cursor
// keys, as e.g. known from user interfaces that require entering license keys.
//
// The function takes the following parameters:
//
//   - direction of focus movement.
//
// The function returns the following values:
//
//   - ok: TRUE if stopping keyboard navigation is fine, FALSE if the emitting
//     widget should try to handle the keyboard navigation attempt in its parent
//     container(s).
func (widget *Widget) KeynavFailed(direction DirectionType) bool {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ListMnemonicLabels returns the widgets for which this widget is the target of
// a mnemonic.
//
// Typically, these widgets will be labels. See, for example,
// gtk.Label.SetMnemonicWidget().
//
// The widgets in the list are not individually referenced. If you want
// to iterate through the list and perform actions involving callbacks
// that might destroy the widgets, you must call g_list_foreach (result,
// (GFunc)g_object_ref, NULL) first, and then unref all the widgets afterwards.
//
// The function returns the following values:
//
//   - list: list of mnemonic labels; free this list with g_list_free() when you
//     are done with it.
func (widget *Widget) ListMnemonicLabels() []Widgetter {
	var _arg0 *C.GtkWidget // out
	var _cret *C.GList     // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_list_mnemonic_labels(_arg0)
	runtime.KeepAlive(widget)

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// Map causes a widget to be mapped if it isn’t already.
//
// This function is only for use in widget implementations.
func (widget *Widget) Map() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_map(_arg0)
	runtime.KeepAlive(widget)
}

// Measure measures widget in the orientation orientation and for the given
// for_size.
//
// As an example, if orientation is GTK_ORIENTATION_HORIZONTAL and for_size is
// 300, this functions will compute the minimum and natural width of widget if
// it is allocated at a height of 300 pixels.
//
// See GtkWidget’s geometry management section
// (class.Widget.html#height-for-width-geometry-management) for a more details
// on implementing WidgetClass.measure().
//
// The function takes the following parameters:
//
//   - orientation to measure.
//   - forSize: size for the opposite of orientation, i.e. if orientation is
//     GTK_ORIENTATION_HORIZONTAL, this is the height the widget should be
//     measured with. The GTK_ORIENTATION_VERTICAL case is analogous. This way,
//     both height-for-width and width-for-height requests can be implemented.
//     If no size is known, -1 can be passed.
//
// The function returns the following values:
//
//   - minimum (optional): location to store the minimum size, or NULL.
//   - natural (optional): location to store the natural size, or NULL.
//   - minimumBaseline (optional): location to store the baseline position for
//     the minimum size, or NULL.
//   - naturalBaseline (optional): location to store the baseline position for
//     the natural size, or NULL.
func (widget *Widget) Measure(orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _arg2 C.int            // out
	var _arg3 C.int            // in
	var _arg4 C.int            // in
	var _arg5 C.int            // in
	var _arg6 C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.int(forSize)

	C.gtk_widget_measure(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(forSize)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = int(_arg3)
	_natural = int(_arg4)
	_minimumBaseline = int(_arg5)
	_naturalBaseline = int(_arg6)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

// MnemonicActivate emits the GtkWidget::mnemonic-activate signal.
//
// The function takes the following parameters:
//
//   - groupCycling: TRUE if there are other widgets with the same mnemonic.
//
// The function returns the following values:
//
//   - ok: TRUE if the signal has been handled.
func (widget *Widget) MnemonicActivate(groupCycling bool) bool {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(groupCycling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ObserveChildren returns a GListModel to track the children of widget.
//
// Calling this function will enable extra internal bookkeeping to track
// children and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of the
// slowdowns.
//
// The function returns the following values:
//
//   - listModel: a GListModel tracking widget's children.
func (widget *Widget) ObserveChildren() *gio.ListModel {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_observe_children(_arg0)
	runtime.KeepAlive(widget)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// ObserveControllers returns a GListModel to track the gtk.EventControllers of
// widget.
//
// Calling this function will enable extra internal bookkeeping to track
// controllers and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of the
// slowdowns.
//
// The function returns the following values:
//
//   - listModel: a GListModel tracking widget's controllers.
func (widget *Widget) ObserveControllers() *gio.ListModel {
	var _arg0 *C.GtkWidget  // out
	var _cret *C.GListModel // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_observe_controllers(_arg0)
	runtime.KeepAlive(widget)

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// Pick finds the descendant of widget closest to the screen at the point (x,
// y).
//
// The point must be given in widget coordinates, so (0, 0) is assumed to be the
// top left of widget's content area.
//
// Usually widgets will return NULL if the given coordinate is not contained in
// widget checked via gtk.Widget.Contains(). Otherwise they will recursively
// try to find a child that does not return NULL. Widgets are however free to
// customize their picking algorithm.
//
// This function is used on the toplevel to determine the widget below the mouse
// cursor for purposes of hover highlighting and delivering events.
//
// The function takes the following parameters:
//
//   - x: x coordinate to test, relative to widget's origin.
//   - y: y coordinate to test, relative to widget's origin.
//   - flags flags to influence what is picked.
//
// The function returns the following values:
//
//   - ret (optional): widget descendant at the given coordinate or NULL if
//     none.
func (widget *Widget) Pick(x, y float64, flags PickFlags) Widgetter {
	var _arg0 *C.GtkWidget   // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out
	var _arg3 C.GtkPickFlags // out
	var _cret *C.GtkWidget   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(x)
	_arg2 = C.double(y)
	_arg3 = C.GtkPickFlags(flags)

	_cret = C.gtk_widget_pick(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(flags)

	var _ret Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_ret = rv
		}
	}

	return _ret
}

// QueueAllocate flags the widget for a rerun of the
// GtkWidgetClass::size_allocate function.
//
// Use this function instead of gtk.Widget.QueueResize() when the widget's size
// request didn't change but it wants to reposition its contents.
//
// An example user of this function is gtk.Widget.SetHAlign().
//
// This function is only for use in widget implementations.
func (widget *Widget) QueueAllocate() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_allocate(_arg0)
	runtime.KeepAlive(widget)
}

// QueueDraw schedules this widget to be redrawn in paint phase of the current
// or the next frame.
//
// This means widget's GtkWidgetClass.snapshot() implementation will be called.
func (widget *Widget) QueueDraw() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_draw(_arg0)
	runtime.KeepAlive(widget)
}

// QueueResize flags a widget to have its size renegotiated.
//
// This should be called when a widget for some reason has a new size request.
// For example, when you change the text in a gtk.Label, the label queues a
// resize to ensure there’s enough space for the new text.
//
// Note that you cannot call gtk_widget_queue_resize() on a widget from inside
// its implementation of the GtkWidgetClass::size_allocate virtual method.
// Calls to gtk_widget_queue_resize() from inside GtkWidgetClass::size_allocate
// will be silently ignored.
//
// This function is only for use in widget implementations.
func (widget *Widget) QueueResize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_queue_resize(_arg0)
	runtime.KeepAlive(widget)
}

// Realize creates the GDK resources associated with a widget.
//
// Normally realization happens implicitly; if you show a widget and all its
// parent containers, then the widget will be realized and mapped automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling this function realizes the widget’s parents in addition to widget
// itself. If a widget is not yet inside a toplevel window when you realize it,
// bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as gtk.Widget::realize.
func (widget *Widget) Realize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_realize(_arg0)
	runtime.KeepAlive(widget)
}

// RemoveController removes controller from widget, so that it doesn't process
// events anymore.
//
// It should not be used again.
//
// Widgets will remove all event controllers automatically when they are
// destroyed, there is normally no need to call this function.
//
// The function takes the following parameters:
//
//   - controller: EventController.
func (widget *Widget) RemoveController(controller EventControllerer) {
	var _arg0 *C.GtkWidget          // out
	var _arg1 *C.GtkEventController // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkEventController)(unsafe.Pointer(coreglib.InternObject(controller).Native()))

	C.gtk_widget_remove_controller(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(controller)
}

// RemoveCSSClass removes a style from widget.
//
// After this, the style of widget will stop matching for css_class.
//
// The function takes the following parameters:
//
//   - cssClass: style class to remove from widget, without the leading '.' used
//     for notation of style classes.
func (widget *Widget) RemoveCSSClass(cssClass string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(cssClass)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_remove_css_class(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cssClass)
}

// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget.
//
// See gtk.Widget.ListMnemonicLabels(). The widget must have previously been
// added to the list with gtk.Widget.AddMnemonicLabel().
//
// The function takes the following parameters:
//
//   - label: GtkWidget that was previously set as a mnemonic label for widget
//     with gtk.Widget.AddMnemonicLabel().
func (widget *Widget) RemoveMnemonicLabel(label Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(label).Native()))

	C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(label)
}

// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
//
// The function takes the following parameters:
//
//   - id returned by gtk.Widget.AddTickCallback().
func (widget *Widget) RemoveTickCallback(id uint) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.guint(id)

	C.gtk_widget_remove_tick_callback(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(id)
}

// SetCanFocus specifies whether the input focus can enter the widget or any of
// its children.
//
// Applications should set can_focus to FALSE to mark a widget as for
// pointer/touch use only.
//
// Note that having can_focus be TRUE is only one of the necessary conditions
// for being focusable. A widget must also be sensitive and focusable and not
// have an ancestor that is marked as not can-focus in order to receive input
// focus.
//
// See gtk.Widget.GrabFocus() for actually setting the input focus on a widget.
//
// The function takes the following parameters:
//
//   - canFocus: whether or not the input focus can enter the widget or any of
//     its children.
func (widget *Widget) SetCanFocus(canFocus bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canFocus {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_focus(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canFocus)
}

// SetCanTarget sets whether widget can be the target of pointer events.
//
// The function takes the following parameters:
//
//   - canTarget: whether this widget should be able to receive pointer events.
func (widget *Widget) SetCanTarget(canTarget bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if canTarget {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_can_target(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(canTarget)
}

// SetChildVisible sets whether widget should be mapped along with its parent.
//
// The child visibility can be set for widget before it is added to a container
// with gtk.Widget.SetParent(), to avoid mapping children unnecessary before
// immediately unmapping them. However it will be reset to its default state of
// TRUE when the widget is removed from a container.
//
// Note that changing the child visibility of a widget does not queue a resize
// on the widget. Most of the time, the size of a widget is computed from all
// visible children, whether or not they are mapped. If this is not the case,
// the container can queue a resize itself.
//
// This function is only useful for container implementations and should never
// be called by an application.
//
// The function takes the following parameters:
//
//   - childVisible: if TRUE, widget should be mapped along with its parent.
func (widget *Widget) SetChildVisible(childVisible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if childVisible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_child_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(childVisible)
}

// SetCSSClasses will clear all style classes applied to widget and replace them
// with classes.
//
// The function takes the following parameters:
//
//   - classes: NULL-terminated list of style classes to apply to widget.
func (widget *Widget) SetCSSClasses(classes []string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 **C.char     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	{
		_arg1 = (**C.char)(C.calloc(C.size_t((len(classes) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg1))
		{
			out := unsafe.Slice(_arg1, len(classes)+1)
			var zero *C.char
			out[len(classes)] = zero
			for i := range classes {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(classes[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.gtk_widget_set_css_classes(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(classes)
}

// SetCursor sets the cursor to be shown when pointer devices point towards
// widget.
//
// If the cursor is NULL, widget will use the cursor inherited from the parent
// widget.
//
// The function takes the following parameters:
//
//   - cursor (optional): new cursor or NULL to use the default cursor.
func (widget *Widget) SetCursor(cursor *gdk.Cursor) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GdkCursor // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if cursor != nil {
		_arg1 = (*C.GdkCursor)(unsafe.Pointer(coreglib.InternObject(cursor).Native()))
	}

	C.gtk_widget_set_cursor(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(cursor)
}

// SetCursorFromName sets a named cursor to be shown when pointer devices point
// towards widget.
//
// This is a utility function that creates a cursor via gdk.Cursor.NewFromName
// and then sets it on widget with gtk.Widget.SetCursor(). See those functions
// for details.
//
// On top of that, this function allows name to be NULL, which will do the same
// as calling gtk.Widget.SetCursor() with a NULL cursor.
//
// The function takes the following parameters:
//
//   - name (optional) of the cursor or NULL to use the default cursor.
func (widget *Widget) SetCursorFromName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_cursor_from_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetDirection sets the reading direction on a particular widget.
//
// This direction controls the primary direction for widgets containing text,
// and also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct localization
// into languages with right-to-left reading directions can be done. Generally,
// applications will let the default reading direction present, except for
// containers where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
//
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// gtk.Widget().SetDefaultDirection will be used.
//
// The function takes the following parameters:
//
//   - dir: new direction.
func (widget *Widget) SetDirection(dir TextDirection) {
	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_direction(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(dir)
}

// SetFocusChild: set child as the current focus child of widget.
//
// The previous focus child will be unset.
//
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call gtk.Widget.GrabFocus() on it.
//
// The function takes the following parameters:
//
//   - child (optional): direct child widget of widget or NULL to unset the
//     focus child of widget.
func (widget *Widget) SetFocusChild(child Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_widget_set_focus_child(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(child)
}

// SetFocusOnClick sets whether the widget should grab focus when it is clicked
// with the mouse.
//
// Making mouse clicks not grab focus is useful in places like toolbars
// where you don’t want the keyboard focus removed from the main area of the
// application.
//
// The function takes the following parameters:
//
//   - focusOnClick: whether the widget should grab focus when clicked with the
//     mouse.
func (widget *Widget) SetFocusOnClick(focusOnClick bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if focusOnClick {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focus_on_click(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(focusOnClick)
}

// SetFocusable specifies whether widget can own the input focus.
//
// Widget implementations should set focusable to TRUE in their init() function
// if they want to receive keyboard input.
//
// Note that having focusable be TRUE is only one of the necessary conditions
// for being focusable. A widget must also be sensitive and can-focus and not
// have an ancestor that is marked as not can-focus in order to receive input
// focus.
//
// See gtk.Widget.GrabFocus() for actually setting the input focus on a widget.
//
// The function takes the following parameters:
//
//   - focusable: whether or not widget can own the input focus.
func (widget *Widget) SetFocusable(focusable bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if focusable {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_focusable(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(focusable)
}

// SetFontMap sets the font map to use for Pango rendering.
//
// The font map is the object that is used to look up fonts. Setting a custom
// font map can be useful in special situations, e.g. when you need to add
// application-specific fonts to the set of available fonts.
//
// When not set, the widget will inherit the font map from its parent.
//
// The function takes the following parameters:
//
//   - fontMap (optional): PangoFontMap, or NULL to unset any previously set
//     font map.
func (widget *Widget) SetFontMap(fontMap pango.FontMapper) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 *C.PangoFontMap // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if fontMap != nil {
		_arg1 = (*C.PangoFontMap)(unsafe.Pointer(coreglib.InternObject(fontMap).Native()))
	}

	C.gtk_widget_set_font_map(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(fontMap)
}

// SetFontOptions sets the cairo_font_options_t used for Pango rendering in this
// widget.
//
// When not set, the default font options for the GdkDisplay will be used.
//
// The function takes the following parameters:
//
//   - options (optional) or NULL to unset any previously set default font
//     options.
func (widget *Widget) SetFontOptions(options *cairo.FontOptions) {
	var _arg0 *C.GtkWidget            // out
	var _arg1 *C.cairo_font_options_t // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if options != nil {
		_arg1 = (*C.cairo_font_options_t)(gextras.StructNative(unsafe.Pointer(options)))
	}

	C.gtk_widget_set_font_options(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(options)
}

// SetHAlign sets the horizontal alignment of widget.
//
// The function takes the following parameters:
//
//   - align: horizontal alignment.
func (widget *Widget) SetHAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_halign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetHasTooltip sets the has-tooltip property on widget to has_tooltip.
//
// The function takes the following parameters:
//
//   - hasTooltip: whether or not widget has a tooltip.
func (widget *Widget) SetHasTooltip(hasTooltip bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if hasTooltip {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_has_tooltip(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(hasTooltip)
}

// SetHExpand sets whether the widget would like any available extra horizontal
// space.
//
// When a user resizes a GtkWindow, widgets with expand=TRUE generally receive
// the extra space. For example, a list or scrollable area or document in your
// window would often be set to expand.
//
// Call this function to set the expand flag if you would like your widget to
// become larger horizontally when the window has extra room.
//
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call gtk.Widget.ComputeExpand(). A container can decide
// how the expandability of children affects the expansion of the container by
// overriding the compute_expand virtual method on GtkWidget.).
//
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
//
// This function forces the widget to expand or not to expand, regardless
// of children. The override occurs because gtk.Widget.SetHExpand() sets the
// hexpand-set property (see gtk.Widget.SetHExpandSet()) which causes the
// widget’s hexpand value to be used, rather than looking at children and widget
// state.
//
// The function takes the following parameters:
//
//   - expand: whether to expand.
func (widget *Widget) SetHExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetHExpandSet sets whether the hexpand flag will be used.
//
// The gtk.Widget:hexpand-set property will be set automatically when you call
// gtk.Widget.SetHExpand() to set hexpand, so the most likely reason to use this
// function would be to unset an explicit expand flag.
//
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
//
// There are few reasons to use this function, but it’s here for completeness
// and consistency.
//
// The function takes the following parameters:
//
//   - set: value for hexpand-set property.
func (widget *Widget) SetHExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_hexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetLayoutManager sets the layout manager delegate instance that provides an
// implementation for measuring and allocating the children of widget.
//
// The function takes the following parameters:
//
//   - layoutManager (optional): GtkLayoutManager.
func (widget *Widget) SetLayoutManager(layoutManager LayoutManagerer) {
	var _arg0 *C.GtkWidget        // out
	var _arg1 *C.GtkLayoutManager // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if layoutManager != nil {
		_arg1 = (*C.GtkLayoutManager)(unsafe.Pointer(coreglib.InternObject(layoutManager).Native()))
		C.g_object_ref(C.gpointer(coreglib.InternObject(layoutManager).Native()))
	}

	C.gtk_widget_set_layout_manager(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(layoutManager)
}

// SetMarginBottom sets the bottom margin of widget.
//
// The function takes the following parameters:
//
//   - margin: bottom margin.
func (widget *Widget) SetMarginBottom(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_bottom(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginEnd sets the end margin of widget.
//
// The function takes the following parameters:
//
//   - margin: end margin.
func (widget *Widget) SetMarginEnd(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_end(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginStart sets the start margin of widget.
//
// The function takes the following parameters:
//
//   - margin: start margin.
func (widget *Widget) SetMarginStart(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_start(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetMarginTop sets the top margin of widget.
//
// The function takes the following parameters:
//
//   - margin: top margin.
func (widget *Widget) SetMarginTop(margin int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(margin)

	C.gtk_widget_set_margin_top(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(margin)
}

// SetName sets a widgets name.
//
// Setting a name allows you to refer to the widget from a CSS file.
// You can apply a style to widgets with a particular name in the CSS file.
// See the documentation for the CSS syntax (on the same page as the docs for
// gtk.StyleContext.
//
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these will
// make your widget impossible to match by name. Any combination of alphanumeric
// symbols, dashes and underscores will suffice.
//
// The function takes the following parameters:
//
//   - name for the widget.
func (widget *Widget) SetName(name string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_set_name(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(name)
}

// SetOpacity: request the widget to be rendered partially transparent.
//
// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
//
// Opacity works on both toplevel widgets and child widgets, although there
// are some limitations: For toplevel widgets, applying opacity depends on
// the capabilities of the windowing system. On X11, this has any effect only
// on X displays with a compositing manager, see gdk_display_is_composited().
// On Windows and Wayland it should always work, although setting a window’s
// opacity after the window has been shown may cause some flicker.
//
// Note that the opacity is inherited through inclusion — if you set a toplevel
// to be partially translucent, all of its content will appear translucent,
// since it is ultimatively rendered on that toplevel. The opacity value
// itself is not inherited by child widgets (since that would make widgets
// deeper in the hierarchy progressively more translucent). As a consequence,
// gtk.Popovers and other gtk.Native widgets with their own surface will use
// their own opacity value, and thus by default appear non-translucent, even if
// they are attached to a toplevel that is translucent.
//
// The function takes the following parameters:
//
//   - opacity: desired opacity, between 0 and 1.
func (widget *Widget) SetOpacity(opacity float64) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(opacity)

	C.gtk_widget_set_opacity(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(opacity)
}

// SetOverflow sets how widget treats content that is drawn outside the widget's
// content area.
//
// See the definition of gtk.Overflow for details.
//
// This setting is provided for widget implementations and should not be used by
// application code.
//
// The default value is GTK_OVERFLOW_VISIBLE.
//
// The function takes the following parameters:
//
//   - overflow: desired overflow.
func (widget *Widget) SetOverflow(overflow Overflow) {
	var _arg0 *C.GtkWidget  // out
	var _arg1 C.GtkOverflow // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOverflow(overflow)

	C.gtk_widget_set_overflow(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(overflow)
}

// SetParent sets parent as the parent widget of widget.
//
// This takes care of details such as updating the state and style of the child
// to reflect its new location and resizing the parent. The opposite function is
// gtk.Widget.Unparent().
//
// This function is useful only when implementing subclasses of GtkWidget.
//
// The function takes the following parameters:
//
//   - parent widget.
func (widget *Widget) SetParent(parent Widgetter) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(parent).Native()))

	C.gtk_widget_set_parent(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(parent)
}

// SetReceivesDefault specifies whether widget will be treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
//
// The function takes the following parameters:
//
//   - receivesDefault: whether or not widget can be a default widget.
func (widget *Widget) SetReceivesDefault(receivesDefault bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if receivesDefault {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_receives_default(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(receivesDefault)
}

// SetSensitive sets the sensitivity of a widget.
//
// A widget is sensitive if the user can interact with it. Insensitive widgets
// are “grayed out” and the user can’t interact with them. Insensitive widgets
// are known as “inactive”, “disabled”, or “ghosted” in some other toolkits.
//
// The function takes the following parameters:
//
//   - sensitive: TRUE to make the widget sensitive.
func (widget *Widget) SetSensitive(sensitive bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if sensitive {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_sensitive(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(sensitive)
}

// SetSizeRequest sets the minimum size of a widget.
//
// That is, the widget’s size request will be at least width by height. You can
// use this function to force a widget to be larger than it normally would be.
//
// In most cases, gtk.Window.SetDefaultSize() is a better choice for toplevel
// windows than this function; setting the default size will still allow users
// to shrink the window. Setting the size request will force them to leave the
// window at least as large as the size request.
//
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change
// the appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
//
// The size request of a widget is the smallest size a widget can accept while
// still functioning well and drawing itself correctly. However in some strange
// cases a widget may be allocated less than its requested size, and in many
// cases a widget may be allocated more space than it requested.
//
// If the size request in a given direction is -1 (unset), then the “natural”
// size request of the widget will be used instead.
//
// The size request set here does not include any margin from the properties
// gtk.Widget:margin-start, gtk.Widget:margin-end, gtk.Widget:margin-top, and
// gtk.Widget:margin-bottom, but it does include pretty much all other padding
// or border properties set by any subclass of GtkWidget.
//
// The function takes the following parameters:
//
//   - width widget should request, or -1 to unset.
//   - height widget should request, or -1 to unset.
func (widget *Widget) SetSizeRequest(width, height int) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetStateFlags turns on flag values in the current widget state.
//
// Typical widget states are insensitive, prelighted, etc.
//
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use gtk.Widget.SetDirection().
//
// This function is for use in widget implementations.
//
// The function takes the following parameters:
//
//   - flags: state flags to turn on.
//   - clear: whether to clear state before turning on flags.
func (widget *Widget) SetStateFlags(flags StateFlags, clear bool) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out
	var _arg2 C.gboolean      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)
	if clear {
		_arg2 = C.TRUE
	}

	C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(clear)
}

// SetTooltipMarkup sets markup as the contents of the tooltip, which is marked
// up with Pango markup.
//
// This function will take care of setting the gtk.Widget:has-tooltip as a side
// effect, and of the default handler for the gtk.Widget::query-tooltip signal.
//
// See also gtk.Tooltip.SetMarkup().
//
// The function takes the following parameters:
//
//   - markup (optional) contents of the tooltip for widget.
func (widget *Widget) SetTooltipMarkup(markup string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if markup != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(markup)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(markup)
}

// SetTooltipText sets text as the contents of the tooltip.
//
// If text contains any markup, it will be escaped.
//
// This function will take care of setting gtk.Widget:has-tooltip as a side
// effect, and of the default handler for the gtk.Widget::query-tooltip signal.
//
// See also gtk.Tooltip.SetText().
//
// The function takes the following parameters:
//
//   - text (optional) contents of the tooltip for widget.
func (widget *Widget) SetTooltipText(text string) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if text != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_widget_set_tooltip_text(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(text)
}

// SetVAlign sets the vertical alignment of widget.
//
// The function takes the following parameters:
//
//   - align: vertical alignment.
func (widget *Widget) SetVAlign(align Align) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.GtkAlign   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkAlign(align)

	C.gtk_widget_set_valign(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(align)
}

// SetVExpand sets whether the widget would like any available extra vertical
// space.
//
// See gtk.Widget.SetHExpand() for more detail.
//
// The function takes the following parameters:
//
//   - expand: whether to expand.
func (widget *Widget) SetVExpand(expand bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if expand {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(expand)
}

// SetVExpandSet sets whether the vexpand flag will be used.
//
// See gtk.Widget.SetHExpandSet() for more detail.
//
// The function takes the following parameters:
//
//   - set: value for vexpand-set property.
func (widget *Widget) SetVExpandSet(set bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if set {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_vexpand_set(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(set)
}

// SetVisible sets the visibility state of widget.
//
// Note that setting this to TRUE doesn’t mean the widget is actually viewable,
// see gtk.Widget.GetVisible().
//
// This function simply calls gtk.Widget.Show() or gtk.Widget.Hide() but is
// nicer to use when the visibility of the widget depends on some condition.
//
// The function takes the following parameters:
//
//   - visible: whether the widget should be shown or not.
func (widget *Widget) SetVisible(visible bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_widget_set_visible(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(visible)
}

// ShouldLayout returns whether widget should contribute to the measuring and
// allocation of its parent.
//
// This is FALSE for invisible children, but also for children that have their
// own surface.
//
// The function returns the following values:
//
//   - ok: TRUE if child should be included in measuring and allocating.
func (widget *Widget) ShouldLayout() bool {
	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C.gtk_widget_should_layout(_arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Show flags a widget to be displayed.
//
// Any widget that isn’t shown will not appear on the screen.
//
// Remember that you have to show the containers containing a widget,
// in addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (widget *Widget) Show() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_show(_arg0)
	runtime.KeepAlive(widget)
}

// SizeAllocate allocates widget with a transformation that translates the
// origin to the position in allocation.
//
// This is a simple form of gtk.Widget.Allocate().
//
// The function takes the following parameters:
//
//   - allocation: position and size to be allocated to widget.
//   - baseline of the child, or -1.
func (widget *Widget) SizeAllocate(allocation *Allocation, baseline int) {
	var _arg0 *C.GtkWidget     // out
	var _arg1 *C.GtkAllocation // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GdkRectangle)(gextras.StructNative(unsafe.Pointer(allocation)))
	type _ = *Allocation
	type _ = *gdk.Rectangle
	_arg2 = C.int(baseline)

	C.gtk_widget_size_allocate(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(allocation)
	runtime.KeepAlive(baseline)
}

// SnapshotChild: snapshot the a child of widget.
//
// When a widget receives a call to the snapshot function, it must send
// synthetic GtkWidgetClass.snapshot() calls to all children. This function
// provides a convenient way of doing this. A widget, when it receives a call
// to its GtkWidgetClass.snapshot() function, calls gtk_widget_snapshot_child()
// once for each child, passing in the snapshot the widget received.
//
// gtk_widget_snapshot_child() takes care of translating the origin of snapshot,
// and deciding whether the child needs to be snapshot.
//
// This function does nothing for children that implement GtkNative.
//
// The function takes the following parameters:
//
//   - child of widget.
//   - snapshot as passed to the widget. In particular, no calls to
//     gtk_snapshot_translate() or other transform calls should have been made.
func (widget *Widget) SnapshotChild(child Widgetter, snapshot *Snapshot) {
	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GtkWidget   // out
	var _arg2 *C.GtkSnapshot // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	_arg2 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C.gtk_widget_snapshot_child(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(child)
	runtime.KeepAlive(snapshot)
}

// TranslateCoordinates: translate coordinates relative to src_widget’s
// allocation to coordinates relative to dest_widget’s allocations.
//
// In order to perform this operation, both widget must share a common ancestor.
//
// The function takes the following parameters:
//
//   - destWidget: GtkWidget.
//   - srcX: x position relative to src_widget.
//   - srcY: y position relative to src_widget.
//
// The function returns the following values:
//
//   - destX (optional): location to store X position relative to dest_widget.
//   - destY (optional): location to store Y position relative to dest_widget.
//   - ok: FALSE if src_widget and dest_widget have no common ancestor. In this
//     case, 0 is stored in *dest_x and *dest_y. Otherwise TRUE.
func (srcWidget *Widget) TranslateCoordinates(destWidget Widgetter, srcX, srcY float64) (destX, destY float64, ok bool) {
	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out
	var _arg2 C.double     // out
	var _arg3 C.double     // out
	var _arg4 C.double     // in
	var _arg5 C.double     // in
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(srcWidget).Native()))
	_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(destWidget).Native()))
	_arg2 = C.double(srcX)
	_arg3 = C.double(srcY)

	_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)
	runtime.KeepAlive(srcWidget)
	runtime.KeepAlive(destWidget)
	runtime.KeepAlive(srcX)
	runtime.KeepAlive(srcY)

	var _destX float64 // out
	var _destY float64 // out
	var _ok bool       // out

	_destX = float64(_arg4)
	_destY = float64(_arg5)
	if _cret != 0 {
		_ok = true
	}

	return _destX, _destY, _ok
}

// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of widget is located.
func (widget *Widget) TriggerTooltipQuery() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_trigger_tooltip_query(_arg0)
	runtime.KeepAlive(widget)
}

// Unmap causes a widget to be unmapped if it’s currently mapped.
//
// This function is only for use in widget implementations.
func (widget *Widget) Unmap() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unmap(_arg0)
	runtime.KeepAlive(widget)
}

// Unparent: dissociate widget from its parent.
//
// This function is only for use in widget implementations, typically in
// dispose.
func (widget *Widget) Unparent() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unparent(_arg0)
	runtime.KeepAlive(widget)
}

// Unrealize causes a widget to be unrealized (frees all GDK resources
// associated with the widget).
//
// This function is only useful in widget implementations.
func (widget *Widget) Unrealize() {
	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C.gtk_widget_unrealize(_arg0)
	runtime.KeepAlive(widget)
}

// UnsetStateFlags turns off flag values for the current widget state.
//
// See gtk.Widget.SetStateFlags().
//
// This function is for use in widget implementations.
//
// The function takes the following parameters:
//
//   - flags: state flags to turn off.
func (widget *Widget) UnsetStateFlags(flags StateFlags) {
	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(flags)

	C.gtk_widget_unset_state_flags(_arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(flags)
}

// Contains tests if the point at (x, y) is contained in widget.
//
// The coordinates for (x, y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of widget's content area.
//
// The function takes the following parameters:
//
//   - x: x coordinate to test, relative to widget's origin.
//   - y: y coordinate to test, relative to widget's origin.
//
// The function returns the following values:
//
//   - ok: TRUE if widget contains (x, y).
func (widget *Widget) contains(x, y float64) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.contains

	var _arg0 *C.GtkWidget // out
	var _arg1 C.double     // out
	var _arg2 C.double     // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.double(x)
	_arg2 = C.double(y)

	_cret = C._gotk4_gtk4_Widget_virtual_contains(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (widget *Widget) directionChanged(previousDirection TextDirection) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.direction_changed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkTextDirection // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkTextDirection(previousDirection)

	C._gotk4_gtk4_Widget_virtual_direction_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousDirection)
}

func (widget *Widget) focus(direction DirectionType) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.focus

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C._gotk4_gtk4_Widget_virtual_focus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// requestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
//
// Single-child widgets generally propagate the preference of their child,
// more complex widgets need to request something either in context of their
// children or in context of their allocation capabilities.
//
// The function returns the following values:
//
//   - sizeRequestMode: GtkSizeRequestMode preferred by widget.
func (widget *Widget) requestMode() SizeRequestMode {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.get_request_mode

	var _arg0 *C.GtkWidget         // out
	var _cret C.GtkSizeRequestMode // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk4_Widget_virtual_get_request_mode(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)

	var _sizeRequestMode SizeRequestMode // out

	_sizeRequestMode = SizeRequestMode(_cret)

	return _sizeRequestMode
}

// grabFocus causes widget to have the keyboard focus for the GtkWindow it's
// inside.
//
// If widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of widget that is focusable, it will not
// take focus and FALSE will be returned.
//
// Calling gtk.Widget.GrabFocus() on an already focused widget is allowed,
// should not have an effect, and return TRUE.
//
// The function returns the following values:
//
//   - ok: TRUE if focus is now inside widget.
func (widget *Widget) grabFocus() bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.grab_focus

	var _arg0 *C.GtkWidget // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	_cret = C._gotk4_gtk4_Widget_virtual_grab_focus(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Hide reverses the effects of gtk_widget_show().
//
// This is causing the widget to be hidden (invisible to the user).
func (widget *Widget) hide() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.hide

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_hide(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// keynavFailed emits the ::keynav-failed signal on the widget.
//
// This function should be called whenever keyboard navigation within a single
// widget hits a boundary.
//
// The return value of this function should be interpreted in a way similar
// to the return value of gtk.Widget.ChildFocus(). When TRUE is returned,
// stay in the widget, the failed keyboard navigation is OK and/or there is
// nowhere we can/should move the focus to. When FALSE is returned, the caller
// should continue with keyboard navigation outside the widget, e.g. by calling
// gtk.Widget.ChildFocus() on the widget’s toplevel.
//
// The default gtk.Widget::keynav-failed handler returns FALSE for
// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
// DirectionType it returns TRUE.
//
// Whenever the default handler returns TRUE, it also calls
// gtk.Widget.ErrorBell() to notify the user of the failed keyboard navigation.
//
// A use case for providing an own implementation of ::keynav-failed (either
// by connecting to it or by overriding it) would be a row of gtk.Entry widgets
// where the user should be able to navigate the entire row with the cursor
// keys, as e.g. known from user interfaces that require entering license keys.
//
// The function takes the following parameters:
//
//   - direction of focus movement.
//
// The function returns the following values:
//
//   - ok: TRUE if stopping keyboard navigation is fine, FALSE if the emitting
//     widget should try to handle the keyboard navigation attempt in its parent
//     container(s).
func (widget *Widget) keynavFailed(direction DirectionType) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.keynav_failed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out
	var _cret C.gboolean         // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	_cret = C._gotk4_gtk4_Widget_virtual_keynav_failed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Map causes a widget to be mapped if it isn’t already.
//
// This function is only for use in widget implementations.
func (widget *Widget) _map() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass._map

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_map(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// Measure measures widget in the orientation orientation and for the given
// for_size.
//
// As an example, if orientation is GTK_ORIENTATION_HORIZONTAL and for_size is
// 300, this functions will compute the minimum and natural width of widget if
// it is allocated at a height of 300 pixels.
//
// See GtkWidget’s geometry management section
// (class.Widget.html#height-for-width-geometry-management) for a more details
// on implementing WidgetClass.measure().
//
// The function takes the following parameters:
//
//   - orientation to measure.
//   - forSize: size for the opposite of orientation, i.e. if orientation is
//     GTK_ORIENTATION_HORIZONTAL, this is the height the widget should be
//     measured with. The GTK_ORIENTATION_VERTICAL case is analogous. This way,
//     both height-for-width and width-for-height requests can be implemented.
//     If no size is known, -1 can be passed.
//
// The function returns the following values:
//
//   - minimum (optional): location to store the minimum size, or NULL.
//   - natural (optional): location to store the natural size, or NULL.
//   - minimumBaseline (optional): location to store the baseline position for
//     the minimum size, or NULL.
//   - naturalBaseline (optional): location to store the baseline position for
//     the natural size, or NULL.
func (widget *Widget) measure(orientation Orientation, forSize int) (minimum, natural, minimumBaseline, naturalBaseline int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.measure

	var _arg0 *C.GtkWidget     // out
	var _arg1 C.GtkOrientation // out
	var _arg2 C.int            // out
	var _arg3 C.int            // in
	var _arg4 C.int            // in
	var _arg5 C.int            // in
	var _arg6 C.int            // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkOrientation(orientation)
	_arg2 = C.int(forSize)

	C._gotk4_gtk4_Widget_virtual_measure(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(orientation)
	runtime.KeepAlive(forSize)

	var _minimum int         // out
	var _natural int         // out
	var _minimumBaseline int // out
	var _naturalBaseline int // out

	_minimum = int(_arg3)
	_natural = int(_arg4)
	_minimumBaseline = int(_arg5)
	_naturalBaseline = int(_arg6)

	return _minimum, _natural, _minimumBaseline, _naturalBaseline
}

// mnemonicActivate emits the GtkWidget::mnemonic-activate signal.
//
// The function takes the following parameters:
//
//   - groupCycling: TRUE if there are other widgets with the same mnemonic.
//
// The function returns the following values:
//
//   - ok: TRUE if the signal has been handled.
func (widget *Widget) mnemonicActivate(groupCycling bool) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.mnemonic_activate

	var _arg0 *C.GtkWidget // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if groupCycling {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gtk4_Widget_virtual_mnemonic_activate(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(groupCycling)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (widget *Widget) moveFocus(direction DirectionType) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.move_focus

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkDirectionType // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkDirectionType(direction)

	C._gotk4_gtk4_Widget_virtual_move_focus(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(direction)
}

// The function takes the following parameters:
//
//   - x
//   - y
//   - keyboardTooltip
//   - tooltip
func (widget *Widget) queryTooltip(x, y int, keyboardTooltip bool, tooltip *Tooltip) bool {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.query_tooltip

	var _arg0 *C.GtkWidget  // out
	var _arg1 C.int         // out
	var _arg2 C.int         // out
	var _arg3 C.gboolean    // out
	var _arg4 *C.GtkTooltip // out
	var _cret C.gboolean    // in

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(x)
	_arg2 = C.int(y)
	if keyboardTooltip {
		_arg3 = C.TRUE
	}
	_arg4 = (*C.GtkTooltip)(unsafe.Pointer(coreglib.InternObject(tooltip).Native()))

	_cret = C._gotk4_gtk4_Widget_virtual_query_tooltip(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(x)
	runtime.KeepAlive(y)
	runtime.KeepAlive(keyboardTooltip)
	runtime.KeepAlive(tooltip)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Realize creates the GDK resources associated with a widget.
//
// Normally realization happens implicitly; if you show a widget and all its
// parent containers, then the widget will be realized and mapped automatically.
//
// Realizing a widget requires all the widget’s parent widgets to be realized;
// calling this function realizes the widget’s parents in addition to widget
// itself. If a widget is not yet inside a toplevel window when you realize it,
// bad things will happen.
//
// This function is primarily used in widget implementations, and isn’t very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as gtk.Widget::realize.
func (widget *Widget) realize() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.realize

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_realize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

func (widget *Widget) root() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.root

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_root(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// setFocusChild: set child as the current focus child of widget.
//
// The previous focus child will be unset.
//
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call gtk.Widget.GrabFocus() on it.
//
// The function takes the following parameters:
//
//   - child (optional): direct child widget of widget or NULL to unset the
//     focus child of widget.
func (widget *Widget) setFocusChild(child Widgetter) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.set_focus_child

	var _arg0 *C.GtkWidget // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C._gotk4_gtk4_Widget_virtual_set_focus_child(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(child)
}

// Show flags a widget to be displayed.
//
// Any widget that isn’t shown will not appear on the screen.
//
// Remember that you have to show the containers containing a widget,
// in addition to the widget itself, before it will appear onscreen.
//
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
func (widget *Widget) show() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.show

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_show(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// The function takes the following parameters:
//
//   - width
//   - height
//   - baseline
func (widget *Widget) sizeAllocate(width, height, baseline int) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.size_allocate

	var _arg0 *C.GtkWidget // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _arg3 C.int        // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)
	_arg3 = C.int(baseline)

	C._gotk4_gtk4_Widget_virtual_size_allocate(unsafe.Pointer(fnarg), _arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(baseline)
}

func (widget *Widget) snapshot(snapshot *Snapshot) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.snapshot

	var _arg0 *C.GtkWidget   // out
	var _arg1 *C.GtkSnapshot // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = (*C.GtkSnapshot)(unsafe.Pointer(coreglib.InternObject(snapshot).Native()))

	C._gotk4_gtk4_Widget_virtual_snapshot(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(snapshot)
}

func (widget *Widget) stateFlagsChanged(previousStateFlags StateFlags) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.state_flags_changed

	var _arg0 *C.GtkWidget    // out
	var _arg1 C.GtkStateFlags // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkStateFlags(previousStateFlags)

	C._gotk4_gtk4_Widget_virtual_state_flags_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(previousStateFlags)
}

func (widget *Widget) systemSettingChanged(settings SystemSetting) {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.system_setting_changed

	var _arg0 *C.GtkWidget       // out
	var _arg1 C.GtkSystemSetting // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	_arg1 = C.GtkSystemSetting(settings)

	C._gotk4_gtk4_Widget_virtual_system_setting_changed(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(widget)
	runtime.KeepAlive(settings)
}

// Unmap causes a widget to be unmapped if it’s currently mapped.
//
// This function is only for use in widget implementations.
func (widget *Widget) unmap() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unmap

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_unmap(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// Unrealize causes a widget to be unrealized (frees all GDK resources
// associated with the widget).
//
// This function is only useful in widget implementations.
func (widget *Widget) unrealize() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unrealize

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_unrealize(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

func (widget *Widget) unroot() {
	gclass := (*C.GtkWidgetClass)(coreglib.PeekParentClass(widget))
	fnarg := gclass.unroot

	var _arg0 *C.GtkWidget // out

	_arg0 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))

	C._gotk4_gtk4_Widget_virtual_unroot(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(widget)
}

// WidgetGetDefaultDirection obtains the current default reading direction.
//
// See gtk.Widget().SetDefaultDirection.
//
// The function returns the following values:
//
//   - textDirection: current default direction.
func WidgetGetDefaultDirection() TextDirection {
	var _cret C.GtkTextDirection // in

	_cret = C.gtk_widget_get_default_direction()

	var _textDirection TextDirection // out

	_textDirection = TextDirection(_cret)

	return _textDirection
}

// WidgetSetDefaultDirection sets the default reading direction for widgets.
//
// See gtk.Widget.SetDirection().
//
// The function takes the following parameters:
//
//   - dir: new default direction. This cannot be GTK_TEXT_DIR_NONE.
func WidgetSetDefaultDirection(dir TextDirection) {
	var _arg1 C.GtkTextDirection // out

	_arg1 = C.GtkTextDirection(dir)

	C.gtk_widget_set_default_direction(_arg1)
	runtime.KeepAlive(dir)
}

// WidgetPaintableOverrides contains methods that are overridable.
type WidgetPaintableOverrides struct {
}

func defaultWidgetPaintableOverrides(v *WidgetPaintable) WidgetPaintableOverrides {
	return WidgetPaintableOverrides{}
}

// WidgetPaintable: GtkWidgetPaintable is a GdkPaintable that displays the
// contents of a widget.
//
// GtkWidgetPaintable will also take care of the widget not being in a state
// where it can be drawn (like when it isn't shown) and just draw nothing or
// where it does not have a size (like when it is hidden) and report no size in
// that case.
//
// Of course, GtkWidgetPaintable allows you to monitor widgets for size
// changes by emitting the gdk.Paintable::invalidate-size signal whenever the
// size of the widget changes as well as for visual changes by emitting the
// gdk.Paintable::invalidate-contents signal whenever the widget changes.
//
// You can use a GtkWidgetPaintable everywhere a GdkPaintable is allowed,
// including using it on a GtkPicture (or one of its parents) that it was set
// on itself via gtk_picture_set_paintable(). The paintable will take care
// of recursion when this happens. If you do this however, ensure that the
// gtk.Picture:can-shrink property is set to TRUE or you might end up with an
// infinitely growing widget.
type WidgetPaintable struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gdk.Paintable
}

var (
	_ coreglib.Objector = (*WidgetPaintable)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WidgetPaintable, *WidgetPaintableClass, WidgetPaintableOverrides](
		GTypeWidgetPaintable,
		initWidgetPaintableClass,
		wrapWidgetPaintable,
		defaultWidgetPaintableOverrides,
	)
}

func initWidgetPaintableClass(gclass unsafe.Pointer, overrides WidgetPaintableOverrides, classInitFunc func(*WidgetPaintableClass)) {
	if classInitFunc != nil {
		class := (*WidgetPaintableClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWidgetPaintable(obj *coreglib.Object) *WidgetPaintable {
	return &WidgetPaintable{
		Object: obj,
		Paintable: gdk.Paintable{
			Object: obj,
		},
	}
}

func marshalWidgetPaintable(p uintptr) (interface{}, error) {
	return wrapWidgetPaintable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWidgetPaintable creates a new widget paintable observing the given widget.
//
// The function takes the following parameters:
//
//   - widget (optional): GtkWidget or NULL.
//
// The function returns the following values:
//
//   - widgetPaintable: new GtkWidgetPaintable.
func NewWidgetPaintable(widget Widgetter) *WidgetPaintable {
	var _arg1 *C.GtkWidget    // out
	var _cret *C.GdkPaintable // in

	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	_cret = C.gtk_widget_paintable_new(_arg1)
	runtime.KeepAlive(widget)

	var _widgetPaintable *WidgetPaintable // out

	_widgetPaintable = wrapWidgetPaintable(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _widgetPaintable
}

// Widget returns the widget that is observed or NULL if none.
//
// The function returns the following values:
//
//   - widget (optional): observed widget.
func (self *WidgetPaintable) Widget() Widgetter {
	var _arg0 *C.GtkWidgetPaintable // out
	var _cret *C.GtkWidget          // in

	_arg0 = (*C.GtkWidgetPaintable)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_widget_paintable_get_widget(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SetWidget sets the widget that should be observed.
//
// The function takes the following parameters:
//
//   - widget (optional) to observe or NULL.
func (self *WidgetPaintable) SetWidget(widget Widgetter) {
	var _arg0 *C.GtkWidgetPaintable // out
	var _arg1 *C.GtkWidget          // out

	_arg0 = (*C.GtkWidgetPaintable)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if widget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(widget).Native()))
	}

	C.gtk_widget_paintable_set_widget(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(widget)
}

// WindowOverrides contains methods that are overridable.
type WindowOverrides struct {
	ActivateDefault func()
	ActivateFocus   func()
	CloseRequest    func() bool
	EnableDebugging func(toggle bool) bool
	KeysChanged     func()
}

func defaultWindowOverrides(v *Window) WindowOverrides {
	return WindowOverrides{
		ActivateDefault: v.activateDefault,
		ActivateFocus:   v.activateFocus,
		CloseRequest:    v.closeRequest,
		EnableDebugging: v.enableDebugging,
		KeysChanged:     v.keysChanged,
	}
}

// Window: GtkWindow is a toplevel window which can contain other widgets.
//
// !An example GtkWindow (window.png)
//
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it,
// close it,...).
//
// # GtkWindow as GtkBuildable
//
// The GtkWindow implementation of the gtk.Buildable interface supports setting
// a child as the titlebar by specifying “titlebar” as the “type” attribute of a
// <child> element.
//
// CSS nodes
//
//	window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen / .tiled]
//	├── <child>
//	╰── <titlebar child>.titlebar [.default-decoration]
//
// GtkWindow has a main CSS node with name window and style class .background.
//
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .maximized, .fullscreen, .tiled (when
// supported, also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).
//
// GtkWindow subclasses often add their own discriminating style classes,
// such as .dialog, .popup or .tooltip.
//
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the main
// window node), the CSS border of the toplevel window is used for resize drags.
// In the .csd case, the shadow area outside of the window can be used to resize
// it.
//
// GtkWindow adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
//
// # Accessibility
//
// GtkWindow uses the GTK_ACCESSIBLE_ROLE_WINDOW role.
type Window struct {
	_ [0]func() // equal guard
	Widget

	*coreglib.Object
	Root
	ShortcutManager
}

var (
	_ Widgetter         = (*Window)(nil)
	_ coreglib.Objector = (*Window)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*Window, *WindowClass, WindowOverrides](
		GTypeWindow,
		initWindowClass,
		wrapWindow,
		defaultWindowOverrides,
	)
}

func initWindowClass(gclass unsafe.Pointer, overrides WindowOverrides, classInitFunc func(*WindowClass)) {
	pclass := (*C.GtkWindowClass)(unsafe.Pointer(C.g_type_check_class_cast((*C.GTypeClass)(gclass), C.GType(GTypeWindow))))

	if overrides.ActivateDefault != nil {
		pclass.activate_default = (*[0]byte)(C._gotk4_gtk4_WindowClass_activate_default)
	}

	if overrides.ActivateFocus != nil {
		pclass.activate_focus = (*[0]byte)(C._gotk4_gtk4_WindowClass_activate_focus)
	}

	if overrides.CloseRequest != nil {
		pclass.close_request = (*[0]byte)(C._gotk4_gtk4_WindowClass_close_request)
	}

	if overrides.EnableDebugging != nil {
		pclass.enable_debugging = (*[0]byte)(C._gotk4_gtk4_WindowClass_enable_debugging)
	}

	if overrides.KeysChanged != nil {
		pclass.keys_changed = (*[0]byte)(C._gotk4_gtk4_WindowClass_keys_changed)
	}

	if classInitFunc != nil {
		class := (*WindowClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWindow(obj *coreglib.Object) *Window {
	return &Window{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Object: obj,
		Root: Root{
			NativeSurface: NativeSurface{
				Widget: Widget{
					InitiallyUnowned: coreglib.InitiallyUnowned{
						Object: obj,
					},
					Object: obj,
					Accessible: Accessible{
						Object: obj,
					},
					Buildable: Buildable{
						Object: obj,
					},
					ConstraintTarget: ConstraintTarget{
						Object: obj,
					},
				},
			},
		},
		ShortcutManager: ShortcutManager{
			Object: obj,
		},
	}
}

func marshalWindow(p uintptr) (interface{}, error) {
	return wrapWindow(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// ConnectActivateDefault is emitted when the user activates the default widget
// of window.
//
// This is a keybinding signal (class.SignalAction.html).
func (window *Window) ConnectActivateDefault(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "activate-default", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectActivateDefault), f)
}

// ConnectActivateFocus is emitted when the user activates the currently focused
// widget of window.
//
// This is a keybinding signal (class.SignalAction.html).
func (window *Window) ConnectActivateFocus(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "activate-focus", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectActivateFocus), f)
}

// ConnectCloseRequest is emitted when the user clicks on the close button of
// the window.
func (window *Window) ConnectCloseRequest(f func() (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "close-request", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectCloseRequest), f)
}

// ConnectEnableDebugging is emitted when the user enables or disables
// interactive debugging.
//
// When toggle is TRUE, interactive debugging is toggled on or off, when it is
// FALSE, the debugger will be pointed at the widget under the pointer.
//
// This is a keybinding signal (class.SignalAction.html).
//
// The default bindings for this signal are Ctrl-Shift-I and Ctrl-Shift-D.
func (window *Window) ConnectEnableDebugging(f func(toggle bool) (ok bool)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "enable-debugging", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectEnableDebugging), f)
}

// ConnectKeysChanged is emitted when the set of accelerators or mnemonics that
// are associated with window changes.
func (window *Window) ConnectKeysChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(window, "keys-changed", false, unsafe.Pointer(C._gotk4_gtk4_Window_ConnectKeysChanged), f)
}

// NewWindow creates a new GtkWindow.
//
// To get an undecorated window (no window borders), use
// gtk.Window.SetDecorated().
//
// All top-level windows created by gtk_window_new() are stored in
// an internal top-level window list. This list can be obtained from
// gtk.Window().ListToplevels. Due to GTK keeping a reference to the window
// internally, gtk_window_new() does not return a reference to the caller.
//
// To delete a GtkWindow, call gtk.Window.Destroy().
//
// The function returns the following values:
//
//   - window: new GtkWindow.
func NewWindow() *Window {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_window_new()

	var _window *Window // out

	_window = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))

	return _window
}

// Close requests that the window is closed.
//
// This is similar to what happens when a window manager close button is
// clicked.
//
// This function can be used with close buttons in custom titlebars.
func (window *Window) Close() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_close(_arg0)
	runtime.KeepAlive(window)
}

// Destroy: drop the internal reference GTK holds on toplevel windows.
func (window *Window) Destroy() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_destroy(_arg0)
	runtime.KeepAlive(window)
}

// Fullscreen asks to place window in the fullscreen state.
//
// Note that you shouldn’t assume the window is definitely fullscreen afterward,
// because other entities (e.g. the user or window manager unfullscreen it
// again, and not all window managers honor requests to fullscreen windows.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications of the gtk.Window:fullscreened
// property.
func (window *Window) Fullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_fullscreen(_arg0)
	runtime.KeepAlive(window)
}

// FullscreenOnMonitor asks to place window in the fullscreen state on the given
// monitor.
//
// Note that you shouldn't assume the window is definitely fullscreen afterward,
// or that the windowing system allows fullscreen windows on any given monitor.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications of the gtk.Window:fullscreened
// property.
//
// The function takes the following parameters:
//
//   - monitor: which monitor to go fullscreen on.
func (window *Window) FullscreenOnMonitor(monitor *gdk.Monitor) {
	var _arg0 *C.GtkWindow  // out
	var _arg1 *C.GdkMonitor // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkMonitor)(unsafe.Pointer(coreglib.InternObject(monitor).Native()))

	C.gtk_window_fullscreen_on_monitor(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(monitor)
}

// Application gets the GtkApplication associated with the window.
//
// The function returns the following values:
//
//   - application (optional): GtkApplication, or NULL.
func (window *Window) Application() *Application {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkApplication // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_application(_arg0)
	runtime.KeepAlive(window)

	var _application *Application // out

	if _cret != nil {
		_application = wrapApplication(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _application
}

// Child gets the child widget of window.
//
// The function returns the following values:
//
//   - widget (optional): child widget of window.
func (window *Window) Child() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_child(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Decorated returns whether the window has been set to have decorations.
//
// The function returns the following values:
//
//   - ok: TRUE if the window has been set to have decorations.
func (window *Window) Decorated() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_decorated(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DefaultSize gets the default size of the window.
//
// A value of 0 for the width or height indicates that a default size has not
// been explicitly set for that dimension, so the “natural” size of the window
// will be used.
//
// The function returns the following values:
//
//   - width (optional): location to store the default width, or NULL.
//   - height (optional): location to store the default height, or NULL.
func (window *Window) DefaultSize() (width, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.int        // in
	var _arg2 C.int        // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(window)

	var _width int  // out
	var _height int // out

	_width = int(_arg1)
	_height = int(_arg2)

	return _width, _height
}

// DefaultWidget returns the default widget for window.
//
// The function returns the following values:
//
//   - widget (optional): default widget, or NULL if there is none.
func (window *Window) DefaultWidget() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_default_widget(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// Deletable returns whether the window has been set to have a close button.
//
// The function returns the following values:
//
//   - ok: TRUE if the window has been set to have a close button.
func (window *Window) Deletable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_deletable(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DestroyWithParent returns whether the window will be destroyed with its
// transient parent.
//
// The function returns the following values:
//
//   - ok: TRUE if the window will be destroyed with its transient parent.
func (window *Window) DestroyWithParent() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_destroy_with_parent(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Focus retrieves the current focused widget within the window.
//
// Note that this is the widget that would have the focus if the toplevel window
// focused; if the toplevel window is not focused then gtk_widget_has_focus
// (widget) will not be TRUE for the widget.
//
// The function returns the following values:
//
//   - widget (optional): currently focused widget, or NULL if there is none.
func (window *Window) Focus() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_focus(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// FocusVisible gets whether “focus rectangles” are supposed to be visible.
//
// The function returns the following values:
//
//   - ok: TRUE if “focus rectangles” are supposed to be visible in this window.
func (window *Window) FocusVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_focus_visible(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Group returns the group for window.
//
// If the window has no group, then the default group is returned.
//
// The function returns the following values:
//
//   - windowGroup: GtkWindowGroup for a window or the default group.
func (window *Window) Group() *WindowGroup {
	var _arg0 *C.GtkWindow      // out
	var _cret *C.GtkWindowGroup // in

	if window != nil {
		_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	}

	_cret = C.gtk_window_get_group(_arg0)
	runtime.KeepAlive(window)

	var _windowGroup *WindowGroup // out

	_windowGroup = wrapWindowGroup(coreglib.Take(unsafe.Pointer(_cret)))

	return _windowGroup
}

// HandleMenubarAccel returns whether this window reacts to F10 key presses by
// activating a menubar it contains.
//
// The function returns the following values:
//
//   - ok: TRUE if the window handles F10.
func (window *Window) HandleMenubarAccel() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_handle_menubar_accel(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HideOnClose returns whether the window will be hidden when the close button
// is clicked.
//
// The function returns the following values:
//
//   - ok: TRUE if the window will be hidden.
func (window *Window) HideOnClose() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_hide_on_close(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IconName returns the name of the themed icon for the window.
//
// The function returns the following values:
//
//   - utf8 (optional): icon name or NULL if the window has no themed icon.
func (window *Window) IconName() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_icon_name(_arg0)
	runtime.KeepAlive(window)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// MnemonicsVisible gets whether mnemonics are supposed to be visible.
//
// The function returns the following values:
//
//   - ok: TRUE if mnemonics are supposed to be visible in this window.
func (window *Window) MnemonicsVisible() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_mnemonics_visible(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Modal returns whether the window is modal.
//
// The function returns the following values:
//
//   - ok: TRUE if the window is set to be modal and establishes a grab when
//     shown.
func (window *Window) Modal() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_modal(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Resizable gets the value set by gtk_window_set_resizable().
//
// The function returns the following values:
//
//   - ok: TRUE if the user can resize the window.
func (window *Window) Resizable() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_resizable(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Title retrieves the title of the window.
//
// The function returns the following values:
//
//   - utf8 (optional): title of the window, or NULL if none has been set
//     explicitly. The returned string is owned by the widget and must not be
//     modified or freed.
func (window *Window) Title() string {
	var _arg0 *C.GtkWindow // out
	var _cret *C.char      // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_title(_arg0)
	runtime.KeepAlive(window)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
//
// The function returns the following values:
//
//   - widget (optional): custom titlebar, or NULL.
func (window *Window) Titlebar() Widgetter {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWidget // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_titlebar(_arg0)
	runtime.KeepAlive(window)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// TransientFor fetches the transient parent for this window.
//
// The function returns the following values:
//
//   - ret (optional): transient parent for this window, or NULL if no transient
//     parent has been set.
func (window *Window) TransientFor() *Window {
	var _arg0 *C.GtkWindow // out
	var _cret *C.GtkWindow // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_get_transient_for(_arg0)
	runtime.KeepAlive(window)

	var _ret *Window // out

	if _cret != nil {
		_ret = wrapWindow(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ret
}

// HasGroup returns whether window has an explicit window group.
//
// The function returns the following values:
//
//   - ok: TRUE if window has an explicit window group.
func (window *Window) HasGroup() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_has_group(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsActive returns whether the window is part of the current active toplevel.
//
// The active toplevel is the window receiving keystrokes.
//
// The return value is TRUE if the window is active toplevel itself. You might
// use this function if you wanted to draw a widget differently in an active
// window from a widget in an inactive window.
//
// The function returns the following values:
//
//   - ok: TRUE if the window part of the current active window.
func (window *Window) IsActive() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_is_active(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsFullscreen retrieves the current fullscreen state of window.
//
// Note that since fullscreening is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk.Window.Fullscreen() or gtk.Window.Unfullscreen().
//
// If the window isn't yet mapped, the value returned will whether the initial
// requested state is fullscreen.
//
// The function returns the following values:
//
//   - ok: whether the window has a fullscreen state.
func (window *Window) IsFullscreen() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_is_fullscreen(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsMaximized retrieves the current maximized state of window.
//
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldn’t assume the
// return value of this function changing immediately (or at all), as an effect
// of calling gtk.Window.Maximize() or gtk.Window.Unmaximize().
//
// If the window isn't yet mapped, the value returned will whether the initial
// requested state is maximized.
//
// The function returns the following values:
//
//   - ok: whether the window has a maximized state.
func (window *Window) IsMaximized() bool {
	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C.gtk_window_is_maximized(_arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Maximize asks to maximize window, so that it fills the screen.
//
// Note that you shouldn’t assume the window is definitely maximized afterward,
// because other entities (e.g. the user or window manager could unmaximize it
// again, and not all window managers support maximization.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications on the gtk.Window:maximized
// property.
func (window *Window) Maximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_maximize(_arg0)
	runtime.KeepAlive(window)
}

// Minimize asks to minimize the specified window.
//
// Note that you shouldn’t assume the window is definitely minimized afterward,
// because the windowing system might not support this functionality; other
// entities (e.g. the user or the window manager could unminimize it again, or
// there may not be a window manager in which case minimization isn’t possible,
// etc.
//
// It’s permitted to call this function before showing a window, in which case
// the window will be minimized before it ever appears onscreen.
//
// You can track result of this operation via the gdk.Toplevel:state property.
func (window *Window) Minimize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_minimize(_arg0)
	runtime.KeepAlive(window)
}

// Present presents a window to the user.
//
// This function should not be used as when it is called, it is too late
// to gather a valid timestamp to allow focus stealing prevention to work
// correctly.
func (window *Window) Present() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_present(_arg0)
	runtime.KeepAlive(window)
}

// PresentWithTime presents a window to the user.
//
// This may mean raising the window in the stacking order, unminimizing it,
// moving it to the current desktop, and/or giving it the keyboard focus,
// possibly dependent on the user’s platform, window manager, and preferences.
//
// If window is hidden, this function calls gtk.Widget.Show() as well.
//
// This function should be used when the user tries to open a window that’s
// already open. Say for example the preferences dialog is currently open,
// and the user chooses Preferences from the menu a second time; use
// gtk.Window.Present() to move the already-open dialog where the user can see
// it.
//
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
//
// The function takes the following parameters:
//
//   - timestamp of the user interaction (typically a button or key press event)
//     which triggered this call.
func (window *Window) PresentWithTime(timestamp uint32) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.guint32    // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.guint32(timestamp)

	C.gtk_window_present_with_time(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(timestamp)
}

// SetApplication sets or unsets the GtkApplication associated with the window.
//
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
//
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the application to NULL.
//
// This is equivalent to calling gtk.Application.RemoveWindow() and/or
// gtk.Application.AddWindow() on the old/new applications as relevant.
//
// The function takes the following parameters:
//
//   - application (optional): GtkApplication, or NULL to unset.
func (window *Window) SetApplication(application *Application) {
	var _arg0 *C.GtkWindow      // out
	var _arg1 *C.GtkApplication // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if application != nil {
		_arg1 = (*C.GtkApplication)(unsafe.Pointer(coreglib.InternObject(application).Native()))
	}

	C.gtk_window_set_application(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(application)
}

// SetChild sets the child widget of window.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (window *Window) SetChild(child Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_window_set_child(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(child)
}

// SetDecorated sets whether the window should be decorated.
//
// By default, windows are decorated with a title bar, resize controls, etc.
// Some window managers allow GTK to disable these decorations, creating a
// borderless window. If you set the decorated property to FALSE using this
// function, GTK will do its best to convince the window manager not to decorate
// the window. Depending on the system, this function may not have any effect
// when called on a window that is already visible, so you should call it before
// calling gtk.Widget.Show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//   - setting: TRUE to decorate the window.
func (window *Window) SetDecorated(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_decorated(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDefaultSize sets the default size of a window.
//
// If the window’s “natural” size (its size request) is larger than the default,
// the default will be ignored.
//
// Unlike gtk.Widget.SetSizeRequest(), which sets a size request for a widget
// and thus would keep users from shrinking the window, this function only sets
// the initial size, just as if the user had resized the window themselves.
// Users can still shrink the window again as they normally would. Setting a
// default size of -1 means to use the “natural” default size (the size request
// of the window).
//
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
//
// Windows can’t actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for width and height is OK, resulting in a 1x1 default size.
//
// If you use this function to reestablish a previously saved window size,
// note that the appropriate size to save is the one returned by
// gtk.Window.GetDefaultSize(). Using the window allocation directly will not
// work in all circumstances and can lead to growing or shrinking windows.
//
// The function takes the following parameters:
//
//   - width in pixels, or -1 to unset the default width.
//   - height in pixels, or -1 to unset the default height.
func (window *Window) SetDefaultSize(width, height int) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = C.int(width)
	_arg2 = C.int(height)

	C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
	runtime.KeepAlive(window)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
}

// SetDefaultWidget sets the default widget.
//
// The default widget is the widget that is activated when the user presses
// Enter in a dialog (for example).
//
// The function takes the following parameters:
//
//   - defaultWidget (optional): widget to be the default, or NULL to unset the
//     default widget for the toplevel.
func (window *Window) SetDefaultWidget(defaultWidget Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if defaultWidget != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(defaultWidget).Native()))
	}

	C.gtk_window_set_default_widget(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(defaultWidget)
}

// SetDeletable sets whether the window should be deletable.
//
// By default, windows have a close button in the window frame. Some window
// managers allow GTK to disable this button. If you set the deletable property
// to FALSE using this function, GTK will do its best to convince the window
// manager not to show a close button. Depending on the system, this function
// may not have any effect when called on a window that is already visible,
// so you should call it before calling gtk.Widget.Show().
//
// On Windows, this function always works, since there’s no window manager
// policy involved.
//
// The function takes the following parameters:
//
//   - setting: TRUE to decorate the window as deletable.
func (window *Window) SetDeletable(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_deletable(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDestroyWithParent: if setting is TRUE, then destroying the transient
// parent of window will also destroy window itself.
//
// This is useful for dialogs that shouldn’t persist beyond the lifetime of the
// main window they are associated with, for example.
//
// The function takes the following parameters:
//
//   - setting: whether to destroy window with its transient parent.
func (window *Window) SetDestroyWithParent(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetDisplay sets the GdkDisplay where the window is displayed.
//
// If the window is already mapped, it will be unmapped, and then remapped on
// the new display.
//
// The function takes the following parameters:
//
//   - display: GdkDisplay.
func (window *Window) SetDisplay(display *gdk.Display) {
	var _arg0 *C.GtkWindow  // out
	var _arg1 *C.GdkDisplay // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.GdkDisplay)(unsafe.Pointer(coreglib.InternObject(display).Native()))

	C.gtk_window_set_display(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(display)
}

// SetFocus sets the focus widget.
//
// If focus is not the current focus widget, and is focusable, sets it as the
// focus widget for the window. If focus is NULL, unsets the focus widget
// for this window. To set the focus to a particular widget in the toplevel,
// it is usually more convenient to use gtk.Widget.GrabFocus() instead of this
// function.
//
// The function takes the following parameters:
//
//   - focus (optional): widget to be the new focus widget, or NULL to unset any
//     focus widget for the toplevel window.
func (window *Window) SetFocus(focus Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if focus != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(focus).Native()))
	}

	C.gtk_window_set_focus(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(focus)
}

// SetFocusVisible sets whether “focus rectangles” are supposed to be visible.
//
// The function takes the following parameters:
//
//   - setting: new value.
func (window *Window) SetFocusVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_focus_visible(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetHandleMenubarAccel sets whether this window should react to F10 key
// presses by activating a menubar it contains.
//
// The function takes the following parameters:
//
//   - handleMenubarAccel: TRUE to make window handle F10.
func (window *Window) SetHandleMenubarAccel(handleMenubarAccel bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if handleMenubarAccel {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_handle_menubar_accel(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(handleMenubarAccel)
}

// SetHideOnClose: if setting is TRUE, then clicking the close button on the
// window will not destroy it, but only hide it.
//
// The function takes the following parameters:
//
//   - setting: whether to hide the window when it is closed.
func (window *Window) SetHideOnClose(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_hide_on_close(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetIconName sets the icon for the window from a named themed icon.
//
// See the docs for gtk.IconTheme for more details. On some platforms, the
// window icon is not used at all.
//
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
//
// The function takes the following parameters:
//
//   - name (optional) of the themed icon.
func (window *Window) SetIconName(name string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_window_set_icon_name(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(name)
}

// SetMnemonicsVisible sets whether mnemonics are supposed to be visible.
//
// The function takes the following parameters:
//
//   - setting: new value.
func (window *Window) SetMnemonicsVisible(setting bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(setting)
}

// SetModal sets a window modal or non-modal.
//
// Modal windows prevent interaction with other windows in the same
// application. To keep modal dialogs on top of main application windows,
// use gtk.Window.SetTransientFor() to make the dialog transient for the parent;
// most window managers will then disallow lowering the dialog below the parent.
//
// The function takes the following parameters:
//
//   - modal: whether the window is modal.
func (window *Window) SetModal(modal bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if modal {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_modal(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(modal)
}

// SetResizable sets whether the user can resize a window.
//
// Windows are user resizable by default.
//
// The function takes the following parameters:
//
//   - resizable: TRUE if the user can resize this window.
func (window *Window) SetResizable(resizable bool) {
	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if resizable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_resizable(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(resizable)
}

// SetStartupID sets the startup notification ID.
//
// Startup notification identifiers are used by desktop environment to track
// application startup, to provide user feedback and other features. This
// function changes the corresponding property on the underlying GdkSurface.
//
// Normally, startup identifier is managed automatically and you should only use
// this function in special cases like transferring focus from other processes.
// You should use this function before calling gtk.Window.Present() or any
// equivalent function generating a window map event.
//
// This function is only useful on X11, not with other GTK targets.
//
// The function takes the following parameters:
//
//   - startupId: string with startup-notification identifier.
func (window *Window) SetStartupID(startupId string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(startupId)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_startup_id(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(startupId)
}

// SetTitle sets the title of the GtkWindow.
//
// The title of a window will be displayed in its title bar; on the X Window
// System, the title bar is rendered by the window manager so exactly how the
// title appears to users may vary according to a user’s exact configuration.
// The title should help a user distinguish this window from other windows they
// may have open. A good title might include the application name and current
// document filename, for example.
//
// Passing NULL does the same as setting the title to an empty string.
//
// The function takes the following parameters:
//
//   - title (optional) of the window.
func (window *Window) SetTitle(title string) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.char      // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if title != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(title)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_window_set_title(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(title)
}

// SetTitlebar sets a custom titlebar for window.
//
// A typical widget used here is gtk.HeaderBar, as it provides various features
// expected of a titlebar while allowing the addition of child widgets to it.
//
// If you set a custom titlebar, GTK will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling gtk.Widget.Show().
//
// The function takes the following parameters:
//
//   - titlebar (optional): widget to use as titlebar.
func (window *Window) SetTitlebar(titlebar Widgetter) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWidget // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if titlebar != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(titlebar).Native()))
	}

	C.gtk_window_set_titlebar(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(titlebar)
}

// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows window managers to
// e.g. keep the dialog on top of the main window, or center the dialog over the
// main window. gtk.Dialog.NewWithButtons and other convenience functions in GTK
// will sometimes call gtk_window_set_transient_for() on your behalf.
//
// Passing NULL for parent unsets the current transient window.
//
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
//
// The function takes the following parameters:
//
//   - parent (optional) window, or NULL.
func (window *Window) SetTransientFor(parent *Window) {
	var _arg0 *C.GtkWindow // out
	var _arg1 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if parent != nil {
		_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native()))
	}

	C.gtk_window_set_transient_for(_arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(parent)
}

// Unfullscreen asks to remove the fullscreen state for window, and return to
// its previous state.
//
// Note that you shouldn’t assume the window is definitely not fullscreen
// afterward, because other entities (e.g. the user or window manager
// could fullscreen it again, and not all window managers honor requests to
// unfullscreen windows; normally the window will end up restored to its normal
// state. Just don’t write code that crashes if not.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications of the gtk.Window:fullscreened
// property.
func (window *Window) Unfullscreen() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_unfullscreen(_arg0)
	runtime.KeepAlive(window)
}

// Unmaximize asks to unmaximize window.
//
// Note that you shouldn’t assume the window is definitely unmaximized
// afterward, because other entities (e.g. the user or window manager maximize
// it again, and not all window managers honor requests to unmaximize.
//
// You can track the result of this operation via the gdk.Toplevel:state
// property, or by listening to notifications on the gtk.Window:maximized
// property.
func (window *Window) Unmaximize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_unmaximize(_arg0)
	runtime.KeepAlive(window)
}

// Unminimize asks to unminimize the specified window.
//
// Note that you shouldn’t assume the window is definitely unminimized
// afterward, because the windowing system might not support this functionality;
// other entities (e.g. the user or the window manager could minimize it again,
// or there may not be a window manager in which case minimization isn’t
// possible, etc.
//
// You can track result of this operation via the gdk.Toplevel:state property.
func (window *Window) Unminimize() {
	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_unminimize(_arg0)
	runtime.KeepAlive(window)
}

func (window *Window) activateDefault() {
	gclass := (*C.GtkWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.activate_default

	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gtk4_Window_virtual_activate_default(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

func (window *Window) activateFocus() {
	gclass := (*C.GtkWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.activate_focus

	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gtk4_Window_virtual_activate_focus(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

func (window *Window) closeRequest() bool {
	gclass := (*C.GtkWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.close_request

	var _arg0 *C.GtkWindow // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	_cret = C._gotk4_gtk4_Window_virtual_close_request(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (window *Window) enableDebugging(toggle bool) bool {
	gclass := (*C.GtkWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.enable_debugging

	var _arg0 *C.GtkWindow // out
	var _arg1 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))
	if toggle {
		_arg1 = C.TRUE
	}

	_cret = C._gotk4_gtk4_Window_virtual_enable_debugging(unsafe.Pointer(fnarg), _arg0, _arg1)
	runtime.KeepAlive(window)
	runtime.KeepAlive(toggle)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (window *Window) keysChanged() {
	gclass := (*C.GtkWindowClass)(coreglib.PeekParentClass(window))
	fnarg := gclass.keys_changed

	var _arg0 *C.GtkWindow // out

	_arg0 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C._gotk4_gtk4_Window_virtual_keys_changed(unsafe.Pointer(fnarg), _arg0)
	runtime.KeepAlive(window)
}

// WindowGetDefaultIconName returns the fallback icon name for windows.
//
// The returned string is owned by GTK and should not be modified. It is only
// valid until the next call to gtk.Window().SetDefaultIconName.
//
// The function returns the following values:
//
//   - utf8 (optional): fallback icon name for windows.
func WindowGetDefaultIconName() string {
	var _cret *C.char // in

	_cret = C.gtk_window_get_default_icon_name()

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// WindowGetToplevels returns a list of all existing toplevel windows.
//
// If you want to iterate through the list and perform actions involving
// callbacks that might destroy the widgets or add new ones, be aware that the
// list of toplevels will change and emit the "items-changed" signal.
//
// The function returns the following values:
//
//   - listModel: list of toplevel widgets.
func WindowGetToplevels() *gio.ListModel {
	var _cret *C.GListModel // in

	_cret = C.gtk_window_get_toplevels()

	var _listModel *gio.ListModel // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_listModel = &gio.ListModel{
			Object: obj,
		}
	}

	return _listModel
}

// WindowListToplevels returns a list of all existing toplevel windows.
//
// The widgets in the list are not individually referenced. If you want
// to iterate through the list and perform actions involving callbacks
// that might destroy the widgets, you must call g_list_foreach (result,
// (GFunc)g_object_ref, NULL) first, and then unref all the widgets afterwards.
//
// The function returns the following values:
//
//   - list of toplevel widgets.
func WindowListToplevels() []Widgetter {
	var _cret *C.GList // in

	_cret = C.gtk_window_list_toplevels()

	var _list []Widgetter // out

	_list = make([]Widgetter, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWidget)(v)
		var dst Widgetter // out
		{
			objptr := unsafe.Pointer(src)
			if objptr == nil {
				panic("object of type gtk.Widgetter is nil")
			}

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			dst = rv
		}
		_list = append(_list, dst)
	})

	return _list
}

// WindowSetAutoStartupNotification sets whether the window should request
// startup notification.
//
// By default, after showing the first GtkWindow, GTK calls
// gdk.Display.NotifyStartupComplete(). Call this function to disable the
// automatic startup notification. You might do this if your first window is a
// splash screen, and you want to delay notification until after your real main
// window has been shown, for example.
//
// In that example, you would disable startup notification temporarily, show
// your splash screen, then re-enable it so that showing the main window would
// automatically result in notification.
//
// The function takes the following parameters:
//
//   - setting: TRUE to automatically do startup notification.
func WindowSetAutoStartupNotification(setting bool) {
	var _arg1 C.gboolean // out

	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_auto_startup_notification(_arg1)
	runtime.KeepAlive(setting)
}

// WindowSetDefaultIconName sets an icon to be used as fallback.
//
// The fallback icon is used for windows that haven't had
// gtk.Window.SetIconName() called on them.
//
// The function takes the following parameters:
//
//   - name of the themed icon.
func WindowSetDefaultIconName(name string) {
	var _arg1 *C.char // out

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_window_set_default_icon_name(_arg1)
	runtime.KeepAlive(name)
}

// WindowSetInteractiveDebugging opens or closes the interactive debugger
// (#interactive-debugging).
//
// The debugger offers access to the widget hierarchy of the application and to
// useful debugging tools.
//
// The function takes the following parameters:
//
//   - enable: TRUE to enable interactive debugging.
func WindowSetInteractiveDebugging(enable bool) {
	var _arg1 C.gboolean // out

	if enable {
		_arg1 = C.TRUE
	}

	C.gtk_window_set_interactive_debugging(_arg1)
	runtime.KeepAlive(enable)
}

// WindowControlsOverrides contains methods that are overridable.
type WindowControlsOverrides struct {
}

func defaultWindowControlsOverrides(v *WindowControls) WindowControlsOverrides {
	return WindowControlsOverrides{}
}

// WindowControls: GtkWindowControls shows window frame controls.
//
// Typical window frame controls are minimize, maximize and close buttons,
// and the window icon.
//
// !An example GtkWindowControls (windowcontrols.png)
//
// GtkWindowControls only displays start or end side of the controls (see
// gtk.WindowControls:side), so it's intended to be always used in pair with
// another GtkWindowControls for the opposite side, for example:
//
//	<object class="GtkBox">
//	  <child>
//	    <object class="GtkWindowControls">
//	      <property name="side">start</property>
//	    </object>
//	  </child>
//
//	  ...
//
//	  <child>
//	    <object class="GtkWindowControls">
//	      <property name="side">end</property>
//	    </object>
//	  </child>
//	</object>
//
// CSS nodes
//
//	windowcontrols
//	├── [image.icon]
//	├── [button.minimize]
//	├── [button.maximize]
//	╰── [button.close]
//
// A GtkWindowControls' CSS node is called windowcontrols. It contains subnodes
// corresponding to each title button. Which of the title buttons exist and
// where they are placed exactly depends on the desktop environment and
// gtk.WindowControls:decoration-layout value.
//
// When gtk.WindowControls:empty is TRUE, it gets the .empty style class.
//
// # Accessibility
//
// GtkWindowControls uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowControls struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*WindowControls)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WindowControls, *WindowControlsClass, WindowControlsOverrides](
		GTypeWindowControls,
		initWindowControlsClass,
		wrapWindowControls,
		defaultWindowControlsOverrides,
	)
}

func initWindowControlsClass(gclass unsafe.Pointer, overrides WindowControlsOverrides, classInitFunc func(*WindowControlsClass)) {
	if classInitFunc != nil {
		class := (*WindowControlsClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWindowControls(obj *coreglib.Object) *WindowControls {
	return &WindowControls{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalWindowControls(p uintptr) (interface{}, error) {
	return wrapWindowControls(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWindowControls creates a new GtkWindowControls.
//
// The function takes the following parameters:
//
//   - side: side.
//
// The function returns the following values:
//
//   - windowControls: new GtkWindowControls.
func NewWindowControls(side PackType) *WindowControls {
	var _arg1 C.GtkPackType // out
	var _cret *C.GtkWidget  // in

	_arg1 = C.GtkPackType(side)

	_cret = C.gtk_window_controls_new(_arg1)
	runtime.KeepAlive(side)

	var _windowControls *WindowControls // out

	_windowControls = wrapWindowControls(coreglib.Take(unsafe.Pointer(_cret)))

	return _windowControls
}

// DecorationLayout gets the decoration layout of this GtkWindowControls.
//
// The function returns the following values:
//
//   - utf8 (optional): decoration layout or NULL if it is unset.
func (self *WindowControls) DecorationLayout() string {
	var _arg0 *C.GtkWindowControls // out
	var _cret *C.char              // in

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_window_controls_get_decoration_layout(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	}

	return _utf8
}

// Empty gets whether the widget has any window buttons.
//
// The function returns the following values:
//
//   - ok: TRUE if the widget has window buttons, otherwise FALSE.
func (self *WindowControls) Empty() bool {
	var _arg0 *C.GtkWindowControls // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_window_controls_get_empty(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Side gets the side to which this GtkWindowControls instance belongs.
//
// The function returns the following values:
//
//   - packType: side.
func (self *WindowControls) Side() PackType {
	var _arg0 *C.GtkWindowControls // out
	var _cret C.GtkPackType        // in

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_window_controls_get_side(_arg0)
	runtime.KeepAlive(self)

	var _packType PackType // out

	_packType = PackType(_cret)

	return _packType
}

// SetDecorationLayout sets the decoration layout for the title buttons.
//
// This overrides the gtk.Settings:gtk-decoration-layout setting.
//
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the right.
// Recognized button names are minimize, maximize, close and icon (the window
// icon).
//
// For example, “icon:minimize,maximize,close” specifies a icon on the left,
// and minimize, maximize and close buttons on the right.
//
// If gtk.WindowControls:side value is GTK_PACK_START, self will display the
// part before the colon, otherwise after that.
//
// The function takes the following parameters:
//
//   - layout (optional): decoration layout, or NULL to unset the layout.
func (self *WindowControls) SetDecorationLayout(layout string) {
	var _arg0 *C.GtkWindowControls // out
	var _arg1 *C.char              // out

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if layout != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(layout)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	C.gtk_window_controls_set_decoration_layout(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(layout)
}

// SetSide determines which part of decoration layout the GtkWindowControls
// uses.
//
// See gtk.WindowControls:decoration-layout.
//
// The function takes the following parameters:
//
//   - side: side.
func (self *WindowControls) SetSide(side PackType) {
	var _arg0 *C.GtkWindowControls // out
	var _arg1 C.GtkPackType        // out

	_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	_arg1 = C.GtkPackType(side)

	C.gtk_window_controls_set_side(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(side)
}

// WindowGroupOverrides contains methods that are overridable.
type WindowGroupOverrides struct {
}

func defaultWindowGroupOverrides(v *WindowGroup) WindowGroupOverrides {
	return WindowGroupOverrides{}
}

// WindowGroup: GtkWindowGroup makes group of windows behave like separate
// applications.
//
// It achieves this by limiting the effect of GTK grabs and modality to windows
// in the same group.
//
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
//
// GtkWindowGroup objects are referenced by each window in the group, so once
// you have added all windows to a GtkWindowGroup, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
type WindowGroup struct {
	_ [0]func() // equal guard
	*coreglib.Object
}

var (
	_ coreglib.Objector = (*WindowGroup)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WindowGroup, *WindowGroupClass, WindowGroupOverrides](
		GTypeWindowGroup,
		initWindowGroupClass,
		wrapWindowGroup,
		defaultWindowGroupOverrides,
	)
}

func initWindowGroupClass(gclass unsafe.Pointer, overrides WindowGroupOverrides, classInitFunc func(*WindowGroupClass)) {
	if classInitFunc != nil {
		class := (*WindowGroupClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWindowGroup(obj *coreglib.Object) *WindowGroup {
	return &WindowGroup{
		Object: obj,
	}
}

func marshalWindowGroup(p uintptr) (interface{}, error) {
	return wrapWindowGroup(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWindowGroup creates a new GtkWindowGroup object.
//
// Modality of windows only affects windows within the same GtkWindowGroup.
//
// The function returns the following values:
//
//   - windowGroup: new GtkWindowGroup.
func NewWindowGroup() *WindowGroup {
	var _cret *C.GtkWindowGroup // in

	_cret = C.gtk_window_group_new()

	var _windowGroup *WindowGroup // out

	_windowGroup = wrapWindowGroup(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _windowGroup
}

// AddWindow adds a window to a GtkWindowGroup.
//
// The function takes the following parameters:
//
//   - window: GtkWindow to add.
func (windowGroup *WindowGroup) AddWindow(window *Window) {
	var _arg0 *C.GtkWindowGroup // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(coreglib.InternObject(windowGroup).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_group_add_window(_arg0, _arg1)
	runtime.KeepAlive(windowGroup)
	runtime.KeepAlive(window)
}

// ListWindows returns a list of the GtkWindows that belong to window_group.
//
// The function returns the following values:
//
//   - list: a newly-allocated list of windows inside the group.
func (windowGroup *WindowGroup) ListWindows() []*Window {
	var _arg0 *C.GtkWindowGroup // out
	var _cret *C.GList          // in

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(coreglib.InternObject(windowGroup).Native()))

	_cret = C.gtk_window_group_list_windows(_arg0)
	runtime.KeepAlive(windowGroup)

	var _list []*Window // out

	_list = make([]*Window, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkWindow)(v)
		var dst *Window // out
		dst = wrapWindow(coreglib.Take(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// RemoveWindow removes a window from a GtkWindowGroup.
//
// The function takes the following parameters:
//
//   - window: GtkWindow to remove.
func (windowGroup *WindowGroup) RemoveWindow(window *Window) {
	var _arg0 *C.GtkWindowGroup // out
	var _arg1 *C.GtkWindow      // out

	_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(coreglib.InternObject(windowGroup).Native()))
	_arg1 = (*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(window).Native()))

	C.gtk_window_group_remove_window(_arg0, _arg1)
	runtime.KeepAlive(windowGroup)
	runtime.KeepAlive(window)
}

// WindowHandleOverrides contains methods that are overridable.
type WindowHandleOverrides struct {
}

func defaultWindowHandleOverrides(v *WindowHandle) WindowHandleOverrides {
	return WindowHandleOverrides{}
}

// WindowHandle: GtkWindowHandle is a titlebar area widget.
//
// When added into a window, it can be dragged to move the window, and handles
// right click, double click and middle click as expected of a titlebar.
//
// # CSS nodes
//
// GtkWindowHandle has a single CSS node with the name windowhandle.
//
// # Accessibility
//
// GtkWindowHandle uses the GTK_ACCESSIBLE_ROLE_GROUP role.
type WindowHandle struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*WindowHandle)(nil)
)

func init() {
	coreglib.RegisterClassInfo[*WindowHandle, *WindowHandleClass, WindowHandleOverrides](
		GTypeWindowHandle,
		initWindowHandleClass,
		wrapWindowHandle,
		defaultWindowHandleOverrides,
	)
}

func initWindowHandleClass(gclass unsafe.Pointer, overrides WindowHandleOverrides, classInitFunc func(*WindowHandleClass)) {
	if classInitFunc != nil {
		class := (*WindowHandleClass)(gextras.NewStructNative(gclass))
		classInitFunc(class)
	}
}

func wrapWindowHandle(obj *coreglib.Object) *WindowHandle {
	return &WindowHandle{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalWindowHandle(p uintptr) (interface{}, error) {
	return wrapWindowHandle(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewWindowHandle creates a new GtkWindowHandle.
//
// The function returns the following values:
//
//   - windowHandle: new GtkWindowHandle.
func NewWindowHandle() *WindowHandle {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_window_handle_new()

	var _windowHandle *WindowHandle // out

	_windowHandle = wrapWindowHandle(coreglib.Take(unsafe.Pointer(_cret)))

	return _windowHandle
}

// Child gets the child widget of self.
//
// The function returns the following values:
//
//   - widget (optional): child widget of self.
func (self *WindowHandle) Child() Widgetter {
	var _arg0 *C.GtkWindowHandle // out
	var _cret *C.GtkWidget       // in

	_arg0 = (*C.GtkWindowHandle)(unsafe.Pointer(coreglib.InternObject(self).Native()))

	_cret = C.gtk_window_handle_get_child(_arg0)
	runtime.KeepAlive(self)

	var _widget Widgetter // out

	if _cret != nil {
		{
			objptr := unsafe.Pointer(_cret)

			object := coreglib.Take(objptr)
			casted := object.WalkCast(func(obj coreglib.Objector) bool {
				_, ok := obj.(Widgetter)
				return ok
			})
			rv, ok := casted.(Widgetter)
			if !ok {
				panic("no marshaler for " + object.TypeFromInstance().String() + " matching gtk.Widgetter")
			}
			_widget = rv
		}
	}

	return _widget
}

// SetChild sets the child widget of self.
//
// The function takes the following parameters:
//
//   - child (optional) widget.
func (self *WindowHandle) SetChild(child Widgetter) {
	var _arg0 *C.GtkWindowHandle // out
	var _arg1 *C.GtkWidget       // out

	_arg0 = (*C.GtkWindowHandle)(unsafe.Pointer(coreglib.InternObject(self).Native()))
	if child != nil {
		_arg1 = (*C.GtkWidget)(unsafe.Pointer(coreglib.InternObject(child).Native()))
	}

	C.gtk_window_handle_set_child(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(child)
}

// ActionableInterface: interface vtable for GtkActionable.
//
// An instance of this type is always passed by reference.
type ActionableInterface struct {
	*actionableInterface
}

// actionableInterface is the struct that's finalized.
type actionableInterface struct {
	native *C.GtkActionableInterface
}

// AdjustmentClass: instance of this type is always passed by reference.
type AdjustmentClass struct {
	*adjustmentClass
}

// adjustmentClass is the struct that's finalized.
type adjustmentClass struct {
	native *C.GtkAdjustmentClass
}

// ApplicationClass: instance of this type is always passed by reference.
type ApplicationClass struct {
	*applicationClass
}

// applicationClass is the struct that's finalized.
type applicationClass struct {
	native *C.GtkApplicationClass
}

// ParentClass: parent class.
func (a *ApplicationClass) ParentClass() *gio.ApplicationClass {
	valptr := &a.native.parent_class
	var _v *gio.ApplicationClass // out
	_v = (*gio.ApplicationClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ApplicationWindowClass: instance of this type is always passed by reference.
type ApplicationWindowClass struct {
	*applicationWindowClass
}

// applicationWindowClass is the struct that's finalized.
type applicationWindowClass struct {
	native *C.GtkApplicationWindowClass
}

// ParentClass: parent class.
func (a *ApplicationWindowClass) ParentClass() *WindowClass {
	valptr := &a.native.parent_class
	var _v *WindowClass // out
	_v = (*WindowClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// BinLayoutClass: instance of this type is always passed by reference.
type BinLayoutClass struct {
	*binLayoutClass
}

// binLayoutClass is the struct that's finalized.
type binLayoutClass struct {
	native *C.GtkBinLayoutClass
}

func (b *BinLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &b.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Bitset: GtkBitset represents a set of unsigned integers.
//
// Another name for this data structure is "bitmap".
//
// The current implementation is based on roaring bitmaps
// (https://roaringbitmap.org/).
//
// A bitset allows adding a set of integers and provides support for set
// operations like unions, intersections and checks for equality or if a value
// is contained in the set. GtkBitset also contains various functions to query
// metadata about the bitset, such as the minimum or maximum values or its size.
//
// The fastest way to iterate values in a bitset is gtk.BitsetIter.
//
// The main use case for GtkBitset is implementing complex selections for
// gtk.SelectionModel.
//
// An instance of this type is always passed by reference.
type Bitset struct {
	*bitset
}

// bitset is the struct that's finalized.
type bitset struct {
	native *C.GtkBitset
}

func marshalBitset(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Bitset{&bitset{(*C.GtkBitset)(b)}}, nil
}

// NewBitsetEmpty constructs a struct Bitset.
func NewBitsetEmpty() *Bitset {
	var _cret *C.GtkBitset // in

	_cret = C.gtk_bitset_new_empty()

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_bitset_unref((*C.GtkBitset)(intern.C))
		},
	)

	return _bitset
}

// NewBitsetRange constructs a struct Bitset.
func NewBitsetRange(start uint, nItems uint) *Bitset {
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _cret *C.GtkBitset // in

	_arg1 = C.guint(start)
	_arg2 = C.guint(nItems)

	_cret = C.gtk_bitset_new_range(_arg1, _arg2)
	runtime.KeepAlive(start)
	runtime.KeepAlive(nItems)

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_bitset_unref((*C.GtkBitset)(intern.C))
		},
	)

	return _bitset
}

// Add adds value to self if it wasn't part of it before.
//
// The function takes the following parameters:
//
//   - value to add.
//
// The function returns the following values:
//
//   - ok: TRUE if value was not part of self and self was changed.
func (self *Bitset) Add(value uint) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(value)

	_cret = C.gtk_bitset_add(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// AddRange adds all values from start (inclusive) to start + n_items
// (exclusive) in self.
//
// The function takes the following parameters:
//
//   - start: first value to add.
//   - nItems: number of consecutive values to add.
func (self *Bitset) AddRange(start uint, nItems uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(start)
	_arg2 = C.guint(nItems)

	C.gtk_bitset_add_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(start)
	runtime.KeepAlive(nItems)
}

// AddRangeClosed adds the closed range [first, last], so first, last and all
// values in between. first must be smaller than last.
//
// The function takes the following parameters:
//
//   - first value to add.
//   - last value to add.
func (self *Bitset) AddRangeClosed(first uint, last uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(first)
	_arg2 = C.guint(last)

	C.gtk_bitset_add_range_closed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(first)
	runtime.KeepAlive(last)
}

// AddRectangle interprets the values as a 2-dimensional boolean grid with the
// given stride and inside that grid, adds a rectangle with the given width and
// height.
//
// The function takes the following parameters:
//
//   - start: first value to add.
//   - width of the rectangle.
//   - height of the rectangle.
//   - stride: row stride of the grid.
func (self *Bitset) AddRectangle(start uint, width uint, height uint, stride uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out
	var _arg4 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(start)
	_arg2 = C.guint(width)
	_arg3 = C.guint(height)
	_arg4 = C.guint(stride)

	C.gtk_bitset_add_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(start)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(stride)
}

// Contains checks if the given value has been added to self.
//
// The function takes the following parameters:
//
//   - value to check.
//
// The function returns the following values:
//
//   - ok: TRUE if self contains value.
func (self *Bitset) Contains(value uint) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(value)

	_cret = C.gtk_bitset_contains(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy creates a copy of self.
//
// The function returns the following values:
//
//   - bitset: new bitset that contains the same values as self.
func (self *Bitset) Copy() *Bitset {
	var _arg0 *C.GtkBitset // out
	var _cret *C.GtkBitset // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gtk_bitset_copy(_arg0)
	runtime.KeepAlive(self)

	var _bitset *Bitset // out

	_bitset = (*Bitset)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bitset)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_bitset_unref((*C.GtkBitset)(intern.C))
		},
	)

	return _bitset
}

// Difference sets self to be the symmetric difference of self and other.
//
// The symmetric difference is set self to contain all values that were either
// contained in self or in other, but not in both. This operation is also called
// an XOR.
//
// It is allowed for self and other to be the same bitset. The bitset will be
// emptied in that case.
//
// The function takes the following parameters:
//
//   - other: GtkBitset to compute the difference from.
func (self *Bitset) Difference(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(other)))

	C.gtk_bitset_difference(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(other)
}

// Equals returns TRUE if self and other contain the same values.
//
// The function takes the following parameters:
//
//   - other GtkBitset.
//
// The function returns the following values:
//
//   - ok: TRUE if self and other contain the same values.
func (self *Bitset) Equals(other *Bitset) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(other)))

	_cret = C.gtk_bitset_equals(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(other)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Maximum returns the largest value in self.
//
// If self is empty, 0 is returned.
//
// The function returns the following values:
//
//   - guint: largest value in self.
func (self *Bitset) Maximum() uint {
	var _arg0 *C.GtkBitset // out
	var _cret C.guint      // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gtk_bitset_get_maximum(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Minimum returns the smallest value in self.
//
// If self is empty, G_MAXUINT is returned.
//
// The function returns the following values:
//
//   - guint: smallest value in self.
func (self *Bitset) Minimum() uint {
	var _arg0 *C.GtkBitset // out
	var _cret C.guint      // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gtk_bitset_get_minimum(_arg0)
	runtime.KeepAlive(self)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Nth returns the value of the nth item in self.
//
// If nth is >= the size of self, 0 is returned.
//
// The function takes the following parameters:
//
//   - nth: index of the item to get.
//
// The function returns the following values:
//
//   - guint: value of the nth item in self.
func (self *Bitset) Nth(nth uint) uint {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.guint      // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(nth)

	_cret = C.gtk_bitset_get_nth(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(nth)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Size gets the number of values that were added to the set.
//
// For example, if the set is empty, 0 is returned.
//
// Note that this function returns a guint64, because when all values are set,
// the return value is G_MAXUINT + 1. Unless you are sure this cannot happen (it
// can't with GListModel), be sure to use a 64bit type.
//
// The function returns the following values:
//
//   - guint64: number of values in the set.
func (self *Bitset) Size() uint64 {
	var _arg0 *C.GtkBitset // out
	var _cret C.guint64    // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gtk_bitset_get_size(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// SizeInRange gets the number of values that are part of the set from first to
// last (inclusive).
//
// Note that this function returns a guint64, because when all values are set,
// the return value is G_MAXUINT + 1. Unless you are sure this cannot happen (it
// can't with GListModel), be sure to use a 64bit type.
//
// The function takes the following parameters:
//
//   - first element to include.
//   - last element to include.
//
// The function returns the following values:
//
//   - guint64: number of values in the set from first to last.
func (self *Bitset) SizeInRange(first uint, last uint) uint64 {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _cret C.guint64    // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(first)
	_arg2 = C.guint(last)

	_cret = C.gtk_bitset_get_size_in_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(first)
	runtime.KeepAlive(last)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Intersect sets self to be the intersection of self and other.
//
// In other words, remove all values from self that are not part of other.
//
// It is allowed for self and other to be the same bitset. Nothing will happen
// in that case.
//
// The function takes the following parameters:
//
//   - other: GtkBitset to intersect with.
func (self *Bitset) Intersect(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(other)))

	C.gtk_bitset_intersect(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(other)
}

// IsEmpty: check if no value is contained in bitset.
//
// The function returns the following values:
//
//   - ok: TRUE if self is empty.
func (self *Bitset) IsEmpty() bool {
	var _arg0 *C.GtkBitset // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))

	_cret = C.gtk_bitset_is_empty(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Remove removes value from self if it was part of it before.
//
// The function takes the following parameters:
//
//   - value to add.
//
// The function returns the following values:
//
//   - ok: TRUE if value was part of self and self was changed.
func (self *Bitset) Remove(value uint) bool {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _cret C.gboolean   // in

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(value)

	_cret = C.gtk_bitset_remove(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RemoveAll removes all values from the bitset so that it is empty again.
func (self *Bitset) RemoveAll() {
	var _arg0 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))

	C.gtk_bitset_remove_all(_arg0)
	runtime.KeepAlive(self)
}

// RemoveRange removes all values from start (inclusive) to start + n_items
// (exclusive) in self.
//
// The function takes the following parameters:
//
//   - start: first value to remove.
//   - nItems: number of consecutive values to remove.
func (self *Bitset) RemoveRange(start uint, nItems uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(start)
	_arg2 = C.guint(nItems)

	C.gtk_bitset_remove_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(start)
	runtime.KeepAlive(nItems)
}

// RemoveRangeClosed removes the closed range [first, last], so first, last and
// all values in between. first must be smaller than last.
//
// The function takes the following parameters:
//
//   - first value to remove.
//   - last value to remove.
func (self *Bitset) RemoveRangeClosed(first uint, last uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(first)
	_arg2 = C.guint(last)

	C.gtk_bitset_remove_range_closed(_arg0, _arg1, _arg2)
	runtime.KeepAlive(self)
	runtime.KeepAlive(first)
	runtime.KeepAlive(last)
}

// RemoveRectangle interprets the values as a 2-dimensional boolean grid with
// the given stride and inside that grid, removes a rectangle with the given
// width and height.
//
// The function takes the following parameters:
//
//   - start: first value to remove.
//   - width of the rectangle.
//   - height of the rectangle.
//   - stride: row stride of the grid.
func (self *Bitset) RemoveRectangle(start uint, width uint, height uint, stride uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out
	var _arg4 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(start)
	_arg2 = C.guint(width)
	_arg3 = C.guint(height)
	_arg4 = C.guint(stride)

	C.gtk_bitset_remove_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(start)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(stride)
}

// ShiftLeft shifts all values in self to the left by amount.
//
// Values smaller than amount are discarded.
//
// The function takes the following parameters:
//
//   - amount to shift all values to the left.
func (self *Bitset) ShiftLeft(amount uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(amount)

	C.gtk_bitset_shift_left(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(amount)
}

// ShiftRight shifts all values in self to the right by amount.
//
// Values that end up too large to be held in a #guint are discarded.
//
// The function takes the following parameters:
//
//   - amount to shift all values to the right.
func (self *Bitset) ShiftRight(amount uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(amount)

	C.gtk_bitset_shift_right(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(amount)
}

// Splice: this is a support function for GListModel handling, by mirroring the
// GlistModel::items-changed signal.
//
// First, it "cuts" the values from position to removed from the bitset.
// That is, it removes all those values and shifts all larger values to the left
// by removed places.
//
// Then, it "pastes" new room into the bitset by shifting all values larger than
// position by added spaces to the right. This frees up space that can then be
// filled.
//
// The function takes the following parameters:
//
//   - position at which to slice.
//   - removed: number of values to remove.
//   - added: number of values to add.
func (self *Bitset) Splice(position uint, removed uint, added uint) {
	var _arg0 *C.GtkBitset // out
	var _arg1 C.guint      // out
	var _arg2 C.guint      // out
	var _arg3 C.guint      // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = C.guint(position)
	_arg2 = C.guint(removed)
	_arg3 = C.guint(added)

	C.gtk_bitset_splice(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(self)
	runtime.KeepAlive(position)
	runtime.KeepAlive(removed)
	runtime.KeepAlive(added)
}

// Subtract sets self to be the subtraction of other from self.
//
// In other words, remove all values from self that are part of other.
//
// It is allowed for self and other to be the same bitset. The bitset will be
// emptied in that case.
//
// The function takes the following parameters:
//
//   - other: GtkBitset to subtract.
func (self *Bitset) Subtract(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(other)))

	C.gtk_bitset_subtract(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(other)
}

// Union sets self to be the union of self and other.
//
// That is, add all values from other into self that weren't part of it.
//
// It is allowed for self and other to be the same bitset. Nothing will happen
// in that case.
//
// The function takes the following parameters:
//
//   - other: GtkBitset to union with.
func (self *Bitset) Union(other *Bitset) {
	var _arg0 *C.GtkBitset // out
	var _arg1 *C.GtkBitset // out

	_arg0 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(self)))
	_arg1 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(other)))

	C.gtk_bitset_union(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(other)
}

// BitsetIter: opaque, stack-allocated struct for iterating over the elements of
// a GtkBitset.
//
// Before a GtkBitsetIter can be used, it needs to be initialized
// with gtk.BitsetIter().InitFirst, gtk.BitsetIter().InitLast or
// gtk.BitsetIter().InitAt.
//
// An instance of this type is always passed by reference.
type BitsetIter struct {
	*bitsetIter
}

// bitsetIter is the struct that's finalized.
type bitsetIter struct {
	native *C.GtkBitsetIter
}

// Value gets the current value that iter points to.
//
// If iter is not valid and gtk.BitsetIter.IsValid() returns FALSE, this
// function returns 0.
//
// The function returns the following values:
//
//   - guint: current value pointer to by iter.
func (iter *BitsetIter) Value() uint {
	var _arg0 *C.GtkBitsetIter // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkBitsetIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_bitset_iter_get_value(_arg0)
	runtime.KeepAlive(iter)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// IsValid checks if iter points to a valid value.
//
// The function returns the following values:
//
//   - ok: TRUE if iter points to a valid value.
func (iter *BitsetIter) IsValid() bool {
	var _arg0 *C.GtkBitsetIter // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBitsetIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_bitset_iter_is_valid(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next moves iter to the next value in the set.
//
// If it was already pointing to the last value in the set, FALSE is returned
// and iter is invalidated.
//
// The function returns the following values:
//
//   - value (optional): set to the next value.
//   - ok: TRUE if a next value existed.
func (iter *BitsetIter) Next() (uint, bool) {
	var _arg0 *C.GtkBitsetIter // out
	var _arg1 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBitsetIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_bitset_iter_next(_arg0, &_arg1)
	runtime.KeepAlive(iter)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// Previous moves iter to the previous value in the set.
//
// If it was already pointing to the first value in the set, FALSE is returned
// and iter is invalidated.
//
// The function returns the following values:
//
//   - value (optional): set to the previous value.
//   - ok: TRUE if a previous value existed.
func (iter *BitsetIter) Previous() (uint, bool) {
	var _arg0 *C.GtkBitsetIter // out
	var _arg1 C.guint          // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkBitsetIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_bitset_iter_previous(_arg0, &_arg1)
	runtime.KeepAlive(iter)

	var _value uint // out
	var _ok bool    // out

	_value = uint(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _value, _ok
}

// BitsetIterInitAt initializes iter to point to target.
//
// If target is not found, finds the next value after it. If no value >= target
// exists in set, this function returns FALSE.
//
// The function takes the following parameters:
//
//   - set: GtkBitset.
//   - target value to start iterating at.
//
// The function returns the following values:
//
//   - iter: pointer to an uninitialized GtkBitsetIter.
//   - value (optional): set to the found value in set.
//   - ok: TRUE if a value was found.
func BitsetIterInitAt(set *Bitset, target uint) (*BitsetIter, uint, bool) {
	var _arg1 C.GtkBitsetIter // in
	var _arg2 *C.GtkBitset    // out
	var _arg3 C.guint         // out
	var _arg4 C.guint         // in
	var _cret C.gboolean      // in

	_arg2 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(set)))
	_arg3 = C.guint(target)

	_cret = C.gtk_bitset_iter_init_at(&_arg1, _arg2, _arg3, &_arg4)
	runtime.KeepAlive(set)
	runtime.KeepAlive(target)

	var _iter *BitsetIter // out
	var _value uint       // out
	var _ok bool          // out

	_iter = (*BitsetIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_value = uint(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _value, _ok
}

// BitsetIterInitFirst initializes an iterator for set and points it to the
// first value in set.
//
// If set is empty, FALSE is returned and value is set to G_MAXUINT.
//
// The function takes the following parameters:
//
//   - set: GtkBitset.
//
// The function returns the following values:
//
//   - iter: pointer to an uninitialized GtkBitsetIter.
//   - value (optional): set to the first value in set.
//   - ok: TRUE if set isn't empty.
func BitsetIterInitFirst(set *Bitset) (*BitsetIter, uint, bool) {
	var _arg1 C.GtkBitsetIter // in
	var _arg2 *C.GtkBitset    // out
	var _arg3 C.guint         // in
	var _cret C.gboolean      // in

	_arg2 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(set)))

	_cret = C.gtk_bitset_iter_init_first(&_arg1, _arg2, &_arg3)
	runtime.KeepAlive(set)

	var _iter *BitsetIter // out
	var _value uint       // out
	var _ok bool          // out

	_iter = (*BitsetIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_value = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _value, _ok
}

// BitsetIterInitLast initializes an iterator for set and points it to the last
// value in set.
//
// If set is empty, FALSE is returned.
//
// The function takes the following parameters:
//
//   - set: GtkBitset.
//
// The function returns the following values:
//
//   - iter: pointer to an uninitialized GtkBitsetIter.
//   - value (optional): set to the last value in set.
//   - ok: TRUE if set isn't empty.
func BitsetIterInitLast(set *Bitset) (*BitsetIter, uint, bool) {
	var _arg1 C.GtkBitsetIter // in
	var _arg2 *C.GtkBitset    // out
	var _arg3 C.guint         // in
	var _cret C.gboolean      // in

	_arg2 = (*C.GtkBitset)(gextras.StructNative(unsafe.Pointer(set)))

	_cret = C.gtk_bitset_iter_init_last(&_arg1, _arg2, &_arg3)
	runtime.KeepAlive(set)

	var _iter *BitsetIter // out
	var _value uint       // out
	var _ok bool          // out

	_iter = (*BitsetIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_value = uint(_arg3)
	if _cret != 0 {
		_ok = true
	}

	return _iter, _value, _ok
}

// BookmarkListClass: instance of this type is always passed by reference.
type BookmarkListClass struct {
	*bookmarkListClass
}

// bookmarkListClass is the struct that's finalized.
type bookmarkListClass struct {
	native *C.GtkBookmarkListClass
}

// BoolFilterClass: instance of this type is always passed by reference.
type BoolFilterClass struct {
	*boolFilterClass
}

// boolFilterClass is the struct that's finalized.
type boolFilterClass struct {
	native *C.GtkBoolFilterClass
}

func (b *BoolFilterClass) ParentClass() *FilterClass {
	valptr := &b.native.parent_class
	var _v *FilterClass // out
	_v = (*FilterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// Border: struct that specifies a border around a rectangular area.
//
// Each side can have different width.
//
// An instance of this type is always passed by reference.
type Border struct {
	*border
}

// border is the struct that's finalized.
type border struct {
	native *C.GtkBorder
}

func marshalBorder(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Border{&border{(*C.GtkBorder)(b)}}, nil
}

// NewBorder constructs a struct Border.
func NewBorder() *Border {
	var _cret *C.GtkBorder // in

	_cret = C.gtk_border_new()

	var _border *Border // out

	_border = (*Border)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_border)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_border_free((*C.GtkBorder)(intern.C))
		},
	)

	return _border
}

// Left: width of the left border.
func (b *Border) Left() int16 {
	valptr := &b.native.left
	var _v int16 // out
	_v = int16(*valptr)
	return _v
}

// Right: width of the right border.
func (b *Border) Right() int16 {
	valptr := &b.native.right
	var _v int16 // out
	_v = int16(*valptr)
	return _v
}

// Top: width of the top border.
func (b *Border) Top() int16 {
	valptr := &b.native.top
	var _v int16 // out
	_v = int16(*valptr)
	return _v
}

// Bottom: width of the bottom border.
func (b *Border) Bottom() int16 {
	valptr := &b.native.bottom
	var _v int16 // out
	_v = int16(*valptr)
	return _v
}

// Left: width of the left border.
func (b *Border) SetLeft(left int16) {
	valptr := &b.native.left
	*valptr = C.gint16(left)
}

// Right: width of the right border.
func (b *Border) SetRight(right int16) {
	valptr := &b.native.right
	*valptr = C.gint16(right)
}

// Top: width of the top border.
func (b *Border) SetTop(top int16) {
	valptr := &b.native.top
	*valptr = C.gint16(top)
}

// Bottom: width of the bottom border.
func (b *Border) SetBottom(bottom int16) {
	valptr := &b.native.bottom
	*valptr = C.gint16(bottom)
}

// Copy copies a Border-struct.
//
// The function returns the following values:
//
//   - border: copy of border_.
func (border_ *Border) Copy() *Border {
	var _arg0 *C.GtkBorder // out
	var _cret *C.GtkBorder // in

	_arg0 = (*C.GtkBorder)(gextras.StructNative(unsafe.Pointer(border_)))

	_cret = C.gtk_border_copy(_arg0)
	runtime.KeepAlive(border_)

	var _border *Border // out

	_border = (*Border)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_border)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_border_free((*C.GtkBorder)(intern.C))
		},
	)

	return _border
}

// BoxClass: instance of this type is always passed by reference.
type BoxClass struct {
	*boxClass
}

// boxClass is the struct that's finalized.
type boxClass struct {
	native *C.GtkBoxClass
}

// ParentClass: parent class.
func (b *BoxClass) ParentClass() *WidgetClass {
	valptr := &b.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// BoxLayoutClass: instance of this type is always passed by reference.
type BoxLayoutClass struct {
	*boxLayoutClass
}

// boxLayoutClass is the struct that's finalized.
type boxLayoutClass struct {
	native *C.GtkBoxLayoutClass
}

func (b *BoxLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &b.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// BuildableIface: GtkBuildableIface interface contains methods that are
// necessary to allow GtkBuilder to construct an object from a GtkBuilder UI
// definition.
//
// An instance of this type is always passed by reference.
type BuildableIface struct {
	*buildableIface
}

// buildableIface is the struct that's finalized.
type buildableIface struct {
	native *C.GtkBuildableIface
}

// BuildableParser: sub-parser for GtkBuildable implementations.
//
// An instance of this type is always passed by reference.
type BuildableParser struct {
	*buildableParser
}

// buildableParser is the struct that's finalized.
type buildableParser struct {
	native *C.GtkBuildableParser
}

// BuilderCScopeClass: instance of this type is always passed by reference.
type BuilderCScopeClass struct {
	*builderCScopeClass
}

// builderCScopeClass is the struct that's finalized.
type builderCScopeClass struct {
	native *C.GtkBuilderCScopeClass
}

// BuilderScopeInterface: virtual function table to implement for BuilderScope
// implementations. Default implementations for each function do exist, but they
// usually just fail, so it is suggested that implementations implement all of
// them.
//
// An instance of this type is always passed by reference.
type BuilderScopeInterface struct {
	*builderScopeInterface
}

// builderScopeInterface is the struct that's finalized.
type builderScopeInterface struct {
	native *C.GtkBuilderScopeInterface
}

// ButtonClass: instance of this type is always passed by reference.
type ButtonClass struct {
	*buttonClass
}

// buttonClass is the struct that's finalized.
type buttonClass struct {
	native *C.GtkButtonClass
}

// ParentClass: parent class.
func (b *ButtonClass) ParentClass() *WidgetClass {
	valptr := &b.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CellAreaClass: instance of this type is always passed by reference.
type CellAreaClass struct {
	*cellAreaClass
}

// cellAreaClass is the struct that's finalized.
type cellAreaClass struct {
	native *C.GtkCellAreaClass
}

// CellAreaContextClass: instance of this type is always passed by reference.
type CellAreaContextClass struct {
	*cellAreaContextClass
}

// cellAreaContextClass is the struct that's finalized.
type cellAreaContextClass struct {
	native *C.GtkCellAreaContextClass
}

// CellEditableIface: instance of this type is always passed by reference.
type CellEditableIface struct {
	*cellEditableIface
}

// cellEditableIface is the struct that's finalized.
type cellEditableIface struct {
	native *C.GtkCellEditableIface
}

// CellLayoutIface: instance of this type is always passed by reference.
type CellLayoutIface struct {
	*cellLayoutIface
}

// cellLayoutIface is the struct that's finalized.
type cellLayoutIface struct {
	native *C.GtkCellLayoutIface
}

// CellRendererClass: instance of this type is always passed by reference.
type CellRendererClass struct {
	*cellRendererClass
}

// cellRendererClass is the struct that's finalized.
type cellRendererClass struct {
	native *C.GtkCellRendererClass
}

// CellRendererTextClass: instance of this type is always passed by reference.
type CellRendererTextClass struct {
	*cellRendererTextClass
}

// cellRendererTextClass is the struct that's finalized.
type cellRendererTextClass struct {
	native *C.GtkCellRendererTextClass
}

func (c *CellRendererTextClass) ParentClass() *CellRendererClass {
	valptr := &c.native.parent_class
	var _v *CellRendererClass // out
	_v = (*CellRendererClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CenterLayoutClass: instance of this type is always passed by reference.
type CenterLayoutClass struct {
	*centerLayoutClass
}

// centerLayoutClass is the struct that's finalized.
type centerLayoutClass struct {
	native *C.GtkCenterLayoutClass
}

func (c *CenterLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &c.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CheckButtonClass: instance of this type is always passed by reference.
type CheckButtonClass struct {
	*checkButtonClass
}

// checkButtonClass is the struct that's finalized.
type checkButtonClass struct {
	native *C.GtkCheckButtonClass
}

func (c *CheckButtonClass) ParentClass() *WidgetClass {
	valptr := &c.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ColorChooserInterface: instance of this type is always passed by reference.
type ColorChooserInterface struct {
	*colorChooserInterface
}

// colorChooserInterface is the struct that's finalized.
type colorChooserInterface struct {
	native *C.GtkColorChooserInterface
}

// ComboBoxClass: instance of this type is always passed by reference.
type ComboBoxClass struct {
	*comboBoxClass
}

// comboBoxClass is the struct that's finalized.
type comboBoxClass struct {
	native *C.GtkComboBoxClass
}

// ParentClass: parent class.
func (c *ComboBoxClass) ParentClass() *WidgetClass {
	valptr := &c.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ConstraintClass: instance of this type is always passed by reference.
type ConstraintClass struct {
	*constraintClass
}

// constraintClass is the struct that's finalized.
type constraintClass struct {
	native *C.GtkConstraintClass
}

// ConstraintGuideClass: instance of this type is always passed by reference.
type ConstraintGuideClass struct {
	*constraintGuideClass
}

// constraintGuideClass is the struct that's finalized.
type constraintGuideClass struct {
	native *C.GtkConstraintGuideClass
}

// ConstraintLayoutChildClass: instance of this type is always passed by
// reference.
type ConstraintLayoutChildClass struct {
	*constraintLayoutChildClass
}

// constraintLayoutChildClass is the struct that's finalized.
type constraintLayoutChildClass struct {
	native *C.GtkConstraintLayoutChildClass
}

func (c *ConstraintLayoutChildClass) ParentClass() *LayoutChildClass {
	valptr := &c.native.parent_class
	var _v *LayoutChildClass // out
	_v = (*LayoutChildClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ConstraintLayoutClass: instance of this type is always passed by reference.
type ConstraintLayoutClass struct {
	*constraintLayoutClass
}

// constraintLayoutClass is the struct that's finalized.
type constraintLayoutClass struct {
	native *C.GtkConstraintLayoutClass
}

func (c *ConstraintLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &c.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CSSLocation represents a location in a file or other source of data parsed by
// the CSS engine.
//
// The bytes and line_bytes offsets are meant to be used to programmatically
// match data. The lines and line_chars offsets can be used for printing the
// location in a file.
//
// Note that the lines parameter starts from 0 and is increased whenever a CSS
// line break is encountered. (CSS defines the C character sequences "\r\n",
// "\r", "\n" and "\f" as newlines.) If your document uses different rules for
// line breaking, you might want run into problems here.
//
// An instance of this type is always passed by reference.
type CSSLocation struct {
	*cssLocation
}

// cssLocation is the struct that's finalized.
type cssLocation struct {
	native *C.GtkCssLocation
}

// NewCSSLocation creates a new CSSLocation instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewCSSLocation(bytes, chars, lines, lineBytes, lineChars uint) CSSLocation {
	var f0 C.gsize // out
	f0 = C.gsize(bytes)
	var f1 C.gsize // out
	f1 = C.gsize(chars)
	var f2 C.gsize // out
	f2 = C.gsize(lines)
	var f3 C.gsize // out
	f3 = C.gsize(lineBytes)
	var f4 C.gsize // out
	f4 = C.gsize(lineChars)

	v := C.GtkCssLocation{
		bytes:      f0,
		chars:      f1,
		lines:      f2,
		line_bytes: f3,
		line_chars: f4,
	}

	return *(*CSSLocation)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Bytes: number of bytes parsed since the beginning.
func (c *CSSLocation) Bytes() uint {
	valptr := &c.native.bytes
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Chars: number of characters parsed since the beginning.
func (c *CSSLocation) Chars() uint {
	valptr := &c.native.chars
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Lines: number of full lines that have been parsed If you want to display this
// as a line number, you need to add 1 to this.
func (c *CSSLocation) Lines() uint {
	valptr := &c.native.lines
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// LineBytes: number of bytes parsed since the last line break.
func (c *CSSLocation) LineBytes() uint {
	valptr := &c.native.line_bytes
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// LineChars: number of characters parsed since the last line break.
func (c *CSSLocation) LineChars() uint {
	valptr := &c.native.line_chars
	var _v uint // out
	_v = uint(*valptr)
	return _v
}

// Bytes: number of bytes parsed since the beginning.
func (c *CSSLocation) SetBytes(bytes uint) {
	valptr := &c.native.bytes
	*valptr = C.gsize(bytes)
}

// Chars: number of characters parsed since the beginning.
func (c *CSSLocation) SetChars(chars uint) {
	valptr := &c.native.chars
	*valptr = C.gsize(chars)
}

// Lines: number of full lines that have been parsed If you want to display this
// as a line number, you need to add 1 to this.
func (c *CSSLocation) SetLines(lines uint) {
	valptr := &c.native.lines
	*valptr = C.gsize(lines)
}

// LineBytes: number of bytes parsed since the last line break.
func (c *CSSLocation) SetLineBytes(lineBytes uint) {
	valptr := &c.native.line_bytes
	*valptr = C.gsize(lineBytes)
}

// LineChars: number of characters parsed since the last line break.
func (c *CSSLocation) SetLineChars(lineChars uint) {
	valptr := &c.native.line_chars
	*valptr = C.gsize(lineChars)
}

// CSSSection defines a part of a CSS document.
//
// Because sections are nested into one another, you can use
// gtk_css_section_get_parent() to get the containing region.
//
// An instance of this type is always passed by reference.
type CSSSection struct {
	*cssSection
}

// cssSection is the struct that's finalized.
type cssSection struct {
	native *C.GtkCssSection
}

func marshalCSSSection(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &CSSSection{&cssSection{(*C.GtkCssSection)(b)}}, nil
}

// NewCSSSection constructs a struct CSSSection.
func NewCSSSection(file gio.Filer, start *CSSLocation, end *CSSLocation) *CSSSection {
	var _arg1 *C.GFile          // out
	var _arg2 *C.GtkCssLocation // out
	var _arg3 *C.GtkCssLocation // out
	var _cret *C.GtkCssSection  // in

	if file != nil {
		_arg1 = (*C.GFile)(unsafe.Pointer(coreglib.InternObject(file).Native()))
	}
	_arg2 = (*C.GtkCssLocation)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkCssLocation)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = C.gtk_css_section_new(_arg1, _arg2, _arg3)
	runtime.KeepAlive(file)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _cssSection *CSSSection // out

	_cssSection = (*CSSSection)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_cssSection)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_css_section_unref((*C.GtkCssSection)(intern.C))
		},
	)

	return _cssSection
}

// EndLocation returns the location in the CSS document where this section ends.
//
// The function returns the following values:
//
//   - cssLocation: end location of this section.
func (section *CSSSection) EndLocation() *CSSLocation {
	var _arg0 *C.GtkCssSection  // out
	var _cret *C.GtkCssLocation // in

	_arg0 = (*C.GtkCssSection)(gextras.StructNative(unsafe.Pointer(section)))

	_cret = C.gtk_css_section_get_end_location(_arg0)
	runtime.KeepAlive(section)

	var _cssLocation *CSSLocation // out

	_cssLocation = (*CSSLocation)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _cssLocation
}

// File gets the file that section was parsed from.
//
// If no such file exists, for example because the CSS was loaded via
// gtk.CSSProvider.LoadFromData(), then NULL is returned.
//
// The function returns the following values:
//
//   - file: GFile from which the section was parsed.
func (section *CSSSection) File() *gio.File {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GFile         // in

	_arg0 = (*C.GtkCssSection)(gextras.StructNative(unsafe.Pointer(section)))

	_cret = C.gtk_css_section_get_file(_arg0)
	runtime.KeepAlive(section)

	var _file *gio.File // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_file = &gio.File{
			Object: obj,
		}
	}

	return _file
}

// Parent gets the parent section for the given section.
//
// The parent section is the section that contains this section. A special
// case are sections of type GTK_CSS_SECTION_DOCUMENT. Their parent will
// either be NULL if they are the original CSS document that was loaded by
// gtk.CSSProvider.LoadFromFile() or a section of type GTK_CSS_SECTION_IMPORT if
// it was loaded with an import rule from a different file.
//
// The function returns the following values:
//
//   - cssSection (optional): parent section.
func (section *CSSSection) Parent() *CSSSection {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.GtkCssSection // in

	_arg0 = (*C.GtkCssSection)(gextras.StructNative(unsafe.Pointer(section)))

	_cret = C.gtk_css_section_get_parent(_arg0)
	runtime.KeepAlive(section)

	var _cssSection *CSSSection // out

	if _cret != nil {
		_cssSection = (*CSSSection)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		C.gtk_css_section_ref(_cret)
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_cssSection)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_css_section_unref((*C.GtkCssSection)(intern.C))
			},
		)
	}

	return _cssSection
}

// StartLocation returns the location in the CSS document where this section
// starts.
//
// The function returns the following values:
//
//   - cssLocation: start location of this section.
func (section *CSSSection) StartLocation() *CSSLocation {
	var _arg0 *C.GtkCssSection  // out
	var _cret *C.GtkCssLocation // in

	_arg0 = (*C.GtkCssSection)(gextras.StructNative(unsafe.Pointer(section)))

	_cret = C.gtk_css_section_get_start_location(_arg0)
	runtime.KeepAlive(section)

	var _cssLocation *CSSLocation // out

	_cssLocation = (*CSSLocation)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _cssLocation
}

// String prints the section into a human-readable text form using
// gtk.CSSSection.Print().
//
// The function returns the following values:
//
//   - utf8: new string.
func (section *CSSSection) String() string {
	var _arg0 *C.GtkCssSection // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkCssSection)(gextras.StructNative(unsafe.Pointer(section)))

	_cret = C.gtk_css_section_to_string(_arg0)
	runtime.KeepAlive(section)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// CustomFilterClass: instance of this type is always passed by reference.
type CustomFilterClass struct {
	*customFilterClass
}

// customFilterClass is the struct that's finalized.
type customFilterClass struct {
	native *C.GtkCustomFilterClass
}

func (c *CustomFilterClass) ParentClass() *FilterClass {
	valptr := &c.native.parent_class
	var _v *FilterClass // out
	_v = (*FilterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CustomLayoutClass: instance of this type is always passed by reference.
type CustomLayoutClass struct {
	*customLayoutClass
}

// customLayoutClass is the struct that's finalized.
type customLayoutClass struct {
	native *C.GtkCustomLayoutClass
}

func (c *CustomLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &c.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// CustomSorterClass: instance of this type is always passed by reference.
type CustomSorterClass struct {
	*customSorterClass
}

// customSorterClass is the struct that's finalized.
type customSorterClass struct {
	native *C.GtkCustomSorterClass
}

func (c *CustomSorterClass) ParentClass() *SorterClass {
	valptr := &c.native.parent_class
	var _v *SorterClass // out
	_v = (*SorterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DialogClass: instance of this type is always passed by reference.
type DialogClass struct {
	*dialogClass
}

// dialogClass is the struct that's finalized.
type dialogClass struct {
	native *C.GtkDialogClass
}

// ParentClass: parent class.
func (d *DialogClass) ParentClass() *WindowClass {
	valptr := &d.native.parent_class
	var _v *WindowClass // out
	_v = (*WindowClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DirectoryListClass: instance of this type is always passed by reference.
type DirectoryListClass struct {
	*directoryListClass
}

// directoryListClass is the struct that's finalized.
type directoryListClass struct {
	native *C.GtkDirectoryListClass
}

// DragIconClass: instance of this type is always passed by reference.
type DragIconClass struct {
	*dragIconClass
}

// dragIconClass is the struct that's finalized.
type dragIconClass struct {
	native *C.GtkDragIconClass
}

func (d *DragIconClass) ParentClass() *WidgetClass {
	valptr := &d.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DrawingAreaClass: instance of this type is always passed by reference.
type DrawingAreaClass struct {
	*drawingAreaClass
}

// drawingAreaClass is the struct that's finalized.
type drawingAreaClass struct {
	native *C.GtkDrawingAreaClass
}

func (d *DrawingAreaClass) ParentClass() *WidgetClass {
	valptr := &d.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// DropDownClass: instance of this type is always passed by reference.
type DropDownClass struct {
	*dropDownClass
}

// dropDownClass is the struct that's finalized.
type dropDownClass struct {
	native *C.GtkDropDownClass
}

func (d *DropDownClass) ParentClass() *WidgetClass {
	valptr := &d.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// EditableInterface: instance of this type is always passed by reference.
type EditableInterface struct {
	*editableInterface
}

// editableInterface is the struct that's finalized.
type editableInterface struct {
	native *C.GtkEditableInterface
}

// EditableLabelClass: instance of this type is always passed by reference.
type EditableLabelClass struct {
	*editableLabelClass
}

// editableLabelClass is the struct that's finalized.
type editableLabelClass struct {
	native *C.GtkEditableLabelClass
}

func (e *EditableLabelClass) ParentClass() *WidgetClass {
	valptr := &e.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// EntryBufferClass: instance of this type is always passed by reference.
type EntryBufferClass struct {
	*entryBufferClass
}

// entryBufferClass is the struct that's finalized.
type entryBufferClass struct {
	native *C.GtkEntryBufferClass
}

// EntryClass class structure for Entry. All virtual functions have a default
// implementation. Derived classes may set the virtual function pointers for the
// signal handlers to NULL, but must keep get_text_area_size and get_frame_size
// non-NULL; either use the default implementation, or provide a custom one.
//
// An instance of this type is always passed by reference.
type EntryClass struct {
	*entryClass
}

// entryClass is the struct that's finalized.
type entryClass struct {
	native *C.GtkEntryClass
}

// ParentClass: parent class.
func (e *EntryClass) ParentClass() *WidgetClass {
	valptr := &e.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ExpressionWatch: opaque structure representing a watched GtkExpression.
//
// The contents of GtkExpressionWatch should only be accessed through the
// provided API.
//
// An instance of this type is always passed by reference.
type ExpressionWatch struct {
	*expressionWatch
}

// expressionWatch is the struct that's finalized.
type expressionWatch struct {
	native *C.GtkExpressionWatch
}

func marshalExpressionWatch(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &ExpressionWatch{&expressionWatch{(*C.GtkExpressionWatch)(b)}}, nil
}

// Evaluate evaluates the watched expression and on success stores the result in
// value.
//
// This is equivalent to calling gtk.Expression.Evaluate() with the expression
// and this pointer originally used to create watch.
//
// The function takes the following parameters:
//
//   - value: empty GValue to be set.
//
// The function returns the following values:
//
//   - ok: TRUE if the expression could be evaluated and value was set.
func (watch *ExpressionWatch) Evaluate(value *coreglib.Value) bool {
	var _arg0 *C.GtkExpressionWatch // out
	var _arg1 *C.GValue             // out
	var _cret C.gboolean            // in

	_arg0 = (*C.GtkExpressionWatch)(gextras.StructNative(unsafe.Pointer(watch)))
	_arg1 = (*C.GValue)(unsafe.Pointer(value.Native()))

	_cret = C.gtk_expression_watch_evaluate(_arg0, _arg1)
	runtime.KeepAlive(watch)
	runtime.KeepAlive(value)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Unwatch stops watching an expression.
//
// See gtk.Expression.Watch() for how the watch was established.
func (watch *ExpressionWatch) Unwatch() {
	var _arg0 *C.GtkExpressionWatch // out

	_arg0 = (*C.GtkExpressionWatch)(gextras.StructNative(unsafe.Pointer(watch)))

	C.gtk_expression_watch_unwatch(_arg0)
	runtime.KeepAlive(watch)
}

// FileChooserNativeClass: instance of this type is always passed by reference.
type FileChooserNativeClass struct {
	*fileChooserNativeClass
}

// fileChooserNativeClass is the struct that's finalized.
type fileChooserNativeClass struct {
	native *C.GtkFileChooserNativeClass
}

func (f *FileChooserNativeClass) ParentClass() *NativeDialogClass {
	valptr := &f.native.parent_class
	var _v *NativeDialogClass // out
	_v = (*NativeDialogClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FilterClass: instance of this type is always passed by reference.
type FilterClass struct {
	*filterClass
}

// filterClass is the struct that's finalized.
type filterClass struct {
	native *C.GtkFilterClass
}

// FilterListModelClass: instance of this type is always passed by reference.
type FilterListModelClass struct {
	*filterListModelClass
}

// filterListModelClass is the struct that's finalized.
type filterListModelClass struct {
	native *C.GtkFilterListModelClass
}

// FixedClass: instance of this type is always passed by reference.
type FixedClass struct {
	*fixedClass
}

// fixedClass is the struct that's finalized.
type fixedClass struct {
	native *C.GtkFixedClass
}

func (f *FixedClass) ParentClass() *WidgetClass {
	valptr := &f.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FixedLayoutChildClass: instance of this type is always passed by reference.
type FixedLayoutChildClass struct {
	*fixedLayoutChildClass
}

// fixedLayoutChildClass is the struct that's finalized.
type fixedLayoutChildClass struct {
	native *C.GtkFixedLayoutChildClass
}

func (f *FixedLayoutChildClass) ParentClass() *LayoutChildClass {
	valptr := &f.native.parent_class
	var _v *LayoutChildClass // out
	_v = (*LayoutChildClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FixedLayoutClass: instance of this type is always passed by reference.
type FixedLayoutClass struct {
	*fixedLayoutClass
}

// fixedLayoutClass is the struct that's finalized.
type fixedLayoutClass struct {
	native *C.GtkFixedLayoutClass
}

func (f *FixedLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &f.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// FlattenListModelClass: instance of this type is always passed by reference.
type FlattenListModelClass struct {
	*flattenListModelClass
}

// flattenListModelClass is the struct that's finalized.
type flattenListModelClass struct {
	native *C.GtkFlattenListModelClass
}

// FlowBoxChildClass: instance of this type is always passed by reference.
type FlowBoxChildClass struct {
	*flowBoxChildClass
}

// flowBoxChildClass is the struct that's finalized.
type flowBoxChildClass struct {
	native *C.GtkFlowBoxChildClass
}

// FontChooserIface: instance of this type is always passed by reference.
type FontChooserIface struct {
	*fontChooserIface
}

// fontChooserIface is the struct that's finalized.
type fontChooserIface struct {
	native *C.GtkFontChooserIface
}

// FrameClass: instance of this type is always passed by reference.
type FrameClass struct {
	*frameClass
}

// frameClass is the struct that's finalized.
type frameClass struct {
	native *C.GtkFrameClass
}

// ParentClass: parent class.
func (f *FrameClass) ParentClass() *WidgetClass {
	valptr := &f.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GLAreaClass: GtkGLAreaClass structure contains only private data.
//
// An instance of this type is always passed by reference.
type GLAreaClass struct {
	*glAreaClass
}

// glAreaClass is the struct that's finalized.
type glAreaClass struct {
	native *C.GtkGLAreaClass
}

// GridClass: instance of this type is always passed by reference.
type GridClass struct {
	*gridClass
}

// gridClass is the struct that's finalized.
type gridClass struct {
	native *C.GtkGridClass
}

// ParentClass: parent class.
func (g *GridClass) ParentClass() *WidgetClass {
	valptr := &g.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GridLayoutChildClass: instance of this type is always passed by reference.
type GridLayoutChildClass struct {
	*gridLayoutChildClass
}

// gridLayoutChildClass is the struct that's finalized.
type gridLayoutChildClass struct {
	native *C.GtkGridLayoutChildClass
}

func (g *GridLayoutChildClass) ParentClass() *LayoutChildClass {
	valptr := &g.native.parent_class
	var _v *LayoutChildClass // out
	_v = (*LayoutChildClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// GridLayoutClass: instance of this type is always passed by reference.
type GridLayoutClass struct {
	*gridLayoutClass
}

// gridLayoutClass is the struct that's finalized.
type gridLayoutClass struct {
	native *C.GtkGridLayoutClass
}

func (g *GridLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &g.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// IMContextClass: instance of this type is always passed by reference.
type IMContextClass struct {
	*imContextClass
}

// imContextClass is the struct that's finalized.
type imContextClass struct {
	native *C.GtkIMContextClass
}

// IMContextSimpleClass: instance of this type is always passed by reference.
type IMContextSimpleClass struct {
	*imContextSimpleClass
}

// imContextSimpleClass is the struct that's finalized.
type imContextSimpleClass struct {
	native *C.GtkIMContextSimpleClass
}

func (i *IMContextSimpleClass) ParentClass() *IMContextClass {
	valptr := &i.native.parent_class
	var _v *IMContextClass // out
	_v = (*IMContextClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// IMMulticontextClass: instance of this type is always passed by reference.
type IMMulticontextClass struct {
	*imMulticontextClass
}

// imMulticontextClass is the struct that's finalized.
type imMulticontextClass struct {
	native *C.GtkIMMulticontextClass
}

func (i *IMMulticontextClass) ParentClass() *IMContextClass {
	valptr := &i.native.parent_class
	var _v *IMContextClass // out
	_v = (*IMContextClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// LayoutChildClass: instance of this type is always passed by reference.
type LayoutChildClass struct {
	*layoutChildClass
}

// layoutChildClass is the struct that's finalized.
type layoutChildClass struct {
	native *C.GtkLayoutChildClass
}

// LayoutManagerClass: GtkLayoutManagerClass structure contains only private
// data, and should only be accessed through the provided API, or when
// subclassing LayoutManager.
//
// An instance of this type is always passed by reference.
type LayoutManagerClass struct {
	*layoutManagerClass
}

// layoutManagerClass is the struct that's finalized.
type layoutManagerClass struct {
	native *C.GtkLayoutManagerClass
}

// LayoutChildType: type of LayoutChild used by this layout manager.
func (l *LayoutManagerClass) LayoutChildType() coreglib.Type {
	valptr := &l.native.layout_child_type
	var _v coreglib.Type // out
	_v = coreglib.Type(*valptr)
	return _v
}

// ListBoxRowClass: instance of this type is always passed by reference.
type ListBoxRowClass struct {
	*listBoxRowClass
}

// listBoxRowClass is the struct that's finalized.
type listBoxRowClass struct {
	native *C.GtkListBoxRowClass
}

// ParentClass: parent class.
func (l *ListBoxRowClass) ParentClass() *WidgetClass {
	valptr := &l.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ListStoreClass: instance of this type is always passed by reference.
type ListStoreClass struct {
	*listStoreClass
}

// listStoreClass is the struct that's finalized.
type listStoreClass struct {
	native *C.GtkListStoreClass
}

// MapListModelClass: instance of this type is always passed by reference.
type MapListModelClass struct {
	*mapListModelClass
}

// mapListModelClass is the struct that's finalized.
type mapListModelClass struct {
	native *C.GtkMapListModelClass
}

// MediaControlsClass: instance of this type is always passed by reference.
type MediaControlsClass struct {
	*mediaControlsClass
}

// mediaControlsClass is the struct that's finalized.
type mediaControlsClass struct {
	native *C.GtkMediaControlsClass
}

func (m *MediaControlsClass) ParentClass() *WidgetClass {
	valptr := &m.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MediaFileClass: instance of this type is always passed by reference.
type MediaFileClass struct {
	*mediaFileClass
}

// mediaFileClass is the struct that's finalized.
type mediaFileClass struct {
	native *C.GtkMediaFileClass
}

func (m *MediaFileClass) ParentClass() *MediaStreamClass {
	valptr := &m.native.parent_class
	var _v *MediaStreamClass // out
	_v = (*MediaStreamClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MediaStreamClass: instance of this type is always passed by reference.
type MediaStreamClass struct {
	*mediaStreamClass
}

// mediaStreamClass is the struct that's finalized.
type mediaStreamClass struct {
	native *C.GtkMediaStreamClass
}

// MountOperationClass: instance of this type is always passed by reference.
type MountOperationClass struct {
	*mountOperationClass
}

// mountOperationClass is the struct that's finalized.
type mountOperationClass struct {
	native *C.GtkMountOperationClass
}

// ParentClass: parent class.
func (m *MountOperationClass) ParentClass() *gio.MountOperationClass {
	valptr := &m.native.parent_class
	var _v *gio.MountOperationClass // out
	_v = (*gio.MountOperationClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// MultiSelectionClass: instance of this type is always passed by reference.
type MultiSelectionClass struct {
	*multiSelectionClass
}

// multiSelectionClass is the struct that's finalized.
type multiSelectionClass struct {
	native *C.GtkMultiSelectionClass
}

// MultiSorterClass: instance of this type is always passed by reference.
type MultiSorterClass struct {
	*multiSorterClass
}

// multiSorterClass is the struct that's finalized.
type multiSorterClass struct {
	native *C.GtkMultiSorterClass
}

func (m *MultiSorterClass) ParentClass() *SorterClass {
	valptr := &m.native.parent_class
	var _v *SorterClass // out
	_v = (*SorterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// NativeDialogClass class structure for NativeDialog.
//
// An instance of this type is always passed by reference.
type NativeDialogClass struct {
	*nativeDialogClass
}

// nativeDialogClass is the struct that's finalized.
type nativeDialogClass struct {
	native *C.GtkNativeDialogClass
}

// NoSelectionClass: instance of this type is always passed by reference.
type NoSelectionClass struct {
	*noSelectionClass
}

// noSelectionClass is the struct that's finalized.
type noSelectionClass struct {
	native *C.GtkNoSelectionClass
}

// NumericSorterClass: instance of this type is always passed by reference.
type NumericSorterClass struct {
	*numericSorterClass
}

// numericSorterClass is the struct that's finalized.
type numericSorterClass struct {
	native *C.GtkNumericSorterClass
}

func (n *NumericSorterClass) ParentClass() *SorterClass {
	valptr := &n.native.parent_class
	var _v *SorterClass // out
	_v = (*SorterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// OrientableIface: instance of this type is always passed by reference.
type OrientableIface struct {
	*orientableIface
}

// orientableIface is the struct that's finalized.
type orientableIface struct {
	native *C.GtkOrientableIface
}

// OverlayLayoutChildClass: instance of this type is always passed by reference.
type OverlayLayoutChildClass struct {
	*overlayLayoutChildClass
}

// overlayLayoutChildClass is the struct that's finalized.
type overlayLayoutChildClass struct {
	native *C.GtkOverlayLayoutChildClass
}

func (o *OverlayLayoutChildClass) ParentClass() *LayoutChildClass {
	valptr := &o.native.parent_class
	var _v *LayoutChildClass // out
	_v = (*LayoutChildClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// OverlayLayoutClass: instance of this type is always passed by reference.
type OverlayLayoutClass struct {
	*overlayLayoutClass
}

// overlayLayoutClass is the struct that's finalized.
type overlayLayoutClass struct {
	native *C.GtkOverlayLayoutClass
}

func (o *OverlayLayoutClass) ParentClass() *LayoutManagerClass {
	valptr := &o.native.parent_class
	var _v *LayoutManagerClass // out
	_v = (*LayoutManagerClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PadActionEntry: struct defining a pad action entry.
//
// An instance of this type is always passed by reference.
type PadActionEntry struct {
	*padActionEntry
}

// padActionEntry is the struct that's finalized.
type padActionEntry struct {
	native *C.GtkPadActionEntry
}

// Type: type of pad feature that will trigger this action entry.
func (p *PadActionEntry) Type() PadActionType {
	valptr := &p.native._type
	var _v PadActionType // out
	_v = PadActionType(*valptr)
	return _v
}

// Index: 0-indexed button/ring/strip number that will trigger this action
// entry.
func (p *PadActionEntry) Index() int {
	valptr := &p.native.index
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Mode: mode that will trigger this action entry, or -1 for all modes.
func (p *PadActionEntry) Mode() int {
	valptr := &p.native.mode
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Label: human readable description of this action entry, this string should be
// deemed user-visible.
func (p *PadActionEntry) Label() string {
	valptr := &p.native.label
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// ActionName: action name that will be activated in the Group.
func (p *PadActionEntry) ActionName() string {
	valptr := &p.native.action_name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Index: 0-indexed button/ring/strip number that will trigger this action
// entry.
func (p *PadActionEntry) SetIndex(index int) {
	valptr := &p.native.index
	*valptr = C.int(index)
}

// Mode: mode that will trigger this action entry, or -1 for all modes.
func (p *PadActionEntry) SetMode(mode int) {
	valptr := &p.native.mode
	*valptr = C.int(mode)
}

// PageRange: range of pages to print.
//
// See also gtk.PrintSettings.SetPageRanges().
//
// An instance of this type is always passed by reference.
type PageRange struct {
	*pageRange
}

// pageRange is the struct that's finalized.
type pageRange struct {
	native *C.GtkPageRange
}

// NewPageRange creates a new PageRange instance from the given
// fields. Beware that this function allocates on the Go heap; be careful
// when using it!
func NewPageRange(start, end int) PageRange {
	var f0 C.int // out
	f0 = C.int(start)
	var f1 C.int // out
	f1 = C.int(end)

	v := C.GtkPageRange{
		start: f0,
		end:   f1,
	}

	return *(*PageRange)(gextras.NewStructNative(unsafe.Pointer(&v)))
}

// Start: start of page range.
func (p *PageRange) Start() int {
	valptr := &p.native.start
	var _v int // out
	_v = int(*valptr)
	return _v
}

// End: end of page range.
func (p *PageRange) End() int {
	valptr := &p.native.end
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Start: start of page range.
func (p *PageRange) SetStart(start int) {
	valptr := &p.native.start
	*valptr = C.int(start)
}

// End: end of page range.
func (p *PageRange) SetEnd(end int) {
	valptr := &p.native.end
	*valptr = C.int(end)
}

// PaperSize: GtkPaperSize handles paper sizes.
//
// It uses the standard called PWG 5101.1-2002 PWG: Standard for Media
// Standardized Names (http://www.pwg.org/standards.html) to name the paper
// sizes (and to get the data for the page sizes). In addition to standard paper
// sizes, GtkPaperSize allows to construct custom paper sizes with arbitrary
// dimensions.
//
// The GtkPaperSize object stores not only the dimensions (width and height) of
// a paper size and its name, it also provides default print margins.
//
// An instance of this type is always passed by reference.
type PaperSize struct {
	*paperSize
}

// paperSize is the struct that's finalized.
type paperSize struct {
	native *C.GtkPaperSize
}

func marshalPaperSize(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &PaperSize{&paperSize{(*C.GtkPaperSize)(b)}}, nil
}

// NewPaperSize constructs a struct PaperSize.
func NewPaperSize(name string) *PaperSize {
	var _arg1 *C.char         // out
	var _cret *C.GtkPaperSize // in

	if name != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_paper_size_new(_arg1)
	runtime.KeepAlive(name)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)

	return _paperSize
}

// NewPaperSizeCustom constructs a struct PaperSize.
func NewPaperSizeCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
	var _arg1 *C.char         // out
	var _arg2 *C.char         // out
	var _arg3 C.double        // out
	var _arg4 C.double        // out
	var _arg5 C.GtkUnit       // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(displayName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.double(width)
	_arg4 = C.double(height)
	_arg5 = C.GtkUnit(unit)

	_cret = C.gtk_paper_size_new_custom(_arg1, _arg2, _arg3, _arg4, _arg5)
	runtime.KeepAlive(name)
	runtime.KeepAlive(displayName)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(unit)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)

	return _paperSize
}

// NewPaperSizeFromGVariant constructs a struct PaperSize.
func NewPaperSizeFromGVariant(variant *glib.Variant) *PaperSize {
	var _arg1 *C.GVariant     // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(variant)))

	_cret = C.gtk_paper_size_new_from_gvariant(_arg1)
	runtime.KeepAlive(variant)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)

	return _paperSize
}

// NewPaperSizeFromIPP constructs a struct PaperSize.
func NewPaperSizeFromIPP(ippName string, width float64, height float64) *PaperSize {
	var _arg1 *C.char         // out
	var _arg2 C.double        // out
	var _arg3 C.double        // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(ippName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.double(width)
	_arg3 = C.double(height)

	_cret = C.gtk_paper_size_new_from_ipp(_arg1, _arg2, _arg3)
	runtime.KeepAlive(ippName)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)

	return _paperSize
}

// NewPaperSizeFromKeyFile constructs a struct PaperSize.
func NewPaperSizeFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PaperSize, error) {
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out
	var _cret *C.GtkPaperSize // in
	var _cerr *C.GError       // in

	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	if groupName != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
		defer C.free(unsafe.Pointer(_arg2))
	}

	_cret = C.gtk_paper_size_new_from_key_file(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)

	var _paperSize *PaperSize // out
	var _goerr error          // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _paperSize, _goerr
}

// NewPaperSizeFromPPD constructs a struct PaperSize.
func NewPaperSizeFromPPD(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
	var _arg1 *C.char         // out
	var _arg2 *C.char         // out
	var _arg3 C.double        // out
	var _arg4 C.double        // out
	var _cret *C.GtkPaperSize // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(ppdName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(ppdDisplayName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.double(width)
	_arg4 = C.double(height)

	_cret = C.gtk_paper_size_new_from_ppd(_arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(ppdName)
	runtime.KeepAlive(ppdDisplayName)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)

	return _paperSize
}

// Copy copies an existing GtkPaperSize.
//
// The function returns the following values:
//
//   - paperSize: copy of other.
func (other *PaperSize) Copy() *PaperSize {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.GtkPaperSize // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(other)))

	_cret = C.gtk_paper_size_copy(_arg0)
	runtime.KeepAlive(other)

	var _paperSize *PaperSize // out

	_paperSize = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_paperSize)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
		},
	)

	return _paperSize
}

// DefaultBottomMargin gets the default bottom margin for the GtkPaperSize.
//
// The function takes the following parameters:
//
//   - unit for the return value, not GTK_UNIT_NONE.
//
// The function returns the following values:
//
//   - gdouble: default bottom margin.
func (size *PaperSize) DefaultBottomMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_paper_size_get_default_bottom_margin(_arg0, _arg1)
	runtime.KeepAlive(size)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// DefaultLeftMargin gets the default left margin for the GtkPaperSize.
//
// The function takes the following parameters:
//
//   - unit for the return value, not GTK_UNIT_NONE.
//
// The function returns the following values:
//
//   - gdouble: default left margin.
func (size *PaperSize) DefaultLeftMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_paper_size_get_default_left_margin(_arg0, _arg1)
	runtime.KeepAlive(size)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// DefaultRightMargin gets the default right margin for the GtkPaperSize.
//
// The function takes the following parameters:
//
//   - unit for the return value, not GTK_UNIT_NONE.
//
// The function returns the following values:
//
//   - gdouble: default right margin.
func (size *PaperSize) DefaultRightMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_paper_size_get_default_right_margin(_arg0, _arg1)
	runtime.KeepAlive(size)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// DefaultTopMargin gets the default top margin for the GtkPaperSize.
//
// The function takes the following parameters:
//
//   - unit for the return value, not GTK_UNIT_NONE.
//
// The function returns the following values:
//
//   - gdouble: default top margin.
func (size *PaperSize) DefaultTopMargin(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_paper_size_get_default_top_margin(_arg0, _arg1)
	runtime.KeepAlive(size)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// DisplayName gets the human-readable name of the GtkPaperSize.
//
// The function returns the following values:
//
//   - utf8: human-readable name of size.
func (size *PaperSize) DisplayName() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))

	_cret = C.gtk_paper_size_get_display_name(_arg0)
	runtime.KeepAlive(size)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Height gets the paper height of the GtkPaperSize, in units of unit.
//
// The function takes the following parameters:
//
//   - unit for the return value, not GTK_UNIT_NONE.
//
// The function returns the following values:
//
//   - gdouble: paper height.
func (size *PaperSize) Height(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_paper_size_get_height(_arg0, _arg1)
	runtime.KeepAlive(size)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// Name gets the name of the GtkPaperSize.
//
// The function returns the following values:
//
//   - utf8: name of size.
func (size *PaperSize) Name() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))

	_cret = C.gtk_paper_size_get_name(_arg0)
	runtime.KeepAlive(size)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PPDName gets the PPD name of the GtkPaperSize, which may be NULL.
//
// The function returns the following values:
//
//   - utf8: PPD name of size.
func (size *PaperSize) PPDName() string {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.char         // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))

	_cret = C.gtk_paper_size_get_ppd_name(_arg0)
	runtime.KeepAlive(size)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Width gets the paper width of the GtkPaperSize, in units of unit.
//
// The function takes the following parameters:
//
//   - unit for the return value, not GTK_UNIT_NONE.
//
// The function returns the following values:
//
//   - gdouble: paper width.
func (size *PaperSize) Width(unit Unit) float64 {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.GtkUnit       // out
	var _cret C.double        // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = C.GtkUnit(unit)

	_cret = C.gtk_paper_size_get_width(_arg0, _arg1)
	runtime.KeepAlive(size)
	runtime.KeepAlive(unit)

	var _gdouble float64 // out

	_gdouble = float64(_cret)

	return _gdouble
}

// IsCustom returns TRUE if size is not a standard paper size.
//
// The function returns the following values:
//
//   - ok: whether size is a custom paper size.
func (size *PaperSize) IsCustom() bool {
	var _arg0 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))

	_cret = C.gtk_paper_size_is_custom(_arg0)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEqual compares two GtkPaperSize objects.
//
// The function takes the following parameters:
//
//   - size2: another GtkPaperSize object.
//
// The function returns the following values:
//
//   - ok: TRUE, if size1 and size2 represent the same paper size.
func (size1 *PaperSize) IsEqual(size2 *PaperSize) bool {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size1)))
	_arg1 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size2)))

	_cret = C.gtk_paper_size_is_equal(_arg0, _arg1)
	runtime.KeepAlive(size1)
	runtime.KeepAlive(size2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsIPP returns TRUE if size is an IPP standard paper size.
//
// The function returns the following values:
//
//   - ok: whether size is not an IPP custom paper size.
func (size *PaperSize) IsIPP() bool {
	var _arg0 *C.GtkPaperSize // out
	var _cret C.gboolean      // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))

	_cret = C.gtk_paper_size_is_ipp(_arg0)
	runtime.KeepAlive(size)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetSize changes the dimensions of a size to width x height.
//
// The function takes the following parameters:
//
//   - width: new width in units of unit.
//   - height: new height in units of unit.
//   - unit for width and height.
func (size *PaperSize) SetSize(width float64, height float64, unit Unit) {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 C.double        // out
	var _arg2 C.double        // out
	var _arg3 C.GtkUnit       // out

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = C.double(width)
	_arg2 = C.double(height)
	_arg3 = C.GtkUnit(unit)

	C.gtk_paper_size_set_size(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(size)
	runtime.KeepAlive(width)
	runtime.KeepAlive(height)
	runtime.KeepAlive(unit)
}

// ToGVariant: serialize a paper size to an a{sv} variant.
//
// The function returns the following values:
//
//   - variant: new, floating, GVariant.
func (paperSize *PaperSize) ToGVariant() *glib.Variant {
	var _arg0 *C.GtkPaperSize // out
	var _cret *C.GVariant     // in

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(paperSize)))

	_cret = C.gtk_paper_size_to_gvariant(_arg0)
	runtime.KeepAlive(paperSize)

	var _variant *glib.Variant // out

	_variant = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_variant_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_variant)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)

	return _variant
}

// ToKeyFile: this function adds the paper size from size to key_file.
//
// The function takes the following parameters:
//
//   - keyFile: GKeyFile to save the paper size to.
//   - groupName: group to add the settings to in key_file.
func (size *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string) {
	var _arg0 *C.GtkPaperSize // out
	var _arg1 *C.GKeyFile     // out
	var _arg2 *C.char         // out

	_arg0 = (*C.GtkPaperSize)(gextras.StructNative(unsafe.Pointer(size)))
	_arg1 = (*C.GKeyFile)(gextras.StructNative(unsafe.Pointer(keyFile)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_paper_size_to_key_file(_arg0, _arg1, _arg2)
	runtime.KeepAlive(size)
	runtime.KeepAlive(keyFile)
	runtime.KeepAlive(groupName)
}

// PaperSizeGetDefault returns the name of the default paper size, which depends
// on the current locale.
//
// The function returns the following values:
//
//   - utf8: name of the default paper size. The string is owned by GTK and
//     should not be modified.
func PaperSizeGetDefault() string {
	var _cret *C.char // in

	_cret = C.gtk_paper_size_get_default()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PaperSizeGetPaperSizes creates a list of known paper sizes.
//
// The function takes the following parameters:
//
//   - includeCustom: whether to include custom paper sizes as defined in the
//     page setup dialog.
//
// The function returns the following values:
//
//   - list: newly allocated list of newly allocated GtkPaperSize objects.
func PaperSizeGetPaperSizes(includeCustom bool) []*PaperSize {
	var _arg1 C.gboolean // out
	var _cret *C.GList   // in

	if includeCustom {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_paper_size_get_paper_sizes(_arg1)
	runtime.KeepAlive(includeCustom)

	var _list []*PaperSize // out

	_list = make([]*PaperSize, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkPaperSize)(v)
		var dst *PaperSize // out
		dst = (*PaperSize)(gextras.NewStructNative(unsafe.Pointer(src)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(dst)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_paper_size_free((*C.GtkPaperSize)(intern.C))
			},
		)
		_list = append(_list, dst)
	})

	return _list
}

// PictureClass: instance of this type is always passed by reference.
type PictureClass struct {
	*pictureClass
}

// pictureClass is the struct that's finalized.
type pictureClass struct {
	native *C.GtkPictureClass
}

func (p *PictureClass) ParentClass() *WidgetClass {
	valptr := &p.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PopoverClass: instance of this type is always passed by reference.
type PopoverClass struct {
	*popoverClass
}

// popoverClass is the struct that's finalized.
type popoverClass struct {
	native *C.GtkPopoverClass
}

func (p *PopoverClass) ParentClass() *WidgetClass {
	valptr := &p.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// PrintOperationClass: instance of this type is always passed by reference.
type PrintOperationClass struct {
	*printOperationClass
}

// printOperationClass is the struct that's finalized.
type printOperationClass struct {
	native *C.GtkPrintOperationClass
}

// PrintOperationPreviewIface: instance of this type is always passed by
// reference.
type PrintOperationPreviewIface struct {
	*printOperationPreviewIface
}

// printOperationPreviewIface is the struct that's finalized.
type printOperationPreviewIface struct {
	native *C.GtkPrintOperationPreviewIface
}

// RangeClass: instance of this type is always passed by reference.
type RangeClass struct {
	*rangeClass
}

// rangeClass is the struct that's finalized.
type rangeClass struct {
	native *C.GtkRangeClass
}

func (r *RangeClass) ParentClass() *WidgetClass {
	valptr := &r.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
//
// An instance of this type is always passed by reference.
type RecentData struct {
	*recentData
}

// recentData is the struct that's finalized.
type recentData struct {
	native *C.GtkRecentData
}

// DisplayName: UTF-8 encoded string, containing the name of the recently used
// resource to be displayed, or NULL;.
func (r *RecentData) DisplayName() string {
	valptr := &r.native.display_name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Description: UTF-8 encoded string, containing a short description of the
// resource, or NULL;.
func (r *RecentData) Description() string {
	valptr := &r.native.description
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// MIMEType: MIME type of the resource;.
func (r *RecentData) MIMEType() string {
	valptr := &r.native.mime_type
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// AppName: name of the application that is registering this recently used
// resource;.
func (r *RecentData) AppName() string {
	valptr := &r.native.app_name
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// AppExec: command line used to launch this resource; may contain the “\f” and
// “\u” escape characters which will be expanded to the resource file path and
// URI respectively when the command line is retrieved;.
func (r *RecentData) AppExec() string {
	valptr := &r.native.app_exec
	var _v string // out
	_v = C.GoString((*C.gchar)(unsafe.Pointer(*valptr)))
	return _v
}

// Groups: vector of strings containing groups names;.
func (r *RecentData) Groups() []string {
	valptr := &r.native.groups
	var _v []string // out
	{
		var i int
		var z *C.char
		for p := *valptr; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(*valptr, i)
		_v = make([]string, i)
		for i := range src {
			_v[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}
	return _v
}

// IsPrivate: whether this resource should be displayed only by the applications
// that have registered it or not.
func (r *RecentData) IsPrivate() bool {
	valptr := &r.native.is_private
	var _v bool // out
	if *valptr != 0 {
		_v = true
	}
	return _v
}

// IsPrivate: whether this resource should be displayed only by the applications
// that have registered it or not.
func (r *RecentData) SetIsPrivate(isPrivate bool) {
	valptr := &r.native.is_private
	if isPrivate {
		*valptr = C.TRUE
	}
}

// RecentInfo: GtkRecentInfo contains the metadata associated with an item in
// the recently used files list.
//
// An instance of this type is always passed by reference.
type RecentInfo struct {
	*recentInfo
}

// recentInfo is the struct that's finalized.
type recentInfo struct {
	native *C.GtkRecentInfo
}

func marshalRecentInfo(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &RecentInfo{&recentInfo{(*C.GtkRecentInfo)(b)}}, nil
}

// CreateAppInfo creates a GAppInfo for the specified GtkRecentInfo.
//
// The function takes the following parameters:
//
//   - appName (optional): name of the application that should be mapped to a
//     GAppInfo; if NULL is used then the default application for the MIME type
//     is used.
//
// The function returns the following values:
//
//   - appInfo (optional): newly created GAppInfo, or NULL. In case of error,
//     error will be set either with a GTK_RECENT_MANAGER_ERROR or a G_IO_ERROR.
func (info *RecentInfo) CreateAppInfo(appName string) (*gio.AppInfo, error) {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.char          // out
	var _cret *C.GAppInfo      // in
	var _cerr *C.GError        // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))
	if appName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(appName)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.gtk_recent_info_create_app_info(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(info)
	runtime.KeepAlive(appName)

	var _appInfo *gio.AppInfo // out
	var _goerr error          // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_appInfo = &gio.AppInfo{
				Object: obj,
			}
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _appInfo, _goerr
}

// Exists checks whether the resource pointed by info still exists. At the
// moment this check is done only on resources pointing to local files.
//
// The function returns the following values:
//
//   - ok: TRUE if the resource exists.
func (info *RecentInfo) Exists() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_exists(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Added gets the the time when the resource was added to the recently used
// resources list.
//
// The function returns the following values:
//
//   - dateTime for the time when the resource was added.
func (info *RecentInfo) Added() *glib.DateTime {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GDateTime     // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_added(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_date_time_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)

	return _dateTime
}

// Age gets the number of days elapsed since the last update of the resource
// pointed by info.
//
// The function returns the following values:
//
//   - gint: positive integer containing the number of days elapsed since the
//     time this resource was last modified.
func (info *RecentInfo) Age() int {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.int            // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_age(_arg0)
	runtime.KeepAlive(info)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ApplicationInfo gets the data regarding the application that has registered
// the resource pointed by info.
//
// If the command line contains any escape characters defined inside the storage
// specification, they will be expanded.
//
// The function takes the following parameters:
//
//   - appName: name of the application that has registered this item.
//
// The function returns the following values:
//
//   - appExec: return location for the string containing the command line.
//   - count: return location for the number of times this item was registered.
//   - stamp: return location for the time this item was last registered for
//     this application.
//   - ok: TRUE if an application with app_name has registered this resource
//     inside the recently used list, or FALSE otherwise. The app_exec string is
//     owned by the GtkRecentInfo and should not be modified or freed.
func (info *RecentInfo) ApplicationInfo(appName string) (string, uint, *glib.DateTime, bool) {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.char          // out
	var _arg2 *C.char          // in
	var _arg3 C.guint          // in
	var _arg4 *C.GDateTime     // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(appName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_get_application_info(_arg0, _arg1, &_arg2, &_arg3, &_arg4)
	runtime.KeepAlive(info)
	runtime.KeepAlive(appName)

	var _appExec string       // out
	var _count uint           // out
	var _stamp *glib.DateTime // out
	var _ok bool              // out

	_appExec = C.GoString((*C.gchar)(unsafe.Pointer(_arg2)))
	_count = uint(_arg3)
	_stamp = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_arg4)))
	C.g_date_time_ref(_arg4)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_stamp)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)
	if _cret != 0 {
		_ok = true
	}

	return _appExec, _count, _stamp, _ok
}

// Applications retrieves the list of applications that have registered this
// resource.
//
// The function returns the following values:
//
//   - utf8s: newly allocated NULL-terminated array of strings. Use g_strfreev()
//     to free it.
func (info *RecentInfo) Applications() []string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret **C.char         // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_applications(_arg0, &_arg1)
	runtime.KeepAlive(info)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.char)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// Description gets the (short) description of the resource.
//
// The function returns the following values:
//
//   - utf8: description of the resource. The returned string is owned by the
//     recent manager, and should not be freed.
func (info *RecentInfo) Description() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_description(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DisplayName gets the name of the resource.
//
// If none has been defined, the basename of the resource is obtained.
//
// The function returns the following values:
//
//   - utf8: display name of the resource. The returned string is owned by the
//     recent manager, and should not be freed.
func (info *RecentInfo) DisplayName() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_display_name(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GIcon retrieves the icon associated to the resource MIME type.
//
// The function returns the following values:
//
//   - icon (optional) containing the icon, or NULL. Use g_object_unref() when
//     finished using the icon.
func (info *RecentInfo) GIcon() *gio.Icon {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GIcon         // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_gicon(_arg0)
	runtime.KeepAlive(info)

	var _icon *gio.Icon // out

	if _cret != nil {
		{
			obj := coreglib.AssumeOwnership(unsafe.Pointer(_cret))
			_icon = &gio.Icon{
				Object: obj,
			}
		}
	}

	return _icon
}

// Groups returns all groups registered for the recently used item info.
//
// The array of returned group names will be NULL terminated, so length might
// optionally be NULL.
//
// The function returns the following values:
//
//   - utf8s: a newly allocated NULL terminated array of strings. Use
//     g_strfreev() to free it.
func (info *RecentInfo) Groups() []string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret **C.char         // in
	var _arg1 C.gsize          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_groups(_arg0, &_arg1)
	runtime.KeepAlive(info)

	var _utf8s []string // out

	defer C.free(unsafe.Pointer(_cret))
	{
		src := unsafe.Slice((**C.char)(_cret), _arg1)
		_utf8s = make([]string, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// MIMEType gets the MIME type of the resource.
//
// The function returns the following values:
//
//   - utf8: MIME type of the resource. The returned string is owned by the
//     recent manager, and should not be freed.
func (info *RecentInfo) MIMEType() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_mime_type(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// Modified gets the time when the meta-data for the resource was last modified.
//
// The function returns the following values:
//
//   - dateTime for the time when the resource was last modified.
func (info *RecentInfo) Modified() *glib.DateTime {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GDateTime     // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_modified(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_date_time_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)

	return _dateTime
}

// PrivateHint gets the value of the “private” flag.
//
// Resources in the recently used list that have this flag set to TRUE should
// only be displayed by the applications that have registered them.
//
// The function returns the following values:
//
//   - ok: TRUE if the private flag was found, FALSE otherwise.
func (info *RecentInfo) PrivateHint() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_private_hint(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ShortName computes a valid UTF-8 string that can be used as the name of the
// item in a menu or list.
//
// For example, calling this function on an item that refers to
// “file:///foo/bar.txt” will yield “bar.txt”.
//
// The function returns the following values:
//
//   - utf8: newly-allocated string in UTF-8 encoding free it with g_free().
func (info *RecentInfo) ShortName() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_short_name(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// URI gets the URI of the resource.
//
// The function returns the following values:
//
//   - utf8: URI of the resource. The returned string is owned by the recent
//     manager, and should not be freed.
func (info *RecentInfo) URI() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_uri(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// URIDisplay gets a displayable version of the resource’s URI.
//
// If the resource is local, it returns a local path; if the resource is not
// local, it returns the UTF-8 encoded content of gtk.RecentInfo.GetURI().
//
// The function returns the following values:
//
//   - utf8 (optional): newly allocated UTF-8 string containing the resource’s
//     URI or NULL. Use g_free() when done using it.
func (info *RecentInfo) URIDisplay() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_uri_display(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Visited gets the time when the meta-data for the resource was last visited.
//
// The function returns the following values:
//
//   - dateTime for the time when the resource was last visited.
func (info *RecentInfo) Visited() *glib.DateTime {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.GDateTime     // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_get_visited(_arg0)
	runtime.KeepAlive(info)

	var _dateTime *glib.DateTime // out

	_dateTime = (*glib.DateTime)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	C.g_date_time_ref(_cret)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_dateTime)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_date_time_unref((*C.GDateTime)(intern.C))
		},
	)

	return _dateTime
}

// HasApplication checks whether an application registered this resource using
// app_name.
//
// The function takes the following parameters:
//
//   - appName: string containing an application name.
//
// The function returns the following values:
//
//   - ok: TRUE if an application with name app_name was found, FALSE otherwise.
func (info *RecentInfo) HasApplication(appName string) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.char          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(appName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_has_application(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(appName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// HasGroup checks whether group_name appears inside the groups registered for
// the recently used item info.
//
// The function takes the following parameters:
//
//   - groupName: name of a group.
//
// The function returns the following values:
//
//   - ok: TRUE if the group was found.
func (info *RecentInfo) HasGroup(groupName string) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.char          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(groupName)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_recent_info_has_group(_arg0, _arg1)
	runtime.KeepAlive(info)
	runtime.KeepAlive(groupName)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsLocal checks whether the resource is local or not by looking at the scheme
// of its URI.
//
// The function returns the following values:
//
//   - ok: TRUE if the resource is local.
func (info *RecentInfo) IsLocal() bool {
	var _arg0 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_is_local(_arg0)
	runtime.KeepAlive(info)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LastApplication gets the name of the last application that have registered
// the recently used resource represented by info.
//
// The function returns the following values:
//
//   - utf8: application name. Use g_free() to free it.
func (info *RecentInfo) LastApplication() string {
	var _arg0 *C.GtkRecentInfo // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(info)))

	_cret = C.gtk_recent_info_last_application(_arg0)
	runtime.KeepAlive(info)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Match checks whether two GtkRecentInfo point to the same resource.
//
// The function takes the following parameters:
//
//   - infoB: GtkRecentInfo.
//
// The function returns the following values:
//
//   - ok: TRUE if both GtkRecentInfo point to the same resource, FALSE
//     otherwise.
func (infoA *RecentInfo) Match(infoB *RecentInfo) bool {
	var _arg0 *C.GtkRecentInfo // out
	var _arg1 *C.GtkRecentInfo // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(infoA)))
	_arg1 = (*C.GtkRecentInfo)(gextras.StructNative(unsafe.Pointer(infoB)))

	_cret = C.gtk_recent_info_match(_arg0, _arg1)
	runtime.KeepAlive(infoA)
	runtime.KeepAlive(infoB)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// RecentManagerClass contains only private data.
//
// An instance of this type is always passed by reference.
type RecentManagerClass struct {
	*recentManagerClass
}

// recentManagerClass is the struct that's finalized.
type recentManagerClass struct {
	native *C.GtkRecentManagerClass
}

// RequestedSize represents a request of a screen object in a given orientation.
// These are primarily used in container implementations when allocating a
// natural size for children calling. See gtk_distribute_natural_allocation().
//
// An instance of this type is always passed by reference.
type RequestedSize struct {
	*requestedSize
}

// requestedSize is the struct that's finalized.
type requestedSize struct {
	native *C.GtkRequestedSize
}

// Data: client pointer.
func (r *RequestedSize) Data() unsafe.Pointer {
	valptr := &r.native.data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// MinimumSize: minimum size needed for allocation in a given orientation.
func (r *RequestedSize) MinimumSize() int {
	valptr := &r.native.minimum_size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// NaturalSize: natural size for allocation in a given orientation.
func (r *RequestedSize) NaturalSize() int {
	valptr := &r.native.natural_size
	var _v int // out
	_v = int(*valptr)
	return _v
}

// MinimumSize: minimum size needed for allocation in a given orientation.
func (r *RequestedSize) SetMinimumSize(minimumSize int) {
	valptr := &r.native.minimum_size
	*valptr = C.int(minimumSize)
}

// NaturalSize: natural size for allocation in a given orientation.
func (r *RequestedSize) SetNaturalSize(naturalSize int) {
	valptr := &r.native.natural_size
	*valptr = C.int(naturalSize)
}

// Requisition represents the desired size of a widget. See [GtkWidget’s
// geometry management section][geometry-management] for more information.
//
// An instance of this type is always passed by reference.
type Requisition struct {
	*requisition
}

// requisition is the struct that's finalized.
type requisition struct {
	native *C.GtkRequisition
}

func marshalRequisition(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Requisition{&requisition{(*C.GtkRequisition)(b)}}, nil
}

// NewRequisition constructs a struct Requisition.
func NewRequisition() *Requisition {
	var _cret *C.GtkRequisition // in

	_cret = C.gtk_requisition_new()

	var _requisition *Requisition // out

	_requisition = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_requisition)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _requisition
}

// Width widget’s desired width.
func (r *Requisition) Width() int {
	valptr := &r.native.width
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Height widget’s desired height.
func (r *Requisition) Height() int {
	valptr := &r.native.height
	var _v int // out
	_v = int(*valptr)
	return _v
}

// Width widget’s desired width.
func (r *Requisition) SetWidth(width int) {
	valptr := &r.native.width
	*valptr = C.int(width)
}

// Height widget’s desired height.
func (r *Requisition) SetHeight(height int) {
	valptr := &r.native.height
	*valptr = C.int(height)
}

// Copy copies a GtkRequisition.
//
// The function returns the following values:
//
//   - ret: copy of requisition.
func (requisition *Requisition) Copy() *Requisition {
	var _arg0 *C.GtkRequisition // out
	var _cret *C.GtkRequisition // in

	_arg0 = (*C.GtkRequisition)(gextras.StructNative(unsafe.Pointer(requisition)))

	_cret = C.gtk_requisition_copy(_arg0)
	runtime.KeepAlive(requisition)

	var _ret *Requisition // out

	_ret = (*Requisition)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_ret)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_requisition_free((*C.GtkRequisition)(intern.C))
		},
	)

	return _ret
}

// ScaleButtonClass: instance of this type is always passed by reference.
type ScaleButtonClass struct {
	*scaleButtonClass
}

// scaleButtonClass is the struct that's finalized.
type scaleButtonClass struct {
	native *C.GtkScaleButtonClass
}

func (s *ScaleButtonClass) ParentClass() *WidgetClass {
	valptr := &s.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ScaleClass: instance of this type is always passed by reference.
type ScaleClass struct {
	*scaleClass
}

// scaleClass is the struct that's finalized.
type scaleClass struct {
	native *C.GtkScaleClass
}

func (s *ScaleClass) ParentClass() *RangeClass {
	valptr := &s.native.parent_class
	var _v *RangeClass // out
	_v = (*RangeClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ScrollableInterface: instance of this type is always passed by reference.
type ScrollableInterface struct {
	*scrollableInterface
}

// scrollableInterface is the struct that's finalized.
type scrollableInterface struct {
	native *C.GtkScrollableInterface
}

// SelectionFilterModelClass: instance of this type is always passed by
// reference.
type SelectionFilterModelClass struct {
	*selectionFilterModelClass
}

// selectionFilterModelClass is the struct that's finalized.
type selectionFilterModelClass struct {
	native *C.GtkSelectionFilterModelClass
}

// SelectionModelInterface: list of virtual functions for the
// SelectionModel interface. No function must be implemented, but unless
// SelectionModel::is_selected() is implemented, it will not be possible to
// select items in the set.
//
// The model does not need to implement any functions to support either
// selecting or unselecting items. Of course, if the model does not do that,
// it means that users cannot select or unselect items in a list widget using
// the model.
//
// All selection functions fall back to SelectionModel::set_selection() so it is
// sufficient to implement just that function for full selection support.
//
// An instance of this type is always passed by reference.
type SelectionModelInterface struct {
	*selectionModelInterface
}

// selectionModelInterface is the struct that's finalized.
type selectionModelInterface struct {
	native *C.GtkSelectionModelInterface
}

// ShortcutClass: instance of this type is always passed by reference.
type ShortcutClass struct {
	*shortcutClass
}

// shortcutClass is the struct that's finalized.
type shortcutClass struct {
	native *C.GtkShortcutClass
}

// ShortcutManagerInterface: list of functions that can be implemented for the
// ShortcutManager interface.
//
// Note that no function is mandatory to implement, the default implementation
// will work fine.
//
// An instance of this type is always passed by reference.
type ShortcutManagerInterface struct {
	*shortcutManagerInterface
}

// shortcutManagerInterface is the struct that's finalized.
type shortcutManagerInterface struct {
	native *C.GtkShortcutManagerInterface
}

// SingleSelectionClass: instance of this type is always passed by reference.
type SingleSelectionClass struct {
	*singleSelectionClass
}

// singleSelectionClass is the struct that's finalized.
type singleSelectionClass struct {
	native *C.GtkSingleSelectionClass
}

// SliceListModelClass: instance of this type is always passed by reference.
type SliceListModelClass struct {
	*sliceListModelClass
}

// sliceListModelClass is the struct that's finalized.
type sliceListModelClass struct {
	native *C.GtkSliceListModelClass
}

// SortListModelClass: instance of this type is always passed by reference.
type SortListModelClass struct {
	*sortListModelClass
}

// sortListModelClass is the struct that's finalized.
type sortListModelClass struct {
	native *C.GtkSortListModelClass
}

// SorterClass: virtual table for GtkSorter.
//
// An instance of this type is always passed by reference.
type SorterClass struct {
	*sorterClass
}

// sorterClass is the struct that's finalized.
type sorterClass struct {
	native *C.GtkSorterClass
}

// StringFilterClass: instance of this type is always passed by reference.
type StringFilterClass struct {
	*stringFilterClass
}

// stringFilterClass is the struct that's finalized.
type stringFilterClass struct {
	native *C.GtkStringFilterClass
}

func (s *StringFilterClass) ParentClass() *FilterClass {
	valptr := &s.native.parent_class
	var _v *FilterClass // out
	_v = (*FilterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// StringListClass: instance of this type is always passed by reference.
type StringListClass struct {
	*stringListClass
}

// stringListClass is the struct that's finalized.
type stringListClass struct {
	native *C.GtkStringListClass
}

// StringObjectClass: instance of this type is always passed by reference.
type StringObjectClass struct {
	*stringObjectClass
}

// stringObjectClass is the struct that's finalized.
type stringObjectClass struct {
	native *C.GtkStringObjectClass
}

// StringSorterClass: instance of this type is always passed by reference.
type StringSorterClass struct {
	*stringSorterClass
}

// stringSorterClass is the struct that's finalized.
type stringSorterClass struct {
	native *C.GtkStringSorterClass
}

func (s *StringSorterClass) ParentClass() *SorterClass {
	valptr := &s.native.parent_class
	var _v *SorterClass // out
	_v = (*SorterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// StyleContextClass: instance of this type is always passed by reference.
type StyleContextClass struct {
	*styleContextClass
}

// styleContextClass is the struct that's finalized.
type styleContextClass struct {
	native *C.GtkStyleContextClass
}

// TextBufferClass class structure for TextBuffer.
//
// An instance of this type is always passed by reference.
type TextBufferClass struct {
	*textBufferClass
}

// textBufferClass is the struct that's finalized.
type textBufferClass struct {
	native *C.GtkTextBufferClass
}

// TextChildAnchorClass: instance of this type is always passed by reference.
type TextChildAnchorClass struct {
	*textChildAnchorClass
}

// textChildAnchorClass is the struct that's finalized.
type textChildAnchorClass struct {
	native *C.GtkTextChildAnchorClass
}

// TextIter: iterator for the contents of a GtkTextBuffer.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
//
// An instance of this type is always passed by reference.
type TextIter struct {
	*textIter
}

// textIter is the struct that's finalized.
type textIter struct {
	native *C.GtkTextIter
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TextIter{&textIter{(*C.GtkTextIter)(b)}}, nil
}

// Assign assigns the value of other to iter.
//
// This function is not useful in applications, because iterators can be
// assigned with GtkTextIter i = j;.
//
// The function is used by language bindings.
//
// The function takes the following parameters:
//
//   - other GtkTextIter.
func (iter *TextIter) Assign(other *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(other)))

	C.gtk_text_iter_assign(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(other)
}

// BackwardChar moves backward by one character offset.
//
// Returns TRUE if movement was possible; if iter was the first in the buffer
// (character offset 0), this function returns FALSE for convenience when
// writing loops.
//
// The function returns the following values:
//
//   - ok: whether movement was possible.
func (iter *TextIter) BackwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_char(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardChars moves count characters backward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator,
// then FALSE is returned. If count is 0, the function does nothing and returns
// FALSE.
//
// The function takes the following parameters:
//
//   - count: number of characters to move.
//
// The function returns the following values:
//
//   - ok: whether iter moved and is dereferenceable.
func (iter *TextIter) BackwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_chars(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(),
// but moves backward.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved.
func (iter *TextIter) BackwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_cursor_position(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPositions moves up to count cursor positions.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
//
// The function takes the following parameters:
//
//   - count: number of positions to move.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new position is dereferenceable.
func (iter *TextIter) BackwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_cursor_positions(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardFindChar: same as gtk_text_iter_forward_find_char(), but goes
// backward from iter.
//
// The function takes the following parameters:
//
//   - pred: function to be called on each character.
//   - limit (optional): search limit, or NULL for none.
//
// The function returns the following values:
//
//   - ok: whether a match was found.
func (iter *TextIter) BackwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var _arg0 *C.GtkTextIter         // out
	var _arg1 C.GtkTextCharPredicate // out
	var _arg2 C.gpointer
	var _arg3 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TextCharPredicate)
	_arg2 = C.gpointer(gbox.Assign(pred))
	defer gbox.Delete(uintptr(_arg2))
	if limit != nil {
		_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(limit)))
	}

	_cret = C.gtk_text_iter_backward_find_char(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(pred)
	runtime.KeepAlive(limit)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLine moves iter to the start of the previous line.
//
// Returns TRUE if iter could be moved; i.e. if iter was at character offset 0,
// this function returns FALSE. Therefore, if iter was already on line 0,
// but not at the start of the line, iter is snapped to the start of the line
// and the function returns TRUE. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.).
//
// The function returns the following values:
//
//   - ok: whether iter moved.
func (iter *TextIter) BackwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLines moves count lines backward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator,
// then FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves forward by 0 - count lines.
//
// The function takes the following parameters:
//
//   - count: number of lines to move backward.
//
// The function returns the following values:
//
//   - ok: whether iter moved and is dereferenceable.
func (iter *TextIter) BackwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_lines(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
//
// match_end will never be set to a GtkTextIter located after iter, even if
// there is a possible match_start before or at iter.
//
// The function takes the following parameters:
//
//   - str: search string.
//   - flags: bitmask of flags affecting the search.
//   - limit (optional): location of last possible match_start, or NULL for
//     start of buffer.
//
// The function returns the following values:
//
//   - matchStart (optional): return location for start of match, or NULL.
//   - matchEnd (optional): return location for end of match, or NULL.
//   - ok: whether a match was found.
func (iter *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart *TextIter, matchEnd *TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.char              // out
	var _arg2 C.GtkTextSearchFlags // out
	var _arg3 C.GtkTextIter        // in
	var _arg4 C.GtkTextIter        // in
	var _arg5 *C.GtkTextIter       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GtkTextSearchFlags(flags)
	if limit != nil {
		_arg5 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(limit)))
	}

	_cret = C.gtk_text_iter_backward_search(_arg0, _arg1, _arg2, &_arg3, &_arg4, _arg5)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(str)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(limit)

	var _matchStart *TextIter // out
	var _matchEnd *TextIter   // out
	var _ok bool              // out

	_matchStart = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	_matchEnd = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))
	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// BackwardSentenceStart moves backward to the previous sentence start.
//
// If iter is already at the start of a sentence, moves backward to the next
// one.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) BackwardSentenceStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_sentence_start(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// count times.
//
// If count is negative, moves forward instead of backward.
//
// The function takes the following parameters:
//
//   - count: number of sentences to move.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) BackwardSentenceStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_sentence_starts(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the tag,
// or to the next toggle of any tag if tag is NULL.
//
// If no matching tag toggles are found, returns FALSE, otherwise TRUE. Does not
// return toggles located at iter, only toggles before iter. Sets iter to the
// location of the toggle, or the start of the buffer if no toggle is found.
//
// The function takes the following parameters:
//
//   - tag (optional): GtkTextTag, or NULL.
//
// The function returns the following values:
//
//   - ok: whether we found a tag toggle before iter.
func (iter *TextIter) BackwardToTagToggle(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = C.gtk_text_iter_backward_to_tag_toggle(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPosition moves iter forward to the previous visible
// cursor position.
//
// See gtk.TextIter.BackwardCursorPosition() for details.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new position is dereferenceable.
func (iter *TextIter) BackwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_visible_cursor_position(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPositions moves up to count visible cursor positions.
//
// See gtk.TextIter.BackwardCursorPosition() for details.
//
// The function takes the following parameters:
//
//   - count: number of positions to move.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new position is dereferenceable.
func (iter *TextIter) BackwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_visible_cursor_positions(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLine moves iter to the start of the previous visible line.
//
// Returns TRUE if iter could be moved; i.e. if iter was at character offset 0,
// this function returns FALSE. Therefore if iter was already on line 0,
// but not at the start of the line, iter is snapped to the start of the line
// and the function returns TRUE. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.).
//
// The function returns the following values:
//
//   - ok: whether iter moved.
func (iter *TextIter) BackwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_visible_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLines moves count visible lines backward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator,
// then FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves forward by 0 - count lines.
//
// The function takes the following parameters:
//
//   - count: number of lines to move backward.
//
// The function returns the following values:
//
//   - ok: whether iter moved and is dereferenceable.
func (iter *TextIter) BackwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_visible_lines(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
//
// If iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) BackwardVisibleWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_visible_word_start(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to count times.
//
// The function takes the following parameters:
//
//   - count: number of times to move.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) BackwardVisibleWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_visible_word_starts(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStart moves backward to the previous word start.
//
// If iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) BackwardWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_backward_word_start(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to count
// times.
//
// The function takes the following parameters:
//
//   - count: number of times to move.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) BackwardWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_word_starts(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanInsert: considering the default editability of the buffer, and tags
// that affect editability, determines whether text inserted at iter would be
// editable.
//
// If text inserted at iter would be editable then the user should be allowed to
// insert text at iter. gtk.TextBuffer.InsertInteractive() uses this function to
// decide whether insertions are allowed at a given position.
//
// The function takes the following parameters:
//
//   - defaultEditability: TRUE if text is editable by default.
//
// The function returns the following values:
//
//   - ok: whether text inserted at iter would be editable.
func (iter *TextIter) CanInsert(defaultEditability bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if defaultEditability {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_can_insert(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(defaultEditability)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Compare: qsort()-style function that returns negative if lhs is less than
// rhs, positive if lhs is greater than rhs, and 0 if they’re equal.
//
// Ordering is in character offset order, i.e. the first character in the buffer
// is less than the second character in the buffer.
//
// The function takes the following parameters:
//
//   - rhs: another GtkTextIter.
//
// The function returns the following values:
//
//   - gint: -1 if lhs is less than rhs, 1 if lhs is greater, 0 if they are
//     equal.
func (lhs *TextIter) Compare(rhs *TextIter) int {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(lhs)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(rhs)))

	_cret = C.gtk_text_iter_compare(_arg0, _arg1)
	runtime.KeepAlive(lhs)
	runtime.KeepAlive(rhs)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Copy creates a dynamically-allocated copy of an iterator.
//
// This function is not useful in applications, because iterators can be copied
// with a simple assignment (GtkTextIter i = j;).
//
// The function is used by language bindings.
//
// The function returns the following values:
//
//   - textIter: copy of the iter, free with gtk.TextIter.Free().
func (iter *TextIter) Copy() *TextIter {
	var _arg0 *C.GtkTextIter // out
	var _cret *C.GtkTextIter // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_copy(_arg0)
	runtime.KeepAlive(iter)

	var _textIter *TextIter // out

	_textIter = (*TextIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_textIter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_text_iter_free((*C.GtkTextIter)(intern.C))
		},
	)

	return _textIter
}

// Editable returns whether the character at iter is within an editable region
// of text.
//
// Non-editable text is “locked” and can’t be changed by the user via TextView.
// If no tags applied to this text affect editability, default_setting will be
// returned.
//
// You don’t want to use this function to decide whether text can be
// inserted at iter, because for insertion you don’t want to know whether
// the char at iter is inside an editable range, you want to know whether
// a new character inserted at iter would be inside an editable range. Use
// gtk.TextIter.CanInsert() to handle this case.
//
// The function takes the following parameters:
//
//   - defaultSetting: TRUE if text is editable by default.
//
// The function returns the following values:
//
//   - ok: whether iter is inside an editable range.
func (iter *TextIter) Editable(defaultSetting bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if defaultSetting {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_editable(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(defaultSetting)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsLine returns TRUE if iter points to the start of the paragraph delimiter
// characters for a line.
//
// Delimiters will be either a newline, a carriage return, a carriage return
// followed by a newline, or a Unicode paragraph separator character.
//
// Note that an iterator pointing to the \n of a \r\n pair will not be counted
// as the end of a line, the line ends before the \r. The end iterator is
// considered to be at the end of a line, even though there are no paragraph
// delimiter chars there.
//
// The function returns the following values:
//
//   - ok: whether iter is at the end of a line.
func (iter *TextIter) EndsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_ends_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsSentence determines whether iter ends a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is at the end of a sentence.
func (iter *TextIter) EndsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_ends_sentence(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsTag returns TRUE if tag is toggled off at exactly this point.
//
// If tag is NULL, returns TRUE if any tag is toggled off at this point.
//
// Note that if this function returns TRUE, it means that iter is at the end of
// the tagged range, but that the character at iter is outside the tagged range.
// In other words, unlike gtk.TextIter.StartsTag(), if this function returns
// TRUE, gtk.TextIter.HasTag() will return FALSE for the same parameters.
//
// The function takes the following parameters:
//
//   - tag (optional): GtkTextTag, or NULL.
//
// The function returns the following values:
//
//   - ok: whether iter is the end of a range tagged with tag.
func (iter *TextIter) EndsTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = C.gtk_text_iter_ends_tag(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsWord determines whether iter ends a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is at the end of a word.
func (iter *TextIter) EndsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_ends_word(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism.
//
// This function is very fast; you can expect it to perform better than e.g.
// getting the character offset for each iterator and comparing the offsets
// yourself. Also, it’s a bit faster than gtk.TextIter.Compare().
//
// The function takes the following parameters:
//
//   - rhs: another GtkTextIter.
//
// The function returns the following values:
//
//   - ok: TRUE if the iterators point to the same place in the buffer.
func (lhs *TextIter) Equal(rhs *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(lhs)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(rhs)))

	_cret = C.gtk_text_iter_equal(_arg0, _arg1)
	runtime.KeepAlive(lhs)
	runtime.KeepAlive(rhs)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChar moves iter forward by one character offset.
//
// Note that images embedded in the buffer occupy 1 character slot, so this
// function may actually move onto an image instead of a character, if you have
// images in your buffer. If iter is the end iterator or one character before
// it, iter will now point at the end iterator, and this function returns FALSE
// for convenience when writing loops.
//
// The function returns the following values:
//
//   - ok: whether iter moved and is dereferenceable.
func (iter *TextIter) ForwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_char(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChars moves count characters if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the new position of iter is different from
// its original position, and dereferenceable (the last iterator in the buffer
// is not dereferenceable). If count is 0, the function does nothing and returns
// FALSE.
//
// The function takes the following parameters:
//
//   - count: number of characters to move, may be negative.
//
// The function returns the following values:
//
//   - ok: whether iter moved and is dereferenceable.
func (iter *TextIter) ForwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_chars(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPosition moves iter forward by a single cursor position.
//
// Cursor positions are (unsurprisingly) positions where the cursor can appear.
// Perhaps surprisingly, there may not be a cursor position between all
// characters. The most common example for European languages would be a
// carriage return/newline sequence.
//
// For some Unicode characters, the equivalent of say the letter “a” with an
// accent mark will be represented as two characters, first the letter then a
// "combining mark" that causes the accent to be rendered; so the cursor can’t
// go between those two characters.
//
// See also the pango.LogAttr struct and the pango.Break() function.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new position is dereferenceable.
func (iter *TextIter) ForwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_cursor_position(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPositions moves up to count cursor positions.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
//
// The function takes the following parameters:
//
//   - count: number of positions to move.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new position is dereferenceable.
func (iter *TextIter) ForwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_cursor_positions(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardFindChar advances iter, calling pred on each character.
//
// If pred returns TRUE, returns TRUE and stops scanning. If pred never returns
// TRUE, iter is set to limit if limit is non-NULL, otherwise to the end
// iterator.
//
// The function takes the following parameters:
//
//   - pred: function to be called on each character.
//   - limit (optional): search limit, or NULL for none.
//
// The function returns the following values:
//
//   - ok: whether a match was found.
func (iter *TextIter) ForwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var _arg0 *C.GtkTextIter         // out
	var _arg1 C.GtkTextCharPredicate // out
	var _arg2 C.gpointer
	var _arg3 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TextCharPredicate)
	_arg2 = C.gpointer(gbox.Assign(pred))
	defer gbox.Delete(uintptr(_arg2))
	if limit != nil {
		_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(limit)))
	}

	_cret = C.gtk_text_iter_forward_find_char(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(pred)
	runtime.KeepAlive(limit)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLine moves iter to the start of the next line.
//
// If the iter is already on the last line of the buffer, moves the iter to the
// end of the current line. If after the operation, the iter is at the end of
// the buffer and not dereferenceable, returns FALSE. Otherwise, returns TRUE.
//
// The function returns the following values:
//
//   - ok: whether iter can be dereferenced.
func (iter *TextIter) ForwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLines moves count lines forward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator,
// then FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves backward by 0 - count lines.
//
// The function takes the following parameters:
//
//   - count: number of lines to move forward.
//
// The function returns the following values:
//
//   - ok: whether iter moved and is dereferenceable.
func (iter *TextIter) ForwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_lines(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSearch searches forward for str.
//
// Any match is returned by setting match_start to the first character of the
// match and match_end to the first character after the match. The search will
// not continue past limit. Note that a search is a linear or O(n) operation,
// so you may wish to use limit to avoid locking up your UI on large buffers.
//
// match_start will never be set to a GtkTextIter located before iter, even if
// there is a possible match_end after or at iter.
//
// The function takes the following parameters:
//
//   - str: search string.
//   - flags affecting how the search is done.
//   - limit (optional): location of last possible match_end, or NULL for the
//     end of the buffer.
//
// The function returns the following values:
//
//   - matchStart (optional): return location for start of match, or NULL.
//   - matchEnd (optional): return location for end of match, or NULL.
//   - ok: whether a match was found.
func (iter *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart *TextIter, matchEnd *TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.char              // out
	var _arg2 C.GtkTextSearchFlags // out
	var _arg3 C.GtkTextIter        // in
	var _arg4 C.GtkTextIter        // in
	var _arg5 *C.GtkTextIter       // out
	var _cret C.gboolean           // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.GtkTextSearchFlags(flags)
	if limit != nil {
		_arg5 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(limit)))
	}

	_cret = C.gtk_text_iter_forward_search(_arg0, _arg1, _arg2, &_arg3, &_arg4, _arg5)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(str)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(limit)

	var _matchStart *TextIter // out
	var _matchEnd *TextIter   // out
	var _ok bool              // out

	_matchStart = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg3))))
	_matchEnd = (*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg4))))
	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// ForwardSentenceEnd moves forward to the next sentence end.
//
// If iter is at the end of a sentence, moves to the next end of sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) ForwardSentenceEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_sentence_end(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() count times.
//
// If count is negative, moves backward instead of forward.
//
// The function takes the following parameters:
//
//   - count: number of sentences to move.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) ForwardSentenceEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_sentence_ends(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToEnd moves iter forward to the “end iterator”, which points one past
// the last valid character in the buffer.
//
// gtk_text_iter_get_char() called on the end iterator returns 0, which is
// convenient for writing loops.
func (iter *TextIter) ForwardToEnd() {
	var _arg0 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	C.gtk_text_iter_forward_to_end(_arg0)
	runtime.KeepAlive(iter)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters.
//
// The possible characters are either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character.
//
// If the iterator is already at the paragraph delimiter characters, moves to
// the paragraph delimiter characters for the next line. If iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns FALSE.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new location is not the end iterator.
func (iter *TextIter) ForwardToLineEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_to_line_end(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the tag,
// or to the next toggle of any tag if tag is NULL.
//
// If no matching tag toggles are found, returns FALSE, otherwise TRUE. Does
// not return toggles located at iter, only toggles after iter. Sets iter to the
// location of the toggle, or to the end of the buffer if no toggle is found.
//
// The function takes the following parameters:
//
//   - tag (optional): GtkTextTag, or NULL.
//
// The function returns the following values:
//
//   - ok: whether we found a tag toggle after iter.
func (iter *TextIter) ForwardToTagToggle(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = C.gtk_text_iter_forward_to_tag_toggle(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPosition moves iter forward to the next visible cursor
// position.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new position is dereferenceable.
func (iter *TextIter) ForwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_visible_cursor_position(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPositions moves up to count visible cursor positions.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
//
// The function takes the following parameters:
//
//   - count: number of positions to move.
//
// The function returns the following values:
//
//   - ok: TRUE if we moved and the new position is dereferenceable.
func (iter *TextIter) ForwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_visible_cursor_positions(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLine moves iter to the start of the next visible line.
//
// Returns TRUE if there was a next line to move to, and FALSE if iter was
// simply moved to the end of the buffer and is now not dereferenceable,
// or if iter was already at the end of the buffer.
//
// The function returns the following values:
//
//   - ok: whether iter can be dereferenced.
func (iter *TextIter) ForwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_visible_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLines moves count visible lines forward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator,
// then FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves backward by 0 - count lines.
//
// The function takes the following parameters:
//
//   - count: number of lines to move forward.
//
// The function returns the following values:
//
//   - ok: whether iter moved and is dereferenceable.
func (iter *TextIter) ForwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_visible_lines(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnd moves forward to the next visible word end.
//
// If iter is currently on a word end, moves forward to the next one after that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) ForwardVisibleWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_visible_word_end(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// count times.
//
// The function takes the following parameters:
//
//   - count: number of times to move.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) ForwardVisibleWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_visible_word_ends(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnd moves forward to the next word end.
//
// If iter is currently on a word end, moves forward to the next one after that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) ForwardWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_forward_word_end(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to count times.
//
// The function takes the following parameters:
//
//   - count: number of times to move.
//
// The function returns the following values:
//
//   - ok: TRUE if iter moved and is not the end iterator.
func (iter *TextIter) ForwardWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_word_ends(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(count)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Buffer returns the GtkTextBuffer this iterator is associated with.
//
// The function returns the following values:
//
//   - textBuffer: buffer.
func (iter *TextIter) Buffer() *TextBuffer {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_buffer(_arg0)
	runtime.KeepAlive(iter)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(coreglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// BytesInLine returns the number of bytes in the line containing iter,
// including the paragraph delimiters.
//
// The function returns the following values:
//
//   - gint: number of bytes in the line.
func (iter *TextIter) BytesInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_bytes_in_line(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Char: unicode character at this iterator is returned.
//
// Equivalent to operator* on a C++ iterator. If the element at this iterator is
// a non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator,
// zero is returned; zero is not a valid Unicode character.
//
// So you can write a loop which ends when this function returns 0.
//
// The function returns the following values:
//
//   - gunichar: unicode character, or 0 if iter is not dereferenceable.
func (iter *TextIter) Char() uint32 {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gunichar     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_char(_arg0)
	runtime.KeepAlive(iter)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// CharsInLine returns the number of characters in the line containing iter,
// including the paragraph delimiters.
//
// The function returns the following values:
//
//   - gint: number of characters in the line.
func (iter *TextIter) CharsInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_chars_in_line(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ChildAnchor: if the location at iter contains a child anchor, the anchor is
// returned.
//
// Otherwise, NULL is returned.
//
// The function returns the following values:
//
//   - textChildAnchor: anchor at iter.
func (iter *TextIter) ChildAnchor() *TextChildAnchor {
	var _arg0 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_child_anchor(_arg0)
	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(coreglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// Language returns the language in effect at iter.
//
// If no tags affecting language apply to iter, the return value is identical to
// that of gtk.GetDefaultLanguage().
//
// The function returns the following values:
//
//   - language in effect at iter.
func (iter *TextIter) Language() *pango.Language {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.PangoLanguage // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_language(_arg0)
	runtime.KeepAlive(iter)

	var _language *pango.Language // out

	_language = (*pango.Language)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_language)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.free(intern.C)
		},
	)

	return _language
}

// Line returns the line number containing the iterator.
//
// Lines in a GtkTextBuffer are numbered beginning with 0 for the first line in
// the buffer.
//
// The function returns the following values:
//
//   - gint: line number.
func (iter *TextIter) Line() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_line(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line.
//
// Remember that GtkTextBuffer encodes text in UTF-8, and that characters can
// require a variable number of bytes to represent.
//
// The function returns the following values:
//
//   - gint: distance from start of line, in bytes.
func (iter *TextIter) LineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_line_index(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line.
//
// The first character on the line has offset 0.
//
// The function returns the following values:
//
//   - gint: offset from start of line.
func (iter *TextIter) LineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_line_offset(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Marks returns a list of all GtkTextMark at this location.
//
// Because marks are not iterable (they don’t take up any "space" in the buffer,
// they are just marks in between iterable locations), multiple marks can exist
// in the same place.
//
// The returned list is not in any meaningful order.
//
// The function returns the following values:
//
//   - sList: list of GtkTextMark.
func (iter *TextIter) Marks() []*TextMark {
	var _arg0 *C.GtkTextIter // out
	var _cret *C.GSList      // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_marks(_arg0)
	runtime.KeepAlive(iter)

	var _sList []*TextMark // out

	_sList = make([]*TextMark, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkTextMark)(v)
		var dst *TextMark // out
		dst = wrapTextMark(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// Offset returns the character offset of an iterator.
//
// Each character in a GtkTextBuffer has an offset, starting with 0 for the
// first character in the buffer. Use gtk,textbuffer.GetIterAtOffset to convert
// an offset back into an iterator.
//
// The function returns the following values:
//
//   - gint: character offset.
func (iter *TextIter) Offset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_offset(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Paintable: if the element at iter is a paintable, the paintable is returned.
//
// Otherwise, NULL is returned.
//
// The function returns the following values:
//
//   - paintable at iter.
func (iter *TextIter) Paintable() *gdk.Paintable {
	var _arg0 *C.GtkTextIter  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_paintable(_arg0)
	runtime.KeepAlive(iter)

	var _paintable *gdk.Paintable // out

	{
		obj := coreglib.Take(unsafe.Pointer(_cret))
		_paintable = &gdk.Paintable{
			Object: obj,
		}
	}

	return _paintable
}

// Slice returns the text in the given range.
//
// A “slice” is an array of characters encoded in UTF-8 format, including the
// Unicode “unknown” character 0xFFFC for iterable non-character elements in
// the buffer, such as images. Because images are encoded in the slice, byte and
// character offsets in the returned array will correspond to byte offsets in
// the text buffer. Note that 0xFFFC can occur in normal text as well, so it is
// not a reliable indicator that a paintable or widget is in the buffer.
//
// The function takes the following parameters:
//
//   - end: iterator at end of a range.
//
// The function returns the following values:
//
//   - utf8: slice of text from the buffer.
func (start *TextIter) Slice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = C.gtk_text_iter_get_slice(_arg0, _arg1)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Tags returns a list of tags that apply to iter, in ascending order of
// priority.
//
// The highest-priority tags are last.
//
// The GtkTextTags in the list don’t have a reference added, but you have to
// free the list itself.
//
// The function returns the following values:
//
//   - sList: list of GtkTextTag.
func (iter *TextIter) Tags() []*TextTag {
	var _arg0 *C.GtkTextIter // out
	var _cret *C.GSList      // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_tags(_arg0)
	runtime.KeepAlive(iter)

	var _sList []*TextTag // out

	_sList = make([]*TextTag, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkTextTag)(v)
		var dst *TextTag // out
		dst = wrapTextTag(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// Text returns text in the given range.
//
// If the range contains non-text elements such as images, the character
// and byte offsets in the returned string will not correspond to character
// and byte offsets in the buffer. If you want offsets to correspond, see
// gtk.TextIter.GetSlice().
//
// The function takes the following parameters:
//
//   - end: iterator at end of a range.
//
// The function returns the following values:
//
//   - utf8: array of characters from the buffer.
func (start *TextIter) Text(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = C.gtk_text_iter_get_text(_arg0, _arg1)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// ToggledTags returns a list of GtkTextTag that are toggled on or off at this
// point.
//
// If toggled_on is TRUE, the list contains tags that are toggled on. If a tag
// is toggled on at iter, then some non-empty range of characters following iter
// has that tag applied to it. If a tag is toggled off, then some non-empty
// range following iter does not have the tag applied to it.
//
// The function takes the following parameters:
//
//   - toggledOn: TRUE to get toggled-on tags.
//
// The function returns the following values:
//
//   - sList: tags toggled at this point.
func (iter *TextIter) ToggledTags(toggledOn bool) []*TextTag {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret *C.GSList      // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if toggledOn {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_get_toggled_tags(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(toggledOn)

	var _sList []*TextTag // out

	_sList = make([]*TextTag, 0, gextras.SListSize(unsafe.Pointer(_cret)))
	gextras.MoveSList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.GtkTextTag)(v)
		var dst *TextTag // out
		dst = wrapTextTag(coreglib.Take(unsafe.Pointer(src)))
		_sList = append(_sList, dst)
	})

	return _sList
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
//
// The function returns the following values:
//
//   - gint: byte index of iter with respect to the start of the line.
func (iter *TextIter) VisibleLineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_visible_line_index(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
//
// The function returns the following values:
//
//   - gint: offset in visible characters from the start of the line.
func (iter *TextIter) VisibleLineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_get_visible_line_offset(_arg0)
	runtime.KeepAlive(iter)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VisibleSlice returns visible text in the given range.
//
// Like gtk.TextIter.GetSlice(), but invisible text is not included. Invisible
// text is usually invisible because a GtkTextTag with the “invisible” attribute
// turned on has been applied to it.
//
// The function takes the following parameters:
//
//   - end: iterator at end of range.
//
// The function returns the following values:
//
//   - utf8: slice of text from the buffer.
func (start *TextIter) VisibleSlice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = C.gtk_text_iter_get_visible_slice(_arg0, _arg1)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleText returns visible text in the given range.
//
// Like gtk.TextIter.GetText(), but invisible text is not included. Invisible
// text is usually invisible because a GtkTextTag with the “invisible” attribute
// turned on has been applied to it.
//
// The function takes the following parameters:
//
//   - end: iterator at end of range.
//
// The function returns the following values:
//
//   - utf8: string containing visible text in the range.
func (start *TextIter) VisibleText(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = C.gtk_text_iter_get_visible_text(_arg0, _arg1)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasTag returns TRUE if iter points to a character that is part of a range
// tagged with tag.
//
// See also gtk.TextIter.StartsTag() and gtk.TextIter.EndsTag().
//
// The function takes the following parameters:
//
//   - tag: GtkTextTag.
//
// The function returns the following values:
//
//   - ok: whether iter is tagged with tag.
func (iter *TextIter) HasTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))

	_cret = C.gtk_text_iter_has_tag(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InRange checks whether iter falls in the range [start, end).
//
// start and end must be in ascending order.
//
// The function takes the following parameters:
//
//   - start of range.
//   - end of range.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is in the range.
func (iter *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	_cret = C.gtk_text_iter_in_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideSentence determines whether iter is inside a sentence (as opposed to in
// between two sentences, e.g. after a period and before the first letter of the
// next sentence).
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is inside a sentence.
func (iter *TextIter) InsideSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_inside_sentence(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideWord determines whether the character pointed by iter is part of a
// natural-language word (as opposed to say inside some whitespace).
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// Note that if gtk.TextIter.StartsWord() returns TRUE, then this function
// returns TRUE too, since iter points to the first character of the word.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is inside a word.
func (iter *TextIter) InsideWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_inside_word(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsCursorPosition: determine if iter is at a cursor position.
//
// See gtk.TextIter.ForwardCursorPosition() or pango.LogAttr or pango.Break()
// for details on what a cursor position is.
//
// The function returns the following values:
//
//   - ok: TRUE if the cursor can be placed at iter.
func (iter *TextIter) IsCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_is_cursor_position(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEnd returns TRUE if iter is the end iterator.
//
// This means it is one past the last dereferenceable iterator in the buffer.
// gtk_text_iter_is_end() is the most efficient way to check whether an iterator
// is the end iterator.
//
// The function returns the following values:
//
//   - ok: whether iter is the end iterator.
func (iter *TextIter) IsEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_is_end(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsStart returns TRUE if iter is the first iterator in the buffer.
//
// The function returns the following values:
//
//   - ok: whether iter is the first in the buffer.
func (iter *TextIter) IsStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_is_start(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Order swaps the value of first and second if second comes before first in the
// buffer.
//
// That is, ensures that first and second are in sequence. Most text buffer
// functions that take a range call this automatically on your behalf,
// so there’s no real reason to call it yourself in those cases. There are some
// exceptions, such as gtk.TextIter.InRange(), that expect a pre-sorted range.
//
// The function takes the following parameters:
//
//   - second: another GtkTextIter.
func (first *TextIter) Order(second *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(first)))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(second)))

	C.gtk_text_iter_order(_arg0, _arg1)
	runtime.KeepAlive(first)
	runtime.KeepAlive(second)
}

// SetLine moves iterator iter to the start of the line line_number.
//
// If line_number is negative or larger than or equal to the number of lines in
// the buffer, moves iter to the start of the last line in the buffer.
//
// The function takes the following parameters:
//
//   - lineNumber: line number (counted from 0).
func (iter *TextIter) SetLine(lineNumber int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(lineNumber)

	C.gtk_text_iter_set_line(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(lineNumber)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
//
// The function takes the following parameters:
//
//   - byteOnLine: byte index relative to the start of iter’s current line.
func (iter *TextIter) SetLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(byteOnLine)

	C.gtk_text_iter_set_line_index(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(byteOnLine)
}

// SetLineOffset moves iter within a line, to a new character (not byte) offset.
//
// The given character offset must be less than or equal to the number of
// characters in the line; if equal, iter moves to the start of the next line.
// See gtk.TextIter.SetLineIndex() if you have a byte index rather than a
// character offset.
//
// The function takes the following parameters:
//
//   - charOnLine: character offset relative to the start of iter’s current
//     line.
func (iter *TextIter) SetLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(charOnLine)

	C.gtk_text_iter_set_line_offset(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(charOnLine)
}

// SetOffset sets iter to point to char_offset.
//
// char_offset counts from the start of the entire text buffer, starting with 0.
//
// The function takes the following parameters:
//
//   - charOffset: character number.
func (iter *TextIter) SetOffset(charOffset int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(charOffset)

	C.gtk_text_iter_set_offset(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(charOffset)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
//
// The function takes the following parameters:
//
//   - byteOnLine: byte index.
func (iter *TextIter) SetVisibleLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(byteOnLine)

	C.gtk_text_iter_set_visible_line_index(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(byteOnLine)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset
// is in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
//
// The function takes the following parameters:
//
//   - charOnLine: character offset.
func (iter *TextIter) SetVisibleLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg1 = C.int(charOnLine)

	C.gtk_text_iter_set_visible_line_offset(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(charOnLine)
}

// StartsLine returns TRUE if iter begins a paragraph.
//
// This is the case if gtk.TextIter.GetLineOffset() would return 0. However this
// function is potentially more efficient than gtk.TextIter.GetLineOffset(),
// because it doesn’t have to compute the offset, it just has to see whether
// it’s 0.
//
// The function returns the following values:
//
//   - ok: whether iter begins a line.
func (iter *TextIter) StartsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_starts_line(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsSentence determines whether iter begins a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is at the start of a sentence.
func (iter *TextIter) StartsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_starts_sentence(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsTag returns TRUE if tag is toggled on at exactly this point.
//
// If tag is NULL, returns TRUE if any tag is toggled on at this point.
//
// Note that if this function returns TRUE, it means that iter is at the
// beginning of the tagged range, and that the character at iter is inside the
// tagged range. In other words, unlike gtk.TextIter.EndsTag(), if this function
// returns TRUE, [methodGtk.TextIter.has_tag will also return TRUE for the same
// parameters.
//
// The function takes the following parameters:
//
//   - tag (optional): GtkTextTag, or NULL.
//
// The function returns the following values:
//
//   - ok: whether iter is the start of a range tagged with tag.
func (iter *TextIter) StartsTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = C.gtk_text_iter_starts_tag(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsWord determines whether iter begins a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// The function returns the following values:
//
//   - ok: TRUE if iter is at the start of a word.
func (iter *TextIter) StartsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_iter_starts_word(_arg0)
	runtime.KeepAlive(iter)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TogglesTag gets whether a range with tag applied to it begins or ends at
// iter.
//
// This is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag()).
//
// The function takes the following parameters:
//
//   - tag (optional): GtkTextTag, or NULL.
//
// The function returns the following values:
//
//   - ok: whether tag is toggled on or off at iter.
func (iter *TextIter) TogglesTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if tag != nil {
		_arg1 = (*C.GtkTextTag)(unsafe.Pointer(coreglib.InternObject(tag).Native()))
	}

	_cret = C.gtk_text_iter_toggles_tag(_arg0, _arg1)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(tag)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TextMarkClass: instance of this type is always passed by reference.
type TextMarkClass struct {
	*textMarkClass
}

// textMarkClass is the struct that's finalized.
type textMarkClass struct {
	native *C.GtkTextMarkClass
}

// TextTagClass: instance of this type is always passed by reference.
type TextTagClass struct {
	*textTagClass
}

// textTagClass is the struct that's finalized.
type textTagClass struct {
	native *C.GtkTextTagClass
}

// TextViewClass: instance of this type is always passed by reference.
type TextViewClass struct {
	*textViewClass
}

// textViewClass is the struct that's finalized.
type textViewClass struct {
	native *C.GtkTextViewClass
}

// ParentClass: object class structure needs to be the first.
func (t *TextViewClass) ParentClass() *WidgetClass {
	valptr := &t.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// ToggleButtonClass: instance of this type is always passed by reference.
type ToggleButtonClass struct {
	*toggleButtonClass
}

// toggleButtonClass is the struct that's finalized.
type toggleButtonClass struct {
	native *C.GtkToggleButtonClass
}

func (t *ToggleButtonClass) ParentClass() *ButtonClass {
	valptr := &t.native.parent_class
	var _v *ButtonClass // out
	_v = (*ButtonClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TreeDragDestIface: instance of this type is always passed by reference.
type TreeDragDestIface struct {
	*treeDragDestIface
}

// treeDragDestIface is the struct that's finalized.
type treeDragDestIface struct {
	native *C.GtkTreeDragDestIface
}

// TreeDragSourceIface: instance of this type is always passed by reference.
type TreeDragSourceIface struct {
	*treeDragSourceIface
}

// treeDragSourceIface is the struct that's finalized.
type treeDragSourceIface struct {
	native *C.GtkTreeDragSourceIface
}

// TreeExpanderClass: instance of this type is always passed by reference.
type TreeExpanderClass struct {
	*treeExpanderClass
}

// treeExpanderClass is the struct that's finalized.
type treeExpanderClass struct {
	native *C.GtkTreeExpanderClass
}

func (t *TreeExpanderClass) ParentClass() *WidgetClass {
	valptr := &t.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TreeIter is the primary structure for accessing a TreeModel. Models are
// expected to put a unique integer in the stamp member, and put model-specific
// data in the three user_data members.
//
// An instance of this type is always passed by reference.
type TreeIter struct {
	*treeIter
}

// treeIter is the struct that's finalized.
type treeIter struct {
	native *C.GtkTreeIter
}

func marshalTreeIter(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreeIter{&treeIter{(*C.GtkTreeIter)(b)}}, nil
}

// Stamp: unique stamp to catch invalid iterators.
func (t *TreeIter) Stamp() int {
	valptr := &t.native.stamp
	var _v int // out
	_v = int(*valptr)
	return _v
}

// UserData: model-specific data.
func (t *TreeIter) UserData() unsafe.Pointer {
	valptr := &t.native.user_data
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// UserData2: model-specific data.
func (t *TreeIter) UserData2() unsafe.Pointer {
	valptr := &t.native.user_data2
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// UserData3: model-specific data.
func (t *TreeIter) UserData3() unsafe.Pointer {
	valptr := &t.native.user_data3
	var _v unsafe.Pointer // out
	_v = (unsafe.Pointer)(unsafe.Pointer(*valptr))
	return _v
}

// Stamp: unique stamp to catch invalid iterators.
func (t *TreeIter) SetStamp(stamp int) {
	valptr := &t.native.stamp
	*valptr = C.int(stamp)
}

// Copy creates a dynamically allocated tree iterator as a copy of iter.
//
// This function is not intended for use in applications, because you can just
// copy the structs by value (GtkTreeIter new_iter = iter;). You must free this
// iter with gtk_tree_iter_free().
//
// The function returns the following values:
//
//   - treeIter: newly-allocated copy of iter.
func (iter *TreeIter) Copy() *TreeIter {
	var _arg0 *C.GtkTreeIter // out
	var _cret *C.GtkTreeIter // in

	_arg0 = (*C.GtkTreeIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_tree_iter_copy(_arg0)
	runtime.KeepAlive(iter)

	var _treeIter *TreeIter // out

	_treeIter = (*TreeIter)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treeIter)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_iter_free((*C.GtkTreeIter)(intern.C))
		},
	)

	return _treeIter
}

// TreeListModelClass: instance of this type is always passed by reference.
type TreeListModelClass struct {
	*treeListModelClass
}

// treeListModelClass is the struct that's finalized.
type treeListModelClass struct {
	native *C.GtkTreeListModelClass
}

// TreeListRowClass: instance of this type is always passed by reference.
type TreeListRowClass struct {
	*treeListRowClass
}

// treeListRowClass is the struct that's finalized.
type treeListRowClass struct {
	native *C.GtkTreeListRowClass
}

// TreeListRowSorterClass: instance of this type is always passed by reference.
type TreeListRowSorterClass struct {
	*treeListRowSorterClass
}

// treeListRowSorterClass is the struct that's finalized.
type treeListRowSorterClass struct {
	native *C.GtkTreeListRowSorterClass
}

func (t *TreeListRowSorterClass) ParentClass() *SorterClass {
	valptr := &t.native.parent_class
	var _v *SorterClass // out
	_v = (*SorterClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// TreeModelFilterClass: instance of this type is always passed by reference.
type TreeModelFilterClass struct {
	*treeModelFilterClass
}

// treeModelFilterClass is the struct that's finalized.
type treeModelFilterClass struct {
	native *C.GtkTreeModelFilterClass
}

// TreeModelIface: instance of this type is always passed by reference.
type TreeModelIface struct {
	*treeModelIface
}

// treeModelIface is the struct that's finalized.
type treeModelIface struct {
	native *C.GtkTreeModelIface
}

// TreeModelSortClass: instance of this type is always passed by reference.
type TreeModelSortClass struct {
	*treeModelSortClass
}

// treeModelSortClass is the struct that's finalized.
type treeModelSortClass struct {
	native *C.GtkTreeModelSortClass
}

// TreePath: opaque structure representing a path to a row in a model.
//
// An instance of this type is always passed by reference.
type TreePath struct {
	*treePath
}

// treePath is the struct that's finalized.
type treePath struct {
	native *C.GtkTreePath
}

func marshalTreePath(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreePath{&treePath{(*C.GtkTreePath)(b)}}, nil
}

// NewTreePath constructs a struct TreePath.
func NewTreePath() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new()

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// NewTreePathFirst constructs a struct TreePath.
func NewTreePathFirst() *TreePath {
	var _cret *C.GtkTreePath // in

	_cret = C.gtk_tree_path_new_first()

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// NewTreePathFromIndices constructs a struct TreePath.
func NewTreePathFromIndices(indices []int) *TreePath {
	var _arg1 *C.int // out
	var _arg2 C.gsize
	var _cret *C.GtkTreePath // in

	_arg2 = (C.gsize)(len(indices))
	_arg1 = (*C.int)(C.calloc(C.size_t(len(indices)), C.size_t(C.sizeof_int)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		out := unsafe.Slice((*C.int)(_arg1), len(indices))
		for i := range indices {
			out[i] = C.int(indices[i])
		}
	}

	_cret = C.gtk_tree_path_new_from_indicesv(_arg1, _arg2)
	runtime.KeepAlive(indices)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// NewTreePathFromString constructs a struct TreePath.
func NewTreePathFromString(path string) *TreePath {
	var _arg1 *C.char        // out
	var _cret *C.GtkTreePath // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_tree_path_new_from_string(_arg1)
	runtime.KeepAlive(path)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// AppendIndex appends a new index to a path.
//
// As a result, the depth of the path is increased.
//
// The function takes the following parameters:
//
//   - index_: index.
func (path *TreePath) AppendIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.int(index_)

	C.gtk_tree_path_append_index(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(index_)
}

// Compare compares two paths.
//
// If a appears before b in a tree, then -1 is returned. If b appears before a,
// then 1 is returned. If the two nodes are equal, then 0 is returned.
//
// The function takes the following parameters:
//
//   - b to compare with.
//
// The function returns the following values:
//
//   - gint: relative positions of a and b.
func (a *TreePath) Compare(b *TreePath) int {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(a)))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(b)))

	_cret = C.gtk_tree_path_compare(_arg0, _arg1)
	runtime.KeepAlive(a)
	runtime.KeepAlive(b)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Copy creates a new TreePath-struct as a copy of path.
//
// The function returns the following values:
//
//   - treePath: new TreePath-struct.
func (path *TreePath) Copy() *TreePath {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.GtkTreePath // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_copy(_arg0)
	runtime.KeepAlive(path)

	var _treePath *TreePath // out

	_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treePath)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
		},
	)

	return _treePath
}

// Down moves path to point to the first child of the current path.
func (path *TreePath) Down() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_path_down(_arg0)
	runtime.KeepAlive(path)
}

// Depth returns the current depth of path.
//
// The function returns the following values:
//
//   - gint: depth of path.
func (path *TreePath) Depth() int {
	var _arg0 *C.GtkTreePath // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_get_depth(_arg0)
	runtime.KeepAlive(path)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Indices returns the current indices of path.
//
// This is an array of integers, each representing a node in a tree. It also
// returns the number of elements in the array. The array should not be freed.
//
// The function returns the following values:
//
//   - gints: current indices, or NULL.
func (path *TreePath) Indices() []int {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.int         // in
	var _arg1 C.int          // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_get_indices_with_depth(_arg0, &_arg1)
	runtime.KeepAlive(path)

	var _gints []int // out

	{
		src := unsafe.Slice((*C.int)(_cret), _arg1)
		_gints = make([]int, _arg1)
		for i := 0; i < int(_arg1); i++ {
			_gints[i] = int(src[i])
		}
	}

	return _gints
}

// IsAncestor returns TRUE if descendant is a descendant of path.
//
// The function takes the following parameters:
//
//   - descendant: another TreePath-struct.
//
// The function returns the following values:
//
//   - ok: TRUE if descendant is contained inside path.
func (path *TreePath) IsAncestor(descendant *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(descendant)))

	_cret = C.gtk_tree_path_is_ancestor(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(descendant)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsDescendant returns TRUE if path is a descendant of ancestor.
//
// The function takes the following parameters:
//
//   - ancestor: another TreePath-struct.
//
// The function returns the following values:
//
//   - ok: TRUE if ancestor contains path somewhere below it.
func (path *TreePath) IsDescendant(ancestor *TreePath) bool {
	var _arg0 *C.GtkTreePath // out
	var _arg1 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(ancestor)))

	_cret = C.gtk_tree_path_is_descendant(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(ancestor)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Next moves the path to point to the next node at the current depth.
func (path *TreePath) Next() {
	var _arg0 *C.GtkTreePath // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_path_next(_arg0)
	runtime.KeepAlive(path)
}

// PrependIndex prepends a new index to a path.
//
// As a result, the depth of the path is increased.
//
// The function takes the following parameters:
//
//   - index_: index.
func (path *TreePath) PrependIndex(index_ int) {
	var _arg0 *C.GtkTreePath // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))
	_arg1 = C.int(index_)

	C.gtk_tree_path_prepend_index(_arg0, _arg1)
	runtime.KeepAlive(path)
	runtime.KeepAlive(index_)
}

// Prev moves the path to point to the previous node at the current depth,
// if it exists.
//
// The function returns the following values:
//
//   - ok: TRUE if path has a previous node, and the move was made.
func (path *TreePath) Prev() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_prev(_arg0)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String generates a string representation of the path.
//
// This string is a “:” separated list of numbers. For example, “4:10:0:3” would
// be an acceptable return value for this string. If the path has depth 0,
// NULL is returned.
//
// The function returns the following values:
//
//   - utf8 (optional): newly-allocated string. Must be freed with g_free().
func (path *TreePath) String() string {
	var _arg0 *C.GtkTreePath // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_to_string(_arg0)
	runtime.KeepAlive(path)

	var _utf8 string // out

	if _cret != nil {
		_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
		defer C.free(unsafe.Pointer(_cret))
	}

	return _utf8
}

// Up moves the path to point to its parent node, if it has a parent.
//
// The function returns the following values:
//
//   - ok: TRUE if path has a parent, and the move was made.
func (path *TreePath) Up() bool {
	var _arg0 *C.GtkTreePath // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_path_up(_arg0)
	runtime.KeepAlive(path)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeRowReference tracks model changes so that it always refers to the
// same row (a TreePath refers to a position, not a fixed row). Create a new
// GtkTreeRowReference with gtk_tree_row_reference_new().
//
// An instance of this type is always passed by reference.
type TreeRowReference struct {
	*treeRowReference
}

// treeRowReference is the struct that's finalized.
type treeRowReference struct {
	native *C.GtkTreeRowReference
}

func marshalTreeRowReference(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &TreeRowReference{&treeRowReference{(*C.GtkTreeRowReference)(b)}}, nil
}

// NewTreeRowReference constructs a struct TreeRowReference.
func NewTreeRowReference(model TreeModeller, path *TreePath) *TreeRowReference {
	var _arg1 *C.GtkTreeModel        // out
	var _arg2 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_row_reference_new(_arg1, _arg2)
	runtime.KeepAlive(model)
	runtime.KeepAlive(path)

	var _treeRowReference *TreeRowReference // out

	if _cret != nil {
		_treeRowReference = (*TreeRowReference)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treeRowReference)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_row_reference_free((*C.GtkTreeRowReference)(intern.C))
			},
		)
	}

	return _treeRowReference
}

// NewTreeRowReferenceProxy constructs a struct TreeRowReference.
func NewTreeRowReferenceProxy(proxy *coreglib.Object, model TreeModeller, path *TreePath) *TreeRowReference {
	var _arg1 *C.GObject             // out
	var _arg2 *C.GtkTreeModel        // out
	var _arg3 *C.GtkTreePath         // out
	var _cret *C.GtkTreeRowReference // in

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(coreglib.InternObject(model).Native()))
	_arg3 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	_cret = C.gtk_tree_row_reference_new_proxy(_arg1, _arg2, _arg3)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(model)
	runtime.KeepAlive(path)

	var _treeRowReference *TreeRowReference // out

	if _cret != nil {
		_treeRowReference = (*TreeRowReference)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treeRowReference)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_row_reference_free((*C.GtkTreeRowReference)(intern.C))
			},
		)
	}

	return _treeRowReference
}

// Copy copies a TreeRowReference.
//
// The function returns the following values:
//
//   - treeRowReference: copy of reference.
func (reference *TreeRowReference) Copy() *TreeRowReference {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeRowReference // in

	_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))

	_cret = C.gtk_tree_row_reference_copy(_arg0)
	runtime.KeepAlive(reference)

	var _treeRowReference *TreeRowReference // out

	_treeRowReference = (*TreeRowReference)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_treeRowReference)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.gtk_tree_row_reference_free((*C.GtkTreeRowReference)(intern.C))
		},
	)

	return _treeRowReference
}

// Model returns the model that the row reference is monitoring.
//
// The function returns the following values:
//
//   - treeModel: model.
func (reference *TreeRowReference) Model() *TreeModel {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreeModel        // in

	_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))

	_cret = C.gtk_tree_row_reference_get_model(_arg0)
	runtime.KeepAlive(reference)

	var _treeModel *TreeModel // out

	_treeModel = wrapTreeModel(coreglib.Take(unsafe.Pointer(_cret)))

	return _treeModel
}

// Path returns a path that the row reference currently points to, or NULL if
// the path pointed to is no longer valid.
//
// The function returns the following values:
//
//   - treePath (optional): current path, or NULL.
func (reference *TreeRowReference) Path() *TreePath {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret *C.GtkTreePath         // in

	_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))

	_cret = C.gtk_tree_row_reference_get_path(_arg0)
	runtime.KeepAlive(reference)

	var _treePath *TreePath // out

	if _cret != nil {
		_treePath = (*TreePath)(gextras.NewStructNative(unsafe.Pointer(_cret)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_treePath)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.gtk_tree_path_free((*C.GtkTreePath)(intern.C))
			},
		)
	}

	return _treePath
}

// Valid returns TRUE if the reference is non-NULL and refers to a current valid
// path.
//
// The function returns the following values:
//
//   - ok: TRUE if reference points to a valid path.
func (reference *TreeRowReference) Valid() bool {
	var _arg0 *C.GtkTreeRowReference // out
	var _cret C.gboolean             // in

	if reference != nil {
		_arg0 = (*C.GtkTreeRowReference)(gextras.StructNative(unsafe.Pointer(reference)))
	}

	_cret = C.gtk_tree_row_reference_valid(_arg0)
	runtime.KeepAlive(reference)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TreeRowReferenceDeleted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-deleted signal.
//
// The function takes the following parameters:
//
//   - proxy: #GObject.
//   - path position that was deleted.
func TreeRowReferenceDeleted(proxy *coreglib.Object, path *TreePath) {
	var _arg1 *C.GObject     // out
	var _arg2 *C.GtkTreePath // out

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_row_reference_deleted(_arg1, _arg2)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(path)
}

// TreeRowReferenceInserted lets a set of row reference created by
// gtk_tree_row_reference_new_proxy() know that the model emitted the
// TreeModel::row-inserted signal.
//
// The function takes the following parameters:
//
//   - proxy: #GObject.
//   - path: row position that was inserted.
func TreeRowReferenceInserted(proxy *coreglib.Object, path *TreePath) {
	var _arg1 *C.GObject     // out
	var _arg2 *C.GtkTreePath // out

	_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
	_arg2 = (*C.GtkTreePath)(gextras.StructNative(unsafe.Pointer(path)))

	C.gtk_tree_row_reference_inserted(_arg1, _arg2)
	runtime.KeepAlive(proxy)
	runtime.KeepAlive(path)
}

// TreeSortableIface: instance of this type is always passed by reference.
type TreeSortableIface struct {
	*treeSortableIface
}

// treeSortableIface is the struct that's finalized.
type treeSortableIface struct {
	native *C.GtkTreeSortableIface
}

// TreeStoreClass: instance of this type is always passed by reference.
type TreeStoreClass struct {
	*treeStoreClass
}

// treeStoreClass is the struct that's finalized.
type treeStoreClass struct {
	native *C.GtkTreeStoreClass
}

// TreeViewClass: instance of this type is always passed by reference.
type TreeViewClass struct {
	*treeViewClass
}

// treeViewClass is the struct that's finalized.
type treeViewClass struct {
	native *C.GtkTreeViewClass
}

func (t *TreeViewClass) ParentClass() *WidgetClass {
	valptr := &t.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// VideoClass: instance of this type is always passed by reference.
type VideoClass struct {
	*videoClass
}

// videoClass is the struct that's finalized.
type videoClass struct {
	native *C.GtkVideoClass
}

func (v *VideoClass) ParentClass() *WidgetClass {
	valptr := &v.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// WidgetClass: instance of this type is always passed by reference.
type WidgetClass struct {
	*widgetClass
}

// widgetClass is the struct that's finalized.
type widgetClass struct {
	native *C.GtkWidgetClass
}

// AddShortcut installs a shortcut in widget_class.
//
// Every instance created for widget_class or its subclasses will inherit this
// shortcut and trigger it.
//
// Shortcuts added this way will be triggered in the GTK_PHASE_BUBBLE phase,
// which means they may also trigger if child widgets have focus.
//
// This function must only be used in class initialization functions otherwise
// it is not guaranteed that the shortcut will be installed.
//
// The function takes the following parameters:
//
//   - shortcut to add.
func (widgetClass *WidgetClass) AddShortcut(shortcut *Shortcut) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.GtkShortcut    // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.GtkShortcut)(unsafe.Pointer(coreglib.InternObject(shortcut).Native()))

	C.gtk_widget_class_add_shortcut(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(shortcut)
}

// BindTemplateChildFull: automatically assign an object declared in the class
// template XML to be set to a location on a freshly built instance’s private
// data, or alternatively accessible via gtk.Widget.GetTemplateChild().
//
// The struct can point either into the public instance, then you should use
// G_STRUCT_OFFSET(WidgetType, member) for struct_offset, or in the private
// struct, then you should use G_PRIVATE_OFFSET(WidgetType, member).
//
// An explicit strong reference will be held automatically for the duration
// of your instance’s life cycle, it will be released automatically when
// GObjectClass.dispose() runs on your instance and if a struct_offset that
// is != 0 is specified, then the automatic location in your instance public
// or private data will be set to NULL. You can however access an automated
// child pointer the first time your classes GObjectClass.dispose() runs,
// or alternatively in gtk.Widget::destroy.
//
// If internal_child is specified, gtk.Buildable.GetInternalChild() will be
// automatically implemented by the GtkWidget class so there is no need to
// implement it manually.
//
// The wrapper macros gtk.WidgetClassBindTemplateChild(),
// gtk.WidgetClassBindTemplateChildInternal(),
// gtk.WidgetClassBindTemplateChildPrivate() and
// gtk.WidgetClassBindTemplateChildInternalPrivate() might be more convenient to
// use.
//
// Note that this must be called from a composite widget classes class
// initializer after calling gtk.WidgetClass.SetTemplate().
//
// The function takes the following parameters:
//
//   - name: “id” of the child defined in the template XML.
//   - internalChild: whether the child should be accessible as an
//     “internal-child” when this class is used in GtkBuilder XML.
//   - structOffset: structure offset into the composite widget’s instance
//     public or private structure where the automated child pointer should be
//     set, or 0 to not assign the pointer.
func (widgetClass *WidgetClass) BindTemplateChildFull(name string, internalChild bool, structOffset int) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out
	var _arg2 C.gboolean        // out
	var _arg3 C.gssize          // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if internalChild {
		_arg2 = C.TRUE
	}
	_arg3 = C.gssize(structOffset)

	C.gtk_widget_class_bind_template_child_full(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(name)
	runtime.KeepAlive(internalChild)
	runtime.KeepAlive(structOffset)
}

// AccessibleRole retrieves the accessible role used by the given GtkWidget
// class.
//
// Different accessible roles have different states, and are rendered
// differently by assistive technologies.
//
// See also: gtk.Accessible.GetAccessibleRole().
//
// The function returns the following values:
//
//   - accessibleRole: accessible role for the widget class.
func (widgetClass *WidgetClass) AccessibleRole() AccessibleRole {
	var _arg0 *C.GtkWidgetClass   // out
	var _cret C.GtkAccessibleRole // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_accessible_role(_arg0)
	runtime.KeepAlive(widgetClass)

	var _accessibleRole AccessibleRole // out

	_accessibleRole = AccessibleRole(_cret)

	return _accessibleRole
}

// ActivateSignal retrieves the signal id for the activation signal set using
// gtk_widget_class_set_activate_signal().
//
// The function returns the following values:
//
//   - guint: signal id, or 0 if the widget class does not specify an activation
//     signal.
func (widgetClass *WidgetClass) ActivateSignal() uint {
	var _arg0 *C.GtkWidgetClass // out
	var _cret C.guint           // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_activate_signal(_arg0)
	runtime.KeepAlive(widgetClass)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// CSSName gets the name used by this class for matching in CSS code.
//
// See gtk_widget_class_set_css_name() for details.
//
// The function returns the following values:
//
//   - utf8: CSS name of the given class.
func (widgetClass *WidgetClass) CSSName() string {
	var _arg0 *C.GtkWidgetClass // out
	var _cret *C.char           // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_css_name(_arg0)
	runtime.KeepAlive(widgetClass)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// LayoutManagerType retrieves the type of the gtk.LayoutManager used by the
// GtkWidget class.
//
// See also: gtk_widget_class_set_layout_manager_type().
//
// The function returns the following values:
//
//   - gType: type of a GtkLayoutManager subclass, or G_TYPE_INVALID.
func (widgetClass *WidgetClass) LayoutManagerType() coreglib.Type {
	var _arg0 *C.GtkWidgetClass // out
	var _cret C.GType           // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))

	_cret = C.gtk_widget_class_get_layout_manager_type(_arg0)
	runtime.KeepAlive(widgetClass)

	var _gType coreglib.Type // out

	_gType = coreglib.Type(_cret)

	return _gType
}

// InstallPropertyAction installs an action called action_name on widget_class
// and binds its state to the value of the property_name property.
//
// This function will perform a few santity checks on the property selected via
// property_name. Namely, the property must exist, must be readable, writable
// and must not be construct-only. There are also restrictions on the type of
// the given property, it must be boolean, int, unsigned int, double or string.
// If any of these conditions are not met, a critical warning will be printed
// and no action will be added.
//
// The state type of the action matches the property type.
//
// If the property is boolean, the action will have no parameter and toggle the
// property value. Otherwise, the action will have a parameter of the same type
// as the property.
//
// The function takes the following parameters:
//
//   - actionName: name of the action.
//   - propertyName: name of the property in instances of widget_class or any
//     parent class.
func (widgetClass *WidgetClass) InstallPropertyAction(actionName string, propertyName string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out
	var _arg2 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(actionName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(propertyName)))
	defer C.free(unsafe.Pointer(_arg2))

	C.gtk_widget_class_install_property_action(_arg0, _arg1, _arg2)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(actionName)
	runtime.KeepAlive(propertyName)
}

// QueryAction queries the actions that have been installed for a widget class
// using gtk.WidgetClass.InstallAction() during class initialization.
//
// Note that this function will also return actions defined by parent classes.
// You can identify those by looking at owner.
//
// The function takes the following parameters:
//
//   - index_: position of the action to query.
//
// The function returns the following values:
//
//   - owner: return location for the type where the action was defined.
//   - actionName: return location for the action name.
//   - parameterType (optional): return location for the parameter type.
//   - propertyName (optional): return location for the property name.
//   - ok: TRUE if the action was found, FALSE if index_ is out of range.
func (widgetClass *WidgetClass) QueryAction(index_ uint) (owner coreglib.Type, actionName string, parameterType *glib.VariantType, propertyName string, ok bool) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.guint           // out
	var _arg2 C.GType           // in
	var _arg3 *C.char           // in
	var _arg4 *C.GVariantType   // in
	var _arg5 *C.char           // in
	var _cret C.gboolean        // in

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.guint(index_)

	_cret = C.gtk_widget_class_query_action(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(index_)

	var _owner coreglib.Type             // out
	var _actionName string               // out
	var _parameterType *glib.VariantType // out
	var _propertyName string             // out
	var _ok bool                         // out

	_owner = coreglib.Type(_arg2)
	_actionName = C.GoString((*C.gchar)(unsafe.Pointer(_arg3)))
	defer C.free(unsafe.Pointer(_arg3))
	if _arg4 != nil {
		_parameterType = (*glib.VariantType)(gextras.NewStructNative(unsafe.Pointer(_arg4)))
		runtime.SetFinalizer(
			gextras.StructIntern(unsafe.Pointer(_parameterType)),
			func(intern *struct{ C unsafe.Pointer }) {
				C.g_variant_type_free((*C.GVariantType)(intern.C))
			},
		)
	}
	if _arg5 != nil {
		_propertyName = C.GoString((*C.gchar)(unsafe.Pointer(_arg5)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if _cret != 0 {
		_ok = true
	}

	return _owner, _actionName, _parameterType, _propertyName, _ok
}

// SetAccessibleRole sets the accessible role used by the given GtkWidget class.
//
// Different accessible roles have different states, and are rendered
// differently by assistive technologies.
//
// The function takes the following parameters:
//
//   - accessibleRole: GtkAccessibleRole used by the widget_class.
func (widgetClass *WidgetClass) SetAccessibleRole(accessibleRole AccessibleRole) {
	var _arg0 *C.GtkWidgetClass   // out
	var _arg1 C.GtkAccessibleRole // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.GtkAccessibleRole(accessibleRole)

	C.gtk_widget_class_set_accessible_role(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(accessibleRole)
}

// SetActivateSignal sets the GtkWidgetClass.activate_signal field
// with the given signal_id; the signal will be emitted when calling
// gtk_widget_activate().
//
// The signal_id must have been registered with g_signal_new() or
// g_signal_newv() before calling this function.
//
// The function takes the following parameters:
//
//   - signalId: id for the activate signal.
func (widgetClass *WidgetClass) SetActivateSignal(signalId uint) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.guint           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.guint(signalId)

	C.gtk_widget_class_set_activate_signal(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(signalId)
}

// SetActivateSignalFromName sets the GtkWidgetClass.activate_signal field with
// the signal id for the given signal_name; the signal will be emitted when
// calling gtk_widget_activate().
//
// The signal_name of widget_type must have been registered with g_signal_new()
// or g_signal_newv() before calling this function.
//
// The function takes the following parameters:
//
//   - signalName: name of the activate signal of widget_type.
func (widgetClass *WidgetClass) SetActivateSignalFromName(signalName string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(signalName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_activate_signal_from_name(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(signalName)
}

// SetCSSName sets the name to be used for CSS matching of widgets.
//
// If this function is not called for a given class, the name set on the parent
// class is used. By default, GtkWidget uses the name "widget".
//
// The function takes the following parameters:
//
//   - name to use.
func (widgetClass *WidgetClass) SetCSSName(name string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_css_name(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(name)
}

// SetLayoutManagerType sets the type to be used for creating layout managers
// for widgets of widget_class.
//
// The given type must be a subtype of gtk.LayoutManager.
//
// This function should only be called from class init functions of widgets.
//
// The function takes the following parameters:
//
//   - typ: object type that implements the GtkLayoutManager for widget_class.
func (widgetClass *WidgetClass) SetLayoutManagerType(typ coreglib.Type) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 C.GType           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = C.GType(typ)

	C.gtk_widget_class_set_layout_manager_type(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(typ)
}

// SetTemplate: this should be called at class initialization time to specify
// the GtkBuilder XML to be used to extend a widget.
//
// For convenience, gtk.WidgetClass.SetTemplateFromResource() is also provided.
//
// Note that any class that installs templates must call
// gtk.Widget.InitTemplate() in the widget’s instance initializer.
//
// The function takes the following parameters:
//
//   - templateBytes holding the Builder XML.
func (widgetClass *WidgetClass) SetTemplate(templateBytes *glib.Bytes) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.GBytes         // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(templateBytes)))

	C.gtk_widget_class_set_template(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(templateBytes)
}

// SetTemplateFromResource: convenience function that calls
// gtk.WidgetClass.SetTemplate() with the contents of a GResource.
//
// Note that any class that installs templates must call
// gtk.Widget.InitTemplate() in the widget’s instance initializer.
//
// The function takes the following parameters:
//
//   - resourceName: name of the resource to load the template from.
func (widgetClass *WidgetClass) SetTemplateFromResource(resourceName string) {
	var _arg0 *C.GtkWidgetClass // out
	var _arg1 *C.char           // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(resourceName)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_widget_class_set_template_from_resource(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(resourceName)
}

// SetTemplateScope: for use in language bindings, this will override the
// default GtkBuilderScope to be used when parsing GtkBuilder XML from this
// class’s template data.
//
// Note that this must be called from a composite widget classes class
// initializer after calling gtk_widget_class_set_template().
//
// The function takes the following parameters:
//
//   - scope: GtkBuilderScope to use when loading the class template.
func (widgetClass *WidgetClass) SetTemplateScope(scope BuilderScoper) {
	var _arg0 *C.GtkWidgetClass  // out
	var _arg1 *C.GtkBuilderScope // out

	_arg0 = (*C.GtkWidgetClass)(gextras.StructNative(unsafe.Pointer(widgetClass)))
	_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(coreglib.InternObject(scope).Native()))

	C.gtk_widget_class_set_template_scope(_arg0, _arg1)
	runtime.KeepAlive(widgetClass)
	runtime.KeepAlive(scope)
}

// WidgetPaintableClass: instance of this type is always passed by reference.
type WidgetPaintableClass struct {
	*widgetPaintableClass
}

// widgetPaintableClass is the struct that's finalized.
type widgetPaintableClass struct {
	native *C.GtkWidgetPaintableClass
}

// WindowClass: instance of this type is always passed by reference.
type WindowClass struct {
	*windowClass
}

// windowClass is the struct that's finalized.
type windowClass struct {
	native *C.GtkWindowClass
}

// ParentClass: parent class.
func (w *WindowClass) ParentClass() *WidgetClass {
	valptr := &w.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// WindowControlsClass: instance of this type is always passed by reference.
type WindowControlsClass struct {
	*windowControlsClass
}

// windowControlsClass is the struct that's finalized.
type windowControlsClass struct {
	native *C.GtkWindowControlsClass
}

func (w *WindowControlsClass) ParentClass() *WidgetClass {
	valptr := &w.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// WindowGroupClass: instance of this type is always passed by reference.
type WindowGroupClass struct {
	*windowGroupClass
}

// windowGroupClass is the struct that's finalized.
type windowGroupClass struct {
	native *C.GtkWindowGroupClass
}

// WindowHandleClass: instance of this type is always passed by reference.
type WindowHandleClass struct {
	*windowHandleClass
}

// windowHandleClass is the struct that's finalized.
type windowHandleClass struct {
	native *C.GtkWindowHandleClass
}

func (w *WindowHandleClass) ParentClass() *WidgetClass {
	valptr := &w.native.parent_class
	var _v *WidgetClass // out
	_v = (*WidgetClass)(gextras.NewStructNative(unsafe.Pointer(valptr)))
	return _v
}

// NewDialogWithFlags is a slightly more advanced version of NewDialog,
// allowing the user to construct a new dialog with the given
// constructor-only dialog flags.
//
// It is a wrapper around Gtk.Dialog.new_with_buttons in C.
func NewDialogWithFlags(title string, parent *Window, flags DialogFlags) *Dialog {
	ctitle := C.CString(title)
	defer C.free(unsafe.Pointer(ctitle))

	w := C._gotk4_gtk4_dialog_new2(
		(*C.gchar)(unsafe.Pointer(ctitle)),
		(*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native())),
		(C.GtkDialogFlags)(flags),
	)
	runtime.KeepAlive(parent)

	return wrapDialog(coreglib.Take(unsafe.Pointer(w)))
}

// NewMessageDialog creates a new message dialog. This is a simple
// dialog with some text taht the user may want to see. When the user
// clicks a button, a "response" signal is emitted with response IDs
// from ResponseType.
func NewMessageDialog(parent *Window, flags DialogFlags, typ MessageType, buttons ButtonsType) *MessageDialog {
	w := C._gotk4_gtk_message_dialog_new2(
		(*C.GtkWindow)(unsafe.Pointer(coreglib.InternObject(parent).Native())),
		(C.GtkDialogFlags)(flags),
		(C.GtkMessageType)(typ),
		(C.GtkButtonsType)(buttons),
	)
	runtime.KeepAlive(parent)

	return wrapMessageDialog(coreglib.Take(unsafe.Pointer(w)))
}

func init() {
	runtime.LockOSThread()
}

// InvalidListPosition is the value used to refer to a guaranteed
// invalid position in a [gio.ListModel].
//
// This value may be returned from some functions, others may accept it
// as input. Its interpretation may differ for different functions.
//
// Refer to each function’s documentation for if this value is allowed
// and what it does.
const InvalidListPosition = math.MaxUint32
