// Code generated by girgen. DO NOT EDIT.

package gtk

import (
"runtime"
"unsafe"

"github.com/diamondburned/gotk4/core/gerror"
"github.com/diamondburned/gotk4/core/gextras"
"github.com/diamondburned/gotk4/pkg/cairo"
"github.com/diamondburned/gotk4/pkg/gdk/v4"
"github.com/diamondburned/gotk4/pkg/gdkpixbuf/v2"
"github.com/diamondburned/gotk4/pkg/gio/v2"
"github.com/diamondburned/gotk4/pkg/glib/v2"
"github.com/diamondburned/gotk4/pkg/graphene"
"github.com/diamondburned/gotk4/pkg/gsk/v4"
"github.com/diamondburned/gotk4/pkg/pango"
externglib "github.com/gotk3/gotk3/glib"
)


// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
  externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
      {T: externglib.Type(C.gtk_accessible_autocomplete_get_type()), F: marshalAccessibleAutocomplete},
      {T: externglib.Type(C.gtk_accessible_invalid_state_get_type()), F: marshalAccessibleInvalidState},
      {T: externglib.Type(C.gtk_accessible_property_get_type()), F: marshalAccessibleProperty},
      {T: externglib.Type(C.gtk_accessible_relation_get_type()), F: marshalAccessibleRelation},
      {T: externglib.Type(C.gtk_accessible_role_get_type()), F: marshalAccessibleRole},
      {T: externglib.Type(C.gtk_accessible_sort_get_type()), F: marshalAccessibleSort},
      {T: externglib.Type(C.gtk_accessible_state_get_type()), F: marshalAccessibleState},
      {T: externglib.Type(C.gtk_accessible_tristate_get_type()), F: marshalAccessibleTristate},
      {T: externglib.Type(C.gtk_align_get_type()), F: marshalAlign},
      {T: externglib.Type(C.gtk_arrow_type_get_type()), F: marshalArrowType},
      {T: externglib.Type(C.gtk_assistant_page_type_get_type()), F: marshalAssistantPageType},
      {T: externglib.Type(C.gtk_baseline_position_get_type()), F: marshalBaselinePosition},
      {T: externglib.Type(C.gtk_border_style_get_type()), F: marshalBorderStyle},
      {T: externglib.Type(C.gtk_builder_error_get_type()), F: marshalBuilderError},
      {T: externglib.Type(C.gtk_buttons_type_get_type()), F: marshalButtonsType},
      {T: externglib.Type(C.gtk_cell_renderer_accel_mode_get_type()), F: marshalCellRendererAccelMode},
      {T: externglib.Type(C.gtk_cell_renderer_mode_get_type()), F: marshalCellRendererMode},
      {T: externglib.Type(C.gtk_constraint_attribute_get_type()), F: marshalConstraintAttribute},
      {T: externglib.Type(C.gtk_constraint_relation_get_type()), F: marshalConstraintRelation},
      {T: externglib.Type(C.gtk_constraint_strength_get_type()), F: marshalConstraintStrength},
      {T: externglib.Type(C.gtk_constraint_vfl_parser_error_get_type()), F: marshalConstraintVflParserError},
      {T: externglib.Type(C.gtk_corner_type_get_type()), F: marshalCornerType},
      {T: externglib.Type(C.gtk_delete_type_get_type()), F: marshalDeleteType},
      {T: externglib.Type(C.gtk_direction_type_get_type()), F: marshalDirectionType},
      {T: externglib.Type(C.gtk_editable_properties_get_type()), F: marshalEditableProperties},
      {T: externglib.Type(C.gtk_entry_icon_position_get_type()), F: marshalEntryIconPosition},
      {T: externglib.Type(C.gtk_event_sequence_state_get_type()), F: marshalEventSequenceState},
      {T: externglib.Type(C.gtk_file_chooser_action_get_type()), F: marshalFileChooserAction},
      {T: externglib.Type(C.gtk_file_chooser_error_get_type()), F: marshalFileChooserError},
      {T: externglib.Type(C.gtk_filter_change_get_type()), F: marshalFilterChange},
      {T: externglib.Type(C.gtk_filter_match_get_type()), F: marshalFilterMatch},
      {T: externglib.Type(C.gtk_icon_size_get_type()), F: marshalIconSize},
      {T: externglib.Type(C.gtk_icon_theme_error_get_type()), F: marshalIconThemeError},
      {T: externglib.Type(C.gtk_icon_view_drop_position_get_type()), F: marshalIconViewDropPosition},
      {T: externglib.Type(C.gtk_image_type_get_type()), F: marshalImageType},
      {T: externglib.Type(C.gtk_input_purpose_get_type()), F: marshalInputPurpose},
      {T: externglib.Type(C.gtk_justification_get_type()), F: marshalJustification},
      {T: externglib.Type(C.gtk_level_bar_mode_get_type()), F: marshalLevelBarMode},
      {T: externglib.Type(C.gtk_license_get_type()), F: marshalLicense},
      {T: externglib.Type(C.gtk_message_type_get_type()), F: marshalMessageType},
      {T: externglib.Type(C.gtk_movement_step_get_type()), F: marshalMovementStep},
      {T: externglib.Type(C.gtk_notebook_tab_get_type()), F: marshalNotebookTab},
      {T: externglib.Type(C.gtk_number_up_layout_get_type()), F: marshalNumberUpLayout},
      {T: externglib.Type(C.gtk_ordering_get_type()), F: marshalOrdering},
      {T: externglib.Type(C.gtk_orientation_get_type()), F: marshalOrientation},
      {T: externglib.Type(C.gtk_overflow_get_type()), F: marshalOverflow},
      {T: externglib.Type(C.gtk_pack_type_get_type()), F: marshalPackType},
      {T: externglib.Type(C.gtk_pad_action_type_get_type()), F: marshalPadActionType},
      {T: externglib.Type(C.gtk_page_orientation_get_type()), F: marshalPageOrientation},
      {T: externglib.Type(C.gtk_page_set_get_type()), F: marshalPageSet},
      {T: externglib.Type(C.gtk_pan_direction_get_type()), F: marshalPanDirection},
      {T: externglib.Type(C.gtk_policy_type_get_type()), F: marshalPolicyType},
      {T: externglib.Type(C.gtk_position_type_get_type()), F: marshalPositionType},
      {T: externglib.Type(C.gtk_print_duplex_get_type()), F: marshalPrintDuplex},
      {T: externglib.Type(C.gtk_print_error_get_type()), F: marshalPrintError},
      {T: externglib.Type(C.gtk_print_operation_action_get_type()), F: marshalPrintOperationAction},
      {T: externglib.Type(C.gtk_print_operation_result_get_type()), F: marshalPrintOperationResult},
      {T: externglib.Type(C.gtk_print_pages_get_type()), F: marshalPrintPages},
      {T: externglib.Type(C.gtk_print_quality_get_type()), F: marshalPrintQuality},
      {T: externglib.Type(C.gtk_print_status_get_type()), F: marshalPrintStatus},
      {T: externglib.Type(C.gtk_propagation_limit_get_type()), F: marshalPropagationLimit},
      {T: externglib.Type(C.gtk_propagation_phase_get_type()), F: marshalPropagationPhase},
      {T: externglib.Type(C.gtk_recent_manager_error_get_type()), F: marshalRecentManagerError},
      {T: externglib.Type(C.gtk_response_type_get_type()), F: marshalResponseType},
      {T: externglib.Type(C.gtk_revealer_transition_type_get_type()), F: marshalRevealerTransitionType},
      {T: externglib.Type(C.gtk_scroll_step_get_type()), F: marshalScrollStep},
      {T: externglib.Type(C.gtk_scroll_type_get_type()), F: marshalScrollType},
      {T: externglib.Type(C.gtk_scrollable_policy_get_type()), F: marshalScrollablePolicy},
      {T: externglib.Type(C.gtk_selection_mode_get_type()), F: marshalSelectionMode},
      {T: externglib.Type(C.gtk_sensitivity_type_get_type()), F: marshalSensitivityType},
      {T: externglib.Type(C.gtk_shortcut_scope_get_type()), F: marshalShortcutScope},
      {T: externglib.Type(C.gtk_shortcut_type_get_type()), F: marshalShortcutType},
      {T: externglib.Type(C.gtk_size_group_mode_get_type()), F: marshalSizeGroupMode},
      {T: externglib.Type(C.gtk_size_request_mode_get_type()), F: marshalSizeRequestMode},
      {T: externglib.Type(C.gtk_sort_type_get_type()), F: marshalSortType},
      {T: externglib.Type(C.gtk_sorter_change_get_type()), F: marshalSorterChange},
      {T: externglib.Type(C.gtk_sorter_order_get_type()), F: marshalSorterOrder},
      {T: externglib.Type(C.gtk_spin_button_update_policy_get_type()), F: marshalSpinButtonUpdatePolicy},
      {T: externglib.Type(C.gtk_spin_type_get_type()), F: marshalSpinType},
      {T: externglib.Type(C.gtk_stack_transition_type_get_type()), F: marshalStackTransitionType},
      {T: externglib.Type(C.gtk_string_filter_match_mode_get_type()), F: marshalStringFilterMatchMode},
      {T: externglib.Type(C.gtk_system_setting_get_type()), F: marshalSystemSetting},
      {T: externglib.Type(C.gtk_text_direction_get_type()), F: marshalTextDirection},
      {T: externglib.Type(C.gtk_text_extend_selection_get_type()), F: marshalTextExtendSelection},
      {T: externglib.Type(C.gtk_text_view_layer_get_type()), F: marshalTextViewLayer},
      {T: externglib.Type(C.gtk_text_window_type_get_type()), F: marshalTextWindowType},
      {T: externglib.Type(C.gtk_tree_view_column_sizing_get_type()), F: marshalTreeViewColumnSizing},
      {T: externglib.Type(C.gtk_tree_view_drop_position_get_type()), F: marshalTreeViewDropPosition},
      {T: externglib.Type(C.gtk_tree_view_grid_lines_get_type()), F: marshalTreeViewGridLines},
      {T: externglib.Type(C.gtk_unit_get_type()), F: marshalUnit},
      {T: externglib.Type(C.gtk_wrap_mode_get_type()), F: marshalWrapMode},
      {T: externglib.Type(C.gtk_application_inhibit_flags_get_type()), F: marshalApplicationInhibitFlags},
      {T: externglib.Type(C.gtk_builder_closure_flags_get_type()), F: marshalBuilderClosureFlags},
      {T: externglib.Type(C.gtk_cell_renderer_state_get_type()), F: marshalCellRendererState},
      {T: externglib.Type(C.gtk_debug_flags_get_type()), F: marshalDebugFlags},
      {T: externglib.Type(C.gtk_dialog_flags_get_type()), F: marshalDialogFlags},
      {T: externglib.Type(C.gtk_event_controller_scroll_flags_get_type()), F: marshalEventControllerScrollFlags},
      {T: externglib.Type(C.gtk_font_chooser_level_get_type()), F: marshalFontChooserLevel},
      {T: externglib.Type(C.gtk_icon_lookup_flags_get_type()), F: marshalIconLookupFlags},
      {T: externglib.Type(C.gtk_input_hints_get_type()), F: marshalInputHints},
      {T: externglib.Type(C.gtk_pick_flags_get_type()), F: marshalPickFlags},
      {T: externglib.Type(C.gtk_popover_menu_flags_get_type()), F: marshalPopoverMenuFlags},
      {T: externglib.Type(C.gtk_print_capabilities_get_type()), F: marshalPrintCapabilities},
      {T: externglib.Type(C.gtk_shortcut_action_flags_get_type()), F: marshalShortcutActionFlags},
      {T: externglib.Type(C.gtk_state_flags_get_type()), F: marshalStateFlags},
      {T: externglib.Type(C.gtk_style_context_print_flags_get_type()), F: marshalStyleContextPrintFlags},
      {T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
      {T: externglib.Type(C.gtk_tree_model_flags_get_type()), F: marshalTreeModelFlags},
      {T: externglib.Type(C.gtk_accessible_get_type()), F: marshalAccessible},
      {T: externglib.Type(C.gtk_actionable_get_type()), F: marshalActionable},
      {T: externglib.Type(C.gtk_app_chooser_get_type()), F: marshalAppChooser},
      {T: externglib.Type(C.gtk_buildable_get_type()), F: marshalBuildable},
      {T: externglib.Type(C.gtk_builder_scope_get_type()), F: marshalBuilderScope},
      {T: externglib.Type(C.gtk_cell_editable_get_type()), F: marshalCellEditable},
      {T: externglib.Type(C.gtk_cell_layout_get_type()), F: marshalCellLayout},
      {T: externglib.Type(C.gtk_color_chooser_get_type()), F: marshalColorChooser},
      {T: externglib.Type(C.gtk_constraint_target_get_type()), F: marshalConstraintTarget},
      {T: externglib.Type(C.gtk_editable_get_type()), F: marshalEditable},
      {T: externglib.Type(C.gtk_file_chooser_get_type()), F: marshalFileChooser},
      {T: externglib.Type(C.gtk_font_chooser_get_type()), F: marshalFontChooser},
      {T: externglib.Type(C.gtk_native_get_type()), F: marshalNative},
      {T: externglib.Type(C.gtk_orientable_get_type()), F: marshalOrientable},
      {T: externglib.Type(C.gtk_print_operation_preview_get_type()), F: marshalPrintOperationPreview},
      {T: externglib.Type(C.gtk_root_get_type()), F: marshalRoot},
      {T: externglib.Type(C.gtk_scrollable_get_type()), F: marshalScrollable},
      {T: externglib.Type(C.gtk_selection_model_get_type()), F: marshalSelectionModel},
      {T: externglib.Type(C.gtk_shortcut_manager_get_type()), F: marshalShortcutManager},
      {T: externglib.Type(C.gtk_style_provider_get_type()), F: marshalStyleProvider},
      {T: externglib.Type(C.gtk_tree_drag_dest_get_type()), F: marshalTreeDragDest},
      {T: externglib.Type(C.gtk_tree_drag_source_get_type()), F: marshalTreeDragSource},
      {T: externglib.Type(C.gtk_tree_model_get_type()), F: marshalTreeModel},
      {T: externglib.Type(C.gtk_tree_sortable_get_type()), F: marshalTreeSortable},
      {T: externglib.Type(C.gtk_at_context_get_type()), F: marshalATContext},
      {T: externglib.Type(C.gtk_about_dialog_get_type()), F: marshalAboutDialog},
      {T: externglib.Type(C.gtk_action_bar_get_type()), F: marshalActionBar},
      {T: externglib.Type(C.gtk_activate_action_get_type()), F: marshalActivateAction},
      {T: externglib.Type(C.gtk_adjustment_get_type()), F: marshalAdjustment},
      {T: externglib.Type(C.gtk_alternative_trigger_get_type()), F: marshalAlternativeTrigger},
      {T: externglib.Type(C.gtk_any_filter_get_type()), F: marshalAnyFilter},
      {T: externglib.Type(C.gtk_app_chooser_button_get_type()), F: marshalAppChooserButton},
      {T: externglib.Type(C.gtk_app_chooser_dialog_get_type()), F: marshalAppChooserDialog},
      {T: externglib.Type(C.gtk_app_chooser_widget_get_type()), F: marshalAppChooserWidget},
      {T: externglib.Type(C.gtk_application_get_type()), F: marshalApplication},
      {T: externglib.Type(C.gtk_application_window_get_type()), F: marshalApplicationWindow},
      {T: externglib.Type(C.gtk_aspect_frame_get_type()), F: marshalAspectFrame},
      {T: externglib.Type(C.gtk_assistant_get_type()), F: marshalAssistant},
      {T: externglib.Type(C.gtk_assistant_page_get_type()), F: marshalAssistantPage},
      {T: externglib.Type(C.gtk_bin_layout_get_type()), F: marshalBinLayout},
      {T: externglib.Type(C.gtk_bookmark_list_get_type()), F: marshalBookmarkList},
      {T: externglib.Type(C.gtk_bool_filter_get_type()), F: marshalBoolFilter},
      {T: externglib.Type(C.gtk_box_get_type()), F: marshalBox},
      {T: externglib.Type(C.gtk_box_layout_get_type()), F: marshalBoxLayout},
      {T: externglib.Type(C.gtk_builder_get_type()), F: marshalBuilder},
      {T: externglib.Type(C.gtk_builder_cscope_get_type()), F: marshalBuilderCScope},
      {T: externglib.Type(C.gtk_builder_list_item_factory_get_type()), F: marshalBuilderListItemFactory},
      {T: externglib.Type(C.gtk_button_get_type()), F: marshalButton},
      {T: externglib.Type(C.gtk_calendar_get_type()), F: marshalCalendar},
      {T: externglib.Type(C.gtk_callback_action_get_type()), F: marshalCallbackAction},
      {T: externglib.Type(C.gtk_cell_area_get_type()), F: marshalCellArea},
      {T: externglib.Type(C.gtk_cell_area_box_get_type()), F: marshalCellAreaBox},
      {T: externglib.Type(C.gtk_cell_area_context_get_type()), F: marshalCellAreaContext},
      {T: externglib.Type(C.gtk_cell_renderer_get_type()), F: marshalCellRenderer},
      {T: externglib.Type(C.gtk_cell_renderer_accel_get_type()), F: marshalCellRendererAccel},
      {T: externglib.Type(C.gtk_cell_renderer_combo_get_type()), F: marshalCellRendererCombo},
      {T: externglib.Type(C.gtk_cell_renderer_pixbuf_get_type()), F: marshalCellRendererPixbuf},
      {T: externglib.Type(C.gtk_cell_renderer_progress_get_type()), F: marshalCellRendererProgress},
      {T: externglib.Type(C.gtk_cell_renderer_spin_get_type()), F: marshalCellRendererSpin},
      {T: externglib.Type(C.gtk_cell_renderer_spinner_get_type()), F: marshalCellRendererSpinner},
      {T: externglib.Type(C.gtk_cell_renderer_text_get_type()), F: marshalCellRendererText},
      {T: externglib.Type(C.gtk_cell_renderer_toggle_get_type()), F: marshalCellRendererToggle},
      {T: externglib.Type(C.gtk_cell_view_get_type()), F: marshalCellView},
      {T: externglib.Type(C.gtk_center_box_get_type()), F: marshalCenterBox},
      {T: externglib.Type(C.gtk_center_layout_get_type()), F: marshalCenterLayout},
      {T: externglib.Type(C.gtk_check_button_get_type()), F: marshalCheckButton},
      {T: externglib.Type(C.gtk_color_button_get_type()), F: marshalColorButton},
      {T: externglib.Type(C.gtk_color_chooser_dialog_get_type()), F: marshalColorChooserDialog},
      {T: externglib.Type(C.gtk_color_chooser_widget_get_type()), F: marshalColorChooserWidget},
      {T: externglib.Type(C.gtk_column_view_get_type()), F: marshalColumnView},
      {T: externglib.Type(C.gtk_column_view_column_get_type()), F: marshalColumnViewColumn},
      {T: externglib.Type(C.gtk_combo_box_get_type()), F: marshalComboBox},
      {T: externglib.Type(C.gtk_combo_box_text_get_type()), F: marshalComboBoxText},
      {T: externglib.Type(C.gtk_constraint_get_type()), F: marshalConstraint},
      {T: externglib.Type(C.gtk_constraint_guide_get_type()), F: marshalConstraintGuide},
      {T: externglib.Type(C.gtk_constraint_layout_get_type()), F: marshalConstraintLayout},
      {T: externglib.Type(C.gtk_constraint_layout_child_get_type()), F: marshalConstraintLayoutChild},
      {T: externglib.Type(C.gtk_css_provider_get_type()), F: marshalCSSProvider},
      {T: externglib.Type(C.gtk_custom_filter_get_type()), F: marshalCustomFilter},
      {T: externglib.Type(C.gtk_custom_layout_get_type()), F: marshalCustomLayout},
      {T: externglib.Type(C.gtk_custom_sorter_get_type()), F: marshalCustomSorter},
      {T: externglib.Type(C.gtk_dialog_get_type()), F: marshalDialog},
      {T: externglib.Type(C.gtk_directory_list_get_type()), F: marshalDirectoryList},
      {T: externglib.Type(C.gtk_drag_icon_get_type()), F: marshalDragIcon},
      {T: externglib.Type(C.gtk_drag_source_get_type()), F: marshalDragSource},
      {T: externglib.Type(C.gtk_drawing_area_get_type()), F: marshalDrawingArea},
      {T: externglib.Type(C.gtk_drop_controller_motion_get_type()), F: marshalDropControllerMotion},
      {T: externglib.Type(C.gtk_drop_down_get_type()), F: marshalDropDown},
      {T: externglib.Type(C.gtk_drop_target_get_type()), F: marshalDropTarget},
      {T: externglib.Type(C.gtk_drop_target_async_get_type()), F: marshalDropTargetAsync},
      {T: externglib.Type(C.gtk_editable_label_get_type()), F: marshalEditableLabel},
      {T: externglib.Type(C.gtk_emoji_chooser_get_type()), F: marshalEmojiChooser},
      {T: externglib.Type(C.gtk_entry_get_type()), F: marshalEntry},
      {T: externglib.Type(C.gtk_entry_buffer_get_type()), F: marshalEntryBuffer},
      {T: externglib.Type(C.gtk_entry_completion_get_type()), F: marshalEntryCompletion},
      {T: externglib.Type(C.gtk_event_controller_get_type()), F: marshalEventController},
      {T: externglib.Type(C.gtk_event_controller_focus_get_type()), F: marshalEventControllerFocus},
      {T: externglib.Type(C.gtk_event_controller_key_get_type()), F: marshalEventControllerKey},
      {T: externglib.Type(C.gtk_event_controller_legacy_get_type()), F: marshalEventControllerLegacy},
      {T: externglib.Type(C.gtk_event_controller_motion_get_type()), F: marshalEventControllerMotion},
      {T: externglib.Type(C.gtk_event_controller_scroll_get_type()), F: marshalEventControllerScroll},
      {T: externglib.Type(C.gtk_every_filter_get_type()), F: marshalEveryFilter},
      {T: externglib.Type(C.gtk_expander_get_type()), F: marshalExpander},
      {T: externglib.Type(C.gtk_file_chooser_dialog_get_type()), F: marshalFileChooserDialog},
      {T: externglib.Type(C.gtk_file_chooser_native_get_type()), F: marshalFileChooserNative},
      {T: externglib.Type(C.gtk_file_chooser_widget_get_type()), F: marshalFileChooserWidget},
      {T: externglib.Type(C.gtk_file_filter_get_type()), F: marshalFileFilter},
      {T: externglib.Type(C.gtk_filter_get_type()), F: marshalFilter},
      {T: externglib.Type(C.gtk_filter_list_model_get_type()), F: marshalFilterListModel},
      {T: externglib.Type(C.gtk_fixed_get_type()), F: marshalFixed},
      {T: externglib.Type(C.gtk_fixed_layout_get_type()), F: marshalFixedLayout},
      {T: externglib.Type(C.gtk_fixed_layout_child_get_type()), F: marshalFixedLayoutChild},
      {T: externglib.Type(C.gtk_flatten_list_model_get_type()), F: marshalFlattenListModel},
      {T: externglib.Type(C.gtk_flow_box_get_type()), F: marshalFlowBox},
      {T: externglib.Type(C.gtk_flow_box_child_get_type()), F: marshalFlowBoxChild},
      {T: externglib.Type(C.gtk_font_button_get_type()), F: marshalFontButton},
      {T: externglib.Type(C.gtk_font_chooser_dialog_get_type()), F: marshalFontChooserDialog},
      {T: externglib.Type(C.gtk_font_chooser_widget_get_type()), F: marshalFontChooserWidget},
      {T: externglib.Type(C.gtk_frame_get_type()), F: marshalFrame},
      {T: externglib.Type(C.gtk_gl_area_get_type()), F: marshalGLArea},
      {T: externglib.Type(C.gtk_gesture_get_type()), F: marshalGesture},
      {T: externglib.Type(C.gtk_gesture_click_get_type()), F: marshalGestureClick},
      {T: externglib.Type(C.gtk_gesture_drag_get_type()), F: marshalGestureDrag},
      {T: externglib.Type(C.gtk_gesture_long_press_get_type()), F: marshalGestureLongPress},
      {T: externglib.Type(C.gtk_gesture_pan_get_type()), F: marshalGesturePan},
      {T: externglib.Type(C.gtk_gesture_rotate_get_type()), F: marshalGestureRotate},
      {T: externglib.Type(C.gtk_gesture_single_get_type()), F: marshalGestureSingle},
      {T: externglib.Type(C.gtk_gesture_stylus_get_type()), F: marshalGestureStylus},
      {T: externglib.Type(C.gtk_gesture_swipe_get_type()), F: marshalGestureSwipe},
      {T: externglib.Type(C.gtk_gesture_zoom_get_type()), F: marshalGestureZoom},
      {T: externglib.Type(C.gtk_grid_get_type()), F: marshalGrid},
      {T: externglib.Type(C.gtk_grid_layout_get_type()), F: marshalGridLayout},
      {T: externglib.Type(C.gtk_grid_layout_child_get_type()), F: marshalGridLayoutChild},
      {T: externglib.Type(C.gtk_grid_view_get_type()), F: marshalGridView},
      {T: externglib.Type(C.gtk_header_bar_get_type()), F: marshalHeaderBar},
      {T: externglib.Type(C.gtk_im_context_get_type()), F: marshalIMContext},
      {T: externglib.Type(C.gtk_im_context_simple_get_type()), F: marshalIMContextSimple},
      {T: externglib.Type(C.gtk_im_multicontext_get_type()), F: marshalIMMulticontext},
      {T: externglib.Type(C.gtk_icon_paintable_get_type()), F: marshalIconPaintable},
      {T: externglib.Type(C.gtk_icon_theme_get_type()), F: marshalIconTheme},
      {T: externglib.Type(C.gtk_icon_view_get_type()), F: marshalIconView},
      {T: externglib.Type(C.gtk_image_get_type()), F: marshalImage},
      {T: externglib.Type(C.gtk_info_bar_get_type()), F: marshalInfoBar},
      {T: externglib.Type(C.gtk_keyval_trigger_get_type()), F: marshalKeyvalTrigger},
      {T: externglib.Type(C.gtk_label_get_type()), F: marshalLabel},
      {T: externglib.Type(C.gtk_layout_child_get_type()), F: marshalLayoutChild},
      {T: externglib.Type(C.gtk_layout_manager_get_type()), F: marshalLayoutManager},
      {T: externglib.Type(C.gtk_level_bar_get_type()), F: marshalLevelBar},
      {T: externglib.Type(C.gtk_link_button_get_type()), F: marshalLinkButton},
      {T: externglib.Type(C.gtk_list_base_get_type()), F: marshalListBase},
      {T: externglib.Type(C.gtk_list_box_get_type()), F: marshalListBox},
      {T: externglib.Type(C.gtk_list_box_row_get_type()), F: marshalListBoxRow},
      {T: externglib.Type(C.gtk_list_item_get_type()), F: marshalListItem},
      {T: externglib.Type(C.gtk_list_item_factory_get_type()), F: marshalListItemFactory},
      {T: externglib.Type(C.gtk_list_store_get_type()), F: marshalListStore},
      {T: externglib.Type(C.gtk_list_view_get_type()), F: marshalListView},
      {T: externglib.Type(C.gtk_lock_button_get_type()), F: marshalLockButton},
      {T: externglib.Type(C.gtk_map_list_model_get_type()), F: marshalMapListModel},
      {T: externglib.Type(C.gtk_media_controls_get_type()), F: marshalMediaControls},
      {T: externglib.Type(C.gtk_media_file_get_type()), F: marshalMediaFile},
      {T: externglib.Type(C.gtk_media_stream_get_type()), F: marshalMediaStream},
      {T: externglib.Type(C.gtk_menu_button_get_type()), F: marshalMenuButton},
      {T: externglib.Type(C.gtk_message_dialog_get_type()), F: marshalMessageDialog},
      {T: externglib.Type(C.gtk_mnemonic_action_get_type()), F: marshalMnemonicAction},
      {T: externglib.Type(C.gtk_mnemonic_trigger_get_type()), F: marshalMnemonicTrigger},
      {T: externglib.Type(C.gtk_mount_operation_get_type()), F: marshalMountOperation},
      {T: externglib.Type(C.gtk_multi_filter_get_type()), F: marshalMultiFilter},
      {T: externglib.Type(C.gtk_multi_selection_get_type()), F: marshalMultiSelection},
      {T: externglib.Type(C.gtk_multi_sorter_get_type()), F: marshalMultiSorter},
      {T: externglib.Type(C.gtk_named_action_get_type()), F: marshalNamedAction},
      {T: externglib.Type(C.gtk_native_dialog_get_type()), F: marshalNativeDialog},
      {T: externglib.Type(C.gtk_never_trigger_get_type()), F: marshalNeverTrigger},
      {T: externglib.Type(C.gtk_no_selection_get_type()), F: marshalNoSelection},
      {T: externglib.Type(C.gtk_notebook_get_type()), F: marshalNotebook},
      {T: externglib.Type(C.gtk_notebook_page_get_type()), F: marshalNotebookPage},
      {T: externglib.Type(C.gtk_nothing_action_get_type()), F: marshalNothingAction},
      {T: externglib.Type(C.gtk_numeric_sorter_get_type()), F: marshalNumericSorter},
      {T: externglib.Type(C.gtk_overlay_get_type()), F: marshalOverlay},
      {T: externglib.Type(C.gtk_overlay_layout_get_type()), F: marshalOverlayLayout},
      {T: externglib.Type(C.gtk_overlay_layout_child_get_type()), F: marshalOverlayLayoutChild},
      {T: externglib.Type(C.gtk_pad_controller_get_type()), F: marshalPadController},
      {T: externglib.Type(C.gtk_page_setup_get_type()), F: marshalPageSetup},
      {T: externglib.Type(C.gtk_page_setup_unix_dialog_get_type()), F: marshalPageSetupUnixDialog},
      {T: externglib.Type(C.gtk_paned_get_type()), F: marshalPaned},
      {T: externglib.Type(C.gtk_password_entry_get_type()), F: marshalPasswordEntry},
      {T: externglib.Type(C.gtk_picture_get_type()), F: marshalPicture},
      {T: externglib.Type(C.gtk_popover_get_type()), F: marshalPopover},
      {T: externglib.Type(C.gtk_popover_menu_get_type()), F: marshalPopoverMenu},
      {T: externglib.Type(C.gtk_popover_menu_bar_get_type()), F: marshalPopoverMenuBar},
      {T: externglib.Type(C.gtk_print_context_get_type()), F: marshalPrintContext},
      {T: externglib.Type(C.gtk_print_job_get_type()), F: marshalPrintJob},
      {T: externglib.Type(C.gtk_print_operation_get_type()), F: marshalPrintOperation},
      {T: externglib.Type(C.gtk_print_settings_get_type()), F: marshalPrintSettings},
      {T: externglib.Type(C.gtk_print_unix_dialog_get_type()), F: marshalPrintUnixDialog},
      {T: externglib.Type(C.gtk_printer_get_type()), F: marshalPrinter},
      {T: externglib.Type(C.gtk_progress_bar_get_type()), F: marshalProgressBar},
      {T: externglib.Type(C.gtk_range_get_type()), F: marshalRange},
      {T: externglib.Type(C.gtk_recent_manager_get_type()), F: marshalRecentManager},
      {T: externglib.Type(C.gtk_revealer_get_type()), F: marshalRevealer},
      {T: externglib.Type(C.gtk_scale_get_type()), F: marshalScale},
      {T: externglib.Type(C.gtk_scale_button_get_type()), F: marshalScaleButton},
      {T: externglib.Type(C.gtk_scrollbar_get_type()), F: marshalScrollbar},
      {T: externglib.Type(C.gtk_scrolled_window_get_type()), F: marshalScrolledWindow},
      {T: externglib.Type(C.gtk_search_bar_get_type()), F: marshalSearchBar},
      {T: externglib.Type(C.gtk_search_entry_get_type()), F: marshalSearchEntry},
      {T: externglib.Type(C.gtk_selection_filter_model_get_type()), F: marshalSelectionFilterModel},
      {T: externglib.Type(C.gtk_separator_get_type()), F: marshalSeparator},
      {T: externglib.Type(C.gtk_settings_get_type()), F: marshalSettings},
      {T: externglib.Type(C.gtk_shortcut_get_type()), F: marshalShortcut},
      {T: externglib.Type(C.gtk_shortcut_action_get_type()), F: marshalShortcutAction},
      {T: externglib.Type(C.gtk_shortcut_controller_get_type()), F: marshalShortcutController},
      {T: externglib.Type(C.gtk_shortcut_label_get_type()), F: marshalShortcutLabel},
      {T: externglib.Type(C.gtk_shortcut_trigger_get_type()), F: marshalShortcutTrigger},
      {T: externglib.Type(C.gtk_shortcuts_group_get_type()), F: marshalShortcutsGroup},
      {T: externglib.Type(C.gtk_shortcuts_section_get_type()), F: marshalShortcutsSection},
      {T: externglib.Type(C.gtk_shortcuts_shortcut_get_type()), F: marshalShortcutsShortcut},
      {T: externglib.Type(C.gtk_shortcuts_window_get_type()), F: marshalShortcutsWindow},
      {T: externglib.Type(C.gtk_signal_action_get_type()), F: marshalSignalAction},
      {T: externglib.Type(C.gtk_signal_list_item_factory_get_type()), F: marshalSignalListItemFactory},
      {T: externglib.Type(C.gtk_single_selection_get_type()), F: marshalSingleSelection},
      {T: externglib.Type(C.gtk_size_group_get_type()), F: marshalSizeGroup},
      {T: externglib.Type(C.gtk_slice_list_model_get_type()), F: marshalSliceListModel},
      {T: externglib.Type(C.gtk_snapshot_get_type()), F: marshalSnapshot},
      {T: externglib.Type(C.gtk_sort_list_model_get_type()), F: marshalSortListModel},
      {T: externglib.Type(C.gtk_sorter_get_type()), F: marshalSorter},
      {T: externglib.Type(C.gtk_spin_button_get_type()), F: marshalSpinButton},
      {T: externglib.Type(C.gtk_spinner_get_type()), F: marshalSpinner},
      {T: externglib.Type(C.gtk_stack_get_type()), F: marshalStack},
      {T: externglib.Type(C.gtk_stack_page_get_type()), F: marshalStackPage},
      {T: externglib.Type(C.gtk_stack_sidebar_get_type()), F: marshalStackSidebar},
      {T: externglib.Type(C.gtk_stack_switcher_get_type()), F: marshalStackSwitcher},
      {T: externglib.Type(C.gtk_statusbar_get_type()), F: marshalStatusbar},
      {T: externglib.Type(C.gtk_string_filter_get_type()), F: marshalStringFilter},
      {T: externglib.Type(C.gtk_string_sorter_get_type()), F: marshalStringSorter},
      {T: externglib.Type(C.gtk_style_context_get_type()), F: marshalStyleContext},
      {T: externglib.Type(C.gtk_switch_get_type()), F: marshalSwitch},
      {T: externglib.Type(C.gtk_text_get_type()), F: marshalText},
      {T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBuffer},
      {T: externglib.Type(C.gtk_text_child_anchor_get_type()), F: marshalTextChildAnchor},
      {T: externglib.Type(C.gtk_text_mark_get_type()), F: marshalTextMark},
      {T: externglib.Type(C.gtk_text_tag_get_type()), F: marshalTextTag},
      {T: externglib.Type(C.gtk_text_tag_table_get_type()), F: marshalTextTagTable},
      {T: externglib.Type(C.gtk_text_view_get_type()), F: marshalTextView},
      {T: externglib.Type(C.gtk_toggle_button_get_type()), F: marshalToggleButton},
      {T: externglib.Type(C.gtk_tooltip_get_type()), F: marshalTooltip},
      {T: externglib.Type(C.gtk_tree_expander_get_type()), F: marshalTreeExpander},
      {T: externglib.Type(C.gtk_tree_list_model_get_type()), F: marshalTreeListModel},
      {T: externglib.Type(C.gtk_tree_list_row_get_type()), F: marshalTreeListRow},
      {T: externglib.Type(C.gtk_tree_list_row_sorter_get_type()), F: marshalTreeListRowSorter},
      {T: externglib.Type(C.gtk_tree_model_filter_get_type()), F: marshalTreeModelFilter},
      {T: externglib.Type(C.gtk_tree_model_sort_get_type()), F: marshalTreeModelSort},
      {T: externglib.Type(C.gtk_tree_selection_get_type()), F: marshalTreeSelection},
      {T: externglib.Type(C.gtk_tree_store_get_type()), F: marshalTreeStore},
      {T: externglib.Type(C.gtk_tree_view_get_type()), F: marshalTreeView},
      {T: externglib.Type(C.gtk_tree_view_column_get_type()), F: marshalTreeViewColumn},
      {T: externglib.Type(C.gtk_video_get_type()), F: marshalVideo},
      {T: externglib.Type(C.gtk_viewport_get_type()), F: marshalViewport},
      {T: externglib.Type(C.gtk_volume_button_get_type()), F: marshalVolumeButton},
      {T: externglib.Type(C.gtk_widget_get_type()), F: marshalWidget},
      {T: externglib.Type(C.gtk_widget_paintable_get_type()), F: marshalWidgetPaintable},
      {T: externglib.Type(C.gtk_window_get_type()), F: marshalWindow},
      {T: externglib.Type(C.gtk_window_controls_get_type()), F: marshalWindowControls},
      {T: externglib.Type(C.gtk_window_group_get_type()), F: marshalWindowGroup},
      {T: externglib.Type(C.gtk_window_handle_get_type()), F: marshalWindowHandle},
      {T: externglib.Type(C.gtk_bitset_get_type()), F: marshalBitset},
      {T: externglib.Type(C.gtk_border_get_type()), F: marshalBorder},
      {T: externglib.Type(C.gtk_css_section_get_type()), F: marshalCSSSection},
      {T: externglib.Type(C.gtk_expression_watch_get_type()), F: marshalExpressionWatch},
      {T: externglib.Type(C.gtk_paper_size_get_type()), F: marshalPaperSize},
      {T: externglib.Type(C.gtk_recent_info_get_type()), F: marshalRecentInfo},
      {T: externglib.Type(C.gtk_requisition_get_type()), F: marshalRequisition},
      {T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
      {T: externglib.Type(C.gtk_tree_iter_get_type()), F: marshalTreeIter},
      {T: externglib.Type(C.gtk_tree_path_get_type()), F: marshalTreePath},
      {T: externglib.Type(C.gtk_tree_row_reference_get_type()), F: marshalTreeRowReference},
  })
}


	
	// Allocation: the rectangle representing the area allocated for a widget by its
// parent.
	type Allocation = gdk.Rectangle


	

	// AccessibleAutocomplete: the possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
	type AccessibleAutocomplete int

	const (
			// AccessibleAutocompleteNone: automatic suggestions are not displayed.
		AccessibleAutocompleteNone AccessibleAutocomplete = 0
			// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
		AccessibleAutocompleteInline AccessibleAutocomplete = 1
			// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
		AccessibleAutocompleteList AccessibleAutocomplete = 2
			// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
		AccessibleAutocompleteBoth AccessibleAutocomplete = 3
		)

	
	func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
		return AccessibleAutocomplete(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccessibleInvalidState: the possible values for the
// GTK_ACCESSIBLE_STATE_INVALID accessible state.
// 
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as false and true.
	type AccessibleInvalidState int

	const (
			// AccessibleInvalidStateFalse: there are no detected errors in the value
		AccessibleInvalidStateFalse AccessibleInvalidState = 0
			// AccessibleInvalidStateTrue: the value entered by the user has failed
	// validation
		AccessibleInvalidStateTrue AccessibleInvalidState = 1
			// AccessibleInvalidStateGrammar: a grammatical error was detected
		AccessibleInvalidStateGrammar AccessibleInvalidState = 2
			// AccessibleInvalidStateSpelling: a spelling error was detected
		AccessibleInvalidStateSpelling AccessibleInvalidState = 3
		)

	
	func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
		return AccessibleInvalidState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccessibleProperty: the possible accessible properties of a `GtkAccessible`.
	type AccessibleProperty int

	const (
			// AccessiblePropertyAutocomplete indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete
		AccessiblePropertyAutocomplete AccessibleProperty = 0
			// AccessiblePropertyDescription defines a string value that describes or
	// annotates the current element. Value type: string
		AccessiblePropertyDescription AccessibleProperty = 1
			// AccessiblePropertyHasPopup indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
		AccessiblePropertyHasPopup AccessibleProperty = 2
			// AccessiblePropertyKeyShortcuts indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string
		AccessiblePropertyKeyShortcuts AccessibleProperty = 3
			// AccessiblePropertyLabel defines a string value that labels the current
	// element. Value type: string
		AccessiblePropertyLabel AccessibleProperty = 4
			// AccessiblePropertyLevel defines the hierarchical level of an element
	// within a structure. Value type: integer
		AccessiblePropertyLevel AccessibleProperty = 5
			// AccessiblePropertyModal indicates whether an element is modal when
	// displayed. Value type: boolean
		AccessiblePropertyModal AccessibleProperty = 6
			// AccessiblePropertyMultiLine indicates whether a text box accepts multiple
	// lines of input or only a single line. Value type: boolean
		AccessiblePropertyMultiLine AccessibleProperty = 7
			// AccessiblePropertyMultiSelectable indicates that the user may select more
	// than one item from the current selectable descendants. Value type:
	// boolean
		AccessiblePropertyMultiSelectable AccessibleProperty = 8
			// AccessiblePropertyOrientation indicates whether the element's orientation
	// is horizontal, vertical, or unknown/ambiguous. Value type: Orientation
		AccessiblePropertyOrientation AccessibleProperty = 9
			// AccessiblePropertyPlaceholder defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has no
	// value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string
		AccessiblePropertyPlaceholder AccessibleProperty = 10
			// AccessiblePropertyReadOnly indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean
		AccessiblePropertyReadOnly AccessibleProperty = 11
			// AccessiblePropertyRequired indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean
		AccessiblePropertyRequired AccessibleProperty = 12
			// AccessiblePropertyRoleDescription defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string
		AccessiblePropertyRoleDescription AccessibleProperty = 13
			// AccessiblePropertySort indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort
		AccessiblePropertySort AccessibleProperty = 14
			// AccessiblePropertyValueMax defines the maximum allowed value for a range
	// widget. Value type: double
		AccessiblePropertyValueMax AccessibleProperty = 15
			// AccessiblePropertyValueMin defines the minimum allowed value for a range
	// widget. Value type: double
		AccessiblePropertyValueMin AccessibleProperty = 16
			// AccessiblePropertyValueNow defines the current value for a range widget.
	// Value type: double
		AccessiblePropertyValueNow AccessibleProperty = 17
			// AccessiblePropertyValueText defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string
		AccessiblePropertyValueText AccessibleProperty = 18
		)

	
	func marshalAccessibleProperty(p uintptr) (interface{}, error) {
		return AccessibleProperty(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccessibleRelation: the possible accessible relations of a `GtkAccessible`.
// 
// Accessible relations can be references to other widgets, integers or strings.
	type AccessibleRelation int

	const (
			// AccessibleRelationActiveDescendant identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group, or
	// application. Value type: reference
		AccessibleRelationActiveDescendant AccessibleRelation = 0
			// AccessibleRelationColCount defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer
		AccessibleRelationColCount AccessibleRelation = 1
			// AccessibleRelationColIndex defines an element's column index or position
	// with respect to the total number of columns within a table, grid, or
	// treegrid. Value type: integer
		AccessibleRelationColIndex AccessibleRelation = 2
			// AccessibleRelationColIndexText defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string
		AccessibleRelationColIndexText AccessibleRelation = 3
			// AccessibleRelationColSpan defines the number of columns spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer
		AccessibleRelationColSpan AccessibleRelation = 4
			// AccessibleRelationControls identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference
		AccessibleRelationControls AccessibleRelation = 5
			// AccessibleRelationDescribedBy identifies the element (or elements) that
	// describes the object. Value type: reference
		AccessibleRelationDescribedBy AccessibleRelation = 6
			// AccessibleRelationDetails identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference
		AccessibleRelationDetails AccessibleRelation = 7
			// AccessibleRelationErrorMessage identifies the element that provides an
	// error message for an object. Value type: reference
		AccessibleRelationErrorMessage AccessibleRelation = 8
			// AccessibleRelationFlowTo identifies the next element (or elements) in an
	// alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference
		AccessibleRelationFlowTo AccessibleRelation = 9
			// AccessibleRelationLabelledBy identifies the element (or elements) that
	// labels the current element. Value type: reference
		AccessibleRelationLabelledBy AccessibleRelation = 10
			// AccessibleRelationOwns identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference
		AccessibleRelationOwns AccessibleRelation = 11
			// AccessibleRelationPosInSet defines an element's number or position in the
	// current set of listitems or treeitems. Value type: integer
		AccessibleRelationPosInSet AccessibleRelation = 12
			// AccessibleRelationRowCount defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer
		AccessibleRelationRowCount AccessibleRelation = 13
			// AccessibleRelationRowIndex defines an element's row index or position
	// with respect to the total number of rows within a table, grid, or
	// treegrid. Value type: integer
		AccessibleRelationRowIndex AccessibleRelation = 14
			// AccessibleRelationRowIndexText defines a human readable text alternative
	// of aria-rowindex. Value type: string
		AccessibleRelationRowIndexText AccessibleRelation = 15
			// AccessibleRelationRowSpan defines the number of rows spanned by a cell or
	// gridcell within a table, grid, or treegrid. Value type: integer
		AccessibleRelationRowSpan AccessibleRelation = 16
			// AccessibleRelationSetSize defines the number of items in the current set
	// of listitems or treeitems. Value type: integer
		AccessibleRelationSetSize AccessibleRelation = 17
		)

	
	func marshalAccessibleRelation(p uintptr) (interface{}, error) {
		return AccessibleRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccessibleRole: the accessible role for a `GtkAccessible` implementation.
// 
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
	type AccessibleRole int

	const (
			// AccessibleRoleAlert: an element with important, and usually
	// time-sensitive, information
		AccessibleRoleAlert AccessibleRole = 0
			// AccessibleRoleAlertDialog: a type of dialog that contains an alert
	// message
		AccessibleRoleAlertDialog AccessibleRole = 1
			// AccessibleRoleBanner: unused
		AccessibleRoleBanner AccessibleRole = 2
			// AccessibleRoleButton: an input element that allows for user-triggered
	// actions when clicked or pressed
		AccessibleRoleButton AccessibleRole = 3
			// AccessibleRoleCaption: unused
		AccessibleRoleCaption AccessibleRole = 4
			// AccessibleRoleCell: unused
		AccessibleRoleCell AccessibleRole = 5
			// AccessibleRoleCheckbox: a checkable input element that has three possible
	// values: `true`, `false`, or `mixed`
		AccessibleRoleCheckbox AccessibleRole = 6
			// AccessibleRoleColumnHeader: a header in a columned list.
		AccessibleRoleColumnHeader AccessibleRole = 7
			// AccessibleRoleComboBox: an input that controls another element, such as a
	// list or a grid, that can dynamically pop up to help the user set the
	// value of the input
		AccessibleRoleComboBox AccessibleRole = 8
			// AccessibleRoleCommand: abstract role.
		AccessibleRoleCommand AccessibleRole = 9
			// AccessibleRoleComposite: abstract role.
		AccessibleRoleComposite AccessibleRole = 10
			// AccessibleRoleDialog: a dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
		AccessibleRoleDialog AccessibleRole = 11
			// AccessibleRoleDocument: unused
		AccessibleRoleDocument AccessibleRole = 12
			// AccessibleRoleFeed: unused
		AccessibleRoleFeed AccessibleRole = 13
			// AccessibleRoleForm: unused
		AccessibleRoleForm AccessibleRole = 14
			// AccessibleRoleGeneric: unused
		AccessibleRoleGeneric AccessibleRole = 15
			// AccessibleRoleGrid: a grid of items.
		AccessibleRoleGrid AccessibleRole = 16
			// AccessibleRoleGridCell: an item in a grid or tree grid.
		AccessibleRoleGridCell AccessibleRole = 17
			// AccessibleRoleGroup: an element that groups multiple widgets. GTK uses
	// this role for various containers, like Box, Viewport, and HeaderBar.
		AccessibleRoleGroup AccessibleRole = 18
			// AccessibleRoleHeading: unused
		AccessibleRoleHeading AccessibleRole = 19
			// AccessibleRoleImg: an image.
		AccessibleRoleImg AccessibleRole = 20
			// AccessibleRoleInput: abstract role.
		AccessibleRoleInput AccessibleRole = 21
			// AccessibleRoleLabel: a visible name or caption for a user interface
	// component.
		AccessibleRoleLabel AccessibleRole = 22
			// AccessibleRoleLandmark: abstract role.
		AccessibleRoleLandmark AccessibleRole = 23
			// AccessibleRoleLegend: unused
		AccessibleRoleLegend AccessibleRole = 24
			// AccessibleRoleLink: a clickable link.
		AccessibleRoleLink AccessibleRole = 25
			// AccessibleRoleList: a list of items.
		AccessibleRoleList AccessibleRole = 26
			// AccessibleRoleListBox: unused.
		AccessibleRoleListBox AccessibleRole = 27
			// AccessibleRoleListItem: an item in a list.
		AccessibleRoleListItem AccessibleRole = 28
			// AccessibleRoleLog: unused
		AccessibleRoleLog AccessibleRole = 29
			// AccessibleRoleMain: unused
		AccessibleRoleMain AccessibleRole = 30
			// AccessibleRoleMarquee: unused
		AccessibleRoleMarquee AccessibleRole = 31
			// AccessibleRoleMath: unused
		AccessibleRoleMath AccessibleRole = 32
			// AccessibleRoleMeter: an element that represents a value within a known
	// range.
		AccessibleRoleMeter AccessibleRole = 33
			// AccessibleRoleMenu: a menu.
		AccessibleRoleMenu AccessibleRole = 34
			// AccessibleRoleMenuBar: a menubar.
		AccessibleRoleMenuBar AccessibleRole = 35
			// AccessibleRoleMenuItem: an item in a menu.
		AccessibleRoleMenuItem AccessibleRole = 36
			// AccessibleRoleMenuItemCheckbox: a check item in a menu.
		AccessibleRoleMenuItemCheckbox AccessibleRole = 37
			// AccessibleRoleMenuItemRadio: a radio item in a menu.
		AccessibleRoleMenuItemRadio AccessibleRole = 38
			// AccessibleRoleNavigation: unused
		AccessibleRoleNavigation AccessibleRole = 39
			// AccessibleRoleNone: an element that is not represented to accessibility
	// technologies.
		AccessibleRoleNone AccessibleRole = 40
			// AccessibleRoleNote: unused
		AccessibleRoleNote AccessibleRole = 41
			// AccessibleRoleOption: unused
		AccessibleRoleOption AccessibleRole = 42
			// AccessibleRolePresentation: an element that is not represented to
	// accessibility technologies.
		AccessibleRolePresentation AccessibleRole = 43
			// AccessibleRoleProgressBar: an element that displays the progress status
	// for tasks that take a long time.
		AccessibleRoleProgressBar AccessibleRole = 44
			// AccessibleRoleRadio: a checkable input in a group of radio roles, only
	// one of which can be checked at a time.
		AccessibleRoleRadio AccessibleRole = 45
			// AccessibleRoleRadioGroup: unused
		AccessibleRoleRadioGroup AccessibleRole = 46
			// AccessibleRoleRange: abstract role.
		AccessibleRoleRange AccessibleRole = 47
			// AccessibleRoleRegion: unused
		AccessibleRoleRegion AccessibleRole = 48
			// AccessibleRoleRow: a row in a columned list.
		AccessibleRoleRow AccessibleRole = 49
			// AccessibleRoleRowGroup: unused
		AccessibleRoleRowGroup AccessibleRole = 50
			// AccessibleRoleRowHeader: unused
		AccessibleRoleRowHeader AccessibleRole = 51
			// AccessibleRoleScrollbar: a graphical object that controls the scrolling
	// of content within a viewing area, regardless of whether the content is
	// fully displayed within the viewing area.
		AccessibleRoleScrollbar AccessibleRole = 52
			// AccessibleRoleSearch: unused
		AccessibleRoleSearch AccessibleRole = 53
			// AccessibleRoleSearchBox: a type of textbox intended for specifying search
	// criteria.
		AccessibleRoleSearchBox AccessibleRole = 54
			// AccessibleRoleSection: abstract role.
		AccessibleRoleSection AccessibleRole = 55
			// AccessibleRoleSectionHead: abstract role.
		AccessibleRoleSectionHead AccessibleRole = 56
			// AccessibleRoleSelect: abstract role.
		AccessibleRoleSelect AccessibleRole = 57
			// AccessibleRoleSeparator: a divider that separates and distinguishes
	// sections of content or groups of menuitems.
		AccessibleRoleSeparator AccessibleRole = 58
			// AccessibleRoleSlider: a user input where the user selects a value from
	// within a given range.
		AccessibleRoleSlider AccessibleRole = 59
			// AccessibleRoleSpinButton: a form of range that expects the user to select
	// from among discrete choices.
		AccessibleRoleSpinButton AccessibleRole = 60
			// AccessibleRoleStatus: unused
		AccessibleRoleStatus AccessibleRole = 61
			// AccessibleRoleStructure: abstract role.
		AccessibleRoleStructure AccessibleRole = 62
			// AccessibleRoleSwitch: a type of checkbox that represents on/off values,
	// as opposed to checked/unchecked values.
		AccessibleRoleSwitch AccessibleRole = 63
			// AccessibleRoleTab: an item in a list of tab used for switching pages.
		AccessibleRoleTab AccessibleRole = 64
			// AccessibleRoleTable: unused
		AccessibleRoleTable AccessibleRole = 65
			// AccessibleRoleTabList: a list of tabs for switching pages.
		AccessibleRoleTabList AccessibleRole = 66
			// AccessibleRoleTabPanel: a page in a notebook or stack.
		AccessibleRoleTabPanel AccessibleRole = 67
			// AccessibleRoleTextBox: a type of input that allows free-form text as its
	// value.
		AccessibleRoleTextBox AccessibleRole = 68
			// AccessibleRoleTime: unused
		AccessibleRoleTime AccessibleRole = 69
			// AccessibleRoleTimer: unused
		AccessibleRoleTimer AccessibleRole = 70
			// AccessibleRoleToolbar: unused
		AccessibleRoleToolbar AccessibleRole = 71
			// AccessibleRoleTooltip: unused
		AccessibleRoleTooltip AccessibleRole = 72
			// AccessibleRoleTree: unused
		AccessibleRoleTree AccessibleRole = 73
			// AccessibleRoleTreeGrid: a treeview-like, columned list.
		AccessibleRoleTreeGrid AccessibleRole = 74
			// AccessibleRoleTreeItem: unused
		AccessibleRoleTreeItem AccessibleRole = 75
			// AccessibleRoleWidget: an interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
		AccessibleRoleWidget AccessibleRole = 76
			// AccessibleRoleWindow: an application window.
		AccessibleRoleWindow AccessibleRole = 77
		)

	
	func marshalAccessibleRole(p uintptr) (interface{}, error) {
		return AccessibleRole(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccessibleSort: the possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
	type AccessibleSort int

	const (
			// AccessibleSortNone: there is no defined sort applied to the column.
		AccessibleSortNone AccessibleSort = 0
			// AccessibleSortAscending items are sorted in ascending order by this
	// column.
		AccessibleSortAscending AccessibleSort = 1
			// AccessibleSortDescending items are sorted in descending order by this
	// column.
		AccessibleSortDescending AccessibleSort = 2
			// AccessibleSortOther: a sort algorithm other than ascending or descending
	// has been applied.
		AccessibleSortOther AccessibleSort = 3
		)

	
	func marshalAccessibleSort(p uintptr) (interface{}, error) {
		return AccessibleSort(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccessibleState: the possible accessible states of a `GtkAccessible`.
	type AccessibleState int

	const (
			// AccessibleStateBusy: a busy state. This state has boolean values
		AccessibleStateBusy AccessibleState = 0
			// AccessibleStateChecked: a checked state; indicates the current state of
	// a CheckButton. Value type: AccessibleTristate
		AccessibleStateChecked AccessibleState = 1
			// AccessibleStateDisabled: a disabled state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean
		AccessibleStateDisabled AccessibleState = 2
			// AccessibleStateExpanded: an expanded state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined
		AccessibleStateExpanded AccessibleState = 3
			// AccessibleStateHidden: a hidden state; corresponds to the
	// Widget:visible property on Widget. You can use this state explicitly on
	// UI elements that should not be exposed to an assistive technology. Value
	// type: boolean See also: GTK_ACCESSIBLE_STATE_DISABLED
		AccessibleStateHidden AccessibleState = 4
			// AccessibleStateInvalid: an invalid state; set when a widget is showing
	// an error. Value type: AccessibleInvalidState
		AccessibleStateInvalid AccessibleState = 5
			// AccessibleStatePressed: a pressed state; indicates the current state of
	// a ToggleButton. Value type: AccessibleTristate enumeration
		AccessibleStatePressed AccessibleState = 6
			// AccessibleStateSelected: a selected state; set when a widget is
	// selected. Value type: boolean or undefined
		AccessibleStateSelected AccessibleState = 7
		)

	
	func marshalAccessibleState(p uintptr) (interface{}, error) {
		return AccessibleState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AccessibleTristate: the possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
// 
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as false and true.
	type AccessibleTristate int

	const (
			// AccessibleTristateFalse: the state is `false`
		AccessibleTristateFalse AccessibleTristate = 0
			// AccessibleTristateTrue: the state is `true`
		AccessibleTristateTrue AccessibleTristate = 1
			// AccessibleTristateMixed: the state is `mixed`
		AccessibleTristateMixed AccessibleTristate = 2
		)

	
	func marshalAccessibleTristate(p uintptr) (interface{}, error) {
		return AccessibleTristate(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Align controls how a widget deals with extra space in a single dimension.
// 
// Alignment only matters if the widget receives a too large allocation, for
// example if you packed the widget with the [property@Gtk.Widget:hexpand]
// property inside a `GtkBox`, then the widget might get extra space. If you
// have for example a 16x16 icon inside a 32x32 space, the icon could be scaled
// and stretched, it could be centered, or it could be positioned to one side of
// the space.
// 
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
// 
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
	type Align int

	const (
			// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch
		AlignFill Align = 0
			// AlignStart: snap to left or top side, leaving space on right or bottom
		AlignStart Align = 1
			// AlignEnd: snap to right or bottom side, leaving space on left or top
		AlignEnd Align = 2
			// AlignCenter: center natural width of widget inside the allocation
		AlignCenter Align = 3
			// AlignBaseline: align the widget according to the baseline. See Widget
		AlignBaseline Align = 4
		)

	
	func marshalAlign(p uintptr) (interface{}, error) {
		return Align(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ArrowType: used to indicate the direction in which an arrow should point.
	type ArrowType int

	const (
			// ArrowTypeUp represents an upward pointing arrow.
		ArrowTypeUp ArrowType = 0
			// ArrowTypeDown represents a downward pointing arrow.
		ArrowTypeDown ArrowType = 1
			// ArrowTypeLeft represents a left pointing arrow.
		ArrowTypeLeft ArrowType = 2
			// ArrowTypeRight represents a right pointing arrow.
		ArrowTypeRight ArrowType = 3
			// ArrowTypeNone: no arrow.
		ArrowTypeNone ArrowType = 4
		)

	
	func marshalArrowType(p uintptr) (interface{}, error) {
		return ArrowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// AssistantPageType determines the page role inside a `GtkAssistant`.
// 
// The role is used to handle buttons sensitivity and visibility.
// 
// Note that an assistant needs to end its page flow with a page of type
// GTK_ASSISTANT_PAGE_CONFIRM, GTK_ASSISTANT_PAGE_SUMMARY or
// GTK_ASSISTANT_PAGE_PROGRESS to be correct.
// 
// The Cancel button will only be shown if the page isnt committed. See
// gtk_assistant_commit() for details.
	type AssistantPageType int

	const (
			// AssistantPageTypeContent: the page has regular contents. Both the Back
	// and forward buttons will be shown.
		AssistantPageTypeContent AssistantPageType = 0
			// AssistantPageTypeIntro: the page contains an introduction to the
	// assistant task. Only the Forward button will be shown if there is a next
	// page.
		AssistantPageTypeIntro AssistantPageType = 1
			// AssistantPageTypeConfirm: the page lets the user confirm or deny the
	// changes. The Back and Apply buttons will be shown.
		AssistantPageTypeConfirm AssistantPageType = 2
			// AssistantPageTypeSummary: the page informs the user of the changes done.
	// Only the Close button will be shown.
		AssistantPageTypeSummary AssistantPageType = 3
			// AssistantPageTypeProgress: used for tasks that take a long time to
	// complete, blocks the assistant until the page is marked as complete. Only
	// the back button will be shown.
		AssistantPageTypeProgress AssistantPageType = 4
			// AssistantPageTypeCustom: used for when other page types are not
	// appropriate. No buttons will be shown, and the application must add its
	// own buttons through gtk_assistant_add_action_widget().
		AssistantPageTypeCustom AssistantPageType = 5
		)

	
	func marshalAssistantPageType(p uintptr) (interface{}, error) {
		return AssistantPageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BaselinePosition: baseline position in a row of widgets.
// 
// Whenever a container has some form of natural row it may align children in
// that row along a common typographical baseline. If the amount of vertical
// space in the row is taller than the total requested height of the
// baseline-aligned children then it can use a `GtkBaselinePosition` to select
// where to put the baseline inside the extra available space.
	type BaselinePosition int

	const (
			// BaselinePositionTop: align the baseline at the top
		BaselinePositionTop BaselinePosition = 0
			// BaselinePositionCenter: center the baseline
		BaselinePositionCenter BaselinePosition = 1
			// BaselinePositionBottom: align the baseline at the bottom
		BaselinePositionBottom BaselinePosition = 2
		)

	
	func marshalBaselinePosition(p uintptr) (interface{}, error) {
		return BaselinePosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BorderStyle describes how the border of a UI element should be rendered.
	type BorderStyle int

	const (
			// BorderStyleNone: no visible border
		BorderStyleNone BorderStyle = 0
			// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE
		BorderStyleHidden BorderStyle = 1
			// BorderStyleSolid: a single line segment
		BorderStyleSolid BorderStyle = 2
			// BorderStyleInset looks as if the content is sunken into the canvas
		BorderStyleInset BorderStyle = 3
			// BorderStyleOutset looks as if the content is coming out of the canvas
		BorderStyleOutset BorderStyle = 4
			// BorderStyleDotted: a series of round dots
		BorderStyleDotted BorderStyle = 5
			// BorderStyleDashed: a series of square-ended dashes
		BorderStyleDashed BorderStyle = 6
			// BorderStyleDouble: two parallel lines with some space between them
		BorderStyleDouble BorderStyle = 7
			// BorderStyleGroove looks as if it were carved in the canvas
		BorderStyleGroove BorderStyle = 8
			// BorderStyleRidge looks as if it were coming out of the canvas
		BorderStyleRidge BorderStyle = 9
		)

	
	func marshalBorderStyle(p uintptr) (interface{}, error) {
		return BorderStyle(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BuilderError: error codes that identify various errors that can occur while
// using Builder.
	type BuilderError int

	const (
			// BuilderErrorInvalidTypeFunction: a type-func attribute didnt name a
	// function that returns a #GType.
		BuilderErrorInvalidTypeFunction BuilderError = 0
			// BuilderErrorUnhandledTag: the input contained a tag that Builder cant
	// handle.
		BuilderErrorUnhandledTag BuilderError = 1
			// BuilderErrorMissingAttribute: an attribute that is required by Builder
	// was missing.
		BuilderErrorMissingAttribute BuilderError = 2
			// BuilderErrorInvalidAttribute: Builder found an attribute that it doesnt
	// understand.
		BuilderErrorInvalidAttribute BuilderError = 3
			// BuilderErrorInvalidTag: Builder found a tag that it doesnt understand.
		BuilderErrorInvalidTag BuilderError = 4
			// BuilderErrorMissingPropertyValue: a required property value was missing.
		BuilderErrorMissingPropertyValue BuilderError = 5
			// BuilderErrorInvalidValue: Builder couldnt parse some attribute value.
		BuilderErrorInvalidValue BuilderError = 6
			// BuilderErrorVersionMismatch: the input file requires a newer version of
	// GTK.
		BuilderErrorVersionMismatch BuilderError = 7
			// BuilderErrorDuplicateID: an object id occurred twice.
		BuilderErrorDuplicateID BuilderError = 8
			// BuilderErrorObjectTypeRefused: a specified object type is of the same
	// type or derived from the type of the composite class being extended with
	// builder XML.
		BuilderErrorObjectTypeRefused BuilderError = 9
			// BuilderErrorTemplateMismatch: the wrong type was specified in a composite
	// classs template XML
		BuilderErrorTemplateMismatch BuilderError = 10
			// BuilderErrorInvalidProperty: the specified property is unknown for the
	// object class.
		BuilderErrorInvalidProperty BuilderError = 11
			// BuilderErrorInvalidSignal: the specified signal is unknown for the object
	// class.
		BuilderErrorInvalidSignal BuilderError = 12
			// BuilderErrorInvalidID: an object id is unknown.
		BuilderErrorInvalidID BuilderError = 13
			// BuilderErrorInvalidFunction: a function could not be found. This often
	// happens when symbols are set to be kept private. Compiling code with
	// -rdynamic or using the `gmodule-export-2.0` pkgconfig module can fix this
	// problem.
		BuilderErrorInvalidFunction BuilderError = 14
		)

	
	func marshalBuilderError(p uintptr) (interface{}, error) {
		return BuilderError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ButtonsType: prebuilt sets of buttons for `GtkDialog`.
// 
// If none of these choices are appropriate, simply use GTK_BUTTONS_NONE and
// call [method@Gtk.Dialog.add_buttons].
// 
// > Please note that GTK_BUTTONS_OK, GTK_BUTTONS_YES_NO > and
// GTK_BUTTONS_OK_CANCEL are discouraged by the > GNOME Human Interface
// Guidelines (http://library.gnome.org/devel/hig-book/stable/).
	type ButtonsType int

	const (
			// ButtonsTypeNone: no buttons at all
		ButtonsTypeNone ButtonsType = 0
			// ButtonsTypeOk: an OK button
		ButtonsTypeOk ButtonsType = 1
			// ButtonsTypeClose: a Close button
		ButtonsTypeClose ButtonsType = 2
			// ButtonsTypeCancel: a Cancel button
		ButtonsTypeCancel ButtonsType = 3
			// ButtonsTypeYesNo yes and No buttons
		ButtonsTypeYesNo ButtonsType = 4
			// ButtonsTypeOkCancel: OK and Cancel buttons
		ButtonsTypeOkCancel ButtonsType = 5
		)

	
	func marshalButtonsType(p uintptr) (interface{}, error) {
		return ButtonsType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CellRendererAccelMode determines if the edited accelerators are GTK
// accelerators. If they are, consumed modifiers are suppressed, only
// accelerators accepted by GTK are allowed, and the accelerators are rendered
// in the same way as they are in menus.
	type CellRendererAccelMode int

	const (
			// CellRendererAccelModeGTK: GTK accelerators mode
		CellRendererAccelModeGTK CellRendererAccelMode = 0
			// CellRendererAccelModeOther: other accelerator mode
		CellRendererAccelModeOther CellRendererAccelMode = 1
		)

	
	func marshalCellRendererAccelMode(p uintptr) (interface{}, error) {
		return CellRendererAccelMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CellRendererMode identifies how the user can interact with a particular cell.
	type CellRendererMode int

	const (
			// CellRendererModeInert: the cell is just for display and cannot be
	// interacted with. Note that this doesnt mean that eg. the row being drawn
	// cant be selected -- just that a particular element of it cannot be
	// individually modified.
		CellRendererModeInert CellRendererMode = 0
			// CellRendererModeActivatable: the cell can be clicked.
		CellRendererModeActivatable CellRendererMode = 1
			// CellRendererModeEditable: the cell can be edited or otherwise modified.
		CellRendererModeEditable CellRendererMode = 2
		)

	
	func marshalCellRendererMode(p uintptr) (interface{}, error) {
		return CellRendererMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ConstraintAttribute: the widget attributes that can be used when creating a
// `GtkConstraint`.
	type ConstraintAttribute int

	const (
			// ConstraintAttributeNone: no attribute, used for constant relations
		ConstraintAttributeNone ConstraintAttribute = 0
			// ConstraintAttributeLeft: the left edge of a widget, regardless of text
	// direction
		ConstraintAttributeLeft ConstraintAttribute = 1
			// ConstraintAttributeRight: the right edge of a widget, regardless of text
	// direction
		ConstraintAttributeRight ConstraintAttribute = 2
			// ConstraintAttributeTop: the top edge of a widget
		ConstraintAttributeTop ConstraintAttribute = 3
			// ConstraintAttributeBottom: the bottom edge of a widget
		ConstraintAttributeBottom ConstraintAttribute = 4
			// ConstraintAttributeStart: the leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones
		ConstraintAttributeStart ConstraintAttribute = 5
			// ConstraintAttributeEnd: the trailing edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones
		ConstraintAttributeEnd ConstraintAttribute = 6
			// ConstraintAttributeWidth: the width of a widget
		ConstraintAttributeWidth ConstraintAttribute = 7
			// ConstraintAttributeHeight: the height of a widget
		ConstraintAttributeHeight ConstraintAttribute = 8
			// ConstraintAttributeCenterX: the center of a widget, on the horizontal
	// axis
		ConstraintAttributeCenterX ConstraintAttribute = 9
			// ConstraintAttributeCenterY: the center of a widget, on the vertical axis
		ConstraintAttributeCenterY ConstraintAttribute = 10
			// ConstraintAttributeBaseline: the baseline of a widget
		ConstraintAttributeBaseline ConstraintAttribute = 11
		)

	
	func marshalConstraintAttribute(p uintptr) (interface{}, error) {
		return ConstraintAttribute(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ConstraintRelation: the relation between two terms of a constraint.
	type ConstraintRelation int

	const (
			// ConstraintRelationLe less than, or equal
		ConstraintRelationLe ConstraintRelation = -1
			// ConstraintRelationEq: equal
		ConstraintRelationEq ConstraintRelation = 0
			// ConstraintRelationGe: greater than, or equal
		ConstraintRelationGe ConstraintRelation = 1
		)

	
	func marshalConstraintRelation(p uintptr) (interface{}, error) {
		return ConstraintRelation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ConstraintStrength: the strength of a constraint, expressed as a symbolic
// constant.
// 
// The strength of a Constraint can be expressed with any positive integer; the
// values of this enumeration can be used for readability.
	type ConstraintStrength int

	const (
			// ConstraintStrengthRequired: the constraint is required towards solving
	// the layout
		ConstraintStrengthRequired ConstraintStrength = 1001001000
			// ConstraintStrengthStrong: a strong constraint
		ConstraintStrengthStrong ConstraintStrength = 1000000000
			// ConstraintStrengthMedium: a medium constraint
		ConstraintStrengthMedium ConstraintStrength = 1000
			// ConstraintStrengthWeak: a weak constraint
		ConstraintStrengthWeak ConstraintStrength = 1
		)

	
	func marshalConstraintStrength(p uintptr) (interface{}, error) {
		return ConstraintStrength(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ConstraintVflParserError: domain for VFL parsing errors.
	type ConstraintVflParserError int

	const (
			// ConstraintVflParserErrorSymbol: invalid or unknown symbol
		ConstraintVflParserErrorSymbol ConstraintVflParserError = 0
			// ConstraintVflParserErrorAttribute: invalid or unknown attribute
		ConstraintVflParserErrorAttribute ConstraintVflParserError = 1
			// ConstraintVflParserErrorView: invalid or unknown view
		ConstraintVflParserErrorView ConstraintVflParserError = 2
			// ConstraintVflParserErrorMetric: invalid or unknown metric
		ConstraintVflParserErrorMetric ConstraintVflParserError = 3
			// ConstraintVflParserErrorPriority: invalid or unknown priority
		ConstraintVflParserErrorPriority ConstraintVflParserError = 4
			// ConstraintVflParserErrorRelation: invalid or unknown relation
		ConstraintVflParserErrorRelation ConstraintVflParserError = 5
		)

	
	func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
		return ConstraintVflParserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CornerType specifies which corner a child widget should be placed in when
// packed into a `GtkScrolledWindow.`
// 
// This is effectively the opposite of where the scroll bars are placed.
	type CornerType int

	const (
			// CornerTypeTopLeft: place the scrollbars on the right and bottom of the
	// widget (default behaviour).
		CornerTypeTopLeft CornerType = 0
			// CornerTypeBottomLeft: place the scrollbars on the top and right of the
	// widget.
		CornerTypeBottomLeft CornerType = 1
			// CornerTypeTopRight: place the scrollbars on the left and bottom of the
	// widget.
		CornerTypeTopRight CornerType = 2
			// CornerTypeBottomRight: place the scrollbars on the top and left of the
	// widget.
		CornerTypeBottomRight CornerType = 3
		)

	
	func marshalCornerType(p uintptr) (interface{}, error) {
		return CornerType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CSSParserError errors that can occur while parsing CSS.
// 
// These errors are unexpected and will cause parts of the given CSS to be
// ignored.
	type CSSParserError int

	const (
			// CSSParserErrorFailed: unknown failure.
		CSSParserErrorFailed CSSParserError = 0
			// CSSParserErrorSyntax: the given text does not form valid syntax
		CSSParserErrorSyntax CSSParserError = 1
			// CSSParserErrorImport: failed to import a resource
		CSSParserErrorImport CSSParserError = 2
			// CSSParserErrorName: the given name has not been defined
		CSSParserErrorName CSSParserError = 3
			// CSSParserErrorUnknownValue: the given value is not correct
		CSSParserErrorUnknownValue CSSParserError = 4
		)

	


	

	// CSSParserWarning warnings that can occur while parsing CSS.
// 
// Unlike CssParserErrors, warnings do not cause the parser to skip any input,
// but they indicate issues that should be fixed.
	type CSSParserWarning int

	const (
			// CSSParserWarningDeprecated: the given construct is deprecated and will be
	// removed in a future version
		CSSParserWarningDeprecated CSSParserWarning = 0
			// CSSParserWarningSyntax: a syntax construct was used that should be
	// avoided
		CSSParserWarningSyntax CSSParserWarning = 1
			// CSSParserWarningUnimplemented: a feature is not implemented
		CSSParserWarningUnimplemented CSSParserWarning = 2
		)

	


	

	// DeleteType: passed to various keybinding signals for deleting text.
	type DeleteType int

	const (
			// DeleteTypeChars: delete characters.
		DeleteTypeChars DeleteType = 0
			// DeleteTypeWordEnds: delete only the portion of the word to the left/right
	// of cursor if were in the middle of a word.
		DeleteTypeWordEnds DeleteType = 1
			// DeleteTypeWords: delete words.
		DeleteTypeWords DeleteType = 2
			// DeleteTypeDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
		DeleteTypeDisplayLines DeleteType = 3
			// DeleteTypeDisplayLineEnds: delete only the portion of the display-line to
	// the left/right of cursor.
		DeleteTypeDisplayLineEnds DeleteType = 4
			// DeleteTypeParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
		DeleteTypeParagraphEnds DeleteType = 5
			// DeleteTypeParagraphs: delete entire line. Like C-k in pico.
		DeleteTypeParagraphs DeleteType = 6
			// DeleteTypeWhitespace: delete only whitespace. Like M-\ in Emacs.
		DeleteTypeWhitespace DeleteType = 7
		)

	
	func marshalDeleteType(p uintptr) (interface{}, error) {
		return DeleteType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DirectionType focus movement types.
	type DirectionType int

	const (
			// DirectionTypeTabForward: move forward.
		DirectionTypeTabForward DirectionType = 0
			// DirectionTypeTabBackward: move backward.
		DirectionTypeTabBackward DirectionType = 1
			// DirectionTypeUp: move up.
		DirectionTypeUp DirectionType = 2
			// DirectionTypeDown: move down.
		DirectionTypeDown DirectionType = 3
			// DirectionTypeLeft: move left.
		DirectionTypeLeft DirectionType = 4
			// DirectionTypeRight: move right.
		DirectionTypeRight DirectionType = 5
		)

	
	func marshalDirectionType(p uintptr) (interface{}, error) {
		return DirectionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	
	type EditableProperties int

	const (
		EditablePropertiesPropText EditableProperties = 0
		EditablePropertiesPropCursorPosition EditableProperties = 1
		EditablePropertiesPropSelectionBound EditableProperties = 2
		EditablePropertiesPropEditable EditableProperties = 3
		EditablePropertiesPropWidthChars EditableProperties = 4
		EditablePropertiesPropMaxWidthChars EditableProperties = 5
		EditablePropertiesPropXalign EditableProperties = 6
		EditablePropertiesPropEnableUndo EditableProperties = 7
		EditablePropertiesNumProperties EditableProperties = 8
		)

	
	func marshalEditableProperties(p uintptr) (interface{}, error) {
		return EditableProperties(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// EntryIconPosition specifies the side of the entry at which an icon is placed.
	type EntryIconPosition int

	const (
			// EntryIconPositionPrimary: at the beginning of the entry (depending on the
	// text direction).
		EntryIconPositionPrimary EntryIconPosition = 0
			// EntryIconPositionSecondary: at the end of the entry (depending on the
	// text direction).
		EntryIconPositionSecondary EntryIconPosition = 1
		)

	
	func marshalEntryIconPosition(p uintptr) (interface{}, error) {
		return EntryIconPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// EventSequenceState describes the state of a `GdkEventSequence` in a
// `GtkGesture`.
	type EventSequenceState int

	const (
			// EventSequenceStateNone: the sequence is handled, but not grabbed.
		EventSequenceStateNone EventSequenceState = 0
			// EventSequenceStateClaimed: the sequence is handled and grabbed.
		EventSequenceStateClaimed EventSequenceState = 1
			// EventSequenceStateDenied: the sequence is denied.
		EventSequenceStateDenied EventSequenceState = 2
		)

	
	func marshalEventSequenceState(p uintptr) (interface{}, error) {
		return EventSequenceState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileChooserAction describes whether a `GtkFileChooser` is being used to open
// existing files or to save to a possibly new file.
	type FileChooserAction int

	const (
			// FileChooserActionOpen indicates open mode. The file chooser will only let
	// the user pick an existing file.
		FileChooserActionOpen FileChooserAction = 0
			// FileChooserActionSave indicates save mode. The file chooser will let the
	// user pick an existing file, or type in a new filename.
		FileChooserActionSave FileChooserAction = 1
			// FileChooserActionSelectFolder indicates an Open mode for selecting
	// folders. The file chooser will let the user pick an existing folder.
		FileChooserActionSelectFolder FileChooserAction = 2
		)

	
	func marshalFileChooserAction(p uintptr) (interface{}, error) {
		return FileChooserAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FileChooserError: these identify the various errors that can occur while
// calling `GtkFileChooser` functions.
	type FileChooserError int

	const (
			// FileChooserErrorNonexistent indicates that a file does not exist.
		FileChooserErrorNonexistent FileChooserError = 0
			// FileChooserErrorBadFilename indicates a malformed filename.
		FileChooserErrorBadFilename FileChooserError = 1
			// FileChooserErrorAlreadyExists indicates a duplicate path (e.g. when
	// adding a bookmark).
		FileChooserErrorAlreadyExists FileChooserError = 2
			// FileChooserErrorIncompleteHostname indicates an incomplete hostname (e.g.
	// "http://foo" without a slash after that).
		FileChooserErrorIncompleteHostname FileChooserError = 3
		)

	
	func marshalFileChooserError(p uintptr) (interface{}, error) {
		return FileChooserError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FilterChange describes changes in a filter in more detail and allows objects
// using the filter to optimize refiltering items.
// 
// If you are writing an implementation and are not sure which value to pass,
// GTK_FILTER_CHANGE_DIFFERENT is always a correct choice.
	type FilterChange int

	const (
			// FilterChangeDifferent: the filter change cannot be described with any of
	// the other enumeration values.
		FilterChangeDifferent FilterChange = 0
			// FilterChangeLessStrict: the filter is less strict than it was before: All
	// items that it used to return true for still return true, others now may,
	// too.
		FilterChangeLessStrict FilterChange = 1
			// FilterChangeMoreStrict: the filter is more strict than it was before: All
	// items that it used to return false for still return false, others now
	// may, too.
		FilterChangeMoreStrict FilterChange = 2
		)

	
	func marshalFilterChange(p uintptr) (interface{}, error) {
		return FilterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FilterMatch describes the known strictness of a filter.
// 
// Note that for filters where the strictness is not known,
// GTK_FILTER_MATCH_SOME is always an acceptable value, even if a filter does
// match all or no items.
	type FilterMatch int

	const (
			// FilterMatchSome: the filter matches some items, gtk_filter_match() may
	// return true or false
		FilterMatchSome FilterMatch = 0
			// FilterMatchNone: the filter does not match any item, gtk_filter_match()
	// will always return false.
		FilterMatchNone FilterMatch = 1
			// FilterMatchAll: the filter matches all items, gtk_filter_match() will
	// alays return true.
		FilterMatchAll FilterMatch = 2
		)

	
	func marshalFilterMatch(p uintptr) (interface{}, error) {
		return FilterMatch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconSize: built-in icon sizes.
// 
// Icon sizes default to being inherited. Where they cannot be inherited, text
// size is the default.
// 
// All widgets which use `GtkIconSize` set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the `-gtk-icon-size` CSS property.
	type IconSize int

	const (
			// IconSizeInherit: keep the size of the parent element
		IconSizeInherit IconSize = 0
			// IconSizeNormal: size similar to text size
		IconSizeNormal IconSize = 1
			// IconSizeLarge: large size, for example in an icon view
		IconSizeLarge IconSize = 2
		)

	
	func marshalIconSize(p uintptr) (interface{}, error) {
		return IconSize(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconThemeError: error codes for `GtkIconTheme` operations.
	type IconThemeError int

	const (
			// IconThemeErrorNotFound: the icon specified does not exist in the theme
		IconThemeErrorNotFound IconThemeError = 0
			// IconThemeErrorFailed: an unspecified error occurred.
		IconThemeErrorFailed IconThemeError = 1
		)

	
	func marshalIconThemeError(p uintptr) (interface{}, error) {
		return IconThemeError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconViewDropPosition: an enum for determining where a dropped item goes.
	type IconViewDropPosition int

	const (
			// IconViewDropPositionNoDrop: no drop possible
		IconViewDropPositionNoDrop IconViewDropPosition = 0
			// IconViewDropPositionDropInto: dropped item replaces the item
		IconViewDropPositionDropInto IconViewDropPosition = 1
			// IconViewDropPositionDropLeft: dropped item is inserted to the left
		IconViewDropPositionDropLeft IconViewDropPosition = 2
			// IconViewDropPositionDropRight: dropped item is inserted to the right
		IconViewDropPositionDropRight IconViewDropPosition = 3
			// IconViewDropPositionDropAbove: dropped item is inserted above
		IconViewDropPositionDropAbove IconViewDropPosition = 4
			// IconViewDropPositionDropBelow: dropped item is inserted below
		IconViewDropPositionDropBelow IconViewDropPosition = 5
		)

	
	func marshalIconViewDropPosition(p uintptr) (interface{}, error) {
		return IconViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ImageType describes the image data representation used by a
// [class@Gtk.Image].
// 
// If you want to get the image from the widget, you can only get the
// currently-stored representation; for instance, if the
// gtk_image_get_storage_type() returns GTK_IMAGE_PAINTABLE, then you can call
// gtk_image_get_paintable().
// 
// For empty images, you can request any storage type (call any of the "get"
// functions), but they will all return nil values.
	type ImageType int

	const (
			// ImageTypeEmpty: there is no image displayed by the widget
		ImageTypeEmpty ImageType = 0
			// ImageTypeIconName: the widget contains a named icon
		ImageTypeIconName ImageType = 1
			// ImageTypeGIcon: the widget contains a #GIcon
		ImageTypeGIcon ImageType = 2
			// ImageTypePaintable: the widget contains a Paintable
		ImageTypePaintable ImageType = 3
		)

	
	func marshalImageType(p uintptr) (interface{}, error) {
		return ImageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// InputPurpose describes primary purpose of the input widget.
// 
// This information is useful for on-screen keyboards and similar input methods
// to decide which keys should be presented to the user.
// 
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
// 
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and e or E as in 3.14E+000.
// 
// This enumeration may be extended in the future; input methods should
// interpret unknown values as free form.
	type InputPurpose int

	const (
			// InputPurposeFreeForm: allow any character
		InputPurposeFreeForm InputPurpose = 0
			// InputPurposeAlpha: allow only alphabetic characters
		InputPurposeAlpha InputPurpose = 1
			// InputPurposeDigits: allow only digits
		InputPurposeDigits InputPurpose = 2
			// InputPurposeNumber: edited field expects numbers
		InputPurposeNumber InputPurpose = 3
			// InputPurposePhone: edited field expects phone number
		InputPurposePhone InputPurpose = 4
			// InputPurposeURL: edited field expects URL
		InputPurposeURL InputPurpose = 5
			// InputPurposeEmail: edited field expects email address
		InputPurposeEmail InputPurpose = 6
			// InputPurposeName: edited field expects the name of a person
		InputPurposeName InputPurpose = 7
			// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden
		InputPurposePassword InputPurpose = 8
			// InputPurposePin: like GTK_INPUT_PURPOSE_DIGITS, but characters are hidden
		InputPurposePin InputPurpose = 9
			// InputPurposeTerminal: allow any character, in addition to control codes
		InputPurposeTerminal InputPurpose = 10
		)

	
	func marshalInputPurpose(p uintptr) (interface{}, error) {
		return InputPurpose(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Justification: used for justifying the text inside a `GtkLabel` widget.
	type Justification int

	const (
			// JustificationLeft: the text is placed at the left edge of the label.
		JustificationLeft Justification = 0
			// JustificationRight: the text is placed at the right edge of the label.
		JustificationRight Justification = 1
			// JustificationCenter: the text is placed in the center of the label.
		JustificationCenter Justification = 2
			// JustificationFill: the text is placed is distributed across the label.
		JustificationFill Justification = 3
		)

	
	func marshalJustification(p uintptr) (interface{}, error) {
		return Justification(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// LevelBarMode describes how `GtkLevelBar` contents should be rendered.
// 
// Note that this enumeration could be extended with additional modes in the
// future.
	type LevelBarMode int

	const (
			// LevelBarModeContinuous: the bar has a continuous mode
		LevelBarModeContinuous LevelBarMode = 0
			// LevelBarModeDiscrete: the bar has a discrete mode
		LevelBarModeDiscrete LevelBarMode = 1
		)

	
	func marshalLevelBarMode(p uintptr) (interface{}, error) {
		return LevelBarMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// License: the type of license for an application.
// 
// This enumeration can be expanded at later date.
	type License int

	const (
			// LicenseUnknown: no license specified
		LicenseUnknown License = 0
			// LicenseCustom: a license text is going to be specified by the developer
		LicenseCustom License = 1
			// LicenseGPL20: the GNU General Public License, version 2.0 or later
		LicenseGPL20 License = 2
			// LicenseGPL30: the GNU General Public License, version 3.0 or later
		LicenseGPL30 License = 3
			// LicenseLGPL21: the GNU Lesser General Public License, version 2.1 or
	// later
		LicenseLGPL21 License = 4
			// LicenseLGPL30: the GNU Lesser General Public License, version 3.0 or
	// later
		LicenseLGPL30 License = 5
			// LicenseBSD: the BSD standard license
		LicenseBSD License = 6
			// LicenseMITX11: the MIT/X11 standard license
		LicenseMITX11 License = 7
			// LicenseArtistic: the Artistic License, version 2.0
		LicenseArtistic License = 8
			// LicenseGPL20Only: the GNU General Public License, version 2.0 only
		LicenseGPL20Only License = 9
			// LicenseGPL30Only: the GNU General Public License, version 3.0 only
		LicenseGPL30Only License = 10
			// LicenseLGPL21Only: the GNU Lesser General Public License, version 2.1
	// only
		LicenseLGPL21Only License = 11
			// LicenseLGPL30Only: the GNU Lesser General Public License, version 3.0
	// only
		LicenseLGPL30Only License = 12
			// LicenseAGPL30: the GNU Affero General Public License, version 3.0 or
	// later
		LicenseAGPL30 License = 13
			// LicenseAGPL30Only: the GNU Affero General Public License, version 3.0
	// only
		LicenseAGPL30Only License = 14
			// LicenseBSD3: the 3-clause BSD licence
		LicenseBSD3 License = 15
			// LicenseApache20: the Apache License, version 2.0
		LicenseApache20 License = 16
			// LicenseMPL20: the Mozilla Public License, version 2.0
		LicenseMPL20 License = 17
		)

	
	func marshalLicense(p uintptr) (interface{}, error) {
		return License(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MessageType: the type of message being displayed in a `GtkMessageDialog`.
	type MessageType int

	const (
			// MessageTypeInfo: informational message
		MessageTypeInfo MessageType = 0
			// MessageTypeWarning: non-fatal warning message
		MessageTypeWarning MessageType = 1
			// MessageTypeQuestion: question requiring a choice
		MessageTypeQuestion MessageType = 2
			// MessageTypeError: fatal error message
		MessageTypeError MessageType = 3
			// MessageTypeOther: none of the above
		MessageTypeOther MessageType = 4
		)

	
	func marshalMessageType(p uintptr) (interface{}, error) {
		return MessageType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// MovementStep: passed as argument to various keybinding signals for moving the
// cursor position.
	type MovementStep int

	const (
			// MovementStepLogicalPositions: move forward or back by graphemes
		MovementStepLogicalPositions MovementStep = 0
			// MovementStepVisualPositions: move left or right by graphemes
		MovementStepVisualPositions MovementStep = 1
			// MovementStepWords: move forward or back by words
		MovementStepWords MovementStep = 2
			// MovementStepDisplayLines: move up or down lines (wrapped lines)
		MovementStepDisplayLines MovementStep = 3
			// MovementStepDisplayLineEnds: move to either end of a line
		MovementStepDisplayLineEnds MovementStep = 4
			// MovementStepParagraphs: move up or down paragraphs (newline-ended lines)
		MovementStepParagraphs MovementStep = 5
			// MovementStepParagraphEnds: move to either end of a paragraph
		MovementStepParagraphEnds MovementStep = 6
			// MovementStepPages: move by pages
		MovementStepPages MovementStep = 7
			// MovementStepBufferEnds: move to ends of the buffer
		MovementStepBufferEnds MovementStep = 8
			// MovementStepHorizontalPages: move horizontally by pages
		MovementStepHorizontalPages MovementStep = 9
		)

	
	func marshalMovementStep(p uintptr) (interface{}, error) {
		return MovementStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// NotebookTab: the parameter used in the action signals of `GtkNotebook`.
	type NotebookTab int

	const (
			// NotebookTabFirst: the first tab in the notebook
		NotebookTabFirst NotebookTab = 0
			// NotebookTabLast: the last tab in the notebook
		NotebookTabLast NotebookTab = 1
		)

	
	func marshalNotebookTab(p uintptr) (interface{}, error) {
		return NotebookTab(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
	type NumberUpLayout int

	const (
			// NumberUpLayoutLrtb: ! (layout-lrtb.png)
		NumberUpLayoutLrtb NumberUpLayout = 0
			// NumberUpLayoutLrbt: ! (layout-lrbt.png)
		NumberUpLayoutLrbt NumberUpLayout = 1
			// NumberUpLayoutRltb: ! (layout-rltb.png)
		NumberUpLayoutRltb NumberUpLayout = 2
			// NumberUpLayoutRlbt: ! (layout-rlbt.png)
		NumberUpLayoutRlbt NumberUpLayout = 3
			// NumberUpLayoutTblr: ! (layout-tblr.png)
		NumberUpLayoutTblr NumberUpLayout = 4
			// NumberUpLayoutTbrl: ! (layout-tbrl.png)
		NumberUpLayoutTbrl NumberUpLayout = 5
			// NumberUpLayoutBtlr: ! (layout-btlr.png)
		NumberUpLayoutBtlr NumberUpLayout = 6
			// NumberUpLayoutBtrl: ! (layout-btrl.png)
		NumberUpLayoutBtrl NumberUpLayout = 7
		)

	
	func marshalNumberUpLayout(p uintptr) (interface{}, error) {
		return NumberUpLayout(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Ordering describes the way two values can be compared.
// 
// These values can be used with a `GCompareFunc`. However, a `GCompareFunc` is
// allowed to return any integer values. For converting such a value to a
// `GtkOrdering` value, use [func@Gtk.Ordering.from_cmpfunc].
	type Ordering int

	const (
			// OrderingSmaller: the first value is smaller than the second
		OrderingSmaller Ordering = -1
			// OrderingEqual: the two values are equal
		OrderingEqual Ordering = 0
			// OrderingLarger: the first value is larger than the second
		OrderingLarger Ordering = 1
		)

	
	func marshalOrdering(p uintptr) (interface{}, error) {
		return Ordering(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Orientation represents the orientation of widgets and other objects.
// 
// Typical examples are `GtkBox or `GtkGesturePan`.
	type Orientation int

	const (
			// OrientationHorizontal: the element is in horizontal orientation.
		OrientationHorizontal Orientation = 0
			// OrientationVertical: the element is in vertical orientation.
		OrientationVertical Orientation = 1
		)

	
	func marshalOrientation(p uintptr) (interface{}, error) {
		return Orientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Overflow defines how content overflowing a given area should be handled.
// 
// This is used in [method@Gtk.Widget.set_overflow]. The
// [property@Gtk.Widget:overflow] property is modeled after the CSS overflow
// property, but implements it only partially.
	type Overflow int

	const (
			// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
		OverflowVisible Overflow = 0
			// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
		OverflowHidden Overflow = 1
		)

	
	func marshalOverflow(p uintptr) (interface{}, error) {
		return Overflow(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PackType represents the packing location of a children in its parent.
// 
// See `GtkWindowControls` for example.
	type PackType int

	const (
			// PackTypeStart: the child is packed into the start of the widget
		PackTypeStart PackType = 0
			// PackTypeEnd: the child is packed into the end of the widget
		PackTypeEnd PackType = 1
		)

	
	func marshalPackType(p uintptr) (interface{}, error) {
		return PackType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PadActionType: the type of a pad action.
	type PadActionType int

	const (
			// PadActionTypeButton: action is triggered by a pad button
		PadActionTypeButton PadActionType = 0
			// PadActionTypeRing: action is triggered by a pad ring
		PadActionTypeRing PadActionType = 1
			// PadActionTypeStrip: action is triggered by a pad strip
		PadActionTypeStrip PadActionType = 2
		)

	
	func marshalPadActionType(p uintptr) (interface{}, error) {
		return PadActionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PageOrientation: see also gtk_print_settings_set_orientation().
	type PageOrientation int

	const (
			// PageOrientationPortrait: portrait mode.
		PageOrientationPortrait PageOrientation = 0
			// PageOrientationLandscape: landscape mode.
		PageOrientationLandscape PageOrientation = 1
			// PageOrientationReversePortrait: reverse portrait mode.
		PageOrientationReversePortrait PageOrientation = 2
			// PageOrientationReverseLandscape: reverse landscape mode.
		PageOrientationReverseLandscape PageOrientation = 3
		)

	
	func marshalPageOrientation(p uintptr) (interface{}, error) {
		return PageOrientation(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PageSet: see also gtk_print_job_set_page_set().
	type PageSet int

	const (
			// PageSetAll: all pages.
		PageSetAll PageSet = 0
			// PageSetEven: even pages.
		PageSetEven PageSet = 1
			// PageSetOdd: odd pages.
		PageSetOdd PageSet = 2
		)

	
	func marshalPageSet(p uintptr) (interface{}, error) {
		return PageSet(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PanDirection describes the panning direction of a `GtkGesturePan`
	type PanDirection int

	const (
			// PanDirectionLeft: panned towards the left
		PanDirectionLeft PanDirection = 0
			// PanDirectionRight: panned towards the right
		PanDirectionRight PanDirection = 1
			// PanDirectionUp: panned upwards
		PanDirectionUp PanDirection = 2
			// PanDirectionDown: panned downwards
		PanDirectionDown PanDirection = 3
		)

	
	func marshalPanDirection(p uintptr) (interface{}, error) {
		return PanDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PolicyType determines how the size should be computed to achieve the one of
// the visibility mode for the scrollbars.
	type PolicyType int

	const (
			// PolicyTypeAlways: the scrollbar is always visible. The view size is
	// independent of the content.
		PolicyTypeAlways PolicyType = 0
			// PolicyTypeAutomatic: the scrollbar will appear and disappear as
	// necessary. For example, when all of a `GtkTreeView` can not be seen.
		PolicyTypeAutomatic PolicyType = 1
			// PolicyTypeNever: the scrollbar should never appear. In this mode the
	// content determines the size.
		PolicyTypeNever PolicyType = 2
			// PolicyTypeExternal: don't show a scrollbar, but don't force the size to
	// follow the content. This can be used e.g. to make multiple scrolled
	// windows share a scrollbar.
		PolicyTypeExternal PolicyType = 3
		)

	
	func marshalPolicyType(p uintptr) (interface{}, error) {
		return PolicyType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PositionType describes which edge of a widget a certain feature is positioned
// at.
// 
// For examples, see the tabs of a `GtkNotebook`, or the label of a `GtkScale`.
	type PositionType int

	const (
			// PositionTypeLeft: the feature is at the left edge.
		PositionTypeLeft PositionType = 0
			// PositionTypeRight: the feature is at the right edge.
		PositionTypeRight PositionType = 1
			// PositionTypeTop: the feature is at the top edge.
		PositionTypeTop PositionType = 2
			// PositionTypeBottom: the feature is at the bottom edge.
		PositionTypeBottom PositionType = 3
		)

	
	func marshalPositionType(p uintptr) (interface{}, error) {
		return PositionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintDuplex: see also gtk_print_settings_set_duplex().
	type PrintDuplex int

	const (
			// PrintDuplexSimplex: no duplex.
		PrintDuplexSimplex PrintDuplex = 0
			// PrintDuplexHorizontal: horizontal duplex.
		PrintDuplexHorizontal PrintDuplex = 1
			// PrintDuplexVertical: vertical duplex.
		PrintDuplexVertical PrintDuplex = 2
		)

	
	func marshalPrintDuplex(p uintptr) (interface{}, error) {
		return PrintDuplex(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintError: error codes that identify various errors that can occur while
// using the GTK printing support.
	type PrintError int

	const (
			// PrintErrorGeneral: an unspecified error occurred.
		PrintErrorGeneral PrintError = 0
			// PrintErrorInternalError: an internal error occurred.
		PrintErrorInternalError PrintError = 1
			// PrintErrorNOMEM: a memory allocation failed.
		PrintErrorNOMEM PrintError = 2
			// PrintErrorInvalidFile: an error occurred while loading a page setup or
	// paper size from a key file.
		PrintErrorInvalidFile PrintError = 3
		)

	
	func marshalPrintError(p uintptr) (interface{}, error) {
		return PrintError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintOperationAction determines what action the print operation should
// perform.
// 
// A parameter of this typs is passed to [method@Gtk.PrintOperation.run].
	type PrintOperationAction int

	const (
			// PrintOperationActionPrintDialog: show the print dialog.
		PrintOperationActionPrintDialog PrintOperationAction = 0
			// PrintOperationActionPrint: start to print without showing the print
	// dialog, based on the current print settings.
		PrintOperationActionPrint PrintOperationAction = 1
			// PrintOperationActionPreview: show the print preview.
		PrintOperationActionPreview PrintOperationAction = 2
			// PrintOperationActionExport: export to a file. This requires the
	// export-filename property to be set.
		PrintOperationActionExport PrintOperationAction = 3
		)

	
	func marshalPrintOperationAction(p uintptr) (interface{}, error) {
		return PrintOperationAction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintOperationResult: the result of a print operation.
// 
// A value of this type is returned by [method@Gtk.PrintOperation.run].
	type PrintOperationResult int

	const (
			// PrintOperationResultError: an error has occurred.
		PrintOperationResultError PrintOperationResult = 0
			// PrintOperationResultApply: the print settings should be stored.
		PrintOperationResultApply PrintOperationResult = 1
			// PrintOperationResultCancel: the print operation has been canceled, the
	// print settings should not be stored.
		PrintOperationResultCancel PrintOperationResult = 2
			// PrintOperationResultInProgress: the print operation is not complete yet.
	// This value will only be returned when running asynchronously.
		PrintOperationResultInProgress PrintOperationResult = 3
		)

	
	func marshalPrintOperationResult(p uintptr) (interface{}, error) {
		return PrintOperationResult(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintPages: see also gtk_print_job_set_pages()
	type PrintPages int

	const (
			// PrintPagesAll: all pages.
		PrintPagesAll PrintPages = 0
			// PrintPagesCurrent: current page.
		PrintPagesCurrent PrintPages = 1
			// PrintPagesRanges: range of pages.
		PrintPagesRanges PrintPages = 2
			// PrintPagesSelection: selected pages.
		PrintPagesSelection PrintPages = 3
		)

	
	func marshalPrintPages(p uintptr) (interface{}, error) {
		return PrintPages(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintQuality: see also gtk_print_settings_set_quality().
	type PrintQuality int

	const (
			// PrintQualityLow: low quality.
		PrintQualityLow PrintQuality = 0
			// PrintQualityNormal: normal quality.
		PrintQualityNormal PrintQuality = 1
			// PrintQualityHigh: high quality.
		PrintQualityHigh PrintQuality = 2
			// PrintQualityDraft: draft quality.
		PrintQualityDraft PrintQuality = 3
		)

	
	func marshalPrintQuality(p uintptr) (interface{}, error) {
		return PrintQuality(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintStatus: the status gives a rough indication of the completion of a
// running print operation.
	type PrintStatus int

	const (
			// PrintStatusInitial: the printing has not started yet; this status is set
	// initially, and while the print dialog is shown.
		PrintStatusInitial PrintStatus = 0
			// PrintStatusPreparing: this status is set while the begin-print signal is
	// emitted and during pagination.
		PrintStatusPreparing PrintStatus = 1
			// PrintStatusGeneratingData: this status is set while the pages are being
	// rendered.
		PrintStatusGeneratingData PrintStatus = 2
			// PrintStatusSendingData: the print job is being sent off to the printer.
		PrintStatusSendingData PrintStatus = 3
			// PrintStatusPending: the print job has been sent to the printer, but is
	// not printed for some reason, e.g. the printer may be stopped.
		PrintStatusPending PrintStatus = 4
			// PrintStatusPendingIssue: some problem has occurred during printing, e.g.
	// a paper jam.
		PrintStatusPendingIssue PrintStatus = 5
			// PrintStatusPrinting: the printer is processing the print job.
		PrintStatusPrinting PrintStatus = 6
			// PrintStatusFinished: the printing has been completed successfully.
		PrintStatusFinished PrintStatus = 7
			// PrintStatusFinishedAborted: the printing has been aborted.
		PrintStatusFinishedAborted PrintStatus = 8
		)

	
	func marshalPrintStatus(p uintptr) (interface{}, error) {
		return PrintStatus(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PropagationLimit describes limits of a `GtkEventController` for handling
// events targeting other widgets.
	type PropagationLimit int

	const (
			// PropagationLimitNone events are handled regardless of what their target
	// is.
		PropagationLimitNone PropagationLimit = 0
			// PropagationLimitSameNative events are only handled if their target is in
	// the same Native as the event controllers widget. Note that some event
	// types have two targets (origin and destination).
		PropagationLimitSameNative PropagationLimit = 1
		)

	
	func marshalPropagationLimit(p uintptr) (interface{}, error) {
		return PropagationLimit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PropagationPhase describes the stage at which events are fed into a
// `GtkEventController`.
	type PropagationPhase int

	const (
			// PropagationPhaseNone events are not delivered.
		PropagationPhaseNone PropagationPhase = 0
			// PropagationPhaseCapture events are delivered in the capture phase. The
	// capture phase happens before the bubble phase, runs from the toplevel
	// down to the event widget. This option should only be used on containers
	// that might possibly handle events before their children do.
		PropagationPhaseCapture PropagationPhase = 1
			// PropagationPhaseBubble events are delivered in the bubble phase. The
	// bubble phase happens after the capture phase, and before the default
	// handlers are run. This phase runs from the event widget, up to the
	// toplevel.
		PropagationPhaseBubble PropagationPhase = 2
			// PropagationPhaseTarget events are delivered in the default widget event
	// handlers, note that widget implementations must chain up on button,
	// motion, touch and grab broken handlers for controllers in this phase to
	// be run.
		PropagationPhaseTarget PropagationPhase = 3
		)

	
	func marshalPropagationPhase(p uintptr) (interface{}, error) {
		return PropagationPhase(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RecentManagerError: error codes for RecentManager operations
	type RecentManagerError int

	const (
			// RecentManagerErrorNotFound: the URI specified does not exists in the
	// recently used resources list.
		RecentManagerErrorNotFound RecentManagerError = 0
			// RecentManagerErrorInvalidURI: the URI specified is not valid.
		RecentManagerErrorInvalidURI RecentManagerError = 1
			// RecentManagerErrorInvalidEncoding: the supplied string is not UTF-8
	// encoded.
		RecentManagerErrorInvalidEncoding RecentManagerError = 2
			// RecentManagerErrorNotRegistered: no application has registered the
	// specified item.
		RecentManagerErrorNotRegistered RecentManagerError = 3
			// RecentManagerErrorRead: failure while reading the recently used resources
	// file.
		RecentManagerErrorRead RecentManagerError = 4
			// RecentManagerErrorWrite: failure while writing the recently used
	// resources file.
		RecentManagerErrorWrite RecentManagerError = 5
			// RecentManagerErrorUnknown: unspecified error.
		RecentManagerErrorUnknown RecentManagerError = 6
		)

	
	func marshalRecentManagerError(p uintptr) (interface{}, error) {
		return RecentManagerError(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ResponseType: predefined values for use as response ids in
// gtk_dialog_add_button().
// 
// All predefined values are negative; GTK leaves values of 0 or greater for
// application-defined response ids.
	type ResponseType int

	const (
			// ResponseTypeNone: returned if an action widget has no response id, or if
	// the dialog gets programmatically hidden or destroyed
		ResponseTypeNone ResponseType = -1
			// ResponseTypeReject: generic response id, not used by GTK dialogs
		ResponseTypeReject ResponseType = -2
			// ResponseTypeAccept: generic response id, not used by GTK dialogs
		ResponseTypeAccept ResponseType = -3
			// ResponseTypeDeleteEvent: returned if the dialog is deleted
		ResponseTypeDeleteEvent ResponseType = -4
			// ResponseTypeOk: returned by OK buttons in GTK dialogs
		ResponseTypeOk ResponseType = -5
			// ResponseTypeCancel: returned by Cancel buttons in GTK dialogs
		ResponseTypeCancel ResponseType = -6
			// ResponseTypeClose: returned by Close buttons in GTK dialogs
		ResponseTypeClose ResponseType = -7
			// ResponseTypeYes: returned by Yes buttons in GTK dialogs
		ResponseTypeYes ResponseType = -8
			// ResponseTypeNo: returned by No buttons in GTK dialogs
		ResponseTypeNo ResponseType = -9
			// ResponseTypeApply: returned by Apply buttons in GTK dialogs
		ResponseTypeApply ResponseType = -10
			// ResponseTypeHelp: returned by Help buttons in GTK dialogs
		ResponseTypeHelp ResponseType = -11
		)

	
	func marshalResponseType(p uintptr) (interface{}, error) {
		return ResponseType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// RevealerTransitionType: these enumeration values describe the possible
// transitions when the child of a `GtkRevealer` widget is shown or hidden.
	type RevealerTransitionType int

	const (
			// RevealerTransitionTypeNone: no transition
		RevealerTransitionTypeNone RevealerTransitionType = 0
			// RevealerTransitionTypeCrossfade: fade in
		RevealerTransitionTypeCrossfade RevealerTransitionType = 1
			// RevealerTransitionTypeSlideRight: slide in from the left
		RevealerTransitionTypeSlideRight RevealerTransitionType = 2
			// RevealerTransitionTypeSlideLeft: slide in from the right
		RevealerTransitionTypeSlideLeft RevealerTransitionType = 3
			// RevealerTransitionTypeSlideUp: slide in from the bottom
		RevealerTransitionTypeSlideUp RevealerTransitionType = 4
			// RevealerTransitionTypeSlideDown: slide in from the top
		RevealerTransitionTypeSlideDown RevealerTransitionType = 5
			// RevealerTransitionTypeSwingRight: floop in from the left
		RevealerTransitionTypeSwingRight RevealerTransitionType = 6
			// RevealerTransitionTypeSwingLeft: floop in from the right
		RevealerTransitionTypeSwingLeft RevealerTransitionType = 7
			// RevealerTransitionTypeSwingUp: floop in from the bottom
		RevealerTransitionTypeSwingUp RevealerTransitionType = 8
			// RevealerTransitionTypeSwingDown: floop in from the top
		RevealerTransitionTypeSwingDown RevealerTransitionType = 9
		)

	
	func marshalRevealerTransitionType(p uintptr) (interface{}, error) {
		return RevealerTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ScrollStep: passed as argument to various keybinding signals.
	type ScrollStep int

	const (
			// ScrollStepSteps: scroll in steps.
		ScrollStepSteps ScrollStep = 0
			// ScrollStepPages: scroll by pages.
		ScrollStepPages ScrollStep = 1
			// ScrollStepEnds: scroll to ends.
		ScrollStepEnds ScrollStep = 2
			// ScrollStepHorizontalSteps: scroll in horizontal steps.
		ScrollStepHorizontalSteps ScrollStep = 3
			// ScrollStepHorizontalPages: scroll by horizontal pages.
		ScrollStepHorizontalPages ScrollStep = 4
			// ScrollStepHorizontalEnds: scroll to the horizontal ends.
		ScrollStepHorizontalEnds ScrollStep = 5
		)

	
	func marshalScrollStep(p uintptr) (interface{}, error) {
		return ScrollStep(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ScrollType: scrolling types.
	type ScrollType int

	const (
			// ScrollTypeNone: no scrolling.
		ScrollTypeNone ScrollType = 0
			// ScrollTypeJump: jump to new location.
		ScrollTypeJump ScrollType = 1
			// ScrollTypeStepBackward: step backward.
		ScrollTypeStepBackward ScrollType = 2
			// ScrollTypeStepForward: step forward.
		ScrollTypeStepForward ScrollType = 3
			// ScrollTypePageBackward: page backward.
		ScrollTypePageBackward ScrollType = 4
			// ScrollTypePageForward: page forward.
		ScrollTypePageForward ScrollType = 5
			// ScrollTypeStepUp: step up.
		ScrollTypeStepUp ScrollType = 6
			// ScrollTypeStepDown: step down.
		ScrollTypeStepDown ScrollType = 7
			// ScrollTypePageUp: page up.
		ScrollTypePageUp ScrollType = 8
			// ScrollTypePageDown: page down.
		ScrollTypePageDown ScrollType = 9
			// ScrollTypeStepLeft: step to the left.
		ScrollTypeStepLeft ScrollType = 10
			// ScrollTypeStepRight: step to the right.
		ScrollTypeStepRight ScrollType = 11
			// ScrollTypePageLeft: page to the left.
		ScrollTypePageLeft ScrollType = 12
			// ScrollTypePageRight: page to the right.
		ScrollTypePageRight ScrollType = 13
			// ScrollTypeStart: scroll to start.
		ScrollTypeStart ScrollType = 14
			// ScrollTypeEnd: scroll to end.
		ScrollTypeEnd ScrollType = 15
		)

	
	func marshalScrollType(p uintptr) (interface{}, error) {
		return ScrollType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
	type ScrollablePolicy int

	const (
			// ScrollablePolicyMinimum: scrollable adjustments are based on the minimum
	// size
		ScrollablePolicyMinimum ScrollablePolicy = 0
			// ScrollablePolicyNatural: scrollable adjustments are based on the natural
	// size
		ScrollablePolicyNatural ScrollablePolicy = 1
		)

	
	func marshalScrollablePolicy(p uintptr) (interface{}, error) {
		return ScrollablePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SelectionMode: used to control what selections users are allowed to make.
	type SelectionMode int

	const (
			// SelectionModeNone: no selection is possible.
		SelectionModeNone SelectionMode = 0
			// SelectionModeSingle: zero or one element may be selected.
		SelectionModeSingle SelectionMode = 1
			// SelectionModeBrowse: exactly one element is selected. In some
	// circumstances, such as initially or during a search operation, its
	// possible for no element to be selected with GTK_SELECTION_BROWSE. What is
	// really enforced is that the user cant deselect a currently selected
	// element except by selecting another element.
		SelectionModeBrowse SelectionMode = 2
			// SelectionModeMultiple: any number of elements may be selected. The Ctrl
	// key may be used to enlarge the selection, and Shift key to select between
	// the focus and the child pointed to. Some widgets may also allow
	// Click-drag to select a range of elements.
		SelectionModeMultiple SelectionMode = 3
		)

	
	func marshalSelectionMode(p uintptr) (interface{}, error) {
		return SelectionMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SensitivityType determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
	type SensitivityType int

	const (
			// SensitivityTypeAuto: the control is made insensitive if no action can be
	// triggered
		SensitivityTypeAuto SensitivityType = 0
			// SensitivityTypeOn: the control is always sensitive
		SensitivityTypeOn SensitivityType = 1
			// SensitivityTypeOff: the control is always insensitive
		SensitivityTypeOff SensitivityType = 2
		)

	
	func marshalSensitivityType(p uintptr) (interface{}, error) {
		return SensitivityType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ShortcutScope describes where `GtkShortcut`s added to a
// `GtkShortcutController` get handled.
	type ShortcutScope int

	const (
			// ShortcutScopeLocal shortcuts are handled inside the widget the controller
	// belongs to.
		ShortcutScopeLocal ShortcutScope = 0
			// ShortcutScopeManaged shortcuts are handled by the first ancestor that is
	// a ShortcutManager
		ShortcutScopeManaged ShortcutScope = 1
			// ShortcutScopeGlobal shortcuts are handled by the root widget.
		ShortcutScopeGlobal ShortcutScope = 2
		)

	
	func marshalShortcutScope(p uintptr) (interface{}, error) {
		return ShortcutScope(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ShortcutType: gtkShortcutType specifies the kind of shortcut that is being
// described.
// 
// More values may be added to this enumeration over time.
	type ShortcutType int

	const (
			// ShortcutTypeAccelerator: the shortcut is a keyboard accelerator. The
	// GtkShortcutsShortcut:accelerator property will be used.
		ShortcutTypeAccelerator ShortcutType = 0
			// ShortcutTypeGesturePinch: the shortcut is a pinch gesture. GTK provides
	// an icon and subtitle.
		ShortcutTypeGesturePinch ShortcutType = 1
			// ShortcutTypeGestureStretch: the shortcut is a stretch gesture. GTK
	// provides an icon and subtitle.
		ShortcutTypeGestureStretch ShortcutType = 2
			// ShortcutTypeGestureRotateClockwise: the shortcut is a clockwise rotation
	// gesture. GTK provides an icon and subtitle.
		ShortcutTypeGestureRotateClockwise ShortcutType = 3
			// ShortcutTypeGestureRotateCounterclockwise: the shortcut is a
	// counterclockwise rotation gesture. GTK provides an icon and subtitle.
		ShortcutTypeGestureRotateCounterclockwise ShortcutType = 4
			// ShortcutTypeGestureTwoFingerSwipeLeft: the shortcut is a two-finger swipe
	// gesture. GTK provides an icon and subtitle.
		ShortcutTypeGestureTwoFingerSwipeLeft ShortcutType = 5
			// ShortcutTypeGestureTwoFingerSwipeRight: the shortcut is a two-finger
	// swipe gesture. GTK provides an icon and subtitle.
		ShortcutTypeGestureTwoFingerSwipeRight ShortcutType = 6
			// ShortcutTypeGesture: the shortcut is a gesture. The
	// GtkShortcutsShortcut:icon property will be used.
		ShortcutTypeGesture ShortcutType = 7
			// ShortcutTypeGestureSwipeLeft: the shortcut is a swipe gesture. GTK
	// provides an icon and subtitle.
		ShortcutTypeGestureSwipeLeft ShortcutType = 8
			// ShortcutTypeGestureSwipeRight: the shortcut is a swipe gesture. GTK
	// provides an icon and subtitle.
		ShortcutTypeGestureSwipeRight ShortcutType = 9
		)

	
	func marshalShortcutType(p uintptr) (interface{}, error) {
		return ShortcutType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SizeGroupMode: the mode of the size group determines the directions in which
// the size group affects the requested sizes of its component widgets.
	type SizeGroupMode int

	const (
			// SizeGroupModeNone: group has no effect
		SizeGroupModeNone SizeGroupMode = 0
			// SizeGroupModeHorizontal: group affects horizontal requisition
		SizeGroupModeHorizontal SizeGroupMode = 1
			// SizeGroupModeVertical: group affects vertical requisition
		SizeGroupModeVertical SizeGroupMode = 2
			// SizeGroupModeBoth: group affects both horizontal and vertical requisition
		SizeGroupModeBoth SizeGroupMode = 3
		)

	
	func marshalSizeGroupMode(p uintptr) (interface{}, error) {
		return SizeGroupMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
	type SizeRequestMode int

	const (
			// SizeRequestModeHeightForWidth: prefer height-for-width geometry
	// management
		SizeRequestModeHeightForWidth SizeRequestMode = 0
			// SizeRequestModeWidthForHeight: prefer width-for-height geometry
	// management
		SizeRequestModeWidthForHeight SizeRequestMode = 1
			// SizeRequestModeConstantSize: dont trade height-for-width or
	// width-for-height
		SizeRequestModeConstantSize SizeRequestMode = 2
		)

	
	func marshalSizeRequestMode(p uintptr) (interface{}, error) {
		return SizeRequestMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SortType determines the direction of a sort.
	type SortType int

	const (
			// SortTypeAscending: sorting is in ascending order.
		SortTypeAscending SortType = 0
			// SortTypeDescending: sorting is in descending order.
		SortTypeDescending SortType = 1
		)

	
	func marshalSortType(p uintptr) (interface{}, error) {
		return SortType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SorterChange describes changes in a sorter in more detail and allows users to
// optimize resorting.
	type SorterChange int

	const (
			// SorterChangeDifferent: the sorter change cannot be described by any of
	// the other enumeration values
		SorterChangeDifferent SorterChange = 0
			// SorterChangeInverted: the sort order was inverted. Comparisons that
	// returned GTK_ORDERING_SMALLER now return GTK_ORDERING_LARGER and vice
	// versa. Other comparisons return the same values as before.
		SorterChangeInverted SorterChange = 1
			// SorterChangeLessStrict: the sorter is less strict: Comparisons may now
	// return GTK_ORDERING_EQUAL that did not do so before.
		SorterChangeLessStrict SorterChange = 2
			// SorterChangeMoreStrict: the sorter is more strict: Comparisons that did
	// return GTK_ORDERING_EQUAL may not do so anymore.
		SorterChangeMoreStrict SorterChange = 3
		)

	
	func marshalSorterChange(p uintptr) (interface{}, error) {
		return SorterChange(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SorterOrder describes the type of order that a `GtkSorter` may produce.
	type SorterOrder int

	const (
			// SorterOrderPartial: a partial order. Any Ordering is possible.
		SorterOrderPartial SorterOrder = 0
			// SorterOrderNone: no order, all elements are considered equal.
	// gtk_sorter_compare() will only return GTK_ORDERING_EQUAL.
		SorterOrderNone SorterOrder = 1
			// SorterOrderTotal: a total order. gtk_sorter_compare() will only return
	// GTK_ORDERING_EQUAL if an item is compared with itself. Two different
	// items will never cause this value to be returned.
		SorterOrderTotal SorterOrder = 2
		)

	
	func marshalSorterOrder(p uintptr) (interface{}, error) {
		return SorterOrder(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SpinButtonUpdatePolicy determines whether the spin button displays values
// outside the adjustment bounds.
// 
// See [method@Gtk.SpinButton.set_update_policy].
	type SpinButtonUpdatePolicy int

	const (
			// SpinButtonUpdatePolicyAlways: when refreshing your SpinButton, the value
	// is always displayed
		SpinButtonUpdatePolicyAlways SpinButtonUpdatePolicy = 0
			// SpinButtonUpdatePolicyIfValid: when refreshing your SpinButton, the value
	// is only displayed if it is valid within the bounds of the spin button's
	// adjustment
		SpinButtonUpdatePolicyIfValid SpinButtonUpdatePolicy = 1
		)

	
	func marshalSpinButtonUpdatePolicy(p uintptr) (interface{}, error) {
		return SpinButtonUpdatePolicy(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SpinType: the values of the GtkSpinType enumeration are used to specify the
// change to make in gtk_spin_button_spin().
	type SpinType int

	const (
			// SpinTypeStepForward: increment by the adjustments step increment.
		SpinTypeStepForward SpinType = 0
			// SpinTypeStepBackward: decrement by the adjustments step increment.
		SpinTypeStepBackward SpinType = 1
			// SpinTypePageForward: increment by the adjustments page increment.
		SpinTypePageForward SpinType = 2
			// SpinTypePageBackward: decrement by the adjustments page increment.
		SpinTypePageBackward SpinType = 3
			// SpinTypeHome: go to the adjustments lower bound.
		SpinTypeHome SpinType = 4
			// SpinTypeEnd: go to the adjustments upper bound.
		SpinTypeEnd SpinType = 5
			// SpinTypeUserDefined: change by a specified amount.
		SpinTypeUserDefined SpinType = 6
		)

	
	func marshalSpinType(p uintptr) (interface{}, error) {
		return SpinType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StackTransitionType: possible transitions between pages in a `GtkStack`
// widget.
// 
// New values may be added to this enumeration over time.
	type StackTransitionType int

	const (
			// StackTransitionTypeNone: no transition
		StackTransitionTypeNone StackTransitionType = 0
			// StackTransitionTypeCrossfade: a cross-fade
		StackTransitionTypeCrossfade StackTransitionType = 1
			// StackTransitionTypeSlideRight: slide from left to right
		StackTransitionTypeSlideRight StackTransitionType = 2
			// StackTransitionTypeSlideLeft: slide from right to left
		StackTransitionTypeSlideLeft StackTransitionType = 3
			// StackTransitionTypeSlideUp: slide from bottom up
		StackTransitionTypeSlideUp StackTransitionType = 4
			// StackTransitionTypeSlideDown: slide from top down
		StackTransitionTypeSlideDown StackTransitionType = 5
			// StackTransitionTypeSlideLeftRight: slide from left or right according to
	// the children order
		StackTransitionTypeSlideLeftRight StackTransitionType = 6
			// StackTransitionTypeSlideUpDown: slide from top down or bottom up
	// according to the order
		StackTransitionTypeSlideUpDown StackTransitionType = 7
			// StackTransitionTypeOverUp: cover the old page by sliding up
		StackTransitionTypeOverUp StackTransitionType = 8
			// StackTransitionTypeOverDown: cover the old page by sliding down
		StackTransitionTypeOverDown StackTransitionType = 9
			// StackTransitionTypeOverLeft: cover the old page by sliding to the left
		StackTransitionTypeOverLeft StackTransitionType = 10
			// StackTransitionTypeOverRight: cover the old page by sliding to the right
		StackTransitionTypeOverRight StackTransitionType = 11
			// StackTransitionTypeUnderUp: uncover the new page by sliding up
		StackTransitionTypeUnderUp StackTransitionType = 12
			// StackTransitionTypeUnderDown: uncover the new page by sliding down
		StackTransitionTypeUnderDown StackTransitionType = 13
			// StackTransitionTypeUnderLeft: uncover the new page by sliding to the left
		StackTransitionTypeUnderLeft StackTransitionType = 14
			// StackTransitionTypeUnderRight: uncover the new page by sliding to the
	// right
		StackTransitionTypeUnderRight StackTransitionType = 15
			// StackTransitionTypeOverUpDown: cover the old page sliding up or uncover
	// the new page sliding down, according to order
		StackTransitionTypeOverUpDown StackTransitionType = 16
			// StackTransitionTypeOverDownUp: cover the old page sliding down or uncover
	// the new page sliding up, according to order
		StackTransitionTypeOverDownUp StackTransitionType = 17
			// StackTransitionTypeOverLeftRight: cover the old page sliding left or
	// uncover the new page sliding right, according to order
		StackTransitionTypeOverLeftRight StackTransitionType = 18
			// StackTransitionTypeOverRightLeft: cover the old page sliding right or
	// uncover the new page sliding left, according to order
		StackTransitionTypeOverRightLeft StackTransitionType = 19
			// StackTransitionTypeRotateLeft: pretend the pages are sides of a cube and
	// rotate that cube to the left
		StackTransitionTypeRotateLeft StackTransitionType = 20
			// StackTransitionTypeRotateRight: pretend the pages are sides of a cube and
	// rotate that cube to the right
		StackTransitionTypeRotateRight StackTransitionType = 21
			// StackTransitionTypeRotateLeftRight: pretend the pages are sides of a cube
	// and rotate that cube to the left or right according to the children order
		StackTransitionTypeRotateLeftRight StackTransitionType = 22
		)

	
	func marshalStackTransitionType(p uintptr) (interface{}, error) {
		return StackTransitionType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StringFilterMatchMode specifies how search strings are matched inside text.
	type StringFilterMatchMode int

	const (
			// StringFilterMatchModeExact: the search string and text must match
	// exactly.
		StringFilterMatchModeExact StringFilterMatchMode = 0
			// StringFilterMatchModeSubstring: the search string must be contained as a
	// substring inside the text.
		StringFilterMatchModeSubstring StringFilterMatchMode = 1
			// StringFilterMatchModePrefix: the text must begin with the search string.
		StringFilterMatchModePrefix StringFilterMatchMode = 2
		)

	
	func marshalStringFilterMatchMode(p uintptr) (interface{}, error) {
		return StringFilterMatchMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// SystemSetting values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc.
// 
// The values indicate which system setting has changed. Widgets may need to
// drop caches, or react otherwise.
// 
// Most of the values correspond to `GtkSettings` properties.
// 
// More values may be added over time.
	type SystemSetting int

	const (
			// SystemSettingDPI: the Settings:gtk-xft-dpi setting has changed
		SystemSettingDPI SystemSetting = 0
			// SystemSettingFontName: the Settings:gtk-font-name setting has changed
		SystemSettingFontName SystemSetting = 1
			// SystemSettingFontConfig: the font configuration has changed in a way that
	// requires text to be redrawn. This can be any of the
	// Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings
		SystemSettingFontConfig SystemSetting = 2
			// SystemSettingDisplay: the display has changed
		SystemSettingDisplay SystemSetting = 3
			// SystemSettingIconTheme: the icon theme has changed in a way that requires
	// icons to be looked up again
		SystemSettingIconTheme SystemSetting = 4
		)

	
	func marshalSystemSetting(p uintptr) (interface{}, error) {
		return SystemSetting(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextDirection: reading directions for text.
	type TextDirection int

	const (
			// TextDirectionNone: no direction.
		TextDirectionNone TextDirection = 0
			// TextDirectionLTR: left to right text direction.
		TextDirectionLTR TextDirection = 1
			// TextDirectionRTL: right to left text direction.
		TextDirectionRTL TextDirection = 2
		)

	
	func marshalTextDirection(p uintptr) (interface{}, error) {
		return TextDirection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextExtendSelection: granularity types that extend the text selection. Use
// the TextView::extend-selection signal to customize the selection.
	type TextExtendSelection int

	const (
			// TextExtendSelectionWord selects the current word. It is triggered by a
	// double-click for example.
		TextExtendSelectionWord TextExtendSelection = 0
			// TextExtendSelectionLine selects the current line. It is triggered by a
	// triple-click for example.
		TextExtendSelectionLine TextExtendSelection = 1
		)

	
	func marshalTextExtendSelection(p uintptr) (interface{}, error) {
		return TextExtendSelection(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextViewLayer: used to reference the layers of TextView for the purpose of
// customized drawing with the ::snapshot_layer vfunc.
	type TextViewLayer int

	const (
			// TextViewLayerBelowText: the layer rendered below the text (but above the
	// background).
		TextViewLayerBelowText TextViewLayer = 0
			// TextViewLayerAboveText: the layer rendered above the text.
		TextViewLayerAboveText TextViewLayer = 1
		)

	
	func marshalTextViewLayer(p uintptr) (interface{}, error) {
		return TextViewLayer(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextWindowType: used to reference the parts of TextView.
	type TextWindowType int

	const (
			// TextWindowTypeWidget: window that floats over scrolling areas.
		TextWindowTypeWidget TextWindowType = 1
			// TextWindowTypeText: scrollable text window.
		TextWindowTypeText TextWindowType = 2
			// TextWindowTypeLeft: left side border window.
		TextWindowTypeLeft TextWindowType = 3
			// TextWindowTypeRight: right side border window.
		TextWindowTypeRight TextWindowType = 4
			// TextWindowTypeTop: top border window.
		TextWindowTypeTop TextWindowType = 5
			// TextWindowTypeBottom: bottom border window.
		TextWindowTypeBottom TextWindowType = 6
		)

	
	func marshalTextWindowType(p uintptr) (interface{}, error) {
		return TextWindowType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeViewColumnSizing: the sizing method the column uses to determine its
// width. Please note that GTK_TREE_VIEW_COLUMN_AUTOSIZE are inefficient for
// large views, and can make columns appear choppy.
	type TreeViewColumnSizing int

	const (
			// TreeViewColumnSizingGrowOnly columns only get bigger in reaction to
	// changes in the model
		TreeViewColumnSizingGrowOnly TreeViewColumnSizing = 0
			// TreeViewColumnSizingAutosize columns resize to be the optimal size every
	// time the model changes.
		TreeViewColumnSizingAutosize TreeViewColumnSizing = 1
			// TreeViewColumnSizingFixed columns are a fixed numbers of pixels wide.
		TreeViewColumnSizingFixed TreeViewColumnSizing = 2
		)

	
	func marshalTreeViewColumnSizing(p uintptr) (interface{}, error) {
		return TreeViewColumnSizing(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeViewDropPosition: an enum for determining where a dropped row goes.
	type TreeViewDropPosition int

	const (
			// TreeViewDropPositionBefore: dropped row is inserted before
		TreeViewDropPositionBefore TreeViewDropPosition = 0
			// TreeViewDropPositionAfter: dropped row is inserted after
		TreeViewDropPositionAfter TreeViewDropPosition = 1
			// TreeViewDropPositionIntoOrBefore: dropped row becomes a child or is
	// inserted before
		TreeViewDropPositionIntoOrBefore TreeViewDropPosition = 2
			// TreeViewDropPositionIntoOrAfter: dropped row becomes a child or is
	// inserted after
		TreeViewDropPositionIntoOrAfter TreeViewDropPosition = 3
		)

	
	func marshalTreeViewDropPosition(p uintptr) (interface{}, error) {
		return TreeViewDropPosition(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
	type TreeViewGridLines int

	const (
			// TreeViewGridLinesNone: no grid lines.
		TreeViewGridLinesNone TreeViewGridLines = 0
			// TreeViewGridLinesHorizontal: horizontal grid lines.
		TreeViewGridLinesHorizontal TreeViewGridLines = 1
			// TreeViewGridLinesVertical: vertical grid lines.
		TreeViewGridLinesVertical TreeViewGridLines = 2
			// TreeViewGridLinesBoth: horizontal and vertical grid lines.
		TreeViewGridLinesBoth TreeViewGridLines = 3
		)

	
	func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
		return TreeViewGridLines(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// Unit: see also gtk_print_settings_set_paper_width().
	type Unit int

	const (
			// UnitNone: no units.
		UnitNone Unit = 0
			// UnitPoints dimensions in points.
		UnitPoints Unit = 1
			// UnitInch dimensions in inches.
		UnitInch Unit = 2
			// UnitMm dimensions in millimeters
		UnitMm Unit = 3
		)

	
	func marshalUnit(p uintptr) (interface{}, error) {
		return Unit(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// WrapMode describes a type of line wrapping.
	type WrapMode int

	const (
			// WrapModeNone: do not wrap lines; just make the text area wider
		WrapModeNone WrapMode = 0
			// WrapModeChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs())
		WrapModeChar WrapMode = 1
			// WrapModeWord: wrap text, breaking lines in between words
		WrapModeWord WrapMode = 2
			// WrapModeWordChar: wrap text, breaking lines in between words, or if that
	// is not enough, also between graphemes
		WrapModeWordChar WrapMode = 3
		)

	
	func marshalWrapMode(p uintptr) (interface{}, error) {
		return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ApplicationInhibitFlags types of user actions that may be blocked by
// `GtkApplication`.
// 
// See [method@Gtk.Application.inhibit].
	type ApplicationInhibitFlags int

	const (
			// ApplicationInhibitFlagsLogout: inhibit ending the user session by logging
	// out or by shutting down the computer
		ApplicationInhibitFlagsLogout ApplicationInhibitFlags = 1
			// ApplicationInhibitFlagsSwitch: inhibit user switching
		ApplicationInhibitFlagsSwitch ApplicationInhibitFlags = 2
			// ApplicationInhibitFlagsSuspend: inhibit suspending the session or
	// computer
		ApplicationInhibitFlagsSuspend ApplicationInhibitFlags = 4
			// ApplicationInhibitFlagsIdle: inhibit the session being marked as idle
	// (and possibly locked)
		ApplicationInhibitFlagsIdle ApplicationInhibitFlags = 8
		)

	
	func marshalApplicationInhibitFlags(p uintptr) (interface{}, error) {
		return ApplicationInhibitFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// BuilderClosureFlags: the list of flags that can be passed to
// gtk_builder_create_closure().
// 
// New values may be added in the future for new features, so external
// implementations of [interface@Gtk.BuilderScope] should test the flags for
// unknown values and raise a GTK_BUILDER_ERROR_INVALID_ATTRIBUTE error when
// they encounter one.
	type BuilderClosureFlags int

	const (
			// BuilderClosureFlagsSwapped: the closure should be created swapped. See
	// g_cclosure_new_swap() for details.
		BuilderClosureFlagsSwapped BuilderClosureFlags = 1
		)

	
	func marshalBuilderClosureFlags(p uintptr) (interface{}, error) {
		return BuilderClosureFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// CellRendererState tells how a cell is to be rendered.
	type CellRendererState int

	const (
			// CellRendererStateSelected: the cell is currently selected, and probably
	// has a selection colored background to render to.
		CellRendererStateSelected CellRendererState = 1
			// CellRendererStatePrelit: the mouse is hovering over the cell.
		CellRendererStatePrelit CellRendererState = 2
			// CellRendererStateInsensitive: the cell is drawn in an insensitive manner
		CellRendererStateInsensitive CellRendererState = 4
			// CellRendererStateSorted: the cell is in a sorted row
		CellRendererStateSorted CellRendererState = 8
			// CellRendererStateFocused: the cell is in the focus row.
		CellRendererStateFocused CellRendererState = 16
			// CellRendererStateExpandable: the cell is in a row that can be expanded
		CellRendererStateExpandable CellRendererState = 32
			// CellRendererStateExpanded: the cell is in a row that is expanded
		CellRendererStateExpanded CellRendererState = 64
		)

	
	func marshalCellRendererState(p uintptr) (interface{}, error) {
		return CellRendererState(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	
	type DebugFlags int

	const (
		DebugFlagsText DebugFlags = 1
		DebugFlagsTree DebugFlags = 2
		DebugFlagsKeybindings DebugFlags = 4
		DebugFlagsModules DebugFlags = 8
		DebugFlagsGeometry DebugFlags = 16
		DebugFlagsIcontheme DebugFlags = 32
		DebugFlagsPrinting DebugFlags = 64
		DebugFlagsBuilder DebugFlags = 128
		DebugFlagsSizeRequest DebugFlags = 256
		DebugFlagsNoCSSCache DebugFlags = 512
		DebugFlagsInteractive DebugFlags = 1024
		DebugFlagsTouchscreen DebugFlags = 2048
		DebugFlagsActions DebugFlags = 4096
		DebugFlagsLayout DebugFlags = 8192
		DebugFlagsSnapshot DebugFlags = 16384
		DebugFlagsConstraints DebugFlags = 32768
		DebugFlagsBuilderObjects DebugFlags = 65536
		DebugFlagsA11Y DebugFlags = 131072
		DebugFlagsIconfallback DebugFlags = 262144
		)

	
	func marshalDebugFlags(p uintptr) (interface{}, error) {
		return DebugFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// DialogFlags flags used to influence dialog construction.
	type DialogFlags int

	const (
			// DialogFlagsModal: make the constructed dialog modal
		DialogFlagsModal DialogFlags = 1
			// DialogFlagsDestroyWithParent: destroy the dialog when its parent is
	// destroyed
		DialogFlagsDestroyWithParent DialogFlags = 2
			// DialogFlagsUseHeaderBar: create dialog with actions in header bar instead
	// of action area
		DialogFlagsUseHeaderBar DialogFlags = 4
		)

	
	func marshalDialogFlags(p uintptr) (interface{}, error) {
		return DialogFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// EventControllerScrollFlags describes the behavior of a
// `GtkEventControllerScroll`.
	type EventControllerScrollFlags int

	const (
			// EventControllerScrollFlagsNone: don't emit scroll.
		EventControllerScrollFlagsNone EventControllerScrollFlags = 0
			// EventControllerScrollFlagsVertical: emit scroll with vertical deltas.
		EventControllerScrollFlagsVertical EventControllerScrollFlags = 1
			// EventControllerScrollFlagsHorizontal: emit scroll with horizontal deltas.
		EventControllerScrollFlagsHorizontal EventControllerScrollFlags = 2
			// EventControllerScrollFlagsDiscrete: only emit deltas that are multiples
	// of 1.
		EventControllerScrollFlagsDiscrete EventControllerScrollFlags = 4
			// EventControllerScrollFlagsKinetic: emit ::decelerate after continuous
	// scroll finishes.
		EventControllerScrollFlagsKinetic EventControllerScrollFlags = 8
			// EventControllerScrollFlagsBothAxes: emit scroll on both axes.
		EventControllerScrollFlagsBothAxes EventControllerScrollFlags = 3
		)

	
	func marshalEventControllerScrollFlags(p uintptr) (interface{}, error) {
		return EventControllerScrollFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// FontChooserLevel specifies the granularity of font selection that is desired
// in a `GtkFontChooser`.
// 
// This enumeration may be extended in the future; applications should ignore
// unknown values.
	type FontChooserLevel int

	const (
			// FontChooserLevelFamily: allow selecting a font family
		FontChooserLevelFamily FontChooserLevel = 0
			// FontChooserLevelStyle: allow selecting a specific font face
		FontChooserLevelStyle FontChooserLevel = 1
			// FontChooserLevelSize: allow selecting a specific font size
		FontChooserLevelSize FontChooserLevel = 2
			// FontChooserLevelVariations: allow changing OpenType font variation axes
		FontChooserLevelVariations FontChooserLevel = 4
			// FontChooserLevelFeatures: allow selecting specific OpenType font features
		FontChooserLevelFeatures FontChooserLevel = 8
		)

	
	func marshalFontChooserLevel(p uintptr) (interface{}, error) {
		return FontChooserLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// IconLookupFlags: used to specify options for gtk_icon_theme_lookup_icon().
	type IconLookupFlags int

	const (
			// IconLookupFlagsForceRegular: try to always load regular icons, even when
	// symbolic icon names are given
		IconLookupFlagsForceRegular IconLookupFlags = 1
			// IconLookupFlagsForceSymbolic: try to always load symbolic icons, even
	// when regular icon names are given
		IconLookupFlagsForceSymbolic IconLookupFlags = 2
			// IconLookupFlagsPreload starts loading the texture in the background so it
	// is ready when later needed.
		IconLookupFlagsPreload IconLookupFlags = 4
		)

	
	func marshalIconLookupFlags(p uintptr) (interface{}, error) {
		return IconLookupFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// InputHints describes hints that might be taken into account by input methods
// or applications.
// 
// Note that input methods may already tailor their behaviour according to the
// `GtkInputPurpose` of the entry.
// 
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
// 
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
	type InputHints int

	const (
			// InputHintsNone: no special behaviour suggested
		InputHintsNone InputHints = 0
			// InputHintsSpellcheck: suggest checking for typos
		InputHintsSpellcheck InputHints = 1
			// InputHintsNoSpellcheck: suggest not checking for typos
		InputHintsNoSpellcheck InputHints = 2
			// InputHintsWordCompletion: suggest word completion
		InputHintsWordCompletion InputHints = 4
			// InputHintsLowercase: suggest to convert all text to lowercase
		InputHintsLowercase InputHints = 8
			// InputHintsUppercaseChars: suggest to capitalize all text
		InputHintsUppercaseChars InputHints = 16
			// InputHintsUppercaseWords: suggest to capitalize the first character of
	// each word
		InputHintsUppercaseWords InputHints = 32
			// InputHintsUppercaseSentences: suggest to capitalize the first word of
	// each sentence
		InputHintsUppercaseSentences InputHints = 64
			// InputHintsInhibitOsk: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
		InputHintsInhibitOsk InputHints = 128
			// InputHintsVerticalWriting: the text is vertical
		InputHintsVerticalWriting InputHints = 256
			// InputHintsEmoji: suggest offering Emoji support
		InputHintsEmoji InputHints = 512
			// InputHintsNoEmoji: suggest not offering Emoji support
		InputHintsNoEmoji InputHints = 1024
			// InputHintsPrivate: request that the input method should not update
	// personalized data (like typing history)
		InputHintsPrivate InputHints = 2048
		)

	
	func marshalInputHints(p uintptr) (interface{}, error) {
		return InputHints(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PickFlags flags that influence the behavior of gtk_widget_pick().
	type PickFlags int

	const (
			// PickFlagsDefault: the default behavior, include widgets that are
	// receiving events
		PickFlagsDefault PickFlags = 0
			// PickFlagsInsensitive: include widgets that are insensitive
		PickFlagsInsensitive PickFlags = 1
			// PickFlagsNonTargetable: include widgets that are marked as
	// non-targetable. See Widget:can-target
		PickFlagsNonTargetable PickFlags = 2
		)

	
	func marshalPickFlags(p uintptr) (interface{}, error) {
		return PickFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PopoverMenuFlags flags that affect how popover menus are created from a menu
// model.
	type PopoverMenuFlags int

	const (
			// PopoverMenuFlagsNested: create submenus as nested popovers. Without this
	// flag, submenus are created as sliding pages that replace the main menu.
		PopoverMenuFlagsNested PopoverMenuFlags = 1
		)

	
	func marshalPopoverMenuFlags(p uintptr) (interface{}, error) {
		return PopoverMenuFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// PrintCapabilities specifies which features the print dialog should offer.
// 
// If neither GTK_PRINT_CAPABILITY_GENERATE_PDF nor
// GTK_PRINT_CAPABILITY_GENERATE_PS is specified, GTK assumes that all formats
// are supported.
	type PrintCapabilities int

	const (
			// PrintCapabilitiesPageSet: print dialog will offer printing even/odd
	// pages.
		PrintCapabilitiesPageSet PrintCapabilities = 1
			// PrintCapabilitiesCopies: print dialog will allow to print multiple
	// copies.
		PrintCapabilitiesCopies PrintCapabilities = 2
			// PrintCapabilitiesCollate: print dialog will allow to collate multiple
	// copies.
		PrintCapabilitiesCollate PrintCapabilities = 4
			// PrintCapabilitiesReverse: print dialog will allow to print pages in
	// reverse order.
		PrintCapabilitiesReverse PrintCapabilities = 8
			// PrintCapabilitiesScale: print dialog will allow to scale the output.
		PrintCapabilitiesScale PrintCapabilities = 16
			// PrintCapabilitiesGeneratePDF: the program will send the document to the
	// printer in PDF format
		PrintCapabilitiesGeneratePDF PrintCapabilities = 32
			// PrintCapabilitiesGeneratePS: the program will send the document to the
	// printer in Postscript format
		PrintCapabilitiesGeneratePS PrintCapabilities = 64
			// PrintCapabilitiesPreview: print dialog will offer a preview
		PrintCapabilitiesPreview PrintCapabilities = 128
			// PrintCapabilitiesNumberUp: print dialog will offer printing multiple
	// pages per sheet
		PrintCapabilitiesNumberUp PrintCapabilities = 256
			// PrintCapabilitiesNumberUpLayout: print dialog will allow to rearrange
	// pages when printing multiple pages per sheet
		PrintCapabilitiesNumberUpLayout PrintCapabilities = 512
		)

	
	func marshalPrintCapabilities(p uintptr) (interface{}, error) {
		return PrintCapabilities(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// ShortcutActionFlags: list of flags that can be passed to action activation.
// 
// More flags may be added in the future.
	type ShortcutActionFlags int

	const (
			// ShortcutActionFlagsExclusive: the action is the only action that can be
	// activated. If this flag is not set, a future activation may select a
	// different action.
		ShortcutActionFlagsExclusive ShortcutActionFlags = 1
		)

	
	func marshalShortcutActionFlags(p uintptr) (interface{}, error) {
		return ShortcutActionFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StateFlags describes a widget state.
// 
// Widget states are used to match the widget against CSS pseudo-classes. Note
// that GTK extends the regular CSS classes and sometimes uses different names.
	type StateFlags int

	const (
			// StateFlagsNormal: state during normal operation
		StateFlagsNormal StateFlags = 0
			// StateFlagsActive: widget is active
		StateFlagsActive StateFlags = 1
			// StateFlagsPrelight: widget has a mouse pointer over it
		StateFlagsPrelight StateFlags = 2
			// StateFlagsSelected: widget is selected
		StateFlagsSelected StateFlags = 4
			// StateFlagsInsensitive: widget is insensitive
		StateFlagsInsensitive StateFlags = 8
			// StateFlagsInconsistent: widget is inconsistent
		StateFlagsInconsistent StateFlags = 16
			// StateFlagsFocused: widget has the keyboard focus
		StateFlagsFocused StateFlags = 32
			// StateFlagsBackdrop: widget is in a background toplevel window
		StateFlagsBackdrop StateFlags = 64
			// StateFlagsDirLTR: widget is in left-to-right text direction
		StateFlagsDirLTR StateFlags = 128
			// StateFlagsDirRTL: widget is in right-to-left text direction
		StateFlagsDirRTL StateFlags = 256
			// StateFlagsLink: widget is a link
		StateFlagsLink StateFlags = 512
			// StateFlagsVisited: the location the widget points to has already been
	// visited
		StateFlagsVisited StateFlags = 1024
			// StateFlagsChecked: widget is checked
		StateFlagsChecked StateFlags = 2048
			// StateFlagsDropActive: widget is highlighted as a drop target for DND
		StateFlagsDropActive StateFlags = 4096
			// StateFlagsFocusVisible: widget has the visible focus
		StateFlagsFocusVisible StateFlags = 8192
			// StateFlagsFocusWithin: widget contains the keyboard focus
		StateFlagsFocusWithin StateFlags = 16384
		)

	
	func marshalStateFlags(p uintptr) (interface{}, error) {
		return StateFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// StyleContextPrintFlags flags that modify the behavior of
// gtk_style_context_to_string().
// 
// New values may be added to this enumeration.
	type StyleContextPrintFlags int

	const (
			// StyleContextPrintFlagsNone: default value.
		StyleContextPrintFlagsNone StyleContextPrintFlags = 0
			// StyleContextPrintFlagsRecurse: print the entire tree of CSS nodes
	// starting at the style context's node
		StyleContextPrintFlagsRecurse StyleContextPrintFlags = 1
			// StyleContextPrintFlagsShowStyle: show the values of the CSS properties
	// for each node
		StyleContextPrintFlagsShowStyle StyleContextPrintFlags = 2
			// StyleContextPrintFlagsShowChange: show information about what changes
	// affect the styles
		StyleContextPrintFlagsShowChange StyleContextPrintFlags = 4
		)

	
	func marshalStyleContextPrintFlags(p uintptr) (interface{}, error) {
		return StyleContextPrintFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TextSearchFlags flags affecting how a search is done.
// 
// If neither GTK_TEXT_SEARCH_VISIBLE_ONLY nor GTK_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
	type TextSearchFlags int

	const (
			// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
		TextSearchFlagsVisibleOnly TextSearchFlags = 1
			// TextSearchFlagsTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
		TextSearchFlagsTextOnly TextSearchFlags = 2
			// TextSearchFlagsCaseInsensitive: the text will be matched regardless of
	// what case it is in.
		TextSearchFlagsCaseInsensitive TextSearchFlags = 4
		)

	
	func marshalTextSearchFlags(p uintptr) (interface{}, error) {
		return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	

	// TreeModelFlags: these flags indicate various properties of a TreeModel.
// 
// They are returned by gtk_tree_model_get_flags(), and must be static for the
// lifetime of the object. A more complete description of
// K_TREE_MODEL_ITERS_PERSIST can be found in the overview of this section.
	type TreeModelFlags int

	const (
			// TreeModelFlagsItersPersist iterators survive all signals emitted by the
	// tree
		TreeModelFlagsItersPersist TreeModelFlags = 1
			// TreeModelFlagsListOnly: the model is a list only, and never has children
		TreeModelFlagsListOnly TreeModelFlags = 2
		)

	
	func marshalTreeModelFlags(p uintptr) (interface{}, error) {
		return TreeModelFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
	}
	


	// AcceleratorGetDefaultModMask gets the modifier mask.
// 
// The modifier mask determines which modifiers are considered significant for
// keyboard accelerators. This includes all keyboard modifiers except for
// GDK_LOCK_MASK.
	func AcceleratorGetDefaultModMask() gdk.ModifierType {
var _cret C.GdkModifierType // in

_cret = C.gtk_accelerator_get_default_mod_mask()


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}


	// AcceleratorGetLabel converts an accelerator keyval and modifier mask into a
// string which can be used to represent the accelerator to the user.
	func AcceleratorGetLabel(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret *C.char // in

_arg1 = (C.guint)(acceleratorKey)
_arg2 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_get_label(_arg1, _arg2)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorGetLabelWithKeycode converts an accelerator keyval and modifier
// mask into a string that can be displayed to the user.
// 
// The string may be translated.
// 
// This function is similar to [func@Gtk.accelerator_get_label], but handling
// keycodes.
// 
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
	func AcceleratorGetLabelWithKeycode(display gdk.DisplayClass, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
var _arg1 *C.GdkDisplay // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.GdkModifierType // out
var _cret *C.char // in

_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
_arg2 = (C.guint)(acceleratorKey)
_arg3 = (C.guint)(keycode)
_arg4 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_get_label_with_keycode(_arg1, _arg2, _arg3, _arg4)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorName converts an accelerator keyval and modifier mask into a
// string parseable by gtk_accelerator_parse().
// 
// For example, if you pass in GDK_KEY_q and GDK_CONTROL_MASK, this function
// returns `<Control>q`.
// 
// If you need to display accelerators in the user interface, see
// [func@Gtk.accelerator_get_label].
	func AcceleratorName(acceleratorKey uint, acceleratorMods gdk.ModifierType) string {
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret *C.char // in

_arg1 = (C.guint)(acceleratorKey)
_arg2 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_name(_arg1, _arg2)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorNameWithKeycode converts an accelerator keyval and modifier mask
// into a string parseable by gtk_accelerator_parse_with_keycode().
// 
// This is similar to [func@Gtk.accelerator_name] but handling keycodes. This is
// only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
	func AcceleratorNameWithKeycode(display gdk.DisplayClass, acceleratorKey uint, keycode uint, acceleratorMods gdk.ModifierType) string {
var _arg1 *C.GdkDisplay // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.GdkModifierType // out
var _cret *C.char // in

_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))
_arg2 = (C.guint)(acceleratorKey)
_arg3 = (C.guint)(keycode)
_arg4 = (C.GdkModifierType)(acceleratorMods)

_cret = C.gtk_accelerator_name_with_keycode(_arg1, _arg2, _arg3, _arg4)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}


	// AcceleratorParse parses a string representing an accelerator.
// 
// The format looks like <Control>a or <Shift><Alt>F1.
// 
// The parser is fairly liberal and allows lower or upper case, and also
// abbreviations such as <Ctl> and <Ctrl>. Key names are parsed using
// [func@Gdk.keyval_from_name]. For character keys the name is not the symbol,
// but the lowercase name, e.g. one would use <Ctrl>minus instead of
// <Ctrl>-.
// 
// If the parse fails, @accelerator_key and @accelerator_mods will be set to 0
// (zero).
	func AcceleratorParse(accelerator string) (uint, gdk.ModifierType, bool) {
var _arg1 *C.char // out
var _arg2 C.guint // in
var _arg3 C.GdkModifierType // in
var _cret C.gboolean // in

_arg1 = (*C.char)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_accelerator_parse(_arg1, &_arg2, &_arg3)


var _acceleratorKey uint // out
var _acceleratorMods gdk.ModifierType // out
var _ok bool // out

_acceleratorKey = (uint)(_arg2)
_acceleratorMods = gdk.ModifierType(_arg3)
if _cret != 0 { _ok = true }

return _acceleratorKey, _acceleratorMods, _ok
}


	// AcceleratorParseWithKeycode parses a string representing an accelerator.
// 
// This is similar to [func@Gtk.accelerator_parse] but handles keycodes as well.
// This is only useful for system-level components, applications should use
// gtk_accelerator_parse() instead.
// 
// If @accelerator_codes is given and the result stored in it is non-nil, the
// result must be freed with g_free().
// 
// If a keycode is present in the accelerator and no @accelerator_codes is
// given, the parse will fail.
// 
// If the parse fails, @accelerator_key, @accelerator_mods and
// @accelerator_codes will be set to 0 (zero).
	func AcceleratorParseWithKeycode(accelerator string, display gdk.DisplayClass) (uint, []uint, gdk.ModifierType, bool) {
var _arg1 *C.char // out
var _arg2 *C.GdkDisplay // out
var _arg3 C.guint // in
var _arg4 *C.guint
var _arg5 C.GdkModifierType // in
var _cret C.gboolean // in

_arg1 = (*C.char)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

_cret = C.gtk_accelerator_parse_with_keycode(_arg1, _arg2, &_arg3, &_arg4, &_arg5)


var _acceleratorKey uint // out
var _acceleratorCodes []uint
var _acceleratorMods gdk.ModifierType // out
var _ok bool // out

_acceleratorKey = (uint)(_arg3)
{
var i int
var z C.guint
for p := _arg4; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_arg4, i)
_acceleratorCodes = make([]uint, i)
for i := range src {
_acceleratorCodes[i] = (uint)(src[i])
}
}
_acceleratorMods = gdk.ModifierType(_arg5)
if _cret != 0 { _ok = true }

return _acceleratorKey, _acceleratorCodes, _acceleratorMods, _ok
}


	// AcceleratorValid determines whether a given keyval and modifier mask
// constitute a valid keyboard accelerator.
// 
// For example, the GDK_KEY_a keyval plus GDK_CONTROL_MASK mark is valid, and
// matches the Ctrl+a accelerator. But, you can't, for instance, use the
// GDK_KEY_Control_L keyval as an accelerator.
	func AcceleratorValid(keyval uint, modifiers gdk.ModifierType) bool {
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret C.gboolean // in

_arg1 = (C.guint)(keyval)
_arg2 = (C.GdkModifierType)(modifiers)

_cret = C.gtk_accelerator_valid(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// CheckVersion checks that the GTK library in use is compatible with the given
// version.
// 
// Generally you would pass in the constants GTK_MAJOR_VERSION,
// GTK_MINOR_VERSION, GTK_MICRO_VERSION as the three arguments to this function;
// that produces a check that the library in use is compatible with the version
// of GTK the application or module was compiled against.
// 
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
// 
// This function is primarily for GTK modules; the module can call this function
// to check that it wasnt loaded into an incompatible version of GTK. However,
// such a check isnt completely reliable, since the module may be linked
// against an old version of GTK and calling the old version of
// gtk_check_version(), but still get loaded into an application using a newer
// version of GTK.
	func CheckVersion(requiredMajor uint, requiredMinor uint, requiredMicro uint) string {
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _cret *C.char // in

_arg1 = (C.guint)(requiredMajor)
_arg2 = (C.guint)(requiredMinor)
_arg3 = (C.guint)(requiredMicro)

_cret = C.gtk_check_version(_arg1, _arg2, _arg3)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}


	// DisableSetlocale prevents [id@gtk_init] and [id@gtk_init_check] from
// automatically calling `setlocale (LC_ALL, "")`.
// 
// You would want to use this function if you wanted to set the locale for your
// program to something other than the users locale, or if you wanted to set
// different values for different locale categories.
// 
// Most programs should not need to call this function.
	func DisableSetlocale()  {
C.gtk_disable_setlocale()
}


	// DistributeNaturalAllocation distributes @extra_space to child @sizes by
// bringing smaller children up to natural size first.
// 
// The remaining space will be added to the @minimum_size member of the
// `GtkRequestedSize` struct. If all sizes reach their natural size then the
// remaining space is returned.
	func DistributeNaturalAllocation(extraSpace int, sizes []RequestedSize) int {
var _arg1 C.int // out
var _arg3 *C.GtkRequestedSize
var _arg2 C.guint
var _cret C.int // in

_arg1 = (C.int)(extraSpace)
_arg2 = C.guint(len(sizes))
_arg3 = (*C.GtkRequestedSize)(unsafe.Pointer(&sizes[0]))

_cret = C.gtk_distribute_natural_allocation(_arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}


	// GetBinaryAge returns the binary age as passed to `libtool`.
// 
// If `libtool` means nothing to you, don't worry about it.
	func GetBinaryAge() uint {
var _cret C.guint // in

_cret = C.gtk_get_binary_age()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetDebugFlags returns the GTK debug flags that are currently active.
// 
// This function is intended for GTK modules that want to adjust their debug
// output based on GTK debug flags.
	func GetDebugFlags() DebugFlags {
var _cret C.GtkDebugFlags // in

_cret = C.gtk_get_debug_flags()


var _debugFlags DebugFlags // out

_debugFlags = DebugFlags(_cret)

return _debugFlags
}


	// GetDefaultLanguage returns the Language for the default language currently in
// effect. (Note that this can change over the life of an application.) The
// default language is derived from the current locale. It determines, for
// example, whether GTK uses the right-to-left or left-to-right text direction.
// 
// This function is equivalent to pango_language_get_default(). See that
// function for details.
	func GetDefaultLanguage() *pango.Language {
var _cret *C.PangoLanguage // in

_cret = C.gtk_get_default_language()


var _language *pango.Language // out

_language = *(**pango.Language)(unsafe.Pointer(&_cret))

return _language
}


	// GetInterfaceAge returns the interface age as passed to `libtool`.
// 
// If `libtool` means nothing to you, don't worry about it.
	func GetInterfaceAge() uint {
var _cret C.guint // in

_cret = C.gtk_get_interface_age()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetLocaleDirection: get the direction of the current locale. This is the
// expected reading direction for text and UI.
// 
// This function depends on the current locale being set with setlocale() and
// will default to setting the GTK_TEXT_DIR_LTR direction otherwise.
// GTK_TEXT_DIR_NONE will never be returned.
// 
// GTK sets the default text direction according to the locale during
// gtk_init(), and you should normally use gtk_widget_get_direction() or
// gtk_widget_get_default_direction() to obtain the current direction.
// 
// This function is only needed rare cases when the locale is changed after GTK
// has already been initialized. In this case, you can use it to update the
// default text direction as follows:
// 
//    setlocale (LC_ALL, new_locale);
//    direction = gtk_get_locale_direction ();
//    gtk_widget_set_default_direction (direction);
	func GetLocaleDirection() TextDirection {
var _cret C.GtkTextDirection // in

_cret = C.gtk_get_locale_direction()


var _textDirection TextDirection // out

_textDirection = TextDirection(_cret)

return _textDirection
}


	// GetMajorVersion returns the major version number of the GTK library.
// 
// For example, in GTK version 3.1.5 this is 3.
// 
// This function is in the library, so it represents the GTK library your code
// is running against. Contrast with the GTK_MAJOR_VERSION macro, which
// represents the major version of the GTK headers you have included when
// compiling your code.
	func GetMajorVersion() uint {
var _cret C.guint // in

_cret = C.gtk_get_major_version()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetMicroVersion returns the micro version number of the GTK library.
// 
// For example, in GTK version 3.1.5 this is 5.
// 
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MICRO_VERSION macro, which
// represents the micro version of the GTK headers you have included when
// compiling your code.
	func GetMicroVersion() uint {
var _cret C.guint // in

_cret = C.gtk_get_micro_version()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// GetMinorVersion returns the minor version number of the GTK library.
// 
// For example, in GTK version 3.1.5 this is 1.
// 
// This function is in the library, so it represents the GTK library your code
// is are running against. Contrast with the GTK_MINOR_VERSION macro, which
// represents the minor version of the GTK headers you have included when
// compiling your code.
	func GetMinorVersion() uint {
var _cret C.guint // in

_cret = C.gtk_get_minor_version()


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}


	// HSVToRGB converts a color from HSV space to RGB.
// 
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
	func HSVToRGB(h float32, s float32, v float32) (r float32, g float32, b float32) {
var _arg1 C.float // out
var _arg2 C.float // out
var _arg3 C.float // out
var _arg4 C.float // in
var _arg5 C.float // in
var _arg6 C.float // in

_arg1 = (C.float)(h)
_arg2 = (C.float)(s)
_arg3 = (C.float)(v)

C.gtk_hsv_to_rgb(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

var _r float32 // out
var _g float32 // out
var _b float32 // out

_r = (float32)(_arg4)
_g = (float32)(_arg5)
_b = (float32)(_arg6)

return _r, _g, _b
}


	// Init: call this function before using any other GTK functions in your GUI
// applications. It will initialize everything needed to operate the toolkit and
// parses some standard command line options.
// 
// If you are using Application, you don't have to call gtk_init() or
// gtk_init_check(); the #GApplication::startup handler does it for you.
// 
// This function will terminate your program if it was unable to initialize the
// windowing system for some reason. If you want your program to fall back to a
// textual interface you want to call gtk_init_check() instead.
// 
// GTK calls `signal (SIGPIPE, SIG_IGN)` during initialization, to ignore
// SIGPIPE signals, since these are almost never wanted in graphical
// applications. If you do need to handle SIGPIPE for some reason, reset the
// handler after gtk_init(), but notice that other libraries (e.g. libdbus or
// gvfs) might do similar things.
	func Init()  {
C.gtk_init()
}


	// InitCheck: this function does the same work as gtk_init() with only a single
// change: It does not terminate the program if the windowing system cant be
// initialized. Instead it returns false on failure.
// 
// This way the application can fall back to some other means of communication
// with the user - for example a curses or command line interface.
	func InitCheck() bool {
var _cret C.gboolean // in

_cret = C.gtk_init_check()


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// IsInitialized: use this function to check if GTK has been initialized with
// gtk_init() or gtk_init_check().
	func IsInitialized() bool {
var _cret C.gboolean // in

_cret = C.gtk_is_initialized()


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// PrintRunPageSetupDialog runs a page setup dialog, letting the user modify the
// values from @page_setup. If the user cancels the dialog, the returned
// PageSetup is identical to the passed in @page_setup, otherwise it contains
// the modifications done in the dialog.
// 
// Note that this function may use a recursive mainloop to show the page setup
// dialog. See gtk_print_run_page_setup_dialog_async() if this is a problem.
	func PrintRunPageSetupDialog(parent WindowClass, pageSetup PageSetupClass, settings PrintSettingsClass) PageSetup {
var _arg1 *C.GtkWindow // out
var _arg2 *C.GtkPageSetup // out
var _arg3 *C.GtkPrintSettings // out
var _cret *C.GtkPageSetup // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))
_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

_cret = C.gtk_print_run_page_setup_dialog(_arg1, _arg2, _arg3)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}


	// RenderActivity renders an activity indicator (such as in Spinner). The state
// GTK_STATE_FLAG_CHECKED determines whether there is activity going on.
	func RenderActivity(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_activity(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderArrow renders an arrow pointing to @angle.
// 
// Typical arrow rendering at 0, 12 ;, ; and 32 :
// 
// ! (arrows.png)
	func RenderArrow(context StyleContextClass, cr *cairo.Context, angle float64, x float64, y float64, size float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(angle)
_arg4 = (C.double)(x)
_arg5 = (C.double)(y)
_arg6 = (C.double)(size)

C.gtk_render_arrow(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderBackground renders the background of an element.
// 
// Typical background rendering, showing the effect of `background-image`,
// `border-width` and `border-radius`:
// 
// ! (background.png)
	func RenderBackground(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_background(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderCheck renders a checkmark (as in a CheckButton).
// 
// The GTK_STATE_FLAG_CHECKED state determines whether the check is on or off,
// and GTK_STATE_FLAG_INCONSISTENT determines whether it should be marked as
// undefined.
// 
// Typical checkmark rendering:
// 
// ! (checks.png)
	func RenderCheck(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_check(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderExpander renders an expander (as used in TreeView and Expander) in the
// area defined by @x, @y, @width, @height. The state GTK_STATE_FLAG_CHECKED
// determines whether the expander is collapsed or expanded.
// 
// Typical expander rendering:
// 
// ! (expanders.png)
	func RenderExpander(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_expander(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderFocus renders a focus indicator on the rectangle determined by @x, @y,
// @width, @height.
// 
// Typical focus rendering:
// 
// ! (focus.png)
	func RenderFocus(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_focus(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderFrame renders a frame around the rectangle defined by @x, @y, @width,
// @height.
// 
// Examples of frame rendering, showing the effect of `border-image`,
// `border-color`, `border-width`, `border-radius` and junctions:
// 
// ! (frames.png)
	func RenderFrame(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_frame(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderHandle renders a handle (as in Paned and Windows resize grip), in the
// rectangle determined by @x, @y, @width, @height.
// 
// Handles rendered for the paned and grip classes:
// 
// ! (handles.png)
	func RenderHandle(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_handle(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderIcon renders the icon in @texture at the specified @x and @y
// coordinates.
// 
// This function will render the icon in @texture at exactly its size,
// regardless of scaling factors, which may not be appropriate when drawing on
// displays with high pixel densities.
	func RenderIcon(context StyleContextClass, cr *cairo.Context, texture gdk.TextureClass, x float64, y float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 *C.GdkTexture // out
var _arg4 C.double // out
var _arg5 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
_arg4 = (C.double)(x)
_arg5 = (C.double)(y)

C.gtk_render_icon(_arg1, _arg2, _arg3, _arg4, _arg5)
}


	// RenderLayout renders @layout on the coordinates @x, @y
	func RenderLayout(context StyleContextClass, cr *cairo.Context, x float64, y float64, layout pango.LayoutClass)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 *C.PangoLayout // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

C.gtk_render_layout(_arg1, _arg2, _arg3, _arg4, _arg5)
}


	// RenderLine renders a line from (x0, y0) to (x1, y1).
	func RenderLine(context StyleContextClass, cr *cairo.Context, x0 float64, y0 float64, x1 float64, y1 float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x0)
_arg4 = (C.double)(y0)
_arg5 = (C.double)(x1)
_arg6 = (C.double)(y1)

C.gtk_render_line(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RenderOption renders an option mark (as in a radio button), the
// GTK_STATE_FLAG_CHECKED state will determine whether the option is on or off,
// and GTK_STATE_FLAG_INCONSISTENT whether it should be marked as undefined.
// 
// Typical option mark rendering:
// 
// ! (options.png)
	func RenderOption(context StyleContextClass, cr *cairo.Context, x float64, y float64, width float64, height float64)  {
var _arg1 *C.GtkStyleContext // out
var _arg2 *C.cairo_t // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg3 = (C.double)(x)
_arg4 = (C.double)(y)
_arg5 = (C.double)(width)
_arg6 = (C.double)(height)

C.gtk_render_option(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}


	// RGBToHSV converts a color from RGB space to HSV.
// 
// Input values must be in the [0.0, 1.0] range; output values will be in the
// same range.
	func RGBToHSV(r float32, g float32, b float32) (h float32, s float32, v float32) {
var _arg1 C.float // out
var _arg2 C.float // out
var _arg3 C.float // out
var _arg4 C.float // in
var _arg5 C.float // in
var _arg6 C.float // in

_arg1 = (C.float)(r)
_arg2 = (C.float)(g)
_arg3 = (C.float)(b)

C.gtk_rgb_to_hsv(_arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6)

var _h float32 // out
var _s float32 // out
var _v float32 // out

_h = (float32)(_arg4)
_s = (float32)(_arg5)
_v = (float32)(_arg6)

return _h, _s, _v
}


	// SetDebugFlags sets the GTK debug flags.
	func SetDebugFlags(flags DebugFlags)  {
var _arg1 C.GtkDebugFlags // out

_arg1 = (C.GtkDebugFlags)(flags)

C.gtk_set_debug_flags(_arg1)
}


	// ShowURI: this function launches the default application for showing a given
// uri, or shows an error dialog if that fails.
	func ShowURI(parent WindowClass, uri string, timestamp uint32)  {
var _arg1 *C.GtkWindow // out
var _arg2 *C.char // out
var _arg3 C.guint32 // out

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.guint32)(timestamp)

C.gtk_show_uri(_arg1, _arg2, _arg3)
}


	// ShowURIFullFinish finishes the gtk_show_uri() call and returns the result of
// the operation.
	func ShowURIFullFinish(parent WindowClass, result gio.AsyncResult) error {
var _arg1 *C.GtkWindow // out
var _arg2 *C.GAsyncResult // out
var _cerr *C.GError // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (*C.GAsyncResult)(unsafe.Pointer(result.Native()))

C.gtk_show_uri_full_finish(_arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}


	
	func TestAccessibleAssertionMessageRole(domain string, file string, line int, fn string, expr string, accessible Accessible, expectedRole AccessibleRole, actualRole AccessibleRole)  {
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 C.int // out
var _arg4 *C.char // out
var _arg5 *C.char // out
var _arg6 *C.GtkAccessible // out
var _arg7 C.GtkAccessibleRole // out
var _arg8 C.GtkAccessibleRole // out

_arg1 = (*C.char)(C.CString(domain))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(file))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(line)
_arg4 = (*C.char)(C.CString(fn))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.char)(C.CString(expr))
defer C.free(unsafe.Pointer(_arg5))
_arg6 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
_arg7 = (C.GtkAccessibleRole)(expectedRole)
_arg8 = (C.GtkAccessibleRole)(actualRole)

C.gtk_test_accessible_assertion_message_role(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}


	// TestAccessibleHasProperty checks whether the Accessible has @property set.
	func TestAccessibleHasProperty(accessible Accessible, property AccessibleProperty) bool {
var _arg1 *C.GtkAccessible // out
var _arg2 C.GtkAccessibleProperty // out
var _cret C.gboolean // in

_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
_arg2 = (C.GtkAccessibleProperty)(property)

_cret = C.gtk_test_accessible_has_property(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestAccessibleHasRelation checks whether the Accessible has @relation set.
	func TestAccessibleHasRelation(accessible Accessible, relation AccessibleRelation) bool {
var _arg1 *C.GtkAccessible // out
var _arg2 C.GtkAccessibleRelation // out
var _cret C.gboolean // in

_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
_arg2 = (C.GtkAccessibleRelation)(relation)

_cret = C.gtk_test_accessible_has_relation(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestAccessibleHasRole checks whether the Accessible:accessible-role of the
// accessible is @role.
	func TestAccessibleHasRole(accessible Accessible, role AccessibleRole) bool {
var _arg1 *C.GtkAccessible // out
var _arg2 C.GtkAccessibleRole // out
var _cret C.gboolean // in

_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
_arg2 = (C.GtkAccessibleRole)(role)

_cret = C.gtk_test_accessible_has_role(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestAccessibleHasState checks whether the Accessible has @state set.
	func TestAccessibleHasState(accessible Accessible, state AccessibleState) bool {
var _arg1 *C.GtkAccessible // out
var _arg2 C.GtkAccessibleState // out
var _cret C.gboolean // in

_arg1 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
_arg2 = (C.GtkAccessibleState)(state)

_cret = C.gtk_test_accessible_has_state(_arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}


	// TestRegisterAllTypes: force registration of all core GTK object types.
// 
// This allowes to refer to any of those object types via g_type_from_name()
// after calling this function.
	func TestRegisterAllTypes()  {
C.gtk_test_register_all_types()
}


	// TestWidgetWaitForDraw enters the main loop and waits for @widget to be
// drawn.
// 
// In this context that means it waits for the frame clock of @widget to have
// run a full styling, layout and drawing cycle.
// 
// This function is intended to be used for syncing with actions that depend on
// @widget relayouting or on interaction with the display server.
	func TestWidgetWaitForDraw(widget WidgetClass)  {
var _arg1 *C.GtkWidget // out

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_test_widget_wait_for_draw(_arg1)
}


	// TreeCreateRowDragContent creates a content provider for dragging @path from
// @tree_model.
	func TreeCreateRowDragContent(treeModel TreeModel, path *TreePath) gdk.ContentProvider {
var _arg1 *C.GtkTreeModel // out
var _arg2 *C.GtkTreePath // out
var _cret *C.GdkContentProvider // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_create_row_drag_content(_arg1, _arg2)


var _contentProvider gdk.ContentProvider // out

_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.ContentProvider)

return _contentProvider
}


	// TreeGetRowDragData obtains a @tree_model and @path from value of target type
// GTK_TYPE_TREE_ROW_DATA.
// 
// The returned path must be freed with gtk_tree_path_free().
	func TreeGetRowDragData(value **externglib.Value) (TreeModel, *TreePath, bool) {
var _arg1 *C.GValue // out
var _arg2 *C.GtkTreeModel // in
var _path *TreePath
var _cret C.gboolean // in

_arg1 = (*C.GValue)(value.GValue)

_cret = C.gtk_tree_get_row_drag_data(_arg1, &_arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)))


var _treeModel TreeModel // out

var _ok bool // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeModel)

if _cret != 0 { _ok = true }

return _treeModel, _path, _ok
}


	// ValueDupExpression retrieves the `GtkExpression` stored inside the given
// `value`, and acquires a reference to it.
	func ValueDupExpression(value **externglib.Value) Expression {
var _arg1 *C.GValue // out
var _cret *C.GtkExpression // in

_arg1 = (*C.GValue)(value.GValue)

_cret = C.gtk_value_dup_expression(_arg1)


var _expression Expression // out

_expression = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Expression)

return _expression
}


	// ValueGetExpression retrieves the `GtkExpression` stored inside the given
// `value`.
	func ValueGetExpression(value **externglib.Value) Expression {
var _arg1 *C.GValue // out
var _cret *C.GtkExpression // in

_arg1 = (*C.GValue)(value.GValue)

_cret = C.gtk_value_get_expression(_arg1)


var _expression Expression // out

_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

return _expression
}


	// ValueSetExpression stores the given `GtkExpression` inside `value`.
// 
// The `GValue` will acquire a reference to the `expression`.
	func ValueSetExpression(value **externglib.Value, expression ExpressionClass)  {
var _arg1 *C.GValue // out
var _arg2 *C.GtkExpression // out

_arg1 = (*C.GValue)(value.GValue)
_arg2 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

C.gtk_value_set_expression(_arg1, _arg2)
}


	// ValueTakeExpression stores the given `GtkExpression` inside `value`.
// 
// This function transfers the ownership of the `expression` to the `GValue`.
	func ValueTakeExpression(value **externglib.Value, expression ExpressionClass)  {
var _arg1 *C.GValue // out
var _arg2 *C.GtkExpression // out

_arg1 = (*C.GValue)(value.GValue)
_arg2 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

C.gtk_value_take_expression(_arg1, _arg2)
}


	

	// Accessible: `GtkAccessible` is an interface for describing UI elements for
// Assistive Technologies.
// 
// Every accessible implementation has:
// 
//    - a role, represented by a value of the [enum@Gtk.AccessibleRole]
//      enumeration
//    - an attribute, represented by a set of [enum@Gtk.AccessibleState],
//      [enum@Gtk.AccessibleProperty] and [enum@Gtk.AccessibleRelation] values
// 
// The role cannot be changed after instantiating a `GtkAccessible`
// implementation.
// 
// The attributes are updated every time a UI element's state changes in a way
// that should be reflected by assistive technologies. For instance, if a
// `GtkWidget` visibility changes, the GTK_ACCESSIBLE_STATE_HIDDEN state will
// also change to reflect the [property@Gtk.Widget:visible] property.
	type Accessible struct {
		**externglib.Object
		
	}

	
	func marshalAccessible(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AccessibleRole retrieves the `GtkAccessibleRole` for the given
// `GtkAccessible`.
	func (s Accessible) AccessibleRole() AccessibleRole {
var _arg0 *C.GtkAccessible // out
var _cret C.GtkAccessibleRole // in

_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))

_cret = C.gtk_accessible_get_accessible_role(_arg0)


var _accessibleRole AccessibleRole // out

_accessibleRole = AccessibleRole(_cret)

return _accessibleRole
}
	
	// ResetProperty resets the accessible @property to its default value.
	func (s Accessible) ResetProperty(property AccessibleProperty)  {
var _arg0 *C.GtkAccessible // out
var _arg1 C.GtkAccessibleProperty // out

_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkAccessibleProperty)(property)

C.gtk_accessible_reset_property(_arg0, _arg1)
}
	
	// ResetRelation resets the accessible @relation to its default value.
	func (s Accessible) ResetRelation(relation AccessibleRelation)  {
var _arg0 *C.GtkAccessible // out
var _arg1 C.GtkAccessibleRelation // out

_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkAccessibleRelation)(relation)

C.gtk_accessible_reset_relation(_arg0, _arg1)
}
	
	// ResetState resets the accessible @state to its default value.
	func (s Accessible) ResetState(state AccessibleState)  {
var _arg0 *C.GtkAccessible // out
var _arg1 C.GtkAccessibleState // out

_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkAccessibleState)(state)

C.gtk_accessible_reset_state(_arg0, _arg1)
}
	
	// UpdatePropertyValue updates an array of accessible properties.
// 
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
// 
// This function is meant to be used by language bindings.
	func (s Accessible) UpdatePropertyValue(properties []AccessibleProperty, values []**externglib.Value)  {
var _arg0 *C.GtkAccessible // out
var _arg2 *C.GtkAccessibleProperty
var _arg1 C.int
var _arg3 *C.GValue
var _arg1 C.int

_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
_arg1 = C.int(len(properties))
_arg2 = (*C.GtkAccessibleProperty)(C.malloc(C.ulong(len(properties)) * C.ulong(C.sizeof_GtkAccessibleProperty)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(properties))
for i := range properties {
out[i] = (C.GtkAccessibleProperty)(properties[i])
}
}
_arg1 = C.int(len(values))
_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_accessible_update_property_value(_arg0, _arg1, _arg2, _arg3)
}
	
	// UpdateRelationValue updates an array of accessible relations.
// 
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
// 
// This function is meant to be used by language bindings.
	func (s Accessible) UpdateRelationValue(relations []AccessibleRelation, values []**externglib.Value)  {
var _arg0 *C.GtkAccessible // out
var _arg2 *C.GtkAccessibleRelation
var _arg1 C.int
var _arg3 *C.GValue
var _arg1 C.int

_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
_arg1 = C.int(len(relations))
_arg2 = (*C.GtkAccessibleRelation)(C.malloc(C.ulong(len(relations)) * C.ulong(C.sizeof_GtkAccessibleRelation)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(relations))
for i := range relations {
out[i] = (C.GtkAccessibleRelation)(relations[i])
}
}
_arg1 = C.int(len(values))
_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_accessible_update_relation_value(_arg0, _arg1, _arg2, _arg3)
}
	
	// UpdateStateValue updates an array of accessible states.
// 
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
// 
// This function is meant to be used by language bindings.
	func (s Accessible) UpdateStateValue(states []AccessibleState, values []**externglib.Value)  {
var _arg0 *C.GtkAccessible // out
var _arg2 *C.GtkAccessibleState
var _arg1 C.int
var _arg3 *C.GValue
var _arg1 C.int

_arg0 = (*C.GtkAccessible)(unsafe.Pointer(s.Native()))
_arg1 = C.int(len(states))
_arg2 = (*C.GtkAccessibleState)(C.malloc(C.ulong(len(states)) * C.ulong(C.sizeof_GtkAccessibleState)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(states))
for i := range states {
out[i] = (C.GtkAccessibleState)(states[i])
}
}
_arg1 = C.int(len(values))
_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_accessible_update_state_value(_arg0, _arg1, _arg2, _arg3)
}
	


	
	// ActionableInterface contains virtual methods for Actionable, or
	// methods that can be overridden.
	type ActionableInterface interface {
		gextras.Objector

			// ActionName gets the action name for @actionable.
		ActionName() string
			// ActionTargetValue gets the current target value of @actionable.
		ActionTargetValue() *glib.Variant
			// SetActionName specifies the name of the action with which this widget
	// should be associated.
	// 
	// If @action_name is nil then the widget will be unassociated from any
	// previous action.
	// 
	// Usually this function is used when the widget is located (or will be
	// located) within the hierarchy of a `GtkApplicationWindow`.
	// 
	// Names are of the form win.save or app.quit for actions on the
	// containing `GtkApplicationWindow` or its associated `GtkApplication`,
	// respectively. This is the same form used for actions in the `GMenu`
	// associated with the window.
		SetActionName(actionName string) 
			// SetActionTargetValue sets the target value of an actionable widget.
	// 
	// If @target_value is nil then the target value is unset.
	// 
	// The target value has two purposes. First, it is used as the parameter to
	// activation of the action associated with the `GtkActionable` widget.
	// Second, it is used to determine if the widget should be rendered as
	// active  the widget is active if the state is equal to the given
	// target.
	// 
	// Consider the example of associating a set of buttons with a `GAction`
	// with string state in a typical radio button situation. Each button will
	// be associated with the same action, but with a different target value for
	// that action. Clicking on a particular button will activate the action
	// with the target of that button, which will typically cause the actions
	// state to change to that value. Since the actions state is now equal to
	// the target value of the button, the button will now be rendered as active
	// (and the other buttons, with different targets, rendered inactive).
		SetActionTargetValue(targetValue *glib.Variant) 
		
	}
	

	// Actionable: the `GtkActionable` interface provides a convenient way of
// asscociating widgets with actions.
// 
// It primarily consists of two properties:
// [property@Gtk.Actionable:action-name] and
// [property@Gtk.Actionable:action-target]. There are also some convenience APIs
// for setting these properties.
// 
// The action will be looked up in action groups that are found among the
// widgets ancestors. Most commonly, these will be the actions with the win.
// or app. prefix that are associated with the `GtkApplicationWindow` or
// `GtkApplication`, but other action groups that are added with
// [method@Gtk.Widget.insert_action_group] will be consulted as well.
	type Actionable struct {
		Widget
		
	}

	
	func marshalActionable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// ActionName gets the action name for @actionable.
	func (a Actionable) ActionName() string {
var _arg0 *C.GtkActionable // out
var _cret *C.char // in

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

_cret = C.gtk_actionable_get_action_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ActionTargetValue gets the current target value of @actionable.
	func (a Actionable) ActionTargetValue() *glib.Variant {
var _arg0 *C.GtkActionable // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))

_cret = C.gtk_actionable_get_action_target_value(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// SetActionName specifies the name of the action with which this widget should
// be associated.
// 
// If @action_name is nil then the widget will be unassociated from any previous
// action.
// 
// Usually this function is used when the widget is located (or will be located)
// within the hierarchy of a `GtkApplicationWindow`.
// 
// Names are of the form win.save or app.quit for actions on the containing
// `GtkApplicationWindow` or its associated `GtkApplication`, respectively. This
// is the same form used for actions in the `GMenu` associated with the window.
	func (a Actionable) SetActionName(actionName string)  {
var _arg0 *C.GtkActionable // out
var _arg1 *C.char // out

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_actionable_set_action_name(_arg0, _arg1)
}
	
	// SetActionTargetValue sets the target value of an actionable widget.
// 
// If @target_value is nil then the target value is unset.
// 
// The target value has two purposes. First, it is used as the parameter to
// activation of the action associated with the `GtkActionable` widget. Second,
// it is used to determine if the widget should be rendered as active  the
// widget is active if the state is equal to the given target.
// 
// Consider the example of associating a set of buttons with a `GAction` with
// string state in a typical radio button situation. Each button will be
// associated with the same action, but with a different target value for that
// action. Clicking on a particular button will activate the action with the
// target of that button, which will typically cause the actions state to
// change to that value. Since the actions state is now equal to the target
// value of the button, the button will now be rendered as active (and the other
// buttons, with different targets, rendered inactive).
	func (a Actionable) SetActionTargetValue(targetValue *glib.Variant)  {
var _arg0 *C.GtkActionable // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(targetValue.Native()))

C.gtk_actionable_set_action_target_value(_arg0, _arg1)
}
	
	// SetDetailedActionName sets the action-name and associated string target value
// of an actionable widget.
// 
// @detailed_action_name is a string in the format accepted by
// g_action_parse_detailed_name().
	func (a Actionable) SetDetailedActionName(detailedActionName string)  {
var _arg0 *C.GtkActionable // out
var _arg1 *C.char // out

_arg0 = (*C.GtkActionable)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(detailedActionName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_actionable_set_detailed_action_name(_arg0, _arg1)
}
	


	

	// AppChooser: `GtkAppChooser` is an interface for widgets which allow the user
// to choose an application.
// 
// The main objects that implement this interface are
// [class@Gtk.AppChooserWidget], [class@Gtk.AppChooserDialog] and
// [class@Gtk.AppChooserButton].
// 
// Applications are represented by GIO `GAppInfo` objects here. GIO has a
// concept of recommended and fallback applications for a given content type.
// Recommended applications are those that claim to handle the content type
// itself, while fallback also includes applications that handle a more generic
// content type. GIO also knows the default and last-used application for a
// given content type. The `GtkAppChooserWidget` provides detailed control over
// whether the shown list of applications should include default, recommended or
// fallback applications.
// 
// To obtain the application that has been selected in a `GtkAppChooser`, use
// [method@Gtk.AppChooser.get_app_info].
	type AppChooser struct {
		Widget
		
	}

	
	func marshalAppChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AppInfo returns the currently selected application.
	func (s AppChooser) AppInfo() gio.AppInfo {
var _arg0 *C.GtkAppChooser // out
var _cret *C.GAppInfo // in

_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_get_app_info(_arg0)


var _appInfo gio.AppInfo // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)

return _appInfo
}
	
	// ContentType returns the content type for which the `GtkAppChooser` shows
// applications.
	func (s AppChooser) ContentType() string {
var _arg0 *C.GtkAppChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_get_content_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Refresh reloads the list of applications.
	func (s AppChooser) Refresh()  {
var _arg0 *C.GtkAppChooser // out

_arg0 = (*C.GtkAppChooser)(unsafe.Pointer(s.Native()))

C.gtk_app_chooser_refresh(_arg0)
}
	


	
	// BuildableInterface contains virtual methods for Buildable, or
	// methods that can be overridden.
	type BuildableInterface interface {
		gextras.Objector

			// AddChild adds a child to @buildable. @type is an optional string
	// describing how the child should be added.
		AddChild(builder BuilderClass, child **externglib.Object, typ string) 
		
		ID() string
			// InternalChild retrieves the internal child called @childname of the
	// @buildable object.
		InternalChild(builder BuilderClass, childname string) **externglib.Object
		
		ParserFinished(builder BuilderClass) 
		
		SetBuildableProperty(builder BuilderClass, name string, value **externglib.Value) 
		
		SetID(id string) 
		
	}
	

	// Buildable: `GtkBuildable` allows objects to extend and customize their
// deserialization from ui files.
// 
// The interface includes methods for setting names and properties of objects,
// parsing custom tags and constructing child objects.
// 
// The `GtkBuildable` interface is implemented by all widgets and many of the
// non-widget objects that are provided by GTK. The main user of this interface
// is [class@Gtk.Builder]. There should be very little need for applications to
// call any of these functions directly.
// 
// An object only needs to implement this interface if it needs to extend the
// `GtkBuilder` XML format or run any extra routines at deserialization time.
	type Buildable struct {
		**externglib.Object
		
	}

	
	func marshalBuildable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// BuildableID gets the ID of the @buildable object.
// 
// `GtkBuilder` sets the name based on the ID attribute of the <object> tag used
// to construct the @buildable.
	func (b Buildable) BuildableID() string {
var _arg0 *C.GtkBuildable // out
var _cret *C.char // in

_arg0 = (*C.GtkBuildable)(unsafe.Pointer(b.Native()))

_cret = C.gtk_buildable_get_buildable_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	
	// BuilderScopeInterface contains virtual methods for BuilderScope, or
	// methods that can be overridden.
	type BuilderScopeInterface interface {
		gextras.Objector

		
		TypeFromFunction(builder BuilderClass, functionName string) externglib.Type
		
		TypeFromName(builder BuilderClass, typeName string) externglib.Type
		
	}
	

	// BuilderScope: `GtkBuilderScope` is an interface to provide language binding
// support to `GtkBuilder`.
// 
// The goal of `GtkBuilderScope` is to look up programming-language-specific
// values for strings that are given in a `GtkBuilder` UI file.
// 
// The primary intended audience is bindings that want to provide deeper
// integration of `GtkBuilder` into the language.
// 
// A `GtkBuilderScope` instance may be used with multiple `GtkBuilder` objects,
// even at once.
// 
// By default, GTK will use its own implementation of `GtkBuilderScope` for the
// C language which can be created via [ctor@Gtk.BuilderCScope.new].
	type BuilderScope struct {
		**externglib.Object
		
	}

	
	func marshalBuilderScope(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {BuilderScope{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	
	// CellEditableInterface contains virtual methods for CellEditable, or
	// methods that can be overridden.
	type CellEditableInterface interface {
		gextras.Objector

			// EditingDone emits the CellEditable::editing-done signal.
		EditingDone() 
			// RemoveWidget emits the CellEditable::remove-widget signal.
		RemoveWidget() 
			// StartEditing begins editing on a @cell_editable.
	// 
	// The CellRenderer for the cell creates and returns a CellEditable from
	// gtk_cell_renderer_start_editing(), configured for the CellRenderer type.
	// 
	// gtk_cell_editable_start_editing() can then set up @cell_editable suitably
	// for editing a cell, e.g. making the Esc key emit
	// CellEditable::editing-done.
	// 
	// Note that the @cell_editable is created on-demand for the current edit;
	// its lifetime is temporary and does not persist across other edits and/or
	// cells.
		StartEditing(event gdk.EventClass) 
		
	}
	

	// CellEditable: interface for widgets that can be used for editing cells
// 
// The CellEditable interface must be implemented for widgets to be usable to
// edit the contents of a TreeView cell. It provides a way to specify how
// temporary widgets should be configured for editing, get the new value, etc.
	type CellEditable struct {
		Widget
		
	}

	
	func marshalCellEditable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// EditingDone emits the CellEditable::editing-done signal.
	func (c CellEditable) EditingDone()  {
var _arg0 *C.GtkCellEditable // out

_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

C.gtk_cell_editable_editing_done(_arg0)
}
	
	// RemoveWidget emits the CellEditable::remove-widget signal.
	func (c CellEditable) RemoveWidget()  {
var _arg0 *C.GtkCellEditable // out

_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))

C.gtk_cell_editable_remove_widget(_arg0)
}
	
	// StartEditing begins editing on a @cell_editable.
// 
// The CellRenderer for the cell creates and returns a CellEditable from
// gtk_cell_renderer_start_editing(), configured for the CellRenderer type.
// 
// gtk_cell_editable_start_editing() can then set up @cell_editable suitably for
// editing a cell, e.g. making the Esc key emit CellEditable::editing-done.
// 
// Note that the @cell_editable is created on-demand for the current edit; its
// lifetime is temporary and does not persist across other edits and/or cells.
	func (c CellEditable) StartEditing(event gdk.EventClass)  {
var _arg0 *C.GtkCellEditable // out
var _arg1 *C.GdkEvent // out

_arg0 = (*C.GtkCellEditable)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

C.gtk_cell_editable_start_editing(_arg0, _arg1)
}
	


	
	// CellLayoutInterface contains virtual methods for CellLayout, or
	// methods that can be overridden.
	type CellLayoutInterface interface {
		gextras.Objector

			// AddAttribute adds an attribute mapping to the list in @cell_layout.
	// 
	// The @column is the column of the model to get a value from, and the
	// @attribute is the parameter on @cell to be set from the value. So for
	// example if column 2 of the model contains strings, you could have the
	// text attribute of a CellRendererText get its values from column 2.
		AddAttribute(cell CellRendererClass, attribute string, column int) 
			// Clear unsets all the mappings on all renderers on @cell_layout and
	// removes all renderers from @cell_layout.
		Clear() 
			// ClearAttributes clears all existing attributes previously set with
	// gtk_cell_layout_set_attributes().
		ClearAttributes(cell CellRendererClass) 
			// Area returns the underlying CellArea which might be @cell_layout if
	// called on a CellArea or might be nil if no CellArea is used by
	// @cell_layout.
		Area() CellArea
			// PackEnd adds the @cell to the end of @cell_layout. If @expand is false,
	// then the @cell is allocated no more space than it needs. Any unused space
	// is divided evenly between cells for which @expand is true.
	// 
	// Note that reusing the same cell renderer is not supported.
		PackEnd(cell CellRendererClass, expand bool) 
			// PackStart packs the @cell into the beginning of @cell_layout. If @expand
	// is false, then the @cell is allocated no more space than it needs. Any
	// unused space is divided evenly between cells for which @expand is true.
	// 
	// Note that reusing the same cell renderer is not supported.
		PackStart(cell CellRendererClass, expand bool) 
			// Reorder re-inserts @cell at @position.
	// 
	// Note that @cell has already to be packed into @cell_layout for this to
	// function properly.
		Reorder(cell CellRendererClass, position int) 
		
	}
	

	// CellLayout: an interface for packing cells
// 
// CellLayout is an interface to be implemented by all objects which want to
// provide a TreeViewColumn like API for packing cells, setting attributes and
// data funcs.
// 
// One of the notable features provided by implementations of GtkCellLayout are
// attributes. Attributes let you set the properties in flexible ways. They can
// just be set to constant values like regular properties. But they can also be
// mapped to a column of the underlying tree model with
// gtk_cell_layout_set_attributes(), which means that the value of the attribute
// can change from cell to cell as they are rendered by the cell renderer.
// Finally, it is possible to specify a function with
// gtk_cell_layout_set_cell_data_func() that is called to determine the value of
// the attribute for each cell that is rendered.
// 
// 
// GtkCellLayouts as GtkBuildable
// 
// Implementations of GtkCellLayout which also implement the GtkBuildable
// interface (CellView, IconView, ComboBox, EntryCompletion, TreeViewColumn)
// accept GtkCellRenderer objects as <child> elements in UI definitions. They
// support a custom <attributes> element for their children, which can contain
// multiple <attribute> elements. Each <attribute> element has a name attribute
// which specifies a property of the cell renderer; the content of the element
// is the attribute value.
// 
// This is an example of a UI definition fragment specifying attributes:
// 
//    <object class="GtkCellView">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <attributes>
//          <attribute name="text">0</attribute>
//        </attributes>
//      </child>"
//    </object>
// 
// Furthermore for implementations of GtkCellLayout that use a CellArea to lay
// out cells (all GtkCellLayouts in GTK use a GtkCellArea) [cell
// properties][cell-properties] can also be defined in the format by specifying
// the custom <cell-packing> attribute which can contain multiple <property>
// elements defined in the normal way.
// 
// Here is a UI definition fragment specifying cell properties:
// 
//    <object class="GtkTreeViewColumn">
//      <child>
//        <object class="GtkCellRendererText"/>
//        <cell-packing>
//          <property name="align">True</property>
//          <property name="expand">False</property>
//        </cell-packing>
//      </child>"
//    </object>
// 
// 
// Subclassing GtkCellLayout implementations
// 
// When subclassing a widget that implements CellLayout like IconView or
// ComboBox, there are some considerations related to the fact that these
// widgets internally use a CellArea. The cell area is exposed as a
// construct-only property by these widgets. This means that it is possible to
// e.g. do
// 
//    static void
//    my_combo_box_init (MyComboBox *b)
//    {
//      GtkCellRenderer *cell;
// 
//      cell = gtk_cell_renderer_pixbuf_new ();
//      // The following call causes the default cell area for combo boxes,
//      // a GtkCellAreaBox, to be instantiated
//      gtk_cell_layout_pack_start (GTK_CELL_LAYOUT (b), cell, FALSE);
//      ...
//    }
// 
//    GtkWidget *
//    my_combo_box_new (GtkCellArea *area)
//    {
//      // This call is going to cause a warning about area being ignored
//      return g_object_new (MY_TYPE_COMBO_BOX, "cell-area", area, NULL);
//    }
// 
// If supporting alternative cell areas with your derived widget is not
// important, then this does not have to concern you. If you want to support
// alternative cell areas, you can do so by moving the problematic calls out of
// init() and into a constructor() for your class.
	type CellLayout struct {
		**externglib.Object
		
	}

	
	func marshalCellLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddAttribute adds an attribute mapping to the list in @cell_layout.
// 
// The @column is the column of the model to get a value from, and the
// @attribute is the parameter on @cell to be set from the value. So for example
// if column 2 of the model contains strings, you could have the text
// attribute of a CellRendererText get its values from column 2.
	func (c CellLayout) AddAttribute(cell CellRendererClass, attribute string, column int)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.char // out
var _arg3 C.int // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
_arg2 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(column)

C.gtk_cell_layout_add_attribute(_arg0, _arg1, _arg2, _arg3)
}
	
	// Clear unsets all the mappings on all renderers on @cell_layout and removes
// all renderers from @cell_layout.
	func (c CellLayout) Clear()  {
var _arg0 *C.GtkCellLayout // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

C.gtk_cell_layout_clear(_arg0)
}
	
	// ClearAttributes clears all existing attributes previously set with
// gtk_cell_layout_set_attributes().
	func (c CellLayout) ClearAttributes(cell CellRendererClass)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_cell_layout_clear_attributes(_arg0, _arg1)
}
	
	// Area returns the underlying CellArea which might be @cell_layout if called on
// a CellArea or might be nil if no CellArea is used by @cell_layout.
	func (c CellLayout) Area() CellArea {
var _arg0 *C.GtkCellLayout // out
var _cret *C.GtkCellArea // in

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_layout_get_area(_arg0)


var _cellArea CellArea // out

_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

return _cellArea
}
	
	// PackEnd adds the @cell to the end of @cell_layout. If @expand is false, then
// the @cell is allocated no more space than it needs. Any unused space is
// divided evenly between cells for which @expand is true.
// 
// Note that reusing the same cell renderer is not supported.
	func (c CellLayout) PackEnd(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_cell_layout_pack_end(_arg0, _arg1, _arg2)
}
	
	// PackStart packs the @cell into the beginning of @cell_layout. If @expand is
// false, then the @cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which @expand is true.
// 
// Note that reusing the same cell renderer is not supported.
	func (c CellLayout) PackStart(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_cell_layout_pack_start(_arg0, _arg1, _arg2)
}
	
	// Reorder re-inserts @cell at @position.
// 
// Note that @cell has already to be packed into @cell_layout for this to
// function properly.
	func (c CellLayout) Reorder(cell CellRendererClass, position int)  {
var _arg0 *C.GtkCellLayout // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.int // out

_arg0 = (*C.GtkCellLayout)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
_arg2 = (C.int)(position)

C.gtk_cell_layout_reorder(_arg0, _arg1, _arg2)
}
	


	
	// ColorChooserInterface contains virtual methods for ColorChooser, or
	// methods that can be overridden.
	type ColorChooserInterface interface {
		gextras.Objector

			// AddPalette adds a palette to the color chooser.
	// 
	// If @orientation is horizontal, the colors are grouped in rows, with
	// @colors_per_line colors in each row. If @horizontal is false, the colors
	// are grouped in columns instead.
	// 
	// The default color palette of [class@Gtk.ColorChooserWidget] has 45
	// colors, organized in columns of 5 colors (this includes some grays).
	// 
	// The layout of the color chooser widget works best when the palettes have
	// 9-10 columns.
	// 
	// Calling this function for the first time has the side effect of removing
	// the default color palette from the color chooser.
	// 
	// If @colors is nil, removes all previously added palettes.
		AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA) 
		
		ColorActivated(color *gdk.RGBA) 
			// RGBA gets the currently-selected color.
		RGBA() gdk.RGBA
			// SetRGBA sets the color.
		SetRGBA(color *gdk.RGBA) 
		
	}
	

	// ColorChooser: `GtkColorChooser` is an interface that is implemented by
// widgets for choosing colors.
// 
// Depending on the situation, colors may be allowed to have alpha
// (translucency).
// 
// In GTK, the main widgets that implement this interface are
// [class@Gtk.ColorChooserWidget], [class@Gtk.ColorChooserDialog] and
// [class@Gtk.ColorButton].
	type ColorChooser struct {
		**externglib.Object
		
	}

	
	func marshalColorChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddPalette adds a palette to the color chooser.
// 
// If @orientation is horizontal, the colors are grouped in rows, with
// @colors_per_line colors in each row. If @horizontal is false, the colors are
// grouped in columns instead.
// 
// The default color palette of [class@Gtk.ColorChooserWidget] has 45 colors,
// organized in columns of 5 colors (this includes some grays).
// 
// The layout of the color chooser widget works best when the palettes have 9-10
// columns.
// 
// Calling this function for the first time has the side effect of removing the
// default color palette from the color chooser.
// 
// If @colors is nil, removes all previously added palettes.
	func (c ColorChooser) AddPalette(orientation Orientation, colorsPerLine int, colors []gdk.RGBA)  {
var _arg0 *C.GtkColorChooser // out
var _arg1 C.GtkOrientation // out
var _arg2 C.int // out
var _arg4 *C.GdkRGBA
var _arg3 C.int

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (C.int)(colorsPerLine)
_arg3 = C.int(len(colors))
_arg4 = (*C.GdkRGBA)(unsafe.Pointer(&colors[0]))

C.gtk_color_chooser_add_palette(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// RGBA gets the currently-selected color.
	func (c ColorChooser) RGBA() gdk.RGBA {
var _arg0 *C.GtkColorChooser // out
var _color gdk.RGBA

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

C.gtk_color_chooser_get_rgba(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// UseAlpha returns whether the color chooser shows the alpha channel.
	func (c ColorChooser) UseAlpha() bool {
var _arg0 *C.GtkColorChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_color_chooser_get_use_alpha(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetRGBA sets the color.
	func (c ColorChooser) SetRGBA(color *gdk.RGBA)  {
var _arg0 *C.GtkColorChooser // out
var _arg1 *C.GdkRGBA // out

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

C.gtk_color_chooser_set_rgba(_arg0, _arg1)
}
	
	// SetUseAlpha sets whether or not the color chooser should use the alpha
// channel.
	func (c ColorChooser) SetUseAlpha(useAlpha bool)  {
var _arg0 *C.GtkColorChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColorChooser)(unsafe.Pointer(c.Native()))
if useAlpha { _arg1 = C.TRUE }

C.gtk_color_chooser_set_use_alpha(_arg0, _arg1)
}
	


	

	// ConstraintTarget: the `GtkConstraintTarget` interface is implemented by
// objects that can be used as source or target in `GtkConstraint`s.
// 
// Besides `GtkWidget`, it is also implemented by `GtkConstraintGuide`.
	type ConstraintTarget struct {
		**externglib.Object
		
	}

	
	func marshalConstraintTarget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	
	// EditableInterface contains virtual methods for Editable, or
	// methods that can be overridden.
	type EditableInterface interface {
		gextras.Objector

		
		Changed() 
			// DeleteText deletes a sequence of characters.
	// 
	// The characters that are deleted are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters deleted are those from @start_pos to the end of the
	// text.
	// 
	// Note that the positions are specified in characters, not bytes.
		DeleteText(startPos int, endPos int) 
			// DoDeleteText deletes a sequence of characters.
	// 
	// The characters that are deleted are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters deleted are those from @start_pos to the end of the
	// text.
	// 
	// Note that the positions are specified in characters, not bytes.
		DoDeleteText(startPos int, endPos int) 
			// Delegate gets the `GtkEditable` that @editable is delegating its
	// implementation to.
	// 
	// Typically, the delegate is a [class@Gtk.Text] widget.
		Delegate() Editable
			// SelectionBounds retrieves the selection bound of the editable.
	// 
	// @start_pos will be filled with the start of the selection and @end_pos
	// with end. If no text was selected both will be identical and false will
	// be returned.
	// 
	// Note that positions are specified in characters, not bytes.
		SelectionBounds() (startPos int, endPos int, ok bool)
			// Text retrieves the contents of @editable.
	// 
	// The returned string is owned by GTK and must not be modified or freed.
		Text() string
			// SetSelectionBounds selects a region of text.
	// 
	// The characters that are selected are those characters at positions from
	// @start_pos up to, but not including @end_pos. If @end_pos is negative,
	// then the characters selected are those characters from @start_pos to the
	// end of the text.
	// 
	// Note that positions are specified in characters, not bytes.
		SetSelectionBounds(startPos int, endPos int) 
		
	}
	

	// Editable: `GtkEditable` is an interface for text editing widgets.
// 
// Typical examples of editable widgets are [class@Gtk.Entry] and
// [class@Gtk.SpinButton]. It contains functions for generically manipulating an
// editable widget, a large number of action signals used for key bindings, and
// several signals that an application can connect to modify the behavior of a
// widget.
// 
// As an example of the latter usage, by connecting the following handler to
// [signal@Gtk.Editable::insert-text], an application can convert all entry into
// a widget into uppercase.
// 
// Forcing entry to uppercase.
// 
// `c #include <ctype.h>
// 
// void insert_text_handler (GtkEditable *editable, const char *text, int
// length, int *position, gpointer data) { char *result = g_utf8_strup (text,
// length);
// 
//    g_signal_handlers_block_by_func (editable,
//                                 (gpointer) insert_text_handler, data);
//    gtk_editable_insert_text (editable, result, length, position);
//    g_signal_handlers_unblock_by_func (editable,
//                                       (gpointer) insert_text_handler, data);
// 
//    g_signal_stop_emission_by_name (editable, "insert_text");
// 
//    g_free (result);
// 
// } `
// 
// 
// Implementing GtkEditable
// 
// The most likely scenario for implementing `GtkEditable` on your own widget is
// that you will embed a Text inside a complex widget, and want to delegate the
// editable functionality to that text widget. `GtkEditable` provides some
// utility functions to make this easy.
// 
// In your class_init function, call [func@Gtk.Editable.install_properties],
// passing the first available property ID:
// 
// `c static void my_class_init (MyClass *class) { ...
// g_object_class_install_properties (object_class, NUM_PROPERTIES, props);
// gtk_editable_install_properties (object_clas, NUM_PROPERTIES); ... } `
// 
// In your interface_init function for the `GtkEditable` interface, provide an
// implementation for the get_delegate vfunc that returns your text widget:
// 
// `c GtkEditable * get_editable_delegate (GtkEditable *editable) { return
// GTK_EDITABLE (MY_WIDGET (editable)->text_widget); }
// 
// static void my_editable_init (GtkEditableInterface *iface) {
// iface->get_delegate = get_editable_delegate; } `
// 
// You don't need to provide any other vfuncs. The default implementations work
// by forwarding to the delegate that the GtkEditableInterface.get_delegate()
// vfunc returns.
// 
// In your instance_init function, create your text widget, and then call
// [method@Gtk.Editable.init_delegate]:
// 
// `c static void my_widget_init (MyWidget *self) { ... self->text_widget =
// gtk_text_new (); gtk_editable_init_delegate (GTK_EDITABLE (self)); ... } `
// 
// In your dispose function, call [method@Gtk.Editable.finish_delegate] before
// destroying your text widget:
// 
// `c static void my_widget_dispose (GObject *object) { ...
// gtk_editable_finish_delegate (GTK_EDITABLE (self)); g_clear_pointer
// (&self->text_widget, gtk_widget_unparent); ... } `
// 
// Finally, use [func@Gtk.Editable.delegate_set_property] in your `set_property`
// function (and similar for `get_property`), to set the editable properties:
// 
// `c ... if (gtk_editable_delegate_set_property (object, prop_id, value,
// pspec)) return;
// 
//    switch (prop_id)
//    ...
// 
// `
// 
// It is important to note that if you create a `GtkEditable` that uses a
// delegate, the low level [signal@Gtk.Editable::insert-text] and
// [signal@Gtk.Editable::delete-text] signals will be propagated from the
// "wrapper" editable to the delegate, but they will not be propagated from the
// delegate to the "wrapper" editable, as they would cause an infinite
// recursion. If you wish to connect to the [signal@Gtk.Editable::insert-text]
// and [signal@Gtk.Editable::delete-text] signals, you will need to connect to
// them on the delegate obtained via [method@Gtk.Editable.get_delegate].
	type Editable struct {
		Widget
		
	}

	
	func marshalEditable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DeleteSelection deletes the currently selected text of the editable.
// 
// This call doesnt do anything if there is no selected text.
	func (e Editable) DeleteSelection()  {
var _arg0 *C.GtkEditable // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

C.gtk_editable_delete_selection(_arg0)
}
	
	// DeleteText deletes a sequence of characters.
// 
// The characters that are deleted are those characters at positions from
// @start_pos up to, but not including @end_pos. If @end_pos is negative, then
// the characters deleted are those from @start_pos to the end of the text.
// 
// Note that the positions are specified in characters, not bytes.
	func (e Editable) DeleteText(startPos int, endPos int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(startPos)
_arg2 = (C.int)(endPos)

C.gtk_editable_delete_text(_arg0, _arg1, _arg2)
}
	
	// FinishDelegate undoes the setup done by [method@Gtk.Editable.init_delegate].
// 
// This is a helper function that should be called from dispose, before removing
// the delegate object.
	func (e Editable) FinishDelegate()  {
var _arg0 *C.GtkEditable // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

C.gtk_editable_finish_delegate(_arg0)
}
	
	// Alignment gets the alignment of the editable.
	func (e Editable) Alignment() float32 {
var _arg0 *C.GtkEditable // out
var _cret C.float // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_alignment(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Chars retrieves a sequence of characters.
// 
// The characters that are retrieved are those characters at positions from
// @start_pos up to, but not including @end_pos. If @end_pos is negative, then
// the characters retrieved are those characters from @start_pos to the end of
// the text.
// 
// Note that positions are specified in characters, not bytes.
	func (e Editable) Chars(startPos int, endPos int) string {
var _arg0 *C.GtkEditable // out
var _arg1 C.int // out
var _arg2 C.int // out
var _cret *C.char // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(startPos)
_arg2 = (C.int)(endPos)

_cret = C.gtk_editable_get_chars(_arg0, _arg1, _arg2)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Delegate gets the `GtkEditable` that @editable is delegating its
// implementation to.
// 
// Typically, the delegate is a [class@Gtk.Text] widget.
	func (e Editable) Delegate() Editable {
var _arg0 *C.GtkEditable // out
var _cret *C.GtkEditable // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_delegate(_arg0)


var _ret Editable // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Editable)

return _ret
}
	
	// Editable retrieves whether @editable is editable.
	func (e Editable) Editable() bool {
var _arg0 *C.GtkEditable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_editable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EnableUndo gets if undo/redo actions are enabled for @editable
	func (e Editable) EnableUndo() bool {
var _arg0 *C.GtkEditable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_enable_undo(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MaxWidthChars retrieves the desired maximum width of @editable, in
// characters.
	func (e Editable) MaxWidthChars() int {
var _arg0 *C.GtkEditable // out
var _cret C.int // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_max_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Position retrieves the current position of the cursor relative to the start
// of the content of the editable.
// 
// Note that this position is in characters, not in bytes.
	func (e Editable) Position() int {
var _arg0 *C.GtkEditable // out
var _cret C.int // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_position(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SelectionBounds retrieves the selection bound of the editable.
// 
// @start_pos will be filled with the start of the selection and @end_pos with
// end. If no text was selected both will be identical and false will be
// returned.
// 
// Note that positions are specified in characters, not bytes.
	func (e Editable) SelectionBounds() (startPos int, endPos int, ok bool) {
var _arg0 *C.GtkEditable // out
var _arg1 C.int // in
var _arg2 C.int // in
var _cret C.gboolean // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_selection_bounds(_arg0, &_arg1, &_arg2)


var _startPos int // out
var _endPos int // out
var _ok bool // out

_startPos = (int)(_arg1)
_endPos = (int)(_arg2)
if _cret != 0 { _ok = true }

return _startPos, _endPos, _ok
}
	
	// Text retrieves the contents of @editable.
// 
// The returned string is owned by GTK and must not be modified or freed.
	func (e Editable) Text() string {
var _arg0 *C.GtkEditable // out
var _cret *C.char // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// WidthChars gets the number of characters of space reserved for the contents
// of the editable.
	func (e Editable) WidthChars() int {
var _arg0 *C.GtkEditable // out
var _cret C.int // in

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

_cret = C.gtk_editable_get_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InitDelegate sets up a delegate for `GtkEditable`.
// 
// This is assuming that the get_delegate vfunc in the `GtkEditable` interface
// has been set up for the @editable's type.
// 
// This is a helper function that should be called in instance init, after
// creating the delegate object.
	func (e Editable) InitDelegate()  {
var _arg0 *C.GtkEditable // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))

C.gtk_editable_init_delegate(_arg0)
}
	
	// SelectRegion selects a region of text.
// 
// The characters that are selected are those characters at positions from
// @start_pos up to, but not including @end_pos. If @end_pos is negative, then
// the characters selected are those characters from @start_pos to the end of
// the text.
// 
// Note that positions are specified in characters, not bytes.
	func (e Editable) SelectRegion(startPos int, endPos int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(startPos)
_arg2 = (C.int)(endPos)

C.gtk_editable_select_region(_arg0, _arg1, _arg2)
}
	
	// SetAlignment sets the alignment for the contents of the editable.
// 
// This controls the horizontal positioning of the contents when the displayed
// text is shorter than the width of the editable.
	func (e Editable) SetAlignment(xalign float32)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.float // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.float)(xalign)

C.gtk_editable_set_alignment(_arg0, _arg1)
}
	
	// SetEditable determines if the user can edit the text in the editable widget.
	func (e Editable) SetEditable(isEditable bool)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
if isEditable { _arg1 = C.TRUE }

C.gtk_editable_set_editable(_arg0, _arg1)
}
	
	// SetEnableUndo: if enabled, changes to @editable will be saved for undo/redo
// actions.
// 
// This results in an additional copy of text changes and are not stored in
// secure memory. As such, undo is forcefully disabled when
// [property@Gtk.Text:visibility] is set to false.
	func (e Editable) SetEnableUndo(enableUndo bool)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
if enableUndo { _arg1 = C.TRUE }

C.gtk_editable_set_enable_undo(_arg0, _arg1)
}
	
	// SetMaxWidthChars sets the desired maximum width in characters of @editable.
	func (e Editable) SetMaxWidthChars(nChars int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.int // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(nChars)

C.gtk_editable_set_max_width_chars(_arg0, _arg1)
}
	
	// SetPosition sets the cursor position in the editable to the given value.
// 
// The cursor is displayed before the character with the given (base 0) index in
// the contents of the editable. The value must be less than or equal to the
// number of characters in the editable. A value of -1 indicates that the
// position should be set after the last character of the editable. Note that
// @position is in characters, not in bytes.
	func (e Editable) SetPosition(position int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.int // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(position)

C.gtk_editable_set_position(_arg0, _arg1)
}
	
	// SetText sets the text in the editable to the given value.
// 
// This is replacing the current contents.
	func (e Editable) SetText(text string)  {
var _arg0 *C.GtkEditable // out
var _arg1 *C.char // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_editable_set_text(_arg0, _arg1)
}
	
	// SetWidthChars changes the size request of the editable to be about the right
// size for @n_chars characters.
// 
// Note that it changes the size request, the size can still be affected by how
// you pack the widget into containers. If @n_chars is -1, the size reverts to
// the default size.
	func (e Editable) SetWidthChars(nChars int)  {
var _arg0 *C.GtkEditable // out
var _arg1 C.int // out

_arg0 = (*C.GtkEditable)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(nChars)

C.gtk_editable_set_width_chars(_arg0, _arg1)
}
	


	

	// FileChooser: `GtkFileChooser` is an interface that can be implemented by file
// selection widgets.
// 
// In GTK, the main objects that implement this interface are
// [class@Gtk.FileChooserWidget] and [class@Gtk.FileChooserDialog].
// 
// You do not need to write an object that implements the `GtkFileChooser`
// interface unless you are trying to adapt an existing file selector to expose
// a standard programming interface.
// 
// `GtkFileChooser` allows for shortcuts to various places in the filesystem. In
// the default implementation these are displayed in the left pane. It may be a
// bit confusing at first that these shortcuts come from various sources and in
// various flavours, so lets explain the terminology here:
// 
// - Bookmarks: are created by the user, by dragging folders from the right pane
// to the left pane, or by using the Add. Bookmarks can be renamed and deleted
// by the user.
// 
// - Shortcuts: can be provided by the application. For example, a Paint program
// may want to add a shortcut for a Clipart folder. Shortcuts cannot be modified
// by the user.
// 
// - Volumes: are provided by the underlying filesystem abstraction. They are
// the roots of the filesystem.
// 
// 
// File Names and Encodings
// 
// When the user is finished selecting files in a `GtkFileChooser`, your program
// can get the selected filenames as `GFile`s.
// 
// 
// Adding options
// 
// You can add extra widgets to a file chooser to provide options that are not
// present in the default design, by using [method@Gtk.FileChooser.add_choice].
// Each choice has an identifier and a user visible label; additionally, each
// choice can have multiple options. If a choice has no option, it will be
// rendered as a check button with the given label; if a choice has options, it
// will be rendered as a combo box.
	type FileChooser struct {
		**externglib.Object
		
	}

	
	func marshalFileChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// AddChoice adds a 'choice' to the file chooser.
// 
// This is typically implemented as a combobox or, for boolean choices, as a
// checkbutton. You can select a value using [method@Gtk.FileChooser.set_choice]
// before the dialog is shown, and you can obtain the user-selected value in the
// [signal@Gtk.Dialog::response] signal handler using
// [method@Gtk.FileChooser.get_choice].
	func (c FileChooser) AddChoice(id string, label string, options []string, optionLabels []string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 **C.char
var _arg4 **C.char

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (**C.char)(C.malloc(C.ulong(len(options)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(options))
for i := range options {
out[i] = (*C.char)(C.CString(options[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}
_arg4 = (**C.char)(C.malloc(C.ulong(len(optionLabels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg4))
{
out := unsafe.Slice(_arg4, len(optionLabels))
for i := range optionLabels {
out[i] = (*C.char)(C.CString(optionLabels[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_file_chooser_add_choice(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// AddFilter adds @filter to the list of filters that the user can select
// between.
// 
// When a filter is selected, only files that are passed by that filter are
// displayed.
// 
// Note that the @chooser takes ownership of the filter if it is floating, so
// you have to ref and sink it if you want to keep a reference.
	func (c FileChooser) AddFilter(filter FileFilterClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

C.gtk_file_chooser_add_filter(_arg0, _arg1)
}
	
	// AddShortcutFolder adds a folder to be displayed with the shortcut folders in
// a file chooser.
	func (c FileChooser) AddShortcutFolder(folder gio.File) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

C.gtk_file_chooser_add_shortcut_folder(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Action gets the type of operation that the file chooser is performing.
	func (c FileChooser) Action() FileChooserAction {
var _arg0 *C.GtkFileChooser // out
var _cret C.GtkFileChooserAction // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_action(_arg0)


var _fileChooserAction FileChooserAction // out

_fileChooserAction = FileChooserAction(_cret)

return _fileChooserAction
}
	
	// Choice gets the currently selected option in the 'choice' with the given ID.
	func (c FileChooser) Choice(id string) string {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_file_chooser_get_choice(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// CreateFolders gets whether file chooser will offer to create new folders.
	func (c FileChooser) CreateFolders() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_create_folders(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CurrentFolder gets the current folder of @chooser as #GFile.
	func (c FileChooser) CurrentFolder() gio.File {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GFile // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_current_folder(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// CurrentName gets the current name in the file selector, as entered by the
// user.
// 
// This is meant to be used in save dialogs, to get the currently typed filename
// when the file itself does not exist yet.
	func (c FileChooser) CurrentName() string {
var _arg0 *C.GtkFileChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_current_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// File gets the `GFile` for the currently selected file in the file selector.
// 
// If multiple files are selected, one of the files will be returned at random.
// 
// If the file chooser is in folder mode, this function returns the selected
// folder.
	func (c FileChooser) File() gio.File {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GFile // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// Files lists all the selected files and subfolders in the current folder of
// @chooser as #GFile.
	func (c FileChooser) Files() gio.ListModel {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_files(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Filter gets the current filter.
	func (c FileChooser) Filter() FileFilter {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GtkFileFilter // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_filter(_arg0)


var _fileFilter FileFilter // out

_fileFilter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FileFilter)

return _fileFilter
}
	
	// Filters gets the current set of user-selectable filters, as a list model.
// 
// See [method@Gtk.FileChooser.add_filter] and
// [method@Gtk.FileChooser.remove_filter] for changing individual filters.
// 
// You should not modify the returned list model. Future changes to @chooser may
// or may not affect the returned model.
	func (c FileChooser) Filters() gio.ListModel {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_filters(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// SelectMultiple gets whether multiple files can be selected in the file
// chooser.
	func (c FileChooser) SelectMultiple() bool {
var _arg0 *C.GtkFileChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_select_multiple(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShortcutFolders queries the list of shortcut folders in the file chooser.
// 
// You should not modify the returned list model. Future changes to @chooser may
// or may not affect the returned model.
	func (c FileChooser) ShortcutFolders() gio.ListModel {
var _arg0 *C.GtkFileChooser // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))

_cret = C.gtk_file_chooser_get_shortcut_folders(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// RemoveChoice removes a 'choice' that has been added with
// gtk_file_chooser_add_choice().
	func (c FileChooser) RemoveChoice(id string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_remove_choice(_arg0, _arg1)
}
	
	// RemoveFilter removes @filter from the list of filters that the user can
// select between.
	func (c FileChooser) RemoveFilter(filter FileFilterClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

C.gtk_file_chooser_remove_filter(_arg0, _arg1)
}
	
	// RemoveShortcutFolder removes a folder from the shortcut folders in a file
// chooser.
	func (c FileChooser) RemoveShortcutFolder(folder gio.File) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(folder.Native()))

C.gtk_file_chooser_remove_shortcut_folder(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetAction sets the type of operation that the chooser is performing.
// 
// The user interface is adapted to suit the selected action.
// 
// For example, an option to create a new folder might be shown if the action is
// GTK_FILE_CHOOSER_ACTION_SAVE but not if the action is
// GTK_FILE_CHOOSER_ACTION_OPEN.
	func (c FileChooser) SetAction(action FileChooserAction)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.GtkFileChooserAction // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkFileChooserAction)(action)

C.gtk_file_chooser_set_action(_arg0, _arg1)
}
	
	// SetChoice selects an option in a 'choice' that has been added with
// gtk_file_chooser_add_choice().
// 
// For a boolean choice, the possible options are "true" and "false".
	func (c FileChooser) SetChoice(id string, option string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(option))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_file_chooser_set_choice(_arg0, _arg1, _arg2)
}
	
	// SetCreateFolders sets whether file chooser will offer to create new folders.
// 
// This is only relevant if the action is not set to be
// GTK_FILE_CHOOSER_ACTION_OPEN.
	func (c FileChooser) SetCreateFolders(createFolders bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if createFolders { _arg1 = C.TRUE }

C.gtk_file_chooser_set_create_folders(_arg0, _arg1)
}
	
	// SetCurrentFolder sets the current folder for @chooser from a #GFile.
	func (c FileChooser) SetCurrentFolder(file gio.File) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_file_chooser_set_current_folder(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetCurrentName sets the current name in the file selector, as if entered by
// the user.
// 
// Note that the name passed in here is a UTF-8 string rather than a filename.
// This function is meant for such uses as a suggested name in a Save As...
// dialog. You can pass Untitled.doc or a similarly suitable suggestion for
// the @name.
// 
// If you want to preselect a particular existing file, you should use
// [method@Gtk.FileChooser.set_file] instead.
// 
// Please see the documentation for those functions for an example of using
// [method@Gtk.FileChooser.set_current_name] as well.
	func (c FileChooser) SetCurrentName(name string)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_set_current_name(_arg0, _arg1)
}
	
	// SetFile sets @file as the current filename for the file chooser.
// 
// This includes changing to the files parent folder and actually selecting the
// file in list. If the @chooser is in GTK_FILE_CHOOSER_ACTION_SAVE mode, the
// files base name will also appear in the dialogs file name entry.
// 
// If the file name isnt in the current folder of @chooser, then the current
// folder of @chooser will be changed to the folder containing @filename.
// 
// Note that the file must exist, or nothing will be done except for the
// directory change.
// 
// If you are implementing a save dialog, you should use this function if you
// already have a file name to which the user may save; for example, when the
// user opens an existing file and then does Save As. If you dont have a
// file name already  for example, if the user just created a new file and is
// saving it for the first time, do not call this function.
// 
// Instead, use something similar to this:
// 
// `c static void prepare_file_chooser (GtkFileChooser *chooser, GFile
// *existing_file) { gboolean document_is_new = (existing_file == NULL);
// 
//    if (document_is_new)
//      {
//        GFile *default_file_for_saving = g_file_new_for_path ("./out.txt");
//        // the user just created a new document
//        gtk_file_chooser_set_current_folder (chooser, default_file_for_saving, NULL);
//        gtk_file_chooser_set_current_name (chooser, "Untitled document");
//        g_object_unref (default_file_for_saving);
//      }
//    else
//      {
//        // the user edited an existing document
//        gtk_file_chooser_set_file (chooser, existing_file, NULL);
//      }
// 
// } `
	func (c FileChooser) SetFile(file gio.File) error {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GFile // out
var _cerr *C.GError // in

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_file_chooser_set_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetFilter sets the current filter.
// 
// Only the files that pass the filter will be displayed. If the user-selectable
// list of filters is non-empty, then the filter should be one of the filters in
// that list.
// 
// Setting the current filter when the list of filters is empty is useful if you
// want to restrict the displayed set of files without letting the user change
// it.
	func (c FileChooser) SetFilter(filter FileFilterClass)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkFileFilter)(unsafe.Pointer(filter.Native()))

C.gtk_file_chooser_set_filter(_arg0, _arg1)
}
	
	// SetSelectMultiple sets whether multiple files can be selected in the file
// chooser.
// 
// This is only relevant if the action is set to be GTK_FILE_CHOOSER_ACTION_OPEN
// or GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
	func (c FileChooser) SetSelectMultiple(selectMultiple bool)  {
var _arg0 *C.GtkFileChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFileChooser)(unsafe.Pointer(c.Native()))
if selectMultiple { _arg1 = C.TRUE }

C.gtk_file_chooser_set_select_multiple(_arg0, _arg1)
}
	


	
	// FontChooserInterface contains virtual methods for FontChooser, or
	// methods that can be overridden.
	type FontChooserInterface interface {
		gextras.Objector

		
		FontActivated(fontname string) 
			// FontFace gets the `PangoFontFace` representing the selected font group
	// details (i.e. family, slant, weight, width, etc).
	// 
	// If the selected font is not installed, returns nil.
		FontFace() pango.FontFace
			// FontFamily gets the `PangoFontFamily` representing the selected font
	// family.
	// 
	// Font families are a collection of font faces.
	// 
	// If the selected font is not installed, returns nil.
		FontFamily() pango.FontFamily
			// FontMap gets the custom font map of this font chooser widget, or nil if
	// it does not have one.
		FontMap() pango.FontMap
			// FontSize: the selected font size.
		FontSize() int
			// SetFontMap sets a custom font map to use for this font chooser widget.
	// 
	// A custom font map can be used to present application-specific fonts
	// instead of or in addition to the normal system fonts.
	// 
	// `c FcConfig *config; PangoFontMap *fontmap;
	// 
	// config = FcInitLoadConfigAndFonts (); FcConfigAppFontAddFile (config,
	// my_app_font_file);
	// 
	// fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
	// pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
	// 
	// gtk_font_chooser_set_font_map (font_chooser, fontmap); `
	// 
	// Note that other GTK widgets will only be able to use the
	// application-specific font if it is present in the font map they use:
	// 
	// `c context = gtk_widget_get_pango_context (label);
	// pango_context_set_font_map (context, fontmap); `
		SetFontMap(fontmap pango.FontMapClass) 
		
	}
	

	// FontChooser: `GtkFontChooser` is an interface that can be implemented by
// widgets for choosing fonts.
// 
// In GTK, the main objects that implement this interface are
// [class@Gtk.FontChooserWidget], [class@Gtk.FontChooserDialog] and
// [class@Gtk.FontButton].
	type FontChooser struct {
		**externglib.Object
		
	}

	
	func marshalFontChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Font gets the currently-selected font name.
// 
// Note that this can be a different string than what you set with
// [method@Gtk.FontChooser.set_font], as the font chooser widget may normalize
// font names and thus return a string with a different structure. For example,
// Helvetica Italic Bold 12 could be normalized to Helvetica Bold Italic 12.
// 
// Use [method@Pango.FontDescription.equal] if you want to compare two font
// descriptions.
	func (f FontChooser) Font() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// FontDesc gets the currently-selected font.
// 
// Note that this can be a different string than what you set with
// [method@Gtk.FontChooser.set_font], as the font chooser widget may normalize
// font names and thus return a string with a different structure. For example,
// Helvetica Italic Bold 12 could be normalized to Helvetica Bold Italic 12.
// 
// Use [method@Pango.FontDescription.equal] if you want to compare two font
// descriptions.
	func (f FontChooser) FontDesc() *pango.FontDescription {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontDescription // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_desc(_arg0)


var _fontDescription *pango.FontDescription // out

_fontDescription = *(**pango.FontDescription)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_fontDescription, func(v *pango.FontDescription) {
  C.free(unsafe.Pointer(v.Native()))
})

return _fontDescription
}
	
	// FontFace gets the `PangoFontFace` representing the selected font group
// details (i.e. family, slant, weight, width, etc).
// 
// If the selected font is not installed, returns nil.
	func (f FontChooser) FontFace() pango.FontFace {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontFace // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_face(_arg0)


var _fontFace pango.FontFace // out

_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFace)

return _fontFace
}
	
	// FontFamily gets the `PangoFontFamily` representing the selected font family.
// 
// Font families are a collection of font faces.
// 
// If the selected font is not installed, returns nil.
	func (f FontChooser) FontFamily() pango.FontFamily {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontFamily // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_family(_arg0)


var _fontFamily pango.FontFamily // out

_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontFamily)

return _fontFamily
}
	
	// FontFeatures gets the currently-selected font features.
	func (f FontChooser) FontFeatures() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_features(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// FontMap gets the custom font map of this font chooser widget, or nil if it
// does not have one.
	func (f FontChooser) FontMap() pango.FontMap {
var _arg0 *C.GtkFontChooser // out
var _cret *C.PangoFontMap // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_map(_arg0)


var _fontMap pango.FontMap // out

_fontMap = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.FontMap)

return _fontMap
}
	
	// FontSize: the selected font size.
	func (f FontChooser) FontSize() int {
var _arg0 *C.GtkFontChooser // out
var _cret C.int // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_font_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Language gets the language that is used for font features.
	func (f FontChooser) Language() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_language(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Level returns the current level of granularity for selecting fonts.
	func (f FontChooser) Level() FontChooserLevel {
var _arg0 *C.GtkFontChooser // out
var _cret C.GtkFontChooserLevel // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_level(_arg0)


var _fontChooserLevel FontChooserLevel // out

_fontChooserLevel = FontChooserLevel(_cret)

return _fontChooserLevel
}
	
	// PreviewText gets the text displayed in the preview area.
	func (f FontChooser) PreviewText() string {
var _arg0 *C.GtkFontChooser // out
var _cret *C.char // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_preview_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// ShowPreviewEntry returns whether the preview entry is shown or not.
	func (f FontChooser) ShowPreviewEntry() bool {
var _arg0 *C.GtkFontChooser // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_chooser_get_show_preview_entry(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetFont sets the currently-selected font.
	func (f FontChooser) SetFont(fontname string)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(fontname))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_chooser_set_font(_arg0, _arg1)
}
	
	// SetFontDesc sets the currently-selected font from @font_desc.
	func (f FontChooser) SetFontDesc(fontDesc *pango.FontDescription)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.PangoFontDescription // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(fontDesc.Native()))

C.gtk_font_chooser_set_font_desc(_arg0, _arg1)
}
	
	// SetFontMap sets a custom font map to use for this font chooser widget.
// 
// A custom font map can be used to present application-specific fonts instead
// of or in addition to the normal system fonts.
// 
// `c FcConfig *config; PangoFontMap *fontmap;
// 
// config = FcInitLoadConfigAndFonts (); FcConfigAppFontAddFile (config,
// my_app_font_file);
// 
// fontmap = pango_cairo_font_map_new_for_font_type (CAIRO_FONT_TYPE_FT);
// pango_fc_font_map_set_config (PANGO_FC_FONT_MAP (fontmap), config);
// 
// gtk_font_chooser_set_font_map (font_chooser, fontmap); `
// 
// Note that other GTK widgets will only be able to use the application-specific
// font if it is present in the font map they use:
// 
// `c context = gtk_widget_get_pango_context (label);
// pango_context_set_font_map (context, fontmap); `
	func (f FontChooser) SetFontMap(fontmap pango.FontMapClass)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.PangoFontMap // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontmap.Native()))

C.gtk_font_chooser_set_font_map(_arg0, _arg1)
}
	
	// SetLanguage sets the language to use for font features.
	func (f FontChooser) SetLanguage(language string)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(language))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_chooser_set_language(_arg0, _arg1)
}
	
	// SetLevel sets the desired level of granularity for selecting fonts.
	func (f FontChooser) SetLevel(level FontChooserLevel)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 C.GtkFontChooserLevel // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (C.GtkFontChooserLevel)(level)

C.gtk_font_chooser_set_level(_arg0, _arg1)
}
	
	// SetPreviewText sets the text displayed in the preview area.
// 
// The @text is used to show how the selected font looks.
	func (f FontChooser) SetPreviewText(text string)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_chooser_set_preview_text(_arg0, _arg1)
}
	
	// SetShowPreviewEntry shows or hides the editable preview entry.
	func (f FontChooser) SetShowPreviewEntry(showPreviewEntry bool)  {
var _arg0 *C.GtkFontChooser // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontChooser)(unsafe.Pointer(f.Native()))
if showPreviewEntry { _arg1 = C.TRUE }

C.gtk_font_chooser_set_show_preview_entry(_arg0, _arg1)
}
	


	

	// Native: `GtkNative` is the interface implemented by all widgets that have
// their own `GdkSurface`.
// 
// The obvious example of a `GtkNative` is `GtkWindow`.
// 
// Every widget that is not itself a `GtkNative` is contained in one, and you
// can get it with [method@Gtk.Widget.get_native].
// 
// To get the surface of a `GtkNative`, use [method@Gtk.Native.get_surface]. It
// is also possible to find the `GtkNative` to which a surface belongs, with
// [func@Gtk.Native.get_for_surface].
// 
// In addition to a [class@Gdk.Surface], a `GtkNative` also provides a
// [class@Gsk.Renderer] for rendering on that surface. To get the renderer, use
// [method@Gtk.Native.get_renderer].
	type Native struct {
		Widget
		
	}

	
	func marshalNative(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Renderer returns the renderer that is used for this `GtkNative`.
	func (s Native) Renderer() gsk.Renderer {
var _arg0 *C.GtkNative // out
var _cret *C.GskRenderer // in

_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_get_renderer(_arg0)


var _renderer gsk.Renderer // out

_renderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gsk.Renderer)

return _renderer
}
	
	// Surface returns the surface of this `GtkNative`.
	func (s Native) Surface() gdk.Surface {
var _arg0 *C.GtkNative // out
var _cret *C.GdkSurface // in

_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_get_surface(_arg0)


var _surface gdk.Surface // out

_surface = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Surface)

return _surface
}
	
	// SurfaceTransform retrieves the surface transform of @self.
// 
// This is the translation from @self's surface coordinates into @self's widget
// coordinates.
	func (s Native) SurfaceTransform() (x float64, y float64) {
var _arg0 *C.GtkNative // out
var _arg1 C.double // in
var _arg2 C.double // in

_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

C.gtk_native_get_surface_transform(_arg0, &_arg1, &_arg2)

var _x float64 // out
var _y float64 // out

_x = (float64)(_arg1)
_y = (float64)(_arg2)

return _x, _y
}
	
	// Realize realizes a `GtkNative`.
// 
// This should only be used by subclasses.
	func (s Native) Realize()  {
var _arg0 *C.GtkNative // out

_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

C.gtk_native_realize(_arg0)
}
	
	// Unrealize unrealizes a `GtkNative`.
// 
// This should only be used by subclasses.
	func (s Native) Unrealize()  {
var _arg0 *C.GtkNative // out

_arg0 = (*C.GtkNative)(unsafe.Pointer(s.Native()))

C.gtk_native_unrealize(_arg0)
}
	


	

	// Orientable: the `GtkOrientable` interface is implemented by all widgets that
// can be oriented horizontally or vertically.
// 
// `GtkOrientable` is more flexible in that it allows the orientation to be
// changed at runtime, allowing the widgets to flip.
	type Orientable struct {
		**externglib.Object
		
	}

	
	func marshalOrientable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Orientation retrieves the orientation of the @orientable.
	func (o Orientable) Orientation() Orientation {
var _arg0 *C.GtkOrientable // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))

_cret = C.gtk_orientable_get_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// SetOrientation sets the orientation of the @orientable.
	func (o Orientable) SetOrientation(orientation Orientation)  {
var _arg0 *C.GtkOrientable // out
var _arg1 C.GtkOrientation // out

_arg0 = (*C.GtkOrientable)(unsafe.Pointer(o.Native()))
_arg1 = (C.GtkOrientation)(orientation)

C.gtk_orientable_set_orientation(_arg0, _arg1)
}
	


	
	// PrintOperationPreviewInterface contains virtual methods for PrintOperationPreview, or
	// methods that can be overridden.
	type PrintOperationPreviewInterface interface {
		gextras.Objector

			// EndPreview ends a preview.
	// 
	// This function must be called to finish a custom print preview.
		EndPreview() 
		
		GotPageSize(context PrintContextClass, pageSetup PageSetupClass) 
			// IsSelected returns whether the given page is included in the set of pages
	// that have been selected for printing.
		IsSelected(pageNr int) bool
		
		Ready(context PrintContextClass) 
			// RenderPage renders a page to the preview.
	// 
	// This is using the print context that was passed to the
	// [signal@Gtk.PrintOperation::preview] handler together with @preview.
	// 
	// A custom print preview should use this function to render the currently
	// selected page.
	// 
	// Note that this function requires a suitable cairo context to be
	// associated with the print context.
		RenderPage(pageNr int) 
		
	}
	

	// PrintOperationPreview: `GtkPrintOperationPreview` is the interface that is
// used to implement print preview.
// 
// A `GtkPrintOperationPreview` object is passed to the
// [signal@Gtk.PrintOperation::preview] signal by [class@Gtk.PrintOperation].
	type PrintOperationPreview struct {
		**externglib.Object
		
	}

	
	func marshalPrintOperationPreview(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {PrintOperationPreview{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// EndPreview ends a preview.
// 
// This function must be called to finish a custom print preview.
	func (p PrintOperationPreview) EndPreview()  {
var _arg0 *C.GtkPrintOperationPreview // out

_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))

C.gtk_print_operation_preview_end_preview(_arg0)
}
	
	// IsSelected returns whether the given page is included in the set of pages
// that have been selected for printing.
	func (p PrintOperationPreview) IsSelected(pageNr int) bool {
var _arg0 *C.GtkPrintOperationPreview // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
_arg1 = (C.int)(pageNr)

_cret = C.gtk_print_operation_preview_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RenderPage renders a page to the preview.
// 
// This is using the print context that was passed to the
// [signal@Gtk.PrintOperation::preview] handler together with @preview.
// 
// A custom print preview should use this function to render the currently
// selected page.
// 
// Note that this function requires a suitable cairo context to be associated
// with the print context.
	func (p PrintOperationPreview) RenderPage(pageNr int)  {
var _arg0 *C.GtkPrintOperationPreview // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintOperationPreview)(unsafe.Pointer(p.Native()))
_arg1 = (C.int)(pageNr)

C.gtk_print_operation_preview_render_page(_arg0, _arg1)
}
	


	

	// Root: `GtkRoot` is the interface implemented by all widgets that can act as a
// toplevel widget.
// 
// The root widget takes care of providing the connection to the windowing
// system and manages layout, drawing and event delivery for its widget
// hierarchy.
// 
// The obvious example of a `GtkRoot` is `GtkWindow`.
// 
// To get the display to which a `GtkRoot` belongs, use
// [method@Gtk.Root.get_display].
// 
// `GtkRoot` also maintains the location of keyboard focus inside its widget
// hierarchy, with [method@Gtk.Root.set_focus] and [method@Gtk.Root.get_focus].
	type Root struct {
		Native
		Widget
		
	}

	
	func marshalRoot(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Display returns the display that this `GtkRoot` is on.
	func (s Root) Display() gdk.Display {
var _arg0 *C.GtkRoot // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkRoot)(unsafe.Pointer(s.Native()))

_cret = C.gtk_root_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// Focus retrieves the current focused widget within the root.
// 
// Note that this is the widget that would have the focus if the root is active;
// if the root is not focused then `gtk_widget_has_focus (widget)` will be false
// for the widget.
	func (s Root) Focus() Widget {
var _arg0 *C.GtkRoot // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkRoot)(unsafe.Pointer(s.Native()))

_cret = C.gtk_root_get_focus(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetFocus: if @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the root.
// 
// If @focus is nil, unsets the focus widget for the root.
// 
// To set the focus to a particular widget in the root, it is usually more
// convenient to use [method@Gtk.Widget.grab_focus] instead of this function.
	func (s Root) SetFocus(focus WidgetClass)  {
var _arg0 *C.GtkRoot // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkRoot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

C.gtk_root_set_focus(_arg0, _arg1)
}
	


	
	// ScrollableInterface contains virtual methods for Scrollable, or
	// methods that can be overridden.
	type ScrollableInterface interface {
		gextras.Objector

			// Border returns the size of a non-scrolling border around the outside of
	// the scrollable.
	// 
	// An example for this would be treeview headers. GTK can use this
	// information to display overlaid graphics, like the overshoot indication,
	// at the right position.
		Border() (Border, bool)
		
	}
	

	// Scrollable: `GtkScrollable` is an interface for widgets with native scrolling
// ability.
// 
// To implement this interface you should override the
// [property@Gtk.Scrollable:hadjustment] and
// [property@Gtk.Scrollable:vadjustment] properties.
// 
// 
// Creating a scrollable widget
// 
// All scrollable widgets should do the following.
// 
// - When a parent widget sets the scrollable child widgets adjustments, the
// widget should populate the adjustments [property@Gtk.Adjustment:lower],
// [property@Gtk.Adjustment:upper], [property@Gtk.Adjustment:step-increment],
// [property@Gtk.Adjustment:page-increment] and
// [property@Gtk.Adjustment:page-size] properties and connect to the
// [signal@Gtk.Adjustment::value-changed] signal.
// 
// - Because its preferred size is the size for a fully expanded widget, the
// scrollable widget must be able to cope with underallocations. This means that
// it must accept any value passed to its GtkWidgetClass.size_allocate()
// function.
// 
// - When the parent allocates space to the scrollable child widget, the widget
// should update the adjustments properties with new values.
// 
// - When any of the adjustments emits the
// [signal@Gtk.Adjustment::value-changed] signal, the scrollable widget should
// scroll its contents.
	type Scrollable struct {
		**externglib.Object
		
	}

	
	func marshalScrollable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Border returns the size of a non-scrolling border around the outside of the
// scrollable.
// 
// An example for this would be treeview headers. GTK can use this information
// to display overlaid graphics, like the overshoot indication, at the right
// position.
	func (s Scrollable) Border() (Border, bool) {
var _arg0 *C.GtkScrollable // out
var _border Border
var _cret C.gboolean // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_border(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_border)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _border, _ok
}
	
	// HAdjustment retrieves the `GtkAdjustment` used for horizontal scrolling.
	func (s Scrollable) HAdjustment() Adjustment {
var _arg0 *C.GtkScrollable // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// HScrollPolicy gets the horizontal `GtkScrollablePolicy`.
	func (s Scrollable) HScrollPolicy() ScrollablePolicy {
var _arg0 *C.GtkScrollable // out
var _cret C.GtkScrollablePolicy // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_hscroll_policy(_arg0)


var _scrollablePolicy ScrollablePolicy // out

_scrollablePolicy = ScrollablePolicy(_cret)

return _scrollablePolicy
}
	
	// VAdjustment retrieves the `GtkAdjustment` used for vertical scrolling.
	func (s Scrollable) VAdjustment() Adjustment {
var _arg0 *C.GtkScrollable // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// VScrollPolicy gets the vertical `GtkScrollablePolicy`.
	func (s Scrollable) VScrollPolicy() ScrollablePolicy {
var _arg0 *C.GtkScrollable // out
var _cret C.GtkScrollablePolicy // in

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollable_get_vscroll_policy(_arg0)


var _scrollablePolicy ScrollablePolicy // out

_scrollablePolicy = ScrollablePolicy(_cret)

return _scrollablePolicy
}
	
	// SetHAdjustment sets the horizontal adjustment of the `GtkScrollable`.
	func (s Scrollable) SetHAdjustment(hadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrollable // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

C.gtk_scrollable_set_hadjustment(_arg0, _arg1)
}
	
	// SetHScrollPolicy sets the `GtkScrollablePolicy`.
// 
// The policy determines whether horizontal scrolling should start below the
// minimum width or below the natural width.
	func (s Scrollable) SetHScrollPolicy(policy ScrollablePolicy)  {
var _arg0 *C.GtkScrollable // out
var _arg1 C.GtkScrollablePolicy // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkScrollablePolicy)(policy)

C.gtk_scrollable_set_hscroll_policy(_arg0, _arg1)
}
	
	// SetVAdjustment sets the vertical adjustment of the `GtkScrollable`.
	func (s Scrollable) SetVAdjustment(vadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrollable // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

C.gtk_scrollable_set_vadjustment(_arg0, _arg1)
}
	
	// SetVScrollPolicy sets the `GtkScrollablePolicy`.
// 
// The policy determines whether vertical scrolling should start below the
// minimum height or below the natural height.
	func (s Scrollable) SetVScrollPolicy(policy ScrollablePolicy)  {
var _arg0 *C.GtkScrollable // out
var _arg1 C.GtkScrollablePolicy // out

_arg0 = (*C.GtkScrollable)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkScrollablePolicy)(policy)

C.gtk_scrollable_set_vscroll_policy(_arg0, _arg1)
}
	


	
	// SelectionModelInterface contains virtual methods for SelectionModel, or
	// methods that can be overridden.
	type SelectionModelInterface interface {
		gextras.Objector

			// SelectionInRange gets the set of selected items in a range.
	// 
	// This function is an optimization for
	// [method@Gtk.SelectionModel.get_selection] when you are only interested in
	// part of the model's selected state. A common use case is in response to
	// the [signal@Gtk.SelectionModel::selection-changed] signal.
		SelectionInRange(position uint, nItems uint) *Bitset
			// IsSelected checks if the given item is selected.
		IsSelected(position uint) bool
			// SelectAll requests to select all items in the model.
		SelectAll() bool
			// SelectItem requests to select an item in the model.
		SelectItem(position uint, unselectRest bool) bool
			// SelectRange requests to select a range of items in the model.
		SelectRange(position uint, nItems uint, unselectRest bool) bool
			// SetSelection: make selection changes.
	// 
	// This is the most advanced selection updating method that allows the most
	// fine-grained control over selection changes. If you can, you should try
	// the simpler versions, as implementations are more likely to implement
	// support for those.
	// 
	// Requests that the selection state of all positions set in @mask be
	// updated to the respective value in the @selected bitmask.
	// 
	// In pseudocode, it would look something like this:
	// 
	// `c for (i = 0; i < n_items; i++) { // don't change values not in the
	// mask if (!gtk_bitset_contains (mask, i)) continue;
	// 
	//      if (gtk_bitset_contains (selected, i))
	//        select_item (i);
	//      else
	//        unselect_item (i);
	//    }
	// 
	// gtk_selection_model_selection_changed (model, first_changed_item,
	// n_changed_items); `
	// 
	// @mask and @selected must not be modified. They may refer to the same
	// bitset, which would mean that every item in the set should be selected.
		SetSelection(selected *Bitset, mask *Bitset) bool
			// UnselectAll requests to unselect all items in the model.
		UnselectAll() bool
			// UnselectItem requests to unselect an item in the model.
		UnselectItem(position uint) bool
			// UnselectRange requests to unselect a range of items in the model.
		UnselectRange(position uint, nItems uint) bool
		
	}
	

	// SelectionModel: `GtkSelectionModel` is an interface that add support for
// selection to list models.
// 
// This support is then used by widgets using list models to add the ability to
// select and unselect various items.
// 
// GTK provides default implementations of the most common selection modes such
// as [class@Gtk.SingleSelection], so you will only need to implement this
// interface if you want detailed control about how selections should be
// handled.
// 
// A `GtkSelectionModel` supports a single boolean per item indicating if an
// item is selected or not. This can be queried via
// [method@Gtk.SelectionModel.is_selected]. When the selected state of one or
// more items changes, the model will emit the
// [signal@Gtk.SelectionModel::selection-changed] signal by calling the
// [method@Gtk.SelectionModel.selection_changed] function. The positions given
// in that signal may have their selection state changed, though that is not a
// requirement. If new items added to the model via the ::items-changed signal
// are selected or not is up to the implementation.
// 
// Note that items added via ::items-changed may already be selected and no
// [Gtk.SelectionModel::selection-changed] will be emitted for them. So to track
// which items are selected, it is necessary to listen to both signals.
// 
// Additionally, the interface can expose functionality to select and unselect
// items. If these functions are implemented, GTK's list widgets will allow
// users to select and unselect items. However, `GtkSelectionModel`s are free to
// only implement them partially or not at all. In that case the widgets will
// not support the unimplemented operations.
// 
// When selecting or unselecting is supported by a model, the return values of
// the selection functions do *not* indicate if selection or unselection
// happened. They are only meant to indicate complete failure, like when this
// mode of selecting is not supported by the model.
// 
// Selections may happen asynchronously, so the only reliable way to find out
// when an item was selected is to listen to the signals that indicate
// selection.
	type SelectionModel struct {
		gio.ListModel
		
	}

	
	func marshalSelectionModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {SelectionModel{
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/diamondburned/gotk4/pkg/gio/v2:gio github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// Selection gets the set containing all currently selected items in the model.
// 
// This function may be slow, so if you are only interested in single item,
// consider using [method@Gtk.SelectionModel.is_selected] or if you are only
// interested in a few, consider
// [method@Gtk.SelectionModel.get_selection_in_range].
	func (m SelectionModel) Selection() *Bitset {
var _arg0 *C.GtkSelectionModel // out
var _cret *C.GtkBitset // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))

_cret = C.gtk_selection_model_get_selection(_arg0)


var _bitset *Bitset // out

_bitset = *(**Bitset)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_bitset, func(v *Bitset) {
  C.free(unsafe.Pointer(v.Native()))
})

return _bitset
}
	
	// SelectionInRange gets the set of selected items in a range.
// 
// This function is an optimization for
// [method@Gtk.SelectionModel.get_selection] when you are only interested in
// part of the model's selected state. A common use case is in response to the
// [signal@Gtk.SelectionModel::selection-changed] signal.
	func (m SelectionModel) SelectionInRange(position uint, nItems uint) *Bitset {
var _arg0 *C.GtkSelectionModel // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _cret *C.GtkBitset // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(nItems)

_cret = C.gtk_selection_model_get_selection_in_range(_arg0, _arg1, _arg2)


var _bitset *Bitset // out

_bitset = *(**Bitset)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_bitset, func(v *Bitset) {
  C.free(unsafe.Pointer(v.Native()))
})

return _bitset
}
	
	// IsSelected checks if the given item is selected.
	func (m SelectionModel) IsSelected(position uint) bool {
var _arg0 *C.GtkSelectionModel // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(position)

_cret = C.gtk_selection_model_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectAll requests to select all items in the model.
	func (m SelectionModel) SelectAll() bool {
var _arg0 *C.GtkSelectionModel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))

_cret = C.gtk_selection_model_select_all(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectItem requests to select an item in the model.
	func (m SelectionModel) SelectItem(position uint, unselectRest bool) bool {
var _arg0 *C.GtkSelectionModel // out
var _arg1 C.guint // out
var _arg2 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(position)
if unselectRest { _arg2 = C.TRUE }

_cret = C.gtk_selection_model_select_item(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectRange requests to select a range of items in the model.
	func (m SelectionModel) SelectRange(position uint, nItems uint, unselectRest bool) bool {
var _arg0 *C.GtkSelectionModel // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(nItems)
if unselectRest { _arg3 = C.TRUE }

_cret = C.gtk_selection_model_select_range(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectionChanged: helper function for implementations of `GtkSelectionModel`.
// 
// Call this when a the selection changes to emit the
// [signal@Gtk.SelectionModel::selection-changed] signal.
	func (m SelectionModel) SelectionChanged(position uint, nItems uint)  {
var _arg0 *C.GtkSelectionModel // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(nItems)

C.gtk_selection_model_selection_changed(_arg0, _arg1, _arg2)
}
	
	// SetSelection: make selection changes.
// 
// This is the most advanced selection updating method that allows the most
// fine-grained control over selection changes. If you can, you should try the
// simpler versions, as implementations are more likely to implement support for
// those.
// 
// Requests that the selection state of all positions set in @mask be updated to
// the respective value in the @selected bitmask.
// 
// In pseudocode, it would look something like this:
// 
// `c for (i = 0; i < n_items; i++) { // don't change values not in the mask if
// (!gtk_bitset_contains (mask, i)) continue;
// 
//      if (gtk_bitset_contains (selected, i))
//        select_item (i);
//      else
//        unselect_item (i);
//    }
// 
// gtk_selection_model_selection_changed (model, first_changed_item,
// n_changed_items); `
// 
// @mask and @selected must not be modified. They may refer to the same bitset,
// which would mean that every item in the set should be selected.
	func (m SelectionModel) SetSelection(selected *Bitset, mask *Bitset) bool {
var _arg0 *C.GtkSelectionModel // out
var _arg1 *C.GtkBitset // out
var _arg2 *C.GtkBitset // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkBitset)(unsafe.Pointer(selected.Native()))
_arg2 = (*C.GtkBitset)(unsafe.Pointer(mask.Native()))

_cret = C.gtk_selection_model_set_selection(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UnselectAll requests to unselect all items in the model.
	func (m SelectionModel) UnselectAll() bool {
var _arg0 *C.GtkSelectionModel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))

_cret = C.gtk_selection_model_unselect_all(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UnselectItem requests to unselect an item in the model.
	func (m SelectionModel) UnselectItem(position uint) bool {
var _arg0 *C.GtkSelectionModel // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(position)

_cret = C.gtk_selection_model_unselect_item(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UnselectRange requests to unselect a range of items in the model.
	func (m SelectionModel) UnselectRange(position uint, nItems uint) bool {
var _arg0 *C.GtkSelectionModel // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSelectionModel)(unsafe.Pointer(m.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(nItems)

_cret = C.gtk_selection_model_unselect_range(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// ShortcutManagerInterface contains virtual methods for ShortcutManager, or
	// methods that can be overridden.
	type ShortcutManagerInterface interface {
		gextras.Objector

		
		AddController(controller ShortcutControllerClass) 
		
		RemoveController(controller ShortcutControllerClass) 
		
	}
	

	// ShortcutManager: the `GtkShortcutManager` interface is used to implement
// shortcut scopes.
// 
// This is important for [iface@Gtk.Native] widgets that have their own surface,
// since the event controllers that are used to implement managed and global
// scopes are limited to the same native.
// 
// Examples for widgets implementing `GtkShortcutManager` are [class@Gtk.Window]
// and [class@Gtk.Popover].
// 
// Every widget that implements `GtkShortcutManager` will be used as a
// GTK_SHORTCUT_SCOPE_MANAGED.
	type ShortcutManager struct {
		**externglib.Object
		
	}

	
	func marshalShortcutManager(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	

	// StyleProvider: `GtkStyleProvider` is an interface for style information used
// by `GtkStyleContext`.
// 
// See [method@Gtk.StyleContext.add_provider] and
// [func@Gtk.StyleContext.add_provider_for_display] for adding
// `GtkStyleProviders`.
// 
// GTK uses the `GtkStyleProvider` implementation for CSS in
// [iface@Gtk.CssProvider].
	type StyleProvider struct {
		**externglib.Object
		
	}

	
	func marshalStyleProvider(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {StyleProvider{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	


	
	// TreeDragDestInterface contains virtual methods for TreeDragDest, or
	// methods that can be overridden.
	type TreeDragDestInterface interface {
		gextras.Objector

			// DragDataReceived asks the TreeDragDest to insert a row before the path
	// @dest, deriving the contents of the row from @value. If @dest is outside
	// the tree so that inserting before it is impossible, false will be
	// returned. Also, false may be returned if the new row is not created for
	// some model-specific reason. Should robustly handle a @dest no longer
	// found in the model!
		DragDataReceived(dest *TreePath, value **externglib.Value) bool
			// RowDropPossible determines whether a drop is possible before the given
	// @dest_path, at the same depth as @dest_path. i.e., can we drop the data
	// in @value at that location. @dest_path does not have to exist; the return
	// value will almost certainly be false if the parent of @dest_path doesnt
	// exist, though.
		RowDropPossible(destPath *TreePath, value **externglib.Value) bool
		
	}
	

	// TreeDragDest: interface for Drag-and-Drop destinations in `GtkTreeView`.
	type TreeDragDest struct {
		**externglib.Object
		
	}

	
	func marshalTreeDragDest(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeDragDest{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DragDataReceived asks the TreeDragDest to insert a row before the path @dest,
// deriving the contents of the row from @value. If @dest is outside the tree so
// that inserting before it is impossible, false will be returned. Also, false
// may be returned if the new row is not created for some model-specific reason.
// Should robustly handle a @dest no longer found in the model!
	func (d TreeDragDest) DragDataReceived(dest *TreePath, value **externglib.Value) bool {
var _arg0 *C.GtkTreeDragDest // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GValue // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(dest.Native()))
_arg2 = (*C.GValue)(value.GValue)

_cret = C.gtk_tree_drag_dest_drag_data_received(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowDropPossible determines whether a drop is possible before the given
// @dest_path, at the same depth as @dest_path. i.e., can we drop the data in
// @value at that location. @dest_path does not have to exist; the return value
// will almost certainly be false if the parent of @dest_path doesnt exist,
// though.
	func (d TreeDragDest) RowDropPossible(destPath *TreePath, value **externglib.Value) bool {
var _arg0 *C.GtkTreeDragDest // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GValue // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragDest)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(destPath.Native()))
_arg2 = (*C.GValue)(value.GValue)

_cret = C.gtk_tree_drag_dest_row_drop_possible(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// TreeDragSourceInterface contains virtual methods for TreeDragSource, or
	// methods that can be overridden.
	type TreeDragSourceInterface interface {
		gextras.Objector

			// DragDataDelete asks the TreeDragSource to delete the row at @path,
	// because it was moved somewhere else via drag-and-drop. Returns false if
	// the deletion fails because @path no longer exists, or for some
	// model-specific reason. Should robustly handle a @path no longer found in
	// the model!
		DragDataDelete(path *TreePath) bool
			// DragDataGet asks the TreeDragSource to return a ContentProvider
	// representing the row at @path. Should robustly handle a @path no longer
	// found in the model!
		DragDataGet(path *TreePath) gdk.ContentProvider
			// RowDraggable asks the TreeDragSource whether a particular row can be used
	// as the source of a DND operation. If the source doesnt implement this
	// interface, the row is assumed draggable.
		RowDraggable(path *TreePath) bool
		
	}
	

	// TreeDragSource: interface for Drag-and-Drop destinations in `GtkTreeView`.
	type TreeDragSource struct {
		**externglib.Object
		
	}

	
	func marshalTreeDragSource(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeDragSource{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// DragDataDelete asks the TreeDragSource to delete the row at @path, because it
// was moved somewhere else via drag-and-drop. Returns false if the deletion
// fails because @path no longer exists, or for some model-specific reason.
// Should robustly handle a @path no longer found in the model!
	func (d TreeDragSource) DragDataDelete(path *TreePath) bool {
var _arg0 *C.GtkTreeDragSource // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_drag_source_drag_data_delete(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DragDataGet asks the TreeDragSource to return a ContentProvider representing
// the row at @path. Should robustly handle a @path no longer found in the
// model!
	func (d TreeDragSource) DragDataGet(path *TreePath) gdk.ContentProvider {
var _arg0 *C.GtkTreeDragSource // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GdkContentProvider // in

_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_drag_source_drag_data_get(_arg0, _arg1)


var _contentProvider gdk.ContentProvider // out

_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.ContentProvider)

return _contentProvider
}
	
	// RowDraggable asks the TreeDragSource whether a particular row can be used as
// the source of a DND operation. If the source doesnt implement this
// interface, the row is assumed draggable.
	func (d TreeDragSource) RowDraggable(path *TreePath) bool {
var _arg0 *C.GtkTreeDragSource // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeDragSource)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_drag_source_row_draggable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	
	// TreeModelInterface contains virtual methods for TreeModel, or
	// methods that can be overridden.
	type TreeModelInterface interface {
		gextras.Objector

			// ColumnType returns the type of the column.
		ColumnType(index_ int) externglib.Type
			// Flags returns a set of flags supported by this interface.
	// 
	// The flags are a bitwise combination of TreeModelFlags. The flags
	// supported should not change during the lifetime of the @tree_model.
		Flags() TreeModelFlags
			// Iter sets @iter to a valid iterator pointing to @path. If @path does not
	// exist, @iter is set to an invalid iterator and false is returned.
		Iter(path *TreePath) (TreeIter, bool)
			// NColumns returns the number of columns supported by @tree_model.
		NColumns() int
			// Path returns a newly-created TreePath-struct referenced by @iter.
	// 
	// This path should be freed with gtk_tree_path_free().
		Path(iter *TreeIter) *TreePath
			// Value initializes and sets @value to that at @column.
	// 
	// When done with @value, g_value_unset() needs to be called to free any
	// allocated memory.
		Value(iter *TreeIter, column int) *externglib.Value
			// IterChildren sets @iter to point to the first child of @parent.
	// 
	// If @parent has no children, false is returned and @iter is set to be
	// invalid. @parent will remain a valid node after this function has been
	// called.
	// 
	// If @parent is nil returns the first node, equivalent to
	// `gtk_tree_model_get_iter_first (tree_model, iter);`
		IterChildren(parent *TreeIter) (TreeIter, bool)
			// IterHasChild returns true if @iter has children, false otherwise.
		IterHasChild(iter *TreeIter) bool
			// IterNChildren returns the number of children that @iter has.
	// 
	// As a special case, if @iter is nil, then the number of toplevel nodes is
	// returned.
		IterNChildren(iter *TreeIter) int
			// IterNext sets @iter to point to the node following it at the current
	// level.
	// 
	// If there is no next @iter, false is returned and @iter is set to be
	// invalid.
		IterNext(iter *TreeIter) bool
			// IterNthChild sets @iter to be the child of @parent, using the given
	// index.
	// 
	// The first index is 0. If @n is too big, or @parent has no children, @iter
	// is set to an invalid iterator and false is returned. @parent will remain
	// a valid node after this function has been called. As a special case, if
	// @parent is nil, then the @n-th root node is set.
		IterNthChild(parent *TreeIter, n int) (TreeIter, bool)
			// IterParent sets @iter to be the parent of @child.
	// 
	// If @child is at the toplevel, and doesnt have a parent, then @iter is
	// set to an invalid iterator and false is returned. @child will remain a
	// valid node after this function has been called.
	// 
	// @iter will be initialized before the lookup is performed, so @child and
	// @iter cannot point to the same memory location.
		IterParent(child *TreeIter) (TreeIter, bool)
			// IterPrevious sets @iter to point to the previous node at the current
	// level.
	// 
	// If there is no previous @iter, false is returned and @iter is set to be
	// invalid.
		IterPrevious(iter *TreeIter) bool
			// RefNode lets the tree ref the node.
	// 
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons.
	// 
	// This function is primarily meant as a way for views to let caching models
	// know when nodes are being displayed (and hence, whether or not to cache
	// that node). Being displayed means a node is in an expanded branch,
	// regardless of whether the node is currently visible in the viewport. For
	// example, a file-system based model would not want to keep the entire
	// file-hierarchy in memory, just the sections that are currently being
	// displayed by every current view.
	// 
	// A model should be expected to be able to get an iter independent of its
	// reffed state.
		RefNode(iter *TreeIter) 
			// RowChanged emits the TreeModel::row-changed signal on @tree_model.
		RowChanged(path *TreePath, iter *TreeIter) 
			// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
	// 
	// This should be called by models after a row has been removed. The
	// location pointed to by @path should be the location that the row
	// previously was at. It may not be a valid location anymore.
	// 
	// Nodes that are deleted are not unreffed, this means that any outstanding
	// references on the deleted node should not be released.
		RowDeleted(path *TreePath) 
			// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
	// @tree_model. This should be called by models after the child state of a
	// node changes.
		RowHasChildToggled(path *TreePath, iter *TreeIter) 
			// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
		RowInserted(path *TreePath, iter *TreeIter) 
			// UnrefNode lets the tree unref the node.
	// 
	// This is an optional method for models to implement. To be more specific,
	// models may ignore this call as it exists primarily for performance
	// reasons. For more information on what this means, see
	// gtk_tree_model_ref_node().
	// 
	// Please note that nodes that are deleted are not unreffed.
		UnrefNode(iter *TreeIter) 
		
	}
	

	// TreeModel: the tree interface used by GtkTreeView
// 
// The TreeModel interface defines a generic tree interface for use by the
// TreeView widget. It is an abstract interface, and is designed to be usable
// with any appropriate data structure. The programmer just has to implement
// this interface on their own data type for it to be viewable by a TreeView
// widget.
// 
// The model is represented as a hierarchical tree of strongly-typed, columned
// data. In other words, the model can be seen as a tree where every node has
// different values depending on which column is being queried. The type of data
// found in a column is determined by using the GType system (ie. TYPE_INT,
// K_TYPE_BUTTON, TYPE_POINTER, etc). The types are homogeneous per column
// across all nodes. It is important to note that this interface only provides a
// way of examining a model and observing changes. The implementation of each
// individual model decides how and if changes are made.
// 
// In order to make life simpler for programmers who do not need to write their
// own specialized model, two generic models are provided  the TreeStore and
// the ListStore. To use these, the developer simply pushes data into these
// models as necessary. These models provide the data structure as well as all
// appropriate tree interfaces. As a result, implementing drag and drop,
// sorting, and storing data is trivial. For the vast majority of trees and
// lists, these two models are sufficient.
// 
// Models are accessed on a node/column level of granularity. One can query for
// the value of a model at a certain node and a certain column on that node.
// There are two structures used to reference a particular node in a model. They
// are the [struct@Gtk.TreePath] and the [struct@Gtk.TreeIter] (iter is short
// for iterator). Most of the interface consists of operations on a
// [struct@Gtk.TreeIter].
// 
// A path is essentially a potential node. It is a location on a model that may
// or may not actually correspond to a node on a specific model. A
// [struct@Gtk.TreePath] can be converted into either an array of unsigned
// integers or a string. The string form is a list of numbers separated by a
// colon. Each number refers to the offset at that level. Thus, the path `0`
// refers to the root node and the path `2:4` refers to the fifth child of the
// third node.
// 
// By contrast, a [struct@Gtk.TreeIter] is a reference to a specific node on a
// specific model. It is a generic struct with an integer and three generic
// pointers. These are filled in by the model in a model-specific way. One can
// convert a path to an iterator by calling gtk_tree_model_get_iter(). These
// iterators are the primary way of accessing a model and are similar to the
// iterators used by TextBuffer. They are generally statically allocated on the
// stack and only used for a short time. The model interface defines a set of
// operations using them for navigating the model.
// 
// It is expected that models fill in the iterator with private data. For
// example, the ListStore model, which is internally a simple linked list,
// stores a list node in one of the pointers. The TreeModelSort stores an array
// and an offset in two of the pointers. Additionally, there is an integer
// field. This field is generally filled with a unique stamp per model. This
// stamp is for catching errors resulting from using invalid iterators with a
// model.
// 
// The lifecycle of an iterator can be a little confusing at first. Iterators
// are expected to always be valid for as long as the model is unchanged (and
// doesnt emit a signal). The model is considered to own all outstanding
// iterators and nothing needs to be done to free them from the users point of
// view. Additionally, some models guarantee that an iterator is valid for as
// long as the node it refers to is valid (most notably the TreeStore and
// ListStore). Although generally uninteresting, as one always has to allow for
// the case where iterators do not persist beyond a signal, some very important
// performance enhancements were made in the sort model. As a result, the
// K_TREE_MODEL_ITERS_PERSIST flag was added to indicate this behavior.
// 
// To help show some common operation of a model, some examples are provided.
// The first example shows three ways of getting the iter at the location
// `3:2:5`. While the first method shown is easier, the second is much more
// common, as you often get paths from callbacks.
// 
// Acquiring a `GtkTreeIter`
// 
// `c // Three ways of getting the iter pointing to the location GtkTreePath
// *path; GtkTreeIter iter; GtkTreeIter parent_iter;
// 
// // get the iterator from a string gtk_tree_model_get_iter_from_string (model,
// // &iter, "3:2:5");
// 
// // get the iterator from a path path = gtk_tree_path_new_from_string
// // ("3:2:5"); gtk_tree_model_get_iter (model, &iter, path); gtk_tree_path_free
// // (path);
// 
// // walk the tree to find the iterator gtk_tree_model_iter_nth_child (model,
// // &iter, NULL, 3); parent_iter = iter; gtk_tree_model_iter_nth_child (model,
// // &iter, &parent_iter, 2); parent_iter = iter; gtk_tree_model_iter_nth_child
// // (model, &iter, &parent_iter, 5); `
// 
// This second example shows a quick way of iterating through a list and getting
// a string and an integer from each row. The populate_model() function used
// below is not shown, as it is specific to the ListStore. For information on
// how to write such a function, see the ListStore documentation.
// 
// Reading data from a `GtkTreeModel`
// 
// `c enum { STRING_COLUMN, INT_COLUMN, N_COLUMNS };
// 
// ...
// 
// GtkTreeModel *list_store; GtkTreeIter iter; gboolean valid; int row_count =
// 0;
// 
// // make a new list_store list_store = gtk_list_store_new (N_COLUMNS,
// // G_TYPE_STRING, G_TYPE_INT);
// 
// // Fill the list store with data populate_model (list_store);
// 
// // Get the first iter in the list, check it is valid and walk // through the
// // list, reading each row.
// 
// valid = gtk_tree_model_get_iter_first (list_store, &iter); while (valid) {
// char *str_data; int int_data;
// 
//      // Make sure you terminate calls to gtk_tree_model_get() with a -1 value
//      gtk_tree_model_get (list_store, &iter,
//                          STRING_COLUMN, &str_data,
//                          INT_COLUMN, &int_data,
//                          -1);
// 
//      // Do something with the data
//      g_print ("Row d: (s,d)\n",
//               row_count, str_data, int_data);
//      g_free (str_data);
// 
//      valid = gtk_tree_model_iter_next (list_store,
//                                        &iter);
//      row_count++;
//    }
// 
// `
// 
// The TreeModel interface contains two methods for reference counting:
// gtk_tree_model_ref_node() and gtk_tree_model_unref_node(). These two methods
// are optional to implement. The reference counting is meant as a way for views
// to let models know when nodes are being displayed. TreeView will take a
// reference on a node when it is visible, which means the node is either in the
// toplevel or expanded. Being displayed does not mean that the node is
// currently directly visible to the user in the viewport. Based on this
// reference counting scheme a caching model, for example, can decide whether or
// not to cache a node based on the reference count. A file-system based model
// would not want to keep the entire file hierarchy in memory, but just the
// folders that are currently expanded in every current view.
// 
// When working with reference counting, the following rules must be taken into
// account:
// 
// - Never take a reference on a node without owning a reference on its parent.
// This means that all parent nodes of a referenced node must be referenced as
// well.
// 
// - Outstanding references on a deleted node are not released. This is not
// possible because the node has already been deleted by the time the
// row-deleted signal is received.
// 
// - Models are not obligated to emit a signal on rows of which none of its
// siblings are referenced. To phrase this differently, signals are only
// required for levels in which nodes are referenced. For the root level
// however, signals must be emitted at all times (however the root level is
// always referenced when any view is attached).
	type TreeModel struct {
		**externglib.Object
		
	}

	
	func marshalTreeModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// NewFilter creates a new TreeModel, with @child_model as the child_model and
// @root as the virtual root.
	func (c TreeModel) NewFilter(root *TreePath) TreeModel {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(root.Native()))

_cret = C.gtk_tree_model_filter_new(_arg0, _arg1)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// ColumnType returns the type of the column.
	func (t TreeModel) ColumnType(index_ int) externglib.Type {
var _arg0 *C.GtkTreeModel // out
var _arg1 C.int // out
var _cret C.GType // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(index_)

_cret = C.gtk_tree_model_get_column_type(_arg0, _arg1)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// Flags returns a set of flags supported by this interface.
// 
// The flags are a bitwise combination of TreeModelFlags. The flags supported
// should not change during the lifetime of the @tree_model.
	func (t TreeModel) Flags() TreeModelFlags {
var _arg0 *C.GtkTreeModel // out
var _cret C.GtkTreeModelFlags // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_get_flags(_arg0)


var _treeModelFlags TreeModelFlags // out

_treeModelFlags = TreeModelFlags(_cret)

return _treeModelFlags
}
	
	// Iter sets @iter to a valid iterator pointing to @path. If @path does not
// exist, @iter is set to an invalid iterator and false is returned.
	func (t TreeModel) Iter(path *TreePath) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_model_get_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterFirst initializes @iter with the first iterator in the tree (the one at
// the path "0") and returns true. Returns false if the tree is empty.
	func (t TreeModel) IterFirst() (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_get_iter_first(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterFromString sets @iter to a valid iterator pointing to @path_string, if it
// exists. Otherwise, @iter is left invalid and false is returned.
	func (t TreeModel) IterFromString(pathString string) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.char)(C.CString(pathString))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_tree_model_get_iter_from_string(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// NColumns returns the number of columns supported by @tree_model.
	func (t TreeModel) NColumns() int {
var _arg0 *C.GtkTreeModel // out
var _cret C.int // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_get_n_columns(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Path returns a newly-created TreePath-struct referenced by @iter.
// 
// This path should be freed with gtk_tree_path_free().
	func (t TreeModel) Path(iter *TreeIter) *TreePath {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_get_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// StringFromIter generates a string representation of the iter.
// 
// This string is a : separated list of numbers. For example, 4:10:0:3 would
// be an acceptable return value for this string.
	func (t TreeModel) StringFromIter(iter *TreeIter) string {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret *C.char // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_get_string_from_iter(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Value initializes and sets @value to that at @column.
// 
// When done with @value, g_value_unset() needs to be called to free any
// allocated memory.
	func (t TreeModel) Value(iter *TreeIter, column int) *externglib.Value {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _arg2 C.int // out
var _arg3 C.GValue // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.int)(column)

C.gtk_tree_model_get_value(_arg0, _arg1, _arg2, &_arg3)

var _value *externglib.Value // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))

return _value
}
	
	// IterChildren sets @iter to point to the first child of @parent.
// 
// If @parent has no children, false is returned and @iter is set to be invalid.
// @parent will remain a valid node after this function has been called.
// 
// If @parent is nil returns the first node, equivalent to
// `gtk_tree_model_get_iter_first (tree_model, iter);`
	func (t TreeModel) IterChildren(parent *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_tree_model_iter_children(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterHasChild returns true if @iter has children, false otherwise.
	func (t TreeModel) IterHasChild(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_has_child(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterNChildren returns the number of children that @iter has.
// 
// As a special case, if @iter is nil, then the number of toplevel nodes is
// returned.
	func (t TreeModel) IterNChildren(iter *TreeIter) int {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.int // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_n_children(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IterNext sets @iter to point to the node following it at the current level.
// 
// If there is no next @iter, false is returned and @iter is set to be invalid.
	func (t TreeModel) IterNext(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_next(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterNthChild sets @iter to be the child of @parent, using the given index.
// 
// The first index is 0. If @n is too big, or @parent has no children, @iter is
// set to an invalid iterator and false is returned. @parent will remain a valid
// node after this function has been called. As a special case, if @parent is
// nil, then the @n-th root node is set.
	func (t TreeModel) IterNthChild(parent *TreeIter, n int) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (C.int)(n)

_cret = C.gtk_tree_model_iter_nth_child(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterParent sets @iter to be the parent of @child.
// 
// If @child is at the toplevel, and doesnt have a parent, then @iter is set to
// an invalid iterator and false is returned. @child will remain a valid node
// after this function has been called.
// 
// @iter will be initialized before the lookup is performed, so @child and @iter
// cannot point to the same memory location.
	func (t TreeModel) IterParent(child *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModel // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(child.Native()))

_cret = C.gtk_tree_model_iter_parent(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterPrevious sets @iter to point to the previous node at the current level.
// 
// If there is no previous @iter, false is returned and @iter is set to be
// invalid.
	func (t TreeModel) IterPrevious(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_iter_previous(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RefNode lets the tree ref the node.
// 
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// 
// This function is primarily meant as a way for views to let caching models
// know when nodes are being displayed (and hence, whether or not to cache that
// node). Being displayed means a node is in an expanded branch, regardless of
// whether the node is currently visible in the viewport. For example, a
// file-system based model would not want to keep the entire file-hierarchy in
// memory, just the sections that are currently being displayed by every current
// view.
// 
// A model should be expected to be able to get an iter independent of its
// reffed state.
	func (t TreeModel) RefNode(iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_ref_node(_arg0, _arg1)
}
	
	// RowChanged emits the TreeModel::row-changed signal on @tree_model.
	func (t TreeModel) RowChanged(path *TreePath, iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_row_changed(_arg0, _arg1, _arg2)
}
	
	// RowDeleted emits the TreeModel::row-deleted signal on @tree_model.
// 
// This should be called by models after a row has been removed. The location
// pointed to by @path should be the location that the row previously was at. It
// may not be a valid location anymore.
// 
// Nodes that are deleted are not unreffed, this means that any outstanding
// references on the deleted node should not be released.
	func (t TreeModel) RowDeleted(path *TreePath)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_model_row_deleted(_arg0, _arg1)
}
	
	// RowHasChildToggled emits the TreeModel::row-has-child-toggled signal on
// @tree_model. This should be called by models after the child state of a node
// changes.
	func (t TreeModel) RowHasChildToggled(path *TreePath, iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_row_has_child_toggled(_arg0, _arg1, _arg2)
}
	
	// RowInserted emits the TreeModel::row-inserted signal on @tree_model.
	func (t TreeModel) RowInserted(path *TreePath, iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_row_inserted(_arg0, _arg1, _arg2)
}
	
	// RowsReorderedWithLength emits the TreeModel::rows-reordered signal on
// @tree_model.
// 
// This should be called by models when their rows have been reordered.
	func (t TreeModel) RowsReorderedWithLength(path *TreePath, iter *TreeIter, newOrder []int)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeIter // out
var _arg3 *C.int
var _arg4 C.int

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg4 = C.int(len(newOrder))
_arg3 = (*C.int)(unsafe.Pointer(&newOrder[0]))

C.gtk_tree_model_rows_reordered_with_length(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// UnrefNode lets the tree unref the node.
// 
// This is an optional method for models to implement. To be more specific,
// models may ignore this call as it exists primarily for performance reasons.
// For more information on what this means, see gtk_tree_model_ref_node().
// 
// Please note that nodes that are deleted are not unreffed.
	func (t TreeModel) UnrefNode(iter *TreeIter)  {
var _arg0 *C.GtkTreeModel // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModel)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_model_unref_node(_arg0, _arg1)
}
	


	
	// TreeSortableInterface contains virtual methods for TreeSortable, or
	// methods that can be overridden.
	type TreeSortableInterface interface {
		gextras.Objector

			// SortColumnID fills in @sort_column_id and @order with the current sort
	// column and the order. It returns true unless the @sort_column_id is
	// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
	// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
		SortColumnID() (int, SortType, bool)
			// HasDefaultSortFunc returns true if the model has a default sort function.
	// This is used primarily by GtkTreeViewColumns in order to determine if a
	// model can go back to the default state, or not.
		HasDefaultSortFunc() bool
			// SetSortColumnID sets the current sort column to be @sort_column_id. The
	// @sortable will resort itself to reflect this change, after emitting a
	// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
	// regular column id, or one of the following special values:
	// 
	// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function
	// will be used, if it is set
	// 
	// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
		SetSortColumnID(sortColumnId int, order SortType) 
			// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
	// @sortable.
		SortColumnChanged() 
		
	}
	

	// TreeSortable: the interface for sortable models used by GtkTreeView
// 
// TreeSortable is an interface to be implemented by tree models which support
// sorting. The TreeView uses the methods provided by this interface to sort the
// model.
	type TreeSortable struct {
		TreeModel
		
	}

	
	func marshalTreeSortable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return {TreeSortable{
TreeModel: TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
} map[github.com/gotk3/gotk3/glib:externglib]}, nil
	}
	

	
	// SortColumnID fills in @sort_column_id and @order with the current sort column
// and the order. It returns true unless the @sort_column_id is
// GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID or
// GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID.
	func (s TreeSortable) SortColumnID() (int, SortType, bool) {
var _arg0 *C.GtkTreeSortable // out
var _arg1 C.int // in
var _arg2 C.GtkSortType // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_sortable_get_sort_column_id(_arg0, &_arg1, &_arg2)


var _sortColumnId int // out
var _order SortType // out
var _ok bool // out

_sortColumnId = (int)(_arg1)
_order = SortType(_arg2)
if _cret != 0 { _ok = true }

return _sortColumnId, _order, _ok
}
	
	// HasDefaultSortFunc returns true if the model has a default sort function.
// This is used primarily by GtkTreeViewColumns in order to determine if a model
// can go back to the default state, or not.
	func (s TreeSortable) HasDefaultSortFunc() bool {
var _arg0 *C.GtkTreeSortable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_sortable_has_default_sort_func(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSortColumnID sets the current sort column to be @sort_column_id. The
// @sortable will resort itself to reflect this change, after emitting a
// TreeSortable::sort-column-changed signal. @sort_column_id may either be a
// regular column id, or one of the following special values:
// 
// - GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID: the default sort function will be
// used, if it is set
// 
// - GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID: no sorting will occur
	func (s TreeSortable) SetSortColumnID(sortColumnId int, order SortType)  {
var _arg0 *C.GtkTreeSortable // out
var _arg1 C.int // out
var _arg2 C.GtkSortType // out

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(sortColumnId)
_arg2 = (C.GtkSortType)(order)

C.gtk_tree_sortable_set_sort_column_id(_arg0, _arg1, _arg2)
}
	
	// SortColumnChanged emits a TreeSortable::sort-column-changed signal on
// @sortable.
	func (s TreeSortable) SortColumnChanged()  {
var _arg0 *C.GtkTreeSortable // out

_arg0 = (*C.GtkTreeSortable)(unsafe.Pointer(s.Native()))

C.gtk_tree_sortable_sort_column_changed(_arg0)
}
	


	// ATContext: `GtkATContext` is an abstract class provided by GTK to communicate
// to platform-specific assistive technologies API.
// 
// Each platform supported by GTK implements a `GtkATContext` subclass, and is
// responsible for updating the accessible state in response to state changes in
// `GtkAccessible`.
	type ATContext struct {
		**externglib.Object
		
	}

	// ATContextClass is an interface that the ATContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ATContextClass interface {
		gextras.Objector
		_atContext()
	}

	func (ATContext) _atContext() {}

	
	func marshalATContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapATContext(obj), nil
	}
	

	
	// NewATContextCreate creates a new `GtkATContext` instance for the given
// accessible role, accessible instance, and display connection.
// 
// The `GtkATContext` implementation being instantiated will depend on the
// platform.
	func NewATContextCreate(accessibleRole AccessibleRole, accessible Accessible, display gdk.DisplayClass) ATContext {
var _arg1 C.GtkAccessibleRole // out
var _arg2 *C.GtkAccessible // out
var _arg3 *C.GdkDisplay // out
var _cret *C.GtkATContext // in

_arg1 = (C.GtkAccessibleRole)(accessibleRole)
_arg2 = (*C.GtkAccessible)(unsafe.Pointer(accessible.Native()))
_arg3 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

_cret = C.gtk_at_context_create(_arg1, _arg2, _arg3)


var _atContext ATContext // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_atContext = ATContext{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _atContext
}
	

	
	// Accessible retrieves the `GtkAccessible` using this context.
	func (s ATContext) Accessible() Accessible {
var _arg0 *C.GtkATContext // out
var _cret *C.GtkAccessible // in

_arg0 = (*C.GtkATContext)(unsafe.Pointer(s.Native()))

_cret = C.gtk_at_context_get_accessible(_arg0)


var _accessible Accessible // out

_accessible = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Accessible)

return _accessible
}
	
	// AccessibleRole retrieves the accessible role of this context.
	func (s ATContext) AccessibleRole() AccessibleRole {
var _arg0 *C.GtkATContext // out
var _cret C.GtkAccessibleRole // in

_arg0 = (*C.GtkATContext)(unsafe.Pointer(s.Native()))

_cret = C.gtk_at_context_get_accessible_role(_arg0)


var _accessibleRole AccessibleRole // out

_accessibleRole = AccessibleRole(_cret)

return _accessibleRole
}
	


	// AboutDialog: the `GtkAboutDialog` offers a simple way to display information
// about a program.
// 
// The shown information includes the programs' logo, name, copyright, website
// and license. It is also possible to give credits to the authors, documenters,
// translators and artists who have worked on the program.
// 
// An about dialog is typically opened when the user selects the `About` option
// from the `Help` menu. All parts of the dialog are optional.
// 
// !An example GtkAboutDialog (aboutdialog.png)
// 
// About dialogs often contain links and email addresses. `GtkAboutDialog`
// displays these as clickable links. By default, it calls [func@Gtk.show_uri]
// when a user clicks one. The behaviour can be overridden with the
// [signal@Gtk.AboutDialog::activate-link] signal.
// 
// To specify a person with an email address, use a string like `Edgar Allan Poe
// <edgar@poe.com>`. To specify a website with a title, use a string like `GTK
// team https://www.gtk.org`.
// 
// To make constructing a `GtkAboutDialog` as convenient as possible, you can
// use the function [func@Gtk.show_about_dialog] which constructs and shows a
// dialog and keeps it around so that it can be shown again.
// 
// Note that GTK sets a default title of `_("About s")` on the dialog window
// (where `s` is replaced by the name of the application, but in order to ensure
// proper translation of the title, applications should set the title property
// explicitly when constructing a `GtkAboutDialog`, as shown in the following
// example:
// 
// `c GFile *logo_file = g_file_new_for_path ("./logo.png"); GdkTexture
// *example_logo = gdk_texture_new_from_file (logo_file, NULL); g_object_unref
// (logo_file);
// 
// gtk_show_about_dialog (NULL, "program-name", "ExampleCode", "logo",
// example_logo, "title", _("About ExampleCode"), NULL); `
// 
// 
// CSS nodes
// 
// `GtkAboutDialog` has a single CSS node with the name `window` and style class
// `.aboutdialog`.
	type AboutDialog struct {
		Window
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// AboutDialogClass is an interface that the AboutDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AboutDialogClass interface {
		gextras.Objector
		_aboutDialog()
	}

	func (AboutDialog) _aboutDialog() {}

	
	func marshalAboutDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAboutDialog(obj), nil
	}
	

	
	// NewAboutDialog creates a new `GtkAboutDialog`.
	func NewAboutDialog() AboutDialog {
var _cret *C.GtkWidget // in

_cret = C.gtk_about_dialog_new()


var _aboutDialog AboutDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_aboutDialog = AboutDialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _aboutDialog
}
	

	
	// AddCreditSection creates a new section in the "Credits" page.
	func (a AboutDialog) AddCreditSection(sectionName string, people []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out
var _arg2 **C.char

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(sectionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.char)(C.malloc(C.ulong(len(people)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(people))
for i := range people {
out[i] = (*C.char)(C.CString(people[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_add_credit_section(_arg0, _arg1, _arg2)
}
	
	// Artists returns the string which are displayed in the "Artists" tab of the
// secondary credits dialog.
	func (a AboutDialog) Artists() []string {
var _arg0 *C.GtkAboutDialog // out
var _cret **C.char

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_artists(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// Authors returns the string which are displayed in the authors tab of the
// secondary credits dialog.
	func (a AboutDialog) Authors() []string {
var _arg0 *C.GtkAboutDialog // out
var _cret **C.char

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_authors(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// Comments returns the comments string.
	func (a AboutDialog) Comments() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_comments(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Copyright returns the copyright string.
	func (a AboutDialog) Copyright() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_copyright(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Documenters returns the string which are displayed in the "Documenters" tab
// of the secondary credits dialog.
	func (a AboutDialog) Documenters() []string {
var _arg0 *C.GtkAboutDialog // out
var _cret **C.char

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_documenters(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// License returns the license information.
	func (a AboutDialog) License() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_license(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LicenseType retrieves the license type.
	func (a AboutDialog) LicenseType() License {
var _arg0 *C.GtkAboutDialog // out
var _cret C.GtkLicense // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_license_type(_arg0)


var _license License // out

_license = License(_cret)

return _license
}
	
	// Logo returns the paintable displayed as logo in the about dialog.
	func (a AboutDialog) Logo() gdk.Paintable {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_logo(_arg0)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// LogoIconName returns the icon name displayed as logo in the about dialog.
	func (a AboutDialog) LogoIconName() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_logo_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ProgramName returns the program name displayed in the about dialog.
	func (a AboutDialog) ProgramName() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_program_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SystemInformation returns the system information that is shown in the about
// dialog.
	func (a AboutDialog) SystemInformation() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_system_information(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TranslatorCredits returns the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
	func (a AboutDialog) TranslatorCredits() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_translator_credits(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Version returns the version string.
	func (a AboutDialog) Version() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_version(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Website returns the website URL.
	func (a AboutDialog) Website() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_website(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// WebsiteLabel returns the label used for the website link.
	func (a AboutDialog) WebsiteLabel() string {
var _arg0 *C.GtkAboutDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_website_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// WrapLicense returns whether the license text in the about dialog is
// automatically wrapped.
	func (a AboutDialog) WrapLicense() bool {
var _arg0 *C.GtkAboutDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))

_cret = C.gtk_about_dialog_get_wrap_license(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetArtists sets the strings which are displayed in the "Artists" tab of the
// secondary credits dialog.
	func (a AboutDialog) SetArtists(artists []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 **C.char

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (**C.char)(C.malloc(C.ulong(len(artists)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(artists))
for i := range artists {
out[i] = (*C.char)(C.CString(artists[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_set_artists(_arg0, _arg1)
}
	
	// SetAuthors sets the strings which are displayed in the "Authors" tab of the
// secondary credits dialog.
	func (a AboutDialog) SetAuthors(authors []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 **C.char

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (**C.char)(C.malloc(C.ulong(len(authors)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(authors))
for i := range authors {
out[i] = (*C.char)(C.CString(authors[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_set_authors(_arg0, _arg1)
}
	
	// SetComments sets the comments string to display in the about dialog.
// 
// This should be a short string of one or two lines.
	func (a AboutDialog) SetComments(comments string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(comments))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_comments(_arg0, _arg1)
}
	
	// SetCopyright sets the copyright string to display in the about dialog.
// 
// This should be a short string of one or two lines.
	func (a AboutDialog) SetCopyright(copyright string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(copyright))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_copyright(_arg0, _arg1)
}
	
	// SetDocumenters sets the strings which are displayed in the "Documenters" tab
// of the credits dialog.
	func (a AboutDialog) SetDocumenters(documenters []string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 **C.char

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (**C.char)(C.malloc(C.ulong(len(documenters)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(documenters))
for i := range documenters {
out[i] = (*C.char)(C.CString(documenters[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_about_dialog_set_documenters(_arg0, _arg1)
}
	
	// SetLicense sets the license information to be displayed in the secondary
// license dialog.
// 
// If `license` is `NULL`, the license button is hidden.
	func (a AboutDialog) SetLicense(license string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(license))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_license(_arg0, _arg1)
}
	
	// SetLicenseType sets the license of the application showing the about dialog
// from a list of known licenses.
// 
// This function overrides the license set using
// [method@Gtk.AboutDialog.set_license].
	func (a AboutDialog) SetLicenseType(licenseType License)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 C.GtkLicense // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (C.GtkLicense)(licenseType)

C.gtk_about_dialog_set_license_type(_arg0, _arg1)
}
	
	// SetLogo sets the logo in the about dialog.
	func (a AboutDialog) SetLogo(logo gdk.Paintable)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.GdkPaintable // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GdkPaintable)(unsafe.Pointer(logo.Native()))

C.gtk_about_dialog_set_logo(_arg0, _arg1)
}
	
	// SetLogoIconName sets the icon name to be displayed as logo in the about
// dialog.
	func (a AboutDialog) SetLogoIconName(iconName string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_logo_icon_name(_arg0, _arg1)
}
	
	// SetProgramName sets the name to display in the about dialog.
// 
// If `name` is not set, it defaults to `g_get_application_name()`.
	func (a AboutDialog) SetProgramName(name string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_program_name(_arg0, _arg1)
}
	
	// SetSystemInformation sets the system information to be displayed in the about
// dialog.
// 
// If `system_information` is `NULL`, the system information tab is hidden.
// 
// See [property@Gtk.AboutDialog:system-information].
	func (a AboutDialog) SetSystemInformation(systemInformation string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(systemInformation))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_system_information(_arg0, _arg1)
}
	
	// SetTranslatorCredits sets the translator credits string which is displayed in
// the translators tab of the secondary credits dialog.
// 
// The intended use for this string is to display the translator of the language
// which is currently used in the user interface. Using `gettext()`, a simple
// way to achieve that is to mark the string for translation:
// 
// `c GtkWidget *about = gtk_about_dialog_new ();
// gtk_about_dialog_set_translator_credits (GTK_ABOUT_DIALOG (about),
// _("translator-credits")); `
// 
// It is a good idea to use the customary `msgid` translator-credits for this
// purpose, since translators will already know the purpose of that `msgid`, and
// since `GtkAboutDialog` will detect if translator-credits is untranslated
// and hide the tab.
	func (a AboutDialog) SetTranslatorCredits(translatorCredits string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(translatorCredits))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_translator_credits(_arg0, _arg1)
}
	
	// SetVersion sets the version string to display in the about dialog.
	func (a AboutDialog) SetVersion(version string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(version))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_version(_arg0, _arg1)
}
	
	// SetWebsite sets the URL to use for the website link.
	func (a AboutDialog) SetWebsite(website string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(website))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_website(_arg0, _arg1)
}
	
	// SetWebsiteLabel sets the label to be used for the website link.
	func (a AboutDialog) SetWebsiteLabel(websiteLabel string)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(websiteLabel))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_about_dialog_set_website_label(_arg0, _arg1)
}
	
	// SetWrapLicense sets whether the license text in the about dialog should be
// automatically wrapped.
	func (a AboutDialog) SetWrapLicense(wrapLicense bool)  {
var _arg0 *C.GtkAboutDialog // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAboutDialog)(unsafe.Pointer(a.Native()))
if wrapLicense { _arg1 = C.TRUE }

C.gtk_about_dialog_set_wrap_license(_arg0, _arg1)
}
	


	// ActionBar: `GtkActionBar` is designed to present contextual actions.
// 
// !An example GtkActionBar (action-bar.png)
// 
// It is expected to be displayed below the content and expand horizontally to
// fill the area.
// 
// It allows placing children at the start or the end. In addition, it contains
// an internal centered box which is centered with respect to the full width of
// the box, even if the children at either side take up different amounts of
// space.
// 
// 
// CSS nodes
// 
// `GtkActionBar` has a single CSS node with name actionbar.
	type ActionBar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// ActionBarClass is an interface that the ActionBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ActionBarClass interface {
		gextras.Objector
		_actionBar()
	}

	func (ActionBar) _actionBar() {}

	
	func marshalActionBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapActionBar(obj), nil
	}
	

	
	// NewActionBar creates a new `GtkActionBar` widget.
	func NewActionBar() ActionBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_action_bar_new()


var _actionBar ActionBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_actionBar = ActionBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _actionBar
}
	

	
	// CenterWidget retrieves the center bar widget of the bar.
	func (a ActionBar) CenterWidget() Widget {
var _arg0 *C.GtkActionBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_bar_get_center_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Revealed gets whether the contents of the action bar are revealed.
	func (a ActionBar) Revealed() bool {
var _arg0 *C.GtkActionBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))

_cret = C.gtk_action_bar_get_revealed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PackEnd adds @child to @action_bar, packed with reference to the end of the
// @action_bar.
	func (a ActionBar) PackEnd(child WidgetClass)  {
var _arg0 *C.GtkActionBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_action_bar_pack_end(_arg0, _arg1)
}
	
	// PackStart adds @child to @action_bar, packed with reference to the start of
// the @action_bar.
	func (a ActionBar) PackStart(child WidgetClass)  {
var _arg0 *C.GtkActionBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_action_bar_pack_start(_arg0, _arg1)
}
	
	// Remove removes a child from @action_bar.
	func (a ActionBar) Remove(child WidgetClass)  {
var _arg0 *C.GtkActionBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_action_bar_remove(_arg0, _arg1)
}
	
	// SetCenterWidget sets the center widget for the `GtkActionBar`.
	func (a ActionBar) SetCenterWidget(centerWidget WidgetClass)  {
var _arg0 *C.GtkActionBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(centerWidget.Native()))

C.gtk_action_bar_set_center_widget(_arg0, _arg1)
}
	
	// SetRevealed reveals or conceals the content of the action bar.
// 
// Note: this does not show or hide @action_bar in the
// [property@Gtk.Widget:visible] sense, so revealing has no effect if the action
// bar is hidden.
	func (a ActionBar) SetRevealed(revealed bool)  {
var _arg0 *C.GtkActionBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkActionBar)(unsafe.Pointer(a.Native()))
if revealed { _arg1 = C.TRUE }

C.gtk_action_bar_set_revealed(_arg0, _arg1)
}
	


	// ActivateAction: a `GtkShortcutAction` that calls gtk_widget_activate().
	type ActivateAction struct {
		ShortcutAction
		
	}

	// ActivateActionClass is an interface that the ActivateAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ActivateActionClass interface {
		gextras.Objector
		_activateAction()
	}

	func (ActivateAction) _activateAction() {}

	
	func marshalActivateAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapActivateAction(obj), nil
	}
	

	

	


	// Adjustment: `GtkAdjustment` is a model for a numeric value.
// 
// The `GtkAdjustment has an associated lower and upper bound. It also contains
// step and page increments, and a page size.
// 
// Adjustments are used within several GTK widgets, including
// [class@Gtk.SpinButton], [class@Gtk.Viewport], [class@Gtk.Scrollbar] and
// [class@Gtk.Scale].
// 
// The `GtkAdjustment` object does not update the value itself. Instead it is
// left up to the owner of the `GtkAdjustment` to control the value.
	type Adjustment struct {
		externglib.InitiallyUnowned
		
	}

	// AdjustmentClass is an interface that the Adjustment class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AdjustmentClass interface {
		gextras.Objector
		_adjustment()
	}

	func (Adjustment) _adjustment() {}

	
	func marshalAdjustment(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAdjustment(obj), nil
	}
	

	
	// NewAdjustment creates a new `GtkAdjustment`.
	func NewAdjustment(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64) Adjustment {
var _arg1 C.double // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out
var _cret *C.GtkAdjustment // in

_arg1 = (C.double)(value)
_arg2 = (C.double)(lower)
_arg3 = (C.double)(upper)
_arg4 = (C.double)(stepIncrement)
_arg5 = (C.double)(pageIncrement)
_arg6 = (C.double)(pageSize)

_cret = C.gtk_adjustment_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _adjustment Adjustment // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_adjustment = Adjustment{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _adjustment
}
	

	
	// ClampPage updates the value property to ensure that the range between @lower
// and @upper is in the current page.
// 
// The current page goes from `value` to `value` + `page-size`. If the range is
// larger than the page size, then only the start of it will be in the current
// page.
// 
// A [signal@Gtk.Adjustment::value-changed] signal will be emitted if the value
// is changed.
	func (a Adjustment) ClampPage(lower float64, upper float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out
var _arg2 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(lower)
_arg2 = (C.double)(upper)

C.gtk_adjustment_clamp_page(_arg0, _arg1, _arg2)
}
	
	// Configure sets all properties of the adjustment at once.
// 
// Use this function to avoid multiple emissions of the
// [signal@Gtk.Adjustment::changed] signal. See
// [method@Gtk.Adjustment.set_lower] for an alternative way of compressing
// multiple emissions of [signal@Gtk.Adjustment::changed] into one.
	func (a Adjustment) Configure(value float64, lower float64, upper float64, stepIncrement float64, pageIncrement float64, pageSize float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out
var _arg6 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(value)
_arg2 = (C.double)(lower)
_arg3 = (C.double)(upper)
_arg4 = (C.double)(stepIncrement)
_arg5 = (C.double)(pageIncrement)
_arg6 = (C.double)(pageSize)

C.gtk_adjustment_configure(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}
	
	// Lower retrieves the minimum value of the adjustment.
	func (a Adjustment) Lower() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.double // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_lower(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// MinimumIncrement gets the smaller of step increment and page increment.
	func (a Adjustment) MinimumIncrement() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.double // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_minimum_increment(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageIncrement retrieves the page increment of the adjustment.
	func (a Adjustment) PageIncrement() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.double // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_page_increment(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageSize retrieves the page size of the adjustment.
	func (a Adjustment) PageSize() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.double // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_page_size(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// StepIncrement retrieves the step increment of the adjustment.
	func (a Adjustment) StepIncrement() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.double // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_step_increment(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Upper retrieves the maximum value of the adjustment.
	func (a Adjustment) Upper() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.double // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_upper(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Value gets the current value of the adjustment.
	func (a Adjustment) Value() float64 {
var _arg0 *C.GtkAdjustment // out
var _cret C.double // in

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))

_cret = C.gtk_adjustment_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetLower sets the minimum value of the adjustment.
// 
// When setting multiple adjustment properties via their individual setters,
// multiple [signal@Gtk.Adjustment::changed] signals will be emitted. However,
// since the emission of the [signal@Gtk.Adjustment::changed] signal is tied to
// the emission of the ::notify signals of the changed properties, its possible
// to compress the [signal@Gtk.Adjustment::changed] signals into one by calling
// g_object_freeze_notify() and g_object_thaw_notify() around the calls to the
// individual setters.
// 
// Alternatively, using a single g_object_set() for all the properties to
// change, or using [method@Gtk.Adjustment.configure] has the same effect.
	func (a Adjustment) SetLower(lower float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(lower)

C.gtk_adjustment_set_lower(_arg0, _arg1)
}
	
	// SetPageIncrement sets the page increment of the adjustment.
// 
// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
// multiple adjustment properties.
	func (a Adjustment) SetPageIncrement(pageIncrement float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(pageIncrement)

C.gtk_adjustment_set_page_increment(_arg0, _arg1)
}
	
	// SetPageSize sets the page size of the adjustment.
// 
// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
// multiple adjustment properties.
	func (a Adjustment) SetPageSize(pageSize float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(pageSize)

C.gtk_adjustment_set_page_size(_arg0, _arg1)
}
	
	// SetStepIncrement sets the step increment of the adjustment.
// 
// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
// multiple adjustment properties.
	func (a Adjustment) SetStepIncrement(stepIncrement float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(stepIncrement)

C.gtk_adjustment_set_step_increment(_arg0, _arg1)
}
	
	// SetUpper sets the maximum value of the adjustment.
// 
// Note that values will be restricted by `upper - page-size` if the page-size
// property is nonzero.
// 
// See [method@Gtk.Adjustment.set_lower] about how to compress multiple
// emissions of the [signal@Gtk.Adjustment::changed] signal when setting
// multiple adjustment properties.
	func (a Adjustment) SetUpper(upper float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(upper)

C.gtk_adjustment_set_upper(_arg0, _arg1)
}
	
	// SetValue sets the `GtkAdjustment` value.
// 
// The value is clamped to lie between [property@Gtk.Adjustment:lower] and
// [property@Gtk.Adjustment:upper].
// 
// Note that for adjustments which are used in a `GtkScrollbar`, the effective
// range of allowed values goes from [property@Gtk.Adjustment:lower] to
// [property@Gtk.Adjustment:upper] - [property@Gtk.Adjustment:page-size].
	func (a Adjustment) SetValue(value float64)  {
var _arg0 *C.GtkAdjustment // out
var _arg1 C.double // out

_arg0 = (*C.GtkAdjustment)(unsafe.Pointer(a.Native()))
_arg1 = (C.double)(value)

C.gtk_adjustment_set_value(_arg0, _arg1)
}
	


	// AlternativeTrigger: a `GtkShortcutTrigger` that combines two triggers.
// 
// The `GtkAlternativeTrigger` triggers when either of two trigger.
// 
// This can be cascaded to combine more than two triggers.
	type AlternativeTrigger struct {
		ShortcutTrigger
		
	}

	// AlternativeTriggerClass is an interface that the AlternativeTrigger class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AlternativeTriggerClass interface {
		gextras.Objector
		_alternativeTrigger()
	}

	func (AlternativeTrigger) _alternativeTrigger() {}

	
	func marshalAlternativeTrigger(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAlternativeTrigger(obj), nil
	}
	

	
	// NewAlternativeTrigger creates a `GtkShortcutTrigger` that will trigger
// whenever either of the two given triggers gets triggered.
// 
// Note that nesting is allowed, so if you want more than two alternative,
// create a new alternative trigger for each option.
	func NewAlternativeTrigger(first ShortcutTriggerClass, second ShortcutTriggerClass) AlternativeTrigger {
var _arg1 *C.GtkShortcutTrigger // out
var _arg2 *C.GtkShortcutTrigger // out
var _cret *C.GtkShortcutTrigger // in

_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(first.Native()))
_arg2 = (*C.GtkShortcutTrigger)(unsafe.Pointer(second.Native()))

_cret = C.gtk_alternative_trigger_new(_arg1, _arg2)


var _alternativeTrigger AlternativeTrigger // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_alternativeTrigger = AlternativeTrigger{
ShortcutTrigger: ShortcutTrigger{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _alternativeTrigger
}
	

	
	// First gets the first of the two alternative triggers that may trigger @self.
// 
// [method@Gtk.AlternativeTrigger.get_second] will return the other one.
	func (s AlternativeTrigger) First() ShortcutTrigger {
var _arg0 *C.GtkAlternativeTrigger // out
var _cret *C.GtkShortcutTrigger // in

_arg0 = (*C.GtkAlternativeTrigger)(unsafe.Pointer(s.Native()))

_cret = C.gtk_alternative_trigger_get_first(_arg0)


var _shortcutTrigger ShortcutTrigger // out

_shortcutTrigger = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutTrigger)

return _shortcutTrigger
}
	
	// Second gets the second of the two alternative triggers that may trigger
// @self.
// 
// [method@Gtk.AlternativeTrigger.get_first] will return the other one.
	func (s AlternativeTrigger) Second() ShortcutTrigger {
var _arg0 *C.GtkAlternativeTrigger // out
var _cret *C.GtkShortcutTrigger // in

_arg0 = (*C.GtkAlternativeTrigger)(unsafe.Pointer(s.Native()))

_cret = C.gtk_alternative_trigger_get_second(_arg0)


var _shortcutTrigger ShortcutTrigger // out

_shortcutTrigger = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutTrigger)

return _shortcutTrigger
}
	


	// AnyFilter: `GtkAnyFilter` matches an item when at least one of its filters
// matches.
// 
// To add filters to a `GtkAnyFilter`, use [method@Gtk.MultiFilter.append].
	type AnyFilter struct {
		MultiFilter
		gio.ListModel
		Buildable
		
	}

	// AnyFilterClass is an interface that the AnyFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AnyFilterClass interface {
		gextras.Objector
		_anyFilter()
	}

	func (AnyFilter) _anyFilter() {}

	
	func marshalAnyFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAnyFilter(obj), nil
	}
	

	
	// NewAnyFilter creates a new empty "any" filter.
// 
// Use [method@Gtk.MultiFilter.append] to add filters to it.
// 
// This filter matches an item if any of the filters added to it matches the
// item. In particular, this means that if no filter has been added to it, the
// filter matches no item.
	func NewAnyFilter() AnyFilter {
var _cret *C.GtkAnyFilter // in

_cret = C.gtk_any_filter_new()


var _anyFilter AnyFilter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_anyFilter = AnyFilter{
MultiFilter: MultiFilter{
Filter: Filter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _anyFilter
}
	

	


	// AppChooserButton: the `GtkAppChooserButton` lets the user select an
// application.
// 
// !An example GtkAppChooserButton (appchooserbutton.png)
// 
// Initially, a `GtkAppChooserButton` selects the first application in its list,
// which will either be the most-recently used application or, if
// [property@Gtk.AppChooserButton:show-default-item] is true, the default
// application.
// 
// The list of applications shown in a `GtkAppChooserButton` includes the
// recommended applications for the given content type. When
// [property@Gtk.AppChooserButton:show-default-item] is set, the default
// application is also included. To let the user chooser other applications, you
// can set the [property@Gtk.AppChooserButton:show-dialog-item] property, which
// allows to open a full [class@Gtk.AppChooserDialog].
// 
// It is possible to add custom items to the list, using
// [method@Gtk.AppChooserButton.append_custom_item]. These items cause the
// [signal@Gtk.AppChooserButton::custom-item-activated] signal to be emitted
// when they are selected.
// 
// To track changes in the selected application, use the
// [signal@Gtk.AppChooserButton::changed] signal.
// 
// 
// CSS nodes
// 
// `GtkAppChooserButton` has a single CSS node with the name appchooserbutton.
	type AppChooserButton struct {
		Widget
		Accessible
		AppChooser
		Buildable
		ConstraintTarget
		
	}

	// AppChooserButtonClass is an interface that the AppChooserButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppChooserButtonClass interface {
		gextras.Objector
		_appChooserButton()
	}

	func (AppChooserButton) _appChooserButton() {}

	
	func marshalAppChooserButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppChooserButton(obj), nil
	}
	

	
	// NewAppChooserButton creates a new `GtkAppChooserButton` for applications that
// can handle content of the given type.
	func NewAppChooserButton(contentType string) AppChooserButton {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_app_chooser_button_new(_arg1)


var _appChooserButton AppChooserButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserButton = AppChooserButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserButton
}
	

	
	// AppendCustomItem appends a custom item to the list of applications that is
// shown in the popup.
// 
// The item name must be unique per-widget. Clients can use the provided name as
// a detail for the [signal@Gtk.AppChooserButton::custom-item-activated] signal,
// to add a callback for the activation of a particular custom item in the list.
// 
// See also [method@Gtk.AppChooserButton.append_separator].
	func (s AppChooserButton) AppendCustomItem(name string, label string, icon gio.Icon)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 *C.GIcon // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_app_chooser_button_append_custom_item(_arg0, _arg1, _arg2, _arg3)
}
	
	// AppendSeparator appends a separator to the list of applications that is shown
// in the popup.
	func (s AppChooserButton) AppendSeparator()  {
var _arg0 *C.GtkAppChooserButton // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

C.gtk_app_chooser_button_append_separator(_arg0)
}
	
	// Heading returns the text to display at the top of the dialog.
	func (s AppChooserButton) Heading() string {
var _arg0 *C.GtkAppChooserButton // out
var _cret *C.char // in

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_button_get_heading(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Modal gets whether the dialog is modal.
	func (s AppChooserButton) Modal() bool {
var _arg0 *C.GtkAppChooserButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_button_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowDefaultItem returns whether the dropdown menu should show the default
// application at the top.
	func (s AppChooserButton) ShowDefaultItem() bool {
var _arg0 *C.GtkAppChooserButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_button_get_show_default_item(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowDialogItem returns whether the dropdown menu shows an item for a
// `GtkAppChooserDialog`.
	func (s AppChooserButton) ShowDialogItem() bool {
var _arg0 *C.GtkAppChooserButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_button_get_show_dialog_item(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActiveCustomItem selects a custom item.
// 
// See [method@Gtk.AppChooserButton.append_custom_item].
// 
// Use [method@Gtk.AppChooser.refresh] to bring the selection to its initial
// state.
	func (s AppChooserButton) SetActiveCustomItem(name string)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_button_set_active_custom_item(_arg0, _arg1)
}
	
	// SetHeading sets the text to display at the top of the dialog.
// 
// If the heading is not set, the dialog displays a default text.
	func (s AppChooserButton) SetHeading(heading string)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(heading))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_button_set_heading(_arg0, _arg1)
}
	
	// SetModal sets whether the dialog should be modal.
	func (s AppChooserButton) SetModal(modal bool)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_app_chooser_button_set_modal(_arg0, _arg1)
}
	
	// SetShowDefaultItem sets whether the dropdown menu of this button should show
// the default application for the given content type at top.
	func (s AppChooserButton) SetShowDefaultItem(setting bool)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_button_set_show_default_item(_arg0, _arg1)
}
	
	// SetShowDialogItem sets whether the dropdown menu of this button should show
// an entry to trigger a `GtkAppChooserDialog`.
	func (s AppChooserButton) SetShowDialogItem(setting bool)  {
var _arg0 *C.GtkAppChooserButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserButton)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_button_set_show_dialog_item(_arg0, _arg1)
}
	


	// AppChooserDialog: `GtkAppChooserDialog` shows a `GtkAppChooserWidget` inside
// a `GtkDialog`.
// 
// !An example GtkAppChooserDialog (appchooserdialog.png)
// 
// Note that `GtkAppChooserDialog` does not have any interesting methods of its
// own. Instead, you should get the embedded `GtkAppChooserWidget` using
// [method@Gtk.AppChooserDialog.get_widget] and call its methods if the generic
// [iface@Gtk.AppChooser] interface is not sufficient for your needs.
// 
// To set the heading that is shown above the `GtkAppChooserWidget`, use
// [method@Gtk.AppChooserDialog.set_heading].
	type AppChooserDialog struct {
		Dialog
		Accessible
		AppChooser
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// AppChooserDialogClass is an interface that the AppChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppChooserDialogClass interface {
		gextras.Objector
		_appChooserDialog()
	}

	func (AppChooserDialog) _appChooserDialog() {}

	
	func marshalAppChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppChooserDialog(obj), nil
	}
	

	
	// NewAppChooserDialog creates a new `GtkAppChooserDialog` for the provided
// `GFile`.
// 
// The dialog will show applications that can open the file.
	func NewAppChooserDialog(parent WindowClass, flags DialogFlags, file gio.File) AppChooserDialog {
var _arg1 *C.GtkWindow // out
var _arg2 C.GtkDialogFlags // out
var _arg3 *C.GFile // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (C.GtkDialogFlags)(flags)
_arg3 = (*C.GFile)(unsafe.Pointer(file.Native()))

_cret = C.gtk_app_chooser_dialog_new(_arg1, _arg2, _arg3)


var _appChooserDialog AppChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserDialog = AppChooserDialog{
Dialog: Dialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserDialog
}
	
	// NewAppChooserDialogForContentType creates a new `GtkAppChooserDialog` for the
// provided content type.
// 
// The dialog will show applications that can open the content type.
	func NewAppChooserDialogForContentType(parent WindowClass, flags DialogFlags, contentType string) AppChooserDialog {
var _arg1 *C.GtkWindow // out
var _arg2 C.GtkDialogFlags // out
var _arg3 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg2 = (C.GtkDialogFlags)(flags)
_arg3 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.gtk_app_chooser_dialog_new_for_content_type(_arg1, _arg2, _arg3)


var _appChooserDialog AppChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserDialog = AppChooserDialog{
Dialog: Dialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserDialog
}
	

	
	// Heading returns the text to display at the top of the dialog.
	func (s AppChooserDialog) Heading() string {
var _arg0 *C.GtkAppChooserDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_dialog_get_heading(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Widget returns the `GtkAppChooserWidget` of this dialog.
	func (s AppChooserDialog) Widget() Widget {
var _arg0 *C.GtkAppChooserDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_dialog_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetHeading sets the text to display at the top of the dialog.
// 
// If the heading is not set, the dialog displays a default text.
	func (s AppChooserDialog) SetHeading(heading string)  {
var _arg0 *C.GtkAppChooserDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAppChooserDialog)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(heading))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_dialog_set_heading(_arg0, _arg1)
}
	


	// AppChooserWidget: `GtkAppChooserWidget` is a widget for selecting
// applications.
// 
// It is the main building block for [class@Gtk.AppChooserDialog]. Most
// applications only need to use the latter; but you can use this widget as part
// of a larger widget if you have special needs.
// 
// `GtkAppChooserWidget` offers detailed control over what applications are
// shown, using the [property@Gtk.AppChooserWidget:show-default],
// [property@Gtk.AppChooserWidget:show-recommended],
// [property@Gtk.AppChooserWidget:show-fallback],
// [property@Gtk.AppChooserWidget:show-other] and
// [property@Gtk.AppChooserWidget:show-all] properties. See the
// [iface@Gtk.AppChooser] documentation for more information about these groups
// of applications.
// 
// To keep track of the selected application, use the
// [signal@Gtk.AppChooserWidget::application-selected] and
// [signal@Gtk.AppChooserWidget::application-activated] signals.
// 
// 
// CSS nodes
// 
// `GtkAppChooserWidget` has a single CSS node with name appchooser.
	type AppChooserWidget struct {
		Widget
		Accessible
		AppChooser
		Buildable
		ConstraintTarget
		
	}

	// AppChooserWidgetClass is an interface that the AppChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AppChooserWidgetClass interface {
		gextras.Objector
		_appChooserWidget()
	}

	func (AppChooserWidget) _appChooserWidget() {}

	
	func marshalAppChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAppChooserWidget(obj), nil
	}
	

	
	// NewAppChooserWidget creates a new `GtkAppChooserWidget` for applications that
// can handle content of the given type.
	func NewAppChooserWidget(contentType string) AppChooserWidget {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(contentType))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_app_chooser_widget_new(_arg1)


var _appChooserWidget AppChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_appChooserWidget = AppChooserWidget{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
AppChooser: AppChooser{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _appChooserWidget
}
	

	
	// DefaultText returns the text that is shown if there are not applications that
// can handle the content type.
	func (s AppChooserWidget) DefaultText() string {
var _arg0 *C.GtkAppChooserWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_default_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ShowAll gets whether the app chooser should show all applications in a flat
// list.
	func (s AppChooserWidget) ShowAll() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_all(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowDefault gets whether the app chooser should show the default handler for
// the content type in a separate section.
	func (s AppChooserWidget) ShowDefault() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowFallback gets whether the app chooser should show related applications
// for the content type in a separate section.
	func (s AppChooserWidget) ShowFallback() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_fallback(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowOther gets whether the app chooser should show applications which are
// unrelated to the content type.
	func (s AppChooserWidget) ShowOther() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_other(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowRecommended gets whether the app chooser should show recommended
// applications for the content type in a separate section.
	func (s AppChooserWidget) ShowRecommended() bool {
var _arg0 *C.GtkAppChooserWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_app_chooser_widget_get_show_recommended(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetDefaultText sets the text that is shown if there are not applications that
// can handle the content type.
	func (s AppChooserWidget) SetDefaultText(text string)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 *C.char // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_app_chooser_widget_set_default_text(_arg0, _arg1)
}
	
	// SetShowAll sets whether the app chooser should show all applications in a
// flat list.
	func (s AppChooserWidget) SetShowAll(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_all(_arg0, _arg1)
}
	
	// SetShowDefault sets whether the app chooser should show the default handler
// for the content type in a separate section.
	func (s AppChooserWidget) SetShowDefault(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_default(_arg0, _arg1)
}
	
	// SetShowFallback sets whether the app chooser should show related applications
// for the content type in a separate section.
	func (s AppChooserWidget) SetShowFallback(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_fallback(_arg0, _arg1)
}
	
	// SetShowOther sets whether the app chooser should show applications which are
// unrelated to the content type.
	func (s AppChooserWidget) SetShowOther(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_other(_arg0, _arg1)
}
	
	// SetShowRecommended sets whether the app chooser should show recommended
// applications for the content type in a separate section.
	func (s AppChooserWidget) SetShowRecommended(setting bool)  {
var _arg0 *C.GtkAppChooserWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAppChooserWidget)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_app_chooser_widget_set_show_recommended(_arg0, _arg1)
}
	


	// Application: `GtkApplication` is a high-level API for writing applications.
// 
// It supports many aspects of writing a GTK application in a convenient
// fashion, without enforcing a one-size-fits-all model.
// 
// Currently, `GtkApplication` handles GTK initialization, application
// uniqueness, session management, provides some basic scriptability and desktop
// shell integration by exporting actions and menus and manages a list of
// toplevel windows whose life-cycle is automatically tied to the life-cycle of
// your application.
// 
// While `GtkApplication` works fine with plain [class@Gtk.Window]s, it is
// recommended to use it together with [class@Gtk.ApplicationWindow].
// 
// 
// Automatic resources
// 
// `GtkApplication` will automatically load menus from the `GtkBuilder` resource
// located at "gtk/menus.ui", relative to the application's resource base path
// (see `g_application_set_resource_base_path()`). The menu with the ID
// "menubar" is taken as the application's menubar. Additional menus (most
// interesting submenus) can be named and accessed via
// [method@Gtk.Application.get_menu_by_id] which allows for dynamic population
// of a part of the menu structure.
// 
// It is also possible to provide the menubar manually using
// [method@Gtk.Application.set_menubar].
// 
// `GtkApplication` will also automatically setup an icon search path for the
// default icon theme by appending "icons" to the resource base path. This
// allows your application to easily store its icons as resources. See
// [method@Gtk.IconTheme.add_resource_path] for more information.
// 
// If there is a resource located at "gtk/help-overlay.ui" which defines a
// [class@Gtk.ShortcutsWindow] with ID "help_overlay" then `GtkApplication`
// associates an instance of this shortcuts window with each
// [class@Gtk.ApplicationWindow] and sets up the keyboard accelerator
// <kbd>Control</kbd>+<kbd>?</kbd> to open it. To create a menu item that
// displays the shortcuts window, associate the item with the action
// `win.show-help-overlay`.
// 
// 
// A simple application
// 
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/bp/bloatpad.c) is
// available in the GTK source code repository
// 
// `GtkApplication` optionally registers with a session manager of the users
// session (if you set the [property@Gtk.Application:register-session] property)
// and offers various functionality related to the session life-cycle.
// 
// An application can block various ways to end the session with the
// [method@Gtk.Application.inhibit] function. Typical use cases for this kind of
// inhibiting are long-running, uninterruptible operations, such as burning a CD
// or performing a disk backup. The session manager may not honor the inhibitor,
// but it can be expected to inform the user about the negative consequences of
// ending the session while inhibitors are present.
// 
// 
// See Also
// 
// HowDoI: Using GtkApplication (https://wiki.gnome.org/HowDoI/GtkApplication),
// Getting Started with GTK: Basics (getting_started.html#basics)
	type Application struct {
		gio.Application
		gio.ActionGroup
		gio.ActionMap
		
	}

	// ApplicationClass is an interface that the Application class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ApplicationClass interface {
		gextras.Objector
		_application()
	}

	func (Application) _application() {}

	
	func marshalApplication(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapApplication(obj), nil
	}
	

	
	// NewApplication creates a new `GtkApplication` instance.
// 
// When using `GtkApplication`, it is not necessary to call [func@Gtk.init]
// manually. It is called as soon as the application gets registered as the
// primary instance.
// 
// Concretely, [func@Gtk.init] is called in the default handler for the
// `GApplication::startup` signal. Therefore, `GtkApplication` subclasses should
// always chain up in their `GApplication::startup` handler before using any GTK
// API.
// 
// Note that commandline arguments are not passed to [func@Gtk.init].
// 
// If `application_id` is not nil, then it must be valid. See
// `g_application_id_is_valid()`.
// 
// If no application ID is given then some features (most notably application
// uniqueness) will be disabled.
	func NewApplication(applicationId string, flags gio.ApplicationFlags) Application {
var _arg1 *C.char // out
var _arg2 C.GApplicationFlags // out
var _cret *C.GtkApplication // in

_arg1 = (*C.char)(C.CString(applicationId))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GApplicationFlags)(flags)

_cret = C.gtk_application_new(_arg1, _arg2)


var _application Application // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_application = Application{
Application: gio.Application{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ActionGroup: gio.ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ActionMap: gio.ActionMap{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _application
}
	

	
	// AddWindow adds a window to `application`.
// 
// This call can only happen after the `application` has started; typically, you
// should add new application windows in response to the emission of the
// `GApplication::activate` signal.
// 
// This call is equivalent to setting the [property@Gtk.Window:application]
// property of `window` to `application`.
// 
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it with
// [method@Gtk.Application.remove_window].
// 
// GTK will keep the `application` running as long as it has any windows.
	func (a Application) AddWindow(window WindowClass)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_application_add_window(_arg0, _arg1)
}
	
	// AccelsForAction gets the accelerators that are currently associated with the
// given action.
	func (a Application) AccelsForAction(detailedActionName string) []string {
var _arg0 *C.GtkApplication // out
var _arg1 *C.char // out
var _cret **C.char

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(detailedActionName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_application_get_accels_for_action(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// ActionsForAccel returns the list of actions (possibly empty) that `accel`
// maps to.
// 
// Each item in the list is a detailed action name in the usual form.
// 
// This might be useful to discover if an accel already exists in order to
// prevent installation of a conflicting accelerator (from an accelerator editor
// or a plugin system, for example). Note that having more than one action per
// accelerator may not be a bad thing and might make sense in cases where the
// actions never appear in the same context.
// 
// In case there are no actions for a given accelerator, an empty array is
// returned. `NULL` is never returned.
// 
// It is a programmer error to pass an invalid accelerator string.
// 
// If you are unsure, check it with [func@Gtk.accelerator_parse] first.
	func (a Application) ActionsForAccel(accel string) []string {
var _arg0 *C.GtkApplication // out
var _arg1 *C.char // out
var _cret **C.char

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(accel))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_application_get_actions_for_accel(_arg0, _arg1)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// ActiveWindow gets the active window for the application.
// 
// The active window is the one that was most recently focused (within the
// application). This window may not have the focus at the moment if another
// application has it  this is just the most recently-focused window within
// this application.
	func (a Application) ActiveWindow() Window {
var _arg0 *C.GtkApplication // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_get_active_window(_arg0)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// MenuByID gets a menu from automatically loaded resources.
// 
// See the section on Automatic resources
// (class.Application.html#automatic-resources) for more information.
	func (a Application) MenuByID(id string) gio.Menu {
var _arg0 *C.GtkApplication // out
var _arg1 *C.char // out
var _cret *C.GMenu // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_application_get_menu_by_id(_arg0, _arg1)


var _menu gio.Menu // out

_menu = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Menu)

return _menu
}
	
	// Menubar returns the menu model that has been set with
// [method@Gtk.Application.set_menubar].
	func (a Application) Menubar() gio.MenuModel {
var _arg0 *C.GtkApplication // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_get_menubar(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// WindowByID returns the [class@Gtk.ApplicationWindow] with the given ID.
// 
// The ID of a `GtkApplicationWindow` can be retrieved with
// [method@Gtk.ApplicationWindow.get_id].
	func (a Application) WindowByID(id uint) Window {
var _arg0 *C.GtkApplication // out
var _arg1 C.guint // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(id)

_cret = C.gtk_application_get_window_by_id(_arg0, _arg1)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// Inhibit: inform the session manager that certain types of actions should be
// inhibited.
// 
// This is not guaranteed to work on all platforms and for all types of actions.
// 
// Applications should invoke this method when they begin an operation that
// should not be interrupted, such as creating a CD or DVD. The types of actions
// that may be blocked are specified by the `flags` parameter. When the
// application completes the operation it should call
// [method@Gtk.Application.uninhibit] to remove the inhibitor. Note that an
// application can have multiple inhibitors, and all of them must be
// individually removed. Inhibitors are also cleared when the application exits.
// 
// Applications should not expect that they will always be able to block the
// action. In most cases, users will be given the option to force the action to
// take place.
// 
// The `reason` message should be short and to the point.
// 
// If `window` is given, the session manager may point the user to this window
// to find out more about why the action is inhibited.
	func (a Application) Inhibit(window WindowClass, flags ApplicationInhibitFlags, reason string) uint {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GtkWindow // out
var _arg2 C.GtkApplicationInhibitFlags // out
var _arg3 *C.char // out
var _cret C.guint // in

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))
_arg2 = (C.GtkApplicationInhibitFlags)(flags)
_arg3 = (*C.char)(C.CString(reason))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.gtk_application_inhibit(_arg0, _arg1, _arg2, _arg3)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// ListActionDescriptions lists the detailed action names which have associated
// accelerators.
// 
// See [method@Gtk.Application.set_accels_for_action].
	func (a Application) ListActionDescriptions() []string {
var _arg0 *C.GtkApplication // out
var _cret **C.char

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))

_cret = C.gtk_application_list_action_descriptions(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// RemoveWindow: remove a window from `application`.
// 
// If `window` belongs to `application` then this call is equivalent to setting
// the [property@Gtk.Window:application] property of `window` to `NULL`.
// 
// The application may stop running as a result of a call to this function, if
// `window` was the last window of the `application`.
	func (a Application) RemoveWindow(window WindowClass)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_application_remove_window(_arg0, _arg1)
}
	
	// SetAccelsForAction sets zero or more keyboard accelerators that will trigger
// the given action.
// 
// The first item in `accels` will be the primary accelerator, which may be
// displayed in the UI.
// 
// To remove all accelerators for an action, use an empty, zero-terminated array
// for `accels`.
// 
// For the `detailed_action_name`, see `g_action_parse_detailed_name()` and
// `g_action_print_detailed_name()`.
	func (a Application) SetAccelsForAction(detailedActionName string, accels []string)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.char // out
var _arg2 **C.char

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.char)(C.CString(detailedActionName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.char)(C.malloc(C.ulong(len(accels)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(accels))
for i := range accels {
out[i] = (*C.char)(C.CString(accels[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_application_set_accels_for_action(_arg0, _arg1, _arg2)
}
	
	// SetMenubar sets or unsets the menubar for windows of `application`.
// 
// This is a menubar in the traditional sense.
// 
// This can only be done in the primary instance of the application, after it
// has been registered. `GApplication::startup` is a good place to call this.
// 
// Depending on the desktop environment, this may appear at the top of each
// window, or at the top of the screen. In some environments, if both the
// application menu and the menubar are set, the application menu will be
// presented as if it were the first item of the menubar. Other environments
// treat the two as completely separate  for example, the application menu may
// be rendered by the desktop shell while the menubar (if set) remains in each
// individual window.
// 
// Use the base `GActionMap` interface to add actions, to respond to the user
// selecting these menu items.
	func (a Application) SetMenubar(menubar gio.MenuModelClass)  {
var _arg0 *C.GtkApplication // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(menubar.Native()))

C.gtk_application_set_menubar(_arg0, _arg1)
}
	
	// Uninhibit removes an inhibitor that has been previously established.
// 
// See [method@Gtk.Application.inhibit].
// 
// Inhibitors are also cleared when the application exits.
	func (a Application) Uninhibit(cookie uint)  {
var _arg0 *C.GtkApplication // out
var _arg1 C.guint // out

_arg0 = (*C.GtkApplication)(unsafe.Pointer(a.Native()))
_arg1 = (C.guint)(cookie)

C.gtk_application_uninhibit(_arg0, _arg1)
}
	


	// ApplicationWindow: `GtkApplicationWindow` is a `GtkWindow` subclass that
// integrates with `GtkApplication`.
// 
// Notably, `GtkApplicationWindow` can handle an application menubar.
// 
// This class implements the `GActionGroup` and `GActionMap` interfaces, to let
// you add window-specific actions that will be exported by the associated
// [class@Gtk.Application], together with its application-wide actions.
// Window-specific actions are prefixed with the win. prefix and
// application-wide actions are prefixed with the app. prefix. Actions must be
// addressed with the prefixed name when referring to them from a `GMenuModel`.
// 
// Note that widgets that are placed inside a `GtkApplicationWindow` can also
// activate these actions, if they implement the [iface@Gtk.Actionable]
// interface.
// 
// The settings [property@Gtk.Settings:gtk-shell-shows-app-menu] and
// [property@Gtk.Settings:gtk-shell-shows-menubar] tell GTK whether the desktop
// environment is showing the application menu and menubar models outside the
// application as part of the desktop shell. For instance, on OS X, both menus
// will be displayed remotely; on Windows neither will be.
// 
// If the desktop environment does not display the menubar, then
// `GtkApplicationWindow` will automatically show a menubar for it. This
// behaviour can be overridden with the
// [property@Gtk.ApplicationWindow:show-menubar] property. If the desktop
// environment does not display the application menu, then it will automatically
// be included in the menubar or in the windows client-side decorations.
// 
// See [class@Gtk.PopoverMenu] for information about the XML language used by
// `GtkBuilder` for menu models.
// 
// See also: [method@Gtk.Application.set_menubar].
// 
// 
// A GtkApplicationWindow with a menubar
// 
// The code sample below shows how to set up a `GtkApplicationWindow` with a
// menu bar defined on the [class@Gtk.Application]:
// 
// `c GtkApplication *app = gtk_application_new ("org.gtk.test", 0);
// 
// GtkBuilder *builder = gtk_builder_new_from_string ( "<interface>" " <menu
// id='menubar'>" " <submenu>" " <attribute name='label'
// translatable='yes'>_Edit</attribute>" " <item>" " <attribute name='label'
// translatable='yes'>_Copy</attribute>" " <attribute
// name='action'>win.copy</attribute>" " </item>" " <item>" " <attribute
// name='label' translatable='yes'>_Paste</attribute>" " <attribute
// name='action'>win.paste</attribute>" " </item>" " </submenu>" " </menu>"
// "</interface>", -1);
// 
// GMenuModel *menubar = G_MENU_MODEL (gtk_builder_get_object (builder,
// "menubar")); gtk_application_set_menubar (GTK_APPLICATION (app), menubar);
// g_object_unref (builder);
// 
// // ...
// 
// GtkWidget *window = gtk_application_window_new (app); `
	type ApplicationWindow struct {
		Window
		gio.ActionGroup
		gio.ActionMap
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// ApplicationWindowClass is an interface that the ApplicationWindow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ApplicationWindowClass interface {
		gextras.Objector
		_applicationWindow()
	}

	func (ApplicationWindow) _applicationWindow() {}

	
	func marshalApplicationWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapApplicationWindow(obj), nil
	}
	

	
	// NewApplicationWindow creates a new `GtkApplicationWindow`.
	func NewApplicationWindow(application ApplicationClass) ApplicationWindow {
var _arg1 *C.GtkApplication // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

_cret = C.gtk_application_window_new(_arg1)


var _applicationWindow ApplicationWindow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_applicationWindow = ApplicationWindow{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
ActionGroup: gio.ActionGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ActionMap: gio.ActionMap{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _applicationWindow
}
	

	
	// HelpOverlay gets the `GtkShortcutsWindow` that is associated with @window.
// 
// See [method@Gtk.ApplicationWindow.set_help_overlay].
	func (w ApplicationWindow) HelpOverlay() ShortcutsWindow {
var _arg0 *C.GtkApplicationWindow // out
var _cret *C.GtkShortcutsWindow // in

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_application_window_get_help_overlay(_arg0)


var _shortcutsWindow ShortcutsWindow // out

_shortcutsWindow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutsWindow)

return _shortcutsWindow
}
	
	// ID returns the unique ID of the window.
// 
//    If the window has not yet been added to a `GtkApplication`, returns `0`.
	func (w ApplicationWindow) ID() uint {
var _arg0 *C.GtkApplicationWindow // out
var _cret C.guint // in

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_application_window_get_id(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// ShowMenubar returns whether the window will display a menubar for the app
// menu and menubar as needed.
	func (w ApplicationWindow) ShowMenubar() bool {
var _arg0 *C.GtkApplicationWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_application_window_get_show_menubar(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetHelpOverlay associates a shortcuts window with the application window.
// 
// Additionally, sets up an action with the name `win.show-help-overlay` to
// present it.
// 
// @window takes responsibility for destroying @help_overlay.
	func (w ApplicationWindow) SetHelpOverlay(helpOverlay ShortcutsWindowClass)  {
var _arg0 *C.GtkApplicationWindow // out
var _arg1 *C.GtkShortcutsWindow // out

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkShortcutsWindow)(unsafe.Pointer(helpOverlay.Native()))

C.gtk_application_window_set_help_overlay(_arg0, _arg1)
}
	
	// SetShowMenubar sets whether the window will display a menubar for the app
// menu and menubar as needed.
	func (w ApplicationWindow) SetShowMenubar(showMenubar bool)  {
var _arg0 *C.GtkApplicationWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkApplicationWindow)(unsafe.Pointer(w.Native()))
if showMenubar { _arg1 = C.TRUE }

C.gtk_application_window_set_show_menubar(_arg0, _arg1)
}
	


	// AspectFrame: `GtkAspectFrame` preserves the aspect ratio of its child.
// 
// The frame can respect the aspect ratio of the child widget, or use its own
// aspect ratio.
// 
// 
// CSS nodes
// 
// `GtkAspectFrame` uses a CSS node with name `frame`.
	type AspectFrame struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// AspectFrameClass is an interface that the AspectFrame class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AspectFrameClass interface {
		gextras.Objector
		_aspectFrame()
	}

	func (AspectFrame) _aspectFrame() {}

	
	func marshalAspectFrame(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAspectFrame(obj), nil
	}
	

	
	// NewAspectFrame: create a new `GtkAspectFrame`.
	func NewAspectFrame(xalign float32, yalign float32, ratio float32, obeyChild bool) AspectFrame {
var _arg1 C.float // out
var _arg2 C.float // out
var _arg3 C.float // out
var _arg4 C.gboolean // out
var _cret *C.GtkWidget // in

_arg1 = (C.float)(xalign)
_arg2 = (C.float)(yalign)
_arg3 = (C.float)(ratio)
if obeyChild { _arg4 = C.TRUE }

_cret = C.gtk_aspect_frame_new(_arg1, _arg2, _arg3, _arg4)


var _aspectFrame AspectFrame // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_aspectFrame = AspectFrame{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _aspectFrame
}
	

	
	// Child gets the child widget of @self.
	func (s AspectFrame) Child() Widget {
var _arg0 *C.GtkAspectFrame // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

_cret = C.gtk_aspect_frame_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ObeyChild returns whether the child's size request should override the set
// aspect ratio of the `GtkAspectFrame`.
	func (s AspectFrame) ObeyChild() bool {
var _arg0 *C.GtkAspectFrame // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

_cret = C.gtk_aspect_frame_get_obey_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ratio returns the desired aspect ratio of the child.
	func (s AspectFrame) Ratio() float32 {
var _arg0 *C.GtkAspectFrame // out
var _cret C.float // in

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

_cret = C.gtk_aspect_frame_get_ratio(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Xalign returns the horizontal alignment of the child within the allocation of
// the `GtkAspectFrame`.
	func (s AspectFrame) Xalign() float32 {
var _arg0 *C.GtkAspectFrame // out
var _cret C.float // in

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

_cret = C.gtk_aspect_frame_get_xalign(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Yalign returns the vertical alignment of the child within the allocation of
// the `GtkAspectFrame`.
	func (s AspectFrame) Yalign() float32 {
var _arg0 *C.GtkAspectFrame // out
var _cret C.float // in

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))

_cret = C.gtk_aspect_frame_get_yalign(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// SetChild sets the child widget of @self.
	func (s AspectFrame) SetChild(child WidgetClass)  {
var _arg0 *C.GtkAspectFrame // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_aspect_frame_set_child(_arg0, _arg1)
}
	
	// SetObeyChild sets whether the aspect ratio of the child's size request should
// override the set aspect ratio of the `GtkAspectFrame`.
	func (s AspectFrame) SetObeyChild(obeyChild bool)  {
var _arg0 *C.GtkAspectFrame // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
if obeyChild { _arg1 = C.TRUE }

C.gtk_aspect_frame_set_obey_child(_arg0, _arg1)
}
	
	// SetRatio sets the desired aspect ratio of the child.
	func (s AspectFrame) SetRatio(ratio float32)  {
var _arg0 *C.GtkAspectFrame // out
var _arg1 C.float // out

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(ratio)

C.gtk_aspect_frame_set_ratio(_arg0, _arg1)
}
	
	// SetXalign sets the horizontal alignment of the child within the allocation of
// the `GtkAspectFrame`.
	func (s AspectFrame) SetXalign(xalign float32)  {
var _arg0 *C.GtkAspectFrame // out
var _arg1 C.float // out

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(xalign)

C.gtk_aspect_frame_set_xalign(_arg0, _arg1)
}
	
	// SetYalign sets the vertical alignment of the child within the allocation of
// the `GtkAspectFrame`.
	func (s AspectFrame) SetYalign(yalign float32)  {
var _arg0 *C.GtkAspectFrame // out
var _arg1 C.float // out

_arg0 = (*C.GtkAspectFrame)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(yalign)

C.gtk_aspect_frame_set_yalign(_arg0, _arg1)
}
	


	// Assistant: `GtkAssistant` is used to represent a complex as a series of
// steps.
// 
// !An example GtkAssistant (assistant.png)
// 
// Each step consists of one or more pages. `GtkAssistant` guides the user
// through the pages, and controls the page flow to collect the data needed for
// the operation.
// 
// `GtkAssistant` handles which buttons to show and to make sensitive based on
// page sequence knowledge and the [enum@Gtk.AssistantPageType] of each page in
// addition to state information like the *completed* and *committed* page
// statuses.
// 
// If you have a case that doesnt quite fit in `GtkAssistant`s way of handling
// buttons, you can use the GTK_ASSISTANT_PAGE_CUSTOM page type and handle
// buttons yourself.
// 
// `GtkAssistant` maintains a `GtkAssistantPage` object for each added child,
// which holds additional per-child properties. You obtain the
// `GtkAssistantPage` for a child with [method@Gtk.Assistant.get_page].
// 
// 
// GtkAssistant as GtkBuildable
// 
// The `GtkAssistant` implementation of the `GtkBuildable` interface exposes the
// @action_area as internal children with the name action_area.
// 
// To add pages to an assistant in `GtkBuilder`, simply add it as a child to the
// `GtkAssistant` object. If you need to set per-object properties, create a
// `GtkAssistantPage` object explicitly, and set the child widget as a property
// on it.
// 
// 
// CSS nodes
// 
// `GtkAssistant` has a single CSS node with the name window and style class
// .assistant.
	type Assistant struct {
		Window
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// AssistantClass is an interface that the Assistant class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AssistantClass interface {
		gextras.Objector
		_assistant()
	}

	func (Assistant) _assistant() {}

	
	func marshalAssistant(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAssistant(obj), nil
	}
	

	
	// NewAssistant creates a new `GtkAssistant`.
	func NewAssistant() Assistant {
var _cret *C.GtkWidget // in

_cret = C.gtk_assistant_new()


var _assistant Assistant // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_assistant = Assistant{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _assistant
}
	

	
	// AddActionWidget adds a widget to the action area of a `GtkAssistant`.
	func (a Assistant) AddActionWidget(child WidgetClass)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_assistant_add_action_widget(_arg0, _arg1)
}
	
	// AppendPage appends a page to the @assistant.
	func (a Assistant) AppendPage(page WidgetClass) int {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_append_page(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Commit erases the visited page history.
// 
// GTK will then hide the back button on the current page, and removes the
// cancel button from subsequent pages.
// 
// Use this when the information provided up to the current page is hereafter
// deemed permanent and cannot be modified or undone. For example, showing a
// progress page to track a long-running, unreversible operation after the user
// has clicked apply on a confirmation page.
	func (a Assistant) Commit()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_commit(_arg0)
}
	
	// CurrentPage returns the page number of the current page.
	func (a Assistant) CurrentPage() int {
var _arg0 *C.GtkAssistant // out
var _cret C.int // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

_cret = C.gtk_assistant_get_current_page(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NPages returns the number of pages in the @assistant
	func (a Assistant) NPages() int {
var _arg0 *C.GtkAssistant // out
var _cret C.int // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

_cret = C.gtk_assistant_get_n_pages(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NthPage returns the child widget contained in page number @page_num.
	func (a Assistant) NthPage(pageNum int) Widget {
var _arg0 *C.GtkAssistant // out
var _arg1 C.int // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (C.int)(pageNum)

_cret = C.gtk_assistant_get_nth_page(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Page returns the `GtkAssistantPage` object for @child.
	func (a Assistant) Page(child WidgetClass) AssistantPage {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkAssistantPage // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_assistant_get_page(_arg0, _arg1)


var _assistantPage AssistantPage // out

_assistantPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(AssistantPage)

return _assistantPage
}
	
	// PageComplete gets whether @page is complete.
	func (a Assistant) PageComplete(page WidgetClass) bool {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_complete(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PageTitle gets the title for @page.
	func (a Assistant) PageTitle(page WidgetClass) string {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_title(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PageType gets the page type of @page.
	func (a Assistant) PageType(page WidgetClass) AssistantPageType {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.GtkAssistantPageType // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_get_page_type(_arg0, _arg1)


var _assistantPageType AssistantPageType // out

_assistantPageType = AssistantPageType(_cret)

return _assistantPageType
}
	
	// Pages gets a list model of the assistant pages.
	func (a Assistant) Pages() gio.ListModel {
var _arg0 *C.GtkAssistant // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

_cret = C.gtk_assistant_get_pages(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// InsertPage inserts a page in the @assistant at a given position.
	func (a Assistant) InsertPage(page WidgetClass, position int) int {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out
var _cret C.int // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (C.int)(position)

_cret = C.gtk_assistant_insert_page(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NextPage: navigate to the next page.
// 
// It is a programming error to call this function when there is no next page.
// 
// This function is for use when creating pages of the GTK_ASSISTANT_PAGE_CUSTOM
// type.
	func (a Assistant) NextPage()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_next_page(_arg0)
}
	
	// PrependPage prepends a page to the @assistant.
	func (a Assistant) PrependPage(page WidgetClass) int {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))

_cret = C.gtk_assistant_prepend_page(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PreviousPage: navigate to the previous visited page.
// 
// It is a programming error to call this function when no previous page is
// available.
// 
// This function is for use when creating pages of the GTK_ASSISTANT_PAGE_CUSTOM
// type.
	func (a Assistant) PreviousPage()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_previous_page(_arg0)
}
	
	// RemoveActionWidget removes a widget from the action area of a `GtkAssistant`.
	func (a Assistant) RemoveActionWidget(child WidgetClass)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_assistant_remove_action_widget(_arg0, _arg1)
}
	
	// RemovePage removes the @page_nums page from @assistant.
	func (a Assistant) RemovePage(pageNum int)  {
var _arg0 *C.GtkAssistant // out
var _arg1 C.int // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (C.int)(pageNum)

C.gtk_assistant_remove_page(_arg0, _arg1)
}
	
	// SetCurrentPage switches the page to @page_num.
// 
// Note that this will only be necessary in custom buttons, as the @assistant
// flow can be set with gtk_assistant_set_forward_page_func().
	func (a Assistant) SetCurrentPage(pageNum int)  {
var _arg0 *C.GtkAssistant // out
var _arg1 C.int // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (C.int)(pageNum)

C.gtk_assistant_set_current_page(_arg0, _arg1)
}
	
	// SetPageComplete sets whether @page contents are complete.
// 
// This will make @assistant update the buttons state to be able to continue the
// task.
	func (a Assistant) SetPageComplete(page WidgetClass, complete bool)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
if complete { _arg2 = C.TRUE }

C.gtk_assistant_set_page_complete(_arg0, _arg1, _arg2)
}
	
	// SetPageTitle sets a title for @page.
// 
// The title is displayed in the header area of the assistant when @page is the
// current page.
	func (a Assistant) SetPageTitle(page WidgetClass, title string)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.char // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_assistant_set_page_title(_arg0, _arg1, _arg2)
}
	
	// SetPageType sets the page type for @page.
// 
// The page type determines the page behavior in the @assistant.
	func (a Assistant) SetPageType(page WidgetClass, typ AssistantPageType)  {
var _arg0 *C.GtkAssistant // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkAssistantPageType // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(page.Native()))
_arg2 = (C.GtkAssistantPageType)(typ)

C.gtk_assistant_set_page_type(_arg0, _arg1, _arg2)
}
	
	// UpdateButtonsState forces @assistant to recompute the buttons state.
// 
// GTK automatically takes care of this in most situations, e.g. when the user
// goes to a different page, or when the visibility or completeness of a page
// changes.
// 
// One situation where it can be necessary to call this function is when
// changing a value on the current page affects the future page flow of the
// assistant.
	func (a Assistant) UpdateButtonsState()  {
var _arg0 *C.GtkAssistant // out

_arg0 = (*C.GtkAssistant)(unsafe.Pointer(a.Native()))

C.gtk_assistant_update_buttons_state(_arg0)
}
	


	// AssistantPage: `GtkAssistantPage` is an auxiliary object used by
// `GtkAssistant.
	type AssistantPage struct {
		**externglib.Object
		
	}

	// AssistantPageClass is an interface that the AssistantPage class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type AssistantPageClass interface {
		gextras.Objector
		_assistantPage()
	}

	func (AssistantPage) _assistantPage() {}

	
	func marshalAssistantPage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapAssistantPage(obj), nil
	}
	

	

	
	// Child returns the child to which @page belongs.
	func (p AssistantPage) Child() Widget {
var _arg0 *C.GtkAssistantPage // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkAssistantPage)(unsafe.Pointer(p.Native()))

_cret = C.gtk_assistant_page_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	


	// BinLayout: `GtkBinLayout` is a `GtkLayoutManager` subclass useful for create
// "bins" of widgets.
// 
// `GtkBinLayout` will stack each child of a widget on top of each other, using
// the [property@Gtk.Widget:hexpand], [property@Gtk.Widget:vexpand],
// [property@Gtk.Widget:halign], and [property@Gtk.Widget:valign] properties of
// each child to determine where they should be positioned.
	type BinLayout struct {
		LayoutManager
		
	}

	// BinLayoutClass is an interface that the BinLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BinLayoutClass interface {
		gextras.Objector
		_binLayout()
	}

	func (BinLayout) _binLayout() {}

	
	func marshalBinLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBinLayout(obj), nil
	}
	

	
	// NewBinLayout creates a new `GtkBinLayout` instance.
	func NewBinLayout() BinLayout {
var _cret *C.GtkLayoutManager // in

_cret = C.gtk_bin_layout_new()


var _binLayout BinLayout // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_binLayout = BinLayout{
LayoutManager: LayoutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _binLayout
}
	

	


	// BookmarkList: `GtkBookmarkList` is a list model that wraps `GBookmarkFile`.
// 
// It presents a `GListModel` and fills it asynchronously with the `GFileInfo`s
// returned from that function.
// 
// The `GFileInfo`s in the list have some attributes in the recent namespace
// added: `recent::private` (boolean) and `recent:applications` (stringv).
	type BookmarkList struct {
		**externglib.Object
		gio.ListModel
		
	}

	// BookmarkListClass is an interface that the BookmarkList class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BookmarkListClass interface {
		gextras.Objector
		_bookmarkList()
	}

	func (BookmarkList) _bookmarkList() {}

	
	func marshalBookmarkList(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBookmarkList(obj), nil
	}
	

	
	// NewBookmarkList creates a new `GtkBookmarkList` with the given @attributes.
	func NewBookmarkList(filename string, attributes string) BookmarkList {
var _arg1 *C.char // out
var _arg2 *C.char // out
var _cret *C.GtkBookmarkList // in

_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_bookmark_list_new(_arg1, _arg2)


var _bookmarkList BookmarkList // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_bookmarkList = BookmarkList{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _bookmarkList
}
	

	
	// Attributes gets the attributes queried on the children.
	func (s BookmarkList) Attributes() string {
var _arg0 *C.GtkBookmarkList // out
var _cret *C.char // in

_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bookmark_list_get_attributes(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Filename returns the filename of the bookmark file that this list is loading.
	func (s BookmarkList) Filename() string {
var _arg0 *C.GtkBookmarkList // out
var _cret *C.char // in

_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bookmark_list_get_filename(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IOPriority gets the IO priority to use while loading file.
	func (s BookmarkList) IOPriority() int {
var _arg0 *C.GtkBookmarkList // out
var _cret C.int // in

_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bookmark_list_get_io_priority(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsLoading returns true if the files are currently being loaded.
// 
// Files will be added to @self from time to time while loading is going on. The
// order in which are added is undefined and may change in between runs.
	func (s BookmarkList) IsLoading() bool {
var _arg0 *C.GtkBookmarkList // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bookmark_list_is_loading(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAttributes sets the @attributes to be enumerated and starts the
// enumeration.
// 
// If @attributes is nil, no attributes will be queried, but a list of Infos
// will still be created.
	func (s BookmarkList) SetAttributes(attributes string)  {
var _arg0 *C.GtkBookmarkList // out
var _arg1 *C.char // out

_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_bookmark_list_set_attributes(_arg0, _arg1)
}
	
	// SetIOPriority sets the IO priority to use while loading files.
// 
// The default IO priority is G_PRIORITY_DEFAULT.
	func (s BookmarkList) SetIOPriority(ioPriority int)  {
var _arg0 *C.GtkBookmarkList // out
var _arg1 C.int // out

_arg0 = (*C.GtkBookmarkList)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(ioPriority)

C.gtk_bookmark_list_set_io_priority(_arg0, _arg1)
}
	


	// BoolFilter: `GtkBoolFilter` evaluates a boolean `GtkExpression` to determine
// whether to include items.
	type BoolFilter struct {
		Filter
		
	}

	// BoolFilterClass is an interface that the BoolFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BoolFilterClass interface {
		gextras.Objector
		_boolFilter()
	}

	func (BoolFilter) _boolFilter() {}

	
	func marshalBoolFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBoolFilter(obj), nil
	}
	

	
	// NewBoolFilter creates a new bool filter.
	func NewBoolFilter(expression ExpressionClass) BoolFilter {
var _arg1 *C.GtkExpression // out
var _cret *C.GtkBoolFilter // in

_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

_cret = C.gtk_bool_filter_new(_arg1)


var _boolFilter BoolFilter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_boolFilter = BoolFilter{
Filter: Filter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _boolFilter
}
	

	
	// Expression gets the expression that the filter uses to evaluate if an item
// should be filtered.
	func (s BoolFilter) Expression() Expression {
var _arg0 *C.GtkBoolFilter // out
var _cret *C.GtkExpression // in

_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bool_filter_get_expression(_arg0)


var _expression Expression // out

_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

return _expression
}
	
	// Invert returns whether the filter inverts the expression.
	func (s BoolFilter) Invert() bool {
var _arg0 *C.GtkBoolFilter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bool_filter_get_invert(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetExpression sets the expression that the filter uses to check if items
// should be filtered.
// 
// The expression must have a value type of G_TYPE_BOOLEAN.
	func (s BoolFilter) SetExpression(expression ExpressionClass)  {
var _arg0 *C.GtkBoolFilter // out
var _arg1 *C.GtkExpression // out

_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

C.gtk_bool_filter_set_expression(_arg0, _arg1)
}
	
	// SetInvert sets whether the filter should invert the expression.
	func (s BoolFilter) SetInvert(invert bool)  {
var _arg0 *C.GtkBoolFilter // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkBoolFilter)(unsafe.Pointer(s.Native()))
if invert { _arg1 = C.TRUE }

C.gtk_bool_filter_set_invert(_arg0, _arg1)
}
	


	// Box: the `GtkBox` widget arranges child widgets into a single row or column.
// 
// !An example GtkBox (box.png)
// 
// Whether it is a row or column depends on the value of its
// [property@Gtk.Orientable:orientation] property. Within the other dimension,
// all children are allocated the same size. Of course, the
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties can
// be used on the children to influence their allocation.
// 
// Use repeated calls to [method@Gtk.Box.append] to pack widgets into a `GtkBox`
// from start to end. Use [method@Gtk.Box.remove] to remove widgets from the
// `GtkBox`. [method@Gtk.Box.insert_child_after] can be used to add a child at a
// particular position.
// 
// Use [method@Gtk.Box.set_homogeneous] to specify whether or not all children
// of the `GtkBox` are forced to get the same amount of space.
// 
// Use [method@Gtk.Box.set_spacing] to determine how much space will be
// minimally placed between all children in the `GtkBox`. Note that spacing is
// added *between* the children.
// 
// Use [method@Gtk.Box.reorder_child_after] to move a child to a different place
// in the box.
// 
// 
// CSS nodes
// 
// `GtkBox` uses a single CSS node with name box.
// 
// 
// Accessibility
// 
// `GtkBox` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type Box struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// BoxClass is an interface that the Box class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BoxClass interface {
		gextras.Objector
		_box()
	}

	func (Box) _box() {}

	
	func marshalBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBox(obj), nil
	}
	

	
	// NewBox creates a new `GtkBox`.
	func NewBox(orientation Orientation, spacing int) Box {
var _arg1 C.GtkOrientation // out
var _arg2 C.int // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (C.int)(spacing)

_cret = C.gtk_box_new(_arg1, _arg2)


var _box Box // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_box = Box{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _box
}
	

	
	// Append adds @child as the last child to @box.
	func (b Box) Append(child WidgetClass)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_box_append(_arg0, _arg1)
}
	
	// BaselinePosition gets the value set by gtk_box_set_baseline_position().
	func (b Box) BaselinePosition() BaselinePosition {
var _arg0 *C.GtkBox // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_get_baseline_position(_arg0)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// Homogeneous returns whether the box is homogeneous (all children are the same
// size).
	func (b Box) Homogeneous() bool {
var _arg0 *C.GtkBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Spacing gets the value set by gtk_box_set_spacing().
	func (b Box) Spacing() int {
var _arg0 *C.GtkBox // out
var _cret C.int // in

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InsertChildAfter inserts @child in the position after @sibling in the list of
// @box children.
// 
// If @sibling is nil, insert @child at the first position.
	func (b Box) InsertChildAfter(child WidgetClass, sibling WidgetClass)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))

C.gtk_box_insert_child_after(_arg0, _arg1, _arg2)
}
	
	// Prepend adds @child as the first child to @box.
	func (b Box) Prepend(child WidgetClass)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_box_prepend(_arg0, _arg1)
}
	
	// Remove removes a child widget from @box.
// 
// The child must have been added before with [method@Gtk.Box.append],
// [method@Gtk.Box.prepend], or [method@Gtk.Box.insert_child_after].
	func (b Box) Remove(child WidgetClass)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_box_remove(_arg0, _arg1)
}
	
	// ReorderChildAfter moves @child to the position after @sibling in the list of
// @box children.
// 
// If @sibling is nil, move @child to the first position.
	func (b Box) ReorderChildAfter(child WidgetClass, sibling WidgetClass)  {
var _arg0 *C.GtkBox // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))

C.gtk_box_reorder_child_after(_arg0, _arg1, _arg2)
}
	
	// SetBaselinePosition sets the baseline position of a box.
// 
// This affects only horizontal boxes with at least one baseline aligned child.
// If there is more vertical space available than requested, and the baseline is
// not allocated by the parent then @position is used to allocate the baseline
// with respect to the extra space available.
	func (b Box) SetBaselinePosition(position BaselinePosition)  {
var _arg0 *C.GtkBox // out
var _arg1 C.GtkBaselinePosition // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkBaselinePosition)(position)

C.gtk_box_set_baseline_position(_arg0, _arg1)
}
	
	// SetHomogeneous sets whether or not all children of @box are given equal space
// in the box.
	func (b Box) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_box_set_homogeneous(_arg0, _arg1)
}
	
	// SetSpacing sets the number of pixels to place between children of @box.
	func (b Box) SetSpacing(spacing int)  {
var _arg0 *C.GtkBox // out
var _arg1 C.int // out

_arg0 = (*C.GtkBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.int)(spacing)

C.gtk_box_set_spacing(_arg0, _arg1)
}
	


	// BoxLayout: `GtkBoxLayout` is a layout manager that arranges children in a
// single row or column.
// 
// Whether it is a row or column depends on the value of its
// [property@Gtk.Orientable:orientation] property. Within the other dimension
// all children all allocated the same size. The `GtkBoxLayout` will respect the
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties of
// each child widget.
// 
// If you want all children to be assigned the same size, you can use the
// [property@Gtk.BoxLayout:homogeneous] property.
// 
// If you want to specify the amount of space placed between each child, you can
// use the [property@Gtk.BoxLayout:spacing] property.
	type BoxLayout struct {
		LayoutManager
		Orientable
		
	}

	// BoxLayoutClass is an interface that the BoxLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BoxLayoutClass interface {
		gextras.Objector
		_boxLayout()
	}

	func (BoxLayout) _boxLayout() {}

	
	func marshalBoxLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBoxLayout(obj), nil
	}
	

	
	// NewBoxLayout creates a new `GtkBoxLayout`.
	func NewBoxLayout(orientation Orientation) BoxLayout {
var _arg1 C.GtkOrientation // out
var _cret *C.GtkLayoutManager // in

_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_box_layout_new(_arg1)


var _boxLayout BoxLayout // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_boxLayout = BoxLayout{
LayoutManager: LayoutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _boxLayout
}
	

	
	// BaselinePosition gets the value set by
// gtk_box_layout_set_baseline_position().
	func (b BoxLayout) BaselinePosition() BaselinePosition {
var _arg0 *C.GtkBoxLayout // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_layout_get_baseline_position(_arg0)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// Homogeneous returns whether the layout is set to be homogeneous.
	func (b BoxLayout) Homogeneous() bool {
var _arg0 *C.GtkBoxLayout // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_layout_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Spacing returns the space that @box_layout puts between children.
	func (b BoxLayout) Spacing() uint {
var _arg0 *C.GtkBoxLayout // out
var _cret C.guint // in

_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))

_cret = C.gtk_box_layout_get_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SetBaselinePosition sets the baseline position of a box layout.
// 
// The baseline position affects only horizontal boxes with at least one
// baseline aligned child. If there is more vertical space available than
// requested, and the baseline is not allocated by the parent then the given
// @position is used to allocate the baseline within the extra space available.
	func (b BoxLayout) SetBaselinePosition(position BaselinePosition)  {
var _arg0 *C.GtkBoxLayout // out
var _arg1 C.GtkBaselinePosition // out

_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkBaselinePosition)(position)

C.gtk_box_layout_set_baseline_position(_arg0, _arg1)
}
	
	// SetHomogeneous sets whether the box layout will allocate the same size to all
// children.
	func (b BoxLayout) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkBoxLayout // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_box_layout_set_homogeneous(_arg0, _arg1)
}
	
	// SetSpacing sets how much spacing to put between children.
	func (b BoxLayout) SetSpacing(spacing uint)  {
var _arg0 *C.GtkBoxLayout // out
var _arg1 C.guint // out

_arg0 = (*C.GtkBoxLayout)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_box_layout_set_spacing(_arg0, _arg1)
}
	


	// Builder: a `GtkBuilder` reads XML descriptions of a user interface and
// instantiates the described objects.
// 
// To create a `GtkBuilder` from a user interface description, call
// [ctor@Gtk.Builder.new_from_file], [ctor@Gtk.Builder.new_from_resource] or
// [ctor@Gtk.Builder.new_from_string].
// 
// In the (unusual) case that you want to add user interface descriptions from
// multiple sources to the same `GtkBuilder` you can call [ctor@Gtk.Builder.new]
// to get an empty builder and populate it by (multiple) calls to
// [method@Gtk.Builder.add_from_file], [method@Gtk.Builder.add_from_resource] or
// [method@Gtk.Builder.add_from_string].
// 
// A `GtkBuilder` holds a reference to all objects that it has constructed and
// drops these references when it is finalized. This finalization can cause the
// destruction of non-widget objects or widgets which are not contained in a
// toplevel window. For toplevel windows constructed by a builder, it is the
// responsibility of the user to call [method@Gtk.Window.destroy] to get rid of
// them and all the widgets they contain.
// 
// The functions [method@Gtk.Builder.get_object] and
// [method@Gtk.Builder.get_objects] can be used to access the widgets in the
// interface by the names assigned to them inside the UI description. Toplevel
// windows returned by these functions will stay around until the user
// explicitly destroys them with [method@Gtk.Window.destroy]. Other widgets will
// either be part of a larger hierarchy constructed by the builder (in which
// case you should not have to worry about their lifecycle), or without a
// parent, in which case they have to be added to some container to make use of
// them. Non-widget objects need to be reffed with g_object_ref() to keep them
// beyond the lifespan of the builder.
// 
// 
// GtkBuilder UI Definitions
// 
// `GtkBuilder` parses textual descriptions of user interfaces which are
// specified in XML format. We refer to these descriptions as GtkBuilder UI
// definitions or just UI definitions if the context is clear.
// 
// The toplevel element is `<interface>`. It optionally takes a domain
// attribute, which will make the builder look for translated strings using
// `dgettext()` in the domain specified. This can also be done by calling
// [method@Gtk.Builder.set_translation_domain] on the builder.
// 
// Objects are described by `<object>` elements, which can contain `<property>`
// elements to set properties, `<signal>` elements which connect signals to
// handlers, and `<child>` elements, which describe child objects (most often
// widgets inside a container, but also e.g. actions in an action group, or
// columns in a tree model). A `<child>` element contains an `<object>` element
// which describes the child object.
// 
// The target toolkit version(s) are described by `<requires>` elements, the
// lib attribute specifies the widget library in question (currently the only
// supported value is gtk) and the version attribute specifies the target
// version in the form `<major>`.`<minor>`. `GtkBuilder` will error out if the
// version requirements are not met.
// 
// Typically, the specific kind of object represented by an `<object>` element
// is specified by the class attribute. If the type has not been loaded yet,
// GTK tries to find the `get_type()` function from the class name by applying
// heuristics. This works in most cases, but if necessary, it is possible to
// specify the name of the `get_type()` function explicitly with the "type-func"
// attribute.
// 
// Objects may be given a name with the id attribute, which allows the
// application to retrieve them from the builder with
// [method@Gtk.Builder.get_object]. An id is also necessary to use the object as
// property value in other parts of the UI definition. GTK reserves ids starting
// and ending with `___` (three consecutive underscores) for its own purposes.
// 
// Setting properties of objects is pretty straightforward with the `<property>`
// element: the name attribute specifies the name of the property, and the
// content of the element specifies the value. If the translatable attribute
// is set to a true value, GTK uses `gettext()` (or `dgettext()` if the builder
// has a translation domain set) to find a translation for the value. This
// happens before the value is parsed, so it can be used for properties of any
// type, but it is probably most useful for string properties. It is also
// possible to specify a context to disambiguate short strings, and comments
// which may help the translators.
// 
// `GtkBuilder` can parse textual representations for the most common property
// types: characters, strings, integers, floating-point numbers, booleans
// (strings like TRUE, t, yes, y, 1 are interpreted as true, strings
// like FALSE, f, no, n, 0 are interpreted as false), enumerations
// (can be specified by their name, nick or integer value), flags (can be
// specified by their name, nick, integer value, optionally combined with |,
// e.g. GTK_INPUT_HINT_EMOJI|GTK_INPUT_HINT_LOWERCASE) and colors (in a format
// understood by [method@Gdk.RGBA.parse]).
// 
// `GVariant`s can be specified in the format understood by g_variant_parse(),
// and pixbufs can be specified as a filename of an image file to load.
// 
// Objects can be referred to by their name and by default refer to objects
// declared in the local XML fragment and objects exposed via
// [method@Gtk.Builder.expose_object]. In general, `GtkBuilder` allows forward
// references to objects  declared in the local XML; an object doesnt have to
// be constructed before it can be referred to. The exception to this rule is
// that an object has to be constructed before it can be used as the value of a
// construct-only property.
// 
// It is also possible to bind a property value to another object's property
// value using the attributes "bind-source" to specify the source object of the
// binding, and optionally, "bind-property" and "bind-flags" to specify the
// source property and source binding flags respectively. Internally,
// `GtkBuilder` implements this using `GBinding` objects. For more information
// see g_object_bind_property().
// 
// Sometimes it is necessary to refer to widgets which have implicitly been
// constructed by GTK as part of a composite widget, to set properties on them
// or to add further children (e.g. the content area of a `GtkDialog`). This can
// be achieved by setting the internal-child property of the `<child>` element
// to a true value. Note that Builder still requires an `<object>` element for
// the internal child, even if it has already been constructed.
// 
// A number of widgets have different places where a child can be added (e.g.
// tabs vs. page content in notebooks). This can be reflected in a UI definition
// by specifying the type attribute on a `<child>` The possible values for the
// type attribute are described in the sections describing the widget-specific
// portions of UI definitions.
// 
// 
// Signal handlers and function pointers
// 
// Signal handlers are set up with the `<signal>` element. The name attribute
// specifies the name of the signal, and the handler attribute specifies the
// function to connect to the signal. The remaining attributes, after,
// swapped and object, have the same meaning as the corresponding parameters
// of the g_signal_connect_object() or g_signal_connect_data() functions. A
// last_modification_time attribute is also allowed, but it does not have a
// meaning to the builder.
// 
// If you rely on `GModule` support to lookup callbacks in the symbol table, the
// following details should be noted:
// 
// When compiling applications for Windows, you must declare signal callbacks
// with G_MODULE_EXPORT, or they will not be put in the symbol table. On Linux
// and Unix, this is not necessary; applications should instead be compiled with
// the -Wl,--export-dynamic `CFLAGS`, and linked against `gmodule-export-2.0`.
// 
// 
// A GtkBuilder UI Definition
// 
// `xml <interface> <object class="GtkDialog" id="dialog1"> <child
// internal-child="vbox"> <object class="GtkBox" id="vbox1"> <child
// internal-child="action_area"> <object class="GtkBox" id="hbuttonbox1">
// <child> <object class="GtkButton" id="ok_button"> <property
// name="label">gtk-ok</property> <signal name="clicked"
// handler="ok_button_clicked"/> </object> </child> </object> </child> </object>
// </child> </object> </interface> `
// 
// Beyond this general structure, several object classes define their own XML
// DTD fragments for filling in the ANY placeholders in the DTD above. Note that
// a custom element in a <child> element gets parsed by the custom tag handler
// of the parent object, while a custom element in an <object> element gets
// parsed by the custom tag handler of the object.
// 
// These XML fragments are explained in the documentation of the respective
// objects.
// 
// A `<template>` tag can be used to define a widget classs components. See the
// GtkWidget documentation
// (class.Widget.html#building-composite-widgets-from-template-xml) for details.
	type Builder struct {
		**externglib.Object
		
	}

	// BuilderClass is an interface that the Builder class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BuilderClass interface {
		gextras.Objector
		_builder()
	}

	func (Builder) _builder() {}

	
	func marshalBuilder(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBuilder(obj), nil
	}
	

	
	// NewBuilder creates a new empty builder object.
// 
// This function is only useful if you intend to make multiple calls to
// [method@Gtk.Builder.add_from_file], [method@Gtk.Builder.add_from_resource] or
// [method@Gtk.Builder.add_from_string] in order to merge multiple UI
// descriptions into a single builder.
	func NewBuilder() Builder {
var _cret *C.GtkBuilder // in

_cret = C.gtk_builder_new()


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	
	// NewBuilderFromFile parses the UI definition in the file @filename.
// 
// If there is an error opening the file or parsing the description then the
// program will be aborted. You should only ever attempt to parse user interface
// descriptions that are shipped as part of your program.
	func NewBuilderFromFile(filename string) Builder {
var _arg1 *C.char // out
var _cret *C.GtkBuilder // in

_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_new_from_file(_arg1)


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	
	// NewBuilderFromResource parses the UI definition at @resource_path.
// 
// If there is an error locating the resource or parsing the description, then
// the program will be aborted.
	func NewBuilderFromResource(resourcePath string) Builder {
var _arg1 *C.char // out
var _cret *C.GtkBuilder // in

_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_new_from_resource(_arg1)


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	
	// NewBuilderFromString parses the UI definition in @string.
// 
// If @string is nil-terminated, then @length should be -1. If @length is not
// -1, then it is the length of @string.
// 
// If there is an error parsing @string then the program will be aborted. You
// should not attempt to parse user interface description from untrusted
// sources.
	func NewBuilderFromString(_string string, length int) Builder {
var _arg1 *C.char // out
var _arg2 C.gssize // out
var _cret *C.GtkBuilder // in

_arg1 = (*C.char)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gssize)(length)

_cret = C.gtk_builder_new_from_string(_arg1, _arg2)


var _builder Builder // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builder = Builder{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _builder
}
	

	
	// AddFromFile parses a file containing a UI definition and merges it with the
// current contents of @builder.
// 
// This function is useful if you need to call
// [method@Gtk.Builder.set_current_object]) to add user data to callbacks before
// loading GtkBuilder UI. Otherwise, you probably want
// [ctor@Gtk.Builder.new_from_file] instead.
// 
// If an error occurs, 0 will be returned and @error will be assigned a `GError`
// from the `GTK_BUILDER_ERROR`, `G_MARKUP_ERROR` or `G_FILE_ERROR` domains.
// 
// Its not really reasonable to attempt to handle failures of this call. You
// should not use this function with untrusted files (ie: files that are not
// part of your application). Broken `GtkBuilder` files can easily crash your
// program, and its possible that memory was leaked leading up to the reported
// failure. The only reasonable thing to do when an error is detected is to call
// `g_error()`.
	func (b Builder) AddFromFile(filename string) error {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_builder_add_from_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AddFromResource parses a resource file containing a UI definition and merges
// it with the current contents of @builder.
// 
// This function is useful if you need to call
// [method@Gtk.Builder.set_current_object] to add user data to callbacks before
// loading GtkBuilder UI. Otherwise, you probably want
// [ctor@Gtk.Builder.new_from_resource] instead.
// 
// If an error occurs, 0 will be returned and @error will be assigned a `GError`
// from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_RESOURCE_ERROR domain.
// 
// Its not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
	func (b Builder) AddFromResource(resourcePath string) error {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_builder_add_from_resource(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AddFromString parses a string containing a UI definition and merges it with
// the current contents of @builder.
// 
// This function is useful if you need to call
// [method@Gtk.Builder.set_current_object] to add user data to callbacks before
// loading `GtkBuilder` UI. Otherwise, you probably want
// [ctor@Gtk.Builder.new_from_string] instead.
// 
// Upon errors false will be returned and @error will be assigned a `GError`
// from the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_VARIANT_PARSE_ERROR domain.
// 
// Its not really reasonable to attempt to handle failures of this call. The
// only reasonable thing to do when an error is detected is to call g_error().
	func (b Builder) AddFromString(buffer string, length int) error {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _arg2 C.gssize // out
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(buffer))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gssize)(length)

C.gtk_builder_add_from_string(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AddObjectsFromFile parses a file containing a UI definition building only the
// requested objects and merges them with the current contents of @builder.
// 
// Upon errors, 0 will be returned and @error will be assigned a `GError` from
// the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_FILE_ERROR domain.
// 
// If you are adding an object that depends on an object that is not its child
// (for instance a `GtkTreeView` that depends on its `GtkTreeModel`), you have
// to explicitly list all of them in @object_ids.
	func (b Builder) AddObjectsFromFile(filename string, objectIds []string) error {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _arg2 **C.char
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.char)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(objectIds))
for i := range objectIds {
out[i] = (*C.gchar)(C.CString(objectIds[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_builder_add_objects_from_file(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AddObjectsFromResource parses a resource file containing a UI definition,
// building only the requested objects and merges them with the current contents
// of @builder.
// 
// Upon errors, 0 will be returned and @error will be assigned a `GError` from
// the GTK_BUILDER_ERROR, G_MARKUP_ERROR or G_RESOURCE_ERROR domain.
// 
// If you are adding an object that depends on an object that is not its child
// (for instance a `GtkTreeView` that depends on its `GtkTreeModel`), you have
// to explicitly list all of them in @object_ids.
	func (b Builder) AddObjectsFromResource(resourcePath string, objectIds []string) error {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _arg2 **C.char
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.char)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(objectIds))
for i := range objectIds {
out[i] = (*C.gchar)(C.CString(objectIds[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_builder_add_objects_from_resource(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// AddObjectsFromString parses a string containing a UI definition, building
// only the requested objects and merges them with the current contents of
// @builder.
// 
// Upon errors false will be returned and @error will be assigned a `GError`
// from the GTK_BUILDER_ERROR or G_MARKUP_ERROR domain.
// 
// If you are adding an object that depends on an object that is not its child
// (for instance a `GtkTreeView` that depends on its `GtkTreeModel`), you have
// to explicitly list all of them in @object_ids.
	func (b Builder) AddObjectsFromString(buffer string, length int, objectIds []string) error {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _arg2 C.gssize // out
var _arg3 **C.char
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(buffer))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.gssize)(length)
_arg3 = (**C.char)(C.malloc(C.ulong(len(objectIds)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(objectIds))
for i := range objectIds {
out[i] = (*C.gchar)(C.CString(objectIds[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_builder_add_objects_from_string(_arg0, _arg1, _arg2, _arg3, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ExposeObject: add @object to the @builder object pool so it can be referenced
// just like any other object built by builder.
	func (b Builder) ExposeObject(name string, object **externglib.Object)  {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _arg2 *C.GObject // out

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GObject)(unsafe.Pointer(object.Native()))

C.gtk_builder_expose_object(_arg0, _arg1, _arg2)
}
	
	// ExtendWithTemplate: main private entry point for building composite
// components from template XML.
// 
// This is exported purely to let `gtk-builder-tool` validate templates,
// applications have no need to call this function.
	func (b Builder) ExtendWithTemplate(object **externglib.Object, templateType externglib.Type, buffer string, length int) error {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.GObject // out
var _arg2 C.GType // out
var _arg3 *C.char // out
var _arg4 C.gssize // out
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(object.Native()))
_arg2 = C.GType(templateType)
_arg3 = (*C.char)(C.CString(buffer))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (C.gssize)(length)

C.gtk_builder_extend_with_template(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// CurrentObject gets the current object set via
// gtk_builder_set_current_object().
	func (b Builder) CurrentObject() **externglib.Object {
var _arg0 *C.GtkBuilder // out
var _cret *C.GObject // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

_cret = C.gtk_builder_get_current_object(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// Object gets the object named @name.
// 
// Note that this function does not increment the reference count of the
// returned object.
	func (b Builder) Object(name string) **externglib.Object {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _cret *C.GObject // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_get_object(_arg0, _arg1)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// Scope gets the scope in use that was set via gtk_builder_set_scope().
	func (b Builder) Scope() BuilderScope {
var _arg0 *C.GtkBuilder // out
var _cret *C.GtkBuilderScope // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

_cret = C.gtk_builder_get_scope(_arg0)


var _builderScope BuilderScope // out

_builderScope = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(BuilderScope)

return _builderScope
}
	
	// TranslationDomain gets the translation domain of @builder.
	func (b Builder) TranslationDomain() string {
var _arg0 *C.GtkBuilder // out
var _cret *C.char // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))

_cret = C.gtk_builder_get_translation_domain(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TypeFromName looks up a type by name.
// 
// This is using the virtual function that `GtkBuilder` has for that purpose.
// This is mainly used when implementing the `GtkBuildable` interface on a type.
	func (b Builder) TypeFromName(typeName string) externglib.Type {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out
var _cret C.GType // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(typeName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_builder_get_type_from_name(_arg0, _arg1)


var _gType externglib.Type // out

_gType = externglib.Type(_cret)

return _gType
}
	
	// SetCurrentObject sets the current object for the @builder.
// 
// The current object can be thought of as the `this` object that the builder is
// working for and will often be used as the default object when an object is
// optional.
// 
// [method@Gtk.Widget.init_template] for example will set the current object to
// the widget the template is inited for. For functions like
// [ctor@Gtk.Builder.new_from_resource], the current object will be nil.
	func (b Builder) SetCurrentObject(currentObject **externglib.Object)  {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.GObject // out

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(currentObject.Native()))

C.gtk_builder_set_current_object(_arg0, _arg1)
}
	
	// SetScope sets the scope the builder should operate in.
// 
// If @scope is nil a new [class@Gtk.BuilderCScope] will be created.
	func (b Builder) SetScope(scope BuilderScope)  {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.GtkBuilderScope // out

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(scope.Native()))

C.gtk_builder_set_scope(_arg0, _arg1)
}
	
	// SetTranslationDomain sets the translation domain of @builder.
	func (b Builder) SetTranslationDomain(domain string)  {
var _arg0 *C.GtkBuilder // out
var _arg1 *C.char // out

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(domain))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_builder_set_translation_domain(_arg0, _arg1)
}
	
	// ValueFromStringType demarshals a value from a string.
// 
// Unlike [method@Gtk.Builder.value_from_string], this function takes a `GType`
// instead of `GParamSpec`.
// 
// Calls g_value_init() on the @value argument, so it need not be initialised
// beforehand.
// 
// Upon errors false will be returned and @error will be assigned a `GError`
// from the GTK_BUILDER_ERROR domain.
	func (b Builder) ValueFromStringType(typ externglib.Type, _string string) (*externglib.Value, error) {
var _arg0 *C.GtkBuilder // out
var _arg1 C.GType // out
var _arg2 *C.char // out
var _arg3 C.GValue // in
var _cerr *C.GError // in

_arg0 = (*C.GtkBuilder)(unsafe.Pointer(b.Native()))
_arg1 = C.GType(typ)
_arg2 = (*C.char)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_builder_value_from_string_type(_arg0, _arg1, _arg2, &_arg3, &_cerr)

var _value *externglib.Value // out
var _goerr error // out

_value = externglib.ValueFromNative(unsafe.Pointer(_arg3))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _value, _goerr
}
	


	// BuilderCScope: a `GtkBuilderScope` implementation for the C language.
// 
// `GtkBuilderCScope` instances use symbols explicitly added to @builder with
// prior calls to [method@Gtk.BuilderCScope.add_callback_symbol]. If developers
// want to do that, they are encouraged to create their own scopes for that
// purpose.
// 
// In the case that symbols are not explicitly added; GTK will uses `GModule`s
// introspective features (by opening the module nil) to look at the
// applications symbol table. From here it tries to match the signal function
// names given in the interface description with symbols in the application.
// 
// Note that unless [method@Gtk.BuilderCScope.add_callback_symbol] is called for
// all signal callbacks which are referenced by the loaded XML, this
// functionality will require that `GModule` be supported on the platform.
	type BuilderCScope struct {
		**externglib.Object
		BuilderScope
		
	}

	// BuilderCScopeClass is an interface that the BuilderCScope class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BuilderCScopeClass interface {
		gextras.Objector
		_builderCScope()
	}

	func (BuilderCScope) _builderCScope() {}

	
	func marshalBuilderCScope(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBuilderCScope(obj), nil
	}
	

	
	// NewBuilderCScope creates a new `GtkBuilderCScope` object to use with future
// `GtkBuilder` instances.
// 
// Calling this function is only necessary if you want to add custom callbacks
// via [method@Gtk.BuilderCScope.add_callback_symbol].
	func NewBuilderCScope() BuilderCScope {
var _cret *C.GtkBuilderScope // in

_cret = C.gtk_builder_cscope_new()


var _builderCScope BuilderCScope // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_builderCScope = BuilderCScope{
Object: &externglib.Object{externglib.ToGObject(obj)},
BuilderScope: BuilderScope{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _builderCScope
}
	

	


	// BuilderListItemFactory: `GtkBuilderListItemFactory` is a `GtkListItemFactory`
// that creates widgets by instantiating `GtkBuilder` UI templates.
// 
// The templates must be extending `GtkListItem`, and typically use
// `GtkExpression`s to obtain data from the items in the model.
// 
// Example: `xml <interface> <template class="GtkListItem"> <property
// name="child"> <object class="GtkLabel"> <property name="xalign">0</property>
// <binding name="label"> <lookup name="name" type="SettingsKey"> <lookup
// name="item">GtkListItem</lookup> </lookup> </binding> </object> </property>
// </template> </interface> `
	type BuilderListItemFactory struct {
		ListItemFactory
		
	}

	// BuilderListItemFactoryClass is an interface that the BuilderListItemFactory class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type BuilderListItemFactoryClass interface {
		gextras.Objector
		_builderListItemFactory()
	}

	func (BuilderListItemFactory) _builderListItemFactory() {}

	
	func marshalBuilderListItemFactory(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapBuilderListItemFactory(obj), nil
	}
	

	
	// NewBuilderListItemFactoryFromResource creates a new
// `GtkBuilderListItemFactory` that instantiates widgets using data read from
// the given @resource_path to pass to `GtkBuilder`.
	func NewBuilderListItemFactoryFromResource(scope BuilderScope, resourcePath string) BuilderListItemFactory {
var _arg1 *C.GtkBuilderScope // out
var _arg2 *C.char // out
var _cret *C.GtkListItemFactory // in

_arg1 = (*C.GtkBuilderScope)(unsafe.Pointer(scope.Native()))
_arg2 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_builder_list_item_factory_new_from_resource(_arg1, _arg2)


var _builderListItemFactory BuilderListItemFactory // out

_builderListItemFactory = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(BuilderListItemFactory)

return _builderListItemFactory
}
	

	
	// Resource: if the data references a resource, gets the path of that resource.
	func (s BuilderListItemFactory) Resource() string {
var _arg0 *C.GtkBuilderListItemFactory // out
var _cret *C.char // in

_arg0 = (*C.GtkBuilderListItemFactory)(unsafe.Pointer(s.Native()))

_cret = C.gtk_builder_list_item_factory_get_resource(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Scope gets the scope used when constructing listitems.
	func (s BuilderListItemFactory) Scope() BuilderScope {
var _arg0 *C.GtkBuilderListItemFactory // out
var _cret *C.GtkBuilderScope // in

_arg0 = (*C.GtkBuilderListItemFactory)(unsafe.Pointer(s.Native()))

_cret = C.gtk_builder_list_item_factory_get_scope(_arg0)


var _builderScope BuilderScope // out

_builderScope = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(BuilderScope)

return _builderScope
}
	


	// Button: the `GtkButton` widget is generally used to trigger a callback
// function that is called when the button is pressed.
// 
// !An example GtkButton (button.png)
// 
// The `GtkButton` widget can hold any valid child widget. That is, it can hold
// almost any other standard `GtkWidget`. The most commonly used child is the
// `GtkLabel`.
// 
// 
// CSS nodes
// 
// `GtkButton` has a single CSS node with name button. The node will get the
// style classes .image-button or .text-button, if the content is just an image
// or label, respectively. It may also receive the .flat style class. When
// activating a button via the keyboard, the button will temporarily gain the
// .keyboard-activating style class.
// 
// Other style classes that are commonly used with `GtkButton` include
// .suggested-action and .destructive-action. In special cases, buttons can be
// made round by adding the .circular style class.
// 
// Button-like widgets like [class@Gtk.ToggleButton], [class@Gtk.MenuButton],
// [class@Gtk.VolumeButton], [class@Gtk.LockButton], [class@Gtk.ColorButton] or
// [class@Gtk.FontButton] use style classes such as .toggle, .popup, .scale,
// .lock, .color on the button node to differentiate themselves from a plain
// `GtkButton`.
// 
// 
// Accessibility
// 
// `GtkButton` uses the GTK_ACCESSIBLE_ROLE_BUTTON role.
	type Button struct {
		Widget
		Accessible
		Actionable
		Buildable
		ConstraintTarget
		
	}

	// ButtonClass is an interface that the Button class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ButtonClass interface {
		gextras.Objector
		_button()
	}

	func (Button) _button() {}

	
	func marshalButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapButton(obj), nil
	}
	

	
	// NewButton creates a new `GtkButton` widget.
// 
// To add a child widget to the button, use [method@Gtk.Button.set_child].
	func NewButton() Button {
var _cret *C.GtkWidget // in

_cret = C.gtk_button_new()


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	
	// NewButtonFromIconName creates a new button containing an icon from the
// current icon theme.
// 
// If the icon name isnt known, a broken image icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
	func NewButtonFromIconName(iconName string) Button {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_button_new_from_icon_name(_arg1)


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	
	// NewButtonWithLabel creates a `GtkButton` widget with a `GtkLabel` child.
	func NewButtonWithLabel(label string) Button {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_button_new_with_label(_arg1)


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	
	// NewButtonWithMnemonic creates a new `GtkButton` containing a label.
// 
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use __ (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. Pressing Alt and that key activates the
// button.
	func NewButtonWithMnemonic(label string) Button {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_button_new_with_mnemonic(_arg1)


var _button Button // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_button = Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _button
}
	

	
	// Child gets the child widget of @button.
	func (b Button) Child() Widget {
var _arg0 *C.GtkButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// HasFrame returns whether the button has a frame.
	func (b Button) HasFrame() bool {
var _arg0 *C.GtkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_has_frame(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconName returns the icon name of the button.
// 
// If the icon name has not been set with [method@Gtk.Button.set_icon_name] the
// return value will be nil. This will be the case if you create an empty button
// with [ctor@Gtk.Button.new] to use as a container.
	func (b Button) IconName() string {
var _arg0 *C.GtkButton // out
var _cret *C.char // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Label fetches the text from the label of the button.
// 
// If the label text has not been set with [method@Gtk.Button.set_label] the
// return value will be nil. This will be the case if you create an empty button
// with [ctor@Gtk.Button.new] to use as a container.
	func (b Button) Label() string {
var _arg0 *C.GtkButton // out
var _cret *C.char // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseUnderline gets whether underlines are interpreted as mnemonics.
// 
// See [method@Gtk.Button.set_use_underline].
	func (b Button) UseUnderline() bool {
var _arg0 *C.GtkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_button_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetChild sets the child widget of @button.
	func (b Button) SetChild(child WidgetClass)  {
var _arg0 *C.GtkButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_button_set_child(_arg0, _arg1)
}
	
	// SetHasFrame sets the style of the button.
// 
// Buttons can has a flat appearance or have a frame drawn around them.
	func (b Button) SetHasFrame(hasFrame bool)  {
var _arg0 *C.GtkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
if hasFrame { _arg1 = C.TRUE }

C.gtk_button_set_has_frame(_arg0, _arg1)
}
	
	// SetIconName adds a `GtkImage` with the given icon name as a child.
// 
// If @button already contains a child widget, that child widget will be removed
// and replaced with the image.
	func (b Button) SetIconName(iconName string)  {
var _arg0 *C.GtkButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_button_set_icon_name(_arg0, _arg1)
}
	
	// SetLabel sets the text of the label of the button to @label.
// 
// This will also clear any previously set labels.
	func (b Button) SetLabel(label string)  {
var _arg0 *C.GtkButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_button_set_label(_arg0, _arg1)
}
	
	// SetUseUnderline sets whether to use underlines as mnemonics.
// 
// If true, an underline in the text of the button label indicates the next
// character should be used for the mnemonic accelerator key.
	func (b Button) SetUseUnderline(useUnderline bool)  {
var _arg0 *C.GtkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkButton)(unsafe.Pointer(b.Native()))
if useUnderline { _arg1 = C.TRUE }

C.gtk_button_set_use_underline(_arg0, _arg1)
}
	


	// Calendar: `GtkCalendar` is a widget that displays a Gregorian calendar, one
// month at a time.
// 
// !An example GtkCalendar (calendar.png)
// 
// A `GtkCalendar` can be created with [ctor@Gtk.Calendar.new].
// 
// The date that is currently displayed can be altered with
// [method@Gtk.Calendar.select_day].
// 
// To place a visual marker on a particular day, use
// [method@Gtk.Calendar.mark_day] and to remove the marker,
// [method@Gtk.Calendar.unmark_day]. Alternative, all marks can be cleared with
// [method@Gtk.Calendar.clear_marks].
// 
// The selected date can be retrieved from a `GtkCalendar` using
// [method@Gtk.Calendar.get_date].
// 
// Users should be aware that, although the Gregorian calendar is the legal
// calendar in most countries, it was adopted progressively between 1582 and
// 1929. Display before these dates is likely to be historically incorrect.
// 
// 
// CSS nodes
// 
// ` calendar.view  header   button   stack.month   button  
// button   label.year   button  grid 
// label[.day-name][.week-number][.day-number][.other-month][.today] `
// 
// `GtkCalendar` has a main node with name calendar. It contains a subnode
// called header containing the widgets for switching between years and months.
// 
// The grid subnode contains all day labels, including week numbers on the left
// (marked with the .week-number css class) and day names on top (marked with
// the .day-name css class).
// 
// Day labels that belong to the previous or next month get the .other-month
// style class. The label of the current day get the .today style class.
// 
// Marked day labels get the :selected state assigned.
	type Calendar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// CalendarClass is an interface that the Calendar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CalendarClass interface {
		gextras.Objector
		_calendar()
	}

	func (Calendar) _calendar() {}

	
	func marshalCalendar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCalendar(obj), nil
	}
	

	
	// NewCalendar creates a new calendar, with the current date being selected.
	func NewCalendar() Calendar {
var _cret *C.GtkWidget // in

_cret = C.gtk_calendar_new()


var _calendar Calendar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_calendar = Calendar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _calendar
}
	

	
	// ClearMarks: remove all visual markers.
	func (c Calendar) ClearMarks()  {
var _arg0 *C.GtkCalendar // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))

C.gtk_calendar_clear_marks(_arg0)
}
	
	// DayIsMarked returns if the @day of the @calendar is already marked.
	func (c Calendar) DayIsMarked(day uint) bool {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(day)

_cret = C.gtk_calendar_get_day_is_marked(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowDayNames returns whether @self is currently showing the names of the week
// days.
// 
// This is the value of the [property@Gtk.Calendar:show-day-names] property.
	func (s Calendar) ShowDayNames() bool {
var _arg0 *C.GtkCalendar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_calendar_get_show_day_names(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowHeading returns whether @self is currently showing the heading.
// 
// This is the value of the [property@Gtk.Calendar:show-heading] property.
	func (s Calendar) ShowHeading() bool {
var _arg0 *C.GtkCalendar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_calendar_get_show_heading(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowWeekNumbers returns whether @self is showing week numbers right now.
// 
// This is the value of the [property@Gtk.Calendar:show-week-numbers] property.
	func (s Calendar) ShowWeekNumbers() bool {
var _arg0 *C.GtkCalendar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_calendar_get_show_week_numbers(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MarkDay places a visual marker on a particular day.
	func (c Calendar) MarkDay(day uint)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(day)

C.gtk_calendar_mark_day(_arg0, _arg1)
}
	
	// SetShowDayNames sets whether the calendar shows day names.
	func (s Calendar) SetShowDayNames(value bool)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
if value { _arg1 = C.TRUE }

C.gtk_calendar_set_show_day_names(_arg0, _arg1)
}
	
	// SetShowHeading sets whether the calendar should show a heading.
// 
// The heading contains the current year and month as well as buttons for
// changing both.
	func (s Calendar) SetShowHeading(value bool)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
if value { _arg1 = C.TRUE }

C.gtk_calendar_set_show_heading(_arg0, _arg1)
}
	
	// SetShowWeekNumbers sets whether week numbers are shown in the calendar.
	func (s Calendar) SetShowWeekNumbers(value bool)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(s.Native()))
if value { _arg1 = C.TRUE }

C.gtk_calendar_set_show_week_numbers(_arg0, _arg1)
}
	
	// UnmarkDay removes the visual marker from a particular day.
	func (c Calendar) UnmarkDay(day uint)  {
var _arg0 *C.GtkCalendar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkCalendar)(unsafe.Pointer(c.Native()))
_arg1 = (C.guint)(day)

C.gtk_calendar_unmark_day(_arg0, _arg1)
}
	


	// CallbackAction: a `GtkShortcutAction` that invokes a callback.
	type CallbackAction struct {
		ShortcutAction
		
	}

	// CallbackActionClass is an interface that the CallbackAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CallbackActionClass interface {
		gextras.Objector
		_callbackAction()
	}

	func (CallbackAction) _callbackAction() {}

	
	func marshalCallbackAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCallbackAction(obj), nil
	}
	

	

	


	// CellArea: an abstract class for laying out GtkCellRenderers
// 
// The CellArea is an abstract class for CellLayout widgets (also referred to as
// "layouting widgets") to interface with an arbitrary number of CellRenderers
// and interact with the user for a given TreeModel row.
// 
// The cell area handles events, focus navigation, drawing and size requests and
// allocations for a given row of data.
// 
// Usually users dont have to interact with the CellArea directly unless they
// are implementing a cell-layouting widget themselves.
// 
// 
// Requesting area sizes
// 
// As outlined in [GtkWidgets geometry management
// section][geometry-management], GTK uses a height-for-width geometry
// management system to compute the sizes of widgets and user interfaces.
// CellArea uses the same semantics to calculate the size of an area for an
// arbitrary number of TreeModel rows.
// 
// When requesting the size of a cell area one needs to calculate the size for a
// handful of rows, and this will be done differently by different layouting
// widgets. For instance a TreeViewColumn always lines up the areas from top to
// bottom while a IconView on the other hand might enforce that all areas
// received the same width and wrap the areas around, requesting height for more
// cell areas when allocated less width.
// 
// Its also important for areas to maintain some cell alignments with areas
// rendered for adjacent rows (cells can appear columnized inside an area even
// when the size of cells are different in each row). For this reason the
// CellArea uses a CellAreaContext object to store the alignments and sizes
// along the way (as well as the overall largest minimum and natural size for
// all the rows which have been calculated with the said context).
// 
// The CellAreaContext is an opaque object specific to the CellArea which
// created it (see gtk_cell_area_create_context()). The owning cell-layouting
// widget can create as many contexts as it wishes to calculate sizes of rows
// which should receive the same size in at least one orientation (horizontally
// or vertically), However, its important that the same CellAreaContext which
// was used to request the sizes for a given TreeModel row be used when
// rendering or processing events for that row.
// 
// In order to request the width of all the rows at the root level of a
// TreeModel one would do the following:
// 
//    static gboolean
//    foo_focus (GtkWidget       *widget,
//               GtkDirectionType direction)
//    {
//      Foo        *foo  = FOO (widget);
//      FooPrivate *priv = foo->priv;
//      int         focus_row;
//      gboolean    have_focus = FALSE;
// 
//      focus_row = priv->focus_row;
// 
//      if (!gtk_widget_has_focus (widget))
//        gtk_widget_grab_focus (widget);
// 
//      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, priv->focus_row);
//      while (valid)
//        {
//          gtk_cell_area_apply_attributes (priv->area, priv->model, &iter, FALSE, FALSE);
// 
//          if (gtk_cell_area_focus (priv->area, direction))
//            {
//               priv->focus_row = focus_row;
//               have_focus = TRUE;
//               break;
//            }
//          else
//            {
//              if (direction == GTK_DIR_RIGHT ||
//                  direction == GTK_DIR_LEFT)
//                break;
//              else if (direction == GTK_DIR_UP ||
//                       direction == GTK_DIR_TAB_BACKWARD)
//               {
//                  if (focus_row == 0)
//                    break;
//                  else
//                   {
//                      focus_row--;
//                      valid = gtk_tree_model_iter_nth_child (priv->model, &iter, NULL, focus_row);
//                   }
//                }
//              else
//                {
//                  if (focus_row == last_row)
//                    break;
//                  else
//                    {
//                      focus_row++;
//                      valid = gtk_tree_model_iter_next (priv->model, &iter);
//                    }
//                }
//            }
//        }
//        return have_focus;
//    }
// 
// Note that the layouting widget is responsible for matching the
// GtkDirectionType values to the way it lays out its cells.
// 
// 
// Cell Properties
// 
// The CellArea introduces cell properties for CellRenderers. This provides some
// general interfaces for defining the relationship cell areas have with their
// cells. For instance in a CellAreaBox a cell might expand and receive extra
// space when the area is allocated more than its full natural request, or a
// cell might be configured to align with adjacent rows which were requested
// and rendered with the same CellAreaContext.
// 
// Use gtk_cell_area_class_install_cell_property() to install cell properties
// for a cell area class and gtk_cell_area_class_find_cell_property() or
// gtk_cell_area_class_list_cell_properties() to get information about existing
// cell properties.
// 
// To set the value of a cell property, use gtk_cell_area_cell_set_property(),
// gtk_cell_area_cell_set() or gtk_cell_area_cell_set_valist(). To obtain the
// value of a cell property, use gtk_cell_area_cell_get_property(),
// gtk_cell_area_cell_get() or gtk_cell_area_cell_get_valist().
	type CellArea struct {
		externglib.InitiallyUnowned
		Buildable
		CellLayout
		
	}

	// CellAreaClass is an interface that the CellArea class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellAreaClass interface {
		gextras.Objector
		_cellArea()
	}

	func (CellArea) _cellArea() {}

	
	func marshalCellArea(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellArea(obj), nil
	}
	

	

	
	// Activate activates @area, usually by activating the currently focused cell,
// however some subclasses which embed widgets in the area can also activate a
// widget if it currently has the focus.
	func (a CellArea) Activate(context CellAreaContextClass, widget WidgetClass, cellArea *gdk.Rectangle, flags CellRendererState, editOnly bool) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkRectangle // out
var _arg4 C.GtkCellRendererState // out
var _arg5 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg4 = (C.GtkCellRendererState)(flags)
if editOnly { _arg5 = C.TRUE }

_cret = C.gtk_cell_area_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ActivateCell: this is used by CellArea subclasses when handling events to
// activate cells, the base CellArea class activates cells for keyboard events
// for free in its own GtkCellArea->activate() implementation.
	func (a CellArea) ActivateCell(widget WidgetClass, renderer CellRendererClass, event gdk.EventClass, cellArea *gdk.Rectangle, flags CellRendererState) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkCellRenderer // out
var _arg3 *C.GdkEvent // out
var _arg4 *C.GdkRectangle // out
var _arg5 C.GtkCellRendererState // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg3 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg5 = (C.GtkCellRendererState)(flags)

_cret = C.gtk_cell_area_activate_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Add adds @renderer to @area with the default child cell properties.
	func (a CellArea) Add(renderer CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

C.gtk_cell_area_add(_arg0, _arg1)
}
	
	// AddFocusSibling adds @sibling to @renderers focusable area, focus will be
// drawn around @renderer and all of its siblings if @renderer can focus for a
// given row.
// 
// Events handled by focus siblings can also activate the given focusable
// @renderer.
	func (a CellArea) AddFocusSibling(renderer CellRendererClass, sibling CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

C.gtk_cell_area_add_focus_sibling(_arg0, _arg1, _arg2)
}
	
	// ApplyAttributes applies any connected attributes to the renderers in @area by
// pulling the values from @tree_model.
	func (a CellArea) ApplyAttributes(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkTreeModel // out
var _arg2 *C.GtkTreeIter // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
if isExpander { _arg3 = C.TRUE }
if isExpanded { _arg4 = C.TRUE }

C.gtk_cell_area_apply_attributes(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// AttributeConnect connects an @attribute to apply values from @column for the
// TreeModel in use.
	func (a CellArea) AttributeConnect(renderer CellRendererClass, attribute string, column int)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.char // out
var _arg3 C.int // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(column)

C.gtk_cell_area_attribute_connect(_arg0, _arg1, _arg2, _arg3)
}
	
	// AttributeDisconnect disconnects @attribute for the @renderer in @area so that
// attribute will no longer be updated with values from the model.
	func (a CellArea) AttributeDisconnect(renderer CellRendererClass, attribute string)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.char // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_cell_area_attribute_disconnect(_arg0, _arg1, _arg2)
}
	
	// AttributeGetColumn returns the model column that an attribute has been mapped
// to, or -1 if the attribute is not mapped.
	func (a CellArea) AttributeGetColumn(renderer CellRendererClass, attribute string) int {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.char // out
var _cret C.int // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_cell_area_attribute_get_column(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// CellGetProperty gets the value of a cell property for @renderer in @area.
	func (a CellArea) CellGetProperty(renderer CellRendererClass, propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.char // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.char)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GValue)(value.GValue)

C.gtk_cell_area_cell_get_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// CellSetProperty sets a cell property for @renderer in @area.
	func (a CellArea) CellSetProperty(renderer CellRendererClass, propertyName string, value **externglib.Value)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.char // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.char)(C.CString(propertyName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.GValue)(value.GValue)

C.gtk_cell_area_cell_set_property(_arg0, _arg1, _arg2, _arg3)
}
	
	// CopyContext: this is sometimes needed for cases where rows need to share
// alignments in one orientation but may be separately grouped in the opposing
// orientation.
// 
// For instance, IconView creates all icons (rows) to have the same width and
// the cells theirin to have the same horizontal alignments. However each row of
// icons may have a separate collective height. IconView uses this to request
// the heights of each row based on a context which was already used to request
// all the row widths that are to be displayed.
	func (a CellArea) CopyContext(context CellAreaContextClass) CellAreaContext {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _cret *C.GtkCellAreaContext // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

_cret = C.gtk_cell_area_copy_context(_arg0, _arg1)


var _cellAreaContext CellAreaContext // out

_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

return _cellAreaContext
}
	
	// CreateContext creates a CellAreaContext to be used with @area for all
// purposes. CellAreaContext stores geometry information for rows for which it
// was operated on, it is important to use the same context for the same row of
// data at all times (i.e. one should render and handle events with the same
// CellAreaContext which was used to request the size of those rows of data).
	func (a CellArea) CreateContext() CellAreaContext {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellAreaContext // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_create_context(_arg0)


var _cellAreaContext CellAreaContext // out

_cellAreaContext = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(CellAreaContext)

return _cellAreaContext
}
	
	// Event delegates event handling to a CellArea.
	func (a CellArea) Event(context CellAreaContextClass, widget WidgetClass, event gdk.EventClass, cellArea *gdk.Rectangle, flags CellRendererState) int {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkEvent // out
var _arg4 *C.GdkRectangle // out
var _arg5 C.GtkCellRendererState // out
var _cret C.int // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg5 = (C.GtkCellRendererState)(flags)

_cret = C.gtk_cell_area_event(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Focus: this should be called by the @areas owning layout widget when focus
// is to be passed to @area, or moved within @area for a given @direction and
// row data.
// 
// Implementing CellArea classes should implement this method to receive and
// navigate focus in its own way particular to how it lays out cells.
	func (a CellArea) Focus(direction DirectionType) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 C.GtkDirectionType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (C.GtkDirectionType)(direction)

_cret = C.gtk_cell_area_focus(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CellAllocation derives the allocation of @renderer inside @area if @area were
// to be renderered in @cell_area.
	func (a CellArea) CellAllocation(context CellAreaContextClass, widget WidgetClass, renderer CellRendererClass, cellArea *gdk.Rectangle) gdk.Rectangle {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkCellRenderer // out
var _arg4 *C.GdkRectangle // out
var _allocation gdk.Rectangle

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_cell_area_get_cell_allocation(_arg0, _arg1, _arg2, _arg3, _arg4, (*C.GdkRectangle)(unsafe.Pointer(&_allocation)))





return _allocation
}
	
	// CellAtPosition gets the CellRenderer at @x and @y coordinates inside @area
// and optionally returns the full cell allocation for it inside @cell_area.
	func (a CellArea) CellAtPosition(context CellAreaContextClass, widget WidgetClass, cellArea *gdk.Rectangle, x int, y int) (gdk.Rectangle, CellRenderer) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkRectangle // out
var _arg4 C.int // out
var _arg5 C.int // out
var _allocArea gdk.Rectangle
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg4 = (C.int)(x)
_arg5 = (C.int)(y)

_cret = C.gtk_cell_area_get_cell_at_position(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, (*C.GdkRectangle)(unsafe.Pointer(&_allocArea)))



var _cellRenderer CellRenderer // out


_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _allocArea, _cellRenderer
}
	
	// CurrentPathString gets the current TreePath string for the currently applied
// TreeIter, this is implicitly updated when gtk_cell_area_apply_attributes() is
// called and can be used to interact with renderers from CellArea subclasses.
	func (a CellArea) CurrentPathString() string {
var _arg0 *C.GtkCellArea // out
var _cret *C.char // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_current_path_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// EditWidget gets the CellEditable widget currently used to edit the currently
// edited cell.
	func (a CellArea) EditWidget() CellEditable {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellEditable // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_edit_widget(_arg0)


var _cellEditable CellEditable // out

_cellEditable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellEditable)

return _cellEditable
}
	
	// EditedCell gets the CellRenderer in @area that is currently being edited.
	func (a CellArea) EditedCell() CellRenderer {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_edited_cell(_arg0)


var _cellRenderer CellRenderer // out

_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _cellRenderer
}
	
	// FocusCell retrieves the currently focused cell for @area
	func (a CellArea) FocusCell() CellRenderer {
var _arg0 *C.GtkCellArea // out
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_focus_cell(_arg0)


var _cellRenderer CellRenderer // out

_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _cellRenderer
}
	
	// FocusFromSibling gets the CellRenderer which is expected to be focusable for
// which @renderer is, or may be a sibling.
// 
// This is handy for CellArea subclasses when handling events, after determining
// the renderer at the event location it can then chose to activate the focus
// cell for which the event cell may have been a sibling.
	func (a CellArea) FocusFromSibling(renderer CellRendererClass) CellRenderer {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _cret *C.GtkCellRenderer // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

_cret = C.gtk_cell_area_get_focus_from_sibling(_arg0, _arg1)


var _cellRenderer CellRenderer // out

_cellRenderer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellRenderer)

return _cellRenderer
}
	
	// PreferredHeight retrieves a cell areas initial minimum and natural height.
// 
// @area will store some geometrical information in @context along the way; when
// requesting sizes over an arbitrary number of rows, its not important to
// check the @minimum_height and @natural_height of this call but rather to
// consult gtk_cell_area_context_get_preferred_height() after a series of
// requests.
	func (a CellArea) PreferredHeight(context CellAreaContextClass, widget WidgetClass) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_area_get_preferred_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg3)
_naturalHeight = (int)(_arg4)

return _minimumHeight, _naturalHeight
}
	
	// PreferredHeightForWidth retrieves a cell areas minimum and natural height if
// it would be given the specified @width.
// 
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_width(). Its important to perform a
// series of gtk_cell_area_get_preferred_width() requests with @context first
// and then call gtk_cell_area_get_preferred_height_for_width() on each cell
// area individually to get the height for width of each fully requested row.
// 
// If at some point, the width of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_width() again and then the full width of the
// requested rows checked again with
// gtk_cell_area_context_get_preferred_width().
	func (a CellArea) PreferredHeightForWidth(context CellAreaContextClass, widget WidgetClass, width int) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.int // out
var _arg4 C.int // in
var _arg5 C.int // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (C.int)(width)

C.gtk_cell_area_get_preferred_height_for_width(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg4)
_naturalHeight = (int)(_arg5)

return _minimumHeight, _naturalHeight
}
	
	// PreferredWidth retrieves a cell areas initial minimum and natural width.
// 
// @area will store some geometrical information in @context along the way; when
// requesting sizes over an arbitrary number of rows, its not important to
// check the @minimum_width and @natural_width of this call but rather to
// consult gtk_cell_area_context_get_preferred_width() after a series of
// requests.
	func (a CellArea) PreferredWidth(context CellAreaContextClass, widget WidgetClass) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_area_get_preferred_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg3)
_naturalWidth = (int)(_arg4)

return _minimumWidth, _naturalWidth
}
	
	// PreferredWidthForHeight retrieves a cell areas minimum and natural width if
// it would be given the specified @height.
// 
// @area stores some geometrical information in @context along the way while
// calling gtk_cell_area_get_preferred_height(). Its important to perform a
// series of gtk_cell_area_get_preferred_height() requests with @context first
// and then call gtk_cell_area_get_preferred_width_for_height() on each cell
// area individually to get the height for width of each fully requested row.
// 
// If at some point, the height of a single row changes, it should be requested
// with gtk_cell_area_get_preferred_height() again and then the full height of
// the requested rows checked again with
// gtk_cell_area_context_get_preferred_height().
	func (a CellArea) PreferredWidthForHeight(context CellAreaContextClass, widget WidgetClass, height int) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 C.int // out
var _arg4 C.int // in
var _arg5 C.int // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (C.int)(height)

C.gtk_cell_area_get_preferred_width_for_height(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg4)
_naturalWidth = (int)(_arg5)

return _minimumWidth, _naturalWidth
}
	
	// RequestMode gets whether the area prefers a height-for-width layout or a
// width-for-height layout.
	func (a CellArea) RequestMode() SizeRequestMode {
var _arg0 *C.GtkCellArea // out
var _cret C.GtkSizeRequestMode // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_get_request_mode(_arg0)


var _sizeRequestMode SizeRequestMode // out

_sizeRequestMode = SizeRequestMode(_cret)

return _sizeRequestMode
}
	
	// HasRenderer checks if @area contains @renderer.
	func (a CellArea) HasRenderer(renderer CellRendererClass) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

_cret = C.gtk_cell_area_has_renderer(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InnerCellArea: this is a convenience function for CellArea implementations to
// get the inner area where a given CellRenderer will be rendered. It removes
// any padding previously added by gtk_cell_area_request_renderer().
	func (a CellArea) InnerCellArea(widget WidgetClass, cellArea *gdk.Rectangle) gdk.Rectangle {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GdkRectangle // out
var _innerArea gdk.Rectangle

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_cell_area_inner_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_innerArea)))





return _innerArea
}
	
	// IsActivatable returns whether the area can do anything when activated, after
// applying new attributes to @area.
	func (a CellArea) IsActivatable() bool {
var _arg0 *C.GtkCellArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_cell_area_is_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFocusSibling returns whether @sibling is one of @renderers focus siblings
// (see gtk_cell_area_add_focus_sibling()).
	func (a CellArea) IsFocusSibling(renderer CellRendererClass, sibling CellRendererClass) bool {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

_cret = C.gtk_cell_area_is_focus_sibling(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Remove removes @renderer from @area.
	func (a CellArea) Remove(renderer CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

C.gtk_cell_area_remove(_arg0, _arg1)
}
	
	// RemoveFocusSibling removes @sibling from @renderers focus sibling list (see
// gtk_cell_area_add_focus_sibling()).
	func (a CellArea) RemoveFocusSibling(renderer CellRendererClass, sibling CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(sibling.Native()))

C.gtk_cell_area_remove_focus_sibling(_arg0, _arg1, _arg2)
}
	
	// RequestRenderer: this is a convenience function for CellArea implementations
// to request size for cell renderers. Its important to use this function to
// request size and then use gtk_cell_area_inner_cell_area() at render and event
// time since this function will add padding around the cell for focus painting.
	func (a CellArea) RequestRenderer(renderer CellRendererClass, orientation Orientation, widget WidgetClass, forSize int) (minimumSize int, naturalSize int) {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.GtkOrientation // out
var _arg3 *C.GtkWidget // out
var _arg4 C.int // out
var _arg5 C.int // in
var _arg6 C.int // in

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
_arg2 = (C.GtkOrientation)(orientation)
_arg3 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg4 = (C.int)(forSize)

C.gtk_cell_area_request_renderer(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)

var _minimumSize int // out
var _naturalSize int // out

_minimumSize = (int)(_arg5)
_naturalSize = (int)(_arg6)

return _minimumSize, _naturalSize
}
	
	// SetFocusCell: explicitly sets the currently focused cell to @renderer.
// 
// This is generally called by implementations of CellAreaClass.focus() or
// CellAreaClass.event(), however it can also be used to implement functions
// such as gtk_tree_view_set_cursor_on_cell().
	func (a CellArea) SetFocusCell(renderer CellRendererClass)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))

C.gtk_cell_area_set_focus_cell(_arg0, _arg1)
}
	
	// Snapshot snapshots @areas cells according to @areas layout onto at the
// given coordinates.
	func (a CellArea) Snapshot(context CellAreaContextClass, widget WidgetClass, snapshot SnapshotClass, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState, paintFocus bool)  {
var _arg0 *C.GtkCellArea // out
var _arg1 *C.GtkCellAreaContext // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkSnapshot // out
var _arg4 *C.GdkRectangle // out
var _arg5 *C.GdkRectangle // out
var _arg6 C.GtkCellRendererState // out
var _arg7 C.gboolean // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg6 = (C.GtkCellRendererState)(flags)
if paintFocus { _arg7 = C.TRUE }

C.gtk_cell_area_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}
	
	// StopEditing: explicitly stops the editing of the currently edited cell.
// 
// If @canceled is true, the currently edited cell renderer will emit the
// ::editing-canceled signal, otherwise the the ::editing-done signal will be
// emitted on the current edit widget.
// 
// See gtk_cell_area_get_edited_cell() and gtk_cell_area_get_edit_widget().
	func (a CellArea) StopEditing(canceled bool)  {
var _arg0 *C.GtkCellArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellArea)(unsafe.Pointer(a.Native()))
if canceled { _arg1 = C.TRUE }

C.gtk_cell_area_stop_editing(_arg0, _arg1)
}
	


	// CellAreaBox: a cell area that renders GtkCellRenderers into a row or a column
// 
// The CellAreaBox renders cell renderers into a row or a column depending on
// its Orientation.
// 
// GtkCellAreaBox uses a notion of packing. Packing refers to adding cell
// renderers with reference to a particular position in a CellAreaBox. There are
// two reference positions: the start and the end of the box. When the
// CellAreaBox is oriented in the GTK_ORIENTATION_VERTICAL orientation, the
// start is defined as the top of the box and the end is defined as the bottom.
// In the GTK_ORIENTATION_HORIZONTAL orientation start is defined as the left
// side and the end is defined as the right side.
// 
// Alignments of CellRenderers rendered in adjacent rows can be configured by
// configuring the CellAreaBox align child cell property with
// gtk_cell_area_cell_set_property() or by specifying the "align" argument to
// gtk_cell_area_box_pack_start() and gtk_cell_area_box_pack_end().
	type CellAreaBox struct {
		CellArea
		Buildable
		CellLayout
		Orientable
		
	}

	// CellAreaBoxClass is an interface that the CellAreaBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellAreaBoxClass interface {
		gextras.Objector
		_cellAreaBox()
	}

	func (CellAreaBox) _cellAreaBox() {}

	
	func marshalCellAreaBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellAreaBox(obj), nil
	}
	

	
	// NewCellAreaBox creates a new CellAreaBox.
	func NewCellAreaBox() CellAreaBox {
var _cret *C.GtkCellArea // in

_cret = C.gtk_cell_area_box_new()


var _cellAreaBox CellAreaBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellAreaBox = CellAreaBox{
CellArea: CellArea{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellAreaBox
}
	

	
	// Spacing gets the spacing added between cell renderers.
	func (b CellAreaBox) Spacing() int {
var _arg0 *C.GtkCellAreaBox // out
var _cret C.int // in

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_cell_area_box_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PackEnd adds @renderer to @box, packed with reference to the end of @box.
// 
// The @renderer is packed after (away from end of) any other CellRenderer
// packed with reference to the end of @box.
	func (b CellAreaBox) PackEnd(renderer CellRendererClass, expand bool, align bool, fixed bool)  {
var _arg0 *C.GtkCellAreaBox // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
if expand { _arg2 = C.TRUE }
if align { _arg3 = C.TRUE }
if fixed { _arg4 = C.TRUE }

C.gtk_cell_area_box_pack_end(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// PackStart adds @renderer to @box, packed with reference to the start of @box.
// 
// The @renderer is packed after any other CellRenderer packed with reference to
// the start of @box.
	func (b CellAreaBox) PackStart(renderer CellRendererClass, expand bool, align bool, fixed bool)  {
var _arg0 *C.GtkCellAreaBox // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(renderer.Native()))
if expand { _arg2 = C.TRUE }
if align { _arg3 = C.TRUE }
if fixed { _arg4 = C.TRUE }

C.gtk_cell_area_box_pack_start(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetSpacing sets the spacing to add between cell renderers in @box.
	func (b CellAreaBox) SetSpacing(spacing int)  {
var _arg0 *C.GtkCellAreaBox // out
var _arg1 C.int // out

_arg0 = (*C.GtkCellAreaBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.int)(spacing)

C.gtk_cell_area_box_set_spacing(_arg0, _arg1)
}
	


	// CellAreaContext stores geometrical information for a series of rows in a
// GtkCellArea
// 
// The CellAreaContext object is created by a given CellArea implementation via
// its CellAreaClass.create_context() virtual method and is used to store cell
// sizes and alignments for a series of TreeModel rows that are requested and
// rendered in the same context.
// 
// CellLayout widgets can create any number of contexts in which to request and
// render groups of data rows. However, its important that the same context
// which was used to request sizes for a given TreeModel row also be used for
// the same row when calling other CellArea APIs such as gtk_cell_area_render()
// and gtk_cell_area_event().
	type CellAreaContext struct {
		**externglib.Object
		
	}

	// CellAreaContextClass is an interface that the CellAreaContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellAreaContextClass interface {
		gextras.Objector
		_cellAreaContext()
	}

	func (CellAreaContext) _cellAreaContext() {}

	
	func marshalCellAreaContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellAreaContext(obj), nil
	}
	

	

	
	// Allocate allocates a width and/or a height for all rows which are to be
// rendered with @context.
// 
// Usually allocation is performed only horizontally or sometimes vertically
// since a group of rows are usually rendered side by side vertically or
// horizontally and share either the same width or the same height. Sometimes
// they are allocated in both horizontal and vertical orientations producing a
// homogeneous effect of the rows. This is generally the case for TreeView when
// TreeView:fixed-height-mode is enabled.
	func (c CellAreaContext) Allocate(width int, height int)  {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)

C.gtk_cell_area_context_allocate(_arg0, _arg1, _arg2)
}
	
	// Allocation fetches the current allocation size for @context.
// 
// If the context was not allocated in width or height, or if the context was
// recently reset with gtk_cell_area_context_reset(), the returned value will be
// -1.
	func (c CellAreaContext) Allocation() (width int, height int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_get_allocation(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// Area fetches the CellArea this @context was created by.
// 
// This is generally unneeded by layouting widgets; however, it is important for
// the context implementation itself to fetch information about the area it is
// being used for.
// 
// For instance at CellAreaContextClass.allocate() time its important to know
// details about any cell spacing that the CellArea is configured with in order
// to compute a proper allocation.
	func (c CellAreaContext) Area() CellArea {
var _arg0 *C.GtkCellAreaContext // out
var _cret *C.GtkCellArea // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_area_context_get_area(_arg0)


var _cellArea CellArea // out

_cellArea = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellArea)

return _cellArea
}
	
	// PreferredHeight gets the accumulative preferred height for all rows which
// have been requested with this context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
	func (c CellAreaContext) PreferredHeight() (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_get_preferred_height(_arg0, &_arg1, &_arg2)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg1)
_naturalHeight = (int)(_arg2)

return _minimumHeight, _naturalHeight
}
	
	// PreferredHeightForWidth gets the accumulative preferred height for @width for
// all rows which have been requested for the same said @width with this
// context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
	func (c CellAreaContext) PreferredHeightForWidth(width int) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // out
var _arg2 C.int // in
var _arg3 C.int // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(width)

C.gtk_cell_area_context_get_preferred_height_for_width(_arg0, _arg1, &_arg2, &_arg3)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg2)
_naturalHeight = (int)(_arg3)

return _minimumHeight, _naturalHeight
}
	
	// PreferredWidth gets the accumulative preferred width for all rows which have
// been requested with this context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are 0.
	func (c CellAreaContext) PreferredWidth() (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_get_preferred_width(_arg0, &_arg1, &_arg2)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg1)
_naturalWidth = (int)(_arg2)

return _minimumWidth, _naturalWidth
}
	
	// PreferredWidthForHeight gets the accumulative preferred width for @height for
// all rows which have been requested for the same said @height with this
// context.
// 
// After gtk_cell_area_context_reset() is called and/or before ever requesting
// the size of a CellArea, the returned values are -1.
	func (c CellAreaContext) PreferredWidthForHeight(height int) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // out
var _arg2 C.int // in
var _arg3 C.int // in

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(height)

C.gtk_cell_area_context_get_preferred_width_for_height(_arg0, _arg1, &_arg2, &_arg3)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg2)
_naturalWidth = (int)(_arg3)

return _minimumWidth, _naturalWidth
}
	
	// PushPreferredHeight causes the minimum and/or natural height to grow if the
// new proposed sizes exceed the current minimum and natural height.
// 
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested height
// over a series of gtk_cell_area_get_preferred_height() requests.
	func (c CellAreaContext) PushPreferredHeight(minimumHeight int, naturalHeight int)  {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(minimumHeight)
_arg2 = (C.int)(naturalHeight)

C.gtk_cell_area_context_push_preferred_height(_arg0, _arg1, _arg2)
}
	
	// PushPreferredWidth causes the minimum and/or natural width to grow if the new
// proposed sizes exceed the current minimum and natural width.
// 
// This is used by CellAreaContext implementations during the request process
// over a series of TreeModel rows to progressively push the requested width
// over a series of gtk_cell_area_get_preferred_width() requests.
	func (c CellAreaContext) PushPreferredWidth(minimumWidth int, naturalWidth int)  {
var _arg0 *C.GtkCellAreaContext // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(minimumWidth)
_arg2 = (C.int)(naturalWidth)

C.gtk_cell_area_context_push_preferred_width(_arg0, _arg1, _arg2)
}
	
	// Reset resets any previously cached request and allocation data.
// 
// When underlying TreeModel data changes its important to reset the context if
// the content size is allowed to shrink. If the content size is only allowed to
// grow (this is usually an option for views rendering large data stores as a
// measure of optimization), then only the row that changed or was inserted
// needs to be (re)requested with gtk_cell_area_get_preferred_width().
// 
// When the new overall size of the context requires that the allocated size
// changes (or whenever this allocation changes at all), the variable row sizes
// need to be re-requested for every row.
// 
// For instance, if the rows are displayed all with the same width from top to
// bottom then a change in the allocated width necessitates a recalculation of
// all the displayed row heights using
// gtk_cell_area_get_preferred_height_for_width().
	func (c CellAreaContext) Reset()  {
var _arg0 *C.GtkCellAreaContext // out

_arg0 = (*C.GtkCellAreaContext)(unsafe.Pointer(c.Native()))

C.gtk_cell_area_context_reset(_arg0)
}
	


	// CellRenderer: an object for rendering a single cell
// 
// The CellRenderer is a base class of a set of objects used for rendering a
// cell to a #cairo_t. These objects are used primarily by the TreeView widget,
// though they arent tied to them in any specific way. It is worth noting that
// CellRenderer is not a Widget and cannot be treated as such.
// 
// The primary use of a CellRenderer is for drawing a certain graphical elements
// on a #cairo_t. Typically, one cell renderer is used to draw many cells on the
// screen. To this extent, it isnt expected that a CellRenderer keep any
// permanent state around. Instead, any state is set just prior to use using
// #GObjects property system. Then, the cell is measured using
// gtk_cell_renderer_get_preferred_size(). Finally, the cell is rendered in the
// correct location using gtk_cell_renderer_snapshot().
// 
// There are a number of rules that must be followed when writing a new
// CellRenderer. First and foremost, its important that a certain set of
// properties will always yield a cell renderer of the same size, barring a
// style change. The CellRenderer also has a number of generic properties that
// are expected to be honored by all children.
// 
// Beyond merely rendering a cell, cell renderers can optionally provide active
// user interface elements. A cell renderer can be activatable like
// CellRendererToggle, which toggles when it gets activated by a mouse click, or
// it can be editable like CellRendererText, which allows the user to edit the
// text using a widget implementing the CellEditable interface, e.g. Entry. To
// make a cell renderer activatable or editable, you have to implement the
// CellRendererClass.activate or CellRendererClass.start_editing virtual
// functions, respectively.
// 
// Many properties of CellRenderer and its subclasses have a corresponding set
// property, e.g. cell-background-set corresponds to cell-background. These
// set properties reflect whether a property has been set or not. You should
// not set them independently.
	type CellRenderer struct {
		externglib.InitiallyUnowned
		
	}

	// CellRendererClass is an interface that the CellRenderer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererClass interface {
		gextras.Objector
		_cellRenderer()
	}

	func (CellRenderer) _cellRenderer() {}

	
	func marshalCellRenderer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRenderer(obj), nil
	}
	

	

	
	// Activate passes an activate event to the cell renderer for possible
// processing. Some cell renderers may use events; for example,
// CellRendererToggle toggles when it gets a mouse click.
	func (c CellRenderer) Activate(event gdk.EventClass, widget WidgetClass, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) bool {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GdkEvent // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.char // out
var _arg4 *C.GdkRectangle // out
var _arg5 *C.GdkRectangle // out
var _arg6 C.GtkCellRendererState // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg6 = (C.GtkCellRendererState)(flags)

_cret = C.gtk_cell_renderer_activate(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AlignedArea gets the aligned area used by @cell inside @cell_area. Used for
// finding the appropriate edit and focus rectangle.
	func (c CellRenderer) AlignedArea(widget WidgetClass, flags CellRendererState, cellArea *gdk.Rectangle) gdk.Rectangle {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkCellRendererState // out
var _arg3 *C.GdkRectangle // out
var _alignedArea gdk.Rectangle

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkCellRendererState)(flags)
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))

C.gtk_cell_renderer_get_aligned_area(_arg0, _arg1, _arg2, _arg3, (*C.GdkRectangle)(unsafe.Pointer(&_alignedArea)))





return _alignedArea
}
	
	// Alignment fills in @xalign and @yalign with the appropriate values of @cell.
	func (c CellRenderer) Alignment() (xalign float32, yalign float32) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.float // in
var _arg2 C.float // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

C.gtk_cell_renderer_get_alignment(_arg0, &_arg1, &_arg2)

var _xalign float32 // out
var _yalign float32 // out

_xalign = (float32)(_arg1)
_yalign = (float32)(_arg2)

return _xalign, _yalign
}
	
	// FixedSize fills in @width and @height with the appropriate size of @cell.
	func (c CellRenderer) FixedSize() (width int, height int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

C.gtk_cell_renderer_get_fixed_size(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// IsExpanded checks whether the given CellRenderer is expanded.
	func (c CellRenderer) IsExpanded() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_is_expanded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsExpander checks whether the given CellRenderer is an expander.
	func (c CellRenderer) IsExpander() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_is_expander(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Padding fills in @xpad and @ypad with the appropriate values of @cell.
	func (c CellRenderer) Padding() (xpad int, ypad int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

C.gtk_cell_renderer_get_padding(_arg0, &_arg1, &_arg2)

var _xpad int // out
var _ypad int // out

_xpad = (int)(_arg1)
_ypad = (int)(_arg2)

return _xpad, _ypad
}
	
	// PreferredHeight retrieves a renderers natural size when rendered to @widget.
	func (c CellRenderer) PreferredHeight(widget WidgetClass) (minimumSize int, naturalSize int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // in
var _arg3 C.int // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_renderer_get_preferred_height(_arg0, _arg1, &_arg2, &_arg3)

var _minimumSize int // out
var _naturalSize int // out

_minimumSize = (int)(_arg2)
_naturalSize = (int)(_arg3)

return _minimumSize, _naturalSize
}
	
	// PreferredHeightForWidth retrieves a cell rendererss minimum and natural
// height if it were rendered to @widget with the specified @width.
	func (c CellRenderer) PreferredHeightForWidth(widget WidgetClass, width int) (minimumHeight int, naturalHeight int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.int)(width)

C.gtk_cell_renderer_get_preferred_height_for_width(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumHeight int // out
var _naturalHeight int // out

_minimumHeight = (int)(_arg3)
_naturalHeight = (int)(_arg4)

return _minimumHeight, _naturalHeight
}
	
	// PreferredSize retrieves the minimum and natural size of a cell taking into
// account the widgets preference for height-for-width management.
	func (c CellRenderer) PreferredSize(widget WidgetClass) (minimumSize Requisition, naturalSize Requisition) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _minimumSize Requisition
var _naturalSize Requisition

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_renderer_get_preferred_size(_arg0, _arg1, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))







return _minimumSize, _naturalSize
}
	
	// PreferredWidth retrieves a renderers natural size when rendered to @widget.
	func (c CellRenderer) PreferredWidth(widget WidgetClass) (minimumSize int, naturalSize int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // in
var _arg3 C.int // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_cell_renderer_get_preferred_width(_arg0, _arg1, &_arg2, &_arg3)

var _minimumSize int // out
var _naturalSize int // out

_minimumSize = (int)(_arg2)
_naturalSize = (int)(_arg3)

return _minimumSize, _naturalSize
}
	
	// PreferredWidthForHeight retrieves a cell rendererss minimum and natural
// width if it were rendered to @widget with the specified @height.
	func (c CellRenderer) PreferredWidthForHeight(widget WidgetClass, height int) (minimumWidth int, naturalWidth int) {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.int)(height)

C.gtk_cell_renderer_get_preferred_width_for_height(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _minimumWidth int // out
var _naturalWidth int // out

_minimumWidth = (int)(_arg3)
_naturalWidth = (int)(_arg4)

return _minimumWidth, _naturalWidth
}
	
	// RequestMode gets whether the cell renderer prefers a height-for-width layout
// or a width-for-height layout.
	func (c CellRenderer) RequestMode() SizeRequestMode {
var _arg0 *C.GtkCellRenderer // out
var _cret C.GtkSizeRequestMode // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_request_mode(_arg0)


var _sizeRequestMode SizeRequestMode // out

_sizeRequestMode = SizeRequestMode(_cret)

return _sizeRequestMode
}
	
	// Sensitive returns the cell renderers sensitivity.
	func (c CellRenderer) Sensitive() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// State translates the cell renderer state to StateFlags, based on the cell
// renderer and widget sensitivity, and the given CellRendererState.
	func (c CellRenderer) State(widget WidgetClass, cellState CellRendererState) StateFlags {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkCellRendererState // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkCellRendererState)(cellState)

_cret = C.gtk_cell_renderer_get_state(_arg0, _arg1, _arg2)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// Visible returns the cell renderers visibility.
	func (c CellRenderer) Visible() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsActivatable checks whether the cell renderer can do something when
// activated.
	func (c CellRenderer) IsActivatable() bool {
var _arg0 *C.GtkCellRenderer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_renderer_is_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAlignment sets the renderers alignment within its available space.
	func (c CellRenderer) SetAlignment(xalign float32, yalign float32)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.float // out
var _arg2 C.float // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (C.float)(xalign)
_arg2 = (C.float)(yalign)

C.gtk_cell_renderer_set_alignment(_arg0, _arg1, _arg2)
}
	
	// SetFixedSize sets the renderer size to be explicit, independent of the
// properties set.
	func (c CellRenderer) SetFixedSize(width int, height int)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)

C.gtk_cell_renderer_set_fixed_size(_arg0, _arg1, _arg2)
}
	
	// SetIsExpanded sets whether the given CellRenderer is expanded.
	func (c CellRenderer) SetIsExpanded(isExpanded bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if isExpanded { _arg1 = C.TRUE }

C.gtk_cell_renderer_set_is_expanded(_arg0, _arg1)
}
	
	// SetIsExpander sets whether the given CellRenderer is an expander.
	func (c CellRenderer) SetIsExpander(isExpander bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if isExpander { _arg1 = C.TRUE }

C.gtk_cell_renderer_set_is_expander(_arg0, _arg1)
}
	
	// SetPadding sets the renderers padding.
	func (c CellRenderer) SetPadding(xpad int, ypad int)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(xpad)
_arg2 = (C.int)(ypad)

C.gtk_cell_renderer_set_padding(_arg0, _arg1, _arg2)
}
	
	// SetSensitive sets the cell renderers sensitivity.
	func (c CellRenderer) SetSensitive(sensitive bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if sensitive { _arg1 = C.TRUE }

C.gtk_cell_renderer_set_sensitive(_arg0, _arg1)
}
	
	// SetVisible sets the cell renderers visibility.
	func (c CellRenderer) SetVisible(visible bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_cell_renderer_set_visible(_arg0, _arg1)
}
	
	// Snapshot invokes the virtual render function of the CellRenderer. The three
// passed-in rectangles are areas in @cr. Most renderers will draw within
// @cell_area; the xalign, yalign, xpad, and ypad fields of the CellRenderer
// should be honored with respect to @cell_area. @background_area includes the
// blank space around the cell, and also the area containing the tree expander;
// so the @background_area rectangles for all cells tile to cover the entire
// @window.
	func (c CellRenderer) Snapshot(snapshot SnapshotClass, widget WidgetClass, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GtkSnapshot // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GdkRectangle // out
var _arg4 *C.GdkRectangle // out
var _arg5 C.GtkCellRendererState // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg5 = (C.GtkCellRendererState)(flags)

C.gtk_cell_renderer_snapshot(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// StartEditing starts editing the contents of this @cell, through a new
// CellEditable widget created by the CellRendererClass.start_editing virtual
// function.
	func (c CellRenderer) StartEditing(event gdk.EventClass, widget WidgetClass, path string, backgroundArea *gdk.Rectangle, cellArea *gdk.Rectangle, flags CellRendererState) CellEditable {
var _arg0 *C.GtkCellRenderer // out
var _arg1 *C.GdkEvent // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.char // out
var _arg4 *C.GdkRectangle // out
var _arg5 *C.GdkRectangle // out
var _arg6 C.GtkCellRendererState // out
var _cret *C.GtkCellEditable // in

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg3))
_arg4 = (*C.GdkRectangle)(unsafe.Pointer(backgroundArea.Native()))
_arg5 = (*C.GdkRectangle)(unsafe.Pointer(cellArea.Native()))
_arg6 = (C.GtkCellRendererState)(flags)

_cret = C.gtk_cell_renderer_start_editing(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _cellEditable CellEditable // out

_cellEditable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(CellEditable)

return _cellEditable
}
	
	// StopEditing informs the cell renderer that the editing is stopped. If
// @canceled is true, the cell renderer will emit the
// CellRenderer::editing-canceled signal.
// 
// This function should be called by cell renderer implementations in response
// to the CellEditable::editing-done signal of CellEditable.
	func (c CellRenderer) StopEditing(canceled bool)  {
var _arg0 *C.GtkCellRenderer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRenderer)(unsafe.Pointer(c.Native()))
if canceled { _arg1 = C.TRUE }

C.gtk_cell_renderer_stop_editing(_arg0, _arg1)
}
	


	// CellRendererAccel renders a keyboard accelerator in a cell
// 
// CellRendererAccel displays a keyboard accelerator (i.e. a key combination
// like `Control + a`). If the cell renderer is editable, the accelerator can be
// changed by simply typing the new combination.
	type CellRendererAccel struct {
		CellRendererText
		
	}

	// CellRendererAccelClass is an interface that the CellRendererAccel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererAccelClass interface {
		gextras.Objector
		_cellRendererAccel()
	}

	func (CellRendererAccel) _cellRendererAccel() {}

	
	func marshalCellRendererAccel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererAccel(obj), nil
	}
	

	
	// NewCellRendererAccel creates a new CellRendererAccel.
	func NewCellRendererAccel() CellRendererAccel {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_accel_new()


var _cellRendererAccel CellRendererAccel // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererAccel = CellRendererAccel{
CellRendererText: CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _cellRendererAccel
}
	

	


	// CellRendererCombo renders a combobox in a cell
// 
// CellRendererCombo renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererCombo offers a ComboBox widget to edit the text. The values
// to display in the combo box are taken from the tree model specified in the
// CellRendererCombo:model property.
// 
// The combo cell renderer takes care of adding a text cell renderer to the
// combo box and sets it to display the column specified by its
// CellRendererCombo:text-column property. Further properties of the combo box
// can be set in a handler for the CellRenderer::editing-started signal.
	type CellRendererCombo struct {
		CellRendererText
		
	}

	// CellRendererComboClass is an interface that the CellRendererCombo class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererComboClass interface {
		gextras.Objector
		_cellRendererCombo()
	}

	func (CellRendererCombo) _cellRendererCombo() {}

	
	func marshalCellRendererCombo(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererCombo(obj), nil
	}
	

	
	// NewCellRendererCombo creates a new CellRendererCombo. Adjust how text is
// drawn using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the text property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView.
	func NewCellRendererCombo() CellRendererCombo {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_combo_new()


var _cellRendererCombo CellRendererCombo // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererCombo = CellRendererCombo{
CellRendererText: CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _cellRendererCombo
}
	

	


	// CellRendererPixbuf renders a pixbuf in a cell
// 
// A CellRendererPixbuf can be used to render an image in a cell. It allows to
// render either a given Pixbuf (set via the CellRendererPixbuf:pixbuf property)
// or a named icon (set via the CellRendererPixbuf:icon-name property).
// 
// To support the tree view, CellRendererPixbuf also supports rendering two
// alternative pixbufs, when the CellRenderer:is-expander property is true. If
// the CellRenderer:is-expanded property is true and the
// CellRendererPixbuf:pixbuf-expander-open property is set to a pixbuf, it
// renders that pixbuf, if the CellRenderer:is-expanded property is false and
// the CellRendererPixbuf:pixbuf-expander-closed property is set to a pixbuf, it
// renders that one.
	type CellRendererPixbuf struct {
		CellRenderer
		
	}

	// CellRendererPixbufClass is an interface that the CellRendererPixbuf class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererPixbufClass interface {
		gextras.Objector
		_cellRendererPixbuf()
	}

	func (CellRendererPixbuf) _cellRendererPixbuf() {}

	
	func marshalCellRendererPixbuf(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererPixbuf(obj), nil
	}
	

	
	// NewCellRendererPixbuf creates a new CellRendererPixbuf. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the pixbuf property on
// the cell renderer to a pixbuf value in the model, thus rendering a different
// image in each row of the TreeView.
	func NewCellRendererPixbuf() CellRendererPixbuf {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_pixbuf_new()


var _cellRendererPixbuf CellRendererPixbuf // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererPixbuf = CellRendererPixbuf{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererPixbuf
}
	

	


	// CellRendererProgress renders numbers as progress bars
// 
// CellRendererProgress renders a numeric value as a progress par in a cell.
// Additionally, it can display a text on top of the progress bar.
	type CellRendererProgress struct {
		CellRenderer
		Orientable
		
	}

	// CellRendererProgressClass is an interface that the CellRendererProgress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererProgressClass interface {
		gextras.Objector
		_cellRendererProgress()
	}

	func (CellRendererProgress) _cellRendererProgress() {}

	
	func marshalCellRendererProgress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererProgress(obj), nil
	}
	

	
	// NewCellRendererProgress creates a new CellRendererProgress.
	func NewCellRendererProgress() CellRendererProgress {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_progress_new()


var _cellRendererProgress CellRendererProgress // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererProgress = CellRendererProgress{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellRendererProgress
}
	

	


	// CellRendererSpin renders a spin button in a cell
// 
// CellRendererSpin renders text in a cell like CellRendererText from which it
// is derived. But while CellRendererText offers a simple entry to edit the
// text, CellRendererSpin offers a SpinButton widget. Of course, that means that
// the text has to be parseable as a floating point number.
// 
// The range of the spinbutton is taken from the adjustment property of the cell
// renderer, which can be set explicitly or mapped to a column in the tree
// model, like all properties of cell renders. CellRendererSpin also has
// properties for the CellRendererSpin:climb-rate and the number of
// CellRendererSpin:digits to display. Other SpinButton properties can be set in
// a handler for the CellRenderer::editing-started signal.
// 
// The CellRendererSpin cell renderer was added in GTK 2.10.
	type CellRendererSpin struct {
		CellRendererText
		
	}

	// CellRendererSpinClass is an interface that the CellRendererSpin class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererSpinClass interface {
		gextras.Objector
		_cellRendererSpin()
	}

	func (CellRendererSpin) _cellRendererSpin() {}

	
	func marshalCellRendererSpin(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererSpin(obj), nil
	}
	

	
	// NewCellRendererSpin creates a new CellRendererSpin.
	func NewCellRendererSpin() CellRendererSpin {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_spin_new()


var _cellRendererSpin CellRendererSpin // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererSpin = CellRendererSpin{
CellRendererText: CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _cellRendererSpin
}
	

	


	// CellRendererSpinner renders a spinning animation in a cell
// 
// GtkCellRendererSpinner renders a spinning animation in a cell, very similar
// to Spinner. It can often be used as an alternative to a CellRendererProgress
// for displaying indefinite activity, instead of actual progress.
// 
// To start the animation in a cell, set the CellRendererSpinner:active property
// to true and increment the CellRendererSpinner:pulse property at regular
// intervals. The usual way to set the cell renderer properties for each cell is
// to bind them to columns in your tree model using e.g.
// gtk_tree_view_column_add_attribute().
	type CellRendererSpinner struct {
		CellRenderer
		
	}

	// CellRendererSpinnerClass is an interface that the CellRendererSpinner class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererSpinnerClass interface {
		gextras.Objector
		_cellRendererSpinner()
	}

	func (CellRendererSpinner) _cellRendererSpinner() {}

	
	func marshalCellRendererSpinner(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererSpinner(obj), nil
	}
	

	
	// NewCellRendererSpinner returns a new cell renderer which will show a spinner
// to indicate activity.
	func NewCellRendererSpinner() CellRendererSpinner {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_spinner_new()


var _cellRendererSpinner CellRendererSpinner // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererSpinner = CellRendererSpinner{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererSpinner
}
	

	


	// CellRendererText renders text in a cell
// 
// A CellRendererText renders a given text in its cell, using the font, color
// and style information provided by its properties. The text will be ellipsized
// if it is too long and the CellRendererText:ellipsize property allows it.
// 
// If the CellRenderer:mode is GTK_CELL_RENDERER_MODE_EDITABLE, the
// CellRendererText allows to edit its text using an entry.
	type CellRendererText struct {
		CellRenderer
		
	}

	// CellRendererTextClass is an interface that the CellRendererText class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererTextClass interface {
		gextras.Objector
		_cellRendererText()
	}

	func (CellRendererText) _cellRendererText() {}

	
	func marshalCellRendererText(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererText(obj), nil
	}
	

	
	// NewCellRendererText creates a new CellRendererText. Adjust how text is drawn
// using object properties. Object properties can be set globally (with
// g_object_set()). Also, with TreeViewColumn, you can bind a property to a
// value in a TreeModel. For example, you can bind the text property on the
// cell renderer to a string value in the model, thus rendering a different
// string in each row of the TreeView
	func NewCellRendererText() CellRendererText {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_text_new()


var _cellRendererText CellRendererText // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererText = CellRendererText{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererText
}
	

	
	// SetFixedHeightFromFont sets the height of a renderer to explicitly be
// determined by the font and y_pad property set on it. Further changes in
// these properties do not affect the height, so they must be accompanied by a
// subsequent call to this function. Using this function is inflexible, and
// should really only be used if calculating the size of a cell is too slow (ie,
// a massive number of cells displayed). If @number_of_rows is -1, then the
// fixed height is unset, and the height is determined by the properties again.
	func (r CellRendererText) SetFixedHeightFromFont(numberOfRows int)  {
var _arg0 *C.GtkCellRendererText // out
var _arg1 C.int // out

_arg0 = (*C.GtkCellRendererText)(unsafe.Pointer(r.Native()))
_arg1 = (C.int)(numberOfRows)

C.gtk_cell_renderer_text_set_fixed_height_from_font(_arg0, _arg1)
}
	


	// CellRendererToggle renders a toggle button in a cell
// 
// CellRendererToggle renders a toggle button in a cell. The button is drawn as
// a radio or a checkbutton, depending on the CellRendererToggle:radio property.
// When activated, it emits the CellRendererToggle::toggled signal.
	type CellRendererToggle struct {
		CellRenderer
		
	}

	// CellRendererToggleClass is an interface that the CellRendererToggle class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellRendererToggleClass interface {
		gextras.Objector
		_cellRendererToggle()
	}

	func (CellRendererToggle) _cellRendererToggle() {}

	
	func marshalCellRendererToggle(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellRendererToggle(obj), nil
	}
	

	
	// NewCellRendererToggle creates a new CellRendererToggle. Adjust rendering
// parameters using object properties. Object properties can be set globally
// (with g_object_set()). Also, with TreeViewColumn, you can bind a property to
// a value in a TreeModel. For example, you can bind the active property on
// the cell renderer to a boolean value in the model, thus causing the check
// button to reflect the state of the model.
	func NewCellRendererToggle() CellRendererToggle {
var _cret *C.GtkCellRenderer // in

_cret = C.gtk_cell_renderer_toggle_new()


var _cellRendererToggle CellRendererToggle // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellRendererToggle = CellRendererToggle{
CellRenderer: CellRenderer{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _cellRendererToggle
}
	

	
	// Activatable returns whether the cell renderer is activatable. See
// gtk_cell_renderer_toggle_set_activatable().
	func (t CellRendererToggle) Activatable() bool {
var _arg0 *C.GtkCellRendererToggle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

_cret = C.gtk_cell_renderer_toggle_get_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Active returns whether the cell renderer is active. See
// gtk_cell_renderer_toggle_set_active().
	func (t CellRendererToggle) Active() bool {
var _arg0 *C.GtkCellRendererToggle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

_cret = C.gtk_cell_renderer_toggle_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Radio returns whether were rendering radio toggles rather than checkboxes.
	func (t CellRendererToggle) Radio() bool {
var _arg0 *C.GtkCellRendererToggle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))

_cret = C.gtk_cell_renderer_toggle_get_radio(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActivatable makes the cell renderer activatable.
	func (t CellRendererToggle) SetActivatable(setting bool)  {
var _arg0 *C.GtkCellRendererToggle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_cell_renderer_toggle_set_activatable(_arg0, _arg1)
}
	
	// SetActive activates or deactivates a cell renderer.
	func (t CellRendererToggle) SetActive(setting bool)  {
var _arg0 *C.GtkCellRendererToggle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_cell_renderer_toggle_set_active(_arg0, _arg1)
}
	
	// SetRadio: if @radio is true, the cell renderer renders a radio toggle (i.e. a
// toggle in a group of mutually-exclusive toggles). If false, it renders a
// check toggle (a standalone boolean option). This can be set globally for the
// cell renderer, or changed just before rendering each cell in the model (for
// TreeView, you set up a per-row setting using TreeViewColumn to associate
// model columns with cell renderer properties).
	func (t CellRendererToggle) SetRadio(radio bool)  {
var _arg0 *C.GtkCellRendererToggle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellRendererToggle)(unsafe.Pointer(t.Native()))
if radio { _arg1 = C.TRUE }

C.gtk_cell_renderer_toggle_set_radio(_arg0, _arg1)
}
	


	// CellView: a widget displaying a single row of a GtkTreeModel
// 
// A CellView displays a single row of a TreeModel using a CellArea and
// CellAreaContext. A CellAreaContext can be provided to the CellView at
// construction time in order to keep the cellview in context of a group of cell
// views, this ensures that the renderers displayed will be properly aligned
// with each other (like the aligned cells in the menus of ComboBox).
// 
// CellView is Orientable in order to decide in which orientation the underlying
// CellAreaContext should be allocated. Taking the ComboBox menu as an example,
// cellviews should be oriented horizontally if the menus are listed
// top-to-bottom and thus all share the same width but may have separate
// individual heights (left-to-right menus should be allocated vertically since
// they all share the same height but may have variable widths).
// 
// 
// CSS nodes
// 
// GtkCellView has a single CSS node with name cellview.
	type CellView struct {
		Widget
		Accessible
		Buildable
		CellLayout
		ConstraintTarget
		Orientable
		
	}

	// CellViewClass is an interface that the CellView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CellViewClass interface {
		gextras.Objector
		_cellView()
	}

	func (CellView) _cellView() {}

	
	func marshalCellView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCellView(obj), nil
	}
	

	
	// NewCellView creates a new CellView widget.
	func NewCellView() CellView {
var _cret *C.GtkWidget // in

_cret = C.gtk_cell_view_new()


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithContext creates a new CellView widget with a specific CellArea
// to layout cells and a specific CellAreaContext.
// 
// Specifying the same context for a handful of cells lets the underlying area
// synchronize the geometry for those cells, in this way alignments with
// cellviews for other rows are possible.
	func NewCellViewWithContext(area CellAreaClass, context CellAreaContextClass) CellView {
var _arg1 *C.GtkCellArea // out
var _arg2 *C.GtkCellAreaContext // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))
_arg2 = (*C.GtkCellAreaContext)(unsafe.Pointer(context.Native()))

_cret = C.gtk_cell_view_new_with_context(_arg1, _arg2)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithMarkup creates a new CellView widget, adds a CellRendererText
// to it, and makes it show @markup. The text can be marked up with the [Pango
// text markup language][PangoMarkupFormat].
	func NewCellViewWithMarkup(markup string) CellView {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_cell_view_new_with_markup(_arg1)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithText creates a new CellView widget, adds a CellRendererText to
// it, and makes it show @text.
	func NewCellViewWithText(text string) CellView {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_cell_view_new_with_text(_arg1)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	
	// NewCellViewWithTexture creates a new CellView widget, adds a
// CellRendererPixbuf to it, and makes it show @texture.
	func NewCellViewWithTexture(texture gdk.TextureClass) CellView {
var _arg1 *C.GdkTexture // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))

_cret = C.gtk_cell_view_new_with_texture(_arg1)


var _cellView CellView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_cellView = CellView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cellView
}
	

	
	// DisplayedRow returns a TreePath referring to the currently displayed row. If
// no row is currently displayed, nil is returned.
	func (c CellView) DisplayedRow() *TreePath {
var _arg0 *C.GtkCellView // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_displayed_row(_arg0)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// DrawSensitive gets whether @cell_view is configured to draw all of its cells
// in a sensitive state.
	func (c CellView) DrawSensitive() bool {
var _arg0 *C.GtkCellView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_draw_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FitModel gets whether @cell_view is configured to request space to fit the
// entire TreeModel.
	func (c CellView) FitModel() bool {
var _arg0 *C.GtkCellView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_fit_model(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Model returns the model for @cell_view. If no model is used nil is returned.
	func (c CellView) Model() TreeModel {
var _arg0 *C.GtkCellView // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))

_cret = C.gtk_cell_view_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// SetDisplayedRow sets the row of the model that is currently displayed by the
// CellView. If the path is unset, then the contents of the cellview stick at
// their last value; this is not normally a desired result, but may be a needed
// intermediate state if say, the model for the CellView becomes temporarily
// empty.
	func (c CellView) SetDisplayedRow(path *TreePath)  {
var _arg0 *C.GtkCellView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_cell_view_set_displayed_row(_arg0, _arg1)
}
	
	// SetDrawSensitive sets whether @cell_view should draw all of its cells in a
// sensitive state, this is used by ComboBox menus to ensure that rows with
// insensitive cells that contain children appear sensitive in the parent menu
// item.
	func (c CellView) SetDrawSensitive(drawSensitive bool)  {
var _arg0 *C.GtkCellView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
if drawSensitive { _arg1 = C.TRUE }

C.gtk_cell_view_set_draw_sensitive(_arg0, _arg1)
}
	
	// SetFitModel sets whether @cell_view should request space to fit the entire
// TreeModel.
// 
// This is used by ComboBox to ensure that the cell view displayed on the combo
// boxs button always gets enough space and does not resize when selection
// changes.
	func (c CellView) SetFitModel(fitModel bool)  {
var _arg0 *C.GtkCellView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
if fitModel { _arg1 = C.TRUE }

C.gtk_cell_view_set_fit_model(_arg0, _arg1)
}
	
	// SetModel sets the model for @cell_view. If @cell_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
	func (c CellView) SetModel(model TreeModel)  {
var _arg0 *C.GtkCellView // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkCellView)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_cell_view_set_model(_arg0, _arg1)
}
	


	// CenterBox: `GtkCenterBox` arranges three children in a row, keeping the
// middle child centered as well as possible.
// 
// !An example GtkCenterBox (centerbox.png)
// 
// To add children to `GtkCenterBox`, use
// [method@Gtk.CenterBox.set_start_widget],
// [method@Gtk.CenterBox.set_center_widget] and
// [method@Gtk.CenterBox.set_end_widget].
// 
// The sizing and positioning of children can be influenced with the align and
// expand properties of the children.
// 
// 
// GtkCenterBox as GtkBuildable
// 
// The `GtkCenterBox` implementation of the `GtkBuildable` interface supports
// placing children in the 3 positions by specifying start, center or end
// as the type attribute of a <child> element.
// 
// 
// CSS nodes
// 
// `GtkCenterBox` uses a single CSS node with the name box,
// 
// The first child of the `GtkCenterBox` will be allocated depending on the text
// direction, i.e. in left-to-right layouts it will be allocated on the left and
// in right-to-left layouts on the right.
// 
// In vertical orientation, the nodes of the children are arranged from top to
// bottom.
// 
// 
// Accessibility
// 
// `GtkCenterBox` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type CenterBox struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// CenterBoxClass is an interface that the CenterBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CenterBoxClass interface {
		gextras.Objector
		_centerBox()
	}

	func (CenterBox) _centerBox() {}

	
	func marshalCenterBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCenterBox(obj), nil
	}
	

	
	// NewCenterBox creates a new `GtkCenterBox`.
	func NewCenterBox() CenterBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_center_box_new()


var _centerBox CenterBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_centerBox = CenterBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _centerBox
}
	

	
	// BaselinePosition gets the value set by
// gtk_center_box_set_baseline_position().
	func (s CenterBox) BaselinePosition() BaselinePosition {
var _arg0 *C.GtkCenterBox // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_box_get_baseline_position(_arg0)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// CenterWidget gets the center widget, or nil if there is none.
	func (s CenterBox) CenterWidget() Widget {
var _arg0 *C.GtkCenterBox // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_box_get_center_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// EndWidget gets the end widget, or nil if there is none.
	func (s CenterBox) EndWidget() Widget {
var _arg0 *C.GtkCenterBox // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_box_get_end_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// StartWidget gets the start widget, or nil if there is none.
	func (s CenterBox) StartWidget() Widget {
var _arg0 *C.GtkCenterBox // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_box_get_start_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetBaselinePosition sets the baseline position of a center box.
// 
// This affects only horizontal boxes with at least one baseline aligned child.
// If there is more vertical space available than requested, and the baseline is
// not allocated by the parent then @position is used to allocate the baseline
// wrt. the extra space available.
	func (s CenterBox) SetBaselinePosition(position BaselinePosition)  {
var _arg0 *C.GtkCenterBox // out
var _arg1 C.GtkBaselinePosition // out

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkBaselinePosition)(position)

C.gtk_center_box_set_baseline_position(_arg0, _arg1)
}
	
	// SetCenterWidget sets the center widget.
// 
// To remove the existing center widget, pas nil.
	func (s CenterBox) SetCenterWidget(child WidgetClass)  {
var _arg0 *C.GtkCenterBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_center_box_set_center_widget(_arg0, _arg1)
}
	
	// SetEndWidget sets the end widget.
// 
// To remove the existing end widget, pass nil.
	func (s CenterBox) SetEndWidget(child WidgetClass)  {
var _arg0 *C.GtkCenterBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_center_box_set_end_widget(_arg0, _arg1)
}
	
	// SetStartWidget sets the start widget.
// 
// To remove the existing start widget, pass nil.
	func (s CenterBox) SetStartWidget(child WidgetClass)  {
var _arg0 *C.GtkCenterBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkCenterBox)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_center_box_set_start_widget(_arg0, _arg1)
}
	


	// CenterLayout: `GtkCenterLayout` is a layout manager that manages up to three
// children.
// 
// The start widget is allocated at the start of the layout (left in
// left-to-right locales and right in right-to-left ones), and the end widget at
// the end.
// 
// The center widget is centered regarding the full width of the layout's.
	type CenterLayout struct {
		LayoutManager
		
	}

	// CenterLayoutClass is an interface that the CenterLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CenterLayoutClass interface {
		gextras.Objector
		_centerLayout()
	}

	func (CenterLayout) _centerLayout() {}

	
	func marshalCenterLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCenterLayout(obj), nil
	}
	

	
	// NewCenterLayout creates a new `GtkCenterLayout`.
	func NewCenterLayout() CenterLayout {
var _cret *C.GtkLayoutManager // in

_cret = C.gtk_center_layout_new()


var _centerLayout CenterLayout // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_centerLayout = CenterLayout{
LayoutManager: LayoutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _centerLayout
}
	

	
	// BaselinePosition returns the baseline position of the layout.
	func (s CenterLayout) BaselinePosition() BaselinePosition {
var _arg0 *C.GtkCenterLayout // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_layout_get_baseline_position(_arg0)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// CenterWidget returns the center widget of the layout.
	func (s CenterLayout) CenterWidget() Widget {
var _arg0 *C.GtkCenterLayout // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_layout_get_center_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// EndWidget returns the end widget of the layout.
	func (s CenterLayout) EndWidget() Widget {
var _arg0 *C.GtkCenterLayout // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_layout_get_end_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Orientation gets the current orienration of the layout manager.
	func (s CenterLayout) Orientation() Orientation {
var _arg0 *C.GtkCenterLayout // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_layout_get_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// StartWidget returns the start widget fo the layout.
	func (s CenterLayout) StartWidget() Widget {
var _arg0 *C.GtkCenterLayout // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))

_cret = C.gtk_center_layout_get_start_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetBaselinePosition sets the new baseline position of @self
	func (s CenterLayout) SetBaselinePosition(baselinePosition BaselinePosition)  {
var _arg0 *C.GtkCenterLayout // out
var _arg1 C.GtkBaselinePosition // out

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkBaselinePosition)(baselinePosition)

C.gtk_center_layout_set_baseline_position(_arg0, _arg1)
}
	
	// SetCenterWidget sets the new center widget of @self.
// 
// To remove the existing center widget, pass nil.
	func (s CenterLayout) SetCenterWidget(widget WidgetClass)  {
var _arg0 *C.GtkCenterLayout // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_center_layout_set_center_widget(_arg0, _arg1)
}
	
	// SetEndWidget sets the new end widget of @self.
// 
// To remove the existing center widget, pass nil.
	func (s CenterLayout) SetEndWidget(widget WidgetClass)  {
var _arg0 *C.GtkCenterLayout // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_center_layout_set_end_widget(_arg0, _arg1)
}
	
	// SetOrientation sets the orientation of @self.
	func (s CenterLayout) SetOrientation(orientation Orientation)  {
var _arg0 *C.GtkCenterLayout // out
var _arg1 C.GtkOrientation // out

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkOrientation)(orientation)

C.gtk_center_layout_set_orientation(_arg0, _arg1)
}
	
	// SetStartWidget sets the new start widget of @self.
// 
// To remove the existing start widget, pass nil.
	func (s CenterLayout) SetStartWidget(widget WidgetClass)  {
var _arg0 *C.GtkCenterLayout // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkCenterLayout)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_center_layout_set_start_widget(_arg0, _arg1)
}
	


	// CheckButton: a `GtkCheckButton` places a label next to an indicator.
// 
// !Example GtkCheckButtons (check-button.png)
// 
// A `GtkCheckButton` is created by calling either [ctor@Gtk.CheckButton.new] or
// [ctor@Gtk.CheckButton.new_with_label].
// 
// The state of a `GtkCheckButton` can be set specifically using
// [method@Gtk.CheckButton.set_active], and retrieved using
// [method@Gtk.CheckButton.get_active].
// 
// 
// Inconsistent state
// 
// In addition to "on" and "off", check buttons can be an "in between" state
// that is neither on nor off. This can be used e.g. when the user has selected
// a range of elements (such as some text or spreadsheet cells) that are
// affected by a check button, and the current values in that range are
// inconsistent.
// 
// To set a `GtkCheckButton` to inconsistent state, use
// [method@Gtk.CheckButton.set_inconsistent].
// 
// 
// Grouping
// 
// Check buttons can be grouped together, to form mutually exclusive groups -
// only one of the buttons can be toggled at a time, and toggling another one
// will switch the currently toggled one off.
// 
// Grouped check buttons use a different indicator, and are commonly referred to
// as *radio buttons*.
// 
// !Example GtkCheckButtons (radio-button.png)
// 
// To add a `GtkCheckButton` to a group, use [method@Gtk.CheckButton.set_group].
// 
// 
// CSS nodes
// 
// ` checkbutton[.text-button]  check  [label] `
// 
// A `GtkCheckButton` has a main node with name checkbutton. If the
// [property@Gtk.CheckButton:label] property is set, it contains a label child.
// The indicator node is named check when no group is set, and radio if the
// checkbutton is grouped together with other checkbuttons.
// 
// 
// Accessibility
// 
// `GtkCheckButton` uses the GTK_ACCESSIBLE_ROLE_CHECKBOX role.
	type CheckButton struct {
		Widget
		Accessible
		Actionable
		Buildable
		ConstraintTarget
		
	}

	// CheckButtonClass is an interface that the CheckButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CheckButtonClass interface {
		gextras.Objector
		_checkButton()
	}

	func (CheckButton) _checkButton() {}

	
	func marshalCheckButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCheckButton(obj), nil
	}
	

	
	// NewCheckButton creates a new `GtkCheckButton`.
	func NewCheckButton() CheckButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_check_button_new()


var _checkButton CheckButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkButton = CheckButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkButton
}
	
	// NewCheckButtonWithLabel creates a new `GtkCheckButton` with the given text.
	func NewCheckButtonWithLabel(label string) CheckButton {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_check_button_new_with_label(_arg1)


var _checkButton CheckButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkButton = CheckButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkButton
}
	
	// NewCheckButtonWithMnemonic creates a new `GtkCheckButton` with the given text
// and a mnemonic.
	func NewCheckButtonWithMnemonic(label string) CheckButton {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_check_button_new_with_mnemonic(_arg1)


var _checkButton CheckButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_checkButton = CheckButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _checkButton
}
	

	
	// Active returns whether the check button is active.
	func (s CheckButton) Active() bool {
var _arg0 *C.GtkCheckButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_check_button_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Inconsistent returns whether the check button is in an inconsistent state.
	func (c CheckButton) Inconsistent() bool {
var _arg0 *C.GtkCheckButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(c.Native()))

_cret = C.gtk_check_button_get_inconsistent(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Label returns the label of the check button.
	func (s CheckButton) Label() string {
var _arg0 *C.GtkCheckButton // out
var _cret *C.char // in

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_check_button_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseUnderline returns whether underlines in the label indicate mnemonics.
	func (s CheckButton) UseUnderline() bool {
var _arg0 *C.GtkCheckButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_check_button_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive changes the check buttons active state.
	func (s CheckButton) SetActive(setting bool)  {
var _arg0 *C.GtkCheckButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_check_button_set_active(_arg0, _arg1)
}
	
	// SetGroup adds @self to the group of @group.
// 
// In a group of multiple check buttons, only one button can be active at a
// time. The behavior of a checkbutton in a group is also commonly known as a
// *radio button*.
// 
// Setting the group of a check button also changes the css name of the
// indicator widget's CSS node to 'radio'.
// 
// Setting up groups in a cycle leads to undefined behavior.
// 
// Note that the same effect can be achieved via the [interface@Gtk.Actionable]
// API, by using the same action with parameter type and state type 's' for all
// buttons in the group, and giving each button its own target value.
	func (s CheckButton) SetGroup(group CheckButtonClass)  {
var _arg0 *C.GtkCheckButton // out
var _arg1 *C.GtkCheckButton // out

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkCheckButton)(unsafe.Pointer(group.Native()))

C.gtk_check_button_set_group(_arg0, _arg1)
}
	
	// SetInconsistent sets the `GtkCheckButton` to inconsistent state.
// 
// You shoud turn off the inconsistent state again if the user checks the check
// button. This has to be done manually.
	func (c CheckButton) SetInconsistent(inconsistent bool)  {
var _arg0 *C.GtkCheckButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(c.Native()))
if inconsistent { _arg1 = C.TRUE }

C.gtk_check_button_set_inconsistent(_arg0, _arg1)
}
	
	// SetLabel sets the text of @self.
// 
// If [property@Gtk.CheckButton:use-underline] is true, an underscore in @label
// is interpreted as mnemonic indicator, see
// [method@Gtk.CheckButton.set_use_underline] for details on this behavior.
	func (s CheckButton) SetLabel(label string)  {
var _arg0 *C.GtkCheckButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_check_button_set_label(_arg0, _arg1)
}
	
	// SetUseUnderline sets whether underlines in the label indicate mnemonics.
// 
// If @setting is true, an underscore character in @self's label indicates a
// mnemonic accelerator key. This behavior is similar to
// [property@Gtk.Label:use-underline].
	func (s CheckButton) SetUseUnderline(setting bool)  {
var _arg0 *C.GtkCheckButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkCheckButton)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_check_button_set_use_underline(_arg0, _arg1)
}
	


	// ColorButton: the `GtkColorButton` allows to open a color chooser dialog to
// change the color.
// 
// !An example GtkColorButton (color-button.png)
// 
// It is suitable widget for selecting a color in a preference dialog.
// 
// 
// CSS nodes
// 
// ` colorbutton  button.color  [content] `
// 
// `GtkColorButton` has a single CSS node with name colorbutton which contains a
// button node. To differentiate it from a plain `GtkButton`, it gets the .color
// style class.
	type ColorButton struct {
		Widget
		Accessible
		Buildable
		ColorChooser
		ConstraintTarget
		
	}

	// ColorButtonClass is an interface that the ColorButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorButtonClass interface {
		gextras.Objector
		_colorButton()
	}

	func (ColorButton) _colorButton() {}

	
	func marshalColorButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorButton(obj), nil
	}
	

	
	// NewColorButton creates a new color button.
// 
// This returns a widget in the form of a small button containing a swatch
// representing the current selected color. When the button is clicked, a color
// chooser dialog will open, allowing the user to select a color. The swatch
// will be updated to reflect the new color when the user finishes.
	func NewColorButton() ColorButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_color_button_new()


var _colorButton ColorButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorButton = ColorButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorButton
}
	
	// NewColorButtonWithRGBA creates a new color button showing the given color.
	func NewColorButtonWithRGBA(rgba *gdk.RGBA) ColorButton {
var _arg1 *C.GdkRGBA // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkRGBA)(unsafe.Pointer(rgba.Native()))

_cret = C.gtk_color_button_new_with_rgba(_arg1)


var _colorButton ColorButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorButton = ColorButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorButton
}
	

	
	// Modal gets whether the dialog is modal.
	func (b ColorButton) Modal() bool {
var _arg0 *C.GtkColorButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_color_button_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title gets the title of the color chooser dialog.
	func (b ColorButton) Title() string {
var _arg0 *C.GtkColorButton // out
var _cret *C.char // in

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_color_button_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetModal sets whether the dialog should be modal.
	func (b ColorButton) SetModal(modal bool)  {
var _arg0 *C.GtkColorButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_color_button_set_modal(_arg0, _arg1)
}
	
	// SetTitle sets the title for the color chooser dialog.
	func (b ColorButton) SetTitle(title string)  {
var _arg0 *C.GtkColorButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkColorButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_color_button_set_title(_arg0, _arg1)
}
	


	// ColorChooserDialog: a dialog for choosing a color.
// 
// !An example GtkColorChooserDialog (colorchooser.png)
// 
// `GtkColorChooserDialog` implements the [iface@Gtk.ColorChooser] interface and
// does not provide much API of its own.
// 
// To create a `GtkColorChooserDialog`, use [ctor@Gtk.ColorChooserDialog.new].
// 
// To change the initially selected color, use
// [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
// [method@Gtk.ColorChooser.get_rgba].
	type ColorChooserDialog struct {
		Dialog
		Accessible
		Buildable
		ColorChooser
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// ColorChooserDialogClass is an interface that the ColorChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorChooserDialogClass interface {
		gextras.Objector
		_colorChooserDialog()
	}

	func (ColorChooserDialog) _colorChooserDialog() {}

	
	func marshalColorChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorChooserDialog(obj), nil
	}
	

	
	// NewColorChooserDialog creates a new `GtkColorChooserDialog`.
	func NewColorChooserDialog(title string, parent WindowClass) ColorChooserDialog {
var _arg1 *C.char // out
var _arg2 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_color_chooser_dialog_new(_arg1, _arg2)


var _colorChooserDialog ColorChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorChooserDialog = ColorChooserDialog{
Dialog: Dialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorChooserDialog
}
	

	


	// ColorChooserWidget: the `GtkColorChooserWidget` widget lets the user select a
// color.
// 
// By default, the chooser presents a predefined palette of colors, plus a small
// number of settable custom colors. It is also possible to select a different
// color with the single-color editor.
// 
// To enter the single-color editing mode, use the context menu of any color of
// the palette, or use the '+' button to add a new custom color.
// 
// The chooser automatically remembers the last selection, as well as custom
// colors.
// 
// To create a `GtkColorChooserWidget`, use [ctor@Gtk.ColorChooserWidget.new].
// 
// To change the initially selected color, use
// [method@Gtk.ColorChooser.set_rgba]. To get the selected color use
// [method@Gtk.ColorChooser.get_rgba].
// 
// The `GtkColorChooserWidget` is used in the [class@Gtk.ColorChooserDialog] to
// provide a dialog for selecting colors.
// 
// 
// CSS names
// 
// `GtkColorChooserWidget` has a single CSS node with name colorchooser.
	type ColorChooserWidget struct {
		Widget
		Accessible
		Buildable
		ColorChooser
		ConstraintTarget
		
	}

	// ColorChooserWidgetClass is an interface that the ColorChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColorChooserWidgetClass interface {
		gextras.Objector
		_colorChooserWidget()
	}

	func (ColorChooserWidget) _colorChooserWidget() {}

	
	func marshalColorChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColorChooserWidget(obj), nil
	}
	

	
	// NewColorChooserWidget creates a new `GtkColorChooserWidget`.
	func NewColorChooserWidget() ColorChooserWidget {
var _cret *C.GtkWidget // in

_cret = C.gtk_color_chooser_widget_new()


var _colorChooserWidget ColorChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_colorChooserWidget = ColorChooserWidget{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ColorChooser: ColorChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _colorChooserWidget
}
	

	


	// ColumnView: `GtkColumnView` presents a large dynamic list of items using
// multiple columns with headers.
// 
// `GtkColumnView` uses the factories of its columns to generate a cell widget
// for each column, for each visible item and displays them together as the row
// for this item.
// 
// The [property@Gtk.ColumnView:show-row-separators] and
// [propertyGtk.ColumnView:show-column-separators] properties offer a simple way
// to display separators between the rows or columns.
// 
// `GtkColumnView` allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on *rubberband selection*, using
// [property@Gtk.ColumnView:enable-rubberband].
// 
// The column view supports sorting that can be customized by the user by
// clicking on column headers. To set this up, the `GtkSorter` returned by
// [method@Gtk.ColumnView.get_sorter] must be attached to a sort model for the
// data that the view is showing, and the columns must have sorters attached to
// them by calling [method@Gtk.ColumnViewColumn.set_sorter]. The initial sort
// order can be set with [method@Gtk.ColumnView.sort_by_column].
// 
// The column view also supports interactive resizing and reordering of columns,
// via Drag-and-Drop of the column headers. This can be enabled or disabled with
// the [property@Gtk.ColumnView:reorderable] and
// [property@Gtk.ColumnViewColumn:resizable] properties.
// 
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
// 
// 
// CSS nodes
// 
// `
// columnview[.column-separators][.rich-list][.navigation-sidebar][.data-table]
//  header   <column header>     <column header>   listview  
//  [rubberband] `
// 
// `GtkColumnView` uses a single CSS node named columnview. It may carry the
// .column-separators style class, when
// [property@Gtk.ColumnView:show-column-separators] property is set. Header
// widgets appear below a node with name header. The rows are contained in a
// `GtkListView` widget, so there is a listview node with the same structure as
// for a standalone `GtkListView` widget. If
// [property@Gtk.ColumnView:show-row-separators] is set, it will be passed on to
// the list view, causing its CSS node to carry the .separators style class. For
// rubberband selection, a node with name rubberband is used.
// 
// The main columnview node may also carry style classes to select the style of
// list presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
// 
// 
// Accessibility
// 
// `GtkColumnView` uses the GTK_ACCESSIBLE_ROLE_TREE_GRID role, header title
// widgets are using the GTK_ACCESSIBLE_ROLE_COLUMN_HEADER role. The row widgets
// are using the GTK_ACCESSIBLE_ROLE_ROW role, and individual cells are using
// the GTK_ACCESSIBLE_ROLE_GRID_CELL role
	type ColumnView struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Scrollable
		
	}

	// ColumnViewClass is an interface that the ColumnView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColumnViewClass interface {
		gextras.Objector
		_columnView()
	}

	func (ColumnView) _columnView() {}

	
	func marshalColumnView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColumnView(obj), nil
	}
	

	
	// NewColumnView creates a new `GtkColumnView`.
// 
// You most likely want to call [method@Gtk.ColumnView.append_column] to add
// columns next.
	func NewColumnView(model SelectionModel) ColumnView {
var _arg1 *C.GtkSelectionModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_column_view_new(_arg1)


var _columnView ColumnView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_columnView = ColumnView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _columnView
}
	

	
	// AppendColumn appends the @column to the end of the columns in @self.
	func (s ColumnView) AppendColumn(column ColumnViewColumnClass)  {
var _arg0 *C.GtkColumnView // out
var _arg1 *C.GtkColumnViewColumn // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_column_view_append_column(_arg0, _arg1)
}
	
	// Columns gets the list of columns in this column view.
// 
// This list is constant over the lifetime of @self and can be used to monitor
// changes to the columns of @self by connecting to the ::items-changed signal.
	func (s ColumnView) Columns() gio.ListModel {
var _arg0 *C.GtkColumnView // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_columns(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// EnableRubberband returns whether rows can be selected by dragging with the
// mouse.
	func (s ColumnView) EnableRubberband() bool {
var _arg0 *C.GtkColumnView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_enable_rubberband(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Model gets the model that's currently used to read the items displayed.
	func (s ColumnView) Model() SelectionModel {
var _arg0 *C.GtkColumnView // out
var _cret *C.GtkSelectionModel // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_model(_arg0)


var _selectionModel SelectionModel // out

_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

return _selectionModel
}
	
	// Reorderable returns whether columns are reorderable.
	func (s ColumnView) Reorderable() bool {
var _arg0 *C.GtkColumnView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_reorderable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowColumnSeparators returns whether the list should show separators between
// columns.
	func (s ColumnView) ShowColumnSeparators() bool {
var _arg0 *C.GtkColumnView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_show_column_separators(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowRowSeparators returns whether the list should show separators between
// rows.
	func (s ColumnView) ShowRowSeparators() bool {
var _arg0 *C.GtkColumnView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_show_row_separators(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SingleClickActivate returns whether rows will be activated on single click
// and selected on hover.
	func (s ColumnView) SingleClickActivate() bool {
var _arg0 *C.GtkColumnView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_single_click_activate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Sorter returns a special sorter that reflects the users sorting choices in
// the column view.
// 
// To allow users to customizable sorting by clicking on column headers, this
// sorter needs to be set on the sort model underneath the model that is
// displayed by the view.
// 
// See [method@Gtk.ColumnViewColumn.set_sorter] for setting up per-column
// sorting.
// 
// Here is an example: `c gtk_column_view_column_set_sorter (column, sorter);
// gtk_column_view_append_column (view, column); sorter = g_object_ref
// (gtk_column_view_get_sorter (view))); model = gtk_sort_list_model_new (store,
// sorter); selection = gtk_no_selection_new (model); gtk_column_view_set_model
// (view, selection); `
	func (s ColumnView) Sorter() Sorter {
var _arg0 *C.GtkColumnView // out
var _cret *C.GtkSorter // in

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_get_sorter(_arg0)


var _sorter Sorter // out

_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

return _sorter
}
	
	// InsertColumn inserts a column at the given position in the columns of @self.
// 
// If @column is already a column of @self, it will be repositioned.
	func (s ColumnView) InsertColumn(position uint, column ColumnViewColumnClass)  {
var _arg0 *C.GtkColumnView // out
var _arg1 C.guint // out
var _arg2 *C.GtkColumnViewColumn // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)
_arg2 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_column_view_insert_column(_arg0, _arg1, _arg2)
}
	
	// RemoveColumn removes the @column from the list of columns of @self.
	func (s ColumnView) RemoveColumn(column ColumnViewColumnClass)  {
var _arg0 *C.GtkColumnView // out
var _arg1 *C.GtkColumnViewColumn // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_column_view_remove_column(_arg0, _arg1)
}
	
	// SetEnableRubberband sets whether selections can be changed by dragging with
// the mouse.
	func (s ColumnView) SetEnableRubberband(enableRubberband bool)  {
var _arg0 *C.GtkColumnView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
if enableRubberband { _arg1 = C.TRUE }

C.gtk_column_view_set_enable_rubberband(_arg0, _arg1)
}
	
	// SetModel sets the model to use.
// 
// This must be a [iface@Gtk.SelectionModel].
	func (s ColumnView) SetModel(model SelectionModel)  {
var _arg0 *C.GtkColumnView // out
var _arg1 *C.GtkSelectionModel // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

C.gtk_column_view_set_model(_arg0, _arg1)
}
	
	// SetReorderable sets whether columns should be reorderable by dragging.
	func (s ColumnView) SetReorderable(reorderable bool)  {
var _arg0 *C.GtkColumnView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
if reorderable { _arg1 = C.TRUE }

C.gtk_column_view_set_reorderable(_arg0, _arg1)
}
	
	// SetShowColumnSeparators sets whether the list should show separators between
// columns.
	func (s ColumnView) SetShowColumnSeparators(showColumnSeparators bool)  {
var _arg0 *C.GtkColumnView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
if showColumnSeparators { _arg1 = C.TRUE }

C.gtk_column_view_set_show_column_separators(_arg0, _arg1)
}
	
	// SetShowRowSeparators sets whether the list should show separators between
// rows.
	func (s ColumnView) SetShowRowSeparators(showRowSeparators bool)  {
var _arg0 *C.GtkColumnView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
if showRowSeparators { _arg1 = C.TRUE }

C.gtk_column_view_set_show_row_separators(_arg0, _arg1)
}
	
	// SetSingleClickActivate sets whether rows should be activated on single click
// and selected on hover.
	func (s ColumnView) SetSingleClickActivate(singleClickActivate bool)  {
var _arg0 *C.GtkColumnView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
if singleClickActivate { _arg1 = C.TRUE }

C.gtk_column_view_set_single_click_activate(_arg0, _arg1)
}
	
	// SortByColumn sets the sorting of the view.
// 
// This function should be used to set up the initial sorting. At runtime, users
// can change the sorting of a column view by clicking on the list headers.
// 
// This call only has an effect if the sorter returned by
// [method@Gtk.ColumnView.get_sorter] is set on a sort model, and
// [method@Gtk.ColumnViewColumn.set_sorter] has been called on @column to
// associate a sorter with the column.
// 
// If @column is nil, the view will be unsorted.
	func (s ColumnView) SortByColumn(column ColumnViewColumnClass, direction SortType)  {
var _arg0 *C.GtkColumnView // out
var _arg1 *C.GtkColumnViewColumn // out
var _arg2 C.GtkSortType // out

_arg0 = (*C.GtkColumnView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkColumnViewColumn)(unsafe.Pointer(column.Native()))
_arg2 = (C.GtkSortType)(direction)

C.gtk_column_view_sort_by_column(_arg0, _arg1, _arg2)
}
	


	// ColumnViewColumn: `GtkColumnViewColumn` represents the columns being added to
// `GtkColumnView`.
// 
// The main ingredient for a `GtkColumnViewColumn` is the `GtkListItemFactory`
// that tells the columnview how to create cells for this column from items in
// the model.
// 
// Columns have a title, and can optionally have a header menu set with
// [method@Gtk.ColumnViewColumn.set_header_menu].
// 
// A sorter can be associated with a column using
// [method@Gtk.ColumnViewColumn.set_sorter], to let users influence sorting by
// clicking on the column header.
	type ColumnViewColumn struct {
		**externglib.Object
		
	}

	// ColumnViewColumnClass is an interface that the ColumnViewColumn class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ColumnViewColumnClass interface {
		gextras.Objector
		_columnViewColumn()
	}

	func (ColumnViewColumn) _columnViewColumn() {}

	
	func marshalColumnViewColumn(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapColumnViewColumn(obj), nil
	}
	

	
	// NewColumnViewColumn creates a new `GtkColumnViewColumn` that uses the given
// @factory for mapping items to widgets.
// 
// You most likely want to call [method@Gtk.ColumnView.append_column] next.
// 
// The function takes ownership of the argument, so you can write code like:
// 
// `c column = gtk_column_view_column_new (_("Name"),
// gtk_builder_list_item_factory_new_from_resource ("/name.ui")); `
	func NewColumnViewColumn(title string, factory ListItemFactoryClass) ColumnViewColumn {
var _arg1 *C.char // out
var _arg2 *C.GtkListItemFactory // out
var _cret *C.GtkColumnViewColumn // in

_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

_cret = C.gtk_column_view_column_new(_arg1, _arg2)


var _columnViewColumn ColumnViewColumn // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_columnViewColumn = ColumnViewColumn{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _columnViewColumn
}
	

	
	// ColumnView gets the column view that's currently displaying this column.
// 
// If @self has not been added to a column view yet, nil is returned.
	func (s ColumnViewColumn) ColumnView() ColumnView {
var _arg0 *C.GtkColumnViewColumn // out
var _cret *C.GtkColumnView // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_column_view(_arg0)


var _columnView ColumnView // out

_columnView = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ColumnView)

return _columnView
}
	
	// Expand returns whether this column should expand.
	func (s ColumnViewColumn) Expand() bool {
var _arg0 *C.GtkColumnViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_expand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Factory gets the factory that's currently used to populate list items for
// this column.
	func (s ColumnViewColumn) Factory() ListItemFactory {
var _arg0 *C.GtkColumnViewColumn // out
var _cret *C.GtkListItemFactory // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_factory(_arg0)


var _listItemFactory ListItemFactory // out

_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

return _listItemFactory
}
	
	// FixedWidth gets the fixed width of the column.
	func (s ColumnViewColumn) FixedWidth() int {
var _arg0 *C.GtkColumnViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_fixed_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// HeaderMenu gets the menu model that is used to create the context menu for
// the column header.
	func (s ColumnViewColumn) HeaderMenu() gio.MenuModel {
var _arg0 *C.GtkColumnViewColumn // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_header_menu(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// Resizable returns whether this column is resizable.
	func (s ColumnViewColumn) Resizable() bool {
var _arg0 *C.GtkColumnViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_resizable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Sorter returns the sorter that is associated with the column.
	func (s ColumnViewColumn) Sorter() Sorter {
var _arg0 *C.GtkColumnViewColumn // out
var _cret *C.GtkSorter // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_sorter(_arg0)


var _sorter Sorter // out

_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

return _sorter
}
	
	// Title returns the title set with gtk_column_view_column_set_title().
	func (s ColumnViewColumn) Title() string {
var _arg0 *C.GtkColumnViewColumn // out
var _cret *C.char // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Visible returns whether this column is visible.
	func (s ColumnViewColumn) Visible() bool {
var _arg0 *C.GtkColumnViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))

_cret = C.gtk_column_view_column_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetExpand sets the column to take available extra space.
// 
// The extra space is shared equally amongst all columns that have the expand
// set to true.
	func (s ColumnViewColumn) SetExpand(expand bool)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_column_view_column_set_expand(_arg0, _arg1)
}
	
	// SetFactory sets the `GtkListItemFactory` to use for populating list items for
// this column.
	func (s ColumnViewColumn) SetFactory(factory ListItemFactoryClass)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 *C.GtkListItemFactory // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

C.gtk_column_view_column_set_factory(_arg0, _arg1)
}
	
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of @column;
// otherwise unsets it.
// 
// Setting a fixed width overrides the automatically calculated width.
// Interactive resizing also sets the fixed-width property.
	func (s ColumnViewColumn) SetFixedWidth(fixedWidth int)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 C.int // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(fixedWidth)

C.gtk_column_view_column_set_fixed_width(_arg0, _arg1)
}
	
	// SetHeaderMenu sets the menu model that is used to create the context menu for
// the column header.
	func (s ColumnViewColumn) SetHeaderMenu(menu gio.MenuModelClass)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(menu.Native()))

C.gtk_column_view_column_set_header_menu(_arg0, _arg1)
}
	
	// SetResizable sets whether this column should be resizable by dragging.
	func (s ColumnViewColumn) SetResizable(resizable bool)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
if resizable { _arg1 = C.TRUE }

C.gtk_column_view_column_set_resizable(_arg0, _arg1)
}
	
	// SetSorter associates a sorter with the column.
// 
// If @sorter is nil, the column will not let users change the sorting by
// clicking on its header.
// 
// This sorter can be made active by clicking on the column header, or by
// calling [method@Gtk.ColumnView.sort_by_column].
// 
// See [method@Gtk.ColumnView.get_sorter] for the necessary steps for setting up
// customizable sorting for [class@Gtk.ColumnView].
	func (s ColumnViewColumn) SetSorter(sorter SorterClass)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 *C.GtkSorter // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

C.gtk_column_view_column_set_sorter(_arg0, _arg1)
}
	
	// SetTitle sets the title of this column.
// 
// The title is displayed in the header of a `GtkColumnView` for this column and
// is therefore user-facing text that should be translated.
	func (s ColumnViewColumn) SetTitle(title string)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 *C.char // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_column_view_column_set_title(_arg0, _arg1)
}
	
	// SetVisible sets whether this column should be visible in views.
	func (s ColumnViewColumn) SetVisible(visible bool)  {
var _arg0 *C.GtkColumnViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkColumnViewColumn)(unsafe.Pointer(s.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_column_view_column_set_visible(_arg0, _arg1)
}
	


	// ComboBox: a `GtkComboBox` is a widget that allows the user to choose from a
// list of valid choices.
// 
// !An example GtkComboBox (combo-box.png)
// 
// The `GtkComboBox` displays the selected choice; when activated, the
// `GtkComboBox` displays a popup which allows the user to make a new choice.
// 
// The `GtkComboBox` uses the model-view pattern; the list of valid choices is
// specified in the form of a tree model, and the display of the choices can be
// adapted to the data in the model by using cell renderers, as you would in a
// tree view. This is possible since `GtkComboBox` implements the
// [interface@Gtk.CellLayout] interface. The tree model holding the valid
// choices is not restricted to a flat list, it can be a real tree, and the
// popup will reflect the tree structure.
// 
// To allow the user to enter values not in the model, the
// [property@Gtk.ComboBox:has-entry] property allows the `GtkComboBox` to
// contain a [class@Gtk.Entry]. This entry can be accessed by calling
// [method@Gtk.ComboBox.get_child] on the combo box.
// 
// For a simple list of textual choices, the model-view API of `GtkComboBox` can
// be a bit overwhelming. In this case, [class@Gtk.ComboBoxText] offers a simple
// alternative. Both `GtkComboBox` and `GtkComboBoxText` can contain an entry.
// 
// 
// CSS nodes
// 
// ` combobox  box.linked   button.combo   box   cellview  
// arrow  window.popup `
// 
// A normal combobox contains a box with the .linked class, a button with the
// .combo class and inside those buttons, there are a cellview and an arrow.
// 
// ` combobox  box.linked   entry.combo   button.combo   box 
//  arrow  window.popup `
// 
// A `GtkComboBox` with an entry has a single CSS node with name combobox. It
// contains a box with the .linked class. That box contains an entry and a
// button, both with the .combo class added. The button also contains another
// node with name arrow.
// 
// 
// Accessibility
// 
// `GtkComboBox` uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
	type ComboBox struct {
		Widget
		Accessible
		Buildable
		CellEditable
		CellLayout
		ConstraintTarget
		
	}

	// ComboBoxClass is an interface that the ComboBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ComboBoxClass interface {
		gextras.Objector
		_comboBox()
	}

	func (ComboBox) _comboBox() {}

	
	func marshalComboBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapComboBox(obj), nil
	}
	

	
	// NewComboBox creates a new empty `GtkComboBox`.
	func NewComboBox() ComboBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_new()


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithEntry creates a new empty `GtkComboBox` with an entry.
	func NewComboBoxWithEntry() ComboBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_new_with_entry()


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithModel creates a new `GtkComboBox` with a model.
	func NewComboBoxWithModel(model TreeModel) ComboBox {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_combo_box_new_with_model(_arg1)


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	
	// NewComboBoxWithModelAndEntry creates a new empty `GtkComboBox` with an entry
// and a model.
	func NewComboBoxWithModelAndEntry(model TreeModel) ComboBox {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_combo_box_new_with_model_and_entry(_arg1)


var _comboBox ComboBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBox = ComboBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBox
}
	

	
	// Active returns the index of the currently active item.
// 
// If the model is a non-flat treemodel, and the active item is not an immediate
// child of the root of the tree, this function returns
// `gtk_tree_path_get_indices (path)[0]`, where `path` is the
// [struct@Gtk.TreePath] of the active item.
	func (c ComboBox) Active() int {
var _arg0 *C.GtkComboBox // out
var _cret C.int // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_active(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ActiveID returns the ID of the active row of @combo_box.
// 
// This value is taken from the active row and the column specified by the
// [property@Gtk.ComboBox:id-column] property of @combo_box (see
// [method@Gtk.ComboBox.set_id_column]).
// 
// The returned value is an interned string which means that you can compare the
// pointer by value to other interned strings and that you must not free it.
// 
// If the [property@Gtk.ComboBox:id-column] property of @combo_box is not set,
// or if no row is active, or if the active row has a nil ID value, then nil is
// returned.
	func (c ComboBox) ActiveID() string {
var _arg0 *C.GtkComboBox // out
var _cret *C.char // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_active_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ActiveIter sets @iter to point to the currently active item.
// 
// If no item is active, @iter is left unchanged.
	func (c ComboBox) ActiveIter() (TreeIter, bool) {
var _arg0 *C.GtkComboBox // out
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_active_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// ButtonSensitivity returns whether the combo box sets the dropdown button
// sensitive or not when there are no items in the model.
	func (c ComboBox) ButtonSensitivity() SensitivityType {
var _arg0 *C.GtkComboBox // out
var _cret C.GtkSensitivityType // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_button_sensitivity(_arg0)


var _sensitivityType SensitivityType // out

_sensitivityType = SensitivityType(_cret)

return _sensitivityType
}
	
	// Child gets the child widget of @combo_box.
	func (c ComboBox) Child() Widget {
var _arg0 *C.GtkComboBox // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// EntryTextColumn returns the column which @combo_box is using to get the
// strings from to display in the internal entry.
	func (c ComboBox) EntryTextColumn() int {
var _arg0 *C.GtkComboBox // out
var _cret C.int // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_entry_text_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// HasEntry returns whether the combo box has an entry.
	func (c ComboBox) HasEntry() bool {
var _arg0 *C.GtkComboBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_has_entry(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IDColumn returns the column which @combo_box is using to get string IDs for
// values from.
	func (c ComboBox) IDColumn() int {
var _arg0 *C.GtkComboBox // out
var _cret C.int // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_id_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the `GtkTreeModel` of @combo_box.
	func (c ComboBox) Model() TreeModel {
var _arg0 *C.GtkComboBox // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// PopupFixedWidth gets whether the popup uses a fixed width.
	func (c ComboBox) PopupFixedWidth() bool {
var _arg0 *C.GtkComboBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_get_popup_fixed_width(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Popdown hides the menu or dropdown list of @combo_box.
// 
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
	func (c ComboBox) Popdown()  {
var _arg0 *C.GtkComboBox // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

C.gtk_combo_box_popdown(_arg0)
}
	
	// Popup pops up the menu or dropdown list of @combo_box.
// 
// This function is mostly intended for use by accessibility technologies;
// applications should have little use for it.
// 
// Before calling this, @combo_box must be mapped, or nothing will happen.
	func (c ComboBox) Popup()  {
var _arg0 *C.GtkComboBox // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))

C.gtk_combo_box_popup(_arg0)
}
	
	// PopupForDevice pops up the menu of @combo_box.
// 
// Note that currently this does not do anything with the device, as it was
// previously only used for list-mode combo boxes, and those were removed in GTK
// 4. However, it is retained in case similar functionality is added back later.
	func (c ComboBox) PopupForDevice(device gdk.DeviceClass)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.GdkDevice // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))

C.gtk_combo_box_popup_for_device(_arg0, _arg1)
}
	
	// SetActive sets the active item of @combo_box to be the item at @index.
	func (c ComboBox) SetActive(index_ int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.int // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(index_)

C.gtk_combo_box_set_active(_arg0, _arg1)
}
	
	// SetActiveID changes the active row of @combo_box to the one that has an ID
// equal to @active_id.
// 
// If @active_id is nil, the active row is unset. Rows having a nil ID string
// cannot be made active by this function.
// 
// If the [property@Gtk.ComboBox:id-column] property of @combo_box is unset or
// if no row has the given ID then the function does nothing and returns false.
	func (c ComboBox) SetActiveID(activeId string) bool {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(activeId))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_combo_box_set_active_id(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActiveIter sets the current active item to be the one referenced by @iter.
// 
// If @iter is nil, the active item is unset.
	func (c ComboBox) SetActiveIter(iter *TreeIter)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_combo_box_set_active_iter(_arg0, _arg1)
}
	
	// SetButtonSensitivity sets whether the dropdown button of the combo box should
// update its sensitivity depending on the model contents.
	func (c ComboBox) SetButtonSensitivity(sensitivity SensitivityType)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.GtkSensitivityType // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkSensitivityType)(sensitivity)

C.gtk_combo_box_set_button_sensitivity(_arg0, _arg1)
}
	
	// SetChild sets the child widget of @combo_box.
	func (c ComboBox) SetChild(child WidgetClass)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_combo_box_set_child(_arg0, _arg1)
}
	
	// SetEntryTextColumn sets the model column which @combo_box should use to get
// strings from to be @text_column.
// 
// The column @text_column in the model of @combo_box must be of type
// G_TYPE_STRING.
// 
// This is only relevant if @combo_box has been created with
// [property@Gtk.ComboBox:has-entry] as true.
	func (c ComboBox) SetEntryTextColumn(textColumn int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.int // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(textColumn)

C.gtk_combo_box_set_entry_text_column(_arg0, _arg1)
}
	
	// SetIDColumn sets the model column which @combo_box should use to get string
// IDs for values from.
// 
// The column @id_column in the model of @combo_box must be of type
// G_TYPE_STRING.
	func (c ComboBox) SetIDColumn(idColumn int)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.int // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(idColumn)

C.gtk_combo_box_set_id_column(_arg0, _arg1)
}
	
	// SetModel sets the model used by @combo_box to be @model.
// 
// Will unset a previously set model (if applicable). If model is nil, then it
// will unset the model.
// 
// Note that this function does not clear the cell renderers, you have to call
// [method@Gtk.CellLayout.clear] yourself if you need to set up different cell
// renderers for the new model.
	func (c ComboBox) SetModel(model TreeModel)  {
var _arg0 *C.GtkComboBox // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_combo_box_set_model(_arg0, _arg1)
}
	
	// SetPopupFixedWidth specifies whether the popups width should be a fixed
// width.
// 
// If @fixed is true, the popup's width is set to match the allocated width of
// the combo box.
	func (c ComboBox) SetPopupFixedWidth(fixed bool)  {
var _arg0 *C.GtkComboBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkComboBox)(unsafe.Pointer(c.Native()))
if fixed { _arg1 = C.TRUE }

C.gtk_combo_box_set_popup_fixed_width(_arg0, _arg1)
}
	


	// ComboBoxText: a `GtkComboBoxText` is a simple variant of `GtkComboBox` for
// text-only use cases.
// 
// !An example GtkComboBoxText (combo-box-text.png)
// 
// `GtkComboBoxText` hides the model-view complexity of `GtkComboBox`.
// 
// To create a `GtkComboBoxText`, use [ctor@Gtk.ComboBoxText.new] or
// [ctor@Gtk.ComboBoxText.new_with_entry].
// 
// You can add items to a `GtkComboBoxText` with
// [method@Gtk.ComboBoxText.append_text], [method@Gtk.ComboBoxText.insert_text]
// or [method@Gtk.ComboBoxText.prepend_text] and remove options with
// [method@Gtk.ComboBoxText.remove].
// 
// If the `GtkComboBoxText` contains an entry (via the
// [property@Gtk.ComboBox:has-entry] property), its contents can be retrieved
// using [method@Gtk.ComboBoxText.get_active_text].
// 
// You should not call [method@Gtk.ComboBox.set_model] or attempt to pack more
// cells into this combo box via its [interface@Gtk.CellLayout] interface.
// 
// 
// GtkComboBoxText as GtkBuildable
// 
// The `GtkComboBoxText` implementation of the `GtkBuildable` interface supports
// adding items directly using the <items> element and specifying <item>
// elements for each item. Each <item> element can specify the id
// corresponding to the appended text and also supports the regular translation
// attributes translatable, context and comments.
// 
// Here is a UI definition fragment specifying `GtkComboBoxText` items: `xml
// <object class="GtkComboBoxText"> <items> <item translatable="yes"
// id="factory">Factory</item> <item translatable="yes" id="home">Home</item>
// <item translatable="yes" id="subway">Subway</item> </items> </object> `
// 
// 
// CSS nodes
// 
// ` combobox  box.linked  entry.combo  button.combo  window.popup
// `
// 
// `GtkComboBoxText` has a single CSS node with name combobox. It adds the style
// class .combo to the main CSS nodes of its entry and button children, and the
// .linked class to the node of its internal box.
	type ComboBoxText struct {
		ComboBox
		Accessible
		Buildable
		CellEditable
		CellLayout
		ConstraintTarget
		
	}

	// ComboBoxTextClass is an interface that the ComboBoxText class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ComboBoxTextClass interface {
		gextras.Objector
		_comboBoxText()
	}

	func (ComboBoxText) _comboBoxText() {}

	
	func marshalComboBoxText(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapComboBoxText(obj), nil
	}
	

	
	// NewComboBoxText creates a new `GtkComboBoxText`.
	func NewComboBoxText() ComboBoxText {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_text_new()


var _comboBoxText ComboBoxText // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBoxText = ComboBoxText{
ComboBox: ComboBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBoxText
}
	
	// NewComboBoxTextWithEntry creates a new `GtkComboBoxText` with an entry.
	func NewComboBoxTextWithEntry() ComboBoxText {
var _cret *C.GtkWidget // in

_cret = C.gtk_combo_box_text_new_with_entry()


var _comboBoxText ComboBoxText // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_comboBoxText = ComboBoxText{
ComboBox: ComboBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _comboBoxText
}
	

	
	// Append appends @text to the list of strings stored in @combo_box.
// 
// If @id is non-nil then it is used as the ID of the row.
// 
// This is the same as calling [method@Gtk.ComboBoxText.insert] with a position
// of -1.
	func (c ComboBoxText) Append(id string, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_combo_box_text_append(_arg0, _arg1, _arg2)
}
	
	// AppendText appends @text to the list of strings stored in @combo_box.
// 
// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
// position of -1.
	func (c ComboBoxText) AppendText(text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.char // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_combo_box_text_append_text(_arg0, _arg1)
}
	
	// ActiveText returns the currently active string in @combo_box.
// 
// If no row is currently selected, nil is returned. If @combo_box contains an
// entry, this function will return its contents (which will not necessarily be
// an item from the list).
	func (c ComboBoxText) ActiveText() string {
var _arg0 *C.GtkComboBoxText // out
var _cret *C.char // in

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

_cret = C.gtk_combo_box_text_get_active_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Insert inserts @text at @position in the list of strings stored in
// @combo_box.
// 
// If @id is non-nil then it is used as the ID of the row. See
// [property@Gtk.ComboBox:id-column].
// 
// If @position is negative then @text is appended.
	func (c ComboBoxText) Insert(position int, id string, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 C.int // out
var _arg2 *C.char // out
var _arg3 *C.char // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(position)
_arg2 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_combo_box_text_insert(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertText inserts @text at @position in the list of strings stored in
// @combo_box.
// 
// If @position is negative then @text is appended.
// 
// This is the same as calling [method@Gtk.ComboBoxText.insert] with a nil ID
// string.
	func (c ComboBoxText) InsertText(position int, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 C.int // out
var _arg2 *C.char // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(position)
_arg2 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_combo_box_text_insert_text(_arg0, _arg1, _arg2)
}
	
	// Prepend prepends @text to the list of strings stored in @combo_box.
// 
// If @id is non-nil then it is used as the ID of the row.
// 
// This is the same as calling [method@Gtk.ComboBoxText.insert] with a position
// of 0.
	func (c ComboBoxText) Prepend(id string, text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_combo_box_text_prepend(_arg0, _arg1, _arg2)
}
	
	// PrependText prepends @text to the list of strings stored in @combo_box.
// 
// This is the same as calling [method@Gtk.ComboBoxText.insert_text] with a
// position of 0.
	func (c ComboBoxText) PrependText(text string)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 *C.char // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_combo_box_text_prepend_text(_arg0, _arg1)
}
	
	// Remove removes the string at @position from @combo_box.
	func (c ComboBoxText) Remove(position int)  {
var _arg0 *C.GtkComboBoxText // out
var _arg1 C.int // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(position)

C.gtk_combo_box_text_remove(_arg0, _arg1)
}
	
	// RemoveAll removes all the text entries from the combo box.
	func (c ComboBoxText) RemoveAll()  {
var _arg0 *C.GtkComboBoxText // out

_arg0 = (*C.GtkComboBoxText)(unsafe.Pointer(c.Native()))

C.gtk_combo_box_text_remove_all(_arg0)
}
	


	// Constraint: `GtkConstraint` describes a constraint between attributes of two
// widgets, expressed as a linear equation.
// 
// The typical equation for a constraint is:
// 
// ` target.target_attr = source.source_attr  multiplier + constant `
// 
// Each `GtkConstraint` is part of a system that will be solved by a
// [class@Gtk.ConstraintLayout] in order to allocate and position each child
// widget or guide.
// 
// The source and target, as well as their attributes, of a `GtkConstraint`
// instance are immutable after creation.
	type Constraint struct {
		**externglib.Object
		
	}

	// ConstraintClass is an interface that the Constraint class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ConstraintClass interface {
		gextras.Objector
		_constraint()
	}

	func (Constraint) _constraint() {}

	
	func marshalConstraint(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapConstraint(obj), nil
	}
	

	
	// NewConstraint creates a new constraint representing a relation between a
// layout attribute on a source and a layout attribute on a target.
	func NewConstraint(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, source ConstraintTarget, sourceAttribute ConstraintAttribute, multiplier float64, constant float64, strength int) Constraint {
var _arg1 C.gpointer // out
var _arg2 C.GtkConstraintAttribute // out
var _arg3 C.GtkConstraintRelation // out
var _arg4 C.gpointer // out
var _arg5 C.GtkConstraintAttribute // out
var _arg6 C.double // out
var _arg7 C.double // out
var _arg8 C.int // out
var _cret *C.GtkConstraint // in

_arg1 = (C.gpointer)(unsafe.Pointer(target.Native()))
_arg2 = (C.GtkConstraintAttribute)(targetAttribute)
_arg3 = (C.GtkConstraintRelation)(relation)
_arg4 = (C.gpointer)(unsafe.Pointer(source.Native()))
_arg5 = (C.GtkConstraintAttribute)(sourceAttribute)
_arg6 = (C.double)(multiplier)
_arg7 = (C.double)(constant)
_arg8 = (C.int)(strength)

_cret = C.gtk_constraint_new(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)


var _constraint Constraint // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_constraint = Constraint{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _constraint
}
	
	// NewConstraintConstant creates a new constraint representing a relation
// between a layout attribute on a target and a constant value.
	func NewConstraintConstant(target ConstraintTarget, targetAttribute ConstraintAttribute, relation ConstraintRelation, constant float64, strength int) Constraint {
var _arg1 C.gpointer // out
var _arg2 C.GtkConstraintAttribute // out
var _arg3 C.GtkConstraintRelation // out
var _arg4 C.double // out
var _arg5 C.int // out
var _cret *C.GtkConstraint // in

_arg1 = (C.gpointer)(unsafe.Pointer(target.Native()))
_arg2 = (C.GtkConstraintAttribute)(targetAttribute)
_arg3 = (C.GtkConstraintRelation)(relation)
_arg4 = (C.double)(constant)
_arg5 = (C.int)(strength)

_cret = C.gtk_constraint_new_constant(_arg1, _arg2, _arg3, _arg4, _arg5)


var _constraint Constraint // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_constraint = Constraint{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _constraint
}
	

	
	// Constant retrieves the constant factor added to the source attributes' value.
	func (c Constraint) Constant() float64 {
var _arg0 *C.GtkConstraint // out
var _cret C.double // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_constant(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Multiplier retrieves the multiplication factor applied to the source
// attribute's value.
	func (c Constraint) Multiplier() float64 {
var _arg0 *C.GtkConstraint // out
var _cret C.double // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_multiplier(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Relation: the order relation between the terms of the constraint.
	func (c Constraint) Relation() ConstraintRelation {
var _arg0 *C.GtkConstraint // out
var _cret C.GtkConstraintRelation // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_relation(_arg0)


var _constraintRelation ConstraintRelation // out

_constraintRelation = ConstraintRelation(_cret)

return _constraintRelation
}
	
	// Source retrieves the [iface@Gtk.ConstraintTarget] used as the source for the
// constraint.
// 
// If the source is set to `NULL` at creation, the constraint will use the
// widget using the [class@Gtk.ConstraintLayout] as the source.
	func (c Constraint) Source() ConstraintTarget {
var _arg0 *C.GtkConstraint // out
var _cret *C.GtkConstraintTarget // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_source(_arg0)


var _constraintTarget ConstraintTarget // out

_constraintTarget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ConstraintTarget)

return _constraintTarget
}
	
	// SourceAttribute retrieves the attribute of the source to be read by the
// constraint.
	func (c Constraint) SourceAttribute() ConstraintAttribute {
var _arg0 *C.GtkConstraint // out
var _cret C.GtkConstraintAttribute // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_source_attribute(_arg0)


var _constraintAttribute ConstraintAttribute // out

_constraintAttribute = ConstraintAttribute(_cret)

return _constraintAttribute
}
	
	// Strength retrieves the strength of the constraint.
	func (c Constraint) Strength() int {
var _arg0 *C.GtkConstraint // out
var _cret C.int // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_strength(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Target retrieves the [iface@Gtk.ConstraintTarget] used as the target for the
// constraint.
// 
// If the targe is set to `NULL` at creation, the constraint will use the widget
// using the [class@Gtk.ConstraintLayout] as the target.
	func (c Constraint) Target() ConstraintTarget {
var _arg0 *C.GtkConstraint // out
var _cret *C.GtkConstraintTarget // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_target(_arg0)


var _constraintTarget ConstraintTarget // out

_constraintTarget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ConstraintTarget)

return _constraintTarget
}
	
	// TargetAttribute retrieves the attribute of the target to be set by the
// constraint.
	func (c Constraint) TargetAttribute() ConstraintAttribute {
var _arg0 *C.GtkConstraint // out
var _cret C.GtkConstraintAttribute // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_get_target_attribute(_arg0)


var _constraintAttribute ConstraintAttribute // out

_constraintAttribute = ConstraintAttribute(_cret)

return _constraintAttribute
}
	
	// IsAttached checks whether the constraint is attached to a
// [class@Gtk.ConstraintLayout], and it is contributing to the layout.
	func (c Constraint) IsAttached() bool {
var _arg0 *C.GtkConstraint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_is_attached(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsConstant checks whether the constraint describes a relation between an
// attribute on the [property@Gtk.Constraint:target] and a constant value.
	func (c Constraint) IsConstant() bool {
var _arg0 *C.GtkConstraint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_is_constant(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsRequired checks whether the constraint is a required relation for solving
// the constraint layout.
	func (c Constraint) IsRequired() bool {
var _arg0 *C.GtkConstraint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkConstraint)(unsafe.Pointer(c.Native()))

_cret = C.gtk_constraint_is_required(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// ConstraintGuide: a `GtkConstraintGuide` is an invisible layout element in a
// `GtkConstraintLayout`.
// 
// The `GtkConstraintLayout` treats guides like widgets. They can be used as the
// source or target of a `GtkConstraint`.
// 
// Guides have a minimum, maximum and natural size. Depending on the constraints
// that are applied, they can act like a guideline that widgets can be aligned
// to, or like *flexible space*.
// 
// Unlike a `GtkWidget`, a `GtkConstraintGuide` will not be drawn.
	type ConstraintGuide struct {
		**externglib.Object
		ConstraintTarget
		
	}

	// ConstraintGuideClass is an interface that the ConstraintGuide class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ConstraintGuideClass interface {
		gextras.Objector
		_constraintGuide()
	}

	func (ConstraintGuide) _constraintGuide() {}

	
	func marshalConstraintGuide(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapConstraintGuide(obj), nil
	}
	

	
	// NewConstraintGuide creates a new `GtkConstraintGuide` object.
	func NewConstraintGuide() ConstraintGuide {
var _cret *C.GtkConstraintGuide // in

_cret = C.gtk_constraint_guide_new()


var _constraintGuide ConstraintGuide // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_constraintGuide = ConstraintGuide{
Object: &externglib.Object{externglib.ToGObject(obj)},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _constraintGuide
}
	

	
	// MaxSize gets the maximum size of @guide.
	func (g ConstraintGuide) MaxSize(width *int, height *int)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 *C.int // out
var _arg2 *C.int // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (*C.int)(unsafe.Pointer(width))
_arg2 = (*C.int)(unsafe.Pointer(height))

C.gtk_constraint_guide_get_max_size(_arg0, _arg1, _arg2)
}
	
	// MinSize gets the minimum size of @guide.
	func (g ConstraintGuide) MinSize(width *int, height *int)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 *C.int // out
var _arg2 *C.int // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (*C.int)(unsafe.Pointer(width))
_arg2 = (*C.int)(unsafe.Pointer(height))

C.gtk_constraint_guide_get_min_size(_arg0, _arg1, _arg2)
}
	
	// Name retrieves the name set using gtk_constraint_guide_set_name().
	func (g ConstraintGuide) Name() string {
var _arg0 *C.GtkConstraintGuide // out
var _cret *C.char // in

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))

_cret = C.gtk_constraint_guide_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NatSize gets the natural size of @guide.
	func (g ConstraintGuide) NatSize(width *int, height *int)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 *C.int // out
var _arg2 *C.int // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (*C.int)(unsafe.Pointer(width))
_arg2 = (*C.int)(unsafe.Pointer(height))

C.gtk_constraint_guide_get_nat_size(_arg0, _arg1, _arg2)
}
	
	// Strength retrieves the strength set using
// gtk_constraint_guide_set_strength().
	func (g ConstraintGuide) Strength() ConstraintStrength {
var _arg0 *C.GtkConstraintGuide // out
var _cret C.GtkConstraintStrength // in

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))

_cret = C.gtk_constraint_guide_get_strength(_arg0)


var _constraintStrength ConstraintStrength // out

_constraintStrength = ConstraintStrength(_cret)

return _constraintStrength
}
	
	// SetMaxSize sets the maximum size of @guide.
// 
// If @guide is attached to a `GtkConstraintLayout`, the constraints will be
// updated to reflect the new size.
	func (g ConstraintGuide) SetMaxSize(width int, height int)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)

C.gtk_constraint_guide_set_max_size(_arg0, _arg1, _arg2)
}
	
	// SetMinSize sets the minimum size of @guide.
// 
// If @guide is attached to a `GtkConstraintLayout`, the constraints will be
// updated to reflect the new size.
	func (g ConstraintGuide) SetMinSize(width int, height int)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)

C.gtk_constraint_guide_set_min_size(_arg0, _arg1, _arg2)
}
	
	// SetName sets a name for the given `GtkConstraintGuide`.
// 
// The name is useful for debugging purposes.
	func (g ConstraintGuide) SetName(name string)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 *C.char // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_constraint_guide_set_name(_arg0, _arg1)
}
	
	// SetNatSize sets the natural size of @guide.
// 
// If @guide is attached to a `GtkConstraintLayout`, the constraints will be
// updated to reflect the new size.
	func (g ConstraintGuide) SetNatSize(width int, height int)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)

C.gtk_constraint_guide_set_nat_size(_arg0, _arg1, _arg2)
}
	
	// SetStrength sets the strength of the constraint on the natural size of the
// given `GtkConstraintGuide`.
	func (g ConstraintGuide) SetStrength(strength ConstraintStrength)  {
var _arg0 *C.GtkConstraintGuide // out
var _arg1 C.GtkConstraintStrength // out

_arg0 = (*C.GtkConstraintGuide)(unsafe.Pointer(g.Native()))
_arg1 = (C.GtkConstraintStrength)(strength)

C.gtk_constraint_guide_set_strength(_arg0, _arg1)
}
	


	// ConstraintLayout: a layout manager using constraints to describe relations
// between widgets.
// 
// `GtkConstraintLayout` is a layout manager that uses relations between widget
// attributes, expressed via [class@Gtk.Constraint] instances, to measure and
// allocate widgets.
// 
// 
// How do constraints work
// 
// Constraints are objects defining the relationship between attributes of a
// widget; you can read the description of the [class@Gtk.Constraint] class to
// have a more in depth definition.
// 
// By taking multiple constraints and applying them to the children of a widget
// using `GtkConstraintLayout`, it's possible to describe complex layout
// policies; each constraint applied to a child or to the parent widgets
// contributes to the full description of the layout, in terms of parameters for
// resolving the value of each attribute.
// 
// It is important to note that a layout is defined by the totality of
// constraints; removing a child, or a constraint, from an existing layout
// without changing the remaining constraints may result in an unstable or
// unsolvable layout.
// 
// Constraints have an implicit "reading order"; you should start describing
// each edge of each child, as well as their relationship with the parent
// container, from the top left (or top right, in RTL languages), horizontally
// first, and then vertically.
// 
// A constraint-based layout with too few constraints can become "unstable",
// that is: have more than one solution. The behavior of an unstable layout is
// undefined.
// 
// A constraint-based layout with conflicting constraints may be unsolvable, and
// lead to an unstable layout. You can use the
// [property@Gtk.Constraint:strength] property of [class@Gtk.Constraint] to
// "nudge" the layout towards a solution.
// 
// 
// GtkConstraintLayout as GtkBuildable
// 
// `GtkConstraintLayout` implements the [iface@Gtk.Buildable] interface and has
// a custom "constraints" element which allows describing constraints in a
// [class@Gtk.Builder] UI file.
// 
// An example of a UI definition fragment specifying a constraint:
// 
// `xml <object class="GtkConstraintLayout"> <constraints> <constraint
// target="button" target-attribute="start" relation="eq" source="super"
// source-attribute="start" constant="12" strength="required" /> <constraint
// target="button" target-attribute="width" relation="ge" constant="250"
// strength="strong" /> </constraints> </object> `
// 
// The definition above will add two constraints to the GtkConstraintLayout:
// 
//    - a required constraint between the leading edge of "button" and
//      the leading edge of the widget using the constraint layout, plus
//      12 pixels
//    - a strong, constant constraint making the width of "button" greater
//      than, or equal to 250 pixels
// 
// The "target" and "target-attribute" attributes are required.
// 
// The "source" and "source-attribute" attributes of the "constraint" element
// are optional; if they are not specified, the constraint is assumed to be a
// constant.
// 
// The "relation" attribute is optional; if not specified, the constraint is
// assumed to be an equality.
// 
// The "strength" attribute is optional; if not specified, the constraint is
// assumed to be required.
// 
// The "source" and "target" attributes can be set to "super" to indicate that
// the constraint target is the widget using the GtkConstraintLayout.
// 
// There can be "constant" and "multiplier" attributes.
// 
// Additionally, the "constraints" element can also contain a description of the
// ConstraintGuides used by the layout:
// 
// `xml <constraints> <guide min-width="100" max-width="500" name="hspace"/>
// <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
// </constraints> `
// 
// The "guide" element has the following optional attributes:
// 
//    - "min-width", "nat-width", and "max-width", describe the minimum,
//      natural, and maximum width of the guide, respectively
//    - "min-height", "nat-height", and "max-height", describe the minimum,
//      natural, and maximum height of the guide, respectively
//    - "strength" describes the strength of the constraint on the natural
//      size of the guide; if not specified, the constraint is assumed to
//      have a medium strength
//    - "name" describes a name for the guide, useful when debugging
// 
// 
// Using the Visual Format Language
// 
// Complex constraints can be described using a compact syntax called VFL, or
// *Visual Format Language*.
// 
// The Visual Format Language describes all the constraints on a row or column,
// typically starting from the leading edge towards the trailing one. Each
// element of the layout is composed by "views", which identify a
// [iface@Gtk.ConstraintTarget].
// 
// For instance:
// 
// ` [button]-[textField] `
// 
// Describes a constraint that binds the trailing edge of "button" to the
// leading edge of "textField", leaving a default space between the two.
// 
// Using VFL is also possible to specify predicates that describe constraints on
// attributes like width and height:
// 
// ` // Width must be greater than, or equal to 50 [button(>=50)]
// 
//    // Width of button1 must be equal to width of button2
//    [button1(==button2)]
// 
// `
// 
// The default orientation for a VFL description is horizontal, unless otherwise
// specified:
// 
// ` // horizontal orientation, default attribute: width H:[button(>=150)]
// 
//    // vertical orientation, default attribute: height
//    V:[button1(==button2)]
// 
// `
// 
// It's also possible to specify multiple predicates, as well as their strength:
// 
// ` // minimum width of button must be 150 // natural width of button can be
// 250 [button(>=150@required, ==250@medium)] `
// 
// Finally, it's also possible to use simple arithmetic operators:
// 
// ` // width of button1 must be equal to width of button2 // divided by 2 plus
// 12 [button1(button2 / 2 + 12)] `
	type ConstraintLayout struct {
		LayoutManager
		Buildable
		
	}

	// ConstraintLayoutClass is an interface that the ConstraintLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ConstraintLayoutClass interface {
		gextras.Objector
		_constraintLayout()
	}

	func (ConstraintLayout) _constraintLayout() {}

	
	func marshalConstraintLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapConstraintLayout(obj), nil
	}
	

	
	// NewConstraintLayout creates a new `GtkConstraintLayout` layout manager.
	func NewConstraintLayout() ConstraintLayout {
var _cret *C.GtkLayoutManager // in

_cret = C.gtk_constraint_layout_new()


var _constraintLayout ConstraintLayout // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_constraintLayout = ConstraintLayout{
LayoutManager: LayoutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _constraintLayout
}
	

	
	// AddConstraint adds a constraint to the layout manager.
// 
// The [property@Gtk.Constraint:source] and [property@Gtk.Constraint:target]
// properties of `constraint` can be:
// 
//    - set to `NULL` to indicate that the constraint refers to the
//      widget using `layout`
//    - set to the [class@Gtk.Widget] using `layout`
//    - set to a child of the [class@Gtk.Widget] using `layout`
//    - set to a [class@Gtk.ConstraintGuide] that is part of `layout`
// 
// The @layout acquires the ownership of @constraint after calling this
// function.
	func (l ConstraintLayout) AddConstraint(constraint ConstraintClass)  {
var _arg0 *C.GtkConstraintLayout // out
var _arg1 *C.GtkConstraint // out

_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkConstraint)(unsafe.Pointer(constraint.Native()))

C.gtk_constraint_layout_add_constraint(_arg0, _arg1)
}
	
	// AddGuide adds a guide to `layout`.
// 
// A guide can be used as the source or target of constraints, like a widget,
// but it is not visible.
// 
// The `layout` acquires the ownership of `guide` after calling this function.
	func (l ConstraintLayout) AddGuide(guide ConstraintGuideClass)  {
var _arg0 *C.GtkConstraintLayout // out
var _arg1 *C.GtkConstraintGuide // out

_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkConstraintGuide)(unsafe.Pointer(guide.Native()))

C.gtk_constraint_layout_add_guide(_arg0, _arg1)
}
	
	// ObserveConstraints returns a `GListModel` to track the constraints that are
// part of the layout.
// 
// Calling this function will enable extra internal bookkeeping to track
// constraints and emit signals on the returned listmodel. It may slow down
// operations a lot.
// 
// Applications should try hard to avoid calling this function because of the
// slowdowns.
	func (l ConstraintLayout) ObserveConstraints() gio.ListModel {
var _arg0 *C.GtkConstraintLayout // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))

_cret = C.gtk_constraint_layout_observe_constraints(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// ObserveGuides returns a `GListModel` to track the guides that are part of the
// layout.
// 
// Calling this function will enable extra internal bookkeeping to track guides
// and emit signals on the returned listmodel. It may slow down operations a
// lot.
// 
// Applications should try hard to avoid calling this function because of the
// slowdowns.
	func (l ConstraintLayout) ObserveGuides() gio.ListModel {
var _arg0 *C.GtkConstraintLayout // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))

_cret = C.gtk_constraint_layout_observe_guides(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// RemoveAllConstraints removes all constraints from the layout manager.
	func (l ConstraintLayout) RemoveAllConstraints()  {
var _arg0 *C.GtkConstraintLayout // out

_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))

C.gtk_constraint_layout_remove_all_constraints(_arg0)
}
	
	// RemoveConstraint removes `constraint` from the layout manager, so that it no
// longer influences the layout.
	func (l ConstraintLayout) RemoveConstraint(constraint ConstraintClass)  {
var _arg0 *C.GtkConstraintLayout // out
var _arg1 *C.GtkConstraint // out

_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkConstraint)(unsafe.Pointer(constraint.Native()))

C.gtk_constraint_layout_remove_constraint(_arg0, _arg1)
}
	
	// RemoveGuide removes `guide` from the layout manager, so that it no longer
// influences the layout.
	func (l ConstraintLayout) RemoveGuide(guide ConstraintGuideClass)  {
var _arg0 *C.GtkConstraintLayout // out
var _arg1 *C.GtkConstraintGuide // out

_arg0 = (*C.GtkConstraintLayout)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkConstraintGuide)(unsafe.Pointer(guide.Native()))

C.gtk_constraint_layout_remove_guide(_arg0, _arg1)
}
	


	// ConstraintLayoutChild: `GtkLayoutChild` subclass for children in a
// `GtkConstraintLayout`.
	type ConstraintLayoutChild struct {
		LayoutChild
		
	}

	// ConstraintLayoutChildClass is an interface that the ConstraintLayoutChild class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ConstraintLayoutChildClass interface {
		gextras.Objector
		_constraintLayoutChild()
	}

	func (ConstraintLayoutChild) _constraintLayoutChild() {}

	
	func marshalConstraintLayoutChild(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapConstraintLayoutChild(obj), nil
	}
	

	

	


	// CSSProvider: `GtkCssProvider` is an object implementing the
// `GtkStyleProvider` interface for CSS.
// 
// It is able to parse CSS-like input in order to style widgets.
// 
// An application can make GTK parse a specific CSS style sheet by calling
// [method@Gtk.CssProvider.load_from_file] or
// [method@Gtk.CssProvider.load_from_resource] and adding the provider with
// [method@Gtk.StyleContext.add_provider] or
// [func@Gtk.StyleContext.add_provider_for_display].
// 
// In addition, certain files will be read when GTK is initialized. First, the
// file `$XDG_CONFIG_HOME/gtk-4.0/gtk.css` is loaded if it exists. Then, GTK
// loads the first existing file among
// `XDG_DATA_HOME/themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$HOME/.themes/THEME/gtk-VERSION/gtk-VARIANT.css`,
// `$XDG_DATA_DIRS/themes/THEME/gtk-VERSION/gtk-VARIANT.css` and
// `DATADIR/share/themes/THEME/gtk-VERSION/gtk-VARIANT.css`, where `THEME` is
// the name of the current theme (see the [property@Gtk.Settings:gtk-theme-name]
// setting), `VARIANT` is the variant to load (see the
// [property@Gtk.Settings:gtk-application-prefer-dark-theme] setting), `DATADIR`
// is the prefix configured when GTK was compiled (unless overridden by the
// `GTK_DATA_PREFIX` environment variable), and `VERSION` is the GTK version
// number. If no file is found for the current version, GTK tries older versions
// all the way back to 4.0.
// 
// To track errors while loading CSS, connect to the
// [signal@Gtk.CssProvider::parsing-error] signal.
	type CSSProvider struct {
		**externglib.Object
		StyleProvider
		
	}

	// CSSProviderClass is an interface that the CSSProvider class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CSSProviderClass interface {
		gextras.Objector
		_cssProvider()
	}

	func (CSSProvider) _cssProvider() {}

	
	func marshalCSSProvider(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCSSProvider(obj), nil
	}
	

	
	// NewCSSProvider returns a newly created `GtkCssProvider`.
	func NewCSSProvider() CSSProvider {
var _cret *C.GtkCssProvider // in

_cret = C.gtk_css_provider_new()


var _cssProvider CSSProvider // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_cssProvider = CSSProvider{
Object: &externglib.Object{externglib.ToGObject(obj)},
StyleProvider: StyleProvider{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _cssProvider
}
	

	
	// LoadFromData loads @data into @css_provider.
// 
// This clears any previously loaded information.
	func (c CSSProvider) LoadFromData(data []byte)  {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.char
var _arg2 C.gssize

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg2 = C.gssize(len(data))
_arg1 = (*C.char)(unsafe.Pointer(&data[0]))

C.gtk_css_provider_load_from_data(_arg0, _arg1, _arg2)
}
	
	// LoadFromFile loads the data contained in @file into @css_provider.
// 
// This clears any previously loaded information.
	func (c CSSProvider) LoadFromFile(file gio.File)  {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_css_provider_load_from_file(_arg0, _arg1)
}
	
	// LoadFromPath loads the data contained in @path into @css_provider.
// 
// This clears any previously loaded information.
	func (c CSSProvider) LoadFromPath(path string)  {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.char // out

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_css_provider_load_from_path(_arg0, _arg1)
}
	
	// LoadFromResource loads the data contained in the resource at @resource_path
// into the @css_provider.
// 
// This clears any previously loaded information.
	func (c CSSProvider) LoadFromResource(resourcePath string)  {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.char // out

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_css_provider_load_from_resource(_arg0, _arg1)
}
	
	// LoadNamed loads a theme from the usual theme paths.
// 
// The actual process of finding the theme might change between releases, but it
// is guaranteed that this function uses the same mechanism to load the theme
// that GTK uses for loading its own theme.
	func (p CSSProvider) LoadNamed(name string, variant string)  {
var _arg0 *C.GtkCssProvider // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(p.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(variant))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_css_provider_load_named(_arg0, _arg1, _arg2)
}
	
	// String converts the @provider into a string representation in CSS format.
// 
// Using [method@Gtk.CssProvider.load_from_data] with the return value from this
// function on a new provider created with [ctor@Gtk.CssProvider.new] will
// basically create a duplicate of this @provider.
	func (p CSSProvider) String() string {
var _arg0 *C.GtkCssProvider // out
var _cret *C.char // in

_arg0 = (*C.GtkCssProvider)(unsafe.Pointer(p.Native()))

_cret = C.gtk_css_provider_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// CustomFilter: `GtkCustomFilter` determines whether to include items with a
// callback.
	type CustomFilter struct {
		Filter
		
	}

	// CustomFilterClass is an interface that the CustomFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CustomFilterClass interface {
		gextras.Objector
		_customFilter()
	}

	func (CustomFilter) _customFilter() {}

	
	func marshalCustomFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCustomFilter(obj), nil
	}
	

	

	


	// CustomLayout: `GtkCustomLayout` uses closures for size negotiation.
// 
// A `GtkCustomLayout `uses closures matching to the old `GtkWidget` virtual
// functions for size negotiation, as a convenience API to ease the porting
// towards the corresponding `GtkLayoutManager virtual functions.
	type CustomLayout struct {
		LayoutManager
		
	}

	// CustomLayoutClass is an interface that the CustomLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CustomLayoutClass interface {
		gextras.Objector
		_customLayout()
	}

	func (CustomLayout) _customLayout() {}

	
	func marshalCustomLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCustomLayout(obj), nil
	}
	

	

	


	// CustomSorter: `GtkCustomSorter` is a `GtkSorter` implementation that sorts
// via a callback function.
	type CustomSorter struct {
		Sorter
		
	}

	// CustomSorterClass is an interface that the CustomSorter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type CustomSorterClass interface {
		gextras.Objector
		_customSorter()
	}

	func (CustomSorter) _customSorter() {}

	
	func marshalCustomSorter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapCustomSorter(obj), nil
	}
	

	

	


	// Dialog dialogs are a convenient way to prompt the user for a small amount of
// input.
// 
// !An example GtkDialog (dialog.png)
// 
// Typical uses are to display a message, ask a question, or anything else that
// does not require extensive effort on the users part.
// 
// The main area of a `GtkDialog` is called the "content area", and is yours to
// populate with widgets such a `GtkLabel` or `GtkEntry`, to present your
// information, questions, or tasks to the user.
// 
// In addition, dialogs allow you to add "action widgets". Most commonly, action
// widgets are buttons. Depending on the platform, action widgets may be
// presented in the header bar at the top of the window, or at the bottom of the
// window. To add action widgets, create your `GtkDialog` using
// [ctor@Gtk.Dialog.new_with_buttons], or use [method@Gtk.Dialog.add_button],
// [method@Gtk.Dialog.add_buttons], or [method@Gtk.Dialog.add_action_widget].
// 
// `GtkDialogs` uses some heuristics to decide whether to add a close button to
// the window decorations. If any of the action buttons use the response ID
// GTK_RESPONSE_CLOSE or GTK_RESPONSE_CANCEL, the close button is omitted.
// 
// Clicking a button that was added as an action widget will emit the
// [signal@Gtk.Dialog::response] signal with a response ID that you specified.
// GTK will never assign a meaning to positive response IDs; these are entirely
// user-defined. But for convenience, you can use the response IDs in the
// [enum@Gtk.ResponseType] enumeration (these all have values less than zero).
// If a dialog receives a delete event, the [signal@Gtk.Dialog::response] signal
// will be emitted with the GTK_RESPONSE_DELETE_EVENT response ID.
// 
// Dialogs are created with a call to [ctor@Gtk.Dialog.new] or
// [ctor@Gtk.Dialog.new_with_buttons]. The latter is recommended; it allows you
// to set the dialog title, some convenient flags, and add buttons.
// 
// A modal dialog (that is, one which freezes the rest of the application from
// user input), can be created by calling [method@Gtk.Window.set_modal] on the
// dialog. When using [ctor@Gtk.Dialog.new_with_buttons], you can also pass the
// GTK_DIALOG_MODAL flag to make a dialog modal.
// 
// For the simple dialog in the following example, a [class@Gtk.MessageDialog]
// would save some effort. But youd need to create the dialog contents manually
// if you had more than a simple message in the dialog.
// 
// An example for simple `GtkDialog` usage: `c // Function to open a dialog box
// with a message void quick_message (GtkWindow *parent, char *message) {
// GtkWidget *dialog, *label, *content_area; GtkDialogFlags flags;
// 
//    // Create the widgets
//    flags = GTK_DIALOG_DESTROY_WITH_PARENT;
//    dialog = gtk_dialog_new_with_buttons ("Message",
//                                          parent,
//                                          flags,
//                                          _("_OK"),
//                                          GTK_RESPONSE_NONE,
//                                          NULL);
//    content_area = gtk_dialog_get_content_area (GTK_DIALOG (dialog));
//    label = gtk_label_new (message);
// 
//    // Ensure that the dialog box is destroyed when the user responds
// 
//    g_signal_connect_swapped (dialog,
//                              "response",
//                              G_CALLBACK (gtk_window_destroy),
//                              dialog);
// 
//    // Add the label, and show everything weve added
// 
//    gtk_box_append (GTK_BOX (content_area), label);
//    gtk_widget_show (dialog);
// 
// } `
// 
// 
// GtkDialog as GtkBuildable
// 
// The `GtkDialog` implementation of the `GtkBuildable` interface exposes the
// @content_area as an internal child with the name content_area.
// 
// `GtkDialog` supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The response attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area). To mark a response as
// default, set the default attribute of the <action-widget> element to true.
// 
// `GtkDialog` supports adding action widgets by specifying action as the
// type attribute of a <child> element. The widget will be added either to the
// action area or the headerbar of the dialog, depending on the use-header-bar
// property. The response id has to be associated with the action widget using
// the <action-widgets> element.
// 
// An example of a Dialog UI definition fragment: `xml <object
// class="GtkDialog" id="dialog1"> <child type="action"> <object
// class="GtkButton" id="button_cancel"/> </child> <child type="action"> <object
// class="GtkButton" id="button_ok"> </object> </child> <action-widgets>
// <action-widget response="cancel">button_cancel</action-widget> <action-widget
// response="ok" default="true">button_ok</action-widget> </action-widgets>
// </object> `
// 
// 
// Accessibility
// 
// `GtkDialog` uses the GTK_ACCESSIBLE_ROLE_DIALOG role.
	type Dialog struct {
		Window
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// DialogClass is an interface that the Dialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DialogClass interface {
		gextras.Objector
		_dialog()
	}

	func (Dialog) _dialog() {}

	
	func marshalDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDialog(obj), nil
	}
	

	
	// NewDialog creates a new dialog box.
// 
// Widgets should not be packed into the `GtkWindow` directly, but into the
// @content_area and @action_area, as described above.
	func NewDialog() Dialog {
var _cret *C.GtkWidget // in

_cret = C.gtk_dialog_new()


var _dialog Dialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_dialog = Dialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dialog
}
	

	
	// AddActionWidget adds an activatable widget to the action area of a
// `GtkDialog`.
// 
// GTK connects a signal handler that will emit the
// [signal@Gtk.Dialog::response] signal on the dialog when the widget is
// activated. The widget is appended to the end of the dialogs action area.
// 
// If you want to add a non-activatable widget, simply pack it into the
// @action_area field of the `GtkDialog` struct.
	func (d Dialog) AddActionWidget(child WidgetClass, responseId int)  {
var _arg0 *C.GtkDialog // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(responseId)

C.gtk_dialog_add_action_widget(_arg0, _arg1, _arg2)
}
	
	// AddButton adds a button with the given text.
// 
// GTK arranges things so that clicking the button will emit the
// [signal@Gtk.Dialog::response] signal with the given @response_id. The button
// is appended to the end of the dialogs action area. The button widget is
// returned, but usually you dont need it.
	func (d Dialog) AddButton(buttonText string, responseId int) Widget {
var _arg0 *C.GtkDialog // out
var _arg1 *C.char // out
var _arg2 C.int // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.char)(C.CString(buttonText))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(responseId)

_cret = C.gtk_dialog_add_button(_arg0, _arg1, _arg2)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ContentArea returns the content area of @dialog.
	func (d Dialog) ContentArea() Box {
var _arg0 *C.GtkDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_dialog_get_content_area(_arg0)


var _box Box // out

_box = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Box)

return _box
}
	
	// HeaderBar returns the header bar of @dialog.
// 
// Note that the headerbar is only used by the dialog if the
// [property@Gtk.Dialog:use-header-bar] property is true.
	func (d Dialog) HeaderBar() HeaderBar {
var _arg0 *C.GtkDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_dialog_get_header_bar(_arg0)


var _headerBar HeaderBar // out

_headerBar = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(HeaderBar)

return _headerBar
}
	
	// ResponseForWidget gets the response id of a widget in the action area of a
// dialog.
	func (d Dialog) ResponseForWidget(widget WidgetClass) int {
var _arg0 *C.GtkDialog // out
var _arg1 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_dialog_get_response_for_widget(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// WidgetForResponse gets the widget button that uses the given response ID in
// the action area of a dialog.
	func (d Dialog) WidgetForResponse(responseId int) Widget {
var _arg0 *C.GtkDialog // out
var _arg1 C.int // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.int)(responseId)

_cret = C.gtk_dialog_get_widget_for_response(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Response emits the ::response signal with the given response ID.
// 
// Used to indicate that the user has responded to the dialog in some way.
	func (d Dialog) Response(responseId int)  {
var _arg0 *C.GtkDialog // out
var _arg1 C.int // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.int)(responseId)

C.gtk_dialog_response(_arg0, _arg1)
}
	
	// SetDefaultResponse sets the default widget for the dialog based on the
// response ID.
// 
// Pressing Enter normally activates the default widget.
	func (d Dialog) SetDefaultResponse(responseId int)  {
var _arg0 *C.GtkDialog // out
var _arg1 C.int // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.int)(responseId)

C.gtk_dialog_set_default_response(_arg0, _arg1)
}
	
	// SetResponseSensitive: a convenient way to sensitize/desensitize dialog
// buttons.
// 
// Calls `gtk_widget_set_sensitive (widget, @setting)` for each widget in the
// dialogs action area with the given @response_id.
	func (d Dialog) SetResponseSensitive(responseId int, setting bool)  {
var _arg0 *C.GtkDialog // out
var _arg1 C.int // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.int)(responseId)
if setting { _arg2 = C.TRUE }

C.gtk_dialog_set_response_sensitive(_arg0, _arg1, _arg2)
}
	


	// DirectoryList: `GtkDirectoryList` is a list model that wraps
// g_file_enumerate_children_async().
// 
// It presents a `GListModel` and fills it asynchronously with the `GFileInfo`s
// returned from that function.
// 
// Enumeration will start automatically when a the
// [property@Gtk.DirectoryList:file] property is set.
// 
// While the `GtkDirectoryList` is being filled, the
// [property@Gtk.DirectoryList:loading] property will be set to true. You can
// listen to that property if you want to show information like a `GtkSpinner`
// or a "Loading..." text.
// 
// If loading fails at any point, the [property@Gtk.DirectoryList:error]
// property will be set to give more indication about the failure.
// 
// The `GFileInfo`s returned from a `GtkDirectoryList` have the "standard::file"
// attribute set to the `GFile` they refer to. This way you can get at the file
// that is referred to in the same way you would via
// g_file_enumerator_get_child(). This means you do not need access to the
// `GtkDirectoryList`, but can access the `GFile` directly from the `GFileInfo`
// when operating with a `GtkListView` or similar.
	type DirectoryList struct {
		**externglib.Object
		gio.ListModel
		
	}

	// DirectoryListClass is an interface that the DirectoryList class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DirectoryListClass interface {
		gextras.Objector
		_directoryList()
	}

	func (DirectoryList) _directoryList() {}

	
	func marshalDirectoryList(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDirectoryList(obj), nil
	}
	

	
	// NewDirectoryList creates a new `GtkDirectoryList`.
// 
// The `GtkDirectoryList` is querying the given @file with the given
// @attributes.
	func NewDirectoryList(attributes string, file gio.File) DirectoryList {
var _arg1 *C.char // out
var _arg2 *C.GFile // out
var _cret *C.GtkDirectoryList // in

_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GFile)(unsafe.Pointer(file.Native()))

_cret = C.gtk_directory_list_new(_arg1, _arg2)


var _directoryList DirectoryList // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_directoryList = DirectoryList{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _directoryList
}
	

	
	// Attributes gets the attributes queried on the children.
	func (s DirectoryList) Attributes() string {
var _arg0 *C.GtkDirectoryList // out
var _cret *C.char // in

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_directory_list_get_attributes(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Error gets the loading error, if any.
// 
// If an error occurs during the loading process, the loading process will
// finish and this property allows querying the error that happened. This error
// will persist until a file is loaded again.
// 
// An error being set does not mean that no files were loaded, and all
// successfully queried files will remain in the list.
	func (s DirectoryList) Error() error {
var _arg0 *C.GtkDirectoryList // out
var _cret *C.GError // in

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_directory_list_get_error(_arg0)


var _err error // out

_err = gerror.Take(unsafe.Pointer(_cret))

return _err
}
	
	// File gets the file whose children are currently enumerated.
	func (s DirectoryList) File() gio.File {
var _arg0 *C.GtkDirectoryList // out
var _cret *C.GFile // in

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_directory_list_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// IOPriority gets the IO priority set via gtk_directory_list_set_io_priority().
	func (s DirectoryList) IOPriority() int {
var _arg0 *C.GtkDirectoryList // out
var _cret C.int // in

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_directory_list_get_io_priority(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Monitored returns whether the directory list is monitoring the directory for
// changes.
	func (s DirectoryList) Monitored() bool {
var _arg0 *C.GtkDirectoryList // out
var _cret C.gboolean // in

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_directory_list_get_monitored(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsLoading returns true if the children enumeration is currently in progress.
// 
// Files will be added to @self from time to time while loading is going on. The
// order in which are added is undefined and may change in between runs.
	func (s DirectoryList) IsLoading() bool {
var _arg0 *C.GtkDirectoryList // out
var _cret C.gboolean // in

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))

_cret = C.gtk_directory_list_is_loading(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAttributes sets the @attributes to be enumerated and starts the
// enumeration.
// 
// If @attributes is nil, no attributes will be queried, but a list of
// `GFileInfo`s will still be created.
	func (s DirectoryList) SetAttributes(attributes string)  {
var _arg0 *C.GtkDirectoryList // out
var _arg1 *C.char // out

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(attributes))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_directory_list_set_attributes(_arg0, _arg1)
}
	
	// SetFile sets the @file to be enumerated and starts the enumeration.
// 
// If @file is nil, the result will be an empty list.
	func (s DirectoryList) SetFile(file gio.File)  {
var _arg0 *C.GtkDirectoryList // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_directory_list_set_file(_arg0, _arg1)
}
	
	// SetIOPriority sets the IO priority to use while loading directories.
// 
// Setting the priority while @self is loading will reprioritize the ongoing
// load as soon as possible.
// 
// The default IO priority is G_PRIORITY_DEFAULT, which is higher than the GTK
// redraw priority. If you are loading a lot of directories in parallel,
// lowering it to something like G_PRIORITY_DEFAULT_IDLE may increase
// responsiveness.
	func (s DirectoryList) SetIOPriority(ioPriority int)  {
var _arg0 *C.GtkDirectoryList // out
var _arg1 C.int // out

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(ioPriority)

C.gtk_directory_list_set_io_priority(_arg0, _arg1)
}
	
	// SetMonitored sets whether the directory list will monitor the directory for
// changes. If monitoring is enabled, the ::items-changed signal will be emitted
// when the directory contents change.
// 
// When monitoring is turned on after the initial creation of the directory
// list, the directory is reloaded to avoid missing files that appeared between
// the initial loading and when monitoring was turned on.
	func (s DirectoryList) SetMonitored(monitored bool)  {
var _arg0 *C.GtkDirectoryList // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkDirectoryList)(unsafe.Pointer(s.Native()))
if monitored { _arg1 = C.TRUE }

C.gtk_directory_list_set_monitored(_arg0, _arg1)
}
	


	// DragIcon: `GtkDragIcon` is a `GtkRoot` implementation for drag icons.
// 
// A drag icon moves with the pointer during a Drag-and-Drop operation and is
// destroyed when the drag ends.
// 
// To set up a drag icon and associate it with an ongoing drag operation, use
// [func@Gtk.DragIcon.get_for_drag] to get the icon for a drag. You can then use
// it like any other widget and use [method@Gtk.DragIcon.set_child] to set
// whatever widget should be used for the drag icon.
// 
// Keep in mind that drag icons do not allow user input.
	type DragIcon struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		
	}

	// DragIconClass is an interface that the DragIcon class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DragIconClass interface {
		gextras.Objector
		_dragIcon()
	}

	func (DragIcon) _dragIcon() {}

	
	func marshalDragIcon(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDragIcon(obj), nil
	}
	

	

	
	// Child gets the widget currently used as drag icon.
	func (s DragIcon) Child() Widget {
var _arg0 *C.GtkDragIcon // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkDragIcon)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drag_icon_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetChild sets the widget to display as the drag icon.
	func (s DragIcon) SetChild(child WidgetClass)  {
var _arg0 *C.GtkDragIcon // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkDragIcon)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_drag_icon_set_child(_arg0, _arg1)
}
	


	// DragSource: `GtkDragSource` is an event controller to initiate Drag-And-Drop
// operations.
// 
// `GtkDragSource` can be set up with the necessary ingredients for a DND
// operation ahead of time. This includes the source for the data that is being
// transferred, in the form of a [class@Gdk.ContentProvider], the desired
// action, and the icon to use during the drag operation. After setting it up,
// the drag source must be added to a widget as an event controller, using
// [method@Gtk.Widget.add_controller].
// 
// `c static void my_widget_init (MyWidget *self) { GtkDragSource *drag_source
// = gtk_drag_source_new ();
// 
//    g_signal_connect (drag_source, "prepare", G_CALLBACK (on_drag_prepare), self);
//    g_signal_connect (drag_source, "drag-begin", G_CALLBACK (on_drag_begin), self);
// 
//    gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (drag_source));
// 
// } `
// 
// Setting up the content provider and icon ahead of time only makes sense when
// the data does not change. More commonly, you will want to set them up just in
// time. To do so, `GtkDragSource` has [signal@Gtk.DragSource::prepare] and
// [signal@Gtk.DragSource::drag-begin] signals.
// 
// The ::prepare signal is emitted before a drag is started, and can be used to
// set the content provider and actions that the drag should be started with.
// 
// `c static GdkContentProvider * on_drag_prepare (GtkDragSource *source,
// double x, double y, MyWidget *self) { // This widget supports two types of
// content: GFile objects // and GdkPixbuf objects; GTK will handle the
// serialization // of these types automatically GFile *file =
// my_widget_get_file (self); GdkPixbuf *pixbuf = my_widget_get_pixbuf (self);
// 
//    return gdk_content_provider_new_union ((GdkContentProvider *[2]) {
//        gdk_content_provider_new_typed (G_TYPE_FILE, file),
//        gdk_content_provider_new_typed (GDK_TYPE_PIXBUF, pixbuf),
//      }, 2);
// 
// } `
// 
// The ::drag-begin signal is emitted after the `GdkDrag` object has been
// created, and can be used to set up the drag icon.
// 
// `c static void on_drag_begin (GtkDragSource *source, GtkDrag *drag, MyWidget
// *self) { // Set the widget as the drag icon GdkPaintable *paintable =
// gtk_widget_paintable_new (GTK_WIDGET (self)); gtk_drag_source_set_icon
// (source, paintable, 0, 0); g_object_unref (paintable); } `
// 
// During the DND operation, `GtkDragSource` emits signals that can be used to
// obtain updates about the status of the operation, but it is not normally
// necessary to connect to any signals, except for one case: when the supported
// actions include GDK_ACTION_MOVE, you need to listen for the
// [signal@Gtk.DragSource::drag-end] signal and delete the data after it has
// been transferred.
	type DragSource struct {
		GestureSingle
		
	}

	// DragSourceClass is an interface that the DragSource class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DragSourceClass interface {
		gextras.Objector
		_dragSource()
	}

	func (DragSource) _dragSource() {}

	
	func marshalDragSource(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDragSource(obj), nil
	}
	

	
	// NewDragSource creates a new `GtkDragSource` object.
	func NewDragSource() DragSource {
var _cret *C.GtkDragSource // in

_cret = C.gtk_drag_source_new()


var _dragSource DragSource // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dragSource = DragSource{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _dragSource
}
	

	
	// DragCancel cancels a currently ongoing drag operation.
	func (s DragSource) DragCancel()  {
var _arg0 *C.GtkDragSource // out

_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

C.gtk_drag_source_drag_cancel(_arg0)
}
	
	// Actions gets the actions that are currently set on the `GtkDragSource`.
	func (s DragSource) Actions() gdk.DragAction {
var _arg0 *C.GtkDragSource // out
var _cret C.GdkDragAction // in

_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drag_source_get_actions(_arg0)


var _dragAction gdk.DragAction // out

_dragAction = gdk.DragAction(_cret)

return _dragAction
}
	
	// Content gets the current content provider of a `GtkDragSource`.
	func (s DragSource) Content() gdk.ContentProvider {
var _arg0 *C.GtkDragSource // out
var _cret *C.GdkContentProvider // in

_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drag_source_get_content(_arg0)


var _contentProvider gdk.ContentProvider // out

_contentProvider = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.ContentProvider)

return _contentProvider
}
	
	// Drag returns the underlying `GdkDrag` object for an ongoing drag.
	func (s DragSource) Drag() gdk.Drag {
var _arg0 *C.GtkDragSource // out
var _cret *C.GdkDrag // in

_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drag_source_get_drag(_arg0)


var _drag gdk.Drag // out

_drag = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Drag)

return _drag
}
	
	// SetActions sets the actions on the `GtkDragSource`.
// 
// During a DND operation, the actions are offered to potential drop targets. If
// @actions include GDK_ACTION_MOVE, you need to listen to the
// [signal@Gtk.DragSource::drag-end] signal and handle @delete_data being true.
// 
// This function can be called before a drag is started, or in a handler for the
// [signal@Gtk.DragSource::prepare] signal.
	func (s DragSource) SetActions(actions gdk.DragAction)  {
var _arg0 *C.GtkDragSource // out
var _arg1 C.GdkDragAction // out

_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))
_arg1 = (C.GdkDragAction)(actions)

C.gtk_drag_source_set_actions(_arg0, _arg1)
}
	
	// SetContent sets a content provider on a `GtkDragSource`.
// 
// When the data is requested in the cause of a DND operation, it will be
// obtained from the content provider.
// 
// This function can be called before a drag is started, or in a handler for the
// [signal@Gtk.DragSource::prepare] signal.
// 
// You may consider setting the content provider back to nil in a
// [signal@Gtk.DragSource::drag-end] signal handler.
	func (s DragSource) SetContent(content gdk.ContentProviderClass)  {
var _arg0 *C.GtkDragSource // out
var _arg1 *C.GdkContentProvider // out

_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkContentProvider)(unsafe.Pointer(content.Native()))

C.gtk_drag_source_set_content(_arg0, _arg1)
}
	
	// SetIcon sets a paintable to use as icon during DND operations.
// 
// The hotspot coordinates determine the point on the icon that gets aligned
// with the hotspot of the cursor.
// 
// If @paintable is nil, a default icon is used.
// 
// This function can be called before a drag is started, or in a
// [signal@Gtk.DragSource::prepare] or [signal@Gtk.DragSource::drag-begin]
// signal handler.
	func (s DragSource) SetIcon(paintable gdk.Paintable, hotX int, hotY int)  {
var _arg0 *C.GtkDragSource // out
var _arg1 *C.GdkPaintable // out
var _arg2 C.int // out
var _arg3 C.int // out

_arg0 = (*C.GtkDragSource)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))
_arg2 = (C.int)(hotX)
_arg3 = (C.int)(hotY)

C.gtk_drag_source_set_icon(_arg0, _arg1, _arg2, _arg3)
}
	


	// DrawingArea: `GtkDrawingArea` is a widget that allows drawing with cairo.
// 
// !An example GtkDrawingArea (drawingarea.png)
// 
// Its essentially a blank widget; you can draw on it. After creating a drawing
// area, the application may want to connect to:
// 
// - The [signal@Gtk.Widget::realize] signal to take any necessary actions when
// the widget is instantiated on a particular display. (Create GDK resources in
// response to this signal.)
// 
// - The [signal@Gtk.DrawingArea::resize] signal to take any necessary actions
// when the widget changes size.
// 
// - Call [method@Gtk.DrawingArea.set_draw_func] to handle redrawing the
// contents of the widget.
// 
// The following code portion demonstrates using a drawing area to display a
// circle in the normal widget foreground color.
// 
// 
// Simple GtkDrawingArea usage
// 
// `c static void draw_function (GtkDrawingArea *area, cairo_t *cr, int width,
// int height, gpointer data) { GdkRGBA color; GtkStyleContext *context;
// 
//    context = gtk_widget_get_style_context (GTK_WIDGET (area));
// 
//    cairo_arc (cr,
//               width / 2.0, height / 2.0,
//               MIN (width, height) / 2.0,
//               0, 2 * G_PI);
// 
//    gtk_style_context_get_color (context,
//                                 &color);
//    gdk_cairo_set_source_rgba (cr, &color);
// 
//    cairo_fill (cr);
// 
// }
// 
// int main (int argc, char **argv) { gtk_init ();
// 
//    GtkWidget *area = gtk_drawing_area_new ();
//    gtk_drawing_area_set_content_width (GTK_DRAWING_AREA (area), 100);
//    gtk_drawing_area_set_content_height (GTK_DRAWING_AREA (area), 100);
//    gtk_drawing_area_set_draw_func (GTK_DRAWING_AREA (area),
//                                    draw_function,
//                                    NULL, NULL);
//    return 0;
// 
// } `
// 
// The draw function is normally called when a drawing area first comes
// onscreen, or when its covered by another window and then uncovered. You can
// also force a redraw by adding to the damage region of the drawing areas
// window using [method@Gtk.Widget.queue_draw]. This will cause the drawing area
// to call the draw function again.
// 
// The available routines for drawing are documented on the [GDK Drawing
// Primitives][gdk4-Cairo-Interaction] page and the cairo documentation.
// 
// To receive mouse events on a drawing area, you will need to use event
// controllers. To receive keyboard events, you will need to set the can-focus
// property on the drawing area, and you should probably draw some user-visible
// indication that the drawing area is focused.
// 
// If you need more complex control over your widget, you should consider
// creating your own `GtkWidget` subclass.
	type DrawingArea struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// DrawingAreaClass is an interface that the DrawingArea class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DrawingAreaClass interface {
		gextras.Objector
		_drawingArea()
	}

	func (DrawingArea) _drawingArea() {}

	
	func marshalDrawingArea(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDrawingArea(obj), nil
	}
	

	
	// NewDrawingArea creates a new drawing area.
	func NewDrawingArea() DrawingArea {
var _cret *C.GtkWidget // in

_cret = C.gtk_drawing_area_new()


var _drawingArea DrawingArea // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_drawingArea = DrawingArea{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _drawingArea
}
	

	
	// ContentHeight retrieves the content height of the `GtkDrawingArea`.
	func (s DrawingArea) ContentHeight() int {
var _arg0 *C.GtkDrawingArea // out
var _cret C.int // in

_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drawing_area_get_content_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ContentWidth retrieves the content width of the `GtkDrawingArea`.
	func (s DrawingArea) ContentWidth() int {
var _arg0 *C.GtkDrawingArea // out
var _cret C.int // in

_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drawing_area_get_content_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetContentHeight sets the desired height of the contents of the drawing area.
// 
// Note that because widgets may be allocated larger sizes than they requested,
// it is possible that the actual height passed to your draw function is larger
// than the height set here. You can use [method@Gtk.Widget.set_valign] to avoid
// that.
// 
// If the height is set to 0 (the default), the drawing area may disappear.
	func (s DrawingArea) SetContentHeight(height int)  {
var _arg0 *C.GtkDrawingArea // out
var _arg1 C.int // out

_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(height)

C.gtk_drawing_area_set_content_height(_arg0, _arg1)
}
	
	// SetContentWidth sets the desired width of the contents of the drawing area.
// 
// Note that because widgets may be allocated larger sizes than they requested,
// it is possible that the actual width passed to your draw function is larger
// than the width set here. You can use [method@Gtk.Widget.set_halign] to avoid
// that.
// 
// If the width is set to 0 (the default), the drawing area may disappear.
	func (s DrawingArea) SetContentWidth(width int)  {
var _arg0 *C.GtkDrawingArea // out
var _arg1 C.int // out

_arg0 = (*C.GtkDrawingArea)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(width)

C.gtk_drawing_area_set_content_width(_arg0, _arg1)
}
	


	// DropControllerMotion: `GtkDropControllerMotion` is an event controller
// tracking the pointer during Drag-and-Drop operations.
// 
// It is modeled after [class@Gtk.EventControllerMotion] so if you have used
// that, this should feel really familiar.
// 
// This controller is not able to accept drops, use [class@Gtk.DropTarget] for
// that purpose.
	type DropControllerMotion struct {
		EventController
		
	}

	// DropControllerMotionClass is an interface that the DropControllerMotion class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DropControllerMotionClass interface {
		gextras.Objector
		_dropControllerMotion()
	}

	func (DropControllerMotion) _dropControllerMotion() {}

	
	func marshalDropControllerMotion(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDropControllerMotion(obj), nil
	}
	

	
	// NewDropControllerMotion creates a new event controller that will handle
// pointer motion events during drag and drop.
	func NewDropControllerMotion() DropControllerMotion {
var _cret *C.GtkEventController // in

_cret = C.gtk_drop_controller_motion_new()


var _dropControllerMotion DropControllerMotion // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dropControllerMotion = DropControllerMotion{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dropControllerMotion
}
	

	
	// ContainsPointer returns if a Drag-and-Drop operation is within the widget
// @self or one of its children.
	func (s DropControllerMotion) ContainsPointer() bool {
var _arg0 *C.GtkDropControllerMotion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_controller_motion_contains_pointer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Drop returns the `GdkDrop` of a current Drag-and-Drop operation over the
// widget of @self.
	func (s DropControllerMotion) Drop() gdk.Drop {
var _arg0 *C.GtkDropControllerMotion // out
var _cret *C.GdkDrop // in

_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_controller_motion_get_drop(_arg0)


var _drop gdk.Drop // out

_drop = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Drop)

return _drop
}
	
	// IsPointer returns if a Drag-and-Drop operation is within the widget @self,
// not one of its children.
	func (s DropControllerMotion) IsPointer() bool {
var _arg0 *C.GtkDropControllerMotion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkDropControllerMotion)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_controller_motion_is_pointer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// DropDown: `GtkDropDown` is a widget that allows the user to choose an item
// from a list of options.
// 
// !An example GtkDropDown (drop-down.png)
// 
// The `GtkDropDown` displays the selected choice.
// 
// The options are given to `GtkDropDown` in the form of `GListModel` and how
// the individual options are represented is determined by a
// [class@Gtk.ListItemFactory]. The default factory displays simple strings.
// 
// `GtkDropDown` knows how to obtain strings from the items in a
// [class@Gtk.StringList]; for other models, you have to provide an expression
// to find the strings via [method@Gtk.DropDown.set_expression].
// 
// `GtkDropDown` can optionally allow search in the popup, which is useful if
// the list of options is long. To enable the search entry, use
// [method@Gtk.DropDown.set_enable_search].
// 
// 
// CSS nodes
// 
// `GtkDropDown` has a single CSS node with name dropdown, with the button and
// popover nodes as children.
// 
// 
// Accessibility
// 
// `GtkDropDown` uses the GTK_ACCESSIBLE_ROLE_COMBO_BOX role.
	type DropDown struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// DropDownClass is an interface that the DropDown class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DropDownClass interface {
		gextras.Objector
		_dropDown()
	}

	func (DropDown) _dropDown() {}

	
	func marshalDropDown(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDropDown(obj), nil
	}
	

	
	// NewDropDown creates a new `GtkDropDown`.
// 
// You may want to call [method@Gtk.DropDown.set_factory] to set up a way to map
// its items to widgets.
	func NewDropDown(model gio.ListModel, expression ExpressionClass) DropDown {
var _arg1 *C.GListModel // out
var _arg2 *C.GtkExpression // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

_cret = C.gtk_drop_down_new(_arg1, _arg2)


var _dropDown DropDown // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_dropDown = DropDown{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dropDown
}
	
	// NewDropDownFromStrings creates a new `GtkDropDown` that is populated with the
// strings.
	func NewDropDownFromStrings(strings []string) DropDown {
var _arg1 **C.char
var _cret *C.GtkWidget // in

_arg1 = (**C.char)(C.malloc(C.ulong(len(strings)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(strings))
for i := range strings {
out[i] = (*C.char)(C.CString(strings[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.gtk_drop_down_new_from_strings(_arg1)


var _dropDown DropDown // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_dropDown = DropDown{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dropDown
}
	

	
	// EnableSearch returns whether search is enabled.
	func (s DropDown) EnableSearch() bool {
var _arg0 *C.GtkDropDown // out
var _cret C.gboolean // in

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_down_get_enable_search(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Expression gets the expression set that is used to obtain strings from items.
// 
// See [method@Gtk.DropDown.set_expression].
	func (s DropDown) Expression() Expression {
var _arg0 *C.GtkDropDown // out
var _cret *C.GtkExpression // in

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_down_get_expression(_arg0)


var _expression Expression // out

_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

return _expression
}
	
	// Factory gets the factory that's currently used to populate list items.
// 
// The factory returned by this function is always used for the item in the
// button. It is also used for items in the popup if
// [property@Gtk.DropDown:list-factory] is not set.
	func (s DropDown) Factory() ListItemFactory {
var _arg0 *C.GtkDropDown // out
var _cret *C.GtkListItemFactory // in

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_down_get_factory(_arg0)


var _listItemFactory ListItemFactory // out

_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

return _listItemFactory
}
	
	// ListFactory gets the factory that's currently used to populate list items in
// the popup.
	func (s DropDown) ListFactory() ListItemFactory {
var _arg0 *C.GtkDropDown // out
var _cret *C.GtkListItemFactory // in

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_down_get_list_factory(_arg0)


var _listItemFactory ListItemFactory // out

_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

return _listItemFactory
}
	
	// Model gets the model that provides the displayed items.
	func (s DropDown) Model() gio.ListModel {
var _arg0 *C.GtkDropDown // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_down_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Selected gets the position of the selected item.
	func (s DropDown) Selected() uint {
var _arg0 *C.GtkDropDown // out
var _cret C.guint // in

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_down_get_selected(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SelectedItem gets the selected item. If no item is selected, nil is returned.
	func (s DropDown) SelectedItem() **externglib.Object {
var _arg0 *C.GtkDropDown // out
var _cret C.gpointer // in

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_down_get_selected_item(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// SetEnableSearch sets whether a search entry will be shown in the popup that
// allows to search for items in the list.
// 
// Note that [property@Gtk.DropDown:expression] must be set for search to work.
	func (s DropDown) SetEnableSearch(enableSearch bool)  {
var _arg0 *C.GtkDropDown // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
if enableSearch { _arg1 = C.TRUE }

C.gtk_drop_down_set_enable_search(_arg0, _arg1)
}
	
	// SetExpression sets the expression that gets evaluated to obtain strings from
// items.
// 
// This is used for search in the popup. The expression must have a value type
// of G_TYPE_STRING.
	func (s DropDown) SetExpression(expression ExpressionClass)  {
var _arg0 *C.GtkDropDown // out
var _arg1 *C.GtkExpression // out

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

C.gtk_drop_down_set_expression(_arg0, _arg1)
}
	
	// SetFactory sets the `GtkListItemFactory` to use for populating list items.
	func (s DropDown) SetFactory(factory ListItemFactoryClass)  {
var _arg0 *C.GtkDropDown // out
var _arg1 *C.GtkListItemFactory // out

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

C.gtk_drop_down_set_factory(_arg0, _arg1)
}
	
	// SetListFactory sets the `GtkListItemFactory` to use for populating list items
// in the popup.
	func (s DropDown) SetListFactory(factory ListItemFactoryClass)  {
var _arg0 *C.GtkDropDown // out
var _arg1 *C.GtkListItemFactory // out

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

C.gtk_drop_down_set_list_factory(_arg0, _arg1)
}
	
	// SetModel sets the `GListModel` to use.
	func (s DropDown) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkDropDown // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_drop_down_set_model(_arg0, _arg1)
}
	
	// SetSelected selects the item at the given position.
	func (s DropDown) SetSelected(position uint)  {
var _arg0 *C.GtkDropDown // out
var _arg1 C.guint // out

_arg0 = (*C.GtkDropDown)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

C.gtk_drop_down_set_selected(_arg0, _arg1)
}
	


	// DropTarget: `GtkDropTarget` is an event controller to receive Drag-and-Drop
// operations.
// 
// The most basic way to use a `GtkDropTarget` to receive drops on a widget is
// to create it via [ctor@Gtk.DropTarget.new], passing in the `GType` of the
// data you want to receive and connect to the [signal@Gtk.DropTarget::drop]
// signal to receive the data:
// 
// `c static gboolean on_drop (GtkDropTarget *target, const GValue *value,
// double x, double y, gpointer data) { MyWidget *self = data;
// 
//    // Call the appropriate setter depending on the type of data
//    // that we received
//    if (G_VALUE_HOLDS (value, G_TYPE_FILE))
//      my_widget_set_file (self, g_value_get_object (value));
//    else if (G_VALUE_HOLDS (value, GDK_TYPE_PIXBUF))
//      my_widget_set_pixbuf (self, g_value_get_object (value));
//    else
//      return FALSE;
// 
//    return TRUE;
// 
// }
// 
// static void my_widget_init (MyWidget *self) { GtkDropTarget *target =
// gtk_drop_target_new (G_TYPE_INVALID, GDK_ACTION_COPY);
// 
//    // This widget accepts two types of drop types: GFile objects
//    // and GdkPixbuf objects
//    gtk_drop_target_set_gtypes (target, (GTypes [2]) {
//      G_TYPE_FILE,
//      GDK_TYPE_PIXBUF,
//    }, 2);
// 
//    gtk_widget_add_controller (GTK_WIDGET (self), GTK_EVENT_CONTROLLER (target));
// 
// } `
// 
// `GtkDropTarget` supports more options, such as:
// 
//    * rejecting potential drops via the [signal@Gtk.DropTarget::accept] signal
//      and the [method@Gtk.DropTarget.reject] function to let other drop
//      targets handle the drop
//    * tracking an ongoing drag operation before the drop via the
//      [signal@Gtk.DropTarget::enter], [signal@Gtk.DropTarget::motion] and
//      [signal@Gtk.DropTarget::leave] signals
//    * configuring how to receive data by setting the
//      [property@Gtk.DropTarget:preload] property and listening for its
//      availability via the [property@Gtk.DropTarget:value] property
// 
// However, `GtkDropTarget` is ultimately modeled in a synchronous way and only
// supports data transferred via `GType`. If you want full control over an
// ongoing drop, the [class@Gtk.DropTargetAsync] object gives you this ability.
// 
// While a pointer is dragged over the drop target's widget and the drop has not
// been rejected, that widget will receive the GTK_STATE_FLAG_DROP_ACTIVE state,
// which can be used to style the widget.
// 
// If you are not interested in receiving the drop, but just want to update UI
// state during a Drag-and-Drop operation (e.g. switching tabs), you can use
// [class@Gtk.DropControllerMotion].
	type DropTarget struct {
		EventController
		
	}

	// DropTargetClass is an interface that the DropTarget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DropTargetClass interface {
		gextras.Objector
		_dropTarget()
	}

	func (DropTarget) _dropTarget() {}

	
	func marshalDropTarget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDropTarget(obj), nil
	}
	

	
	// NewDropTarget creates a new `GtkDropTarget` object.
// 
// If the drop target should support more than 1 type, pass G_TYPE_INVALID for
// @type and then call [method@Gtk.DropTarget.set_gtypes].
	func NewDropTarget(typ externglib.Type, actions gdk.DragAction) DropTarget {
var _arg1 C.GType // out
var _arg2 C.GdkDragAction // out
var _cret *C.GtkDropTarget // in

_arg1 = C.GType(typ)
_arg2 = (C.GdkDragAction)(actions)

_cret = C.gtk_drop_target_new(_arg1, _arg2)


var _dropTarget DropTarget // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dropTarget = DropTarget{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dropTarget
}
	

	
	// Actions gets the actions that this drop target supports.
	func (s DropTarget) Actions() gdk.DragAction {
var _arg0 *C.GtkDropTarget // out
var _cret C.GdkDragAction // in

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_target_get_actions(_arg0)


var _dragAction gdk.DragAction // out

_dragAction = gdk.DragAction(_cret)

return _dragAction
}
	
	// Drop gets the currently handled drop operation.
// 
// If no drop operation is going on, nil is returned.
	func (s DropTarget) Drop() gdk.Drop {
var _arg0 *C.GtkDropTarget // out
var _cret *C.GdkDrop // in

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_target_get_drop(_arg0)


var _drop gdk.Drop // out

_drop = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Drop)

return _drop
}
	
	// Formats gets the data formats that this drop target accepts.
// 
// If the result is nil, all formats are expected to be supported.
	func (s DropTarget) Formats() *gdk.ContentFormats {
var _arg0 *C.GtkDropTarget // out
var _cret *C.GdkContentFormats // in

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_target_get_formats(_arg0)


var _contentFormats *gdk.ContentFormats // out

_contentFormats = *(**gdk.ContentFormats)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_contentFormats, func(v *gdk.ContentFormats) {
  C.free(unsafe.Pointer(v.Native()))
})

return _contentFormats
}
	
	// Preload gets whether data should be preloaded on hover.
	func (s DropTarget) Preload() bool {
var _arg0 *C.GtkDropTarget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_target_get_preload(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Value gets the current drop data, as a `GValue`.
	func (s DropTarget) Value() **externglib.Value {
var _arg0 *C.GtkDropTarget // out
var _cret *C.GValue // in

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_target_get_value(_arg0)


var _value **externglib.Value // out

_value = externglib.ValueFromNative(unsafe.Pointer(_cret))

return _value
}
	
	// Reject rejects the ongoing drop operation.
// 
// If no drop operation is ongoing, i.e when [property@Gtk.DropTarget:drop] is
// nil, this function does nothing.
// 
// This function should be used when delaying the decision on whether to accept
// a drag or not until after reading the data.
	func (s DropTarget) Reject()  {
var _arg0 *C.GtkDropTarget // out

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))

C.gtk_drop_target_reject(_arg0)
}
	
	// SetActions sets the actions that this drop target supports.
	func (s DropTarget) SetActions(actions gdk.DragAction)  {
var _arg0 *C.GtkDropTarget // out
var _arg1 C.GdkDragAction // out

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))
_arg1 = (C.GdkDragAction)(actions)

C.gtk_drop_target_set_actions(_arg0, _arg1)
}
	
	// SetGTypes sets the supported `GTypes` for this drop target.
	func (s DropTarget) SetGTypes(types []externglib.Type)  {
var _arg0 *C.GtkDropTarget // out
var _arg1 *C.GType
var _arg2 C.gsize

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))
_arg2 = C.gsize(len(types))
_arg1 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

C.gtk_drop_target_set_gtypes(_arg0, _arg1, _arg2)
}
	
	// SetPreload sets whether data should be preloaded on hover.
	func (s DropTarget) SetPreload(preload bool)  {
var _arg0 *C.GtkDropTarget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkDropTarget)(unsafe.Pointer(s.Native()))
if preload { _arg1 = C.TRUE }

C.gtk_drop_target_set_preload(_arg0, _arg1)
}
	


	// DropTargetAsync: `GtkDropTargetAsync` is an event controller to receive
// Drag-and-Drop operations, asynchronously.
// 
// It is the more complete but also more complex method of handling drop
// operations compared to [class@Gtk.DropTarget], and you should only use it if
// `GtkDropTarget` doesn't provide all the features you need.
// 
// To use a `GtkDropTargetAsync` to receive drops on a widget, you create a
// `GtkDropTargetAsync` object, configure which data formats and actions you
// support, connect to its signals, and then attach it to the widget with
// [method@Gtk.Widget.add_controller].
// 
// During a drag operation, the first signal that a `GtkDropTargetAsync` emits
// is [signal@Gtk.DropTargetAsync::accept], which is meant to determine whether
// the target is a possible drop site for the ongoing drop. The default handler
// for the ::accept signal accepts the drop if it finds a compatible data format
// and an action that is supported on both sides.
// 
// If it is, and the widget becomes a target, you will receive a
// [signal@Gtk.DropTargetAsync::drag-enter] signal, followed by
// [signal@Gtk.DropTargetAsync::drag-motion] signals as the pointer moves,
// optionally a [signal@Gtk.DropTargetAsync::drop] signal when a drop happens,
// and finally a [signal@Gtk.DropTargetAsync::drag-leave] signal when the
// pointer moves off the widget.
// 
// The ::drag-enter and ::drag-motion handler return a `GdkDragAction` to update
// the status of the ongoing operation. The ::drop handler should decide if it
// ultimately accepts the drop and if it does, it should initiate the data
// transfer and finish the operation by calling [method@Gdk.Drop.finish].
// 
// Between the ::drag-enter and ::drag-leave signals the widget is a current
// drop target, and will receive the GTK_STATE_FLAG_DROP_ACTIVE state, which can
// be used by themes to style the widget as a drop target.
	type DropTargetAsync struct {
		EventController
		
	}

	// DropTargetAsyncClass is an interface that the DropTargetAsync class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type DropTargetAsyncClass interface {
		gextras.Objector
		_dropTargetAsync()
	}

	func (DropTargetAsync) _dropTargetAsync() {}

	
	func marshalDropTargetAsync(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapDropTargetAsync(obj), nil
	}
	

	
	// NewDropTargetAsync creates a new `GtkDropTargetAsync` object.
	func NewDropTargetAsync(formats *gdk.ContentFormats, actions gdk.DragAction) DropTargetAsync {
var _arg1 *C.GdkContentFormats // out
var _arg2 C.GdkDragAction // out
var _cret *C.GtkDropTargetAsync // in

_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
_arg2 = (C.GdkDragAction)(actions)

_cret = C.gtk_drop_target_async_new(_arg1, _arg2)


var _dropTargetAsync DropTargetAsync // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_dropTargetAsync = DropTargetAsync{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _dropTargetAsync
}
	

	
	// Actions gets the actions that this drop target supports.
	func (s DropTargetAsync) Actions() gdk.DragAction {
var _arg0 *C.GtkDropTargetAsync // out
var _cret C.GdkDragAction // in

_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_target_async_get_actions(_arg0)


var _dragAction gdk.DragAction // out

_dragAction = gdk.DragAction(_cret)

return _dragAction
}
	
	// Formats gets the data formats that this drop target accepts.
// 
// If the result is nil, all formats are expected to be supported.
	func (s DropTargetAsync) Formats() *gdk.ContentFormats {
var _arg0 *C.GtkDropTargetAsync // out
var _cret *C.GdkContentFormats // in

_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))

_cret = C.gtk_drop_target_async_get_formats(_arg0)


var _contentFormats *gdk.ContentFormats // out

_contentFormats = *(**gdk.ContentFormats)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_contentFormats, func(v *gdk.ContentFormats) {
  C.free(unsafe.Pointer(v.Native()))
})

return _contentFormats
}
	
	// RejectDrop sets the @drop as not accepted on this drag site.
// 
// This function should be used when delaying the decision on whether to accept
// a drag or not until after reading the data.
	func (s DropTargetAsync) RejectDrop(drop gdk.DropClass)  {
var _arg0 *C.GtkDropTargetAsync // out
var _arg1 *C.GdkDrop // out

_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkDrop)(unsafe.Pointer(drop.Native()))

C.gtk_drop_target_async_reject_drop(_arg0, _arg1)
}
	
	// SetActions sets the actions that this drop target supports.
	func (s DropTargetAsync) SetActions(actions gdk.DragAction)  {
var _arg0 *C.GtkDropTargetAsync // out
var _arg1 C.GdkDragAction // out

_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))
_arg1 = (C.GdkDragAction)(actions)

C.gtk_drop_target_async_set_actions(_arg0, _arg1)
}
	
	// SetFormats sets the data formats that this drop target will accept.
	func (s DropTargetAsync) SetFormats(formats *gdk.ContentFormats)  {
var _arg0 *C.GtkDropTargetAsync // out
var _arg1 *C.GdkContentFormats // out

_arg0 = (*C.GtkDropTargetAsync)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))

C.gtk_drop_target_async_set_formats(_arg0, _arg1)
}
	


	// EditableLabel: a `GtkEditableLabel` is a label that allows users to edit the
// text by switching to an edit mode.
// 
// !An example GtkEditableLabel (editable-label.png)
// 
// `GtkEditableLabel` does not have API of its own, but it implements the
// [iface@Gtk.Editable] interface.
// 
// The default bindings for activating the edit mode is to click or press the
// Enter key. The default bindings for leaving the edit mode are the Enter key
// (to save the results) or the Escape key (to cancel the editing).
// 
// 
// CSS nodes
// 
// ` editablelabel[.editing]  stack  label  text `
// 
// `GtkEditableLabel` has a main node with the name editablelabel. When the
// entry is in editing mode, it gets the .editing style class.
// 
// For all the subnodes added to the text node in various situations, see
// [class@Gtk.Text].
	type EditableLabel struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Editable
		
	}

	// EditableLabelClass is an interface that the EditableLabel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EditableLabelClass interface {
		gextras.Objector
		_editableLabel()
	}

	func (EditableLabel) _editableLabel() {}

	
	func marshalEditableLabel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEditableLabel(obj), nil
	}
	

	
	// NewEditableLabel creates a new `GtkEditableLabel` widget.
	func NewEditableLabel(str string) EditableLabel {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_editable_label_new(_arg1)


var _editableLabel EditableLabel // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_editableLabel = EditableLabel{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _editableLabel
}
	

	
	// Editing returns whether the label is currently in editing mode.
	func (s EditableLabel) Editing() bool {
var _arg0 *C.GtkEditableLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_editable_label_get_editing(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartEditing switches the label into editing mode.
	func (s EditableLabel) StartEditing()  {
var _arg0 *C.GtkEditableLabel // out

_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(s.Native()))

C.gtk_editable_label_start_editing(_arg0)
}
	
	// StopEditing switches the label out of editing mode.
// 
// If @commit is true, the resulting text is kept as the
// [property@Gtk.Editable:text] property value, otherwise the resulting text is
// discarded and the label will keep its previous [property@Gtk.Editable:text]
// property value.
	func (s EditableLabel) StopEditing(commit bool)  {
var _arg0 *C.GtkEditableLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEditableLabel)(unsafe.Pointer(s.Native()))
if commit { _arg1 = C.TRUE }

C.gtk_editable_label_stop_editing(_arg0, _arg1)
}
	


	// EmojiChooser: the `GtkEmojiChooser` is used by text widgets such as
// `GtkEntry` or `GtkTextView` to let users insert Emoji characters.
// 
// !An example GtkEmojiChooser (emojichooser.png)
// 
// `GtkEmojiChooser` emits the [signal@Gtk.EmojiChooser::emoji-picked] signal
// when an Emoji is selected.
// 
// 
// CSS nodes
// 
// ` popover  box.emoji-searchbar   entry.search  box.emoji-toolbar
//  button.image-button.emoji-section  ... 
// button.image-button.emoji-section `
// 
// Every `GtkEmojiChooser` consists of a main node called popover. The contents
// of the popover are largely implementation defined and supposed to inherit
// general styles. The top searchbar used to search emoji and gets the
// .emoji-searchbar style class itself. The bottom toolbar used to switch
// between different emoji categories consists of buttons with the
// .emoji-section style class and gets the .emoji-toolbar style class itself.
	type EmojiChooser struct {
		Popover
		Accessible
		Buildable
		ConstraintTarget
		Native
		ShortcutManager
		
	}

	// EmojiChooserClass is an interface that the EmojiChooser class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EmojiChooserClass interface {
		gextras.Objector
		_emojiChooser()
	}

	func (EmojiChooser) _emojiChooser() {}

	
	func marshalEmojiChooser(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEmojiChooser(obj), nil
	}
	

	
	// NewEmojiChooser creates a new `GtkEmojiChooser`.
	func NewEmojiChooser() EmojiChooser {
var _cret *C.GtkWidget // in

_cret = C.gtk_emoji_chooser_new()


var _emojiChooser EmojiChooser // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_emojiChooser = EmojiChooser{
Popover: Popover{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _emojiChooser
}
	

	


	// Entry: `GtkEntry` is a single line text entry widget.
// 
// !An example GtkEntry (entry.png)
// 
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
// 
// When using an entry for passwords and other sensitive information, it can be
// put into password mode using [method@Gtk.Entry.set_visibility]. In this
// mode, entered text is displayed using a invisible character. By default,
// GTK picks the best invisible character that is available in the current font,
// but it can be changed with [method@Gtk.Entry.set_invisible_char].
// 
// `GtkEntry` has the ability to display progress or activity information behind
// the text. To make an entry display such information, use
// [method@Gtk.Entry.set_progress_fraction] or
// [method@Gtk.Entry.set_progress_pulse_step].
// 
// Additionally, `GtkEntry` can show icons at either side of the entry. These
// icons can be activatable by clicking, can be set up as drag source and can
// have tooltips. To add an icon, use [method@Gtk.Entry.set_icon_from_gicon] or
// one of the various other functions that set an icon from an icon name or a
// paintable. To trigger an action when the user clicks an icon, connect to the
// [signal@Gtk.Entry::icon-press] signal. To allow DND operations from an icon,
// use [method@Gtk.Entry.set_icon_drag_source]. To set a tooltip on an icon, use
// [method@Gtk.Entry.set_icon_tooltip_text] or the corresponding function for
// markup.
// 
// Note that functionality or information that is only available by clicking on
// an icon in an entry may not be accessible at all to users which are not able
// to use a mouse or other pointing device. It is therefore recommended that any
// such functionality should also be available by other means, e.g. via the
// context menu of the entry.
// 
// 
// CSS nodes
// 
// ` entry[.flat][.warning][.error]  text[.readonly]  image.left 
// image.right  [progress[.pulse]] `
// 
// `GtkEntry` has a main node with the name entry. Depending on the properties
// of the entry, the style classes .read-only and .flat may appear. The style
// classes .warning and .error may also be used with entries.
// 
// When the entry shows icons, it adds subnodes with the name image and the
// style class .left or .right, depending on where the icon appears.
// 
// When the entry shows progress, it adds a subnode with the name progress. The
// node has the style class .pulse when the shown progress is pulsing.
// 
// For all the subnodes added to the text node in various situations, see
// [class@Gtk.Text].
// 
// 
// GtkEntry as GtkBuildable
// 
// The `GtkEntry` implementation of the `GtkBuildable` interface supports a
// custom <attributes> element, which supports any number of <attribute>
// elements. The <attribute> element has attributes named name, value,
// start and end and allows you to specify Attribute values for this label.
// 
// An example of a UI definition fragment specifying Pango attributes: `xml
// <object class="GtkEnry"> <attributes> <attribute name="weight"
// value="PANGO_WEIGHT_BOLD"/> <attribute name="background" value="red"
// start="5" end="10"/> </attributes> </object> `
// 
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
// 
// 
// Accessibility
// 
// `GtkEntry` uses the GTK_ACCESSIBLE_ROLE_TEXT_BOX role.
	type Entry struct {
		Widget
		Accessible
		Buildable
		CellEditable
		ConstraintTarget
		Editable
		
	}

	// EntryClass is an interface that the Entry class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EntryClass interface {
		gextras.Objector
		_entry()
	}

	func (Entry) _entry() {}

	
	func marshalEntry(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEntry(obj), nil
	}
	

	
	// NewEntry creates a new entry.
	func NewEntry() Entry {
var _cret *C.GtkWidget // in

_cret = C.gtk_entry_new()


var _entry Entry // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_entry = Entry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _entry
}
	
	// NewEntryWithBuffer creates a new entry with the specified text buffer.
	func NewEntryWithBuffer(buffer EntryBufferClass) Entry {
var _arg1 *C.GtkEntryBuffer // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_entry_new_with_buffer(_arg1)


var _entry Entry // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_entry = Entry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _entry
}
	

	
	// ActivatesDefault retrieves the value set by
// gtk_entry_set_activates_default().
	func (e Entry) ActivatesDefault() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_activates_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Alignment gets the value set by gtk_entry_set_alignment().
// 
// See also: [property@Gtk.Editable:xalign]
	func (e Entry) Alignment() float32 {
var _arg0 *C.GtkEntry // out
var _cret C.float // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_alignment(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Attributes gets the attribute list of the `GtkEntry`.
// 
// See [method@Gtk.Entry.set_attributes].
	func (e Entry) Attributes() *pango.AttrList {
var _arg0 *C.GtkEntry // out
var _cret *C.PangoAttrList // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_attributes(_arg0)


var _attrList *pango.AttrList // out

_attrList = *(**pango.AttrList)(unsafe.Pointer(&_cret))

return _attrList
}
	
	// Buffer: get the `GtkEntryBuffer` object which holds the text for this widget.
	func (e Entry) Buffer() EntryBuffer {
var _arg0 *C.GtkEntry // out
var _cret *C.GtkEntryBuffer // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_buffer(_arg0)


var _entryBuffer EntryBuffer // out

_entryBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryBuffer)

return _entryBuffer
}
	
	// Completion returns the auxiliary completion object currently in use by
// @entry.
	func (e Entry) Completion() EntryCompletion {
var _arg0 *C.GtkEntry // out
var _cret *C.GtkEntryCompletion // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_completion(_arg0)


var _entryCompletion EntryCompletion // out

_entryCompletion = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryCompletion)

return _entryCompletion
}
	
	// CurrentIconDragSource returns the index of the icon which is the source of
// the current DND operation, or -1.
	func (e Entry) CurrentIconDragSource() int {
var _arg0 *C.GtkEntry // out
var _cret C.int // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_current_icon_drag_source(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ExtraMenu gets the menu model set with gtk_entry_set_extra_menu().
	func (e Entry) ExtraMenu() gio.MenuModel {
var _arg0 *C.GtkEntry // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_extra_menu(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// HasFrame gets the value set by gtk_entry_set_has_frame().
	func (e Entry) HasFrame() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_has_frame(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconActivatable returns whether the icon is activatable.
	func (e Entry) IconActivatable(iconPos EntryIconPosition) bool {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_activatable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconArea gets the area where entrys icon at @icon_pos is drawn.
// 
// This function is useful when drawing something to the entry in a draw
// callback.
// 
// If the entry is not realized or has no icon at the given position, @icon_area
// is filled with zeros. Otherwise, @icon_area will be filled with the icon's
// allocation, relative to @entry's allocation.
	func (e Entry) IconArea(iconPos EntryIconPosition) gdk.Rectangle {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _iconArea gdk.Rectangle

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

C.gtk_entry_get_icon_area(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_iconArea)))





return _iconArea
}
	
	// IconAtPos finds the icon at the given position and return its index.
// 
// The positions coordinates are relative to the @entrys top left corner. If
// @x, @y doesnt lie inside an icon, -1 is returned. This function is intended
// for use in a [signal@Gtk.Widget::query-tooltip] signal handler.
	func (e Entry) IconAtPos(x int, y int) int {
var _arg0 *C.GtkEntry // out
var _arg1 C.int // out
var _arg2 C.int // out
var _cret C.int // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)

_cret = C.gtk_entry_get_icon_at_pos(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IconGIcon retrieves the `GIcon` used for the icon.
// 
// nil will be returned if there is no icon or if the icon was set by some other
// method (e.g., by `GdkPaintable` or icon name).
	func (e Entry) IconGIcon(iconPos EntryIconPosition) gio.Icon {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_gicon(_arg0, _arg1)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// IconName retrieves the icon name used for the icon.
// 
// nil is returned if there is no icon or if the icon was set by some other
// method (e.g., by `GdkPaintable` or gicon).
	func (e Entry) IconName(iconPos EntryIconPosition) string {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.char // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_name(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IconPaintable retrieves the `GdkPaintable` used for the icon.
// 
// If no `GdkPaintable` was used for the icon, nil is returned.
	func (e Entry) IconPaintable(iconPos EntryIconPosition) gdk.Paintable {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_paintable(_arg0, _arg1)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// IconSensitive returns whether the icon appears sensitive or insensitive.
	func (e Entry) IconSensitive(iconPos EntryIconPosition) bool {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_sensitive(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconStorageType gets the type of representation being used by the icon to
// store image data.
// 
// If the icon has no image data, the return value will be GTK_IMAGE_EMPTY.
	func (e Entry) IconStorageType(iconPos EntryIconPosition) ImageType {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret C.GtkImageType // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_storage_type(_arg0, _arg1)


var _imageType ImageType // out

_imageType = ImageType(_cret)

return _imageType
}
	
	// IconTooltipMarkup gets the contents of the tooltip on the icon at the
// specified position in @entry.
	func (e Entry) IconTooltipMarkup(iconPos EntryIconPosition) string {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.char // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_tooltip_markup(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// IconTooltipText gets the contents of the tooltip on the icon at the specified
// position in @entry.
	func (e Entry) IconTooltipText(iconPos EntryIconPosition) string {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _cret *C.char // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)

_cret = C.gtk_entry_get_icon_tooltip_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// InputHints gets the input hints of this `GtkEntry`.
	func (e Entry) InputHints() InputHints {
var _arg0 *C.GtkEntry // out
var _cret C.GtkInputHints // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_input_hints(_arg0)


var _inputHints InputHints // out

_inputHints = InputHints(_cret)

return _inputHints
}
	
	// InputPurpose gets the input purpose of the `GtkEntry`.
	func (e Entry) InputPurpose() InputPurpose {
var _arg0 *C.GtkEntry // out
var _cret C.GtkInputPurpose // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_input_purpose(_arg0)


var _inputPurpose InputPurpose // out

_inputPurpose = InputPurpose(_cret)

return _inputPurpose
}
	
	// InvisibleChar retrieves the character displayed in place of the actual text
// in password mode.
	func (e Entry) InvisibleChar() uint32 {
var _arg0 *C.GtkEntry // out
var _cret C.gunichar // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_invisible_char(_arg0)


var _gunichar uint32 // out

_gunichar = (uint32)(_cret)

return _gunichar
}
	
	// MaxLength retrieves the maximum allowed length of the text in @entry.
// 
// See [method@Gtk.Entry.set_max_length].
	func (e Entry) MaxLength() int {
var _arg0 *C.GtkEntry // out
var _cret C.int // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_max_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// OverwriteMode gets whether the `GtkEntry` is in overwrite mode.
	func (e Entry) OverwriteMode() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_overwrite_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PlaceholderText retrieves the text that will be displayed when @entry is
// empty and unfocused
	func (e Entry) PlaceholderText() string {
var _arg0 *C.GtkEntry // out
var _cret *C.char // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_placeholder_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ProgressFraction returns the current fraction of the task thats been
// completed.
// 
// See [method@Gtk.Entry.set_progress_fraction].
	func (e Entry) ProgressFraction() float64 {
var _arg0 *C.GtkEntry // out
var _cret C.double // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_progress_fraction(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// ProgressPulseStep retrieves the pulse step set with
// gtk_entry_set_progress_pulse_step().
	func (e Entry) ProgressPulseStep() float64 {
var _arg0 *C.GtkEntry // out
var _cret C.double // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_progress_pulse_step(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Tabs gets the tabstops of the `GtkEntry.
// 
// See [method@Gtk.Entry.set_tabs].
	func (e Entry) Tabs() *pango.TabArray {
var _arg0 *C.GtkEntry // out
var _cret *C.PangoTabArray // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_tabs(_arg0)


var _tabArray *pango.TabArray // out

_tabArray = *(**pango.TabArray)(unsafe.Pointer(&_cret))

return _tabArray
}
	
	// TextLength retrieves the current length of the text in @entry.
// 
// This is equivalent to getting @entry's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.get_length] on it.
	func (e Entry) TextLength() uint16 {
var _arg0 *C.GtkEntry // out
var _cret C.guint16 // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_text_length(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// Visibility retrieves whether the text in @entry is visible.
// 
// See [method@Gtk.Entry.set_visibility].
	func (e Entry) Visibility() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_get_visibility(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GrabFocusWithoutSelecting causes @entry to have keyboard focus.
// 
// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't select
// the contents of the entry. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
	func (e Entry) GrabFocusWithoutSelecting() bool {
var _arg0 *C.GtkEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_entry_grab_focus_without_selecting(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ProgressPulse indicates that some progress is made, but you dont know how
// much.
// 
// Causes the entrys progress indicator to enter activity mode, where a block
// bounces back and forth. Each call to gtk_entry_progress_pulse() causes the
// block to move by a little bit (the amount of movement per pulse is determined
// by [method@Gtk.Entry.set_progress_pulse_step]).
	func (e Entry) ProgressPulse()  {
var _arg0 *C.GtkEntry // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_progress_pulse(_arg0)
}
	
	// ResetImContext: reset the input method context of the entry if needed.
// 
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
	func (e Entry) ResetImContext()  {
var _arg0 *C.GtkEntry // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_reset_im_context(_arg0)
}
	
	// SetActivatesDefault sets whether pressing Enter in the @entry will activate
// the default widget for the window containing the entry.
// 
// This usually means that the dialog containing the entry will be closed, since
// the default widget is usually one of the dialog buttons.
	func (e Entry) SetActivatesDefault(setting bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_entry_set_activates_default(_arg0, _arg1)
}
	
	// SetAlignment sets the alignment for the contents of the entry.
// 
// This controls the horizontal positioning of the contents when the displayed
// text is shorter than the width of the entry.
// 
// See also: [property@Gtk.Editable:xalign]
	func (e Entry) SetAlignment(xalign float32)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.float // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.float)(xalign)

C.gtk_entry_set_alignment(_arg0, _arg1)
}
	
	// SetAttributes sets a `PangoAttrList`.
// 
// The attributes in the list are applied to the entry text.
// 
// Since the attributes will be applies to text that changes as the user types,
// it makes most sense to use attributes with unlimited extent.
	func (e Entry) SetAttributes(attrs *pango.AttrList)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.PangoAttrList // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

C.gtk_entry_set_attributes(_arg0, _arg1)
}
	
	// SetBuffer: set the `GtkEntryBuffer` object which holds the text for this
// widget.
	func (e Entry) SetBuffer(buffer EntryBufferClass)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GtkEntryBuffer // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

C.gtk_entry_set_buffer(_arg0, _arg1)
}
	
	// SetCompletion sets @completion to be the auxiliary completion object to use
// with @entry.
// 
// All further configuration of the completion mechanism is done on @completion
// using the `GtkEntryCompletion` API. Completion is disabled if @completion is
// set to nil.
	func (e Entry) SetCompletion(completion EntryCompletionClass)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GtkEntryCompletion // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkEntryCompletion)(unsafe.Pointer(completion.Native()))

C.gtk_entry_set_completion(_arg0, _arg1)
}
	
	// SetExtraMenu sets a menu model to add when constructing the context menu for
// @entry.
	func (e Entry) SetExtraMenu(model gio.MenuModelClass)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.gtk_entry_set_extra_menu(_arg0, _arg1)
}
	
	// SetHasFrame sets whether the entry has a beveled frame around it.
	func (e Entry) SetHasFrame(setting bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_entry_set_has_frame(_arg0, _arg1)
}
	
	// SetIconActivatable sets whether the icon is activatable.
	func (e Entry) SetIconActivatable(iconPos EntryIconPosition, activatable bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
if activatable { _arg2 = C.TRUE }

C.gtk_entry_set_icon_activatable(_arg0, _arg1, _arg2)
}
	
	// SetIconDragSource sets up the icon at the given position as drag source.
// 
// This makes it so that GTK will start a drag operation when the user clicks
// and drags the icon.
	func (e Entry) SetIconDragSource(iconPos EntryIconPosition, provider gdk.ContentProviderClass, actions gdk.DragAction)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.GdkContentProvider // out
var _arg3 C.GdkDragAction // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.GdkContentProvider)(unsafe.Pointer(provider.Native()))
_arg3 = (C.GdkDragAction)(actions)

C.gtk_entry_set_icon_drag_source(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetIconFromGIcon sets the icon shown in the entry at the specified position
// from the current icon theme.
// 
// If the icon isnt known, a broken image icon will be displayed instead.
// 
// If @icon is nil, no icon will be shown in the specified position.
	func (e Entry) SetIconFromGIcon(iconPos EntryIconPosition, icon gio.Icon)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.GIcon // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_entry_set_icon_from_gicon(_arg0, _arg1, _arg2)
}
	
	// SetIconFromIconName sets the icon shown in the entry at the specified
// position from the current icon theme.
// 
// If the icon name isnt known, a broken image icon will be displayed
// instead.
// 
// If @icon_name is nil, no icon will be shown in the specified position.
	func (e Entry) SetIconFromIconName(iconPos EntryIconPosition, iconName string)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.char // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_set_icon_from_icon_name(_arg0, _arg1, _arg2)
}
	
	// SetIconFromPaintable sets the icon shown in the specified position using a
// `GdkPaintable`.
// 
// If @paintable is nil, no icon will be shown in the specified position.
	func (e Entry) SetIconFromPaintable(iconPos EntryIconPosition, paintable gdk.Paintable)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.GdkPaintable // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

C.gtk_entry_set_icon_from_paintable(_arg0, _arg1, _arg2)
}
	
	// SetIconSensitive sets the sensitivity for the specified icon.
	func (e Entry) SetIconSensitive(iconPos EntryIconPosition, sensitive bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
if sensitive { _arg2 = C.TRUE }

C.gtk_entry_set_icon_sensitive(_arg0, _arg1, _arg2)
}
	
	// SetIconTooltipMarkup sets @tooltip as the contents of the tooltip for the
// icon at the specified position.
// 
// @tooltip is assumed to be marked up with Pango Markup.
// 
// Use nil for @tooltip to remove an existing tooltip.
// 
// See also [method@Gtk.Widget.set_tooltip_markup] and
// [method@Gtk.Entry.set_icon_tooltip_text].
	func (e Entry) SetIconTooltipMarkup(iconPos EntryIconPosition, tooltip string)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.char // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.char)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_set_icon_tooltip_markup(_arg0, _arg1, _arg2)
}
	
	// SetIconTooltipText sets @tooltip as the contents of the tooltip for the icon
// at the specified position.
// 
// Use nil for @tooltip to remove an existing tooltip.
// 
// See also [method@Gtk.Widget.set_tooltip_text] and
// [method@Gtk.Entry.set_icon_tooltip_markup].
// 
// If you unset the widget tooltip via [method@Gtk.Widget.set_tooltip_text] or
// [method@Gtk.Widget.set_tooltip_markup], this sets
// [property@Gtk.Widget:has-tooltip] to false, which suppresses icon tooltips
// too. You can resolve this by then calling [method@Gtk.Widget.set_has_tooltip]
// to set [property@Gtk.Widget:has-tooltip] back to true, or setting at least
// one non-empty tooltip on any icon achieves the same result.
	func (e Entry) SetIconTooltipText(iconPos EntryIconPosition, tooltip string)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkEntryIconPosition // out
var _arg2 *C.char // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkEntryIconPosition)(iconPos)
_arg2 = (*C.char)(C.CString(tooltip))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_entry_set_icon_tooltip_text(_arg0, _arg1, _arg2)
}
	
	// SetInputHints: set additional hints which allow input methods to fine-tune
// their behavior.
	func (e Entry) SetInputHints(hints InputHints)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkInputHints // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkInputHints)(hints)

C.gtk_entry_set_input_hints(_arg0, _arg1)
}
	
	// SetInputPurpose sets the input purpose which can be used by input methods to
// adjust their behavior.
	func (e Entry) SetInputPurpose(purpose InputPurpose)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.GtkInputPurpose // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.GtkInputPurpose)(purpose)

C.gtk_entry_set_input_purpose(_arg0, _arg1)
}
	
	// SetInvisibleChar sets the character to use in place of the actual text in
// password mode.
// 
// See [method@Gtk.Entry.set_visibility] for how to enable password mode.
// 
// By default, GTK picks the best invisible char available in the current font.
// If you set the invisible char to 0, then the user will get no feedback at
// all; there will be no text on the screen as they type.
	func (e Entry) SetInvisibleChar(ch uint32)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gunichar // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.gunichar)(ch)

C.gtk_entry_set_invisible_char(_arg0, _arg1)
}
	
	// SetMaxLength sets the maximum allowed length of the contents of the widget.
// 
// If the current contents are longer than the given length, then they will be
// truncated to fit.
// 
// This is equivalent to getting @entry's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.set_max_length] on it.
	func (e Entry) SetMaxLength(max int)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.int // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.int)(max)

C.gtk_entry_set_max_length(_arg0, _arg1)
}
	
	// SetOverwriteMode sets whether the text is overwritten when typing in the
// `GtkEntry`.
	func (e Entry) SetOverwriteMode(overwrite bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if overwrite { _arg1 = C.TRUE }

C.gtk_entry_set_overwrite_mode(_arg0, _arg1)
}
	
	// SetPlaceholderText sets text to be displayed in @entry when it is empty.
// 
// This can be used to give a visual hint of the expected contents of the
// `GtkEntry`.
	func (e Entry) SetPlaceholderText(text string)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.char // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_entry_set_placeholder_text(_arg0, _arg1)
}
	
	// SetProgressFraction causes the entrys progress indicator to fill in the
// given fraction of the bar.
// 
// The fraction should be between 0.0 and 1.0, inclusive.
	func (e Entry) SetProgressFraction(fraction float64)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.double // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.double)(fraction)

C.gtk_entry_set_progress_fraction(_arg0, _arg1)
}
	
	// SetProgressPulseStep sets the fraction of total entry width to move the
// progress bouncing block for each pulse.
// 
// Use [method@Gtk.Entry.progress_pulse] to pulse the progress.
	func (e Entry) SetProgressPulseStep(fraction float64)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.double // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (C.double)(fraction)

C.gtk_entry_set_progress_pulse_step(_arg0, _arg1)
}
	
	// SetTabs sets a `PangoTabArray`.
// 
// The tabstops in the array are applied to the entry text.
	func (e Entry) SetTabs(tabs *pango.TabArray)  {
var _arg0 *C.GtkEntry // out
var _arg1 *C.PangoTabArray // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

C.gtk_entry_set_tabs(_arg0, _arg1)
}
	
	// SetVisibility sets whether the contents of the entry are visible or not.
// 
// When visibility is set to false, characters are displayed as the invisible
// char, and will also appear that way when the text in the entry widget is
// copied elsewhere.
// 
// By default, GTK picks the best invisible character available in the current
// font, but it can be changed with [method@Gtk.Entry.set_invisible_char].
// 
// Note that you probably want to set [property@Gtk.Entry:input-purpose] to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this entry, in addition to setting visibility to false.
	func (e Entry) SetVisibility(visible bool)  {
var _arg0 *C.GtkEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_entry_set_visibility(_arg0, _arg1)
}
	
	// UnsetInvisibleChar unsets the invisible char, so that the default invisible
// char is used again. See [method@Gtk.Entry.set_invisible_char].
	func (e Entry) UnsetInvisibleChar()  {
var _arg0 *C.GtkEntry // out

_arg0 = (*C.GtkEntry)(unsafe.Pointer(e.Native()))

C.gtk_entry_unset_invisible_char(_arg0)
}
	


	// EntryBuffer: a `GtkEntryBuffer` hold the text displayed in a `GtkText`
// widget.
// 
// A single `GtkEntryBuffer` object can be shared by multiple widgets which will
// then share the same text content, but not the cursor position, visibility
// attributes, icon etc.
// 
// `GtkEntryBuffer` may be derived from. Such a derived class might allow text
// to be stored in an alternate location, such as non-pageable memory, useful in
// the case of important passwords. Or a derived class could integrate with an
// applications concept of undo/redo.
	type EntryBuffer struct {
		**externglib.Object
		
	}

	// EntryBufferClass is an interface that the EntryBuffer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EntryBufferClass interface {
		gextras.Objector
		_entryBuffer()
	}

	func (EntryBuffer) _entryBuffer() {}

	
	func marshalEntryBuffer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEntryBuffer(obj), nil
	}
	

	
	// NewEntryBuffer: create a new `GtkEntryBuffer` object.
// 
// Optionally, specify initial text to set in the buffer.
	func NewEntryBuffer(initialChars string, nInitialChars int) EntryBuffer {
var _arg1 *C.char // out
var _arg2 C.int // out
var _cret *C.GtkEntryBuffer // in

_arg1 = (*C.char)(C.CString(initialChars))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(nInitialChars)

_cret = C.gtk_entry_buffer_new(_arg1, _arg2)


var _entryBuffer EntryBuffer // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_entryBuffer = EntryBuffer{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _entryBuffer
}
	

	
	// DeleteText deletes a sequence of characters from the buffer.
// 
// @n_chars characters are deleted starting at @position. If @n_chars is
// negative, then all characters until the end of the text are deleted.
// 
// If @position or @n_chars are out of bounds, then they are coerced to sane
// values.
// 
// Note that the positions are specified in characters, not bytes.
	func (b EntryBuffer) DeleteText(position uint, nChars int) uint {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 C.int // out
var _cret C.guint // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.int)(nChars)

_cret = C.gtk_entry_buffer_delete_text(_arg0, _arg1, _arg2)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// EmitDeletedText: used when subclassing `GtkEntryBuffer`.
	func (b EntryBuffer) EmitDeletedText(position uint, nChars uint)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(nChars)

C.gtk_entry_buffer_emit_deleted_text(_arg0, _arg1, _arg2)
}
	
	// EmitInsertedText: used when subclassing `GtkEntryBuffer`.
	func (b EntryBuffer) EmitInsertedText(position uint, chars string, nChars uint)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 *C.char // out
var _arg3 C.guint // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (*C.char)(C.CString(chars))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.guint)(nChars)

C.gtk_entry_buffer_emit_inserted_text(_arg0, _arg1, _arg2, _arg3)
}
	
	// Bytes retrieves the length in bytes of the buffer.
// 
// See [method@Gtk.EntryBuffer.get_length].
	func (b EntryBuffer) Bytes() uint {
var _arg0 *C.GtkEntryBuffer // out
var _cret C.gsize // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_bytes(_arg0)


var _gsize uint // out

_gsize = (uint)(_cret)

return _gsize
}
	
	// Length retrieves the length in characters of the buffer.
	func (b EntryBuffer) Length() uint {
var _arg0 *C.GtkEntryBuffer // out
var _cret C.guint // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_length(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MaxLength retrieves the maximum allowed length of the text in @buffer.
	func (b EntryBuffer) MaxLength() int {
var _arg0 *C.GtkEntryBuffer // out
var _cret C.int // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_max_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Text retrieves the contents of the buffer.
// 
// The memory pointer returned by this call will not change unless this object
// emits a signal, or is finalized.
	func (b EntryBuffer) Text() string {
var _arg0 *C.GtkEntryBuffer // out
var _cret *C.char // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_entry_buffer_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// InsertText inserts @n_chars characters of @chars into the contents of the
// buffer, at position @position.
// 
// If @n_chars is negative, then characters from chars will be inserted until a
// null-terminator is found. If @position or @n_chars are out of bounds, or the
// maximum buffer text length is exceeded, then they are coerced to sane values.
// 
// Note that the position and length are in characters, not in bytes.
	func (b EntryBuffer) InsertText(position uint, chars string, nChars int) uint {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.guint // out
var _arg2 *C.char // out
var _arg3 C.int // out
var _cret C.guint // in

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(position)
_arg2 = (*C.char)(C.CString(chars))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(nChars)

_cret = C.gtk_entry_buffer_insert_text(_arg0, _arg1, _arg2, _arg3)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SetMaxLength sets the maximum allowed length of the contents of the buffer.
// 
// If the current contents are longer than the given length, then they will be
// truncated to fit.
	func (b EntryBuffer) SetMaxLength(maxLength int)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 C.int // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.int)(maxLength)

C.gtk_entry_buffer_set_max_length(_arg0, _arg1)
}
	
	// SetText sets the text in the buffer.
// 
// This is roughly equivalent to calling [method@Gtk.EntryBuffer.delete_text]
// and [method@Gtk.EntryBuffer.insert_text].
// 
// Note that @n_chars is in characters, not in bytes.
	func (b EntryBuffer) SetText(chars string, nChars int)  {
var _arg0 *C.GtkEntryBuffer // out
var _arg1 *C.char // out
var _arg2 C.int // out

_arg0 = (*C.GtkEntryBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(chars))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(nChars)

C.gtk_entry_buffer_set_text(_arg0, _arg1, _arg2)
}
	


	// EntryCompletion: `GtkEntryCompletion` is an auxiliary object to provide
// completion functionality for `GtkEntry`.
// 
// It implements the [iface@Gtk.CellLayout] interface, to allow the user to add
// extra cells to the `GtkTreeView` with completion matches.
// 
// Completion functionality means that when the user modifies the text in the
// entry, `GtkEntryCompletion` checks which rows in the model match the current
// content of the entry, and displays a list of matches. By default, the
// matching is done by comparing the entry text case-insensitively against the
// text column of the model (see [method@Gtk.EntryCompletion.set_text_column]),
// but this can be overridden with a custom match function (see
// [method@Gtk.EntryCompletion.set_match_func]).
// 
// When the user selects a completion, the content of the entry is updated. By
// default, the content of the entry is replaced by the text column of the
// model, but this can be overridden by connecting to the
// [signal@Gtk.EntryCompletion::match-selected] signal and updating the entry in
// the signal handler. Note that you should return true from the signal handler
// to suppress the default behaviour.
// 
// To add completion functionality to an entry, use
// [method@Gtk.Entry.set_completion].
// 
// `GtkEntryCompletion` uses a [class@Gtk.TreeModelFilter] model to represent
// the subset of the entire model that is currently matching. While the
// `GtkEntryCompletion` signals [signal@Gtk.EntryCompletion::match-selected] and
// [signal@Gtk.EntryCompletion::cursor-on-match] take the original model and an
// iter pointing to that model as arguments, other callbacks and signals (such
// as `GtkCellLayoutDataFunc` or [signal@Gtk.CellArea::apply-attributes)] will
// generally take the filter model as argument. As long as you are only calling
// [method@Gtk.TreeModel.get], this will make no difference to you. If for some
// reason, you need the original model, use
// [method@Gtk.TreeModelFilter.get_model]. Dont forget to use
// [method@Gtk.TreeModelFilter.convert_iter_to_child_iter] to obtain a matching
// iter.
	type EntryCompletion struct {
		**externglib.Object
		Buildable
		CellLayout
		
	}

	// EntryCompletionClass is an interface that the EntryCompletion class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EntryCompletionClass interface {
		gextras.Objector
		_entryCompletion()
	}

	func (EntryCompletion) _entryCompletion() {}

	
	func marshalEntryCompletion(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEntryCompletion(obj), nil
	}
	

	
	// NewEntryCompletion creates a new `GtkEntryCompletion` object.
	func NewEntryCompletion() EntryCompletion {
var _cret *C.GtkEntryCompletion // in

_cret = C.gtk_entry_completion_new()


var _entryCompletion EntryCompletion // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_entryCompletion = EntryCompletion{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _entryCompletion
}
	
	// NewEntryCompletionWithArea creates a new `GtkEntryCompletion` object using
// the specified @area.
// 
// The `GtkCellArea` is used to layout cells in the underlying
// `GtkTreeViewColumn` for the drop-down menu.
	func NewEntryCompletionWithArea(area CellAreaClass) EntryCompletion {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkEntryCompletion // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_entry_completion_new_with_area(_arg1)


var _entryCompletion EntryCompletion // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_entryCompletion = EntryCompletion{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _entryCompletion
}
	

	
	// Complete requests a completion operation, or in other words a refiltering of
// the current list with completions, using the current key.
// 
// The completion list view will be updated accordingly.
	func (c EntryCompletion) Complete()  {
var _arg0 *C.GtkEntryCompletion // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

C.gtk_entry_completion_complete(_arg0)
}
	
	// ComputePrefix computes the common prefix that is shared by all rows in
// @completion that start with @key.
// 
// If no row matches @key, nil will be returned. Note that a text column must
// have been set for this function to work, see
// [method@Gtk.EntryCompletion.set_text_column] for details.
	func (c EntryCompletion) ComputePrefix(key string) string {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_entry_completion_compute_prefix(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// CompletionPrefix: get the original text entered by the user that triggered
// the completion or nil if theres no completion ongoing.
	func (c EntryCompletion) CompletionPrefix() string {
var _arg0 *C.GtkEntryCompletion // out
var _cret *C.char // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_completion_prefix(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Entry gets the entry @completion has been attached to.
	func (c EntryCompletion) Entry() Widget {
var _arg0 *C.GtkEntryCompletion // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_entry(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// InlineCompletion returns whether the common prefix of the possible
// completions should be automatically inserted in the entry.
	func (c EntryCompletion) InlineCompletion() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_inline_completion(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InlineSelection returns true if inline-selection mode is turned on.
	func (c EntryCompletion) InlineSelection() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_inline_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MinimumKeyLength returns the minimum key length as set for @completion.
	func (c EntryCompletion) MinimumKeyLength() int {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.int // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_minimum_key_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the model the `GtkEntryCompletion` is using as data source.
// 
// Returns nil if the model is unset.
	func (c EntryCompletion) Model() TreeModel {
var _arg0 *C.GtkEntryCompletion // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// PopupCompletion returns whether the completions should be presented in a
// popup window.
	func (c EntryCompletion) PopupCompletion() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_popup_completion(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PopupSetWidth returns whether the completion popup window will be resized to
// the width of the entry.
	func (c EntryCompletion) PopupSetWidth() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_popup_set_width(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PopupSingleMatch returns whether the completion popup window will appear even
// if there is only a single match.
	func (c EntryCompletion) PopupSingleMatch() bool {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_popup_single_match(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TextColumn returns the column in the model of @completion to get strings
// from.
	func (c EntryCompletion) TextColumn() int {
var _arg0 *C.GtkEntryCompletion // out
var _cret C.int // in

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

_cret = C.gtk_entry_completion_get_text_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InsertPrefix requests a prefix insertion.
	func (c EntryCompletion) InsertPrefix()  {
var _arg0 *C.GtkEntryCompletion // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))

C.gtk_entry_completion_insert_prefix(_arg0)
}
	
	// SetInlineCompletion sets whether the common prefix of the possible
// completions should be automatically inserted in the entry.
	func (c EntryCompletion) SetInlineCompletion(inlineCompletion bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if inlineCompletion { _arg1 = C.TRUE }

C.gtk_entry_completion_set_inline_completion(_arg0, _arg1)
}
	
	// SetInlineSelection sets whether it is possible to cycle through the possible
// completions inside the entry.
	func (c EntryCompletion) SetInlineSelection(inlineSelection bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if inlineSelection { _arg1 = C.TRUE }

C.gtk_entry_completion_set_inline_selection(_arg0, _arg1)
}
	
	// SetMinimumKeyLength requires the length of the search key for @completion to
// be at least @length.
// 
// This is useful for long lists, where completing using a small key takes a lot
// of time and will come up with meaningless results anyway (ie, a too large
// dataset).
	func (c EntryCompletion) SetMinimumKeyLength(length int)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.int // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(length)

C.gtk_entry_completion_set_minimum_key_length(_arg0, _arg1)
}
	
	// SetModel sets the model for a `GtkEntryCompletion`.
// 
// If @completion already has a model set, it will remove it before setting the
// new model. If model is nil, then it will unset the model.
	func (c EntryCompletion) SetModel(model TreeModel)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_entry_completion_set_model(_arg0, _arg1)
}
	
	// SetPopupCompletion sets whether the completions should be presented in a
// popup window.
	func (c EntryCompletion) SetPopupCompletion(popupCompletion bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if popupCompletion { _arg1 = C.TRUE }

C.gtk_entry_completion_set_popup_completion(_arg0, _arg1)
}
	
	// SetPopupSetWidth sets whether the completion popup window will be resized to
// be the same width as the entry.
	func (c EntryCompletion) SetPopupSetWidth(popupSetWidth bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if popupSetWidth { _arg1 = C.TRUE }

C.gtk_entry_completion_set_popup_set_width(_arg0, _arg1)
}
	
	// SetPopupSingleMatch sets whether the completion popup window will appear even
// if there is only a single match.
// 
// You may want to set this to false if you are using
// [property@Gtk.EntryCompletion:inline-completion].
	func (c EntryCompletion) SetPopupSingleMatch(popupSingleMatch bool)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
if popupSingleMatch { _arg1 = C.TRUE }

C.gtk_entry_completion_set_popup_single_match(_arg0, _arg1)
}
	
	// SetTextColumn: convenience function for setting up the most used case of this
// code: a completion list with just strings.
// 
// This function will set up @completion to have a list displaying all (and
// just) strings in the completion list, and to get those strings from @column
// in the model of @completion.
// 
// This functions creates and adds a `GtkCellRendererText` for the selected
// column. If you need to set the text column, but don't want the cell renderer,
// use g_object_set() to set the [property@Gtk.EntryCompletion:text-column]
// property directly.
	func (c EntryCompletion) SetTextColumn(column int)  {
var _arg0 *C.GtkEntryCompletion // out
var _arg1 C.int // out

_arg0 = (*C.GtkEntryCompletion)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(column)

C.gtk_entry_completion_set_text_column(_arg0, _arg1)
}
	


	// EventController: `GtkEventController` is the base class for event
// controllers.
// 
// These are ancillary objects associated to widgets, which react to
// `GdkEvents`, and possibly trigger actions as a consequence.
// 
// Event controllers are added to a widget with
// [method@Gtk.Widget.add_controller]. It is rarely necessary to explicitly
// remove a controller with [method@Gtk.Widget.remove_controller].
// 
// See the chapter of input handling (input-handling.html) for an overview of
// the basic concepts, such as the capture and bubble phases of even
// propagation.
	type EventController struct {
		**externglib.Object
		
	}

	// EventControllerClass is an interface that the EventController class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerClass interface {
		gextras.Objector
		_eventController()
	}

	func (EventController) _eventController() {}

	
	func marshalEventController(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventController(obj), nil
	}
	

	

	
	// CurrentEvent returns the event that is currently being handled by the
// controller, and nil at other times.
	func (c EventController) CurrentEvent() gdk.Event {
var _arg0 *C.GtkEventController // out
var _cret *C.GdkEvent // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_current_event(_arg0)


var _event gdk.Event // out

_event = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Event)

return _event
}
	
	// CurrentEventDevice returns the device of the event that is currently being
// handled by the controller, and nil otherwise.
	func (c EventController) CurrentEventDevice() gdk.Device {
var _arg0 *C.GtkEventController // out
var _cret *C.GdkDevice // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_current_event_device(_arg0)


var _device gdk.Device // out

_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

return _device
}
	
	// CurrentEventState returns the modifier state of the event that is currently
// being handled by the controller, and 0 otherwise.
	func (c EventController) CurrentEventState() gdk.ModifierType {
var _arg0 *C.GtkEventController // out
var _cret C.GdkModifierType // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_current_event_state(_arg0)


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}
	
	// CurrentEventTime returns the timestamp of the event that is currently being
// handled by the controller, and 0 otherwise.
	func (c EventController) CurrentEventTime() uint32 {
var _arg0 *C.GtkEventController // out
var _cret C.guint32 // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_current_event_time(_arg0)


var _guint32 uint32 // out

_guint32 = (uint32)(_cret)

return _guint32
}
	
	// Name gets the name of @controller.
	func (c EventController) Name() string {
var _arg0 *C.GtkEventController // out
var _cret *C.char // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PropagationLimit gets the propagation limit of the event controller.
	func (c EventController) PropagationLimit() PropagationLimit {
var _arg0 *C.GtkEventController // out
var _cret C.GtkPropagationLimit // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_propagation_limit(_arg0)


var _propagationLimit PropagationLimit // out

_propagationLimit = PropagationLimit(_cret)

return _propagationLimit
}
	
	// PropagationPhase gets the propagation phase at which @controller handles
// events.
	func (c EventController) PropagationPhase() PropagationPhase {
var _arg0 *C.GtkEventController // out
var _cret C.GtkPropagationPhase // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_propagation_phase(_arg0)


var _propagationPhase PropagationPhase // out

_propagationPhase = PropagationPhase(_cret)

return _propagationPhase
}
	
	// Widget returns the Widget this controller relates to.
	func (c EventController) Widget() Widget {
var _arg0 *C.GtkEventController // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Reset resets the @controller to a clean state.
	func (c EventController) Reset()  {
var _arg0 *C.GtkEventController // out

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))

C.gtk_event_controller_reset(_arg0)
}
	
	// SetName sets a name on the controller that can be used for debugging.
	func (c EventController) SetName(name string)  {
var _arg0 *C.GtkEventController // out
var _arg1 *C.char // out

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_event_controller_set_name(_arg0, _arg1)
}
	
	// SetPropagationLimit sets the event propagation limit on the event controller.
// 
// If the limit is set to GTK_LIMIT_SAME_NATIVE, the controller won't handle
// events that are targeted at widgets on a different surface, such as popovers.
	func (c EventController) SetPropagationLimit(limit PropagationLimit)  {
var _arg0 *C.GtkEventController // out
var _arg1 C.GtkPropagationLimit // out

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkPropagationLimit)(limit)

C.gtk_event_controller_set_propagation_limit(_arg0, _arg1)
}
	
	// SetPropagationPhase sets the propagation phase at which a controller handles
// events.
// 
// If @phase is GTK_PHASE_NONE, no automatic event handling will be performed,
// but other additional gesture maintenance will.
	func (c EventController) SetPropagationPhase(phase PropagationPhase)  {
var _arg0 *C.GtkEventController // out
var _arg1 C.GtkPropagationPhase // out

_arg0 = (*C.GtkEventController)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkPropagationPhase)(phase)

C.gtk_event_controller_set_propagation_phase(_arg0, _arg1)
}
	


	// EventControllerFocus: `GtkEventControllerFocus` is an event controller to
// keep track of keyboard focus.
// 
// The event controller offers [signal@Gtk.EventControllerFocus::enter] and
// [signal@Gtk.EventControllerFocus::leave] signals, as well as
// [property@Gtk.EventControllerFocus:is-focus] and
// [property@Gtk.EventControllerFocus:contains-focus] properties which are
// updated to reflect focus changes inside the widget hierarchy that is rooted
// at the controllers widget.
	type EventControllerFocus struct {
		EventController
		
	}

	// EventControllerFocusClass is an interface that the EventControllerFocus class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerFocusClass interface {
		gextras.Objector
		_eventControllerFocus()
	}

	func (EventControllerFocus) _eventControllerFocus() {}

	
	func marshalEventControllerFocus(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerFocus(obj), nil
	}
	

	
	// NewEventControllerFocus creates a new event controller that will handle focus
// events.
	func NewEventControllerFocus() EventControllerFocus {
var _cret *C.GtkEventController // in

_cret = C.gtk_event_controller_focus_new()


var _eventControllerFocus EventControllerFocus // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerFocus = EventControllerFocus{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerFocus
}
	

	
	// ContainsFocus returns true if focus is within @self or one of its children.
	func (s EventControllerFocus) ContainsFocus() bool {
var _arg0 *C.GtkEventControllerFocus // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventControllerFocus)(unsafe.Pointer(s.Native()))

_cret = C.gtk_event_controller_focus_contains_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFocus returns true if focus is within @self, but not one of its children.
	func (s EventControllerFocus) IsFocus() bool {
var _arg0 *C.GtkEventControllerFocus // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventControllerFocus)(unsafe.Pointer(s.Native()))

_cret = C.gtk_event_controller_focus_is_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// EventControllerKey: `GtkEventControllerKey` is an event controller that
// provides access to key events.
	type EventControllerKey struct {
		EventController
		
	}

	// EventControllerKeyClass is an interface that the EventControllerKey class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerKeyClass interface {
		gextras.Objector
		_eventControllerKey()
	}

	func (EventControllerKey) _eventControllerKey() {}

	
	func marshalEventControllerKey(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerKey(obj), nil
	}
	

	
	// NewEventControllerKey creates a new event controller that will handle key
// events.
	func NewEventControllerKey() EventControllerKey {
var _cret *C.GtkEventController // in

_cret = C.gtk_event_controller_key_new()


var _eventControllerKey EventControllerKey // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerKey = EventControllerKey{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerKey
}
	

	
	// Forward forwards the current event of this @controller to a @widget.
// 
// This function can only be used in handlers for the
// [signal@Gtk.EventControllerKey::key-pressed],
// [signal@Gtk.EventControllerKey::key-released] or
// [signal@Gtk.EventControllerKey::modifiers] signals.
	func (c EventControllerKey) Forward(widget WidgetClass) bool {
var _arg0 *C.GtkEventControllerKey // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_event_controller_key_forward(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Group gets the key group of the current event of this @controller.
// 
// See [method@Gdk.KeyEvent.get_layout].
	func (c EventControllerKey) Group() uint {
var _arg0 *C.GtkEventControllerKey // out
var _cret C.guint // in

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_key_get_group(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// ImContext gets the input method context of the key @controller.
	func (c EventControllerKey) ImContext() IMContext {
var _arg0 *C.GtkEventControllerKey // out
var _cret *C.GtkIMContext // in

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))

_cret = C.gtk_event_controller_key_get_im_context(_arg0)


var _imContext IMContext // out

_imContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(IMContext)

return _imContext
}
	
	// SetImContext sets the input method context of the key @controller.
	func (c EventControllerKey) SetImContext(imContext IMContextClass)  {
var _arg0 *C.GtkEventControllerKey // out
var _arg1 *C.GtkIMContext // out

_arg0 = (*C.GtkEventControllerKey)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkIMContext)(unsafe.Pointer(imContext.Native()))

C.gtk_event_controller_key_set_im_context(_arg0, _arg1)
}
	


	// EventControllerLegacy: `GtkEventControllerLegacy` is an event controller that
// provides raw access to the event stream.
// 
// It should only be used as a last resort if none of the other event
// controllers or gestures do the job.
	type EventControllerLegacy struct {
		EventController
		
	}

	// EventControllerLegacyClass is an interface that the EventControllerLegacy class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerLegacyClass interface {
		gextras.Objector
		_eventControllerLegacy()
	}

	func (EventControllerLegacy) _eventControllerLegacy() {}

	
	func marshalEventControllerLegacy(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerLegacy(obj), nil
	}
	

	
	// NewEventControllerLegacy creates a new legacy event controller.
	func NewEventControllerLegacy() EventControllerLegacy {
var _cret *C.GtkEventController // in

_cret = C.gtk_event_controller_legacy_new()


var _eventControllerLegacy EventControllerLegacy // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerLegacy = EventControllerLegacy{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerLegacy
}
	

	


	// EventControllerMotion: `GtkEventControllerMotion` is an event controller
// tracking the pointer position.
// 
// The event controller offers [signal@Gtk.EventControllerMotion::enter] and
// [signal@Gtk.EventControllerMotion::leave] signals, as well as
// [property@Gtk.EventControllerMotion:is-pointer] and
// [property@Gtk.EventControllerMotion:contains-pointer] properties which are
// updated to reflect changes in the pointer position as it moves over the
// widget.
	type EventControllerMotion struct {
		EventController
		
	}

	// EventControllerMotionClass is an interface that the EventControllerMotion class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerMotionClass interface {
		gextras.Objector
		_eventControllerMotion()
	}

	func (EventControllerMotion) _eventControllerMotion() {}

	
	func marshalEventControllerMotion(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerMotion(obj), nil
	}
	

	
	// NewEventControllerMotion creates a new event controller that will handle
// motion events.
	func NewEventControllerMotion() EventControllerMotion {
var _cret *C.GtkEventController // in

_cret = C.gtk_event_controller_motion_new()


var _eventControllerMotion EventControllerMotion // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerMotion = EventControllerMotion{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerMotion
}
	

	
	// ContainsPointer returns if a pointer is within @self or one of its children.
	func (s EventControllerMotion) ContainsPointer() bool {
var _arg0 *C.GtkEventControllerMotion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventControllerMotion)(unsafe.Pointer(s.Native()))

_cret = C.gtk_event_controller_motion_contains_pointer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsPointer returns if a pointer is within @self, but not one of its children.
	func (s EventControllerMotion) IsPointer() bool {
var _arg0 *C.GtkEventControllerMotion // out
var _cret C.gboolean // in

_arg0 = (*C.GtkEventControllerMotion)(unsafe.Pointer(s.Native()))

_cret = C.gtk_event_controller_motion_is_pointer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// EventControllerScroll: `GtkEventControllerScroll` is an event controller that
// handles scroll events.
// 
// It is capable of handling both discrete and continuous scroll events from
// mice or touchpads, abstracting them both with the
// [signal@Gtk.EventControllerScroll::scroll] signal. Deltas in the discrete
// case are multiples of 1.
// 
// In the case of continuous scroll events, `GtkEventControllerScroll` encloses
// all [signal@Gtk.EventControllerScroll::scroll] emissions between two
// [signal@Gtk.EventControllerScroll::scroll-begin] and
// [signal@Gtk.EventControllerScroll::scroll-end] signals.
// 
// The behavior of the event controller can be modified by the flags given at
// creation time, or modified at a later point through
// [method@Gtk.EventControllerScroll.set_flags] (e.g. because the scrolling
// conditions of the widget changed).
// 
// The controller can be set up to emit motion for either/both vertical and
// horizontal scroll events through GTK_EVENT_CONTROLLER_SCROLL_VERTICAL,
// GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL and
// GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES. If any axis is disabled, the
// respective [signal@Gtk.EventControllerScroll::scroll] delta will be 0.
// Vertical scroll events will be translated to horizontal motion for the
// devices incapable of horizontal scrolling.
// 
// The event controller can also be forced to emit discrete events on all
// devices through GTK_EVENT_CONTROLLER_SCROLL_DISCRETE. This can be used to
// implement discrete actions triggered through scroll events (e.g. switching
// across combobox options).
// 
// The GTK_EVENT_CONTROLLER_SCROLL_KINETIC flag toggles the emission of the
// [signal@Gtk.EventControllerScroll::decelerate] signal, emitted at the end of
// scrolling with two X/Y velocity arguments that are consistent with the motion
// that was received.
	type EventControllerScroll struct {
		EventController
		
	}

	// EventControllerScrollClass is an interface that the EventControllerScroll class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EventControllerScrollClass interface {
		gextras.Objector
		_eventControllerScroll()
	}

	func (EventControllerScroll) _eventControllerScroll() {}

	
	func marshalEventControllerScroll(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEventControllerScroll(obj), nil
	}
	

	
	// NewEventControllerScroll creates a new event controller that will handle
// scroll events.
	func NewEventControllerScroll(flags EventControllerScrollFlags) EventControllerScroll {
var _arg1 C.GtkEventControllerScrollFlags // out
var _cret *C.GtkEventController // in

_arg1 = (C.GtkEventControllerScrollFlags)(flags)

_cret = C.gtk_event_controller_scroll_new(_arg1)


var _eventControllerScroll EventControllerScroll // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_eventControllerScroll = EventControllerScroll{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _eventControllerScroll
}
	

	
	// Flags gets the flags conditioning the scroll controller behavior.
	func (s EventControllerScroll) Flags() EventControllerScrollFlags {
var _arg0 *C.GtkEventControllerScroll // out
var _cret C.GtkEventControllerScrollFlags // in

_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(s.Native()))

_cret = C.gtk_event_controller_scroll_get_flags(_arg0)


var _eventControllerScrollFlags EventControllerScrollFlags // out

_eventControllerScrollFlags = EventControllerScrollFlags(_cret)

return _eventControllerScrollFlags
}
	
	// SetFlags sets the flags conditioning scroll controller behavior.
	func (s EventControllerScroll) SetFlags(flags EventControllerScrollFlags)  {
var _arg0 *C.GtkEventControllerScroll // out
var _arg1 C.GtkEventControllerScrollFlags // out

_arg0 = (*C.GtkEventControllerScroll)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkEventControllerScrollFlags)(flags)

C.gtk_event_controller_scroll_set_flags(_arg0, _arg1)
}
	


	// EveryFilter: `GtkEveryFilter` matches an item when each of its filters
// matches.
// 
// To add filters to a `GtkEveryFilter`, use [method@Gtk.MultiFilter.append].
	type EveryFilter struct {
		MultiFilter
		gio.ListModel
		Buildable
		
	}

	// EveryFilterClass is an interface that the EveryFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type EveryFilterClass interface {
		gextras.Objector
		_everyFilter()
	}

	func (EveryFilter) _everyFilter() {}

	
	func marshalEveryFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapEveryFilter(obj), nil
	}
	

	
	// NewEveryFilter creates a new empty "every" filter.
// 
// Use [method@Gtk.MultiFilter.append] to add filters to it.
// 
// This filter matches an item if each of the filters added to it matches the
// item. In particular, this means that if no filter has been added to it, the
// filter matches every item.
	func NewEveryFilter() EveryFilter {
var _cret *C.GtkEveryFilter // in

_cret = C.gtk_every_filter_new()


var _everyFilter EveryFilter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_everyFilter = EveryFilter{
MultiFilter: MultiFilter{
Filter: Filter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _everyFilter
}
	

	


	// Expander: `GtkExpander` allows the user to reveal its child by clicking on an
// expander triangle.
// 
// !An example GtkExpander (expander.png)
// 
// This is similar to the triangles used in a `GtkTreeView`.
// 
// Normally you use an expander as you would use a frame; you create the child
// widget and use [method@Gtk.Expander.set_child] to add it to the expander.
// When the expander is toggled, it will take care of showing and hiding the
// child automatically.
// 
// 
// Special Usage
// 
// There are situations in which you may prefer to show and hide the expanded
// widget yourself, such as when you want to actually create the widget at
// expansion time. In this case, create a `GtkExpander` but do not add a child
// to it. The expander widget has an [property@Gtk.Expander:expanded[ property
// which can be used to monitor its expansion state. You should watch this
// property with a signal connection as follows:
// 
// `c static void expander_callback (GObject *object, GParamSpec *param_spec,
// gpointer user_data) { GtkExpander *expander;
// 
//    expander = GTK_EXPANDER (object);
// 
//    if (gtk_expander_get_expanded (expander))
//      {
//        // Show or create widgets
//      }
//    else
//      {
//        // Hide or destroy widgets
//      }
// 
// }
// 
// static void create_expander (void) { GtkWidget *expander =
// gtk_expander_new_with_mnemonic ("_More Options"); g_signal_connect (expander,
// "notify::expanded", G_CALLBACK (expander_callback), NULL);
// 
//    // ...
// 
// } `
// 
// 
// GtkExpander as GtkBuildable
// 
// The `GtkExpander` implementation of the `GtkBuildable` interface supports
// placing a child in the label position by specifying label as the type
// attribute of a <child> element. A normal content child can be specified
// without specifying a <child> type attribute.
// 
// An example of a UI definition fragment with GtkExpander:
// 
// `xml <object class="GtkExpander"> <child type="label"> <object
// class="GtkLabel" id="expander-label"/> </child> <child> <object
// class="GtkEntry" id="expander-content"/> </child> </object> `
// 
// 
// CSS nodes
// 
// ` expander  box  title   arrow   <label widget>  <child> `
// 
// `GtkExpander` has three CSS nodes, the main node with the name expander, a
// subnode with name title and node below it with name arrow. The arrow of an
// expander that is showing its child gets the :checked pseudoclass added to it.
// 
// 
// Accessibility
// 
// `GtkExpander` uses the GTK_ACCESSIBLE_ROLE_BUTTON role.
	type Expander struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// ExpanderClass is an interface that the Expander class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ExpanderClass interface {
		gextras.Objector
		_expander()
	}

	func (Expander) _expander() {}

	
	func marshalExpander(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapExpander(obj), nil
	}
	

	
	// NewExpander creates a new expander using @label as the text of the label.
	func NewExpander(label string) Expander {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_expander_new(_arg1)


var _expander Expander // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_expander = Expander{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _expander
}
	
	// NewExpanderWithMnemonic creates a new expander using @label as the text of
// the label.
// 
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use __ (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
// 
// Pressing Alt and that key activates the button.
	func NewExpanderWithMnemonic(label string) Expander {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_expander_new_with_mnemonic(_arg1)


var _expander Expander // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_expander = Expander{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _expander
}
	

	
	// Child gets the child widget of @expander.
	func (e Expander) Child() Widget {
var _arg0 *C.GtkExpander // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Expanded queries a Expander and returns its current state.
// 
// Returns true if the child widget is revealed.
	func (e Expander) Expanded() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_expanded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Label fetches the text from a label widget.
// 
// This is including any embedded underlines indicating mnemonics and Pango
// markup, as set by [method@Gtk.Expander.set_label]. If the label text has not
// been set the return value will be nil. This will be the case if you create an
// empty button with gtk_button_new() to use as a container.
	func (e Expander) Label() string {
var _arg0 *C.GtkExpander // out
var _cret *C.char // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LabelWidget retrieves the label widget for the frame.
	func (e Expander) LabelWidget() Widget {
var _arg0 *C.GtkExpander // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_label_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ResizeToplevel returns whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
	func (e Expander) ResizeToplevel() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_resize_toplevel(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseMarkup returns whether the labels text is interpreted as Pango markup.
	func (e Expander) UseMarkup() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_use_markup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseUnderline returns whether an underline in the text indicates a mnemonic.
	func (e Expander) UseUnderline() bool {
var _arg0 *C.GtkExpander // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))

_cret = C.gtk_expander_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetChild sets the child widget of @expander.
	func (e Expander) SetChild(child WidgetClass)  {
var _arg0 *C.GtkExpander // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_expander_set_child(_arg0, _arg1)
}
	
	// SetExpanded sets the state of the expander.
// 
// Set to true, if you want the child widget to be revealed, and false if you
// want the child widget to be hidden.
	func (e Expander) SetExpanded(expanded bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if expanded { _arg1 = C.TRUE }

C.gtk_expander_set_expanded(_arg0, _arg1)
}
	
	// SetLabel sets the text of the label of the expander to @label.
// 
// This will also clear any previously set labels.
	func (e Expander) SetLabel(label string)  {
var _arg0 *C.GtkExpander // out
var _arg1 *C.char // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_expander_set_label(_arg0, _arg1)
}
	
	// SetLabelWidget: set the label widget for the expander.
// 
// This is the widget that will appear embedded alongside the expander arrow.
	func (e Expander) SetLabelWidget(labelWidget WidgetClass)  {
var _arg0 *C.GtkExpander // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

C.gtk_expander_set_label_widget(_arg0, _arg1)
}
	
	// SetResizeToplevel sets whether the expander will resize the toplevel widget
// containing the expander upon resizing and collpasing.
	func (e Expander) SetResizeToplevel(resizeToplevel bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if resizeToplevel { _arg1 = C.TRUE }

C.gtk_expander_set_resize_toplevel(_arg0, _arg1)
}
	
	// SetUseMarkup sets whether the text of the label contains Pango markup.
	func (e Expander) SetUseMarkup(useMarkup bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if useMarkup { _arg1 = C.TRUE }

C.gtk_expander_set_use_markup(_arg0, _arg1)
}
	
	// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
	func (e Expander) SetUseUnderline(useUnderline bool)  {
var _arg0 *C.GtkExpander // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkExpander)(unsafe.Pointer(e.Native()))
if useUnderline { _arg1 = C.TRUE }

C.gtk_expander_set_use_underline(_arg0, _arg1)
}
	


	// FileChooserDialog: `GtkFileChooserDialog` is a dialog suitable for use with
// File Open or File Save commands.
// 
// !An example GtkFileChooserDialog (filechooser.png)
// 
// This widget works by putting a [class@Gtk.FileChooserWidget] inside a
// [class@Gtk.Dialog]. It exposes the [iface@Gtk.FileChooser] interface, so you
// can use all of the [iface@Gtk.FileChooser] functions on the file chooser
// dialog as well as those for [class@Gtk.Dialog].
// 
// Note that `GtkFileChooserDialog` does not have any methods of its own.
// Instead, you should use the functions that work on a [iface@Gtk.FileChooser].
// 
// If you want to integrate well with the platform you should use the
// [class@Gtk.FileChooserNative] API, which will use a platform-specific dialog
// if available and fall back to `GtkFileChooserDialog` otherwise.
// 
// 
// Typical usage
// 
// In the simplest of cases, you can the following code to use
// `GtkFileChooserDialog` to select a file for opening:
// 
// `c static void on_open_response (GtkDialog *dialog, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (dialog);
// 
//        g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
// 
//        open_file (file);
//      }
// 
//    gtk_window_destroy (GTK_WINDOW (dialog));
// 
// }
// 
//    // ...
//    GtkWidget *dialog;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
// 
//    dialog = gtk_file_chooser_dialog_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Open"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
// 
//    gtk_widget_show (dialog);
// 
//    g_signal_connect (dialog, "response",
//                      G_CALLBACK (on_open_response),
//                      NULL);
// 
// `
// 
// To use a dialog for saving, you can use this:
// 
// `c static void on_save_response (GtkDialog *dialog, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (dialog);
// 
//        g_autoptr(GFile) file = gtk_file_chooser_get_file (chooser);
// 
//        save_to_file (file);
//      }
// 
//    gtk_window_destroy (GTK_WINDOW (dialog));
// 
// }
// 
//    // ...
//    GtkWidget *dialog;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
// 
//    dialog = gtk_file_chooser_dialog_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          _("_Cancel"),
//                                          GTK_RESPONSE_CANCEL,
//                                          _("_Save"),
//                                          GTK_RESPONSE_ACCEPT,
//                                          NULL);
//    chooser = GTK_FILE_CHOOSER (dialog);
// 
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//    else
//      gtk_file_chooser_set_file (chooser, existing_filename);
// 
//    gtk_widget_show (dialog);
// 
//    g_signal_connect (dialog, "response",
//                      G_CALLBACK (on_save_response),
//                      NULL);
// 
// `
// 
// 
// Setting up a file chooser dialog
// 
// There are various cases in which you may need to use a
// `GtkFileChooserDialog`:
// 
// - To select a file for opening, use GTK_FILE_CHOOSER_ACTION_OPEN.
// 
// - To save a file for the first time, use GTK_FILE_CHOOSER_ACTION_SAVE, and
// suggest a name such as Untitled with
// [method@Gtk.FileChooser.set_current_name].
// 
// - To save a file under a different name, use GTK_FILE_CHOOSER_ACTION_SAVE,
// and set the existing file with [method@Gtk.FileChooser.set_file].
// 
// - To choose a folder instead of a filem use
// GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER.
// 
// In general, you should only cause the file chooser to show a specific folder
// when it is appropriate to use [method@Gtk,FileChooser.set_file], i.e. when
// you are doing a Save As command and you already have a file saved
// somewhere.
// 
// 
// Response Codes
// 
// `GtkFileChooserDialog` inherits from [class@Gtk.Dialog], so buttons that go
// in its action area have response codes such as GTK_RESPONSE_ACCEPT and
// GTK_RESPONSE_CANCEL. For example, you could call
// [ctor@Gtk.FileChooserDialog.new] as follows:
// 
// `c GtkWidget *dialog; GtkFileChooserAction action =
// GTK_FILE_CHOOSER_ACTION_OPEN;
// 
// dialog = gtk_file_chooser_dialog_new ("Open File", parent_window, action,
// _("_Cancel"), GTK_RESPONSE_CANCEL, _("_Open"), GTK_RESPONSE_ACCEPT, NULL); `
// 
// This will create buttons for Cancel and Open that use predefined response
// identifiers from [enum@Gtk.ResponseType]. For most dialog boxes you can use
// your own custom response codes rather than the ones in
// [enum@Gtk.ResponseType], but `GtkFileChooserDialog` assumes that its
// accept-type action, e.g. an Open or Save button, will have one of the
// following response codes:
// 
// - GTK_RESPONSE_ACCEPT - GTK_RESPONSE_OK - GTK_RESPONSE_YES -
// GTK_RESPONSE_APPLY
// 
// This is because `GtkFileChooserDialog` must intercept responses and switch to
// folders if appropriate, rather than letting the dialog terminate  the
// implementation uses these known response codes to know which responses can be
// blocked if appropriate.
// 
// To summarize, make sure you use a predefined response code when you use
// `GtkFileChooserDialog` to ensure proper operation.
	type FileChooserDialog struct {
		Dialog
		Accessible
		Buildable
		ConstraintTarget
		FileChooser
		Native
		Root
		ShortcutManager
		
	}

	// FileChooserDialogClass is an interface that the FileChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileChooserDialogClass interface {
		gextras.Objector
		_fileChooserDialog()
	}

	func (FileChooserDialog) _fileChooserDialog() {}

	
	func marshalFileChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileChooserDialog(obj), nil
	}
	

	

	


	// FileChooserNative: `GtkFileChooserNative` is an abstraction of a dialog
// suitable for use with File Open or File Save as commands.
// 
// By default, this just uses a `GtkFileChooserDialog` to implement the actual
// dialog. However, on some platforms, such as Windows and macOS, the native
// platform file chooser is used instead. When the application is running in a
// sandboxed environment without direct filesystem access (such as Flatpak),
// `GtkFileChooserNative` may call the proper APIs (portals) to let the user
// choose a file and make it available to the application.
// 
// While the API of `GtkFileChooserNative` closely mirrors
// `GtkFileChooserDialog`, the main difference is that there is no access to any
// `GtkWindow` or `GtkWidget` for the dialog. This is required, as there may not
// be one in the case of a platform native dialog.
// 
// Showing, hiding and running the dialog is handled by the
// [class@Gtk.NativeDialog] functions.
// 
// Note that unlike `GtkFileChooserDialog`, `GtkFileChooserNative` objects are
// not toplevel widgets, and GTK does not keep them alive. It is your
// responsibility to keep a reference until you are done with the object.
// 
// 
// Typical usage
// 
// In the simplest of cases, you can the following code to use
// `GtkFileChooserNative` to select a file for opening:
// 
// `c static void on_response (GtkNativeDialog *native, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (native); GFile *file = gtk_file_chooser_get_file (chooser);
// 
//        open_file (file);
// 
//        g_object_unref (file);
//      }
// 
//    g_object_unref (native);
// 
// }
// 
//    // ...
//    GtkFileChooserNative *native;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
// 
//    native = gtk_file_chooser_native_new ("Open File",
//                                          parent_window,
//                                          action,
//                                          "_Open",
//                                          "_Cancel");
// 
//    g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//    gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
// 
// `
// 
// To use a `GtkFileChooserNative` for saving, you can use this:
// 
// `c static void on_response (GtkNativeDialog *native, int response) { if
// (response == GTK_RESPONSE_ACCEPT) { GtkFileChooser *chooser =
// GTK_FILE_CHOOSER (native); GFile *file = gtk_file_chooser_get_file (chooser);
// 
//        save_to_file (file);
// 
//        g_object_unref (file);
//      }
// 
//    g_object_unref (native);
// 
// }
// 
//    // ...
//    GtkFileChooserNative *native;
//    GtkFileChooser *chooser;
//    GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_SAVE;
// 
//    native = gtk_file_chooser_native_new ("Save File",
//                                          parent_window,
//                                          action,
//                                          "_Save",
//                                          "_Cancel");
//    chooser = GTK_FILE_CHOOSER (native);
// 
//    if (user_edited_a_new_document)
//      gtk_file_chooser_set_current_name (chooser, _("Untitled document"));
//    else
//      gtk_file_chooser_set_file (chooser, existing_file, NULL);
// 
//    g_signal_connect (native, "response", G_CALLBACK (on_response), NULL);
//    gtk_native_dialog_show (GTK_NATIVE_DIALOG (native));
// 
// `
// 
// For more information on how to best set up a file dialog, see the
// [class@Gtk.FileChooserDialog] documentation.
// 
// 
// Response Codes
// 
// `GtkFileChooserNative` inherits from [class@Gtk.NativeDialog], which means it
// will return GTK_RESPONSE_ACCEPT if the user accepted, and GTK_RESPONSE_CANCEL
// if he pressed cancel. It can also return GTK_RESPONSE_DELETE_EVENT if the
// window was unexpectedly closed.
// 
// 
// Differences from FileChooserDialog
// 
// There are a few things in the [iface@Gtk.FileChooser] interface that are not
// possible to use with `GtkFileChooserNative`, as such use would prohibit the
// use of a native dialog.
// 
// No operations that change the dialog work while the dialog is visible. Set
// all the properties that are required before showing the dialog.
// 
// 
// Win32 details
// 
// On windows the `IFileDialog` implementation (added in Windows Vista) is used.
// It supports many of the features that `GtkFileChooser` has, but there are
// some things it does not handle:
// 
// * Any [class@Gtk.FileFilter] added using a mimetype
// 
// If any of these features are used the regular `GtkFileChooserDialog` will be
// used in place of the native one.
// 
// 
// Portal details
// 
// When the `org.freedesktop.portal.FileChooser` portal is available on the
// session bus, it is used to bring up an out-of-process file chooser. Depending
// on the kind of session the application is running in, this may or may not be
// a GTK file chooser.
// 
// macOS details
// 
// On macOS the `NSSavePanel` and `NSOpenPanel` classes are used to provide
// native file chooser dialogs. Some features provided by `GtkFileChooser` are
// not supported:
// 
// * Shortcut folders.
	type FileChooserNative struct {
		NativeDialog
		FileChooser
		
	}

	// FileChooserNativeClass is an interface that the FileChooserNative class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileChooserNativeClass interface {
		gextras.Objector
		_fileChooserNative()
	}

	func (FileChooserNative) _fileChooserNative() {}

	
	func marshalFileChooserNative(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileChooserNative(obj), nil
	}
	

	
	// NewFileChooserNative creates a new `GtkFileChooserNative`.
	func NewFileChooserNative(title string, parent WindowClass, action FileChooserAction, acceptLabel string, cancelLabel string) FileChooserNative {
var _arg1 *C.char // out
var _arg2 *C.GtkWindow // out
var _arg3 C.GtkFileChooserAction // out
var _arg4 *C.char // out
var _arg5 *C.char // out
var _cret *C.GtkFileChooserNative // in

_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))
_arg3 = (C.GtkFileChooserAction)(action)
_arg4 = (*C.char)(C.CString(acceptLabel))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.char)(C.CString(cancelLabel))
defer C.free(unsafe.Pointer(_arg5))

_cret = C.gtk_file_chooser_native_new(_arg1, _arg2, _arg3, _arg4, _arg5)


var _fileChooserNative FileChooserNative // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fileChooserNative = FileChooserNative{
NativeDialog: NativeDialog{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileChooser: FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileChooserNative
}
	

	
	// AcceptLabel retrieves the custom label text for the accept button.
	func (s FileChooserNative) AcceptLabel() string {
var _arg0 *C.GtkFileChooserNative // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

_cret = C.gtk_file_chooser_native_get_accept_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// CancelLabel retrieves the custom label text for the cancel button.
	func (s FileChooserNative) CancelLabel() string {
var _arg0 *C.GtkFileChooserNative // out
var _cret *C.char // in

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))

_cret = C.gtk_file_chooser_native_get_cancel_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetAcceptLabel sets the custom label text for the accept button.
// 
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use __ (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
// 
// Pressing Alt and that key should activate the button.
	func (s FileChooserNative) SetAcceptLabel(acceptLabel string)  {
var _arg0 *C.GtkFileChooserNative // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(acceptLabel))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_native_set_accept_label(_arg0, _arg1)
}
	
	// SetCancelLabel sets the custom label text for the cancel button.
// 
// If characters in @label are preceded by an underscore, they are underlined.
// If you need a literal underscore character in a label, use __ (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic.
// 
// Pressing Alt and that key should activate the button.
	func (s FileChooserNative) SetCancelLabel(cancelLabel string)  {
var _arg0 *C.GtkFileChooserNative // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileChooserNative)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(cancelLabel))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_chooser_native_set_cancel_label(_arg0, _arg1)
}
	


	// FileChooserWidget: `GtkFileChooserWidget` is a widget for choosing files.
// 
// It exposes the [iface@Gtk.FileChooser] interface, and you should use the
// methods of this interface to interact with the widget.
// 
// 
// CSS nodes
// 
// `GtkFileChooserWidget` has a single CSS node with name filechooser.
	type FileChooserWidget struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		FileChooser
		
	}

	// FileChooserWidgetClass is an interface that the FileChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileChooserWidgetClass interface {
		gextras.Objector
		_fileChooserWidget()
	}

	func (FileChooserWidget) _fileChooserWidget() {}

	
	func marshalFileChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileChooserWidget(obj), nil
	}
	

	
	// NewFileChooserWidget creates a new `GtkFileChooserWidget`.
// 
// This is a file chooser widget that can be embedded in custom windows, and it
// is the same widget that is used by `GtkFileChooserDialog`.
	func NewFileChooserWidget(action FileChooserAction) FileChooserWidget {
var _arg1 C.GtkFileChooserAction // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkFileChooserAction)(action)

_cret = C.gtk_file_chooser_widget_new(_arg1)


var _fileChooserWidget FileChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fileChooserWidget = FileChooserWidget{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FileChooser: FileChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileChooserWidget
}
	

	


	// FileFilter: `GtkFileFilter` filters files by name or mime type.
// 
// `GtkFileFilter` can be used to restrict the files being shown in a
// `GtkFileChooser`. Files can be filtered based on their name (with
// [method@Gtk.FileFilter.add_pattern]) or on their mime type (with
// [method@Gtk.FileFilter.add_mime_type]).
// 
// Filtering by mime types handles aliasing and subclassing of mime types; e.g.
// a filter for text/plain also matches a file with mime type application/rtf,
// since application/rtf is a subclass of text/plain. Note that `GtkFileFilter`
// allows wildcards for the subtype of a mime type, so you can e.g. filter for
// image/\*.
// 
// Normally, file filters are used by adding them to a `GtkFileChooser` (see
// [method@Gtk.FileChooser.add_filter]), but it is also possible to manually use
// a file filter on any [class@Gtk.FilterListModel] containing `GFileInfo`
// objects.
// 
// 
// GtkFileFilter as GtkBuildable
// 
// The `GtkFileFilter` implementation of the `GtkBuildable` interface supports
// adding rules using the <mime-types> and <patterns> elements and listing the
// rules within. Specifying a <mime-type> or <pattern> has the same effect as as
// calling [method@Gtk.FileFilter.add_mime_type] or
// [method@Gtk.FileFilter.add_pattern].
// 
// An example of a UI definition fragment specifying `GtkFileFilter` rules:
// `xml <object class="GtkFileFilter"> <property name="name"
// translatable="yes">Text and Images</property> <mime-types>
// <mime-type>text/plain</mime-type> <mime-type>image/ *</mime-type>
// </mime-types> <patterns> <pattern>*.txt</pattern> <pattern>*.png</pattern>
// </patterns> </object> `
	type FileFilter struct {
		Filter
		Buildable
		
	}

	// FileFilterClass is an interface that the FileFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FileFilterClass interface {
		gextras.Objector
		_fileFilter()
	}

	func (FileFilter) _fileFilter() {}

	
	func marshalFileFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFileFilter(obj), nil
	}
	

	
	// NewFileFilter creates a new `GtkFileFilter` with no rules added to it.
// 
// Such a filter doesnt accept any files, so is not particularly useful until
// you add rules with [method@Gtk.FileFilter.add_mime_type],
// [method@Gtk.FileFilter.add_pattern], or
// [method@Gtk.FileFilter.add_pixbuf_formats].
// 
// To create a filter that accepts any file, use: `c GtkFileFilter *filter =
// gtk_file_filter_new (); gtk_file_filter_add_pattern (filter, "*"); `
	func NewFileFilter() FileFilter {
var _cret *C.GtkFileFilter // in

_cret = C.gtk_file_filter_new()


var _fileFilter FileFilter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fileFilter = FileFilter{
Filter: Filter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileFilter
}
	
	// NewFileFilterFromGVariant: deserialize a file filter from a `GVariant`.
// 
// The variant must be in the format produced by
// [method@Gtk.FileFilter.to_gvariant].
	func NewFileFilterFromGVariant(variant *glib.Variant) FileFilter {
var _arg1 *C.GVariant // out
var _cret *C.GtkFileFilter // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_file_filter_new_from_gvariant(_arg1)


var _fileFilter FileFilter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fileFilter = FileFilter{
Filter: Filter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fileFilter
}
	

	
	// AddMIMEType adds a rule allowing a given mime type to @filter.
	func (f FileFilter) AddMIMEType(mimeType string)  {
var _arg0 *C.GtkFileFilter // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(mimeType))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_filter_add_mime_type(_arg0, _arg1)
}
	
	// AddPattern adds a rule allowing a shell style glob to a filter.
	func (f FileFilter) AddPattern(pattern string)  {
var _arg0 *C.GtkFileFilter // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(pattern))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_filter_add_pattern(_arg0, _arg1)
}
	
	// AddPixbufFormats adds a rule allowing image files in the formats supported by
// GdkPixbuf.
// 
// This is equivalent to calling [method@Gtk.FileFilter.add_mime_type] for all
// the supported mime types.
	func (f FileFilter) AddPixbufFormats()  {
var _arg0 *C.GtkFileFilter // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

C.gtk_file_filter_add_pixbuf_formats(_arg0)
}
	
	// Attributes gets the attributes that need to be filled in for the `GFileInfo`
// passed to this filter.
// 
// This function will not typically be used by applications; it is intended
// principally for use in the implementation of `GtkFileChooser`.
	func (f FileFilter) Attributes() []string {
var _arg0 *C.GtkFileFilter // out
var _cret **C.char

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_file_filter_get_attributes(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// Name gets the human-readable name for the filter.
// 
// See [method@Gtk.FileFilter.set_name].
	func (f FileFilter) Name() string {
var _arg0 *C.GtkFileFilter // out
var _cret *C.char // in

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_file_filter_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetName sets a human-readable name of the filter.
// 
// This is the string that will be displayed in the file chooser if there is a
// selectable list of filters.
	func (f FileFilter) SetName(name string)  {
var _arg0 *C.GtkFileFilter // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_file_filter_set_name(_arg0, _arg1)
}
	
	// ToGVariant: serialize a file filter to an `a{sv}` variant.
	func (f FileFilter) ToGVariant() *glib.Variant {
var _arg0 *C.GtkFileFilter // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkFileFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_file_filter_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	


	// Filter: a `GtkFilter` object describes the filtering to be performed by a
// `GtkFilterListModel`.
// 
// The model will use the filter to determine if it should include items or not
// by calling [method@Gtk.Filter.match] for each item and only keeping the ones
// that the function returns true for.
// 
// Filters may change what items they match through their lifetime. In that
// case, they will emit the [signal@Gtk.Filter::changed] signal to notify that
// previous filter results are no longer valid and that items should be checked
// again via [method@Gtk.Filter.match].
// 
// GTK provides various pre-made filter implementations for common filtering
// operations. These filters often include properties that can be linked to
// various widgets to easily allow searches.
// 
// However, in particular for large lists or complex search methods, it is also
// possible to subclass Filter and provide one's own filter.
	type Filter struct {
		**externglib.Object
		
	}

	// FilterClass is an interface that the Filter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FilterClass interface {
		gextras.Objector
		_filter()
	}

	func (Filter) _filter() {}

	
	func marshalFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFilter(obj), nil
	}
	

	

	
	// Changed emits the Filter::changed signal to notify all users of the filter
// that the filter changed. Users of the filter should then check items again
// via gtk_filter_match().
// 
// Depending on the @change parameter, not all items need to be changed, but
// only some. Refer to the FilterChange documentation for details.
// 
// This function is intended for implementors of Filter subclasses and should
// not be called from other functions.
	func (s Filter) Changed(change FilterChange)  {
var _arg0 *C.GtkFilter // out
var _arg1 C.GtkFilterChange // out

_arg0 = (*C.GtkFilter)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkFilterChange)(change)

C.gtk_filter_changed(_arg0, _arg1)
}
	
	// Strictness gets the known strictness of @filters. If the strictness is not
// known, GTK_FILTER_MATCH_SOME is returned.
// 
// This value may change after emission of the Filter::changed signal.
// 
// This function is meant purely for optimization purposes, filters can choose
// to omit implementing it, but FilterListModel uses it.
	func (s Filter) Strictness() FilterMatch {
var _arg0 *C.GtkFilter // out
var _cret C.GtkFilterMatch // in

_arg0 = (*C.GtkFilter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_filter_get_strictness(_arg0)


var _filterMatch FilterMatch // out

_filterMatch = FilterMatch(_cret)

return _filterMatch
}
	
	// Match checks if the given @item is matched by the filter or not.
	func (s Filter) Match(item **externglib.Object) bool {
var _arg0 *C.GtkFilter // out
var _arg1 C.gpointer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFilter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(item.Native()))

_cret = C.gtk_filter_match(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// FilterListModel: `GtkFilterListModel` is a list model that filters the
// elements of the underlying model according to a `GtkFilter`.
// 
// It hides some elements from the other model according to criteria given by a
// `GtkFilter`.
// 
// The model can be set up to do incremental searching, so that filtering long
// lists doesn't block the UI. See [method@Gtk.FilterListModel.set_incremental]
// for details.
	type FilterListModel struct {
		**externglib.Object
		gio.ListModel
		
	}

	// FilterListModelClass is an interface that the FilterListModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FilterListModelClass interface {
		gextras.Objector
		_filterListModel()
	}

	func (FilterListModel) _filterListModel() {}

	
	func marshalFilterListModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFilterListModel(obj), nil
	}
	

	
	// NewFilterListModel creates a new `GtkFilterListModel` that will filter @model
// using the given @filter.
	func NewFilterListModel(model gio.ListModel, filter FilterClass) FilterListModel {
var _arg1 *C.GListModel // out
var _arg2 *C.GtkFilter // out
var _cret *C.GtkFilterListModel // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.GtkFilter)(unsafe.Pointer(filter.Native()))

_cret = C.gtk_filter_list_model_new(_arg1, _arg2)


var _filterListModel FilterListModel // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_filterListModel = FilterListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _filterListModel
}
	

	
	// Filter gets the `GtkFilter` currently set on @self.
	func (s FilterListModel) Filter() Filter {
var _arg0 *C.GtkFilterListModel // out
var _cret *C.GtkFilter // in

_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_filter_list_model_get_filter(_arg0)


var _filter Filter // out

_filter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Filter)

return _filter
}
	
	// Incremental returns whether incremental filtering is enabled.
// 
// See [method@Gtk.FilterListModel.set_incremental].
	func (s FilterListModel) Incremental() bool {
var _arg0 *C.GtkFilterListModel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_filter_list_model_get_incremental(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Model gets the model currently filtered or nil if none.
	func (s FilterListModel) Model() gio.ListModel {
var _arg0 *C.GtkFilterListModel // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_filter_list_model_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Pending returns the number of items that have not been filtered yet.
// 
// You can use this value to check if @self is busy filtering by comparing the
// return value to 0 or you can compute the percentage of the filter remaining
// by dividing the return value by the total number of items in the underlying
// model:
// 
// `c pending = gtk_filter_list_model_get_pending (self); model =
// gtk_filter_list_model_get_model (self); percentage = pending / (double)
// g_list_model_get_n_items (model); `
// 
// If no filter operation is ongoing - in particular when
// [property@Gtk.FilterListModel:incremental] is false - this function returns
// 0.
	func (s FilterListModel) Pending() uint {
var _arg0 *C.GtkFilterListModel // out
var _cret C.guint // in

_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_filter_list_model_get_pending(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SetFilter sets the filter used to filter items.
	func (s FilterListModel) SetFilter(filter FilterClass)  {
var _arg0 *C.GtkFilterListModel // out
var _arg1 *C.GtkFilter // out

_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkFilter)(unsafe.Pointer(filter.Native()))

C.gtk_filter_list_model_set_filter(_arg0, _arg1)
}
	
	// SetIncremental sets the filter model to do an incremental sort.
// 
// When incremental filtering is enabled, the `GtkFilterListModel` will not run
// filters immediately, but will instead queue an idle handler that
// incrementally filters the items and adds them to the list. This of course
// means that items are not instantly added to the list, but only appear
// incrementally.
// 
// When your filter blocks the UI while filtering, you might consider turning
// this on. Depending on your model and filters, this may become interesting
// around 10,000 to 100,000 items.
// 
// By default, incremental filtering is disabled.
// 
// See [method@Gtk.FilterListModel.get_pending] for progress information about
// an ongoing incremental filtering operation.
	func (s FilterListModel) SetIncremental(incremental bool)  {
var _arg0 *C.GtkFilterListModel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))
if incremental { _arg1 = C.TRUE }

C.gtk_filter_list_model_set_incremental(_arg0, _arg1)
}
	
	// SetModel sets the model to be filtered.
// 
// Note that GTK makes no effort to ensure that @model conforms to the item type
// of @self. It assumes that the caller knows what they are doing and have set
// up an appropriate filter to ensure that item types match.
	func (s FilterListModel) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkFilterListModel // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkFilterListModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_filter_list_model_set_model(_arg0, _arg1)
}
	


	// Fixed: `GtkFixed` places its child widgets at fixed positions and with fixed
// sizes.
// 
// `GtkFixed` performs no automatic layout management.
// 
// For most applications, you should not use this container! It keeps you from
// having to learn about the other GTK containers, but it results in broken
// applications. With `GtkFixed`, the following things will result in truncated
// text, overlapping widgets, and other display bugs:
// 
// - Themes, which may change widget sizes.
// 
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
// 
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
// 
// In addition, `GtkFixed` does not pay attention to text direction and thus may
// produce unwanted results if your app is run under right-to-left languages
// such as Hebrew or Arabic. That is: normally GTK will order containers
// appropriately for the text direction, e.g. to put labels to the right of the
// thing they label when using an RTL language, but it cant do that with
// `GtkFixed`. So if you need to reorder widgets depending on the text
// direction, you would need to manually detect it and adjust child positions
// accordingly.
// 
// Finally, fixed positioning makes it kind of annoying to add/remove UI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
// 
// If you know none of these things are an issue for your application, and
// prefer the simplicity of `GtkFixed`, by all means use the widget. But you
// should be aware of the tradeoffs.
	type Fixed struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// FixedClass is an interface that the Fixed class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FixedClass interface {
		gextras.Objector
		_fixed()
	}

	func (Fixed) _fixed() {}

	
	func marshalFixed(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFixed(obj), nil
	}
	

	
	// NewFixed creates a new `GtkFixed`.
	func NewFixed() Fixed {
var _cret *C.GtkWidget // in

_cret = C.gtk_fixed_new()


var _fixed Fixed // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fixed = Fixed{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fixed
}
	

	
	// ChildPosition retrieves the translation transformation of the given child
// `GtkWidget` in the `GtkFixed`.
// 
// See also: [method@Gtk.Fixed.get_child_transform].
	func (f Fixed) ChildPosition(widget WidgetClass) (x float64, y float64) {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out
var _arg2 C.double // in
var _arg3 C.double // in

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_fixed_get_child_position(_arg0, _arg1, &_arg2, &_arg3)

var _x float64 // out
var _y float64 // out

_x = (float64)(_arg2)
_y = (float64)(_arg3)

return _x, _y
}
	
	// ChildTransform retrieves the transformation for @widget set using
// gtk_fixed_set_child_transform().
	func (f Fixed) ChildTransform(widget WidgetClass) *gsk.Transform {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out
var _cret *C.GskTransform // in

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_fixed_get_child_transform(_arg0, _arg1)


var _transform *gsk.Transform // out

_transform = *(**gsk.Transform)(unsafe.Pointer(&_cret))

return _transform
}
	
	// Move sets a translation transformation to the given @x and @y coordinates to
// the child @widget of the `GtkFixed`.
	func (f Fixed) Move(widget WidgetClass, x float64, y float64)  {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out
var _arg2 C.double // out
var _arg3 C.double // out

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.double)(x)
_arg3 = (C.double)(y)

C.gtk_fixed_move(_arg0, _arg1, _arg2, _arg3)
}
	
	// Put adds a widget to a `GtkFixed` at the given position.
	func (f Fixed) Put(widget WidgetClass, x float64, y float64)  {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out
var _arg2 C.double // out
var _arg3 C.double // out

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.double)(x)
_arg3 = (C.double)(y)

C.gtk_fixed_put(_arg0, _arg1, _arg2, _arg3)
}
	
	// Remove removes a child from @fixed.
	func (f Fixed) Remove(widget WidgetClass)  {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_fixed_remove(_arg0, _arg1)
}
	
	// SetChildTransform sets the transformation for @widget.
// 
// This is a convenience function that retrieves the
// [class@Gtk.FixedLayoutChild] instance associated to @widget and calls
// [method@Gtk.FixedLayoutChild.set_transform].
	func (f Fixed) SetChildTransform(widget WidgetClass, transform *gsk.Transform)  {
var _arg0 *C.GtkFixed // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GskTransform // out

_arg0 = (*C.GtkFixed)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

C.gtk_fixed_set_child_transform(_arg0, _arg1, _arg2)
}
	


	// FixedLayout: `GtkFixedLayout` is a layout manager which can place child
// widgets at fixed positions.
// 
// Most applications should never use this layout manager; fixed positioning and
// sizing requires constant recalculations on where children need to be
// positioned and sized. Other layout managers perform this kind of work
// internally so that application developers don't need to do it. Specifically,
// widgets positioned in a fixed layout manager will need to take into account:
// 
// - Themes, which may change widget sizes.
// 
// - Fonts other than the one you used to write the app will of course change
// the size of widgets containing text; keep in mind that users may use a larger
// font because of difficulty reading the default, or they may be using a
// different OS that provides different fonts.
// 
// - Translation of text into other languages changes its size. Also, display of
// non-English text will use a different font in many cases.
// 
// In addition, `GtkFixedLayout` does not pay attention to text direction and
// thus may produce unwanted results if your app is run under right-to-left
// languages such as Hebrew or Arabic. That is: normally GTK will order
// containers appropriately depending on the text direction, e.g. to put labels
// to the right of the thing they label when using an RTL language;
// `GtkFixedLayout` won't be able to do that for you.
// 
// Finally, fixed positioning makes it kind of annoying to add/remove UI
// elements, since you have to reposition all the other elements. This is a
// long-term maintenance problem for your application.
	type FixedLayout struct {
		LayoutManager
		
	}

	// FixedLayoutClass is an interface that the FixedLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FixedLayoutClass interface {
		gextras.Objector
		_fixedLayout()
	}

	func (FixedLayout) _fixedLayout() {}

	
	func marshalFixedLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFixedLayout(obj), nil
	}
	

	
	// NewFixedLayout creates a new `GtkFixedLayout`.
	func NewFixedLayout() FixedLayout {
var _cret *C.GtkLayoutManager // in

_cret = C.gtk_fixed_layout_new()


var _fixedLayout FixedLayout // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_fixedLayout = FixedLayout{
LayoutManager: LayoutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fixedLayout
}
	

	


	// FixedLayoutChild: `GtkLayoutChild` subclass for children in a
// `GtkFixedLayout`.
	type FixedLayoutChild struct {
		LayoutChild
		
	}

	// FixedLayoutChildClass is an interface that the FixedLayoutChild class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FixedLayoutChildClass interface {
		gextras.Objector
		_fixedLayoutChild()
	}

	func (FixedLayoutChild) _fixedLayoutChild() {}

	
	func marshalFixedLayoutChild(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFixedLayoutChild(obj), nil
	}
	

	

	
	// Transform retrieves the transformation of the child.
	func (c FixedLayoutChild) Transform() *gsk.Transform {
var _arg0 *C.GtkFixedLayoutChild // out
var _cret *C.GskTransform // in

_arg0 = (*C.GtkFixedLayoutChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_fixed_layout_child_get_transform(_arg0)


var _transform *gsk.Transform // out

_transform = *(**gsk.Transform)(unsafe.Pointer(&_cret))

return _transform
}
	
	// SetTransform sets the transformation of the child of a `GtkFixedLayout`.
	func (c FixedLayoutChild) SetTransform(transform *gsk.Transform)  {
var _arg0 *C.GtkFixedLayoutChild // out
var _arg1 *C.GskTransform // out

_arg0 = (*C.GtkFixedLayoutChild)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

C.gtk_fixed_layout_child_set_transform(_arg0, _arg1)
}
	


	// FlattenListModel: `GtkFlattenListModel` is a list model that concatenates
// other list models.
// 
// `GtkFlattenListModel` takes a list model containing list models, and flattens
// it into a single model.
	type FlattenListModel struct {
		**externglib.Object
		gio.ListModel
		
	}

	// FlattenListModelClass is an interface that the FlattenListModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FlattenListModelClass interface {
		gextras.Objector
		_flattenListModel()
	}

	func (FlattenListModel) _flattenListModel() {}

	
	func marshalFlattenListModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFlattenListModel(obj), nil
	}
	

	
	// NewFlattenListModel creates a new `GtkFlattenListModel` that flattens @list.
	func NewFlattenListModel(model gio.ListModel) FlattenListModel {
var _arg1 *C.GListModel // out
var _cret *C.GtkFlattenListModel // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_flatten_list_model_new(_arg1)


var _flattenListModel FlattenListModel // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_flattenListModel = FlattenListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _flattenListModel
}
	

	
	// Model gets the model set via gtk_flatten_list_model_set_model().
	func (s FlattenListModel) Model() gio.ListModel {
var _arg0 *C.GtkFlattenListModel // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_flatten_list_model_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// ModelForItem returns the model containing the item at the given position.
	func (s FlattenListModel) ModelForItem(position uint) gio.ListModel {
var _arg0 *C.GtkFlattenListModel // out
var _arg1 C.guint // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

_cret = C.gtk_flatten_list_model_get_model_for_item(_arg0, _arg1)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// SetModel sets a new model to be flattened.
	func (s FlattenListModel) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkFlattenListModel // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkFlattenListModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_flatten_list_model_set_model(_arg0, _arg1)
}
	


	// FlowBox: a `GtkFlowBox` puts child widgets in reflowing grid.
// 
// For instance, with the horizontal orientation, the widgets will be arranged
// from left to right, starting a new row under the previous row when necessary.
// Reducing the width in this case will require more rows, so a larger height
// will be requested.
// 
// Likewise, with the vertical orientation, the widgets will be arranged from
// top to bottom, starting a new column to the right when necessary. Reducing
// the height will require more columns, so a larger width will be requested.
// 
// The size request of a `GtkFlowBox` alone may not be what you expect; if you
// need to be able to shrink it along both axes and dynamically reflow its
// children, you may have to wrap it in a `GtkScrolledWindow` to enable that.
// 
// The children of a `GtkFlowBox` can be dynamically sorted and filtered.
// 
// Although a `GtkFlowBox` must have only `GtkFlowBoxChild` children, you can
// add any kind of widget to it via [method@Gtk.FlowBox.insert], and a
// `GtkFlowBoxChild` widget will automatically be inserted between the box and
// the widget.
// 
// Also see [class@Gtk.ListBox].
// 
// 
// CSS nodes
// 
// ` flowbox  flowboxchild   <child>  flowboxchild   <child> 
//  [rubberband] `
// 
// `GtkFlowBox` uses a single CSS node with name flowbox. `GtkFlowBoxChild` uses
// a single CSS node with name flowboxchild. For rubberband selection, a subnode
// with name rubberband is used.
// 
// 
// Accessibility
// 
// `GtkFlowBox` uses the GTK_ACCESSIBLE_ROLE_GRID role, and `GtkFlowBoxChild`
// uses the GTK_ACCESSIBLE_ROLE_GRID_CELL role.
	type FlowBox struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// FlowBoxClass is an interface that the FlowBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FlowBoxClass interface {
		gextras.Objector
		_flowBox()
	}

	func (FlowBox) _flowBox() {}

	
	func marshalFlowBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFlowBox(obj), nil
	}
	

	
	// NewFlowBox creates a `GtkFlowBox`.
	func NewFlowBox() FlowBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_flow_box_new()


var _flowBox FlowBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_flowBox = FlowBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _flowBox
}
	

	
	// ActivateOnSingleClick returns whether children activate on single clicks.
	func (b FlowBox) ActivateOnSingleClick() bool {
var _arg0 *C.GtkFlowBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildAtIndex gets the nth child in the @box.
	func (b FlowBox) ChildAtIndex(idx int) FlowBoxChild {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.int // out
var _cret *C.GtkFlowBoxChild // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.int)(idx)

_cret = C.gtk_flow_box_get_child_at_index(_arg0, _arg1)


var _flowBoxChild FlowBoxChild // out

_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

return _flowBoxChild
}
	
	// ChildAtPos gets the child in the (@x, @y) position.
// 
// Both @x and @y are assumed to be relative to the origin of @box.
	func (b FlowBox) ChildAtPos(x int, y int) FlowBoxChild {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.int // out
var _arg2 C.int // out
var _cret *C.GtkFlowBoxChild // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)

_cret = C.gtk_flow_box_get_child_at_pos(_arg0, _arg1, _arg2)


var _flowBoxChild FlowBoxChild // out

_flowBoxChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FlowBoxChild)

return _flowBoxChild
}
	
	// ColumnSpacing gets the horizontal spacing.
	func (b FlowBox) ColumnSpacing() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_column_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Homogeneous returns whether the box is homogeneous.
	func (b FlowBox) Homogeneous() bool {
var _arg0 *C.GtkFlowBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MaxChildrenPerLine gets the maximum number of children per line.
	func (b FlowBox) MaxChildrenPerLine() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_max_children_per_line(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MinChildrenPerLine gets the minimum number of children per line.
	func (b FlowBox) MinChildrenPerLine() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_min_children_per_line(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// RowSpacing gets the vertical spacing.
	func (b FlowBox) RowSpacing() uint {
var _arg0 *C.GtkFlowBox // out
var _cret C.guint // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_row_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SelectionMode gets the selection mode of @box.
	func (b FlowBox) SelectionMode() SelectionMode {
var _arg0 *C.GtkFlowBox // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_flow_box_get_selection_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// Insert inserts the @widget into @box at @position.
// 
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
// 
// If @position is -1, or larger than the total number of children in the @box,
// then the @widget will be appended to the end.
	func (b FlowBox) Insert(widget WidgetClass, position int)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.int)(position)

C.gtk_flow_box_insert(_arg0, _arg1, _arg2)
}
	
	// InvalidateFilter updates the filtering for all children.
// 
// Call this function when the result of the filter function on the @box is
// changed due ot an external factor. For instance, this would be used if the
// filter function just looked for a specific search term, and the entry with
// the string has changed.
	func (b FlowBox) InvalidateFilter()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_invalidate_filter(_arg0)
}
	
	// InvalidateSort updates the sorting for all children.
// 
// Call this when the result of the sort function on @box is changed due to an
// external factor.
	func (b FlowBox) InvalidateSort()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_invalidate_sort(_arg0)
}
	
	// Remove removes a child from @box.
	func (b FlowBox) Remove(widget WidgetClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_flow_box_remove(_arg0, _arg1)
}
	
	// SelectAll: select all children of @box, if the selection mode allows it.
	func (b FlowBox) SelectAll()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_select_all(_arg0)
}
	
	// SelectChild selects a single child of @box, if the selection mode allows it.
	func (b FlowBox) SelectChild(child FlowBoxChildClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkFlowBoxChild // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

C.gtk_flow_box_select_child(_arg0, _arg1)
}
	
	// SetActivateOnSingleClick: if @single is true, children will be activated when
// you click on them, otherwise you need to double-click.
	func (b FlowBox) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
if single { _arg1 = C.TRUE }

C.gtk_flow_box_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetColumnSpacing sets the horizontal space to add between children.
	func (b FlowBox) SetColumnSpacing(spacing uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_flow_box_set_column_spacing(_arg0, _arg1)
}
	
	// SetHAdjustment hooks up an adjustment to focus handling in @box.
// 
// The adjustment is also used for autoscrolling during rubberband selection.
// See [method@Gtk.ScrolledWindow.get_hadjustment] for a typical way of
// obtaining the adjustment, and [method@Gtk.FlowBox.set_vadjustment] for
// setting the vertical adjustment.
// 
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
	func (b FlowBox) SetHAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_flow_box_set_hadjustment(_arg0, _arg1)
}
	
	// SetHomogeneous sets whether or not all children of @box are given equal space
// in the box.
	func (b FlowBox) SetHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_flow_box_set_homogeneous(_arg0, _arg1)
}
	
	// SetMaxChildrenPerLine sets the maximum number of children to request and
// allocate space for in @boxs orientation.
// 
// Setting the maximum number of children per line limits the overall natural
// size request to be no more than @n_children children long in the given
// orientation.
	func (b FlowBox) SetMaxChildrenPerLine(nChildren uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(nChildren)

C.gtk_flow_box_set_max_children_per_line(_arg0, _arg1)
}
	
	// SetMinChildrenPerLine sets the minimum number of children to line up in
// @boxs orientation before flowing.
	func (b FlowBox) SetMinChildrenPerLine(nChildren uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(nChildren)

C.gtk_flow_box_set_min_children_per_line(_arg0, _arg1)
}
	
	// SetRowSpacing sets the vertical space to add between children.
	func (b FlowBox) SetRowSpacing(spacing uint)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.guint // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_flow_box_set_row_spacing(_arg0, _arg1)
}
	
	// SetSelectionMode sets how selection works in @box.
	func (b FlowBox) SetSelectionMode(mode SelectionMode)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkSelectionMode)(mode)

C.gtk_flow_box_set_selection_mode(_arg0, _arg1)
}
	
	// SetVAdjustment hooks up an adjustment to focus handling in @box.
// 
// The adjustment is also used for autoscrolling during rubberband selection.
// See [method@Gtk.ScrolledWindow.get_vadjustment] for a typical way of
// obtaining the adjustment, and [method@Gtk.FlowBox.set_hadjustment] for
// setting the horizontal adjustment.
// 
// The adjustments have to be in pixel units and in the same coordinate system
// as the allocation for immediate children of the box.
	func (b FlowBox) SetVAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_flow_box_set_vadjustment(_arg0, _arg1)
}
	
	// UnselectAll: unselect all children of @box, if the selection mode allows it.
	func (b FlowBox) UnselectAll()  {
var _arg0 *C.GtkFlowBox // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))

C.gtk_flow_box_unselect_all(_arg0)
}
	
	// UnselectChild unselects a single child of @box, if the selection mode allows
// it.
	func (b FlowBox) UnselectChild(child FlowBoxChildClass)  {
var _arg0 *C.GtkFlowBox // out
var _arg1 *C.GtkFlowBoxChild // out

_arg0 = (*C.GtkFlowBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkFlowBoxChild)(unsafe.Pointer(child.Native()))

C.gtk_flow_box_unselect_child(_arg0, _arg1)
}
	


	// FlowBoxChild: `GtkFlowBoxChild` is the kind of widget that can be added to a
// `GtkFlowBox`.
	type FlowBoxChild struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// FlowBoxChildClass is an interface that the FlowBoxChild class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FlowBoxChildClass interface {
		gextras.Objector
		_flowBoxChild()
	}

	func (FlowBoxChild) _flowBoxChild() {}

	
	func marshalFlowBoxChild(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFlowBoxChild(obj), nil
	}
	

	
	// NewFlowBoxChild creates a new `GtkFlowBoxChild`.
// 
// This should only be used as a child of a `GtkFlowBox`.
	func NewFlowBoxChild() FlowBoxChild {
var _cret *C.GtkWidget // in

_cret = C.gtk_flow_box_child_new()


var _flowBoxChild FlowBoxChild // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_flowBoxChild = FlowBoxChild{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _flowBoxChild
}
	

	
	// Changed marks @child as changed, causing any state that depends on this to be
// updated.
// 
// This affects sorting and filtering.
// 
// Note that calls to this method must be in sync with the data used for the
// sorting and filtering functions. For instance, if the list is mirroring some
// external data set, and *two* children changed in the external data set when
// you call gtk_flow_box_child_changed() on the first child, the sort function
// must only read the new data for the first of the two changed children,
// otherwise the resorting of the children will be wrong.
// 
// This generally means that if you dont fully control the data model, you have
// to duplicate the data that affects the sorting and filtering functions into
// the widgets themselves.
// 
// Another alternative is to call [method@Gtk.FlowBox.invalidate_sort] on any
// model change, but that is more expensive.
	func (c FlowBoxChild) Changed()  {
var _arg0 *C.GtkFlowBoxChild // out

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

C.gtk_flow_box_child_changed(_arg0)
}
	
	// Child gets the child widget of @self.
	func (s FlowBoxChild) Child() Widget {
var _arg0 *C.GtkFlowBoxChild // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(s.Native()))

_cret = C.gtk_flow_box_child_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Index gets the current index of the @child in its `GtkFlowBox` container.
	func (c FlowBoxChild) Index() int {
var _arg0 *C.GtkFlowBoxChild // out
var _cret C.int // in

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_flow_box_child_get_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsSelected returns whether the @child is currently selected in its
// `GtkFlowBox` container.
	func (c FlowBoxChild) IsSelected() bool {
var _arg0 *C.GtkFlowBoxChild // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_flow_box_child_is_selected(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetChild sets the child widget of @self.
	func (s FlowBoxChild) SetChild(child WidgetClass)  {
var _arg0 *C.GtkFlowBoxChild // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFlowBoxChild)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_flow_box_child_set_child(_arg0, _arg1)
}
	


	// FontButton: the `GtkFontButton` allows to open a font chooser dialog to
// change the font.
// 
// !An example GtkFontButton (font-button.png)
// 
// It is suitable widget for selecting a font in a preference dialog.
// 
// 
// CSS nodes
// 
// ` fontbutton  button.font  [content] `
// 
// `GtkFontButton` has a single CSS node with name fontbutton which contains a
// button node with the .font style class.
	type FontButton struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		FontChooser
		
	}

	// FontButtonClass is an interface that the FontButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontButtonClass interface {
		gextras.Objector
		_fontButton()
	}

	func (FontButton) _fontButton() {}

	
	func marshalFontButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontButton(obj), nil
	}
	

	
	// NewFontButton creates a new font picker widget.
	func NewFontButton() FontButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_font_button_new()


var _fontButton FontButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontButton = FontButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontButton
}
	
	// NewFontButtonWithFont creates a new font picker widget showing the given
// font.
	func NewFontButtonWithFont(fontname string) FontButton {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(fontname))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_font_button_new_with_font(_arg1)


var _fontButton FontButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontButton = FontButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontButton
}
	

	
	// Modal gets whether the dialog is modal.
	func (f FontButton) Modal() bool {
var _arg0 *C.GtkFontButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title retrieves the title of the font chooser dialog.
	func (f FontButton) Title() string {
var _arg0 *C.GtkFontButton // out
var _cret *C.char // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseFont returns whether the selected font is used in the label.
	func (f FontButton) UseFont() bool {
var _arg0 *C.GtkFontButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_use_font(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseSize returns whether the selected size is used in the label.
	func (f FontButton) UseSize() bool {
var _arg0 *C.GtkFontButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))

_cret = C.gtk_font_button_get_use_size(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetModal sets whether the dialog should be modal.
	func (f FontButton) SetModal(modal bool)  {
var _arg0 *C.GtkFontButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_font_button_set_modal(_arg0, _arg1)
}
	
	// SetTitle sets the title for the font chooser dialog.
	func (f FontButton) SetTitle(title string)  {
var _arg0 *C.GtkFontButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_font_button_set_title(_arg0, _arg1)
}
	
	// SetUseFont: if @use_font is true, the font name will be written using the
// selected font.
	func (f FontButton) SetUseFont(useFont bool)  {
var _arg0 *C.GtkFontButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
if useFont { _arg1 = C.TRUE }

C.gtk_font_button_set_use_font(_arg0, _arg1)
}
	
	// SetUseSize: if @use_size is true, the font name will be written using the
// selected size.
	func (f FontButton) SetUseSize(useSize bool)  {
var _arg0 *C.GtkFontButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkFontButton)(unsafe.Pointer(f.Native()))
if useSize { _arg1 = C.TRUE }

C.gtk_font_button_set_use_size(_arg0, _arg1)
}
	


	// FontChooserDialog: the `GtkFontChooserDialog` widget is a dialog for
// selecting a font.
// 
// !An example GtkFontChooserDialog (fontchooser.png)
// 
// `GtkFontChooserDialog` implements the [iface@Gtk.FontChooser] interface and
// does not provide much API of its own.
// 
// To create a `GtkFontChooserDialog`, use [ctor@Gtk.FontChooserDialog.new].
// 
// 
// GtkFontChooserDialog as GtkBuildable
// 
// The `GtkFontChooserDialog` implementation of the `GtkBuildable` interface
// exposes the buttons with the names select_button and cancel_button.
	type FontChooserDialog struct {
		Dialog
		Accessible
		Buildable
		ConstraintTarget
		FontChooser
		Native
		Root
		ShortcutManager
		
	}

	// FontChooserDialogClass is an interface that the FontChooserDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontChooserDialogClass interface {
		gextras.Objector
		_fontChooserDialog()
	}

	func (FontChooserDialog) _fontChooserDialog() {}

	
	func marshalFontChooserDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontChooserDialog(obj), nil
	}
	

	
	// NewFontChooserDialog creates a new `GtkFontChooserDialog`.
	func NewFontChooserDialog(title string, parent WindowClass) FontChooserDialog {
var _arg1 *C.char // out
var _arg2 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_font_chooser_dialog_new(_arg1, _arg2)


var _fontChooserDialog FontChooserDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontChooserDialog = FontChooserDialog{
Dialog: Dialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontChooserDialog
}
	

	


	// FontChooserWidget: the `GtkFontChooserWidget` widget lets the user select a
// font.
// 
// It is used in the `GtkFontChooserDialog` widget to provide a dialog for
// selecting fonts.
// 
// To set the font which is initially selected, use
// [method@Gtk.FontChooser.set_font] or [method@Gtk.FontChooser.set_font_desc].
// 
// To get the selected font use [method@Gtk.FontChooser.get_font] or
// [method@Gtk.FontChooser.get_font_desc].
// 
// To change the text which is shown in the preview area, use
// [method@Gtk.FontChooser.set_preview_text].
// 
// 
// CSS nodes
// 
// `GtkFontChooserWidget` has a single CSS node with name fontchooser.
	type FontChooserWidget struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		FontChooser
		
	}

	// FontChooserWidgetClass is an interface that the FontChooserWidget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FontChooserWidgetClass interface {
		gextras.Objector
		_fontChooserWidget()
	}

	func (FontChooserWidget) _fontChooserWidget() {}

	
	func marshalFontChooserWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFontChooserWidget(obj), nil
	}
	

	
	// NewFontChooserWidget creates a new `GtkFontChooserWidget`.
	func NewFontChooserWidget() FontChooserWidget {
var _cret *C.GtkWidget // in

_cret = C.gtk_font_chooser_widget_new()


var _fontChooserWidget FontChooserWidget // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_fontChooserWidget = FontChooserWidget{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
FontChooser: FontChooser{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _fontChooserWidget
}
	

	


	// Frame: `GtkFrame` is a widget that surrounds its child with a decorative
// frame and an optional label.
// 
// !An example GtkFrame (frame.png)
// 
// If present, the label is drawn inside the top edge of the frame. The
// horizontal position of the label can be controlled with
// [method@Gtk.Frame.set_label_align].
// 
// `GtkFrame` clips its child. You can use this to add rounded corners to
// widgets, but be aware that it also cuts off shadows.
// 
// 
// GtkFrame as GtkBuildable
// 
// The `GtkFrame` implementation of the `GtkBuildable` interface supports
// placing a child in the label position by specifying label as the type
// attribute of a <child> element. A normal content child can be specified
// without specifying a <child> type attribute.
// 
// An example of a UI definition fragment with GtkFrame: `xml <object
// class="GtkFrame"> <child type="label"> <object class="GtkLabel"
// id="frame_label"/> </child> <child> <object class="GtkEntry"
// id="frame_content"/> </child> </object> `
// 
// 
// CSS nodes
// 
// ` frame  <label widget>  <child> `
// 
// `GtkFrame` has a main CSS node with name frame, which is used to draw the
// visible border. You can set the appearance of the border using CSS properties
// like border-style on this node.
	type Frame struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// FrameClass is an interface that the Frame class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type FrameClass interface {
		gextras.Objector
		_frame()
	}

	func (Frame) _frame() {}

	
	func marshalFrame(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapFrame(obj), nil
	}
	

	
	// NewFrame creates a new `GtkFrame`, with optional label @label.
// 
// If @label is nil, the label is omitted.
	func NewFrame(label string) Frame {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_frame_new(_arg1)


var _frame Frame // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_frame = Frame{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _frame
}
	

	
	// Child gets the child widget of @frame.
	func (f Frame) Child() Widget {
var _arg0 *C.GtkFrame // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

_cret = C.gtk_frame_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Label returns the frame labels text.
// 
// If the frame's label widget is not a `GtkLabel`, nil is returned.
	func (f Frame) Label() string {
var _arg0 *C.GtkFrame // out
var _cret *C.char // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

_cret = C.gtk_frame_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// LabelAlign retrieves the X alignment of the frames label.
	func (f Frame) LabelAlign() float32 {
var _arg0 *C.GtkFrame // out
var _cret C.float // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

_cret = C.gtk_frame_get_label_align(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// LabelWidget retrieves the label widget for the frame.
	func (f Frame) LabelWidget() Widget {
var _arg0 *C.GtkFrame // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))

_cret = C.gtk_frame_get_label_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetChild sets the child widget of @frame.
	func (f Frame) SetChild(child WidgetClass)  {
var _arg0 *C.GtkFrame // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_frame_set_child(_arg0, _arg1)
}
	
	// SetLabel creates a new `GtkLabel` with the @label and sets it as the frame's
// label widget.
	func (f Frame) SetLabel(label string)  {
var _arg0 *C.GtkFrame // out
var _arg1 *C.char // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_frame_set_label(_arg0, _arg1)
}
	
	// SetLabelAlign sets the X alignment of the frame widgets label.
// 
// The default value for a newly created frame is 0.0.
	func (f Frame) SetLabelAlign(xalign float32)  {
var _arg0 *C.GtkFrame // out
var _arg1 C.float // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (C.float)(xalign)

C.gtk_frame_set_label_align(_arg0, _arg1)
}
	
	// SetLabelWidget sets the label widget for the frame.
// 
// This is the widget that will appear embedded in the top edge of the frame as
// a title.
	func (f Frame) SetLabelWidget(labelWidget WidgetClass)  {
var _arg0 *C.GtkFrame // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkFrame)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(labelWidget.Native()))

C.gtk_frame_set_label_widget(_arg0, _arg1)
}
	


	// GLArea: `GtkGLArea` is a widget that allows drawing with OpenGL.
// 
// !An example GtkGLArea (glarea.png)
// 
// `GtkGLArea` sets up its own [class@Gdk.GLContext], and creates a custom GL
// framebuffer that the widget will do GL rendering onto. It also ensures that
// this framebuffer is the default GL rendering target when rendering.
// 
// In order to draw, you have to connect to the [signal@Gtk.GLArea::render]
// signal, or subclass `GtkGLArea` and override the GtkGLAreaClass.render
// virtual function.
// 
// The `GtkGLArea` widget ensures that the `GdkGLContext` is associated with the
// widget's drawing area, and it is kept updated when the size and position of
// the drawing area changes.
// 
// 
// Drawing with GtkGLArea
// 
// The simplest way to draw using OpenGL commands in a `GtkGLArea` is to create
// a widget instance and connect to the [signal@Gtk.GLArea::render] signal:
// 
// The `render()` function will be called when the `GtkGLArea` is ready for you
// to draw its content:
// 
// `c static gboolean render (GtkGLArea *area, GdkGLContext *context) { //
// inside this function it's safe to use GL; the given // GLContext has been
// made current to the drawable // surface used by the `GtkGLArea` and the
// viewport has // already been set to be the size of the allocation
// 
//    // we can start by clearing the buffer
//    glClearColor (0, 0, 0, 0);
//    glClear (GL_COLOR_BUFFER_BIT);
// 
//    // draw your object
//    // draw_an_object ();
// 
//    // we completed our drawing; the draw commands will be
//    // flushed at the end of the signal emission chain, and
//    // the buffers will be drawn on the window
//    return TRUE;
// 
// }
// 
// void setup_glarea (void) { // create a GtkGLArea instance GtkWidget *gl_area
// = gtk_gl_area_new ();
// 
//    // connect to the "render" signal
//    g_signal_connect (gl_area, "render", G_CALLBACK (render), NULL);
// 
// } `
// 
// If you need to initialize OpenGL state, e.g. buffer objects or shaders, you
// should use the [signal@Gtk.Widget::realize] signal; you can use the
// [signal@Gtk.Widget::unrealize] signal to clean up. Since the `GdkGLContext`
// creation and initialization may fail, you will need to check for errors,
// using [method@Gtk.GLArea.get_error].
// 
// An example of how to safely initialize the GL state is:
// 
// `c static void on_realize (GtkGLarea *area) { // We need to make the context
// current if we want to // call GL API gtk_gl_area_make_current (area);
// 
//    // If there were errors during the initialization or
//    // when trying to make the context current, this
//    // function will return a #GError for you to catch
//    if (gtk_gl_area_get_error (area) != NULL)
//      return;
// 
//    // You can also use gtk_gl_area_set_error() in order
//    // to show eventual initialization errors on the
//    // GtkGLArea widget itself
//    GError *internal_error = NULL;
//    init_buffer_objects (&error);
//    if (error != NULL)
//      {
//        gtk_gl_area_set_error (area, error);
//        g_error_free (error);
//        return;
//      }
// 
//    init_shaders (&error);
//    if (error != NULL)
//      {
//        gtk_gl_area_set_error (area, error);
//        g_error_free (error);
//        return;
//      }
// 
// } `
// 
// If you need to change the options for creating the `GdkGLContext` you should
// use the [signal@Gtk.GLArea::create-context] signal.
	type GLArea struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// GLAreaClass is an interface that the GLArea class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GLAreaClass interface {
		gextras.Objector
		_glArea()
	}

	func (GLArea) _glArea() {}

	
	func marshalGLArea(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGLArea(obj), nil
	}
	

	
	// NewGLArea creates a new `GtkGLArea` widget.
	func NewGLArea() GLArea {
var _cret *C.GtkWidget // in

_cret = C.gtk_gl_area_new()


var _glArea GLArea // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_glArea = GLArea{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _glArea
}
	

	
	// AttachBuffers binds buffers to the framebuffer.
// 
// Ensures that the @area framebuffer object is made the current draw and read
// target, and that all the required buffers for the @area are created and bound
// to the framebuffer.
// 
// This function is automatically called before emitting the
// [signal@Gtk.GLArea::render] signal, and doesn't normally need to be called by
// application code.
	func (a GLArea) AttachBuffers()  {
var _arg0 *C.GtkGLArea // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_attach_buffers(_arg0)
}
	
	// AutoRender returns whether the area is in auto render mode or not.
	func (a GLArea) AutoRender() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_auto_render(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Context retrieves the `GdkGLContext` used by @area.
	func (a GLArea) Context() gdk.GLContext {
var _arg0 *C.GtkGLArea // out
var _cret *C.GdkGLContext // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_context(_arg0)


var _glContext gdk.GLContext // out

_glContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.GLContext)

return _glContext
}
	
	// Error gets the current error set on the @area.
	func (a GLArea) Error() error {
var _arg0 *C.GtkGLArea // out
var _cret *C.GError // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_error(_arg0)


var _err error // out

_err = gerror.Take(unsafe.Pointer(_cret))

return _err
}
	
	// HasDepthBuffer returns whether the area has a depth buffer.
	func (a GLArea) HasDepthBuffer() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_has_depth_buffer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasStencilBuffer returns whether the area has a stencil buffer.
	func (a GLArea) HasStencilBuffer() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_has_stencil_buffer(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RequiredVersion retrieves the required version of OpenGL.
// 
// See [method@Gtk.GLArea.set_required_version].
	func (a GLArea) RequiredVersion() (major int, minor int) {
var _arg0 *C.GtkGLArea // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_get_required_version(_arg0, &_arg1, &_arg2)

var _major int // out
var _minor int // out

_major = (int)(_arg1)
_minor = (int)(_arg2)

return _major, _minor
}
	
	// UseES returns whether the `GtkGLArea` should use OpenGL ES.
// 
// See [method@Gtk.GLArea.set_use_es].
	func (a GLArea) UseES() bool {
var _arg0 *C.GtkGLArea // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

_cret = C.gtk_gl_area_get_use_es(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MakeCurrent ensures that the `GdkGLContext` used by @area is associated with
// the `GtkGLArea`.
// 
// This function is automatically called before emitting the
// [signal@Gtk.GLArea::render] signal, and doesn't normally need to be called by
// application code.
	func (a GLArea) MakeCurrent()  {
var _arg0 *C.GtkGLArea // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_make_current(_arg0)
}
	
	// QueueRender marks the currently rendered data (if any) as invalid, and queues
// a redraw of the widget.
// 
// This ensures that the [signal@Gtk.GLArea::render] signal is emitted during
// the draw.
// 
// This is only needed when [method@Gtk.GLArea.set_auto_render] has been called
// with a false value. The default behaviour is to emit
// [signal@Gtk.GLArea::render] on each draw.
	func (a GLArea) QueueRender()  {
var _arg0 *C.GtkGLArea // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))

C.gtk_gl_area_queue_render(_arg0)
}
	
	// SetAutoRender sets whether the `GtkGLArea` is in auto render mode.
// 
// If @auto_render is true the [signal@Gtk.GLArea::render] signal will be
// emitted every time the widget draws. This is the default and is useful if
// drawing the widget is faster.
// 
// If @auto_render is false the data from previous rendering is kept around and
// will be used for drawing the widget the next time, unless the window is
// resized. In order to force a rendering [method@Gtk.GLArea.queue_render] must
// be called. This mode is useful when the scene changes seldom, but takes a
// long time to redraw.
	func (a GLArea) SetAutoRender(autoRender bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if autoRender { _arg1 = C.TRUE }

C.gtk_gl_area_set_auto_render(_arg0, _arg1)
}
	
	// SetError sets an error on the area which will be shown instead of the GL
// rendering.
// 
// This is useful in the [signal@Gtk.GLArea::create-context] signal if GL
// context creation fails.
	func (a GLArea) SetError(err error)  {
var _arg0 *C.GtkGLArea // out
var _arg1 *C.GError // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))
defer C.g_error_free(_arg1)

C.gtk_gl_area_set_error(_arg0, _arg1)
}
	
	// SetHasDepthBuffer sets whether the `GtkGLArea` should use a depth buffer.
// 
// If @has_depth_buffer is true the widget will allocate and enable a depth
// buffer for the target framebuffer. Otherwise there will be none.
	func (a GLArea) SetHasDepthBuffer(hasDepthBuffer bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if hasDepthBuffer { _arg1 = C.TRUE }

C.gtk_gl_area_set_has_depth_buffer(_arg0, _arg1)
}
	
	// SetHasStencilBuffer sets whether the `GtkGLArea` should use a stencil buffer.
// 
// If @has_stencil_buffer is true the widget will allocate and enable a stencil
// buffer for the target framebuffer. Otherwise there will be none.
	func (a GLArea) SetHasStencilBuffer(hasStencilBuffer bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if hasStencilBuffer { _arg1 = C.TRUE }

C.gtk_gl_area_set_has_stencil_buffer(_arg0, _arg1)
}
	
	// SetRequiredVersion sets the required version of OpenGL to be used when
// creating the context for the widget.
// 
// This function must be called before the area has been realized.
	func (a GLArea) SetRequiredVersion(major int, minor int)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
_arg1 = (C.int)(major)
_arg2 = (C.int)(minor)

C.gtk_gl_area_set_required_version(_arg0, _arg1, _arg2)
}
	
	// SetUseES sets whether the @area should create an OpenGL or an OpenGL ES
// context.
// 
// You should check the capabilities of the GLContext before drawing with either
// API.
	func (a GLArea) SetUseES(useEs bool)  {
var _arg0 *C.GtkGLArea // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGLArea)(unsafe.Pointer(a.Native()))
if useEs { _arg1 = C.TRUE }

C.gtk_gl_area_set_use_es(_arg0, _arg1)
}
	


	// Gesture: `GtkGesture` is the base class for gesture recognition.
// 
// Although `GtkGesture` is quite generalized to serve as a base for multi-touch
// gestures, it is suitable to implement single-touch and pointer-based gestures
// (using the special nil `GdkEventSequence` value for these).
// 
// The number of touches that a `GtkGesture` need to be recognized is controlled
// by the [property@Gtk.Gesture:n-points] property, if a gesture is keeping
// track of less or more than that number of sequences, it won't check whether
// the gesture is recognized.
// 
// As soon as the gesture has the expected number of touches, it will check
// regularly if it is recognized, the criteria to consider a gesture as
// "recognized" is left to `GtkGesture` subclasses.
// 
// A recognized gesture will then emit the following signals:
// 
// - [signal@Gtk.Gesture::begin] when the gesture is recognized. -
// [signal@Gtk.Gesture::update], whenever an input event is processed. -
// [signal@Gtk.Gesture::end] when the gesture is no longer recognized.
// 
// 
// Event propagation
// 
// In order to receive events, a gesture needs to set a propagation phase
// through [method@Gtk.EventController.set_propagation_phase].
// 
// In the capture phase, events are propagated from the toplevel down to the
// target widget, and gestures that are attached to containers above the widget
// get a chance to interact with the event before it reaches the target.
// 
// In the bubble phase, events are propagated up from the target widget to the
// toplevel, and gestures that are attached to containers above the widget get a
// chance to interact with events that have not been handled yet.
// 
// 
// States of a sequence
// 
// Whenever input interaction happens, a single event may trigger a cascade of
// `GtkGesture`s, both across the parents of the widget receiving the event and
// in parallel within an individual widget. It is a responsibility of the
// widgets using those gestures to set the state of touch sequences accordingly
// in order to enable cooperation of gestures around the `GdkEventSequence`s
// triggering those.
// 
// Within a widget, gestures can be grouped through [method@Gtk.Gesture.group].
// Grouped gestures synchronize the state of sequences, so calling
// [method@Gtk.Gesture.set_sequence_state] on one will effectively propagate the
// state throughout the group.
// 
// By default, all sequences start out in the GTK_EVENT_SEQUENCE_NONE state,
// sequences in this state trigger the gesture event handler, but event
// propagation will continue unstopped by gestures.
// 
// If a sequence enters into the GTK_EVENT_SEQUENCE_DENIED state, the gesture
// group will effectively ignore the sequence, letting events go unstopped
// through the gesture, but the "slot" will still remain occupied while the
// touch is active.
// 
// If a sequence enters in the GTK_EVENT_SEQUENCE_CLAIMED state, the gesture
// group will grab all interaction on the sequence, by:
// 
// - Setting the same sequence to GTK_EVENT_SEQUENCE_DENIED on every other
// gesture group within the widget, and every gesture on parent widgets in the
// propagation chain. - Emitting [signal@Gtk.Gesture::cancel] on every gesture
// in widgets underneath in the propagation chain. - Stopping event propagation
// after the gesture group handles the event.
// 
// Note: if a sequence is set early to GTK_EVENT_SEQUENCE_CLAIMED on
// GDK_TOUCH_BEGIN/GDK_BUTTON_PRESS (so those events are captured before
// reaching the event widget, this implies GTK_PHASE_CAPTURE), one similar event
// will emulated if the sequence changes to GTK_EVENT_SEQUENCE_DENIED. This way
// event coherence is preserved before event propagation is unstopped again.
// 
// Sequence states can't be changed freely. See
// [method@Gtk.Gesture.set_sequence_state] to know about the possible lifetimes
// of a `GdkEventSequence`.
// 
// 
// Touchpad gestures
// 
// On the platforms that support it, `GtkGesture` will handle transparently
// touchpad gesture events. The only precautions users of `GtkGesture` should do
// to enable this support are:
// 
// - If the gesture has GTK_PHASE_NONE, ensuring events of type
// GDK_TOUCHPAD_SWIPE and GDK_TOUCHPAD_PINCH are handled by the `GtkGesture`
	type Gesture struct {
		EventController
		
	}

	// GestureClass is an interface that the Gesture class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureClass interface {
		gextras.Objector
		_gesture()
	}

	func (Gesture) _gesture() {}

	
	func marshalGesture(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGesture(obj), nil
	}
	

	

	
	// BoundingBox: if there are touch sequences being currently handled by
// @gesture, returns true and fills in @rect with the bounding box containing
// all active touches.
// 
// Otherwise, false will be returned.
// 
// Note: This function will yield unexpected results on touchpad gestures. Since
// there is no correlation between physical and pixel distances, these will look
// as if constrained in an infinitely small area, @rect width and height will
// thus be 0 regardless of the number of touchpoints.
	func (g Gesture) BoundingBox() (gdk.Rectangle, bool) {
var _arg0 *C.GtkGesture // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_bounding_box(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// BoundingBoxCenter: if there are touch sequences being currently handled by
// @gesture, returns true and fills in @x and @y with the center of the bounding
// box containing all active touches.
// 
// Otherwise, false will be returned.
	func (g Gesture) BoundingBoxCenter() (x float64, y float64, ok bool) {
var _arg0 *C.GtkGesture // out
var _arg1 C.double // in
var _arg2 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_bounding_box_center(_arg0, &_arg1, &_arg2)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg1)
_y = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	
	// Device returns the logical `GdkDevice` that is currently operating on
// @gesture.
// 
// This returns nil if the gesture is not being interacted.
	func (g Gesture) Device() gdk.Device {
var _arg0 *C.GtkGesture // out
var _cret *C.GdkDevice // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_device(_arg0)


var _device gdk.Device // out

_device = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Device)

return _device
}
	
	// LastEvent returns the last event that was processed for @sequence.
// 
// Note that the returned pointer is only valid as long as the @sequence is
// still interpreted by the @gesture. If in doubt, you should make a copy of the
// event.
	func (g Gesture) LastEvent(sequence *gdk.EventSequence) gdk.Event {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _cret *C.GdkEvent // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

_cret = C.gtk_gesture_get_last_event(_arg0, _arg1)


var _event gdk.Event // out

_event = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Event)

return _event
}
	
	// LastUpdatedSequence returns the `GdkEventSequence` that was last updated on
// @gesture.
	func (g Gesture) LastUpdatedSequence() *gdk.EventSequence {
var _arg0 *C.GtkGesture // out
var _cret *C.GdkEventSequence // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_get_last_updated_sequence(_arg0)


var _eventSequence *gdk.EventSequence // out

_eventSequence = *(**gdk.EventSequence)(unsafe.Pointer(&_cret))

return _eventSequence
}
	
	// Point: if @sequence is currently being interpreted by @gesture, returns true
// and fills in @x and @y with the last coordinates stored for that event
// sequence.
// 
// The coordinates are always relative to the widget allocation.
	func (g Gesture) Point(sequence *gdk.EventSequence) (x float64, y float64, ok bool) {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _arg2 C.double // in
var _arg3 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

_cret = C.gtk_gesture_get_point(_arg0, _arg1, &_arg2, &_arg3)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg2)
_y = (float64)(_arg3)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	
	// SequenceState returns the @sequence state, as seen by @gesture.
	func (g Gesture) SequenceState(sequence *gdk.EventSequence) EventSequenceState {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _cret C.GtkEventSequenceState // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

_cret = C.gtk_gesture_get_sequence_state(_arg0, _arg1)


var _eventSequenceState EventSequenceState // out

_eventSequenceState = EventSequenceState(_cret)

return _eventSequenceState
}
	
	// Group adds @gesture to the same group than @group_gesture.
// 
// Gestures are by default isolated in their own groups.
// 
// Both gestures must have been added to the same widget before they can be
// grouped.
// 
// When gestures are grouped, the state of `GdkEventSequences` is kept in sync
// for all of those, so calling [method@Gtk.Gesture.set_sequence_state], on one
// will transfer the same value to the others.
// 
// Groups also perform an "implicit grabbing" of sequences, if a
// `GdkEventSequence` state is set to GTK_EVENT_SEQUENCE_CLAIMED on one group,
// every other gesture group attached to the same `GtkWidget` will switch the
// state for that sequence to GTK_EVENT_SEQUENCE_DENIED.
	func (g Gesture) Group(gesture GestureClass)  {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GtkGesture // out

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkGesture)(unsafe.Pointer(gesture.Native()))

C.gtk_gesture_group(_arg0, _arg1)
}
	
	// HandlesSequence returns true if @gesture is currently handling events
// corresponding to @sequence.
	func (g Gesture) HandlesSequence(sequence *gdk.EventSequence) bool {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))

_cret = C.gtk_gesture_handles_sequence(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsActive returns true if the gesture is currently active.
// 
// A gesture is active while there are touch sequences interacting with it.
	func (g Gesture) IsActive() bool {
var _arg0 *C.GtkGesture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsGroupedWith returns true if both gestures pertain to the same group.
	func (g Gesture) IsGroupedWith(other GestureClass) bool {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GtkGesture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkGesture)(unsafe.Pointer(other.Native()))

_cret = C.gtk_gesture_is_grouped_with(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsRecognized returns true if the gesture is currently recognized.
// 
// A gesture is recognized if there are as many interacting touch sequences as
// required by @gesture.
	func (g Gesture) IsRecognized() bool {
var _arg0 *C.GtkGesture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_is_recognized(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSequenceState sets the state of @sequence in @gesture.
// 
// Sequences start in state GTK_EVENT_SEQUENCE_NONE, and whenever they change
// state, they can never go back to that state. Likewise, sequences in state
// GTK_EVENT_SEQUENCE_DENIED cannot turn back to a not denied state. With these
// rules, the lifetime of an event sequence is constrained to the next four:
// 
// * None * None  Denied * None  Claimed * None  Claimed  Denied
// 
// Note: Due to event handling ordering, it may be unsafe to set the state on
// another gesture within a [signal@Gtk.Gesture::begin] signal handler, as the
// callback might be executed before the other gesture knows about the sequence.
// A safe way to perform this could be:
// 
// `c static void first_gesture_begin_cb (GtkGesture *first_gesture,
// GdkEventSequence *sequence, gpointer user_data) {
// gtk_gesture_set_sequence_state (first_gesture, sequence,
// GTK_EVENT_SEQUENCE_CLAIMED); gtk_gesture_set_sequence_state (second_gesture,
// sequence, GTK_EVENT_SEQUENCE_DENIED); }
// 
// static void second_gesture_begin_cb (GtkGesture *second_gesture,
// GdkEventSequence *sequence, gpointer user_data) { if
// (gtk_gesture_get_sequence_state (first_gesture, sequence) ==
// GTK_EVENT_SEQUENCE_CLAIMED) gtk_gesture_set_sequence_state (second_gesture,
// sequence, GTK_EVENT_SEQUENCE_DENIED); } `
// 
// If both gestures are in the same group, just set the state on the gesture
// emitting the event, the sequence will be already be initialized to the
// group's global state when the second gesture processes the event.
	func (g Gesture) SetSequenceState(sequence *gdk.EventSequence, state EventSequenceState) bool {
var _arg0 *C.GtkGesture // out
var _arg1 *C.GdkEventSequence // out
var _arg2 C.GtkEventSequenceState // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GdkEventSequence)(unsafe.Pointer(sequence.Native()))
_arg2 = (C.GtkEventSequenceState)(state)

_cret = C.gtk_gesture_set_sequence_state(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetState sets the state of all sequences that @gesture is currently
// interacting with.
// 
// See [method@Gtk.Gesture.set_sequence_state] for more details on sequence
// states.
	func (g Gesture) SetState(state EventSequenceState) bool {
var _arg0 *C.GtkGesture // out
var _arg1 C.GtkEventSequenceState // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))
_arg1 = (C.GtkEventSequenceState)(state)

_cret = C.gtk_gesture_set_state(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ungroup separates @gesture into an isolated group.
	func (g Gesture) Ungroup()  {
var _arg0 *C.GtkGesture // out

_arg0 = (*C.GtkGesture)(unsafe.Pointer(g.Native()))

C.gtk_gesture_ungroup(_arg0)
}
	


	// GestureClick: `GtkGestureClick` is a `GtkGesture` implementation for clicks.
// 
// It is able to recognize multiple clicks on a nearby zone, which can be
// listened for through the [signal@Gtk.GestureClick::pressed] signal. Whenever
// time or distance between clicks exceed the GTK defaults,
// [signal@Gtk.GestureClick::stopped] is emitted, and the click counter is
// reset.
	type GestureClick struct {
		GestureSingle
		
	}

	// GestureClickClass is an interface that the GestureClick class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureClickClass interface {
		gextras.Objector
		_gestureClick()
	}

	func (GestureClick) _gestureClick() {}

	
	func marshalGestureClick(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureClick(obj), nil
	}
	

	
	// NewGestureClick returns a newly created `GtkGesture` that recognizes single
// and multiple presses.
	func NewGestureClick() GestureClick {
var _cret *C.GtkGesture // in

_cret = C.gtk_gesture_click_new()


var _gestureClick GestureClick // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureClick = GestureClick{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureClick
}
	

	


	// GestureDrag: `GtkGestureDrag` is a `GtkGesture` implementation for drags.
// 
// The drag operation itself can be tracked throughout the
// [signal@Gtk.GestureDrag::drag-begin], [signal@Gtk.GestureDrag::drag-update]
// and [signal@Gtk.GestureDrag::drag-end] signals, and the relevant coordinates
// can be extracted through [method@Gtk.GestureDrag.get_offset] and
// [method@Gtk.GestureDrag.get_start_point].
	type GestureDrag struct {
		GestureSingle
		
	}

	// GestureDragClass is an interface that the GestureDrag class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureDragClass interface {
		gextras.Objector
		_gestureDrag()
	}

	func (GestureDrag) _gestureDrag() {}

	
	func marshalGestureDrag(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureDrag(obj), nil
	}
	

	
	// NewGestureDrag returns a newly created `GtkGesture` that recognizes drags.
	func NewGestureDrag() GestureDrag {
var _cret *C.GtkGesture // in

_cret = C.gtk_gesture_drag_new()


var _gestureDrag GestureDrag // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureDrag = GestureDrag{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureDrag
}
	

	
	// Offset gets the offset from the start point.
// 
// If the @gesture is active, this function returns true and fills in @x and @y
// with the coordinates of the current point, as an offset to the starting drag
// point.
	func (g GestureDrag) Offset() (x float64, y float64, ok bool) {
var _arg0 *C.GtkGestureDrag // out
var _arg1 C.double // in
var _arg2 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_drag_get_offset(_arg0, &_arg1, &_arg2)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg1)
_y = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	
	// StartPoint gets the point where the drag started.
// 
// If the @gesture is active, this function returns true and fills in @x and @y
// with the drag start coordinates, in surface-relative coordinates.
	func (g GestureDrag) StartPoint() (x float64, y float64, ok bool) {
var _arg0 *C.GtkGestureDrag // out
var _arg1 C.double // in
var _arg2 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureDrag)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_drag_get_start_point(_arg0, &_arg1, &_arg2)


var _x float64 // out
var _y float64 // out
var _ok bool // out

_x = (float64)(_arg1)
_y = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _x, _y, _ok
}
	


	// GestureLongPress: `GtkGestureLongPress` is a `GtkGesture` for long presses.
// 
// This gesture is also known as Press and Hold.
// 
// When the timeout is exceeded, the gesture is triggering the
// [signal@Gtk.GestureLongPress::pressed] signal.
// 
// If the touchpoint is lifted before the timeout passes, or if it drifts too
// far of the initial press point, the [signal@Gtk.GestureLongPress::cancelled]
// signal will be emitted.
// 
// How long the timeout is before the ::pressed signal gets emitted is
// determined by the [property@Gtk.Settings:gtk-long-press-time] setting. It can
// be modified by the [property@Gtk.GestureLongPress:delay-factor] property.
	type GestureLongPress struct {
		GestureSingle
		
	}

	// GestureLongPressClass is an interface that the GestureLongPress class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureLongPressClass interface {
		gextras.Objector
		_gestureLongPress()
	}

	func (GestureLongPress) _gestureLongPress() {}

	
	func marshalGestureLongPress(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureLongPress(obj), nil
	}
	

	
	// NewGestureLongPress returns a newly created `GtkGesture` that recognizes long
// presses.
	func NewGestureLongPress() GestureLongPress {
var _cret *C.GtkGesture // in

_cret = C.gtk_gesture_long_press_new()


var _gestureLongPress GestureLongPress // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureLongPress = GestureLongPress{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureLongPress
}
	

	
	// DelayFactor returns the delay factor.
	func (g GestureLongPress) DelayFactor() float64 {
var _arg0 *C.GtkGestureLongPress // out
var _cret C.double // in

_arg0 = (*C.GtkGestureLongPress)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_long_press_get_delay_factor(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetDelayFactor applies the given delay factor.
// 
// The default long press time will be multiplied by this value. Valid values
// are in the range [0.5..2.0].
	func (g GestureLongPress) SetDelayFactor(delayFactor float64)  {
var _arg0 *C.GtkGestureLongPress // out
var _arg1 C.double // out

_arg0 = (*C.GtkGestureLongPress)(unsafe.Pointer(g.Native()))
_arg1 = (C.double)(delayFactor)

C.gtk_gesture_long_press_set_delay_factor(_arg0, _arg1)
}
	


	// GesturePan: `GtkGesturePan` is a `GtkGesture` for pan gestures.
// 
// These are drags that are locked to happen along one axis. The axis that a
// `GtkGesturePan` handles is defined at construct time, and can be changed
// through [method@Gtk.GesturePan.set_orientation].
// 
// When the gesture starts to be recognized, `GtkGesturePan` will attempt to
// determine as early as possible whether the sequence is moving in the expected
// direction, and denying the sequence if this does not happen.
// 
// Once a panning gesture along the expected axis is recognized, the
// [signal@Gtk.GesturePan::pan] signal will be emitted as input events are
// received, containing the offset in the given axis.
	type GesturePan struct {
		GestureDrag
		
	}

	// GesturePanClass is an interface that the GesturePan class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GesturePanClass interface {
		gextras.Objector
		_gesturePan()
	}

	func (GesturePan) _gesturePan() {}

	
	func marshalGesturePan(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGesturePan(obj), nil
	}
	

	
	// NewGesturePan returns a newly created `GtkGesture` that recognizes pan
// gestures.
	func NewGesturePan(orientation Orientation) GesturePan {
var _arg1 C.GtkOrientation // out
var _cret *C.GtkGesture // in

_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_gesture_pan_new(_arg1)


var _gesturePan GesturePan // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gesturePan = GesturePan{
GestureDrag: GestureDrag{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
},
}
}

return _gesturePan
}
	

	
	// Orientation returns the orientation of the pan gestures that this @gesture
// expects.
	func (g GesturePan) Orientation() Orientation {
var _arg0 *C.GtkGesturePan // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_pan_get_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// SetOrientation sets the orientation to be expected on pan gestures.
	func (g GesturePan) SetOrientation(orientation Orientation)  {
var _arg0 *C.GtkGesturePan // out
var _arg1 C.GtkOrientation // out

_arg0 = (*C.GtkGesturePan)(unsafe.Pointer(g.Native()))
_arg1 = (C.GtkOrientation)(orientation)

C.gtk_gesture_pan_set_orientation(_arg0, _arg1)
}
	


	// GestureRotate: `GtkGestureRotate` is a `GtkGesture` for 2-finger rotations.
// 
// Whenever the angle between both handled sequences changes, the
// [signal@Gtk.GestureRotate::angle-changed] signal is emitted.
	type GestureRotate struct {
		Gesture
		
	}

	// GestureRotateClass is an interface that the GestureRotate class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureRotateClass interface {
		gextras.Objector
		_gestureRotate()
	}

	func (GestureRotate) _gestureRotate() {}

	
	func marshalGestureRotate(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureRotate(obj), nil
	}
	

	
	// NewGestureRotate returns a newly created `GtkGesture` that recognizes 2-touch
// rotation gestures.
	func NewGestureRotate() GestureRotate {
var _cret *C.GtkGesture // in

_cret = C.gtk_gesture_rotate_new()


var _gestureRotate GestureRotate // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureRotate = GestureRotate{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _gestureRotate
}
	

	
	// AngleDelta gets the angle delta in radians.
// 
// If @gesture is active, this function returns the angle difference in radians
// since the gesture was first recognized. If @gesture is not active, 0 is
// returned.
	func (g GestureRotate) AngleDelta() float64 {
var _arg0 *C.GtkGestureRotate // out
var _cret C.double // in

_arg0 = (*C.GtkGestureRotate)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_rotate_get_angle_delta(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	


	// GestureSingle: `GtkGestureSingle` is a `GtkGestures` subclass optimized for
// singe-touch and mouse gestures.
// 
// Under interaction, these gestures stick to the first interacting sequence,
// which is accessible through [method@Gtk.GestureSingle.get_current_sequence]
// while the gesture is being interacted with.
// 
// By default gestures react to both GDK_BUTTON_PRIMARY and touch events.
// [method@Gtk.GestureSingle.set_touch_only] can be used to change the touch
// behavior. Callers may also specify a different mouse button number to
// interact with through [method@Gtk.GestureSingle.set_button], or react to any
// mouse button by setting it to 0. While the gesture is active, the button
// being currently pressed can be known through
// [method@Gtk.GestureSingle.get_current_button].
	type GestureSingle struct {
		Gesture
		
	}

	// GestureSingleClass is an interface that the GestureSingle class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureSingleClass interface {
		gextras.Objector
		_gestureSingle()
	}

	func (GestureSingle) _gestureSingle() {}

	
	func marshalGestureSingle(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureSingle(obj), nil
	}
	

	

	
	// Button returns the button number @gesture listens for.
// 
// If this is 0, the gesture reacts to any button press.
	func (g GestureSingle) Button() uint {
var _arg0 *C.GtkGestureSingle // out
var _cret C.guint // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_button(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// CurrentButton returns the button number currently interacting with @gesture,
// or 0 if there is none.
	func (g GestureSingle) CurrentButton() uint {
var _arg0 *C.GtkGestureSingle // out
var _cret C.guint // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_current_button(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// CurrentSequence returns the event sequence currently interacting with
// @gesture.
// 
// This is only meaningful if [method@Gtk.Gesture.is_active] returns true.
	func (g GestureSingle) CurrentSequence() *gdk.EventSequence {
var _arg0 *C.GtkGestureSingle // out
var _cret *C.GdkEventSequence // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_current_sequence(_arg0)


var _eventSequence *gdk.EventSequence // out

_eventSequence = *(**gdk.EventSequence)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_eventSequence, func(v *gdk.EventSequence) {
  C.free(unsafe.Pointer(v.Native()))
})

return _eventSequence
}
	
	// Exclusive gets whether a gesture is exclusive.
// 
// For more information, see [method@Gtk.GestureSingle.set_exclusive].
	func (g GestureSingle) Exclusive() bool {
var _arg0 *C.GtkGestureSingle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_exclusive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TouchOnly returns true if the gesture is only triggered by touch events.
	func (g GestureSingle) TouchOnly() bool {
var _arg0 *C.GtkGestureSingle // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_single_get_touch_only(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetButton sets the button number @gesture listens to.
// 
// If non-0, every button press from a different button number will be ignored.
// Touch events implicitly match with button 1.
	func (g GestureSingle) SetButton(button uint)  {
var _arg0 *C.GtkGestureSingle // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(button)

C.gtk_gesture_single_set_button(_arg0, _arg1)
}
	
	// SetExclusive sets whether @gesture is exclusive.
// 
// An exclusive gesture will only handle pointer and "pointer emulated" touch
// events, so at any given time, there is only one sequence able to interact
// with those.
	func (g GestureSingle) SetExclusive(exclusive bool)  {
var _arg0 *C.GtkGestureSingle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
if exclusive { _arg1 = C.TRUE }

C.gtk_gesture_single_set_exclusive(_arg0, _arg1)
}
	
	// SetTouchOnly sets whether to handle only touch events.
// 
// If @touch_only is true, @gesture will only handle events of type
// GDK_TOUCH_BEGIN, GDK_TOUCH_UPDATE or GDK_TOUCH_END. If false, mouse events
// will be handled too.
	func (g GestureSingle) SetTouchOnly(touchOnly bool)  {
var _arg0 *C.GtkGestureSingle // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGestureSingle)(unsafe.Pointer(g.Native()))
if touchOnly { _arg1 = C.TRUE }

C.gtk_gesture_single_set_touch_only(_arg0, _arg1)
}
	


	// GestureStylus: `GtkGestureStylus` is a `GtkGesture` specific to stylus input.
// 
// The provided signals just relay the basic information of the stylus events.
	type GestureStylus struct {
		GestureSingle
		
	}

	// GestureStylusClass is an interface that the GestureStylus class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureStylusClass interface {
		gextras.Objector
		_gestureStylus()
	}

	func (GestureStylus) _gestureStylus() {}

	
	func marshalGestureStylus(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureStylus(obj), nil
	}
	

	
	// NewGestureStylus creates a new `GtkGestureStylus`.
	func NewGestureStylus() GestureStylus {
var _cret *C.GtkGesture // in

_cret = C.gtk_gesture_stylus_new()


var _gestureStylus GestureStylus // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureStylus = GestureStylus{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureStylus
}
	

	
	// Axis returns the current value for the requested @axis.
// 
// This function must be called from the handler of one of the
// [signal@Gtk.GestureStylus::down], [signal@Gtk.GestureStylus::motion],
// [signal@Gtk.GestureStylus::up] or [signal@Gtk.GestureStylus::proximity]
// signals.
	func (g GestureStylus) Axis(axis gdk.AxisUse) (float64, bool) {
var _arg0 *C.GtkGestureStylus // out
var _arg1 C.GdkAxisUse // out
var _arg2 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))
_arg1 = (C.GdkAxisUse)(axis)

_cret = C.gtk_gesture_stylus_get_axis(_arg0, _arg1, &_arg2)


var _value float64 // out
var _ok bool // out

_value = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _value, _ok
}
	
	// Backlog returns the accumulated backlog of tracking information.
// 
// By default, GTK will limit rate of input events. On stylus input where
// accuracy of strokes is paramount, this function returns the accumulated
// coordinate/timing state before the emission of the current
// [Gtk.GestureStylus::motion] signal.
// 
// This function may only be called within a [signal@Gtk.GestureStylus::motion]
// signal handler, the state given in this signal and obtainable through
// [method@Gtk.GestureStylus.get_axis] express the latest (most up-to-date)
// state in motion history.
// 
// The @backlog is provided in chronological order.
	func (g GestureStylus) Backlog() ([]gdk.TimeCoord, bool) {
var _arg0 *C.GtkGestureStylus // out
var _arg1 *C.GdkTimeCoord
var _arg2 C.guint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_stylus_get_backlog(_arg0, &_arg1, &_arg2)


var _backlog []gdk.TimeCoord
var _ok bool // out

_backlog = unsafe.Slice((*gdk.TimeCoord)(unsafe.Pointer(_arg1)), _arg2)
runtime.SetFinalizer(&_backlog, func(v *[]gdk.TimeCoord) {
  C.free(unsafe.Pointer(&(*v)[0]))
})
if _cret != 0 { _ok = true }

return _backlog, _ok
}
	
	// DeviceTool returns the `GdkDeviceTool` currently driving input through this
// gesture.
// 
// This function must be called from the handler of one of the
// [signal@Gtk.GestureStylus::down], [signal@Gtk.GestureStylus::motion],
// [signal@Gtk.GestureStylus::up] or [signal@Gtk.GestureStylus::proximity]
// signals.
	func (g GestureStylus) DeviceTool() gdk.DeviceTool {
var _arg0 *C.GtkGestureStylus // out
var _cret *C.GdkDeviceTool // in

_arg0 = (*C.GtkGestureStylus)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_stylus_get_device_tool(_arg0)


var _deviceTool gdk.DeviceTool // out

_deviceTool = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.DeviceTool)

return _deviceTool
}
	


	// GestureSwipe: `GtkGestureSwipe` is a `GtkGesture` for swipe gestures.
// 
// After a press/move/.../move/release sequence happens, the
// [signal@Gtk.GestureSwipe::swipe] signal will be emitted, providing the
// velocity and directionality of the sequence at the time it was lifted.
// 
// If the velocity is desired in intermediate points,
// [method@Gtk.GestureSwipe.get_velocity] can be called in a
// [signal@Gtk.Gesture::update] handler.
// 
// All velocities are reported in pixels/sec units.
	type GestureSwipe struct {
		GestureSingle
		
	}

	// GestureSwipeClass is an interface that the GestureSwipe class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureSwipeClass interface {
		gextras.Objector
		_gestureSwipe()
	}

	func (GestureSwipe) _gestureSwipe() {}

	
	func marshalGestureSwipe(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureSwipe(obj), nil
	}
	

	
	// NewGestureSwipe returns a newly created `GtkGesture` that recognizes swipes.
	func NewGestureSwipe() GestureSwipe {
var _cret *C.GtkGesture // in

_cret = C.gtk_gesture_swipe_new()


var _gestureSwipe GestureSwipe // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureSwipe = GestureSwipe{
GestureSingle: GestureSingle{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _gestureSwipe
}
	

	
	// Velocity gets the current velocity.
// 
// If the gesture is recognized, this function returns true and fills in
// @velocity_x and @velocity_y with the recorded velocity, as per the last
// events processed.
	func (g GestureSwipe) Velocity() (velocityX float64, velocityY float64, ok bool) {
var _arg0 *C.GtkGestureSwipe // out
var _arg1 C.double // in
var _arg2 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkGestureSwipe)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_swipe_get_velocity(_arg0, &_arg1, &_arg2)


var _velocityX float64 // out
var _velocityY float64 // out
var _ok bool // out

_velocityX = (float64)(_arg1)
_velocityY = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _velocityX, _velocityY, _ok
}
	


	// GestureZoom: `GtkGestureZoom` is a `GtkGesture` for 2-finger pinch/zoom
// gestures.
// 
// Whenever the distance between both tracked sequences changes, the
// [signal@Gtk.GestureZoom::scale-changed] signal is emitted to report the scale
// factor.
	type GestureZoom struct {
		Gesture
		
	}

	// GestureZoomClass is an interface that the GestureZoom class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GestureZoomClass interface {
		gextras.Objector
		_gestureZoom()
	}

	func (GestureZoom) _gestureZoom() {}

	
	func marshalGestureZoom(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGestureZoom(obj), nil
	}
	

	
	// NewGestureZoom returns a newly created `GtkGesture` that recognizes
// pinch/zoom gestures.
	func NewGestureZoom() GestureZoom {
var _cret *C.GtkGesture // in

_cret = C.gtk_gesture_zoom_new()


var _gestureZoom GestureZoom // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gestureZoom = GestureZoom{
Gesture: Gesture{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _gestureZoom
}
	

	
	// ScaleDelta gets the scale delta.
// 
// If @gesture is active, this function returns the zooming difference since the
// gesture was recognized (hence the starting point is considered 1:1). If
// @gesture is not active, 1 is returned.
	func (g GestureZoom) ScaleDelta() float64 {
var _arg0 *C.GtkGestureZoom // out
var _cret C.double // in

_arg0 = (*C.GtkGestureZoom)(unsafe.Pointer(g.Native()))

_cret = C.gtk_gesture_zoom_get_scale_delta(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	


	// Grid: `GtkGrid` is a container which arranges its child widgets in rows and
// columns.
// 
// !An example GtkGrid (grid.png)
// 
// It supports arbitrary positions and horizontal/vertical spans.
// 
// Children are added using [method@Gtk.Grid.attach]. They can span multiple
// rows or columns. It is also possible to add a child next to an existing
// child, using [method@Gtk.Grid.attach_next_to]. To remove a child from the
// grid, use [method@Gtk.Grid.remove].
// 
// The behaviour of `GtkGrid` when several children occupy the same grid cell is
// undefined.
// 
// 
// GtkGrid as GtkBuildable
// 
// Every child in a `GtkGrid` has access to a custom [iface@Gtk.Buildable]
// element, called <layout>. It can by used to specify a position in the grid
// and optionally spans. All properties that can be used in the <layout>
// element are implemented by [class@Gtk.GridLayoutChild].
// 
// It is implemented by `GtkWidget` using [class@Gtk.LayoutManager].
// 
// To showcase it, here is a simple example:
// 
// `xml <object class="GtkGrid" id="my_grid"> <child> <object class="GtkButton"
// id="button1"> <property name="label">Button 1</property> <layout> <property
// name="column">0</property> <property name="row">0</property> </layout>
// </object> </child> <child> <object class="GtkButton" id="button2"> <property
// name="label">Button 2</property> <layout> <property
// name="column">1</property> <property name="row">0</property> </layout>
// </object> </child> <child> <object class="GtkButton" id="button3"> <property
// name="label">Button 3</property> <layout> <property
// name="column">2</property> <property name="row">0</property> <property
// name="row-span">2</property> </layout> </object> </child> <child> <object
// class="GtkButton" id="button4"> <property name="label">Button 4</property>
// <layout> <property name="column">0</property> <property
// name="row">1</property> <property name="column-span">2</property> </layout>
// </object> </child> </object> `
// 
// It organizes the first two buttons side-by-side in one cell each. The third
// button is in the last column but spans across two rows. This is defined by
// the row-span property. The last button is located in the second row and
// spans across two columns, which is defined by the column-span property.
// 
// 
// CSS nodes
// 
// `GtkGrid` uses a single CSS node with name `grid`.
// 
// 
// Accessibility
// 
// `GtkGrid` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type Grid struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// GridClass is an interface that the Grid class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GridClass interface {
		gextras.Objector
		_grid()
	}

	func (Grid) _grid() {}

	
	func marshalGrid(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGrid(obj), nil
	}
	

	
	// NewGrid creates a new grid widget.
	func NewGrid() Grid {
var _cret *C.GtkWidget // in

_cret = C.gtk_grid_new()


var _grid Grid // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_grid = Grid{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _grid
}
	

	
	// Attach adds a widget to the grid.
// 
// The position of @child is determined by @column and @row. The number of
// cells that @child will occupy is determined by @width and @height.
	func (g Grid) Attach(child WidgetClass, column int, row int, width int, height int)  {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 C.int // out
var _arg5 C.int // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(column)
_arg3 = (C.int)(row)
_arg4 = (C.int)(width)
_arg5 = (C.int)(height)

C.gtk_grid_attach(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// AttachNextTo adds a widget to the grid.
// 
// The widget is placed next to @sibling, on the side determined by @side. When
// @sibling is nil, the widget is placed in row (for left or right placement) or
// column 0 (for top or bottom placement), at the end indicated by @side.
// 
// Attaching widgets labeled [1], [2], [3] with @sibling == nil and @side ==
// GTK_POS_LEFT yields a layout of [3][2][1].
	func (g Grid) AttachNextTo(child WidgetClass, sibling WidgetClass, side PositionType, width int, height int)  {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 C.GtkPositionType // out
var _arg4 C.int // out
var _arg5 C.int // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
_arg3 = (C.GtkPositionType)(side)
_arg4 = (C.int)(width)
_arg5 = (C.int)(height)

C.gtk_grid_attach_next_to(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// BaselineRow returns which row defines the global baseline of @grid.
	func (g Grid) BaselineRow() int {
var _arg0 *C.GtkGrid // out
var _cret C.int // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_baseline_row(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ChildAt gets the child of @grid whose area covers the grid cell at @column,
// @row.
	func (g Grid) ChildAt(column int, row int) Widget {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out
var _arg2 C.int // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(column)
_arg2 = (C.int)(row)

_cret = C.gtk_grid_get_child_at(_arg0, _arg1, _arg2)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ColumnHomogeneous returns whether all columns of @grid have the same width.
	func (g Grid) ColumnHomogeneous() bool {
var _arg0 *C.GtkGrid // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_column_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ColumnSpacing returns the amount of space between the columns of @grid.
	func (g Grid) ColumnSpacing() uint {
var _arg0 *C.GtkGrid // out
var _cret C.guint // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_column_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// RowBaselinePosition returns the baseline position of @row.
// 
// See [method@Gtk.Grid.set_row_baseline_position].
	func (g Grid) RowBaselinePosition(row int) BaselinePosition {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(row)

_cret = C.gtk_grid_get_row_baseline_position(_arg0, _arg1)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// RowHomogeneous returns whether all rows of @grid have the same height.
	func (g Grid) RowHomogeneous() bool {
var _arg0 *C.GtkGrid // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_row_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowSpacing returns the amount of space between the rows of @grid.
	func (g Grid) RowSpacing() uint {
var _arg0 *C.GtkGrid // out
var _cret C.guint // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_get_row_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// InsertColumn inserts a column at the specified position.
// 
// Children which are attached at or to the right of this position are moved one
// column to the right. Children which span across this position are grown to
// span the new column.
	func (g Grid) InsertColumn(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(position)

C.gtk_grid_insert_column(_arg0, _arg1)
}
	
	// InsertNextTo inserts a row or column at the specified position.
// 
// The new row or column is placed next to @sibling, on the side determined by
// @side. If @side is GTK_POS_TOP or GTK_POS_BOTTOM, a row is inserted. If @side
// is GTK_POS_LEFT of GTK_POS_RIGHT, a column is inserted.
	func (g Grid) InsertNextTo(sibling WidgetClass, side PositionType)  {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkPositionType // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(sibling.Native()))
_arg2 = (C.GtkPositionType)(side)

C.gtk_grid_insert_next_to(_arg0, _arg1, _arg2)
}
	
	// InsertRow inserts a row at the specified position.
// 
// Children which are attached at or below this position are moved one row down.
// Children which span across this position are grown to span the new row.
	func (g Grid) InsertRow(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(position)

C.gtk_grid_insert_row(_arg0, _arg1)
}
	
	// QueryChild queries the attach points and spans of @child inside the given
// `GtkGrid`.
	func (g Grid) QueryChild(child WidgetClass) (column int, row int, width int, height int) {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // in
var _arg3 C.int // in
var _arg4 C.int // in
var _arg5 C.int // in

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_grid_query_child(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)

var _column int // out
var _row int // out
var _width int // out
var _height int // out

_column = (int)(_arg2)
_row = (int)(_arg3)
_width = (int)(_arg4)
_height = (int)(_arg5)

return _column, _row, _width, _height
}
	
	// Remove removes a child from @grid.
// 
// The child must have been added with [method@Gtk.Grid.attach] or
// [method@Gtk.Grid.attach_next_to].
	func (g Grid) Remove(child WidgetClass)  {
var _arg0 *C.GtkGrid // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_grid_remove(_arg0, _arg1)
}
	
	// RemoveColumn removes a column from the grid.
// 
// Children that are placed in this column are removed, spanning children that
// overlap this column have their width reduced by one, and children after the
// column are moved to the left.
	func (g Grid) RemoveColumn(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(position)

C.gtk_grid_remove_column(_arg0, _arg1)
}
	
	// RemoveRow removes a row from the grid.
// 
// Children that are placed in this row are removed, spanning children that
// overlap this row have their height reduced by one, and children below the row
// are moved up.
	func (g Grid) RemoveRow(position int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(position)

C.gtk_grid_remove_row(_arg0, _arg1)
}
	
	// SetBaselineRow sets which row defines the global baseline for the entire
// grid.
// 
// Each row in the grid can have its own local baseline, but only one of those
// is global, meaning it will be the baseline in the parent of the @grid.
	func (g Grid) SetBaselineRow(row int)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(row)

C.gtk_grid_set_baseline_row(_arg0, _arg1)
}
	
	// SetColumnHomogeneous sets whether all columns of @grid will have the same
// width.
	func (g Grid) SetColumnHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_grid_set_column_homogeneous(_arg0, _arg1)
}
	
	// SetColumnSpacing sets the amount of space between columns of @grid.
	func (g Grid) SetColumnSpacing(spacing uint)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_grid_set_column_spacing(_arg0, _arg1)
}
	
	// SetRowBaselinePosition sets how the baseline should be positioned on @row of
// the grid, in case that row is assigned more space than is requested.
// 
// The default baseline position is GTK_BASELINE_POSITION_CENTER.
	func (g Grid) SetRowBaselinePosition(row int, pos BaselinePosition)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.int // out
var _arg2 C.GtkBaselinePosition // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(row)
_arg2 = (C.GtkBaselinePosition)(pos)

C.gtk_grid_set_row_baseline_position(_arg0, _arg1, _arg2)
}
	
	// SetRowHomogeneous sets whether all rows of @grid will have the same height.
	func (g Grid) SetRowHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_grid_set_row_homogeneous(_arg0, _arg1)
}
	
	// SetRowSpacing sets the amount of space between rows of @grid.
	func (g Grid) SetRowSpacing(spacing uint)  {
var _arg0 *C.GtkGrid // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGrid)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_grid_set_row_spacing(_arg0, _arg1)
}
	


	// GridLayout: `GtkGridLayout` is a layout manager which arranges child widgets
// in rows and columns.
// 
// Children have an "attach point" defined by the horizontal and vertical index
// of the cell they occupy; children can span multiple rows or columns. The
// layout properties for setting the attach points and spans are set using the
// [class@Gtk.GridLayoutChild] associated to each child widget.
// 
// The behaviour of `GtkGridLayout` when several children occupy the same grid
// cell is undefined.
// 
// `GtkGridLayout` can be used like a `GtkBoxLayout` if all children are
// attached to the same row or column; however, if you only ever need a single
// row or column, you should consider using `GtkBoxLayout`.
	type GridLayout struct {
		LayoutManager
		
	}

	// GridLayoutClass is an interface that the GridLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GridLayoutClass interface {
		gextras.Objector
		_gridLayout()
	}

	func (GridLayout) _gridLayout() {}

	
	func marshalGridLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGridLayout(obj), nil
	}
	

	
	// NewGridLayout creates a new `GtkGridLayout`.
	func NewGridLayout() GridLayout {
var _cret *C.GtkLayoutManager // in

_cret = C.gtk_grid_layout_new()


var _gridLayout GridLayout // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_gridLayout = GridLayout{
LayoutManager: LayoutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _gridLayout
}
	

	
	// BaselineRow retrieves the row set with gtk_grid_layout_set_baseline_row().
	func (g GridLayout) BaselineRow() int {
var _arg0 *C.GtkGridLayout // out
var _cret C.int // in

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_layout_get_baseline_row(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ColumnHomogeneous checks whether all columns of @grid should have the same
// width.
	func (g GridLayout) ColumnHomogeneous() bool {
var _arg0 *C.GtkGridLayout // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_layout_get_column_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ColumnSpacing retrieves the spacing set with
// gtk_grid_layout_set_column_spacing().
	func (g GridLayout) ColumnSpacing() uint {
var _arg0 *C.GtkGridLayout // out
var _cret C.guint // in

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_layout_get_column_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// RowBaselinePosition returns the baseline position of @row.
// 
// If no value has been set with
// [method@Gtk.GridLayout.set_row_baseline_position], the default value of
// GTK_BASELINE_POSITION_CENTER is returned.
	func (g GridLayout) RowBaselinePosition(row int) BaselinePosition {
var _arg0 *C.GtkGridLayout // out
var _arg1 C.int // out
var _cret C.GtkBaselinePosition // in

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(row)

_cret = C.gtk_grid_layout_get_row_baseline_position(_arg0, _arg1)


var _baselinePosition BaselinePosition // out

_baselinePosition = BaselinePosition(_cret)

return _baselinePosition
}
	
	// RowHomogeneous checks whether all rows of @grid should have the same height.
	func (g GridLayout) RowHomogeneous() bool {
var _arg0 *C.GtkGridLayout // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_layout_get_row_homogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowSpacing retrieves the spacing set with gtk_grid_layout_set_row_spacing().
	func (g GridLayout) RowSpacing() uint {
var _arg0 *C.GtkGridLayout // out
var _cret C.guint // in

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))

_cret = C.gtk_grid_layout_get_row_spacing(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SetBaselineRow sets which row defines the global baseline for the entire
// grid.
// 
// Each row in the grid can have its own local baseline, but only one of those
// is global, meaning it will be the baseline in the parent of the @grid.
	func (g GridLayout) SetBaselineRow(row int)  {
var _arg0 *C.GtkGridLayout // out
var _arg1 C.int // out

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(row)

C.gtk_grid_layout_set_baseline_row(_arg0, _arg1)
}
	
	// SetColumnHomogeneous sets whether all columns of @grid should have the same
// width.
	func (g GridLayout) SetColumnHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkGridLayout // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_grid_layout_set_column_homogeneous(_arg0, _arg1)
}
	
	// SetColumnSpacing sets the amount of space to insert between consecutive
// columns.
	func (g GridLayout) SetColumnSpacing(spacing uint)  {
var _arg0 *C.GtkGridLayout // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_grid_layout_set_column_spacing(_arg0, _arg1)
}
	
	// SetRowBaselinePosition sets how the baseline should be positioned on @row of
// the grid, in case that row is assigned more space than is requested.
	func (g GridLayout) SetRowBaselinePosition(row int, pos BaselinePosition)  {
var _arg0 *C.GtkGridLayout // out
var _arg1 C.int // out
var _arg2 C.GtkBaselinePosition // out

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
_arg1 = (C.int)(row)
_arg2 = (C.GtkBaselinePosition)(pos)

C.gtk_grid_layout_set_row_baseline_position(_arg0, _arg1, _arg2)
}
	
	// SetRowHomogeneous sets whether all rows of @grid should have the same height.
	func (g GridLayout) SetRowHomogeneous(homogeneous bool)  {
var _arg0 *C.GtkGridLayout // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
if homogeneous { _arg1 = C.TRUE }

C.gtk_grid_layout_set_row_homogeneous(_arg0, _arg1)
}
	
	// SetRowSpacing sets the amount of space to insert between consecutive rows.
	func (g GridLayout) SetRowSpacing(spacing uint)  {
var _arg0 *C.GtkGridLayout // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGridLayout)(unsafe.Pointer(g.Native()))
_arg1 = (C.guint)(spacing)

C.gtk_grid_layout_set_row_spacing(_arg0, _arg1)
}
	


	// GridLayoutChild: `GtkLayoutChild` subclass for children in a `GtkGridLayout`.
	type GridLayoutChild struct {
		LayoutChild
		
	}

	// GridLayoutChildClass is an interface that the GridLayoutChild class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GridLayoutChildClass interface {
		gextras.Objector
		_gridLayoutChild()
	}

	func (GridLayoutChild) _gridLayoutChild() {}

	
	func marshalGridLayoutChild(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGridLayoutChild(obj), nil
	}
	

	

	
	// Column retrieves the column number to which @child attaches its left side.
	func (c GridLayoutChild) Column() int {
var _arg0 *C.GtkGridLayoutChild // out
var _cret C.int // in

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_grid_layout_child_get_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ColumnSpan retrieves the number of columns that @child spans to.
	func (c GridLayoutChild) ColumnSpan() int {
var _arg0 *C.GtkGridLayoutChild // out
var _cret C.int // in

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_grid_layout_child_get_column_span(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Row retrieves the row number to which @child attaches its top side.
	func (c GridLayoutChild) Row() int {
var _arg0 *C.GtkGridLayoutChild // out
var _cret C.int // in

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_grid_layout_child_get_row(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// RowSpan retrieves the number of rows that @child spans to.
	func (c GridLayoutChild) RowSpan() int {
var _arg0 *C.GtkGridLayoutChild // out
var _cret C.int // in

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_grid_layout_child_get_row_span(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetColumn sets the column number to attach the left side of @child.
	func (c GridLayoutChild) SetColumn(column int)  {
var _arg0 *C.GtkGridLayoutChild // out
var _arg1 C.int // out

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(column)

C.gtk_grid_layout_child_set_column(_arg0, _arg1)
}
	
	// SetColumnSpan sets the number of columns @child spans to.
	func (c GridLayoutChild) SetColumnSpan(span int)  {
var _arg0 *C.GtkGridLayoutChild // out
var _arg1 C.int // out

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(span)

C.gtk_grid_layout_child_set_column_span(_arg0, _arg1)
}
	
	// SetRow sets the row to place @child in.
	func (c GridLayoutChild) SetRow(row int)  {
var _arg0 *C.GtkGridLayoutChild // out
var _arg1 C.int // out

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(row)

C.gtk_grid_layout_child_set_row(_arg0, _arg1)
}
	
	// SetRowSpan sets the number of rows @child spans to.
	func (c GridLayoutChild) SetRowSpan(span int)  {
var _arg0 *C.GtkGridLayoutChild // out
var _arg1 C.int // out

_arg0 = (*C.GtkGridLayoutChild)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(span)

C.gtk_grid_layout_child_set_row_span(_arg0, _arg1)
}
	


	// GridView: `GtkGridView` presents a large dynamic grid of items.
// 
// `GtkGridView` uses its factory to generate one child widget for each visible
// item and shows them in a grid. The orientation of the grid view determines if
// the grid reflows vertically or horizontally.
// 
// `GtkGridView` allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// [property@Gtk.GridView:enable-rubberband].
// 
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
// 
// 
// CSS nodes
// 
// ` gridview  child   child    [rubberband] `
// 
// `GtkGridView` uses a single CSS node with name gridview. Each child uses a
// single CSS node with name child. For rubberband selection, a subnode with
// name rubberband is used.
// 
// 
// Accessibility
// 
// `GtkGridView` uses the GTK_ACCESSIBLE_ROLE_GRID role, and the items use the
// GTK_ACCESSIBLE_ROLE_GRID_CELL role.
	type GridView struct {
		ListBase
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		Scrollable
		
	}

	// GridViewClass is an interface that the GridView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type GridViewClass interface {
		gextras.Objector
		_gridView()
	}

	func (GridView) _gridView() {}

	
	func marshalGridView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapGridView(obj), nil
	}
	

	
	// NewGridView creates a new `GtkGridView` that uses the given @factory for
// mapping items to widgets.
// 
// The function takes ownership of the arguments, so you can write code like `c
// grid_view = gtk_grid_view_new (create_model (),
// gtk_builder_list_item_factory_new_from_resource ("/resource.ui")); `
	func NewGridView(model SelectionModel, factory ListItemFactoryClass) GridView {
var _arg1 *C.GtkSelectionModel // out
var _arg2 *C.GtkListItemFactory // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

_cret = C.gtk_grid_view_new(_arg1, _arg2)


var _gridView GridView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_gridView = GridView{
ListBase: ListBase{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _gridView
}
	

	
	// EnableRubberband returns whether rows can be selected by dragging with the
// mouse.
	func (s GridView) EnableRubberband() bool {
var _arg0 *C.GtkGridView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_grid_view_get_enable_rubberband(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Factory gets the factory that's currently used to populate list items.
	func (s GridView) Factory() ListItemFactory {
var _arg0 *C.GtkGridView // out
var _cret *C.GtkListItemFactory // in

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_grid_view_get_factory(_arg0)


var _listItemFactory ListItemFactory // out

_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

return _listItemFactory
}
	
	// MaxColumns gets the maximum number of columns that the grid will use.
	func (s GridView) MaxColumns() uint {
var _arg0 *C.GtkGridView // out
var _cret C.guint // in

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_grid_view_get_max_columns(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MinColumns gets the minimum number of columns that the grid will use.
	func (s GridView) MinColumns() uint {
var _arg0 *C.GtkGridView // out
var _cret C.guint // in

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_grid_view_get_min_columns(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Model gets the model that's currently used to read the items displayed.
	func (s GridView) Model() SelectionModel {
var _arg0 *C.GtkGridView // out
var _cret *C.GtkSelectionModel // in

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_grid_view_get_model(_arg0)


var _selectionModel SelectionModel // out

_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

return _selectionModel
}
	
	// SingleClickActivate returns whether items will be activated on single click
// and selected on hover.
	func (s GridView) SingleClickActivate() bool {
var _arg0 *C.GtkGridView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_grid_view_get_single_click_activate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetEnableRubberband sets whether selections can be changed by dragging with
// the mouse.
	func (s GridView) SetEnableRubberband(enableRubberband bool)  {
var _arg0 *C.GtkGridView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
if enableRubberband { _arg1 = C.TRUE }

C.gtk_grid_view_set_enable_rubberband(_arg0, _arg1)
}
	
	// SetFactory sets the `GtkListItemFactory` to use for populating list items.
	func (s GridView) SetFactory(factory ListItemFactoryClass)  {
var _arg0 *C.GtkGridView // out
var _arg1 *C.GtkListItemFactory // out

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

C.gtk_grid_view_set_factory(_arg0, _arg1)
}
	
	// SetMaxColumns sets the maximum number of columns to use.
// 
// This number must be at least 1.
// 
// If @max_columns is smaller than the minimum set via
// [method@Gtk.GridView.set_min_columns], that value is used instead.
	func (s GridView) SetMaxColumns(maxColumns uint)  {
var _arg0 *C.GtkGridView // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(maxColumns)

C.gtk_grid_view_set_max_columns(_arg0, _arg1)
}
	
	// SetMinColumns sets the minimum number of columns to use.
// 
// This number must be at least 1.
// 
// If @min_columns is smaller than the minimum set via
// [method@Gtk.GridView.set_max_columns], that value is ignored.
	func (s GridView) SetMinColumns(minColumns uint)  {
var _arg0 *C.GtkGridView // out
var _arg1 C.guint // out

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(minColumns)

C.gtk_grid_view_set_min_columns(_arg0, _arg1)
}
	
	// SetModel sets the imodel to use.
// 
// This must be a [iface@Gtk.SelectionModel].
	func (s GridView) SetModel(model SelectionModel)  {
var _arg0 *C.GtkGridView // out
var _arg1 *C.GtkSelectionModel // out

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

C.gtk_grid_view_set_model(_arg0, _arg1)
}
	
	// SetSingleClickActivate sets whether items should be activated on single click
// and selected on hover.
	func (s GridView) SetSingleClickActivate(singleClickActivate bool)  {
var _arg0 *C.GtkGridView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkGridView)(unsafe.Pointer(s.Native()))
if singleClickActivate { _arg1 = C.TRUE }

C.gtk_grid_view_set_single_click_activate(_arg0, _arg1)
}
	


	// HeaderBar: `GtkHeaderBar` is a widget for creating custom title bars for
// windows.
// 
// !An example GtkHeaderBar (headerbar.png)
// 
// `GtkHeaderBar` is similar to a horizontal `GtkCenterBox`. It allows children
// to be placed at the start or the end. In addition, it allows the window title
// to be displayed. The title will be centered with respect to the width of the
// box, even if the children at either side take up different amounts of space.
// 
// `GtkHeaderBar` can add typical window frame controls, such as minimize,
// maximize and close buttons, or the window icon.
// 
// For these reasons, `GtkHeaderBar` is the natural choice for use as the custom
// titlebar widget of a `GtkWindow (see [method@Gtk.Window.set_titlebar]), as it
// gives features typical of titlebars while allowing the addition of child
// widgets.
// 
// 
// GtkHeaderBar as GtkBuildable
// 
// The `GtkHeaderBar` implementation of the `GtkBuildable` interface supports
// adding children at the start or end sides by specifying start or end as
// the type attribute of a <child> element, or setting the title widget by
// specifying title value.
// 
// By default the `GtkHeaderBar` uses a `GtkLabel` displaying the title of the
// window it is contained in as the title widget, equivalent to the following UI
// definition:
// 
// `xml <object class="GtkHeaderBar"> <property name="title-widget"> <object
// class="GtkLabel"> <property name="label" translatable="yes">Label</property>
// <property name="single-line-mode">True</property> <property
// name="ellipsize">end</property> <property name="width-chars">5</property>
// <style> <class name="title"/> </style> </object> </property> </object> `
// 
// 
// CSS nodes
// 
// ` headerbar  windowhandle  box  box.start  
// windowcontrols.start   [other children]  [Title Widget]  box.end
//  [other children]  windowcontrols.end `
// 
// A `GtkHeaderBar`'s CSS node is called `headerbar`. It contains a
// `windowhandle` subnode, which contains a `box` subnode, which contains two
// `box` subnodes at the start and end of the header bar, as well as a center
// node that represents the title.
// 
// Each of the boxes contains a `windowcontrols` subnode, see
// [class@Gtk.WindowControls] for details, as well as other children.
// 
// 
// Accessibility
// 
// `GtkHeaderBar` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type HeaderBar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// HeaderBarClass is an interface that the HeaderBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type HeaderBarClass interface {
		gextras.Objector
		_headerBar()
	}

	func (HeaderBar) _headerBar() {}

	
	func marshalHeaderBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapHeaderBar(obj), nil
	}
	

	
	// NewHeaderBar creates a new `GtkHeaderBar` widget.
	func NewHeaderBar() HeaderBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_header_bar_new()


var _headerBar HeaderBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_headerBar = HeaderBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _headerBar
}
	

	
	// DecorationLayout gets the decoration layout of the `GtkHeaderBar`.
	func (b HeaderBar) DecorationLayout() string {
var _arg0 *C.GtkHeaderBar // out
var _cret *C.char // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_decoration_layout(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ShowTitleButtons returns whether this header bar shows the standard window
// title buttons.
	func (b HeaderBar) ShowTitleButtons() bool {
var _arg0 *C.GtkHeaderBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_show_title_buttons(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TitleWidget retrieves the title widget of the header.
// 
// See [method@Gtk.HeaderBar.set_title_widget].
	func (b HeaderBar) TitleWidget() Widget {
var _arg0 *C.GtkHeaderBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_header_bar_get_title_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// PackEnd adds @child to @bar, packed with reference to the end of the @bar.
	func (b HeaderBar) PackEnd(child WidgetClass)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_header_bar_pack_end(_arg0, _arg1)
}
	
	// PackStart adds @child to @bar, packed with reference to the start of the
// @bar.
	func (b HeaderBar) PackStart(child WidgetClass)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_header_bar_pack_start(_arg0, _arg1)
}
	
	// Remove removes a child from the `GtkHeaderBar`.
// 
// The child must have been added with [method@Gtk.HeaderBar.pack_start],
// [method@Gtk.HeaderBar.pack_end] or [method@Gtk.HeaderBar.set_title_widget].
	func (b HeaderBar) Remove(child WidgetClass)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_header_bar_remove(_arg0, _arg1)
}
	
	// SetDecorationLayout sets the decoration layout for this header bar.
// 
// This property overrides the [property@Gtk.Settings:gtk-decoration-layout]
// setting.
// 
// There can be valid reasons for overriding the setting, such as a header bar
// design that does not allow for buttons to take room on the right, or only
// offers room for a single close button. Split header bars are another example
// for overriding the setting.
// 
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the right.
// Recognized button names are minimize, maximize, close and icon (the window
// icon).
// 
// For example, icon:minimize,maximize,close specifies a icon on the left, and
// minimize, maximize and close buttons on the right.
	func (b HeaderBar) SetDecorationLayout(layout string)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.char // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(layout))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_header_bar_set_decoration_layout(_arg0, _arg1)
}
	
	// SetShowTitleButtons sets whether this header bar shows the standard window
// title buttons.
	func (b HeaderBar) SetShowTitleButtons(setting bool)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_header_bar_set_show_title_buttons(_arg0, _arg1)
}
	
	// SetTitleWidget sets the title for the `GtkHeaderBar`.
// 
// When set to nil, the headerbar will display the title of the window it is
// contained in.
// 
// The title should help a user identify the current view. To achieve the same
// style as the builtin title, use the title style class.
// 
// You should set the title widget to nil, for the window title label to be
// visible again.
	func (b HeaderBar) SetTitleWidget(titleWidget WidgetClass)  {
var _arg0 *C.GtkHeaderBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkHeaderBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(titleWidget.Native()))

C.gtk_header_bar_set_title_widget(_arg0, _arg1)
}
	


	// IMContext: `GtkIMContext` defines the interface for GTK input methods.
// 
// `GtkIMContext` is used by GTK text input widgets like `GtkText` to map from
// key events to Unicode character strings.
// 
// By default, GTK uses a platform-dependent default input method. On Windows,
// the default implementation is IME-based and on Wayland, it is using the
// Wayland text protocol. The choice can be overridden programmatically via the
// [property@Gtk.Settings:gtk-im-module] setting. Users may set the
// `GTK_IM_MODULE` environment variable to override the default.
// 
// Text widgets have a :im-module property (e.g.
// [property@Gtk.TextView:im-module]) that may also be used to set input methods
// for specific widget instances. For instance, a certain entry widget might be
// expected to contain certain characters which would be easier to input with a
// specific input method.
// 
// An input method may consume multiple key events in sequence before finally
// outputting the composed result. This is called *preediting*, and an input
// method may provide feedback about this process by displaying the intermediate
// composition states as preedit text.
// 
// For instance, the built-in GTK input method `GtkIMContextSimple` implements
// the input of arbitrary Unicode code points by holding down the
// <kbd>Control</kbd> and <kbd>Shift</kbd> keys and then typing <kbd>U</kbd>
// followed by the hexadecimal digits of the code point. When releasing the
// <kbd>Control</kbd> and <kbd>Shift</kbd> keys, preediting ends and the
// character is inserted as text. For example,
// 
//    Ctrl+Shift+u 2 0 A C
// 
// results in the  sign.
// 
// Additional input methods can be made available for use by GTK widgets as
// loadable modules. An input method module is a small shared library which
// provides a `GIOExtension` for the extension point named "gtk-im-module".
	type IMContext struct {
		**externglib.Object
		
	}

	// IMContextClass is an interface that the IMContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IMContextClass interface {
		gextras.Objector
		_imContext()
	}

	func (IMContext) _imContext() {}

	
	func marshalIMContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIMContext(obj), nil
	}
	

	

	
	// DeleteSurrounding asks the widget that the input context is attached to
// delete characters around the cursor position by emitting the
// GtkIMContext::delete_surrounding signal.
// 
// Note that @offset and @n_chars are in characters not in bytes which differs
// from the usage other places in IMContext.
// 
// In order to use this function, you should first call
// gtk_im_context_get_surrounding() to get the current context, and call this
// function immediately afterwards to make sure that you know what you are
// deleting. You should also account for the fact that even if the signal was
// handled, the input context might not have deleted all the characters that
// were requested to be deleted.
// 
// This function is used by an input method that wants to make subsitutions in
// the existing text in response to new input. It is not useful for
// applications.
	func (c IMContext) DeleteSurrounding(offset int, nChars int) bool {
var _arg0 *C.GtkIMContext // out
var _arg1 C.int // out
var _arg2 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(offset)
_arg2 = (C.int)(nChars)

_cret = C.gtk_im_context_delete_surrounding(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FilterKey: allow an input method to forward key press and release events to
// another input methodm without necessarily having a `GdkEvent` available.
	func (c IMContext) FilterKey(press bool, surface gdk.SurfaceClass, device gdk.DeviceClass, time uint32, keycode uint, state gdk.ModifierType, group int) bool {
var _arg0 *C.GtkIMContext // out
var _arg1 C.gboolean // out
var _arg2 *C.GdkSurface // out
var _arg3 *C.GdkDevice // out
var _arg4 C.guint32 // out
var _arg5 C.guint // out
var _arg6 C.GdkModifierType // out
var _arg7 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
if press { _arg1 = C.TRUE }
_arg2 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))
_arg3 = (*C.GdkDevice)(unsafe.Pointer(device.Native()))
_arg4 = (C.guint32)(time)
_arg5 = (C.guint)(keycode)
_arg6 = (C.GdkModifierType)(state)
_arg7 = (C.int)(group)

_cret = C.gtk_im_context_filter_key(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FilterKeypress: allow an input method to internally handle key press and
// release events.
// 
// If this function returns true, then no further processing should be done for
// this key event.
	func (c IMContext) FilterKeypress(event gdk.EventClass) bool {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.GdkEvent // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

_cret = C.gtk_im_context_filter_keypress(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FocusIn: notify the input method that the widget to which this input context
// corresponds has gained focus.
// 
// The input method may, for example, change the displayed feedback to reflect
// this change.
	func (c IMContext) FocusIn()  {
var _arg0 *C.GtkIMContext // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_focus_in(_arg0)
}
	
	// FocusOut: notify the input method that the widget to which this input context
// corresponds has lost focus.
// 
// The input method may, for example, change the displayed feedback or reset the
// contexts state to reflect this change.
	func (c IMContext) FocusOut()  {
var _arg0 *C.GtkIMContext // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_focus_out(_arg0)
}
	
	// PreeditString: retrieve the current preedit string for the input context, and
// a list of attributes to apply to the string.
// 
// This string should be displayed inserted at the insertion point.
	func (c IMContext) PreeditString() (string, *pango.AttrList, int) {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.char // in
var _attrs *pango.AttrList
var _arg3 C.int // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_get_preedit_string(_arg0, &_arg1, (**C.PangoAttrList)(unsafe.Pointer(&_attrs)), &_arg3)

var _str string // out

var _cursorPos int // out

_str = C.GoString(_arg1)
defer C.free(unsafe.Pointer(_arg1))

_cursorPos = (int)(_arg3)

return _str, _attrs, _cursorPos
}
	
	// Surrounding retrieves context around the insertion point.
// 
// Input methods typically want context in order to constrain input text based
// on existing text; this is important for languages such as Thai where only
// some sequences of characters are allowed.
// 
// This function is implemented by emitting the
// [signal@Gtk.IMContext::retrieve-surrounding] signal on the input method; in
// response to this signal, a widget should provide as much context as is
// available, up to an entire paragraph, by calling
// [method@Gtk.IMContext.set_surrounding].
// 
// Note that there is no obligation for a widget to respond to the
// `::retrieve-surrounding` signal, so input methods must be prepared to
// function without context.
	func (c IMContext) Surrounding() (string, int, bool) {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.char // in
var _arg2 C.int // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_im_context_get_surrounding(_arg0, &_arg1, &_arg2)


var _text string // out
var _cursorIndex int // out
var _ok bool // out

_text = C.GoString(_arg1)
defer C.free(unsafe.Pointer(_arg1))
_cursorIndex = (int)(_arg2)
if _cret != 0 { _ok = true }

return _text, _cursorIndex, _ok
}
	
	// SurroundingWithSelection retrieves context around the insertion point.
// 
// Input methods typically want context in order to constrain input text based
// on existing text; this is important for languages such as Thai where only
// some sequences of characters are allowed.
// 
// This function is implemented by emitting the
// [signal@Gtk.IMContext::retrieve-surrounding] signal on the input method; in
// response to this signal, a widget should provide as much context as is
// available, up to an entire paragraph, by calling
// [method@Gtk.IMContext.set_surrounding_with_selection].
// 
// Note that there is no obligation for a widget to respond to the
// `::retrieve-surrounding` signal, so input methods must be prepared to
// function without context.
	func (c IMContext) SurroundingWithSelection() (text string, cursorIndex int, anchorIndex int, ok bool) {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.char // in
var _arg2 C.int // in
var _arg3 C.int // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_im_context_get_surrounding_with_selection(_arg0, &_arg1, &_arg2, &_arg3)


var _text string // out
var _cursorIndex int // out
var _anchorIndex int // out
var _ok bool // out

_text = C.GoString(_arg1)
defer C.free(unsafe.Pointer(_arg1))
_cursorIndex = (int)(_arg2)
_anchorIndex = (int)(_arg3)
if _cret != 0 { _ok = true }

return _text, _cursorIndex, _anchorIndex, _ok
}
	
	// Reset: notify the input method that a change such as a change in cursor
// position has been made.
// 
// This will typically cause the input method to clear the preedit state.
	func (c IMContext) Reset()  {
var _arg0 *C.GtkIMContext // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))

C.gtk_im_context_reset(_arg0)
}
	
	// SetClientWidget: set the client widget for the input context.
// 
// This is the `GtkWidget` holding the input focus. This widget is used in order
// to correctly position status windows, and may also be used for purposes
// internal to the input method.
	func (c IMContext) SetClientWidget(widget WidgetClass)  {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_im_context_set_client_widget(_arg0, _arg1)
}
	
	// SetCursorLocation: notify the input method that a change in cursor position
// has been made.
// 
// The location is relative to the client window.
	func (c IMContext) SetCursorLocation(area *gdk.Rectangle)  {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.GdkRectangle // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(area.Native()))

C.gtk_im_context_set_cursor_location(_arg0, _arg1)
}
	
	// SetSurrounding sets surrounding context around the insertion point and
// preedit string.
// 
// This function is expected to be called in response to the
// [signal@Gtk.IMContext::retrieve-surrounding] signal, and will likely have no
// effect if called at other times.
	func (c IMContext) SetSurrounding(text string, len int, cursorIndex int)  {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.char // out
var _arg2 C.int // out
var _arg3 C.int // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(len)
_arg3 = (C.int)(cursorIndex)

C.gtk_im_context_set_surrounding(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetSurroundingWithSelection sets surrounding context around the insertion
// point and preedit string. This function is expected to be called in response
// to the GtkIMContext::retrieve_surrounding signal, and will likely have no
// effect if called at other times.
	func (c IMContext) SetSurroundingWithSelection(text string, len int, cursorIndex int, anchorIndex int)  {
var _arg0 *C.GtkIMContext // out
var _arg1 *C.char // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 C.int // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(len)
_arg3 = (C.int)(cursorIndex)
_arg4 = (C.int)(anchorIndex)

C.gtk_im_context_set_surrounding_with_selection(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetUsePreedit sets whether the IM context should use the preedit string to
// display feedback.
// 
// If @use_preedit is false (default is true), then the IM context may use some
// other method to display feedback, such as displaying it in a child of the
// root window.
	func (c IMContext) SetUsePreedit(usePreedit bool)  {
var _arg0 *C.GtkIMContext // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIMContext)(unsafe.Pointer(c.Native()))
if usePreedit { _arg1 = C.TRUE }

C.gtk_im_context_set_use_preedit(_arg0, _arg1)
}
	


	// IMContextSimple: `GtkIMContextSimple` is an input method supporting
// table-based input methods.
// 
// `GtkIMContextSimple` has a built-in table of compose sequences that is
// derived from the X11 Compose files.
// 
// `GtkIMContextSimple` reads additional compose sequences from the first of the
// following files that is found: ~/.config/gtk-4.0/Compose, ~/.XCompose,
// /usr/share/X11/locale/$locale/Compose (for locales that have a nontrivial
// Compose file). The syntax of these files is described in the Compose(5)
// manual page.
// 
// 
// Unicode characters
// 
// `GtkIMContextSimple` also supports numeric entry of Unicode characters by
// typing <kbd>Ctrl</kbd>-<kbd>Shift</kbd>-<kbd>u</kbd>, followed by a
// hexadecimal Unicode codepoint.
// 
// For example,
// 
//    Ctrl-Shift-u 1 2 3 Enter
// 
// yields U+0123 LATIN SMALL LETTER G WITH CEDILLA, i.e. .
	type IMContextSimple struct {
		IMContext
		
	}

	// IMContextSimpleClass is an interface that the IMContextSimple class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IMContextSimpleClass interface {
		gextras.Objector
		_imContextSimple()
	}

	func (IMContextSimple) _imContextSimple() {}

	
	func marshalIMContextSimple(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIMContextSimple(obj), nil
	}
	

	
	// NewIMContextSimple creates a new IMContextSimple.
	func NewIMContextSimple() IMContextSimple {
var _cret *C.GtkIMContext // in

_cret = C.gtk_im_context_simple_new()


var _imContextSimple IMContextSimple // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_imContextSimple = IMContextSimple{
IMContext: IMContext{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imContextSimple
}
	

	
	// AddComposeFile adds an additional table from the X11 compose file.
	func (c IMContextSimple) AddComposeFile(composeFile string)  {
var _arg0 *C.GtkIMContextSimple // out
var _arg1 *C.char // out

_arg0 = (*C.GtkIMContextSimple)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(composeFile))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_im_context_simple_add_compose_file(_arg0, _arg1)
}
	


	// IMMulticontext: `GtkIMMulticontext` is input method supporting multiple,
// switchable input methods.
// 
// Text widgets such as `GtkText` or `GtkTextView` use a `GtkIMMultiContext` to
// implement their `im-module` property for switching between different input
// methods.
	type IMMulticontext struct {
		IMContext
		
	}

	// IMMulticontextClass is an interface that the IMMulticontext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IMMulticontextClass interface {
		gextras.Objector
		_imMulticontext()
	}

	func (IMMulticontext) _imMulticontext() {}

	
	func marshalIMMulticontext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIMMulticontext(obj), nil
	}
	

	
	// NewIMMulticontext creates a new `GtkIMMulticontext`.
	func NewIMMulticontext() IMMulticontext {
var _cret *C.GtkIMContext // in

_cret = C.gtk_im_multicontext_new()


var _imMulticontext IMMulticontext // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_imMulticontext = IMMulticontext{
IMContext: IMContext{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _imMulticontext
}
	

	
	// ContextID gets the id of the currently active delegate of the @context.
	func (c IMMulticontext) ContextID() string {
var _arg0 *C.GtkIMMulticontext // out
var _cret *C.char // in

_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_im_multicontext_get_context_id(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetContextID sets the context id for @context.
// 
// This causes the currently active delegate of @context to be replaced by the
// delegate corresponding to the new context id.
	func (c IMMulticontext) SetContextID(contextId string)  {
var _arg0 *C.GtkIMMulticontext // out
var _arg1 *C.char // out

_arg0 = (*C.GtkIMMulticontext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(contextId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_im_multicontext_set_context_id(_arg0, _arg1)
}
	


	// IconPaintable contains information found when looking up an icon in
// `GtkIconTheme`.
// 
// `GtkIconPaintable` implements `GdkPaintable`.
	type IconPaintable struct {
		**externglib.Object
		gdk.Paintable
		
	}

	// IconPaintableClass is an interface that the IconPaintable class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IconPaintableClass interface {
		gextras.Objector
		_iconPaintable()
	}

	func (IconPaintable) _iconPaintable() {}

	
	func marshalIconPaintable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIconPaintable(obj), nil
	}
	

	
	// NewIconPaintableForFile creates a `GtkIconPaintable` for a file with a given
// size and scale.
// 
// The icon can then be rendered by using it as a `GdkPaintable`.
	func NewIconPaintableForFile(file gio.File, size int, scale int) IconPaintable {
var _arg1 *C.GFile // out
var _arg2 C.int // out
var _arg3 C.int // out
var _cret *C.GtkIconPaintable // in

_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))
_arg2 = (C.int)(size)
_arg3 = (C.int)(scale)

_cret = C.gtk_icon_paintable_new_for_file(_arg1, _arg2, _arg3)


var _iconPaintable IconPaintable // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_iconPaintable = IconPaintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconPaintable
}
	

	
	// File gets the `GFile` that was used to load the icon.
// 
// Returns nil if the icon was not loaded from a file.
	func (s IconPaintable) File() gio.File {
var _arg0 *C.GtkIconPaintable // out
var _cret *C.GFile // in

_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_paintable_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// IconName: get the icon name being used for this icon.
// 
// When an icon looked up in the icon theme was not available, the icon theme
// may use fallback icons - either those specified to
// gtk_icon_theme_lookup_icon() or the always-available "image-missing". The
// icon chosen is returned by this function.
// 
// If the icon was created without an icon theme, this function returns nil.
	func (s IconPaintable) IconName() string {
var _arg0 *C.GtkIconPaintable // out
var _cret *C.char // in

_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_paintable_get_icon_name(_arg0)


var _filename string // out

_filename = C.GoString(_cret)

return _filename
}
	
	// IsSymbolic checks if the icon is symbolic or not.
// 
// This currently uses only the file name and not the file contents for
// determining this. This behaviour may change in the future.
// 
// Note that to render a symbolic `GtkIconPaintable` properly (with recoloring),
// you have to set its icon name on a `GtkImage`.
	func (s IconPaintable) IsSymbolic() bool {
var _arg0 *C.GtkIconPaintable // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconPaintable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_paintable_is_symbolic(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// IconTheme: `GtkIconTheme` provides a facility for loading themed icons.
// 
// The main reason for using a name rather than simply providing a filename is
// to allow different icons to be used depending on what icon theme is
// selected by the user. The operation of icon themes on Linux and Unix follows
// the Icon Theme Specification
// (http://www.freedesktop.org/Standards/icon-theme-spec) There is a fallback
// icon theme, named `hicolor`, where applications should install their icons,
// but additional icon themes can be installed as operating system vendors and
// users choose.
// 
// In many cases, named themes are used indirectly, via [class@Gtk.Image] rather
// than directly, but looking up icons directly is also simple. The
// `GtkIconTheme` object acts as a database of all the icons in the current
// theme. You can create new `GtkIconTheme` objects, but its much more
// efficient to use the standard icon theme of the `GtkWidget` so that the icon
// information is shared with other people looking up icons.
// 
// `c GtkIconTheme *icon_theme; GtkIconPaintable *icon; GdkPaintable
// *paintable;
// 
// icon_theme = gtk_icon_theme_get_for_display (gtk_widget_get_display
// (my_widget)); icon = gtk_icon_theme_lookup_icon (icon_theme, "my-icon-name",
// // icon name 48, // icon size 1, // scale 0, // flags); paintable =
// GDK_PAINTABLE (icon); // Use the paintable g_object_unref (icon); `
	type IconTheme struct {
		**externglib.Object
		
	}

	// IconThemeClass is an interface that the IconTheme class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IconThemeClass interface {
		gextras.Objector
		_iconTheme()
	}

	func (IconTheme) _iconTheme() {}

	
	func marshalIconTheme(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIconTheme(obj), nil
	}
	

	
	// NewIconTheme creates a new icon theme object.
// 
// Icon theme objects are used to lookup up an icon by name in a particular icon
// theme. Usually, youll want to use [func@Gtk.IconTheme.get_for_display]
// rather than creating a new icon theme object for scratch.
	func NewIconTheme() IconTheme {
var _cret *C.GtkIconTheme // in

_cret = C.gtk_icon_theme_new()


var _iconTheme IconTheme // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_iconTheme = IconTheme{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _iconTheme
}
	

	
	// AddResourcePath adds a resource path that will be looked at when looking for
// icons, similar to search paths.
// 
// See [method@Gtk.IconTheme.set_resource_path].
// 
// This function should be used to make application-specific icons available as
// part of the icon theme.
	func (s IconTheme) AddResourcePath(path string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.char // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_add_resource_path(_arg0, _arg1)
}
	
	// AddSearchPath appends a directory to the search path.
// 
// See [method@Gtk.IconTheme.set_search_path].
	func (s IconTheme) AddSearchPath(path string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.char // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_add_search_path(_arg0, _arg1)
}
	
	// Display returns the display that the `GtkIconTheme` object was created for.
	func (s IconTheme) Display() gdk.Display {
var _arg0 *C.GtkIconTheme // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_theme_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// IconNames lists the names of icons in the current icon theme.
	func (s IconTheme) IconNames() []string {
var _arg0 *C.GtkIconTheme // out
var _cret **C.char

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_theme_get_icon_names(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// IconSizes returns an array of integers describing the sizes at which the icon
// is available without scaling.
// 
// A size of -1 means that the icon is available in a scalable format. The array
// is zero-terminated.
	func (s IconTheme) IconSizes(iconName string) []int {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.char // out
var _cret *C.int

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_icon_theme_get_icon_sizes(_arg0, _arg1)


var _gints []int

{
var i int
var z C.int
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_gints = make([]int, i)
for i := range src {
_gints[i] = (int)(src[i])
}
}

return _gints
}
	
	// ResourcePath gets the current resource path.
// 
// See [method@Gtk.IconTheme.set_resource_path].
	func (s IconTheme) ResourcePath() []string {
var _arg0 *C.GtkIconTheme // out
var _cret **C.char

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_theme_get_resource_path(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// SearchPath gets the current search path.
// 
// See [method@Gtk.IconTheme.set_search_path].
	func (s IconTheme) SearchPath() []string {
var _arg0 *C.GtkIconTheme // out
var _cret **C.char

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_theme_get_search_path(_arg0)


var _filenames []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_filenames = make([]string, i)
for i := range src {
_filenames[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _filenames
}
	
	// ThemeName gets the current icon theme name.
// 
// Returns (transfer full): the current icon theme name,
	func (s IconTheme) ThemeName() string {
var _arg0 *C.GtkIconTheme // out
var _cret *C.char // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))

_cret = C.gtk_icon_theme_get_theme_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// HasGIcon checks whether an icon theme includes an icon for a particular
// `GIcon`.
	func (s IconTheme) HasGIcon(gicon gio.Icon) bool {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.GIcon // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))

_cret = C.gtk_icon_theme_has_gicon(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasIcon checks whether an icon theme includes an icon for a particular name.
	func (s IconTheme) HasIcon(iconName string) bool {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_icon_theme_has_icon(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LookupByGIcon looks up a icon for a desired size and window scale.
// 
// The icon can then be rendered by using it as a `GdkPaintable`, or you can get
// information such as the filename and size.
	func (s IconTheme) LookupByGIcon(icon gio.Icon, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.GIcon // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 C.GtkTextDirection // out
var _arg5 C.GtkIconLookupFlags // out
var _cret *C.GtkIconPaintable // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))
_arg2 = (C.int)(size)
_arg3 = (C.int)(scale)
_arg4 = (C.GtkTextDirection)(direction)
_arg5 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_lookup_by_gicon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)


var _iconPaintable IconPaintable // out

_iconPaintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconPaintable)

return _iconPaintable
}
	
	// LookupIcon looks up a named icon for a desired size and window scale,
// returning a `GtkIconPaintable`.
// 
// The icon can then be rendered by using it as a `GdkPaintable`, or you can get
// information such as the filename and size.
// 
// If the available @icon_name is not available and @fallbacks are provided,
// they will be tried in order.
// 
// If no matching icon is found, then a paintable that renders the "missing
// icon" icon is returned. If you need to do something else for missing icons
// you need to use [method@Gtk.IconTheme.has_icon].
// 
// Note that you probably want to listen for icon theme changes and update the
// icon. This is usually done by overriding the GtkWidgetClass.css-changed()
// function.
	func (s IconTheme) LookupIcon(iconName string, fallbacks []string, size int, scale int, direction TextDirection, flags IconLookupFlags) IconPaintable {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.char // out
var _arg2 **C.char
var _arg3 C.int // out
var _arg4 C.int // out
var _arg5 C.GtkTextDirection // out
var _arg6 C.GtkIconLookupFlags // out
var _cret *C.GtkIconPaintable // in

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (**C.char)(C.malloc(C.ulong(len(fallbacks)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(fallbacks))
for i := range fallbacks {
out[i] = (*C.char)(C.CString(fallbacks[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}
_arg3 = (C.int)(size)
_arg4 = (C.int)(scale)
_arg5 = (C.GtkTextDirection)(direction)
_arg6 = (C.GtkIconLookupFlags)(flags)

_cret = C.gtk_icon_theme_lookup_icon(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)


var _iconPaintable IconPaintable // out

_iconPaintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(IconPaintable)

return _iconPaintable
}
	
	// SetResourcePath sets the resource paths that will be looked at when looking
// for icons, similar to search paths.
// 
// The resources are considered as part of the hicolor icon theme and must be
// located in subdirectories that are defined in the hicolor icon theme, such as
// `@path/16x16/actions/run.png` or `@path/scalable/actions/run.svg`.
// 
// Icons that are directly placed in the resource path instead of a subdirectory
// are also considered as ultimate fallback, but they are treated like unthemed
// icons.
	func (s IconTheme) SetResourcePath(path *string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 **C.char // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (**C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_set_resource_path(_arg0, _arg1)
}
	
	// SetSearchPath sets the search path for the icon theme object.
// 
// When looking for an icon theme, GTK will search for a subdirectory of one or
// more of the directories in @path with the same name as the icon theme
// containing an index.theme file. (Themes from multiple of the path elements
// are combined to allow themes to be extended by adding icons in the users
// home directory.)
// 
// In addition if an icon found isnt found either in the current icon theme or
// the default icon theme, and an image file with the right name is found
// directly in one of the elements of @path, then that image will be used for
// the icon name. (This is legacy feature, and new icons should be put into the
// fallback icon theme, which is called hicolor, rather than directly on the
// icon path.)
	func (s IconTheme) SetSearchPath(path []string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 **C.char

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (**C.char)(C.malloc(C.ulong(len(path)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(path))
for i := range path {
out[i] = (*C.gchar)(C.CString(path[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_icon_theme_set_search_path(_arg0, _arg1)
}
	
	// SetThemeName sets the name of the icon theme that the `GtkIconTheme` object
// uses overriding system configuration.
// 
// This function cannot be called on the icon theme objects returned from
// [type_func@Gtk.IconTheme.get_for_display].
	func (s IconTheme) SetThemeName(themeName string)  {
var _arg0 *C.GtkIconTheme // out
var _arg1 *C.char // out

_arg0 = (*C.GtkIconTheme)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(themeName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_icon_theme_set_theme_name(_arg0, _arg1)
}
	


	// IconView: `GtkIconView` is a widget which displays data in a grid of icons.
// 
// `GtkIconView` provides an alternative view on a `GtkTreeModel`. It displays
// the model as a grid of icons with labels. Like [class@Gtk.TreeView], it
// allows to select one or multiple items (depending on the selection mode, see
// [method@Gtk.IconView.set_selection_mode]). In addition to selection with the
// arrow keys, `GtkIconView` supports rubberband selection, which is controlled
// by dragging the pointer.
// 
// Note that if the tree model is backed by an actual tree store (as opposed to
// a flat list where the mapping to icons is obvious), IconView will only
// display the first level of the tree and ignore the trees branches.
// 
// 
// CSS nodes
// 
// ` iconview.view  [rubberband] `
// 
// `GtkIconView` has a single CSS node with name iconview and style class .view.
// For rubberband selection, a subnode with name rubberband is used.
	type IconView struct {
		Widget
		Accessible
		Buildable
		CellLayout
		ConstraintTarget
		Scrollable
		
	}

	// IconViewClass is an interface that the IconView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type IconViewClass interface {
		gextras.Objector
		_iconView()
	}

	func (IconView) _iconView() {}

	
	func marshalIconView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapIconView(obj), nil
	}
	

	
	// NewIconView creates a new IconView widget
	func NewIconView() IconView {
var _cret *C.GtkWidget // in

_cret = C.gtk_icon_view_new()


var _iconView IconView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_iconView = IconView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconView
}
	
	// NewIconViewWithArea creates a new IconView widget using the specified @area
// to layout cells inside the icons.
	func NewIconViewWithArea(area CellAreaClass) IconView {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_icon_view_new_with_area(_arg1)


var _iconView IconView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_iconView = IconView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconView
}
	
	// NewIconViewWithModel creates a new IconView widget with the model @model.
	func NewIconViewWithModel(model TreeModel) IconView {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_icon_view_new_with_model(_arg1)


var _iconView IconView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_iconView = IconView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _iconView
}
	

	
	// CreateDragIcon creates a #cairo_surface_t representation of the item at
// @path. This image is used for a drag icon.
	func (i IconView) CreateDragIcon(path *TreePath) gdk.Paintable {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_create_drag_icon(_arg0, _arg1)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// EnableModelDragDest turns @icon_view into a drop destination for automatic
// DND. Calling this method sets IconView:reorderable to false.
	func (i IconView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GdkContentFormats // out
var _arg2 C.GdkDragAction // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
_arg2 = (C.GdkDragAction)(actions)

C.gtk_icon_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
}
	
	// EnableModelDragSource turns @icon_view into a drag source for automatic DND.
// Calling this method sets IconView:reorderable to false.
	func (i IconView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.GdkModifierType // out
var _arg2 *C.GdkContentFormats // out
var _arg3 C.GdkDragAction // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.GdkModifierType)(startButtonMask)
_arg2 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
_arg3 = (C.GdkDragAction)(actions)

C.gtk_icon_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
}
	
	// ActivateOnSingleClick gets the setting set by
// gtk_icon_view_set_activate_on_single_click().
	func (i IconView) ActivateOnSingleClick() bool {
var _arg0 *C.GtkIconView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CellRect fills the bounding rectangle in widget coordinates for the cell
// specified by @path and @cell. If @cell is nil the main cell area is used.
// 
// This function is only valid if @icon_view is realized.
	func (i IconView) CellRect(path *TreePath, cell CellRendererClass) (gdk.Rectangle, bool) {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkCellRenderer // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

_cret = C.gtk_icon_view_get_cell_rect(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// ColumnSpacing returns the value of the ::column-spacing property.
	func (i IconView) ColumnSpacing() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_column_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Columns returns the value of the ::columns property.
	func (i IconView) Columns() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_columns(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Cursor fills in @path and @cell with the current cursor path and cell. If the
// cursor isnt currently set, then *@path will be nil. If no cell currently has
// focus, then *@cell will be nil.
// 
// The returned TreePath must be freed with gtk_tree_path_free().
	func (i IconView) Cursor() (*TreePath, CellRenderer, bool) {
var _arg0 *C.GtkIconView // out
var _path *TreePath
var _arg2 *C.GtkCellRenderer // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)



var _cell CellRenderer // out
var _ok bool // out


_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(CellRenderer)
if _cret != 0 { _ok = true }

return _path, _cell, _ok
}
	
	// DestItemAtPos determines the destination item for a given position.
	func (i IconView) DestItemAtPos(dragX int, dragY int) (*TreePath, IconViewDropPosition, bool) {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _path *TreePath
var _arg4 C.GtkIconViewDropPosition // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(dragX)
_arg2 = (C.int)(dragY)

_cret = C.gtk_icon_view_get_dest_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)



var _pos IconViewDropPosition // out
var _ok bool // out


_pos = IconViewDropPosition(_arg4)
if _cret != 0 { _ok = true }

return _path, _pos, _ok
}
	
	// DragDestItem gets information about the item that is highlighted for
// feedback.
	func (i IconView) DragDestItem() (*TreePath, IconViewDropPosition) {
var _arg0 *C.GtkIconView // out
var _path *TreePath
var _arg2 C.GtkIconViewDropPosition // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_get_drag_dest_item(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)


var _pos IconViewDropPosition // out


_pos = IconViewDropPosition(_arg2)

return _path, _pos
}
	
	// ItemAtPos gets the path and cell for the icon at the given position.
	func (i IconView) ItemAtPos(x int, y int) (*TreePath, CellRenderer, bool) {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _path *TreePath
var _arg4 *C.GtkCellRenderer // in
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)

_cret = C.gtk_icon_view_get_item_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)



var _cell CellRenderer // out
var _ok bool // out


_cell = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(CellRenderer)
if _cret != 0 { _ok = true }

return _path, _cell, _ok
}
	
	// ItemColumn gets the column in which the item @path is currently displayed.
// Column numbers start at 0.
	func (i IconView) ItemColumn(path *TreePath) int {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_get_item_column(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ItemOrientation returns the value of the ::item-orientation property which
// determines whether the labels are drawn beside the icons instead of below.
	func (i IconView) ItemOrientation() Orientation {
var _arg0 *C.GtkIconView // out
var _cret C.GtkOrientation // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_item_orientation(_arg0)


var _orientation Orientation // out

_orientation = Orientation(_cret)

return _orientation
}
	
	// ItemPadding returns the value of the ::item-padding property.
	func (i IconView) ItemPadding() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_item_padding(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ItemRow gets the row in which the item @path is currently displayed. Row
// numbers start at 0.
	func (i IconView) ItemRow(path *TreePath) int {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_get_item_row(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ItemWidth returns the value of the ::item-width property.
	func (i IconView) ItemWidth() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_item_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Margin returns the value of the ::margin property.
	func (i IconView) Margin() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarkupColumn returns the column with markup text for @icon_view.
	func (i IconView) MarkupColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_markup_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the model the IconView is based on. Returns nil if the model is
// unset.
	func (i IconView) Model() TreeModel {
var _arg0 *C.GtkIconView // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// PathAtPos gets the path for the icon at the given position.
	func (i IconView) PathAtPos(x int, y int) *TreePath {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)

_cret = C.gtk_icon_view_get_path_at_pos(_arg0, _arg1, _arg2)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// PixbufColumn returns the column with pixbufs for @icon_view.
	func (i IconView) PixbufColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_pixbuf_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Reorderable retrieves whether the user can reorder the list via
// drag-and-drop. See gtk_icon_view_set_reorderable().
	func (i IconView) Reorderable() bool {
var _arg0 *C.GtkIconView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_reorderable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RowSpacing returns the value of the ::row-spacing property.
	func (i IconView) RowSpacing() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_row_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SelectionMode gets the selection mode of the @icon_view.
	func (i IconView) SelectionMode() SelectionMode {
var _arg0 *C.GtkIconView // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_selection_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// Spacing returns the value of the ::spacing property.
	func (i IconView) Spacing() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// TextColumn returns the column with text for @icon_view.
	func (i IconView) TextColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_text_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// TooltipColumn returns the column of @icon_views model which is being used
// for displaying tooltips on @icon_views rows.
	func (i IconView) TooltipColumn() int {
var _arg0 *C.GtkIconView // out
var _cret C.int // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_tooltip_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for IconView. The @x, @y and
// @keyboard_tip values which are received in the signal handler, should be
// passed to this function without modification.
// 
// The return value indicates whether there is an icon view item at the given
// coordinates (true) or not (false) for mouse tooltips. For keyboard tooltips
// the item returned will be the cursor item. When true, then any of @model,
// @path and @iter which have been provided will be set to point to that row and
// the corresponding model.
	func (i IconView) TooltipContext(x int, y int, keyboardTip bool) (TreeModel, *TreePath, TreeIter, bool) {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.gboolean // out
var _arg4 *C.GtkTreeModel // in
var _path *TreePath
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)
if keyboardTip { _arg3 = C.TRUE }

_cret = C.gtk_icon_view_get_tooltip_context(_arg0, _arg1, _arg2, _arg3, &_arg4, (**C.GtkTreePath)(unsafe.Pointer(&_path)), (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))


var _model TreeModel // out


var _ok bool // out

_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeModel)


if _cret != 0 { _ok = true }

return _model, _path, _iter, _ok
}
	
	// VisibleRange sets @start_path and @end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
// 
// Both paths should be freed with gtk_tree_path_free() after use.
	func (i IconView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
var _arg0 *C.GtkIconView // out
var _startPath *TreePath
var _endPath *TreePath
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

_cret = C.gtk_icon_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))




var _ok bool // out



if _cret != 0 { _ok = true }

return _startPath, _endPath, _ok
}
	
	// ItemActivated activates the item determined by @path.
	func (i IconView) ItemActivated(path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_item_activated(_arg0, _arg1)
}
	
	// PathIsSelected returns true if the icon pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned.
	func (i IconView) PathIsSelected(path *TreePath) bool {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_icon_view_path_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ScrollToPath moves the alignments of @icon_view to the position specified by
// @path. @row_align determines where the row is placed, and @col_align
// determines where @column is placed. Both are expected to be between 0.0 and
// 1.0. 0.0 means left/top alignment, 1.0 means right/bottom alignment, 0.5
// means center.
// 
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the item onto the screen. This
// means that the item will be scrolled to the edge closest to its current
// position. If the item is currently visible on the screen, nothing is done.
// 
// This function only works if the model is set, and @path is a valid row on the
// model. If the model changes before the @icon_view is realized, the centered
// path will be modified to reflect this change.
	func (i IconView) ScrollToPath(path *TreePath, useAlign bool, rowAlign float32, colAlign float32)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.gboolean // out
var _arg3 C.float // out
var _arg4 C.float // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
if useAlign { _arg2 = C.TRUE }
_arg3 = (C.float)(rowAlign)
_arg4 = (C.float)(colAlign)

C.gtk_icon_view_scroll_to_path(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SelectAll selects all the icons. @icon_view must has its selection mode set
// to K_SELECTION_MULTIPLE.
	func (i IconView) SelectAll()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_select_all(_arg0)
}
	
	// SelectPath selects the row at @path.
	func (i IconView) SelectPath(path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_select_path(_arg0, _arg1)
}
	
	// SetActivateOnSingleClick causes the IconView::item-activated signal to be
// emitted on a single click instead of a double click.
	func (i IconView) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
if single { _arg1 = C.TRUE }

C.gtk_icon_view_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetColumnSpacing sets the ::column-spacing property which specifies the space
// which is inserted between the columns of the icon view.
	func (i IconView) SetColumnSpacing(columnSpacing int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(columnSpacing)

C.gtk_icon_view_set_column_spacing(_arg0, _arg1)
}
	
	// SetColumns sets the ::columns property which determines in how many columns
// the icons are arranged. If @columns is -1, the number of columns will be
// chosen automatically to fill the available area.
	func (i IconView) SetColumns(columns int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(columns)

C.gtk_icon_view_set_columns(_arg0, _arg1)
}
	
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the users attention on a particular
// item. If @cell is not nil, then focus is given to the cell specified by it.
// Additionally, if @start_editing is true, then editing should be started in
// the specified cell.
// 
// This function is often followed by `gtk_widget_grab_focus (icon_view)` in
// order to give keyboard focus to the widget. Please note that editing can only
// happen when the widget is realized.
	func (i IconView) SetCursor(path *TreePath, cell CellRendererClass, startEditing bool)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkCellRenderer // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if startEditing { _arg3 = C.TRUE }

C.gtk_icon_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetDragDestItem sets the item that is highlighted for feedback.
	func (i IconView) SetDragDestItem(path *TreePath, pos IconViewDropPosition)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.GtkIconViewDropPosition // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (C.GtkIconViewDropPosition)(pos)

C.gtk_icon_view_set_drag_dest_item(_arg0, _arg1, _arg2)
}
	
	// SetItemOrientation sets the ::item-orientation property which determines
// whether the labels are drawn beside the icons instead of below.
	func (i IconView) SetItemOrientation(orientation Orientation)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.GtkOrientation // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.GtkOrientation)(orientation)

C.gtk_icon_view_set_item_orientation(_arg0, _arg1)
}
	
	// SetItemPadding sets the IconView:item-padding property which specifies the
// padding around each of the icon views items.
	func (i IconView) SetItemPadding(itemPadding int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(itemPadding)

C.gtk_icon_view_set_item_padding(_arg0, _arg1)
}
	
	// SetItemWidth sets the ::item-width property which specifies the width to use
// for each item. If it is set to -1, the icon view will automatically determine
// a suitable item size.
	func (i IconView) SetItemWidth(itemWidth int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(itemWidth)

C.gtk_icon_view_set_item_width(_arg0, _arg1)
}
	
	// SetMargin sets the ::margin property which specifies the space which is
// inserted at the top, bottom, left and right of the icon view.
	func (i IconView) SetMargin(margin int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(margin)

C.gtk_icon_view_set_margin(_arg0, _arg1)
}
	
	// SetMarkupColumn sets the column with markup information for @icon_view to be
// @column. The markup column must be of type TYPE_STRING. If the markup column
// is set to something, it overrides the text column set by
// gtk_icon_view_set_text_column().
	func (i IconView) SetMarkupColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(column)

C.gtk_icon_view_set_markup_column(_arg0, _arg1)
}
	
	// SetModel sets the model for a IconView. If the @icon_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
	func (i IconView) SetModel(model TreeModel)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_icon_view_set_model(_arg0, _arg1)
}
	
	// SetPixbufColumn sets the column with pixbufs for @icon_view to be @column.
// The pixbuf column must be of type K_TYPE_PIXBUF
	func (i IconView) SetPixbufColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(column)

C.gtk_icon_view_set_pixbuf_column(_arg0, _arg1)
}
	
	// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to the
// model's row_inserted and row_deleted signals. The reordering is implemented
// by setting up the icon view as a drag source and destination. Therefore, drag
// and drop can not be used in a reorderable view for any other purpose.
// 
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
	func (i IconView) SetReorderable(reorderable bool)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
if reorderable { _arg1 = C.TRUE }

C.gtk_icon_view_set_reorderable(_arg0, _arg1)
}
	
	// SetRowSpacing sets the ::row-spacing property which specifies the space which
// is inserted between the rows of the icon view.
	func (i IconView) SetRowSpacing(rowSpacing int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(rowSpacing)

C.gtk_icon_view_set_row_spacing(_arg0, _arg1)
}
	
	// SetSelectionMode sets the selection mode of the @icon_view.
	func (i IconView) SetSelectionMode(mode SelectionMode)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.GtkSelectionMode)(mode)

C.gtk_icon_view_set_selection_mode(_arg0, _arg1)
}
	
	// SetSpacing sets the ::spacing property which specifies the space which is
// inserted between the cells (i.e. the icon and the text) of an item.
	func (i IconView) SetSpacing(spacing int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(spacing)

C.gtk_icon_view_set_spacing(_arg0, _arg1)
}
	
	// SetTextColumn sets the column with text for @icon_view to be @column. The
// text column must be of type TYPE_STRING.
	func (i IconView) SetTextColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(column)

C.gtk_icon_view_set_text_column(_arg0, _arg1)
}
	
	// SetTooltipCell sets the tip area of @tooltip to the area which @cell occupies
// in the item pointed to by @path. See also gtk_tooltip_set_tip_area().
// 
// See also gtk_icon_view_set_tooltip_column() for a simpler alternative.
	func (i IconView) SetTooltipCell(tooltip TooltipClass, path *TreePath, cell CellRendererClass)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out
var _arg3 *C.GtkCellRenderer // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_icon_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full items, you can use this function to have IconView handle these
// automatically for you. @column should be set to the column in @icon_views
// model containing the tooltip texts, or -1 to disable this feature.
// 
// When enabled, Widget:has-tooltip will be set to true and @icon_view will
// connect a Widget::query-tooltip signal handler.
// 
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
	func (i IconView) SetTooltipColumn(column int)  {
var _arg0 *C.GtkIconView // out
var _arg1 C.int // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(column)

C.gtk_icon_view_set_tooltip_column(_arg0, _arg1)
}
	
	// SetTooltipItem sets the tip area of @tooltip to be the area covered by the
// item at @path. See also gtk_icon_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
	func (i IconView) SetTooltipItem(tooltip TooltipClass, path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_set_tooltip_item(_arg0, _arg1, _arg2)
}
	
	// UnselectAll unselects all the icons.
	func (i IconView) UnselectAll()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_unselect_all(_arg0)
}
	
	// UnselectPath unselects the row at @path.
	func (i IconView) UnselectPath(path *TreePath)  {
var _arg0 *C.GtkIconView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_icon_view_unselect_path(_arg0, _arg1)
}
	
	// UnsetModelDragDest undoes the effect of
// gtk_icon_view_enable_model_drag_dest(). Calling this method sets
// IconView:reorderable to false.
	func (i IconView) UnsetModelDragDest()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_unset_model_drag_dest(_arg0)
}
	
	// UnsetModelDragSource undoes the effect of
// gtk_icon_view_enable_model_drag_source(). Calling this method sets
// IconView:reorderable to false.
	func (i IconView) UnsetModelDragSource()  {
var _arg0 *C.GtkIconView // out

_arg0 = (*C.GtkIconView)(unsafe.Pointer(i.Native()))

C.gtk_icon_view_unset_model_drag_source(_arg0)
}
	


	// Image: the `GtkImage` widget displays an image.
// 
// !An example GtkImage (image.png)
// 
// Various kinds of object can be displayed as an image; most typically, you
// would load a `GdkTexture` from a file, using the convenience function
// [ctor@Gtk.Image.new_from_file], for instance:
// 
// `c GtkWidget *image = gtk_image_new_from_file ("myfile.png"); `
// 
// If the file isnt loaded successfully, the image will contain a broken
// image icon similar to that used in many web browsers.
// 
// If you want to handle errors in loading the file yourself, for example by
// displaying an error message, then load the image with
// [ctor@Gdk.Texture.new_from_file], then create the `GtkImage` with
// [ctor@Gtk.Image.new_from_paintable].
// 
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of `GResource` inside GIO, for
// details. In this case, [property@Gtk.Image:resource],
// [ctor@Gtk.Image.new_from_resource], and [method@Gtk.Image.set_from_resource]
// should be used.
// 
// `GtkImage` displays its image as an icon, with a size that is determined by
// the application. See [class@Gtk.Picture] if you want to show an image at is
// actual size.
// 
// 
// CSS nodes
// 
// `GtkImage` has a single CSS node with the name `image`. The style classes
// `.normal-icons` or `.large-icons` may appear, depending on the
// [property@Gtk.Image:icon-size] property.
// 
// 
// Accessibility
// 
// `GtkImage` uses the `GTK_ACCESSIBLE_ROLE_IMG` role.
	type Image struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// ImageClass is an interface that the Image class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ImageClass interface {
		gextras.Objector
		_image()
	}

	func (Image) _image() {}

	
	func marshalImage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapImage(obj), nil
	}
	

	
	// NewImage creates a new empty `GtkImage` widget.
	func NewImage() Image {
var _cret *C.GtkWidget // in

_cret = C.gtk_image_new()


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromFile creates a new `GtkImage` displaying the file @filename.
// 
// If the file isnt found or cant be loaded, the resulting `GtkImage` will
// display a broken image icon. This function never returns nil, it always
// returns a valid `GtkImage` widget.
// 
// If you need to detect failures to load the file, use
// [ctor@Gdk.Texture.new_from_file] to load the file yourself, then create the
// `GtkImage` from the texture.
// 
// The storage type (see [method@Gtk.Image.get_storage_type]) of the returned
// image is not defined, it will be whatever is appropriate for displaying the
// file.
	func NewImageFromFile(filename string) Image {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_image_new_from_file(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromGIcon creates a `GtkImage` displaying an icon from the current
// icon theme.
// 
// If the icon name isnt known, a broken image icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
	func NewImageFromGIcon(icon gio.Icon) Image {
var _arg1 *C.GIcon // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

_cret = C.gtk_image_new_from_gicon(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromIconName creates a `GtkImage` displaying an icon from the current
// icon theme.
// 
// If the icon name isnt known, a broken image icon will be displayed
// instead. If the current icon theme is changed, the icon will be updated
// appropriately.
	func NewImageFromIconName(iconName string) Image {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_image_new_from_icon_name(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromPaintable creates a new `GtkImage` displaying @paintable.
// 
// The `GtkImage` does not assume a reference to the paintable; you still need
// to unref it if you own references. `GtkImage` will add its own reference
// rather than adopting yours.
// 
// The `GtkImage` will track changes to the @paintable and update its size and
// contents in response to it.
	func NewImageFromPaintable(paintable gdk.Paintable) Image {
var _arg1 *C.GdkPaintable // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

_cret = C.gtk_image_new_from_paintable(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromPixbuf creates a new `GtkImage` displaying @pixbuf.
// 
// The `GtkImage` does not assume a reference to the pixbuf; you still need to
// unref it if you own references. `GtkImage` will add its own reference rather
// than adopting yours.
// 
// This is a helper for [ctor@Gtk.Image.new_from_paintable], and you can't get
// back the exact pixbuf once this is called, only a texture.
// 
// Note that this function just creates an `GtkImage` from the pixbuf. The
// `GtkImage` created will not react to state changes. Should you want that, you
// should use [ctor@Gtk.Image.new_from_icon_name].
	func NewImageFromPixbuf(pixbuf gdkpixbuf.PixbufClass) Image {
var _arg1 *C.GdkPixbuf // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_image_new_from_pixbuf(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	
	// NewImageFromResource creates a new `GtkImage` displaying the resource file
// @resource_path.
// 
// If the file isnt found or cant be loaded, the resulting `GtkImage` will
// display a broken image icon. This function never returns nil, it always
// returns a valid `GtkImage` widget.
// 
// If you need to detect failures to load the file, use
// [ctor@GdkPixbuf.Pixbuf.new_from_file] to load the file yourself, then create
// the `GtkImage` from the pixbuf.
// 
// The storage type (see [method@Gtk.Image.get_storage_type]) of the returned
// image is not defined, it will be whatever is appropriate for displaying the
// file.
	func NewImageFromResource(resourcePath string) Image {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_image_new_from_resource(_arg1)


var _image Image // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_image = Image{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _image
}
	

	
	// Clear resets the image to be empty.
	func (i Image) Clear()  {
var _arg0 *C.GtkImage // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

C.gtk_image_clear(_arg0)
}
	
	// GIcon gets the `GIcon` being displayed by the `GtkImage`.
// 
// The storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_GICON (see
// [method@Gtk.Image.get_storage_type]). The caller of this function does not
// own a reference to the returned `GIcon`.
	func (i Image) GIcon() gio.Icon {
var _arg0 *C.GtkImage // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_gicon(_arg0)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// IconName gets the icon name and size being displayed by the `GtkImage`.
// 
// The storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_ICON_NAME
// (see [method@Gtk.Image.get_storage_type]). The returned string is owned by
// the `GtkImage` and should not be freed.
	func (i Image) IconName() string {
var _arg0 *C.GtkImage // out
var _cret *C.char // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// IconSize gets the icon size used by the @image when rendering icons.
	func (i Image) IconSize() IconSize {
var _arg0 *C.GtkImage // out
var _cret C.GtkIconSize // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_icon_size(_arg0)


var _iconSize IconSize // out

_iconSize = IconSize(_cret)

return _iconSize
}
	
	// Paintable gets the image `GdkPaintable` being displayed by the `GtkImage`.
// 
// The storage type of the image must be GTK_IMAGE_EMPTY or GTK_IMAGE_PAINTABLE
// (see [method@Gtk.Image.get_storage_type]). The caller of this function does
// not own a reference to the returned paintable.
	func (i Image) Paintable() gdk.Paintable {
var _arg0 *C.GtkImage // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_paintable(_arg0)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// PixelSize gets the pixel size used for named icons.
	func (i Image) PixelSize() int {
var _arg0 *C.GtkImage // out
var _cret C.int // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_pixel_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// StorageType gets the type of representation being used by the `GtkImage` to
// store image data.
// 
// If the `GtkImage` has no image data, the return value will be
// GTK_IMAGE_EMPTY.
	func (i Image) StorageType() ImageType {
var _arg0 *C.GtkImage // out
var _cret C.GtkImageType // in

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))

_cret = C.gtk_image_get_storage_type(_arg0)


var _imageType ImageType // out

_imageType = ImageType(_cret)

return _imageType
}
	
	// SetFromFile sets a `GtkImage` to show a file.
// 
// See [ctor@Gtk.Image.new_from_file] for details.
	func (i Image) SetFromFile(filename string)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.char // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_image_set_from_file(_arg0, _arg1)
}
	
	// SetFromGIcon sets a `GtkImage` to show a `GIcon`.
// 
// See [ctor@Gtk.Image.new_from_gicon] for details.
	func (i Image) SetFromGIcon(icon gio.Icon)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(icon.Native()))

C.gtk_image_set_from_gicon(_arg0, _arg1)
}
	
	// SetFromIconName sets a `GtkImage` to show a named icon.
// 
// See [ctor@Gtk.Image.new_from_icon_name] for details.
	func (i Image) SetFromIconName(iconName string)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.char // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_image_set_from_icon_name(_arg0, _arg1)
}
	
	// SetFromPaintable sets a `GtkImage` to show a `GdkPaintable`.
// 
// See [ctor@Gtk.Image.new_from_paintable] for details.
	func (i Image) SetFromPaintable(paintable gdk.Paintable)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.GdkPaintable // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

C.gtk_image_set_from_paintable(_arg0, _arg1)
}
	
	// SetFromPixbuf sets a `GtkImage` to show a `GdkPixbuf`.
// 
// See [ctor@Gtk.Image.new_from_pixbuf] for details.
// 
// Note: This is a helper for [method@Gtk.Image.set_from_paintable], and you
// can't get back the exact pixbuf once this is called, only a paintable.
	func (i Image) SetFromPixbuf(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_image_set_from_pixbuf(_arg0, _arg1)
}
	
	// SetFromResource sets a `GtkImage` to show a resource.
// 
// See [ctor@Gtk.Image.new_from_resource] for details.
	func (i Image) SetFromResource(resourcePath string)  {
var _arg0 *C.GtkImage // out
var _arg1 *C.char // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_image_set_from_resource(_arg0, _arg1)
}
	
	// SetIconSize suggests an icon size to the theme for named icons.
	func (i Image) SetIconSize(iconSize IconSize)  {
var _arg0 *C.GtkImage // out
var _arg1 C.GtkIconSize // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (C.GtkIconSize)(iconSize)

C.gtk_image_set_icon_size(_arg0, _arg1)
}
	
	// SetPixelSize sets the pixel size to use for named icons.
// 
// If the pixel size is set to a value != -1, it is used instead of the icon
// size set by [method@Gtk.Image.set_from_icon_name].
	func (i Image) SetPixelSize(pixelSize int)  {
var _arg0 *C.GtkImage // out
var _arg1 C.int // out

_arg0 = (*C.GtkImage)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(pixelSize)

C.gtk_image_set_pixel_size(_arg0, _arg1)
}
	


	// InfoBar: `GtkInfoBar` can be show messages to the user without a dialog.
// 
// !An example GtkInfoBar (info-bar.png)
// 
// It is often temporarily shown at the top or bottom of a document. In contrast
// to [class@Gtk.Dialog], which has an action area at the bottom, `GtkInfoBar`
// has an action area at the side.
// 
// The API of `GtkInfoBar` is very similar to `GtkDialog`, allowing you to add
// buttons to the action area with [method@Gtk.InfoBar.add_button] or
// [ctor@Gtk.InfoBar.new_with_buttons]. The sensitivity of action widgets can be
// controlled with [method@Gtk.InfoBar.set_response_sensitive].
// 
// To add widgets to the main content area of a `GtkInfoBar`, use
// [method@Gtk.InfoBar.add_child].
// 
// Similar to [class@Gtk.MessageDialog], the contents of a `GtkInfoBar` can by
// classified as error message, warning, informational message, etc, by using
// [method@Gtk.InfoBar.set_message_type]. GTK may use the message type to
// determine how the message is displayed.
// 
// A simple example for using a `GtkInfoBar`: `c GtkWidget *message_label;
// GtkWidget *widget; GtkWidget *grid; GtkInfoBar *bar;
// 
// // set up info bar widget = gtk_info_bar_new (); bar = GTK_INFO_BAR (widget);
// // grid = gtk_grid_new ();
// 
// message_label = gtk_label_new (""); gtk_info_bar_add_child (bar,
// message_label); gtk_info_bar_add_button (bar, _("_OK"), GTK_RESPONSE_OK);
// g_signal_connect (bar, "response", G_CALLBACK (gtk_widget_hide), NULL);
// gtk_grid_attach (GTK_GRID (grid), widget, 0, 2, 1, 1);
// 
// // ...
// 
// // show an error message gtk_label_set_text (GTK_LABEL (message_label), "An
// // error occurred!"); gtk_info_bar_set_message_type (bar, GTK_MESSAGE_ERROR);
// // gtk_widget_show (bar); `
// 
// 
// GtkInfoBar as GtkBuildable
// 
// The `GtkInfoBar` implementation of the `GtkBuildable` interface exposes the
// content area and action area as internal children with the names
// content_area and action_area.
// 
// `GtkInfoBar` supports a custom <action-widgets> element, which can contain
// multiple <action-widget> elements. The response attribute specifies a
// numeric response, and the content of the element is the id of widget (which
// should be a child of the dialogs @action_area).
// 
// 
// CSS nodes
// 
// `GtkInfoBar` has a single CSS node with name infobar. The node may get one of
// the style classes .info, .warning, .error or .question, depending on the
// message type. If the info bar shows a close button, that button will have the
// .close style class applied.
	type InfoBar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// InfoBarClass is an interface that the InfoBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type InfoBarClass interface {
		gextras.Objector
		_infoBar()
	}

	func (InfoBar) _infoBar() {}

	
	func marshalInfoBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapInfoBar(obj), nil
	}
	

	
	// NewInfoBar creates a new `GtkInfoBar` object.
	func NewInfoBar() InfoBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_info_bar_new()


var _infoBar InfoBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_infoBar = InfoBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _infoBar
}
	

	
	// AddActionWidget: add an activatable widget to the action area of a
// `GtkInfoBar`.
// 
// This also connects a signal handler that will emit the
// [signal@Gtk.InfoBar::response] signal on the message area when the widget is
// activated. The widget is appended to the end of the message areas action
// area.
	func (i InfoBar) AddActionWidget(child WidgetClass, responseId int)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(responseId)

C.gtk_info_bar_add_action_widget(_arg0, _arg1, _arg2)
}
	
	// AddButton adds a button with the given text.
// 
// Clicking the button will emit the [signal@Gtk.InfoBar::response] signal with
// the given response_id. The button is appended to the end of the info bars's
// action area. The button widget is returned, but usually you don't need it.
	func (i InfoBar) AddButton(buttonText string, responseId int) Button {
var _arg0 *C.GtkInfoBar // out
var _arg1 *C.char // out
var _arg2 C.int // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(buttonText))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(responseId)

_cret = C.gtk_info_bar_add_button(_arg0, _arg1, _arg2)


var _button Button // out

_button = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

return _button
}
	
	// AddChild adds a widget to the content area of the info bar.
	func (i InfoBar) AddChild(widget WidgetClass)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_info_bar_add_child(_arg0, _arg1)
}
	
	// MessageType returns the message type of the message area.
	func (i InfoBar) MessageType() MessageType {
var _arg0 *C.GtkInfoBar // out
var _cret C.GtkMessageType // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_message_type(_arg0)


var _messageType MessageType // out

_messageType = MessageType(_cret)

return _messageType
}
	
	// Revealed returns whether the info bar is currently revealed.
	func (i InfoBar) Revealed() bool {
var _arg0 *C.GtkInfoBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_revealed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowCloseButton returns whether the widget will display a standard close
// button.
	func (i InfoBar) ShowCloseButton() bool {
var _arg0 *C.GtkInfoBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))

_cret = C.gtk_info_bar_get_show_close_button(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveActionWidget removes a widget from the action area of @info_bar.
// 
// The widget must have been put there by a call to
// [method@Gtk.InfoBar.add_action_widget] or [method@Gtk.InfoBar.add_button].
	func (i InfoBar) RemoveActionWidget(widget WidgetClass)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_info_bar_remove_action_widget(_arg0, _arg1)
}
	
	// RemoveChild removes a widget from the content area of the info bar.
	func (i InfoBar) RemoveChild(widget WidgetClass)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_info_bar_remove_child(_arg0, _arg1)
}
	
	// Response emits the response signal with the given @response_id.
	func (i InfoBar) Response(responseId int)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.int // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(responseId)

C.gtk_info_bar_response(_arg0, _arg1)
}
	
	// SetDefaultResponse sets the last widget in the info bars action area with
// the given response_id as the default widget for the dialog.
// 
// Pressing Enter normally activates the default widget.
// 
// Note that this function currently requires @info_bar to be added to a widget
// hierarchy.
	func (i InfoBar) SetDefaultResponse(responseId int)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.int // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(responseId)

C.gtk_info_bar_set_default_response(_arg0, _arg1)
}
	
	// SetMessageType sets the message type of the message area.
// 
// GTK uses this type to determine how the message is displayed.
	func (i InfoBar) SetMessageType(messageType MessageType)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.GtkMessageType // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.GtkMessageType)(messageType)

C.gtk_info_bar_set_message_type(_arg0, _arg1)
}
	
	// SetResponseSensitive sets the sensitivity of action widgets for @response_id.
// 
// Calls `gtk_widget_set_sensitive (widget, setting)` for each widget in the
// info barss action area with the given @response_id. A convenient way to
// sensitize/desensitize buttons.
	func (i InfoBar) SetResponseSensitive(responseId int, setting bool)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.int // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(responseId)
if setting { _arg2 = C.TRUE }

C.gtk_info_bar_set_response_sensitive(_arg0, _arg1, _arg2)
}
	
	// SetRevealed sets whether the `GtkInfoBar` is revealed.
// 
// Changing this will make @info_bar reveal or conceal itself via a sliding
// transition.
// 
// Note: this does not show or hide @info_bar in the
// [property@Gtk.Widget:visible] sense, so revealing has no effect if
// [property@Gtk.Widget:visible] is false.
	func (i InfoBar) SetRevealed(revealed bool)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
if revealed { _arg1 = C.TRUE }

C.gtk_info_bar_set_revealed(_arg0, _arg1)
}
	
	// SetShowCloseButton: if true, a standard close button is shown.
// 
// When clicked it emits the response GTK_RESPONSE_CLOSE.
	func (i InfoBar) SetShowCloseButton(setting bool)  {
var _arg0 *C.GtkInfoBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkInfoBar)(unsafe.Pointer(i.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_info_bar_set_show_close_button(_arg0, _arg1)
}
	


	// KeyvalTrigger: a `GtkShortcutTrigger` that triggers when a specific keyval
// and modifiers are pressed.
	type KeyvalTrigger struct {
		ShortcutTrigger
		
	}

	// KeyvalTriggerClass is an interface that the KeyvalTrigger class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type KeyvalTriggerClass interface {
		gextras.Objector
		_keyvalTrigger()
	}

	func (KeyvalTrigger) _keyvalTrigger() {}

	
	func marshalKeyvalTrigger(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapKeyvalTrigger(obj), nil
	}
	

	
	// NewKeyvalTrigger creates a `GtkShortcutTrigger` that will trigger whenever
// the key with the given @keyval and @modifiers is pressed.
	func NewKeyvalTrigger(keyval uint, modifiers gdk.ModifierType) KeyvalTrigger {
var _arg1 C.guint // out
var _arg2 C.GdkModifierType // out
var _cret *C.GtkShortcutTrigger // in

_arg1 = (C.guint)(keyval)
_arg2 = (C.GdkModifierType)(modifiers)

_cret = C.gtk_keyval_trigger_new(_arg1, _arg2)


var _keyvalTrigger KeyvalTrigger // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_keyvalTrigger = KeyvalTrigger{
ShortcutTrigger: ShortcutTrigger{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _keyvalTrigger
}
	

	
	// Keyval gets the keyval that must be pressed to succeed triggering @self.
	func (s KeyvalTrigger) Keyval() uint {
var _arg0 *C.GtkKeyvalTrigger // out
var _cret C.guint // in

_arg0 = (*C.GtkKeyvalTrigger)(unsafe.Pointer(s.Native()))

_cret = C.gtk_keyval_trigger_get_keyval(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Modifiers gets the modifiers that must be present to succeed triggering
// @self.
	func (s KeyvalTrigger) Modifiers() gdk.ModifierType {
var _arg0 *C.GtkKeyvalTrigger // out
var _cret C.GdkModifierType // in

_arg0 = (*C.GtkKeyvalTrigger)(unsafe.Pointer(s.Native()))

_cret = C.gtk_keyval_trigger_get_modifiers(_arg0)


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}
	


	// Label: the `GtkLabel` widget displays a small amount of text.
// 
// As the name implies, most labels are used to label another widget such as a
// [class@Button].
// 
// !An example GtkLabel (label.png)
// 
// 
// CSS nodes
// 
// ` label  [selection]  [link]   [link] `
// 
// `GtkLabel` has a single CSS node with the name label. A wide variety of style
// classes may be applied to labels, such as .title, .subtitle, .dim-label, etc.
// In the `GtkShortcutsWindow`, labels are used with the .keycap style class.
// 
// If the label has a selection, it gets a subnode with name selection.
// 
// If the label has links, there is one subnode per link. These subnodes carry
// the link or visited state depending on whether they have been visited. In
// this case, label node also gets a .link style class.
// 
// 
// GtkLabel as GtkBuildable
// 
// The GtkLabel implementation of the GtkBuildable interface supports a custom
// <attributes> element, which supports any number of <attribute> elements. The
// <attribute> element has attributes named name, value, start and end
// and allows you to specify [struct@Pango.Attribute] values for this label.
// 
// An example of a UI definition fragment specifying Pango attributes: `xml
// <object class="GtkLabel"> <attributes> <attribute name="weight"
// value="PANGO_WEIGHT_BOLD"/> <attribute name="background" value="red"
// start="5" end="10"/> </attributes> </object> `
// 
// The start and end attributes specify the range of characters to which the
// Pango attribute applies. If start and end are not specified, the attribute is
// applied to the whole text. Note that specifying ranges does not make much
// sense with translatable attributes. Use markup embedded in the translatable
// content instead.
// 
// 
// Accessibility
// 
// `GtkLabel` uses the K_ACCESSIBLE_ROLE_LABEL role.
// 
// 
// Mnemonics
// 
// Labels may contain mnemonics. Mnemonics are underlined characters in the
// label, used for keyboard navigation. Mnemonics are created by providing a
// string with an underscore before the mnemonic character, such as `"_File"`,
// to the functions [ctor@Gtk.Label.new_with_mnemonic] or
// [method@Gtk.Label.set_text_with_mnemonic].
// 
// Mnemonics automatically activate any activatable widget the label is inside,
// such as a [class@Gtk.Button]; if the label is not inside the mnemonics
// target widget, you have to tell the label about the target using
// [class@Gtk.Label.set_mnemonic_widget]. Heres a simple example where the
// label is inside a button:
// 
// `c // Pressing Alt+H will activate this button GtkWidget *button =
// gtk_button_new (); GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_button_set_child (GTK_BUTTON (button), label); `
// 
// Theres a convenience function to create buttons with a mnemonic label
// already inside:
// 
// `c // Pressing Alt+H will activate this button GtkWidget *button =
// gtk_button_new_with_mnemonic ("_Hello"); `
// 
// To create a mnemonic for a widget alongside the label, such as a
// [class@Gtk.Entry], you have to point the label at the entry with
// [method@Gtk.Label.set_mnemonic_widget]:
// 
// `c // Pressing Alt+H will focus the entry GtkWidget *entry = gtk_entry_new
// (); GtkWidget *label = gtk_label_new_with_mnemonic ("_Hello");
// gtk_label_set_mnemonic_widget (GTK_LABEL (label), entry); `
// 
// Markup (styled text)
// 
// To make it easy to format text in a label (changing colors, fonts, etc.),
// label text can be provided in a simple markup format:
// 
// Heres how to create a label with a small font: `c GtkWidget *label =
// gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL (label), "<small>Small
// text</small>"); `
// 
// (See the Pango manual for complete documentation] of available tags,
// [func@Pango.parse_markup])
// 
// The markup passed to gtk_label_set_markup() must be valid; for example,
// literal <, > and & characters must be escaped as &lt;, &gt;, and &amp;. If
// you pass text obtained from the user, file, or a network to
// [method@Gtk.Label.set_markup], youll want to escape it with
// g_markup_escape_text() or g_markup_printf_escaped().
// 
// Markup strings are just a convenient way to set the [struct@Pango.AttrList]
// on a label; [method@Gtk.Label.set_attributes] may be a simpler way to set
// attributes in some cases. Be careful though; [struct@Pango.AttrList] tends to
// cause internationalization problems, unless youre applying attributes to the
// entire string (i.e. unless you set the range of each attribute to [0,
// G_MAXINT)). The reason is that specifying the start_index and end_index for a
// [struct@Pango.Attribute] requires knowledge of the exact string being
// displayed, so translations will cause problems.
// 
// 
// Selectable labels
// 
// Labels can be made selectable with [method@Gtk.Label.set_selectable].
// Selectable labels allow the user to copy the label contents to the clipboard.
// Only labels that contain useful-to-copy information  such as error messages
//  should be made selectable.
// 
// 
// Text layout
// 
// A label can contain any number of paragraphs, but will have performance
// problems if it contains more than a small number. Paragraphs are separated by
// newlines or other paragraph separators understood by Pango.
// 
// Labels can automatically wrap text if you call [method@Gtk.Label.set_wrap].
// 
// [method@Gtk.Label.set_justify] sets how the lines in a label align with one
// another. If you want to set how the label as a whole aligns in its available
// space, see the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties.
// 
// The [property@Gtk.Label:width-chars] and [property@Gtk.Label:max-width-chars]
// properties can be used to control the size allocation of ellipsized or
// wrapped labels. For ellipsizing labels, if either is specified (and less than
// the actual text size), it is used as the minimum width, and the actual text
// size is used as the natural width of the label. For wrapping labels,
// width-chars is used as the minimum width, if specified, and max-width-chars
// is used as the natural width. Even if max-width-chars specified, wrapping
// labels will be rewrapped to use all of the available width.
// 
// 
// Links
// 
// GTK supports markup for clickable hyperlinks in addition to regular Pango
// markup. The markup for links is borrowed from HTML, using the `<a>` with
// href, title and class attributes. GTK renders links similar to the way
// they appear in web browsers, with colored, underlined text. The title
// attribute is displayed as a tooltip on the link. The class attribute is
// used as style class on the CSS node for the link.
// 
// An example looks like this:
// 
// `c const char *text = "Go to the" "<a href=\"http://www.gtk.org
// title=\"&lt;i&gt;Our&lt;/i&gt; website\">" "GTK website</a> for more...";
// GtkWidget *label = gtk_label_new (NULL); gtk_label_set_markup (GTK_LABEL
// (label), text); `
// 
// It is possible to implement custom handling for links and their tooltips with
// the [signal@Gtk.Label::activate-link] signal and the
// [method@Gtk.Label.get_current_uri] function.
	type Label struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// LabelClass is an interface that the Label class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LabelClass interface {
		gextras.Objector
		_label()
	}

	func (Label) _label() {}

	
	func marshalLabel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLabel(obj), nil
	}
	

	
	// NewLabel creates a new label with the given text inside it.
// 
// You can pass nil to get an empty label widget.
	func NewLabel(str string) Label {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_label_new(_arg1)


var _label Label // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_label = Label{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _label
}
	
	// NewLabelWithMnemonic creates a new `GtkLabel`, containing the text in @str.
// 
// If characters in @str are preceded by an underscore, they are underlined. If
// you need a literal underscore character in a label, use '__' (two
// underscores). The first underlined character represents a keyboard
// accelerator called a mnemonic. The mnemonic key can be used to activate
// another widget, chosen automatically, or explicitly using
// [method@Gtk.Label.set_mnemonic_widget].
// 
// If [method@Gtk.Label.set_mnemonic_widget] is not called, then the first
// activatable ancestor of the `GtkLabel` will be chosen as the mnemonic widget.
// For instance, if the label is inside a button or menu item, the button or
// menu item will automatically become the mnemonic widget and be activated by
// the mnemonic.
	func NewLabelWithMnemonic(str string) Label {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_label_new_with_mnemonic(_arg1)


var _label Label // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_label = Label{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _label
}
	

	
	// Attributes gets the labels attribute list.
// 
// This is the [struct@Pango.AttrList] that was set on the label using
// [method@Gtk.Label.set_attributes], if any. This function does not reflect
// attributes that come from the labels markup (see
// [method@Gtk.Label.set_markup]). If you want to get the effective attributes
// for the label, use `pango_layout_get_attribute (gtk_label_get_layout
// (self))`.
	func (s Label) Attributes() *pango.AttrList {
var _arg0 *C.GtkLabel // out
var _cret *C.PangoAttrList // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_attributes(_arg0)


var _attrList *pango.AttrList // out

_attrList = *(**pango.AttrList)(unsafe.Pointer(&_cret))

return _attrList
}
	
	// CurrentURI returns the URI for the currently active link in the label.
// 
// The active link is the one under the mouse pointer or, in a selectable label,
// the link in which the text cursor is currently positioned.
// 
// This function is intended for use in a [signal@Gtk.Label::activate-link]
// handler or for use in a [signal@Gtk.Widget::query-tooltip] handler.
	func (s Label) CurrentURI() string {
var _arg0 *C.GtkLabel // out
var _cret *C.char // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_current_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Ellipsize returns the ellipsizing position of the label.
// 
// See [method@Gtk.Label.set_ellipsize].
	func (s Label) Ellipsize() pango.EllipsizeMode {
var _arg0 *C.GtkLabel // out
var _cret C.PangoEllipsizeMode // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_ellipsize(_arg0)


var _ellipsizeMode pango.EllipsizeMode // out

_ellipsizeMode = pango.EllipsizeMode(_cret)

return _ellipsizeMode
}
	
	// ExtraMenu gets the extra menu model of @label.
// 
// See [method@Gtk.Label.set_extra_menu].
	func (s Label) ExtraMenu() gio.MenuModel {
var _arg0 *C.GtkLabel // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_extra_menu(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// Justify returns the justification of the label.
// 
// See [method@Gtk.Label.set_justify].
	func (s Label) Justify() Justification {
var _arg0 *C.GtkLabel // out
var _cret C.GtkJustification // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_justify(_arg0)


var _justification Justification // out

_justification = Justification(_cret)

return _justification
}
	
	// Label fetches the text from a label.
// 
// The returned text includes any embedded underlines indicating mnemonics and
// Pango markup. (See [method@Gtk.Label.get_text]).
	func (s Label) Label() string {
var _arg0 *C.GtkLabel // out
var _cret *C.char // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Layout gets the `PangoLayout` used to display the label.
// 
// The layout is useful to e.g. convert text positions to pixel positions, in
// combination with [method@Gtk.Label.get_layout_offsets]. The returned layout
// is owned by the @label so need not be freed by the caller. The @label is free
// to recreate its layout at any time, so it should be considered read-only.
	func (s Label) Layout() pango.Layout {
var _arg0 *C.GtkLabel // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_layout(_arg0)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// LayoutOffsets obtains the coordinates where the label will draw its
// `PangoLayout`.
// 
// The coordinates are useful to convert mouse events into coordinates inside
// the [class@Pango.Layout], e.g. to take some action if some part of the label
// is clicked. Remember when using the [class@Pango.Layout] functions you need
// to convert to and from pixels using PANGO_PIXELS() or [constant@Pango.SCALE].
	func (s Label) LayoutOffsets() (x int, y int) {
var _arg0 *C.GtkLabel // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

C.gtk_label_get_layout_offsets(_arg0, &_arg1, &_arg2)

var _x int // out
var _y int // out

_x = (int)(_arg1)
_y = (int)(_arg2)

return _x, _y
}
	
	// Lines gets the number of lines to which an ellipsized, wrapping label should
// be limited.
// 
// See [method@Gtk.Label.set_lines].
	func (s Label) Lines() int {
var _arg0 *C.GtkLabel // out
var _cret C.int // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_lines(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MaxWidthChars retrieves the desired maximum width of @label, in characters.
// 
// See [method@Gtk.Label.set_width_chars].
	func (s Label) MaxWidthChars() int {
var _arg0 *C.GtkLabel // out
var _cret C.int // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_max_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MnemonicKeyval: return the mnemonic accelerator.
// 
// If the label has been set so that it has a mnemonic key this function returns
// the keyval used for the mnemonic accelerator. If there is no mnemonic set up
// it returns `GDK_KEY_VoidSymbol`.
	func (s Label) MnemonicKeyval() uint {
var _arg0 *C.GtkLabel // out
var _cret C.guint // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_mnemonic_keyval(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// MnemonicWidget retrieves the target of the mnemonic (keyboard shortcut) of
// this label.
// 
// See [method@Gtk.Label.set_mnemonic_widget].
	func (s Label) MnemonicWidget() Widget {
var _arg0 *C.GtkLabel // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_mnemonic_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Selectable returns whether the label is selectable.
	func (s Label) Selectable() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_selectable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectionBounds gets the selected range of characters in the label.
	func (s Label) SelectionBounds() (start int, end int, ok bool) {
var _arg0 *C.GtkLabel // out
var _arg1 C.int // in
var _arg2 C.int // in
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_selection_bounds(_arg0, &_arg1, &_arg2)


var _start int // out
var _end int // out
var _ok bool // out

_start = (int)(_arg1)
_end = (int)(_arg2)
if _cret != 0 { _ok = true }

return _start, _end, _ok
}
	
	// SingleLineMode returns whether the label is in single line mode.
	func (s Label) SingleLineMode() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_single_line_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Text fetches the text from a label.
// 
// The returned text is as it appears on screen. This does not include any
// embedded underlines indicating mnemonics or Pango markup. (See
// [method@Gtk.Label.get_label])
	func (s Label) Text() string {
var _arg0 *C.GtkLabel // out
var _cret *C.char // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseMarkup returns whether the labels text is interpreted as Pango markup.
// 
// See [method@Gtk.Label.set_use_markup].
	func (s Label) UseMarkup() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_use_markup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UseUnderline returns whether an embedded underlines in the label indicate
// mnemonics.
// 
// See [method@Gtk.Label.set_use_underline].
	func (s Label) UseUnderline() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WidthChars retrieves the desired width of @label, in characters.
// 
// See [method@Gtk.Label.set_width_chars].
	func (s Label) WidthChars() int {
var _arg0 *C.GtkLabel // out
var _cret C.int // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_width_chars(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Wrap returns whether lines in the label are automatically wrapped.
// 
// See [method@Gtk.Label.set_wrap].
	func (s Label) Wrap() bool {
var _arg0 *C.GtkLabel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_wrap(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WrapMode returns line wrap mode used by the label.
// 
// See [method@Gtk.Label.set_wrap_mode].
	func (s Label) WrapMode() pango.WrapMode {
var _arg0 *C.GtkLabel // out
var _cret C.PangoWrapMode // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_wrap_mode(_arg0)


var _wrapMode pango.WrapMode // out

_wrapMode = pango.WrapMode(_cret)

return _wrapMode
}
	
	// Xalign gets the `xalign` of the label.
// 
// See the [property@Gtk.Label:xalign] property.
	func (s Label) Xalign() float32 {
var _arg0 *C.GtkLabel // out
var _cret C.float // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_xalign(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Yalign gets the `yalign` of the label.
// 
// See the [property@Gtk.Label:yalign] property.
	func (s Label) Yalign() float32 {
var _arg0 *C.GtkLabel // out
var _cret C.float // in

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_label_get_yalign(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// SelectRegion selects a range of characters in the label, if the label is
// selectable.
// 
// See [method@Gtk.Label.set_selectable]. If the label is not selectable, this
// function has no effect. If @start_offset or @end_offset are -1, then the end
// of the label will be substituted.
	func (s Label) SelectRegion(startOffset int, endOffset int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(startOffset)
_arg2 = (C.int)(endOffset)

C.gtk_label_select_region(_arg0, _arg1, _arg2)
}
	
	// SetAttributes: apply attributes to the label text.
// 
// The attributes set with this function will be applied and merged with any
// other attributes previously effected by way of the
// [property@Gtk.Label:use-underline] or [property@Gtk.Label:use-markup]
// properties. While it is not recommended to mix markup strings with manually
// set attributes, if you must; know that the attributes will be applied to the
// label after the markup string is parsed.
	func (s Label) SetAttributes(attrs *pango.AttrList)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.PangoAttrList // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

C.gtk_label_set_attributes(_arg0, _arg1)
}
	
	// SetEllipsize sets the mode used to ellipsizei the text.
// 
// The text will be ellipsized if there is not enough space to render the entire
// string.
	func (s Label) SetEllipsize(mode pango.EllipsizeMode)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.PangoEllipsizeMode // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.PangoEllipsizeMode)(mode)

C.gtk_label_set_ellipsize(_arg0, _arg1)
}
	
	// SetExtraMenu sets a menu model to add when constructing the context menu for
// @label.
	func (s Label) SetExtraMenu(model gio.MenuModelClass)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.gtk_label_set_extra_menu(_arg0, _arg1)
}
	
	// SetJustify sets the alignment of the lines in the text of the label relative
// to each other.
// 
// GTK_JUSTIFY_LEFT is the default value when the widget is first created with
// [ctor@Gtk.Label.new]. If you instead want to set the alignment of the label
// as a whole, use [method@Gtk.Widget.set_halign] instead.
// [method@Gtk.Label.set_justify] has no effect on labels containing only a
// single line.
	func (s Label) SetJustify(jtype Justification)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.GtkJustification // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkJustification)(jtype)

C.gtk_label_set_justify(_arg0, _arg1)
}
	
	// SetLabel sets the text of the label.
// 
// The label is interpreted as including embedded underlines and/or Pango markup
// depending on the values of the [property@Gtk.Label:use-underline] and
// [property@Gtk.Label:use-markup] properties.
	func (s Label) SetLabel(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.char // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_label(_arg0, _arg1)
}
	
	// SetLines sets the number of lines to which an ellipsized, wrapping label
// should be limited.
// 
// This has no effect if the label is not wrapping or ellipsized. Set this to -1
// if you dont want to limit the number of lines.
	func (s Label) SetLines(lines int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.int // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(lines)

C.gtk_label_set_lines(_arg0, _arg1)
}
	
	// SetMarkup sets the labels text and attributes from markup.
// 
// The string must be marked up with Pango markup (see
// [func@Pango.parse_markup]).
// 
// If the @str is external data, you may need to escape it with
// g_markup_escape_text() or g_markup_printf_escaped():
// 
// `c GtkWidget *self = gtk_label_new (NULL); const char *str = "..."; const
// char *format = "<span style=\"italic\">\s</span>"; char *markup;
// 
// markup = g_markup_printf_escaped (format, str); gtk_label_set_markup
// (GTK_LABEL (self), markup); g_free (markup); `
// 
// This function will set the [property@Gtk.Label:use-markup] property to true
// as a side effect.
// 
// If you set the label contents using the [property@Gtk.Label:label] property
// you should also ensure that you set the [property@Gtk.Label:use-markup]
// property accordingly.
// 
// See also: [method@Gtk.Label.set_text]
	func (s Label) SetMarkup(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.char // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_markup(_arg0, _arg1)
}
	
	// SetMarkupWithMnemonic sets the labels text, attributes and mnemonic from
// markup.
// 
// Parses @str which is marked up with Pango markup (see
// [func@Pango.parse_markup]), setting the labels text and attribute list based
// on the parse results. If characters in @str are preceded by an underscore,
// they are underlined indicating that they represent a keyboard accelerator
// called a mnemonic.
// 
// The mnemonic key can be used to activate another widget, chosen
// automatically, or explicitly using method@Gtk.Label.set_mnemonic_widget].
	func (s Label) SetMarkupWithMnemonic(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.char // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_markup_with_mnemonic(_arg0, _arg1)
}
	
	// SetMaxWidthChars sets the desired maximum width in characters of @label to
// @n_chars.
	func (s Label) SetMaxWidthChars(nChars int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.int // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(nChars)

C.gtk_label_set_max_width_chars(_arg0, _arg1)
}
	
	// SetMnemonicWidget: associate the label with its mnemonic target.
// 
// If the label has been set so that it has a mnemonic key (using i.e.
// [method@Gtk.Label.set_markup_with_mnemonic],
// [method@Gtk.Label.set_text_with_mnemonic], [ctor@Gtk.Label.new_with_mnemonic]
// or the [property@Gtk.Label:use_underline] property) the label can be
// associated with a widget that is the target of the mnemonic. When the label
// is inside a widget (like a [class@Gtk.Button] or a [class@Gtk.Notebook] tab)
// it is automatically associated with the correct widget, but sometimes (i.e.
// when the target is a [class@Gtk.Entry] next to the label) you need to set it
// explicitly using this function.
// 
// The target widget will be accelerated by emitting the
// [signal@GtkWidget::mnemonic-activate] signal on it. The default handler for
// this signal will activate the widget if there are no mnemonic collisions and
// toggle focus between the colliding widgets otherwise.
	func (s Label) SetMnemonicWidget(widget WidgetClass)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_label_set_mnemonic_widget(_arg0, _arg1)
}
	
	// SetSelectable makes text in the label selectable.
// 
// Selectable labels allow the user to select text from the label, for
// copy-and-paste.
	func (s Label) SetSelectable(setting bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_label_set_selectable(_arg0, _arg1)
}
	
	// SetSingleLineMode sets whether the label is in single line mode.
	func (s Label) SetSingleLineMode(singleLineMode bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
if singleLineMode { _arg1 = C.TRUE }

C.gtk_label_set_single_line_mode(_arg0, _arg1)
}
	
	// SetText sets the text within the `GtkLabel` widget.
// 
// It overwrites any text that was there before.
// 
// This function will clear any previously set mnemonic accelerators, and set
// the [property@Gtk.Label:use-underline property] to false as a side effect.
// 
// This function will set the [property@Gtk.Label:use-markup] property to false
// as a side effect.
// 
// See also: [method@Gtk.Label.set_markup]
	func (s Label) SetText(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.char // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_text(_arg0, _arg1)
}
	
	// SetTextWithMnemonic sets the labels text from the string @str.
// 
// If characters in @str are preceded by an underscore, they are underlined
// indicating that they represent a keyboard accelerator called a mnemonic. The
// mnemonic key can be used to activate another widget, chosen automatically, or
// explicitly using [method@Gtk.Label.set_mnemonic_widget].
	func (s Label) SetTextWithMnemonic(str string)  {
var _arg0 *C.GtkLabel // out
var _arg1 *C.char // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_label_set_text_with_mnemonic(_arg0, _arg1)
}
	
	// SetUseMarkup sets whether the text of the label contains markup.
// 
// See [method@Gtk.Label.set_markup].
	func (s Label) SetUseMarkup(setting bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_label_set_use_markup(_arg0, _arg1)
}
	
	// SetUseUnderline sets whether underlines in the text indicate mnemonics.
	func (s Label) SetUseUnderline(setting bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_label_set_use_underline(_arg0, _arg1)
}
	
	// SetWidthChars sets the desired width in characters of @label to @n_chars.
	func (s Label) SetWidthChars(nChars int)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.int // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(nChars)

C.gtk_label_set_width_chars(_arg0, _arg1)
}
	
	// SetWrap toggles line wrapping within the `GtkLabel` widget.
// 
// true makes it break lines if text exceeds the widgets size. false lets the
// text get cut off by the edge of the widget if it exceeds the widget size.
// 
// Note that setting line wrapping to true does not make the label wrap at its
// parent containers width, because GTK widgets conceptually cant make their
// requisition depend on the parent containers size. For a label that wraps at
// a specific position, set the labels width using
// [method@Gtk.Widget.set_size_request].
	func (s Label) SetWrap(wrap bool)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
if wrap { _arg1 = C.TRUE }

C.gtk_label_set_wrap(_arg0, _arg1)
}
	
	// SetWrapMode controls how line wrapping is done.
// 
// This only affects the label if line wrapping is on. (See
// [method@Gtk.Label.set_wrap]) The default is PANGO_WRAP_WORD which means wrap
// on word boundaries.
	func (s Label) SetWrapMode(wrapMode pango.WrapMode)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.PangoWrapMode // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.PangoWrapMode)(wrapMode)

C.gtk_label_set_wrap_mode(_arg0, _arg1)
}
	
	// SetXalign sets the `xalign` of the label.
// 
// See the [property@Gtk.Label:xalign] property.
	func (s Label) SetXalign(xalign float32)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.float // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(xalign)

C.gtk_label_set_xalign(_arg0, _arg1)
}
	
	// SetYalign sets the `yalign` of the label.
// 
// See the [property@Gtk.Label:yalign] property.
	func (s Label) SetYalign(yalign float32)  {
var _arg0 *C.GtkLabel // out
var _arg1 C.float // out

_arg0 = (*C.GtkLabel)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(yalign)

C.gtk_label_set_yalign(_arg0, _arg1)
}
	


	// LayoutChild: `GtkLayoutChild` is the base class for objects that are meant to
// hold layout properties.
// 
// If a `GtkLayoutManager` has per-child properties, like their packing type, or
// the horizontal and vertical span, or the icon name, then the layout manager
// should use a `GtkLayoutChild` implementation to store those properties.
// 
// A `GtkLayoutChild` instance is only ever valid while a widget is part of a
// layout.
	type LayoutChild struct {
		**externglib.Object
		
	}

	// LayoutChildClass is an interface that the LayoutChild class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LayoutChildClass interface {
		gextras.Objector
		_layoutChild()
	}

	func (LayoutChild) _layoutChild() {}

	
	func marshalLayoutChild(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLayoutChild(obj), nil
	}
	

	

	
	// ChildWidget retrieves the `GtkWidget` associated to the given @layout_child.
	func (l LayoutChild) ChildWidget() Widget {
var _arg0 *C.GtkLayoutChild // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkLayoutChild)(unsafe.Pointer(l.Native()))

_cret = C.gtk_layout_child_get_child_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// LayoutManager retrieves the `GtkLayoutManager` instance that created the
// given @layout_child.
	func (l LayoutChild) LayoutManager() LayoutManager {
var _arg0 *C.GtkLayoutChild // out
var _cret *C.GtkLayoutManager // in

_arg0 = (*C.GtkLayoutChild)(unsafe.Pointer(l.Native()))

_cret = C.gtk_layout_child_get_layout_manager(_arg0)


var _layoutManager LayoutManager // out

_layoutManager = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(LayoutManager)

return _layoutManager
}
	


	// LayoutManager: layout managers are delegate classes that handle the preferred
// size and the allocation of a widget.
// 
// You typically subclass `GtkLayoutManager` if you want to implement a layout
// policy for the children of a widget, or if you want to determine the size of
// a widget depending on its contents.
// 
// Each `GtkWidget` can only have a `GtkLayoutManager` instance associated to it
// at any given time; it is possible, though, to replace the layout manager
// instance using [method@Gtk.Widget.set_layout_manager].
// 
// 
// Layout properties
// 
// A layout manager can expose properties for controlling the layout of each
// child, by creating an object type derived from [class@Gtk.LayoutChild] and
// installing the properties on it as normal `GObject` properties.
// 
// Each `GtkLayoutChild` instance storing the layout properties for a specific
// child is created through the [method@Gtk.LayoutManager.get_layout_child]
// method; a `GtkLayoutManager` controls the creation of its `GtkLayoutChild`
// instances by overriding the GtkLayoutManagerClass.create_layout_child()
// virtual function. The typical implementation should look like:
// 
// `c static GtkLayoutChild * create_layout_child (GtkLayoutManager *manager,
// GtkWidget *container, GtkWidget *child) { return g_object_new
// (your_layout_child_get_type (), "layout-manager", manager, "child-widget",
// child, NULL); } `
// 
// The [property@Gtk.LayoutChild:layout-manager] and
// [property@Gtk.LayoutChild:child-widget] properties on the newly created
// `GtkLayoutChild` instance are mandatory. The `GtkLayoutManager` will cache
// the newly created `GtkLayoutChild` instance until the widget is removed from
// its parent, or the parent removes the layout manager.
// 
// Each `GtkLayoutManager` instance creating a `GtkLayoutChild` should use
// [method@Gtk.LayoutManager.get_layout_child] every time it needs to query the
// layout properties; each `GtkLayoutChild` instance should call
// [method@Gtk.LayoutManager.layout_changed] every time a property is updated,
// in order to queue a new size measuring and allocation.
	type LayoutManager struct {
		**externglib.Object
		
	}

	// LayoutManagerClass is an interface that the LayoutManager class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LayoutManagerClass interface {
		gextras.Objector
		_layoutManager()
	}

	func (LayoutManager) _layoutManager() {}

	
	func marshalLayoutManager(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLayoutManager(obj), nil
	}
	

	

	
	// Allocate assigns the given @width, @height, and @baseline to a @widget, and
// computes the position and sizes of the children of the @widget using the
// layout management policy of @manager.
	func (m LayoutManager) Allocate(widget WidgetClass, width int, height int, baseline int)  {
var _arg0 *C.GtkLayoutManager // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 C.int // out

_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.int)(width)
_arg3 = (C.int)(height)
_arg4 = (C.int)(baseline)

C.gtk_layout_manager_allocate(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// LayoutChild retrieves a `GtkLayoutChild` instance for the `GtkLayoutManager`,
// creating one if necessary.
// 
// The @child widget must be a child of the widget using @manager.
// 
// The `GtkLayoutChild` instance is owned by the `GtkLayoutManager`, and is
// guaranteed to exist as long as @child is a child of the `GtkWidget` using the
// given `GtkLayoutManager`.
	func (m LayoutManager) LayoutChild(child WidgetClass) LayoutChild {
var _arg0 *C.GtkLayoutManager // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkLayoutChild // in

_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_layout_manager_get_layout_child(_arg0, _arg1)


var _layoutChild LayoutChild // out

_layoutChild = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(LayoutChild)

return _layoutChild
}
	
	// RequestMode retrieves the request mode of @manager.
	func (m LayoutManager) RequestMode() SizeRequestMode {
var _arg0 *C.GtkLayoutManager // out
var _cret C.GtkSizeRequestMode // in

_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_layout_manager_get_request_mode(_arg0)


var _sizeRequestMode SizeRequestMode // out

_sizeRequestMode = SizeRequestMode(_cret)

return _sizeRequestMode
}
	
	// Widget retrieves the `GtkWidget` using the given `GtkLayoutManager`.
	func (m LayoutManager) Widget() Widget {
var _arg0 *C.GtkLayoutManager // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_layout_manager_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// LayoutChanged queues a resize on the `GtkWidget` using @manager, if any.
// 
// This function should be called by subclasses of `GtkLayoutManager` in
// response to changes to their layout management policies.
	func (m LayoutManager) LayoutChanged()  {
var _arg0 *C.GtkLayoutManager // out

_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))

C.gtk_layout_manager_layout_changed(_arg0)
}
	
	// Measure measures the size of the @widget using @manager, for the given
// @orientation and size.
// 
// See the [class@Gtk.Widget] documentation on layout management for more
// details.
	func (m LayoutManager) Measure(widget WidgetClass, orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
var _arg0 *C.GtkLayoutManager // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkOrientation // out
var _arg3 C.int // out
var _arg4 C.int // in
var _arg5 C.int // in
var _arg6 C.int // in
var _arg7 C.int // in

_arg0 = (*C.GtkLayoutManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkOrientation)(orientation)
_arg3 = (C.int)(forSize)

C.gtk_layout_manager_measure(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5, &_arg6, &_arg7)

var _minimum int // out
var _natural int // out
var _minimumBaseline int // out
var _naturalBaseline int // out

_minimum = (int)(_arg4)
_natural = (int)(_arg5)
_minimumBaseline = (int)(_arg6)
_naturalBaseline = (int)(_arg7)

return _minimum, _natural, _minimumBaseline, _naturalBaseline
}
	


	// LevelBar: `GtkLevelBar` is a widget that can be used as a level indicator.
// 
// Typical use cases are displaying the strength of a password, or showing the
// charge level of a battery.
// 
// !An example GtkLevelBar (levelbar.png)
// 
// Use [method@Gtk.LevelBar.set_value] to set the current value, and
// [method@Gtk.LevelBar.add_offset_value] to set the value offsets at which the
// bar will be considered in a different state. GTK will add a few offsets by
// default on the level bar: GTK_LEVEL_BAR_OFFSET_LOW, GTK_LEVEL_BAR_OFFSET_HIGH
// and GTK_LEVEL_BAR_OFFSET_FULL, with values 0.25, 0.75 and 1.0 respectively.
// 
// Note that it is your responsibility to update preexisting offsets when
// changing the minimum or maximum value. GTK will simply clamp them to the new
// range.
// 
// 
// Adding a custom offset on the bar
// 
// `c static GtkWidget * create_level_bar (void) { GtkWidget *widget;
// GtkLevelBar *bar;
// 
//    widget = gtk_level_bar_new ();
//    bar = GTK_LEVEL_BAR (widget);
// 
//    // This changes the value of the default low offset
// 
//    gtk_level_bar_add_offset_value (bar,
//                                    GTK_LEVEL_BAR_OFFSET_LOW,
//                                    0.10);
// 
//    // This adds a new offset to the bar; the application will
//    // be able to change its color CSS like this:
//    //
//    // levelbar block.my-offset {
//    //   background-color: magenta;
//    //   border-style: solid;
//    //   border-color: black;
//    //   border-style: 1px;
//    // }
// 
//    gtk_level_bar_add_offset_value (bar, "my-offset", 0.60);
// 
//    return widget;
// 
// } `
// 
// The default interval of values is between zero and one, but its possible to
// modify the interval using [method@Gtk.LevelBar.set_min_value] and
// [method@Gtk.LevelBar.set_max_value]. The value will be always drawn in
// proportion to the admissible interval, i.e. a value of 15 with a specified
// interval between 10 and 20 is equivalent to a value of 0.5 with an interval
// between 0 and 1. When K_LEVEL_BAR_MODE_DISCRETE is used, the bar level is
// rendered as a finite number of separated blocks instead of a single one. The
// number of blocks that will be rendered is equal to the number of units
// specified by the admissible interval.
// 
// For instance, to build a bar rendered with five blocks, its sufficient to
// set the minimum value to 0 and the maximum value to 5 after changing the
// indicator mode to discrete.
// 
// 
// GtkLevelBar as GtkBuildable
// 
// The `GtkLevelBar` implementation of the `GtkBuildable` interface supports a
// custom <offsets> element, which can contain any number of <offset> elements,
// each of which must have name and value attributes.
// 
// 
// CSS nodes
// 
// ` levelbar[.discrete]  trough  block.filled.level-name  
// block.empty  `
// 
// `GtkLevelBar` has a main CSS node with name levelbar and one of the style
// classes .discrete or .continuous and a subnode with name trough. Below the
// trough node are a number of nodes with name block and style class .filled or
// .empty. In continuous mode, there is exactly one node of each, in discrete
// mode, the number of filled and unfilled nodes corresponds to blocks that are
// drawn. The block.filled nodes also get a style class .level-name
// corresponding to the level for the current value.
// 
// In horizontal orientation, the nodes are always arranged from left to right,
// regardless of text direction.
// 
// 
// Accessibility
// 
// `GtkLevelBar` uses the K_ACCESSIBLE_ROLE_METER role.
	type LevelBar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// LevelBarClass is an interface that the LevelBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LevelBarClass interface {
		gextras.Objector
		_levelBar()
	}

	func (LevelBar) _levelBar() {}

	
	func marshalLevelBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLevelBar(obj), nil
	}
	

	
	// NewLevelBar creates a new `GtkLevelBar`.
	func NewLevelBar() LevelBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_level_bar_new()


var _levelBar LevelBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_levelBar = LevelBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _levelBar
}
	
	// NewLevelBarForInterval creates a new `GtkLevelBar` for the specified
// interval.
	func NewLevelBarForInterval(minValue float64, maxValue float64) LevelBar {
var _arg1 C.double // out
var _arg2 C.double // out
var _cret *C.GtkWidget // in

_arg1 = (C.double)(minValue)
_arg2 = (C.double)(maxValue)

_cret = C.gtk_level_bar_new_for_interval(_arg1, _arg2)


var _levelBar LevelBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_levelBar = LevelBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _levelBar
}
	

	
	// AddOffsetValue adds a new offset marker on @self at the position specified by
// @value.
// 
// When the bar value is in the interval topped by @value (or between @value and
// [property@Gtk.LevelBar:max-value] in case the offset is the last one on the
// bar) a style class named `level-`@name will be applied when rendering the
// level bar fill.
// 
// If another offset marker named @name exists, its value will be replaced by
// @value.
	func (s LevelBar) AddOffsetValue(name string, value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 *C.char // out
var _arg2 C.double // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.double)(value)

C.gtk_level_bar_add_offset_value(_arg0, _arg1, _arg2)
}
	
	// Inverted returns whether the levelbar is inverted.
	func (s LevelBar) Inverted() bool {
var _arg0 *C.GtkLevelBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_inverted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MaxValue returns the `max-value` of the `GtkLevelBar`.
	func (s LevelBar) MaxValue() float64 {
var _arg0 *C.GtkLevelBar // out
var _cret C.double // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_max_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// MinValue returns the `min-value of the `GtkLevelBar`.
	func (s LevelBar) MinValue() float64 {
var _arg0 *C.GtkLevelBar // out
var _cret C.double // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_min_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Mode returns the `mode` of the `GtkLevelBar`.
	func (s LevelBar) Mode() LevelBarMode {
var _arg0 *C.GtkLevelBar // out
var _cret C.GtkLevelBarMode // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_mode(_arg0)


var _levelBarMode LevelBarMode // out

_levelBarMode = LevelBarMode(_cret)

return _levelBarMode
}
	
	// OffsetValue fetches the value specified for the offset marker @name in @self.
	func (s LevelBar) OffsetValue(name string) (float64, bool) {
var _arg0 *C.GtkLevelBar // out
var _arg1 *C.char // out
var _arg2 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_level_bar_get_offset_value(_arg0, _arg1, &_arg2)


var _value float64 // out
var _ok bool // out

_value = (float64)(_arg2)
if _cret != 0 { _ok = true }

return _value, _ok
}
	
	// Value returns the `value` of the `GtkLevelBar`.
	func (s LevelBar) Value() float64 {
var _arg0 *C.GtkLevelBar // out
var _cret C.double // in

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_level_bar_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// RemoveOffsetValue removes an offset marker from a `GtkLevelBar`.
// 
// The marker must have been previously added with
// [method@Gtk.LevelBar.add_offset_value].
	func (s LevelBar) RemoveOffsetValue(name string)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 *C.char // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_level_bar_remove_offset_value(_arg0, _arg1)
}
	
	// SetInverted sets whether the `GtkLevelBar` is inverted.
	func (s LevelBar) SetInverted(inverted bool)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
if inverted { _arg1 = C.TRUE }

C.gtk_level_bar_set_inverted(_arg0, _arg1)
}
	
	// SetMaxValue sets the `max-value` of the `GtkLevelBar`.
// 
// You probably want to update preexisting level offsets after calling this
// function.
	func (s LevelBar) SetMaxValue(value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.double // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(value)

C.gtk_level_bar_set_max_value(_arg0, _arg1)
}
	
	// SetMinValue sets the `min-value` of the `GtkLevelBar`.
// 
// You probably want to update preexisting level offsets after calling this
// function.
	func (s LevelBar) SetMinValue(value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.double // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(value)

C.gtk_level_bar_set_min_value(_arg0, _arg1)
}
	
	// SetMode sets the `mode` of the `GtkLevelBar`.
	func (s LevelBar) SetMode(mode LevelBarMode)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.GtkLevelBarMode // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkLevelBarMode)(mode)

C.gtk_level_bar_set_mode(_arg0, _arg1)
}
	
	// SetValue sets the value of the `GtkLevelBar`.
	func (s LevelBar) SetValue(value float64)  {
var _arg0 *C.GtkLevelBar // out
var _arg1 C.double // out

_arg0 = (*C.GtkLevelBar)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(value)

C.gtk_level_bar_set_value(_arg0, _arg1)
}
	


	// LinkButton: a `GtkLinkButton` is a button with a hyperlink.
// 
// !An example GtkLinkButton (link-button.png)
// 
// It is useful to show quick links to resources.
// 
// A link button is created by calling either [ctor@Gtk.LinkButton.new] or
// [ctor@Gtk.LinkButton.new_with_label]. If using the former, the URI you pass
// to the constructor is used as a label for the widget.
// 
// The URI bound to a `GtkLinkButton` can be set specifically using
// [method@Gtk.LinkButton.set_uri].
// 
// By default, `GtkLinkButton` calls [func@Gtk.show_uri] when the button is
// clicked. This behaviour can be overridden by connecting to the
// [signal@Gtk.LinkButton::activate-link] signal and returning true from the
// signal handler.
// 
// 
// CSS nodes
// 
// `GtkLinkButton` has a single CSS node with name button. To differentiate it
// from a plain `GtkButton`, it gets the .link style class.
// 
// 
// Accessibility
// 
// `GtkLinkButton` uses the K_ACCESSIBLE_ROLE_LINK role.
	type LinkButton struct {
		Button
		Accessible
		Actionable
		Buildable
		ConstraintTarget
		
	}

	// LinkButtonClass is an interface that the LinkButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LinkButtonClass interface {
		gextras.Objector
		_linkButton()
	}

	func (LinkButton) _linkButton() {}

	
	func marshalLinkButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLinkButton(obj), nil
	}
	

	
	// NewLinkButton creates a new `GtkLinkButton` with the URI as its text.
	func NewLinkButton(uri string) LinkButton {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_link_button_new(_arg1)


var _linkButton LinkButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_linkButton = LinkButton{
Button: Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _linkButton
}
	
	// NewLinkButtonWithLabel creates a new `GtkLinkButton` containing a label.
	func NewLinkButtonWithLabel(uri string, label string) LinkButton {
var _arg1 *C.char // out
var _arg2 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_link_button_new_with_label(_arg1, _arg2)


var _linkButton LinkButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_linkButton = LinkButton{
Button: Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _linkButton
}
	

	
	// URI retrieves the URI of the `GtkLinkButton`.
	func (l LinkButton) URI() string {
var _arg0 *C.GtkLinkButton // out
var _cret *C.char // in

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

_cret = C.gtk_link_button_get_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Visited retrieves the visited state of the `GtkLinkButton`.
// 
// The button becomes visited when it is clicked. If the URI is changed on the
// button, the visited state is unset again.
// 
// The state may also be changed using [method@Gtk.LinkButton.set_visited].
	func (l LinkButton) Visited() bool {
var _arg0 *C.GtkLinkButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))

_cret = C.gtk_link_button_get_visited(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetURI sets @uri as the URI where the `GtkLinkButton` points.
// 
// As a side-effect this unsets the visited state of the button.
	func (l LinkButton) SetURI(uri string)  {
var _arg0 *C.GtkLinkButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_link_button_set_uri(_arg0, _arg1)
}
	
	// SetVisited sets the visited state of the `GtkLinkButton`.
// 
// See [method@Gtk.LinkButton.get_visited] for more details.
	func (l LinkButton) SetVisited(visited bool)  {
var _arg0 *C.GtkLinkButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkLinkButton)(unsafe.Pointer(l.Native()))
if visited { _arg1 = C.TRUE }

C.gtk_link_button_set_visited(_arg0, _arg1)
}
	


	// ListBase: `GtkListBase` is the abstract base class for GTK's list widgets.
	type ListBase struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		Scrollable
		
	}

	// ListBaseClass is an interface that the ListBase class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListBaseClass interface {
		gextras.Objector
		_listBase()
	}

	func (ListBase) _listBase() {}

	
	func marshalListBase(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListBase(obj), nil
	}
	

	

	


	// ListBox: `GtkListBox` is a vertical list.
// 
// A `GtkListBox` only contains `GtkListBoxRow` children. These rows can by
// dynamically sorted and filtered, and headers can be added dynamically
// depending on the row content. It also allows keyboard and mouse navigation
// and selection like a typical list.
// 
// Using `GtkListBox` is often an alternative to `GtkTreeView`, especially when
// the list contents has a more complicated layout than what is allowed by a
// `GtkCellRenderer`, or when the contents is interactive (i.e. has a button in
// it).
// 
// Although a `GtkListBox` must have only `GtkListBoxRow` children, you can add
// any kind of widget to it via [method@Gtk.ListBox.prepend],
// [method@Gtk.ListBox.append] and [method@Gtk.ListBox.insert] and a
// `GtkListBoxRow` widget will automatically be inserted between the list and
// the widget.
// 
// `GtkListBoxRows` can be marked as activatable or selectable. If a row is
// activatable, [signal@Gtk.ListBox::row-activated] will be emitted for it when
// the user tries to activate it. If it is selectable, the row will be marked as
// selected when the user tries to select it.
// 
// 
// GtkListBox as GtkBuildable
// 
// The `GtkListBox` implementation of the `GtkBuildable` interface supports
// setting a child as the placeholder by specifying placeholder as the type
// attribute of a <child> element. See [method@Gtk.ListBox.set_placeholder] for
// info.
// 
// CSS nodes
// 
//    list[.separators][.rich-list][.navigation-sidebar]
//     row[.activatable]
// 
// `GtkListBox` uses a single CSS node named list. It may carry the .separators
// style class, when the [property@Gtk.ListBox:show-separators] property is set.
// Each `GtkListBoxRow` uses a single CSS node named row. The row nodes get the
// .activatable style class added when appropriate.
// 
// The main list node may also carry style classes to select the style of list
// presentation (section-list-widget.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
// 
// 
// Accessibility
// 
// `GtkListBox` uses the GTK_ACCESSIBLE_ROLE_LIST role and `GtkListBoxRow` uses
// the GTK_ACCESSIBLE_ROLE_LIST_ITEM role.
	type ListBox struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// ListBoxClass is an interface that the ListBox class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListBoxClass interface {
		gextras.Objector
		_listBox()
	}

	func (ListBox) _listBox() {}

	
	func marshalListBox(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListBox(obj), nil
	}
	

	
	// NewListBox creates a new `GtkListBox` container.
	func NewListBox() ListBox {
var _cret *C.GtkWidget // in

_cret = C.gtk_list_box_new()


var _listBox ListBox // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_listBox = ListBox{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _listBox
}
	

	
	// Append: append a widget to the list.
// 
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
	func (b ListBox) Append(child WidgetClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_list_box_append(_arg0, _arg1)
}
	
	// DragHighlightRow: add a drag highlight to a row.
// 
// This is a helper function for implementing DnD onto a `GtkListBox`. The
// passed in @row will be highlighted by setting the GTK_STATE_FLAG_DROP_ACTIVE
// state and any previously highlighted row will be unhighlighted.
// 
// The row will also be unhighlighted when the widget gets a drag leave event.
	func (b ListBox) DragHighlightRow(row ListBoxRowClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

C.gtk_list_box_drag_highlight_row(_arg0, _arg1)
}
	
	// DragUnhighlightRow: if a row has previously been highlighted via
// gtk_list_box_drag_highlight_row(), it will have the highlight removed.
	func (b ListBox) DragUnhighlightRow()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_drag_unhighlight_row(_arg0)
}
	
	// ActivateOnSingleClick returns whether rows activate on single clicks.
	func (b ListBox) ActivateOnSingleClick() bool {
var _arg0 *C.GtkListBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Adjustment gets the adjustment (if any) that the widget uses to for vertical
// scrolling.
	func (b ListBox) Adjustment() Adjustment {
var _arg0 *C.GtkListBox // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// RowAtIndex gets the n-th child in the list (not counting headers).
// 
// If @index_ is negative or larger than the number of items in the list, nil is
// returned.
	func (b ListBox) RowAtIndex(index_ int) ListBoxRow {
var _arg0 *C.GtkListBox // out
var _arg1 C.int // out
var _cret *C.GtkListBoxRow // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.int)(index_)

_cret = C.gtk_list_box_get_row_at_index(_arg0, _arg1)


var _listBoxRow ListBoxRow // out

_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

return _listBoxRow
}
	
	// RowAtY gets the row at the @y position.
	func (b ListBox) RowAtY(y int) ListBoxRow {
var _arg0 *C.GtkListBox // out
var _arg1 C.int // out
var _cret *C.GtkListBoxRow // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.int)(y)

_cret = C.gtk_list_box_get_row_at_y(_arg0, _arg1)


var _listBoxRow ListBoxRow // out

_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

return _listBoxRow
}
	
	// SelectedRow gets the selected row, or nil if no rows are selected.
// 
// Note that the box may allow multiple selection, in which case you should use
// [method@Gtk.ListBox.selected_foreach] to find all selected rows.
	func (b ListBox) SelectedRow() ListBoxRow {
var _arg0 *C.GtkListBox // out
var _cret *C.GtkListBoxRow // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_selected_row(_arg0)


var _listBoxRow ListBoxRow // out

_listBoxRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListBoxRow)

return _listBoxRow
}
	
	// SelectionMode gets the selection mode of the listbox.
	func (b ListBox) SelectionMode() SelectionMode {
var _arg0 *C.GtkListBox // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_selection_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// ShowSeparators returns whether the list box should show separators between
// rows.
	func (b ListBox) ShowSeparators() bool {
var _arg0 *C.GtkListBox // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

_cret = C.gtk_list_box_get_show_separators(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Insert: insert the @child into the @box at @position.
// 
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
// 
// If @position is -1, or larger than the total number of items in the @box,
// then the @child will be appended to the end.
	func (b ListBox) Insert(child WidgetClass, position int)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(position)

C.gtk_list_box_insert(_arg0, _arg1, _arg2)
}
	
	// InvalidateFilter: update the filtering for all rows.
// 
// Call this when result of the filter function on the @box is changed due to an
// external factor. For instance, this would be used if the filter function just
// looked for a specific search string and the entry with the search string has
// changed.
	func (b ListBox) InvalidateFilter()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_invalidate_filter(_arg0)
}
	
	// InvalidateHeaders: update the separators for all rows.
// 
// Call this when result of the header function on the @box is changed due to an
// external factor.
	func (b ListBox) InvalidateHeaders()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_invalidate_headers(_arg0)
}
	
	// InvalidateSort: update the sorting for all rows.
// 
// Call this when result of the sort function on the @box is changed due to an
// external factor.
	func (b ListBox) InvalidateSort()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_invalidate_sort(_arg0)
}
	
	// Prepend: prepend a widget to the list.
// 
// If a sort function is set, the widget will actually be inserted at the
// calculated position.
	func (b ListBox) Prepend(child WidgetClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_list_box_prepend(_arg0, _arg1)
}
	
	// Remove removes a child from @box.
	func (b ListBox) Remove(child WidgetClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_list_box_remove(_arg0, _arg1)
}
	
	// SelectAll: select all children of @box, if the selection mode allows it.
	func (b ListBox) SelectAll()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_select_all(_arg0)
}
	
	// SelectRow: make @row the currently selected row.
	func (b ListBox) SelectRow(row ListBoxRowClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

C.gtk_list_box_select_row(_arg0, _arg1)
}
	
	// SetActivateOnSingleClick: if @single is true, rows will be activated when you
// click on them, otherwise you need to double-click.
	func (b ListBox) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkListBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
if single { _arg1 = C.TRUE }

C.gtk_list_box_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetAdjustment sets the adjustment (if any) that the widget uses to for
// vertical scrolling.
// 
// For instance, this is used to get the page size for PageUp/Down key handling.
// 
// In the normal case when the @box is packed inside a `GtkScrolledWindow` the
// adjustment from that will be picked up automatically, so there is no need to
// manually do that.
	func (b ListBox) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_list_box_set_adjustment(_arg0, _arg1)
}
	
	// SetPlaceholder sets the placeholder widget that is shown in the list when it
// doesn't display any visible children.
	func (b ListBox) SetPlaceholder(placeholder WidgetClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(placeholder.Native()))

C.gtk_list_box_set_placeholder(_arg0, _arg1)
}
	
	// SetSelectionMode sets how selection works in the listbox.
	func (b ListBox) SetSelectionMode(mode SelectionMode)  {
var _arg0 *C.GtkListBox // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (C.GtkSelectionMode)(mode)

C.gtk_list_box_set_selection_mode(_arg0, _arg1)
}
	
	// SetShowSeparators sets whether the list box should show separators between
// rows.
	func (b ListBox) SetShowSeparators(showSeparators bool)  {
var _arg0 *C.GtkListBox // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
if showSeparators { _arg1 = C.TRUE }

C.gtk_list_box_set_show_separators(_arg0, _arg1)
}
	
	// UnselectAll: unselect all children of @box, if the selection mode allows it.
	func (b ListBox) UnselectAll()  {
var _arg0 *C.GtkListBox // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))

C.gtk_list_box_unselect_all(_arg0)
}
	
	// UnselectRow unselects a single row of @box, if the selection mode allows it.
	func (b ListBox) UnselectRow(row ListBoxRowClass)  {
var _arg0 *C.GtkListBox // out
var _arg1 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBox)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkListBoxRow)(unsafe.Pointer(row.Native()))

C.gtk_list_box_unselect_row(_arg0, _arg1)
}
	


	// ListBoxRow: `GtkListBoxRow` is the kind of widget that can be added to a
// `GtkListBox`.
	type ListBoxRow struct {
		Widget
		Accessible
		Actionable
		Buildable
		ConstraintTarget
		
	}

	// ListBoxRowClass is an interface that the ListBoxRow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListBoxRowClass interface {
		gextras.Objector
		_listBoxRow()
	}

	func (ListBoxRow) _listBoxRow() {}

	
	func marshalListBoxRow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListBoxRow(obj), nil
	}
	

	
	// NewListBoxRow creates a new `GtkListBoxRow`.
	func NewListBoxRow() ListBoxRow {
var _cret *C.GtkWidget // in

_cret = C.gtk_list_box_row_new()


var _listBoxRow ListBoxRow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_listBoxRow = ListBoxRow{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _listBoxRow
}
	

	
	// Changed marks @row as changed, causing any state that depends on this to be
// updated.
// 
// This affects sorting, filtering and headers.
// 
// Note that calls to this method must be in sync with the data used for the row
// functions. For instance, if the list is mirroring some external data set, and
// *two* rows changed in the external data set then when you call
// gtk_list_box_row_changed() on the first row the sort function must only read
// the new data for the first of the two changed rows, otherwise the resorting
// of the rows will be wrong.
// 
// This generally means that if you dont fully control the data model you have
// to duplicate the data that affects the listbox row functions into the row
// widgets themselves. Another alternative is to call
// [method@Gtk.ListBox.invalidate_sort] on any model change, but that is more
// expensive.
	func (r ListBoxRow) Changed()  {
var _arg0 *C.GtkListBoxRow // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

C.gtk_list_box_row_changed(_arg0)
}
	
	// Activatable gets whether the row is activatable.
	func (r ListBoxRow) Activatable() bool {
var _arg0 *C.GtkListBoxRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Child gets the child widget of @row.
	func (r ListBoxRow) Child() Widget {
var _arg0 *C.GtkListBoxRow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Header returns the current header of the @row.
// 
// This can be used in a [callback@Gtk.ListBoxUpdateHeaderFunc] to see if there
// is a header set already, and if so to update the state of it.
	func (r ListBoxRow) Header() Widget {
var _arg0 *C.GtkListBoxRow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_header(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Index gets the current index of the @row in its `GtkListBox` container.
	func (r ListBoxRow) Index() int {
var _arg0 *C.GtkListBoxRow // out
var _cret C.int // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Selectable gets whether the row can be selected.
	func (r ListBoxRow) Selectable() bool {
var _arg0 *C.GtkListBoxRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_get_selectable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSelected returns whether the child is currently selected in its
// `GtkListBox` container.
	func (r ListBoxRow) IsSelected() bool {
var _arg0 *C.GtkListBoxRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))

_cret = C.gtk_list_box_row_is_selected(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActivatable: set whether the row is activatable.
	func (r ListBoxRow) SetActivatable(activatable bool)  {
var _arg0 *C.GtkListBoxRow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
if activatable { _arg1 = C.TRUE }

C.gtk_list_box_row_set_activatable(_arg0, _arg1)
}
	
	// SetChild sets the child widget of @self.
	func (r ListBoxRow) SetChild(child WidgetClass)  {
var _arg0 *C.GtkListBoxRow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_list_box_row_set_child(_arg0, _arg1)
}
	
	// SetHeader sets the current header of the @row.
// 
// This is only allowed to be called from a
// [callback@Gtk.ListBoxUpdateHeaderFunc]. It will replace any existing header
// in the row, and be shown in front of the row in the listbox.
	func (r ListBoxRow) SetHeader(header WidgetClass)  {
var _arg0 *C.GtkListBoxRow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(header.Native()))

C.gtk_list_box_row_set_header(_arg0, _arg1)
}
	
	// SetSelectable: set whether the row can be selected.
	func (r ListBoxRow) SetSelectable(selectable bool)  {
var _arg0 *C.GtkListBoxRow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListBoxRow)(unsafe.Pointer(r.Native()))
if selectable { _arg1 = C.TRUE }

C.gtk_list_box_row_set_selectable(_arg0, _arg1)
}
	


	// ListItem: `GtkListItem` is used by list widgets to represent items in a
// `GListModel`.
// 
// The `GtkListItem`s are managed by the list widget (with its factory) and
// cannot be created by applications, but they need to be populated by
// application code. This is done by calling [method@Gtk.ListItem.set_child].
// 
// `GtkListItem`s exist in 2 stages:
// 
// 1. The unbound stage where the listitem is not currently connected to an item
// in the list. In that case, the [property@Gtk.ListItem:item] property is set
// to nil.
// 
// 2. The bound stage where the listitem references an item from the list. The
// [property@Gtk.ListItem:item] property is not nil.
	type ListItem struct {
		**externglib.Object
		
	}

	// ListItemClass is an interface that the ListItem class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListItemClass interface {
		gextras.Objector
		_listItem()
	}

	func (ListItem) _listItem() {}

	
	func marshalListItem(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListItem(obj), nil
	}
	

	

	
	// Activatable checks if a list item has been set to be activatable via
// gtk_list_item_set_activatable().
	func (s ListItem) Activatable() bool {
var _arg0 *C.GtkListItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_item_get_activatable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Child gets the child previously set via gtk_list_item_set_child() or nil if
// none was set.
	func (s ListItem) Child() Widget {
var _arg0 *C.GtkListItem // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_item_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Item gets the model item that associated with @self.
// 
// If @self is unbound, this function returns nil.
	func (s ListItem) Item() **externglib.Object {
var _arg0 *C.GtkListItem // out
var _cret C.gpointer // in

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_item_get_item(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// Position gets the position in the model that @self currently displays.
// 
// If @self is unbound, GTK_INVALID_LIST_POSITION is returned.
	func (s ListItem) Position() uint {
var _arg0 *C.GtkListItem // out
var _cret C.guint // in

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_item_get_position(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Selectable checks if a list item has been set to be selectable via
// gtk_list_item_set_selectable().
// 
// Do not confuse this function with [method@Gtk.ListItem.get_selected].
	func (s ListItem) Selectable() bool {
var _arg0 *C.GtkListItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_item_get_selectable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Selected checks if the item is displayed as selected.
// 
// The selected state is maintained by the liste widget and its model and cannot
// be set otherwise.
	func (s ListItem) Selected() bool {
var _arg0 *C.GtkListItem // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_item_get_selected(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActivatable sets @self to be activatable.
// 
// If an item is activatable, double-clicking on the item, using the Return key
// or calling gtk_widget_activate() will activate the item. Activating instructs
// the containing view to handle activation. `GtkListView` for example will be
// emitting the [signal@Gtk.ListView::activate] signal.
// 
// By default, list items are activatable.
	func (s ListItem) SetActivatable(activatable bool)  {
var _arg0 *C.GtkListItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
if activatable { _arg1 = C.TRUE }

C.gtk_list_item_set_activatable(_arg0, _arg1)
}
	
	// SetChild sets the child to be used for this listitem.
// 
// This function is typically called by applications when setting up a listitem
// so that the widget can be reused when binding it multiple times.
	func (s ListItem) SetChild(child WidgetClass)  {
var _arg0 *C.GtkListItem // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_list_item_set_child(_arg0, _arg1)
}
	
	// SetSelectable sets @self to be selectable.
// 
// If an item is selectable, clicking on the item or using the keyboard will try
// to select or unselect the item. If this succeeds is up to the model to
// determine, as it is managing the selected state.
// 
// Note that this means that making an item non-selectable has no influence on
// the selected state at all. A non-selectable item may still be selected.
// 
// By default, list items are selectable. When rebinding them to a new item,
// they will also be reset to be selectable by GTK.
	func (s ListItem) SetSelectable(selectable bool)  {
var _arg0 *C.GtkListItem // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListItem)(unsafe.Pointer(s.Native()))
if selectable { _arg1 = C.TRUE }

C.gtk_list_item_set_selectable(_arg0, _arg1)
}
	


	// ListItemFactory: a `GtkListItemFactory` creates widgets for the items taken
// from a `GListModel`.
// 
// This is one of the core concepts of handling list widgets such as
// [class@Gtk.ListView] or [class@Gtk.GridView].
// 
// The `GtkListItemFactory` is tasked with creating widgets for items taken from
// the model when the views need them and updating them as the items displayed
// by the view change.
// 
// A view is usually only able to display anything after both a factory and a
// model have been set on the view. So it is important that you do not skip this
// step when setting up your first view.
// 
// Because views do not display the whole list at once but only a few items,
// they only need to maintain a few widgets at a time. They will instruct the
// `GtkListItemFactory` to create these widgets and bind them to the items that
// are currently displayed.
// 
// As the list model changes or the user scrolls to the list, the items will
// change and the view will instruct the factory to bind the widgets to those
// new items.
// 
// The actual widgets used for displaying those widgets is provided by you.
// 
// When the factory needs widgets created, it will create a `GtkListItem` and
// hand it to your code to set up a widget for. This list item will provide
// various properties with information about what item to display and provide
// you with some opportunities to configure its behavior. See the
// [class@Gtk.ListItem] documentation for further details.
// 
// Various implementations of `GtkListItemFactory` exist to allow you different
// ways to provide those widgets. The most common implementations are
// [class@Gtk.BuilderListItemFactory] which takes a `GtkBuilder` .ui file and
// then creates widgets and manages everything automatically from the
// information in that file and [class@Gtk.SignalListItemFactory] which allows
// you to connect to signals with your own code and retain full control over how
// the widgets are setup and managed.
// 
// A `GtkListItemFactory` is supposed to be final - that means its behavior
// should not change and the first widget created from it should behave the same
// way as the last widget created from it. If you intend to do changes to the
// behavior, it is recommended that you create a new `GtkListItemFactory` which
// will allow the views to recreate its widgets.
// 
// Once you have chosen your factory and created it, you need to set it on the
// view widget you want to use it with, such as via
// [method@Gtk.ListView.set_factory]. Reusing factories across different views
// is allowed, but very uncommon.
	type ListItemFactory struct {
		**externglib.Object
		
	}

	// ListItemFactoryClass is an interface that the ListItemFactory class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListItemFactoryClass interface {
		gextras.Objector
		_listItemFactory()
	}

	func (ListItemFactory) _listItemFactory() {}

	
	func marshalListItemFactory(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListItemFactory(obj), nil
	}
	

	

	


	// ListStore: a list-like data structure that can be used with the GtkTreeView
// 
// The ListStore object is a list model for use with a TreeView widget. It
// implements the TreeModel interface, and consequentialy, can use all of the
// methods available there. It also implements the TreeSortable interface so it
// can be sorted by the view. Finally, it also implements the tree [drag and
// drop][gtk4-GtkTreeView-drag-and-drop] interfaces.
// 
// The ListStore can accept most GObject types as a column type, though it cant
// accept all custom types. Internally, it will keep a copy of data passed in
// (such as a string or a boxed pointer). Columns that accept #GObjects are
// handled a little differently. The ListStore will keep a reference to the
// object instead of copying the value. As a result, if the object is modified,
// it is up to the application writer to call gtk_tree_model_row_changed() to
// emit the TreeModel::row_changed signal. This most commonly affects lists with
// Textures stored.
// 
// An example for creating a simple list store:
// 
//    <object class="GtkListStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//      <data>
//        <row>
//          <col id="0">John</col>
//          <col id="1">Doe</col>
//          <col id="2">25</col>
//        </row>
//        <row>
//          <col id="0">Johan</col>
//          <col id="1">Dahlin</col>
//          <col id="2">50</col>
//        </row>
//      </data>
//    </object>
	type ListStore struct {
		**externglib.Object
		Buildable
		TreeDragDest
		TreeDragSource
		TreeModel
		TreeSortable
		
	}

	// ListStoreClass is an interface that the ListStore class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListStoreClass interface {
		gextras.Objector
		_listStore()
	}

	func (ListStore) _listStore() {}

	
	func marshalListStore(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListStore(obj), nil
	}
	

	
	// NewListStoreV: non-vararg creation function. Used primarily by language
// bindings.
	func NewListStoreV(types []externglib.Type) ListStore {
var _arg2 *C.GType
var _arg1 C.int
var _cret *C.GtkListStore // in

_arg1 = C.int(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

_cret = C.gtk_list_store_newv(_arg1, _arg2)


var _listStore ListStore // out

_listStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(ListStore)

return _listStore
}
	

	
	// Append appends a new row to @list_store. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
	func (l ListStore) Append() TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

C.gtk_list_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// Clear removes all rows from the list store.
	func (l ListStore) Clear()  {
var _arg0 *C.GtkListStore // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

C.gtk_list_store_clear(_arg0)
}
	
	// Insert creates a new row at @position. @iter will be changed to point to this
// new row. If @position is -1 or is larger than the number of rows on the list,
// then the new row will be appended to the list. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_list_store_set() or gtk_list_store_set_value().
	func (l ListStore) Insert(position int) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 C.int // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (C.int)(position)

C.gtk_list_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then the
// row will be prepended to the beginning of the list. @iter will be changed to
// point to this new row. The row will be empty after this function is called.
// To fill in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
	func (l ListStore) InsertAfter(sibling *TreeIter) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_list_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then the
// row will be appended to the end of the list. @iter will be changed to point
// to this new row. The row will be empty after this function is called. To fill
// in values, you need to call gtk_list_store_set() or
// gtk_list_store_set_value().
	func (l ListStore) InsertBefore(sibling *TreeIter) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_list_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// InsertWithValuesv: a variant of gtk_list_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs.
// 
// This function is mainly intended for language-bindings.
	func (l ListStore) InsertWithValuesv(position int, columns []int, values []**externglib.Value) TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter
var _arg2 C.int // out
var _arg3 *C.int
var _arg5 C.int
var _arg4 *C.GValue
var _arg5 C.int

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg2 = (C.int)(position)
_arg5 = C.int(len(columns))
_arg3 = (*C.int)(unsafe.Pointer(&columns[0]))
_arg5 = C.int(len(values))
_arg4 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg4))
{
out := unsafe.Slice(_arg4, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_list_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5)





return _iter
}
	
	// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
// 
// Checks if the given iter is a valid iter for this ListStore.
	func (l ListStore) IterIsValid(iter *TreeIter) bool {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_list_store_iter_is_valid(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveAfter moves @iter in @store to the position after @position. Note that
// this function only works with unsorted stores. If @position is nil, @iter
// will be moved to the start of the list.
	func (s ListStore) MoveAfter(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_list_store_move_after(_arg0, _arg1, _arg2)
}
	
	// MoveBefore moves @iter in @store to the position before @position. Note that
// this function only works with unsorted stores. If @position is nil, @iter
// will be moved to the end of the list.
	func (s ListStore) MoveBefore(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_list_store_move_before(_arg0, _arg1, _arg2)
}
	
	// Prepend prepends a new row to @list_store. @iter will be changed to point to
// this new row. The row will be empty after this function is called. To fill in
// values, you need to call gtk_list_store_set() or gtk_list_store_set_value().
	func (l ListStore) Prepend() TreeIter {
var _arg0 *C.GtkListStore // out
var _iter TreeIter

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))

C.gtk_list_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// Remove removes the given row from the list store. After being removed, @iter
// is set to be the next valid row, or invalidated if it pointed to the last row
// in @list_store.
	func (l ListStore) Remove(iter *TreeIter) bool {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_list_store_remove(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Reorder reorders @store to follow the order indicated by @new_order. Note
// that this function only works with unsorted stores.
	func (s ListStore) Reorder(newOrder []int)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.int

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
{
var zero int
newOrder = append(newOrder, zero)
}
_arg1 = (*C.int)(unsafe.Pointer(&newOrder[0]))

C.gtk_list_store_reorder(_arg0, _arg1)
}
	
	// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from ListStore, and should only be used when constructing a new ListStore. It
// will not function after a row has been added, or a method on the TreeModel
// interface is called.
	func (l ListStore) SetColumnTypes(types []externglib.Type)  {
var _arg0 *C.GtkListStore // out
var _arg2 *C.GType
var _arg1 C.int

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = C.int(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

C.gtk_list_store_set_column_types(_arg0, _arg1, _arg2)
}
	
	// SetValue sets the data in the cell specified by @iter and @column. The type
// of @value must be convertible to the type of the column.
	func (l ListStore) SetValue(iter *TreeIter, column int, value **externglib.Value)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 C.int // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.int)(column)
_arg3 = (*C.GValue)(value.GValue)

C.gtk_list_store_set_value(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetValuesv: a variant of gtk_list_store_set_valist() which takes the columns
// and values as two arrays, instead of varargs. This function is mainly
// intended for language-bindings and in case the number of columns to change is
// not known until run-time.
	func (l ListStore) SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.int
var _arg4 C.int
var _arg3 *C.GValue
var _arg4 C.int

_arg0 = (*C.GtkListStore)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg4 = C.int(len(columns))
_arg2 = (*C.int)(unsafe.Pointer(&columns[0]))
_arg4 = C.int(len(values))
_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_list_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Swap swaps @a and @b in @store. Note that this function only works with
// unsorted stores.
	func (s ListStore) Swap(a *TreeIter, b *TreeIter)  {
var _arg0 *C.GtkListStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkListStore)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

C.gtk_list_store_swap(_arg0, _arg1, _arg2)
}
	


	// ListView: `GtkListView` presents a large dynamic list of items.
// 
// `GtkListView` uses its factory to generate one row widget for each visible
// item and shows them in a linear display, either vertically or horizontally.
// 
// The [property@Gtk.ListView:show-separators] property offers a simple way to
// display separators between the rows.
// 
// `GtkListView` allows the user to select items according to the selection
// characteristics of the model. For models that allow multiple selected items,
// it is possible to turn on _rubberband selection_, using
// [property@Gtk.ListView:enable-rubberband].
// 
// If you need multiple columns with headers, see [class@Gtk.ColumnView].
// 
// To learn more about the list widget framework, see the overview
// (section-list-widget.html).
// 
// An example of using `GtkListView`: `c static void setup_listitem_cb
// (GtkListItemFactory *factory, GtkListItem *list_item) { GtkWidget *image;
// 
//    image = gtk_image_new ();
//    gtk_image_set_icon_size (GTK_IMAGE (image), GTK_ICON_SIZE_LARGE);
//    gtk_list_item_set_child (list_item, image);
// 
// }
// 
// static void bind_listitem_cb (GtkListItemFactory *factory, GtkListItem
// *list_item) { GtkWidget *image; GAppInfo *app_info;
// 
//    image = gtk_list_item_get_child (list_item);
//    app_info = gtk_list_item_get_item (list_item);
//    gtk_image_set_from_gicon (GTK_IMAGE (image), g_app_info_get_icon (app_info));
// 
// }
// 
// static void activate_cb (GtkListView *list, guint position, gpointer unused)
// { GAppInfo *app_info;
// 
//    app_info = g_list_model_get_item (G_LIST_MODEL (gtk_list_view_get_model (list)), position);
//    g_app_info_launch (app_info, NULL, NULL, NULL);
//    g_object_unref (app_info);
// 
// }
// 
// ...
// 
//    model = create_application_list ();
// 
//    factory = gtk_signal_list_item_factory_new ();
//    g_signal_connect (factory, "setup", G_CALLBACK (setup_listitem_cb), NULL);
//    g_signal_connect (factory, "bind", G_CALLBACK (bind_listitem_cb), NULL);
// 
//    list = gtk_list_view_new (GTK_SELECTION_MODEL (gtk_single_selection_new (model)), factory);
// 
//    g_signal_connect (list, "activate", G_CALLBACK (activate_cb), NULL);
// 
//    gtk_scrolled_window_set_child (GTK_SCROLLED_WINDOW (sw), list);
// 
// `
// 
// 
// CSS nodes
// 
// ` listview[.separators][.rich-list][.navigation-sidebar][.data-table] 
// row   row    [rubberband] `
// 
// `GtkListView` uses a single CSS node named listview. It may carry the
// .separators style class, when `GtkListView`:show-separators property is set.
// Each child widget uses a single CSS node named row. For rubberband selection,
// a node with name rubberband is used.
// 
// The main listview node may also carry style classes to select the style of
// list presentation (ListContainers.html#list-styles): .rich-list,
// .navigation-sidebar or .data-table.
// 
// 
// Accessibility
// 
// `GtkListView` uses the GTK_ACCESSIBLE_ROLE_LIST role, and the list items use
// the GTK_ACCESSIBLE_ROLE_LIST_ITEM role.
	type ListView struct {
		ListBase
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		Scrollable
		
	}

	// ListViewClass is an interface that the ListView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ListViewClass interface {
		gextras.Objector
		_listView()
	}

	func (ListView) _listView() {}

	
	func marshalListView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapListView(obj), nil
	}
	

	
	// NewListView creates a new `GtkListView` that uses the given @factory for
// mapping items to widgets.
// 
// The function takes ownership of the arguments, so you can write code like `c
// list_view = gtk_list_view_new (create_model (),
// gtk_builder_list_item_factory_new_from_resource ("/resource.ui")); `
	func NewListView(model SelectionModel, factory ListItemFactoryClass) ListView {
var _arg1 *C.GtkSelectionModel // out
var _arg2 *C.GtkListItemFactory // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

_cret = C.gtk_list_view_new(_arg1, _arg2)


var _listView ListView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_listView = ListView{
ListBase: ListBase{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _listView
}
	

	
	// EnableRubberband returns whether rows can be selected by dragging with the
// mouse.
	func (s ListView) EnableRubberband() bool {
var _arg0 *C.GtkListView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_view_get_enable_rubberband(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Factory gets the factory that's currently used to populate list items.
	func (s ListView) Factory() ListItemFactory {
var _arg0 *C.GtkListView // out
var _cret *C.GtkListItemFactory // in

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_view_get_factory(_arg0)


var _listItemFactory ListItemFactory // out

_listItemFactory = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ListItemFactory)

return _listItemFactory
}
	
	// Model gets the model that's currently used to read the items displayed.
	func (s ListView) Model() SelectionModel {
var _arg0 *C.GtkListView // out
var _cret *C.GtkSelectionModel // in

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_view_get_model(_arg0)


var _selectionModel SelectionModel // out

_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

return _selectionModel
}
	
	// ShowSeparators returns whether the list box should show separators between
// rows.
	func (s ListView) ShowSeparators() bool {
var _arg0 *C.GtkListView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_view_get_show_separators(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SingleClickActivate returns whether rows will be activated on single click
// and selected on hover.
	func (s ListView) SingleClickActivate() bool {
var _arg0 *C.GtkListView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))

_cret = C.gtk_list_view_get_single_click_activate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetEnableRubberband sets whether selections can be changed by dragging with
// the mouse.
	func (s ListView) SetEnableRubberband(enableRubberband bool)  {
var _arg0 *C.GtkListView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
if enableRubberband { _arg1 = C.TRUE }

C.gtk_list_view_set_enable_rubberband(_arg0, _arg1)
}
	
	// SetFactory sets the `GtkListItemFactory` to use for populating list items.
	func (s ListView) SetFactory(factory ListItemFactoryClass)  {
var _arg0 *C.GtkListView // out
var _arg1 *C.GtkListItemFactory // out

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkListItemFactory)(unsafe.Pointer(factory.Native()))

C.gtk_list_view_set_factory(_arg0, _arg1)
}
	
	// SetModel sets the model to use.
// 
// This must be a [iface@Gtk.SelectionModel] to use.
	func (s ListView) SetModel(model SelectionModel)  {
var _arg0 *C.GtkListView // out
var _arg1 *C.GtkSelectionModel // out

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

C.gtk_list_view_set_model(_arg0, _arg1)
}
	
	// SetShowSeparators sets whether the list box should show separators between
// rows.
	func (s ListView) SetShowSeparators(showSeparators bool)  {
var _arg0 *C.GtkListView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
if showSeparators { _arg1 = C.TRUE }

C.gtk_list_view_set_show_separators(_arg0, _arg1)
}
	
	// SetSingleClickActivate sets whether rows should be activated on single click
// and selected on hover.
	func (s ListView) SetSingleClickActivate(singleClickActivate bool)  {
var _arg0 *C.GtkListView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkListView)(unsafe.Pointer(s.Native()))
if singleClickActivate { _arg1 = C.TRUE }

C.gtk_list_view_set_single_click_activate(_arg0, _arg1)
}
	


	// LockButton: `GtkLockButton` is a widget to obtain and revoke authorizations
// needed to operate the controls.
// 
// !An example GtkLockButton (lock-button.png)
// 
// It is typically used in preference dialogs or control panels.
// 
// The required authorization is represented by a `GPermission` object. Concrete
// implementations of `GPermission` may use PolicyKit or some other
// authorization framework. To obtain a PolicyKit-based `GPermission`, use
// `polkit_permission_new()`.
// 
// If the user is not currently allowed to perform the action, but can obtain
// the permission, the widget looks like this:
// 
// ! (lockbutton-locked.png)
// 
// and the user can click the button to request the permission. Depending on the
// platform, this may pop up an authentication dialog or ask the user to
// authenticate in some other way. Once the user has obtained the permission,
// the widget changes to this:
// 
// ! (lockbutton-unlocked.png)
// 
// and the permission can be dropped again by clicking the button. If the user
// is not able to obtain the permission at all, the widget looks like this:
// 
// ! (lockbutton-sorry.png)
// 
// If the user has the permission and cannot drop it, the button is hidden.
// 
// The text (and tooltips) that are shown in the various cases can be adjusted
// with the [property@Gtk.LockButton:text-lock],
// [property@Gtk.LockButton:text-unlock],
// [property@Gtk.LockButton:tooltip-lock],
// [property@Gtk.LockButton:tooltip-unlock] and
// [property@Gtk.LockButton:tooltip-not-authorized] properties.
	type LockButton struct {
		Button
		Accessible
		Actionable
		Buildable
		ConstraintTarget
		
	}

	// LockButtonClass is an interface that the LockButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type LockButtonClass interface {
		gextras.Objector
		_lockButton()
	}

	func (LockButton) _lockButton() {}

	
	func marshalLockButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapLockButton(obj), nil
	}
	

	
	// NewLockButton creates a new lock button which reflects the @permission.
	func NewLockButton(permission gio.PermissionClass) LockButton {
var _arg1 *C.GPermission // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

_cret = C.gtk_lock_button_new(_arg1)


var _lockButton LockButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_lockButton = LockButton{
Button: Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _lockButton
}
	

	
	// Permission obtains the `GPermission` object that controls @button.
	func (b LockButton) Permission() gio.Permission {
var _arg0 *C.GtkLockButton // out
var _cret *C.GPermission // in

_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_lock_button_get_permission(_arg0)


var _permission gio.Permission // out

_permission = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.Permission)

return _permission
}
	
	// SetPermission sets the `GPermission` object that controls @button.
	func (b LockButton) SetPermission(permission gio.PermissionClass)  {
var _arg0 *C.GtkLockButton // out
var _arg1 *C.GPermission // out

_arg0 = (*C.GtkLockButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GPermission)(unsafe.Pointer(permission.Native()))

C.gtk_lock_button_set_permission(_arg0, _arg1)
}
	


	// MapListModel: a `GtkMapListModel` maps the items in a list model to different
// items.
// 
// `GtkMapListModel` uses a [callback@Gtk.MapListModelMapFunc].
// 
// Example: Create a list of `GtkEventControllers` `c static gpointer
// map_to_controllers (gpointer widget, gpointer data) { gpointer result =
// gtk_widget_observe_controllers (widget); g_object_unref (widget); return
// result; }
// 
// widgets = gtk_widget_observe_children (widget);
// 
// controllers = gtk_map_list_model_new (G_TYPE_LIST_MODEL, widgets,
// map_to_controllers, NULL, NULL);
// 
// model = gtk_flatten_list_model_new (GTK_TYPE_EVENT_CONTROLLER, controllers);
// `
// 
// `GtkMapListModel` will attempt to discard the mapped objects as soon as they
// are no longer needed and recreate them if necessary.
	type MapListModel struct {
		**externglib.Object
		gio.ListModel
		
	}

	// MapListModelClass is an interface that the MapListModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MapListModelClass interface {
		gextras.Objector
		_mapListModel()
	}

	func (MapListModel) _mapListModel() {}

	
	func marshalMapListModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMapListModel(obj), nil
	}
	

	

	
	// Model gets the model that is currently being mapped or nil if none.
	func (s MapListModel) Model() gio.ListModel {
var _arg0 *C.GtkMapListModel // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_map_list_model_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// HasMap checks if a map function is currently set on @self.
	func (s MapListModel) HasMap() bool {
var _arg0 *C.GtkMapListModel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_map_list_model_has_map(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetModel sets the model to be mapped.
// 
// GTK makes no effort to ensure that @model conforms to the item type expected
// by the map function. It assumes that the caller knows what they are doing and
// have set up an appropriate map function.
	func (s MapListModel) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkMapListModel // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkMapListModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_map_list_model_set_model(_arg0, _arg1)
}
	


	// MediaControls: `GtkMediaControls` is a widget to show controls for a video.
// 
// !An example GtkMediaControls (media-controls.png)
// 
// Usually, `GtkMediaControls` is used as part of [class@Gtk.Video].
	type MediaControls struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// MediaControlsClass is an interface that the MediaControls class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MediaControlsClass interface {
		gextras.Objector
		_mediaControls()
	}

	func (MediaControls) _mediaControls() {}

	
	func marshalMediaControls(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMediaControls(obj), nil
	}
	

	
	// NewMediaControls creates a new `GtkMediaControls` managing the @stream passed
// to it.
	func NewMediaControls(stream MediaStreamClass) MediaControls {
var _arg1 *C.GtkMediaStream // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

_cret = C.gtk_media_controls_new(_arg1)


var _mediaControls MediaControls // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_mediaControls = MediaControls{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mediaControls
}
	

	
	// MediaStream gets the media stream managed by @controls or nil if none.
	func (c MediaControls) MediaStream() MediaStream {
var _arg0 *C.GtkMediaControls // out
var _cret *C.GtkMediaStream // in

_arg0 = (*C.GtkMediaControls)(unsafe.Pointer(c.Native()))

_cret = C.gtk_media_controls_get_media_stream(_arg0)


var _mediaStream MediaStream // out

_mediaStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(MediaStream)

return _mediaStream
}
	
	// SetMediaStream sets the stream that is controlled by @controls.
	func (c MediaControls) SetMediaStream(stream MediaStreamClass)  {
var _arg0 *C.GtkMediaControls // out
var _arg1 *C.GtkMediaStream // out

_arg0 = (*C.GtkMediaControls)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

C.gtk_media_controls_set_media_stream(_arg0, _arg1)
}
	


	// MediaFile: `GtkMediaFile` implements `GtkMediaStream` for files.
// 
// This provides a simple way to play back video files with GTK.
// 
// GTK provides a GIO extension point for `GtkMediaFile` implementations to
// allow for external implementations using various media frameworks.
// 
// GTK itself includes implementations using GStreamer and ffmpeg.
	type MediaFile struct {
		MediaStream
		gdk.Paintable
		
	}

	// MediaFileClass is an interface that the MediaFile class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MediaFileClass interface {
		gextras.Objector
		_mediaFile()
	}

	func (MediaFile) _mediaFile() {}

	
	func marshalMediaFile(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMediaFile(obj), nil
	}
	

	
	// NewMediaFile creates a new empty media file.
	func NewMediaFile() MediaFile {
var _cret *C.GtkMediaStream // in

_cret = C.gtk_media_file_new()


var _mediaFile MediaFile // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mediaFile = MediaFile{
MediaStream: MediaStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mediaFile
}
	
	// NewMediaFileForFile creates a new media file to play @file.
	func NewMediaFileForFile(file gio.File) MediaFile {
var _arg1 *C.GFile // out
var _cret *C.GtkMediaStream // in

_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

_cret = C.gtk_media_file_new_for_file(_arg1)


var _mediaFile MediaFile // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mediaFile = MediaFile{
MediaStream: MediaStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mediaFile
}
	
	// NewMediaFileForFilename creates a new media file for the given filename.
// 
// This is a utility function that converts the given @filename to a `GFile` and
// calls [ctor@Gtk.MediaFile.new_for_file].
	func NewMediaFileForFilename(filename string) MediaFile {
var _arg1 *C.char // out
var _cret *C.GtkMediaStream // in

_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_media_file_new_for_filename(_arg1)


var _mediaFile MediaFile // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mediaFile = MediaFile{
MediaStream: MediaStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mediaFile
}
	
	// NewMediaFileForInputStream creates a new media file to play @stream.
// 
// If you want the resulting media to be seekable, the stream should implement
// the `GSeekable` interface.
	func NewMediaFileForInputStream(stream gio.InputStreamClass) MediaFile {
var _arg1 *C.GInputStream // out
var _cret *C.GtkMediaStream // in

_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))

_cret = C.gtk_media_file_new_for_input_stream(_arg1)


var _mediaFile MediaFile // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mediaFile = MediaFile{
MediaStream: MediaStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mediaFile
}
	
	// NewMediaFileForResource creates a new new media file for the given resource.
// 
// This is a utility function that converts the given @resource to a `GFile` and
// calls [ctor@Gtk.MediaFile.new_for_file].
	func NewMediaFileForResource(resourcePath string) MediaFile {
var _arg1 *C.char // out
var _cret *C.GtkMediaStream // in

_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_media_file_new_for_resource(_arg1)


var _mediaFile MediaFile // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mediaFile = MediaFile{
MediaStream: MediaStream{
Object: &externglib.Object{externglib.ToGObject(obj)},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mediaFile
}
	

	
	// Clear resets the media file to be empty.
	func (s MediaFile) Clear()  {
var _arg0 *C.GtkMediaFile // out

_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))

C.gtk_media_file_clear(_arg0)
}
	
	// File returns the file that @self is currently playing from.
// 
// When @self is not playing or not playing from a file, nil is returned.
	func (s MediaFile) File() gio.File {
var _arg0 *C.GtkMediaFile // out
var _cret *C.GFile // in

_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_file_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// InputStream returns the stream that @self is currently playing from.
// 
// When @self is not playing or not playing from a stream, nil is returned.
	func (s MediaFile) InputStream() gio.InputStream {
var _arg0 *C.GtkMediaFile // out
var _cret *C.GInputStream // in

_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_file_get_input_stream(_arg0)


var _inputStream gio.InputStream // out

_inputStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.InputStream)

return _inputStream
}
	
	// SetFile sets the `GtkMediaFile` to play the given file.
// 
// If any file is still playing, stop playing it.
	func (s MediaFile) SetFile(file gio.File)  {
var _arg0 *C.GtkMediaFile // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_media_file_set_file(_arg0, _arg1)
}
	
	// SetFilename sets the `GtkMediaFile to play the given file.
// 
// This is a utility function that converts the given @filename to a `GFile` and
// calls [method@Gtk.MediaFile.set_file].
	func (s MediaFile) SetFilename(filename string)  {
var _arg0 *C.GtkMediaFile // out
var _arg1 *C.char // out

_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_media_file_set_filename(_arg0, _arg1)
}
	
	// SetInputStream sets the `GtkMediaFile` to play the given stream.
// 
// If anything is still playing, stop playing it.
// 
// Full control about the @stream is assumed for the duration of playback. The
// stream will not be closed.
	func (s MediaFile) SetInputStream(stream gio.InputStreamClass)  {
var _arg0 *C.GtkMediaFile // out
var _arg1 *C.GInputStream // out

_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GInputStream)(unsafe.Pointer(stream.Native()))

C.gtk_media_file_set_input_stream(_arg0, _arg1)
}
	
	// SetResource sets the `GtkMediaFile to play the given resource.
// 
// This is a utility function that converts the given @resource_path to a
// `GFile` and calls [method@Gtk.MediaFile.set_file].
	func (s MediaFile) SetResource(resourcePath string)  {
var _arg0 *C.GtkMediaFile // out
var _arg1 *C.char // out

_arg0 = (*C.GtkMediaFile)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_media_file_set_resource(_arg0, _arg1)
}
	


	// MediaStream: `GtkMediaStream` is the integration point for media playback
// inside GTK.
// 
// GTK provides an implementation of the `GtkMediaStream` interface that is
// called [class@Gtk.MediaFile].
// 
// Apart from application-facing API for stream playback, `GtkMediaStream` has a
// number of APIs that are only useful for implementations and should not be
// used in applications: [method@Gtk.MediaStream.prepared],
// [method@Gtk.MediaStream.unprepared], [method@Gtk.MediaStream.update],
// [method@Gtk.MediaStream.ended], [method@Gtk.MediaStream.seek_success],
// [method@Gtk.MediaStream.seek_failed], [method@Gtk.MediaStream.gerror],
// [method@Gtk.MediaStream.error], [method@Gtk.MediaStream.error_valist].
	type MediaStream struct {
		**externglib.Object
		gdk.Paintable
		
	}

	// MediaStreamClass is an interface that the MediaStream class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MediaStreamClass interface {
		gextras.Objector
		_mediaStream()
	}

	func (MediaStream) _mediaStream() {}

	
	func marshalMediaStream(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMediaStream(obj), nil
	}
	

	

	
	// Ended pauses the media stream and marks it as ended.
// 
// This is a hint only, calls to GtkMediaStream.play() may still happen.
// 
// The media stream must be prepared when this function is called.
	func (s MediaStream) Ended()  {
var _arg0 *C.GtkMediaStream // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

C.gtk_media_stream_ended(_arg0)
}
	
	// Gerror sets @self into an error state.
// 
// This will pause the stream (you can check for an error via
// [method@Gtk.MediaStream.get_error] in your GtkMediaStream.pause()
// implementation), abort pending seeks and mark the stream as prepared.
// 
// if the stream is already in an error state, this call will be ignored and the
// existing error will be retained.
// 
// To unset an error, the stream must be reset via a call to
// [method@Gtk.MediaStream.unprepared].
	func (s MediaStream) Gerror(err error)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 *C.GError // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GError)(gerror.New(unsafe.Pointer(err)))

C.gtk_media_stream_gerror(_arg0, _arg1)
}
	
	// Duration gets the duration of the stream.
// 
// If the duration is not known, 0 will be returned.
	func (s MediaStream) Duration() int64 {
var _arg0 *C.GtkMediaStream // out
var _cret C.gint64 // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_duration(_arg0)


var _gint64 int64 // out

_gint64 = (int64)(_cret)

return _gint64
}
	
	// GetEnded returns whether the streams playback is finished.
	func (s MediaStream) GetEnded() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_ended(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Error: if the stream is in an error state, returns the `GError` explaining
// that state.
// 
// Any type of error can be reported here depending on the implementation of the
// media stream.
// 
// A media stream in an error cannot be operated on, calls like
// [method@Gtk.MediaStream.play] or [method@Gtk.MediaStream.seek] will not have
// any effect.
// 
// `GtkMediaStream` itself does not provide a way to unset an error, but
// implementations may provide options. For example, a [class@Gtk.MediaFile]
// will unset errors when a new source is set, e.g. with
// [method@Gtk.MediaFile.set_file].
	func (s MediaStream) Error() error {
var _arg0 *C.GtkMediaStream // out
var _cret *C.GError // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_error(_arg0)


var _err error // out

_err = gerror.Take(unsafe.Pointer(_cret))

return _err
}
	
	// Loop returns whether the stream is set to loop.
// 
// See [method@Gtk.MediaStream.set_loop] for details.
	func (s MediaStream) Loop() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_loop(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Muted returns whether the audio for the stream is muted.
// 
// See [method@Gtk.MediaStream.set_muted] for details.
	func (s MediaStream) Muted() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_muted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Playing: return whether the stream is currently playing.
	func (s MediaStream) Playing() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_playing(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Timestamp returns the current presentation timestamp in microseconds.
	func (s MediaStream) Timestamp() int64 {
var _arg0 *C.GtkMediaStream // out
var _cret C.gint64 // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_timestamp(_arg0)


var _gint64 int64 // out

_gint64 = (int64)(_cret)

return _gint64
}
	
	// Volume returns the volume of the audio for the stream.
// 
// See [method@Gtk.MediaStream.set_volume] for details.
	func (s MediaStream) Volume() float64 {
var _arg0 *C.GtkMediaStream // out
var _cret C.double // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_get_volume(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// HasAudio returns whether the stream has audio.
	func (s MediaStream) HasAudio() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_has_audio(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasVideo returns whether the stream has video.
	func (s MediaStream) HasVideo() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_has_video(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsPrepared returns whether the stream has finished initializing.
// 
// At this point the existence of audio and video is known.
	func (s MediaStream) IsPrepared() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_is_prepared(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSeekable checks if a stream may be seekable.
// 
// This is meant to be a hint. Streams may not allow seeking even if this
// function returns true. However, if this function returns false, streams are
// guaranteed to not be seekable and user interfaces may hide controls that
// allow seeking.
// 
// It is allowed to call [method@Gtk.MediaStream.seek] on a non-seekable stream,
// though it will not do anything.
	func (s MediaStream) IsSeekable() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_is_seekable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSeeking checks if there is currently a seek operation going on.
	func (s MediaStream) IsSeeking() bool {
var _arg0 *C.GtkMediaStream // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

_cret = C.gtk_media_stream_is_seeking(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Pause pauses playback of the stream.
// 
// If the stream is not playing, do nothing.
	func (s MediaStream) Pause()  {
var _arg0 *C.GtkMediaStream // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

C.gtk_media_stream_pause(_arg0)
}
	
	// Play starts playing the stream.
// 
// If the stream is in error or already playing, do nothing.
	func (s MediaStream) Play()  {
var _arg0 *C.GtkMediaStream // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

C.gtk_media_stream_play(_arg0)
}
	
	// Prepared: called by `GtkMediaStream` implementations to advertise the stream
// being ready to play and providing details about the stream.
// 
// Note that the arguments are hints. If the stream implementation cannot
// determine the correct values, it is better to err on the side of caution and
// return true. User interfaces will use those values to determine what controls
// to show.
// 
// This function may not be called again until the stream has been reset via
// [method@Gtk.MediaStream.unprepared].
	func (s MediaStream) Prepared(hasAudio bool, hasVideo bool, seekable bool, duration int64)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 C.gboolean // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _arg4 C.gint64 // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
if hasAudio { _arg1 = C.TRUE }
if hasVideo { _arg2 = C.TRUE }
if seekable { _arg3 = C.TRUE }
_arg4 = (C.gint64)(duration)

C.gtk_media_stream_prepared(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Realize: called by users to attach the media stream to a `GdkSurface` they
// manage.
// 
// The stream can then access the resources of @surface for its rendering
// purposes. In particular, media streams might want to create a `GdkGLContext`
// or sync to the `GdkFrameClock`.
// 
// Whoever calls this function is responsible for calling
// [method@Gtk.MediaStream.unrealize] before either the stream or @surface get
// destroyed.
// 
// Multiple calls to this function may happen from different users of the video,
// even with the same @surface. Each of these calls must be followed by its own
// call to [method@Gtk.MediaStream.unrealize].
// 
// It is not required to call this function to make a media stream work.
	func (s MediaStream) Realize(surface gdk.SurfaceClass)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 *C.GdkSurface // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

C.gtk_media_stream_realize(_arg0, _arg1)
}
	
	// Seek: start a seek operation on @self to @timestamp.
// 
// If @timestamp is out of range, it will be clamped.
// 
// Seek operations may not finish instantly. While a seek operation is in
// process, the [property@Gtk.MediaStream:seeking] property will be set.
// 
// When calling gtk_media_stream_seek() during an ongoing seek operation, the
// new seek will override any pending seek.
	func (s MediaStream) Seek(timestamp int64)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 C.gint64 // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint64)(timestamp)

C.gtk_media_stream_seek(_arg0, _arg1)
}
	
	// SeekFailed ends a seek operation started via GtkMediaStream.seek() as a
// failure.
// 
// This will not cause an error on the stream and will assume that playback
// continues as if no seek had happened.
// 
// See [method@Gtk.MediaStream.seek_success] for the other way of ending a seek.
	func (s MediaStream) SeekFailed()  {
var _arg0 *C.GtkMediaStream // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

C.gtk_media_stream_seek_failed(_arg0)
}
	
	// SeekSuccess ends a seek operation started via GtkMediaStream.seek()
// successfully.
// 
// This function will unset the GtkMediaStream:ended property if it was set.
// 
// See [method@Gtk.MediaStream.seek_failed] for the other way of ending a seek.
	func (s MediaStream) SeekSuccess()  {
var _arg0 *C.GtkMediaStream // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

C.gtk_media_stream_seek_success(_arg0)
}
	
	// SetLoop sets whether the stream should loop.
// 
// In this case, it will attempt to restart playback from the beginning instead
// of stopping at the end.
// 
// Not all streams may support looping, in particular non-seekable streams.
// Those streams will ignore the loop setting and just end.
	func (s MediaStream) SetLoop(loop bool)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
if loop { _arg1 = C.TRUE }

C.gtk_media_stream_set_loop(_arg0, _arg1)
}
	
	// SetMuted sets whether the audio stream should be muted.
// 
// Muting a stream will cause no audio to be played, but it does not modify the
// volume. This means that muting and then unmuting the stream will restore the
// volume settings.
// 
// If the stream has no audio, calling this function will still work but it will
// not have an audible effect.
	func (s MediaStream) SetMuted(muted bool)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
if muted { _arg1 = C.TRUE }

C.gtk_media_stream_set_muted(_arg0, _arg1)
}
	
	// SetPlaying starts or pauses playback of the stream.
	func (s MediaStream) SetPlaying(playing bool)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
if playing { _arg1 = C.TRUE }

C.gtk_media_stream_set_playing(_arg0, _arg1)
}
	
	// SetVolume sets the volume of the audio stream.
// 
// This function call will work even if the stream is muted.
// 
// The given @volume should range from 0.0 for silence to 1.0 for as loud as
// possible. Values outside of this range will be clamped to the nearest value.
// 
// If the stream has no audio or is muted, calling this function will still work
// but it will not have an immediate audible effect. When the stream is unmuted,
// the new volume setting will take effect.
	func (s MediaStream) SetVolume(volume float64)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 C.double // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(volume)

C.gtk_media_stream_set_volume(_arg0, _arg1)
}
	
	// Unprepared resets a given media stream implementation.
// 
// [method@Gtk.MediaStream.prepared] can then be called again.
// 
// This function will also reset any error state the stream was in.
	func (s MediaStream) Unprepared()  {
var _arg0 *C.GtkMediaStream // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))

C.gtk_media_stream_unprepared(_arg0)
}
	
	// Unrealize undoes a previous call to gtk_media_stream_realize().
// 
// This causes the stream to release all resources it had allocated from
// @surface.
	func (s MediaStream) Unrealize(surface gdk.SurfaceClass)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 *C.GdkSurface // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkSurface)(unsafe.Pointer(surface.Native()))

C.gtk_media_stream_unrealize(_arg0, _arg1)
}
	
	// Update: media stream implementations should regularly call this function to
// update the timestamp reported by the stream.
// 
// It is up to implementations to call this at the frequency they deem
// appropriate.
// 
// The media stream must be prepared when this function is called.
	func (s MediaStream) Update(timestamp int64)  {
var _arg0 *C.GtkMediaStream // out
var _arg1 C.gint64 // out

_arg0 = (*C.GtkMediaStream)(unsafe.Pointer(s.Native()))
_arg1 = (C.gint64)(timestamp)

C.gtk_media_stream_update(_arg0, _arg1)
}
	


	// MenuButton: the `GtkMenuButton` widget is used to display a popup when
// clicked.
// 
// !An example GtkMenuButton (menu-button.png)
// 
// This popup can be provided either as a `GtkPopover` or as an abstract
// `GMenuModel`.
// 
// The `GtkMenuButton` widget can show either an icon (set with the
// [property@Gtk.MenuButton:icon-name] property) or a label (set with the
// [property@Gtk.MenuButton:label] property). If neither is explicitly set, a
// [class@Gtk.Image] is automatically created, using an arrow image oriented
// according to [property@Gtk.MenuButton:direction] or the generic
// open-menu-symbolic icon if the direction is not set.
// 
// The positioning of the popup is determined by the
// [property@Gtk.MenuButton:direction] property of the menu button.
// 
// For menus, the [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign]
// properties of the menu are also taken into account. For example, when the
// direction is GTK_ARROW_DOWN and the horizontal alignment is GTK_ALIGN_START,
// the menu will be positioned below the button, with the starting edge
// (depending on the text direction) of the menu aligned with the starting edge
// of the button. If there is not enough space below the button, the menu is
// popped up above the button instead. If the alignment would move part of the
// menu offscreen, it is pushed in.
// 
// | | start | center | end | | - | --- | --- | --- | | **down** | !
// (down-start.png) | ! (down-center.png) | ! (down-end.png) | | **up** | !
// (up-start.png) | ! (up-center.png) | ! (up-end.png) | | **left** | !
// (left-start.png) | ! (left-center.png) | ! (left-end.png) | | **right** | !
// (right-start.png) | ! (right-center.png) | ! (right-end.png) |
// 
// 
// CSS nodes
// 
// ` menubutton  button.toggle  <content>  [arrow] `
// 
// `GtkMenuButton` has a single CSS node with name `menubutton` which contains a
// `button` node with a `.toggle` style class.
// 
// Inside the toggle button content, there is an `arrow` node for the indicator,
// which will carry one of the `.none`, `.up`, `.down`, `.left` or `.right`
// style classes to indicate the direction that the menu will appear in. The CSS
// is expected to provide a suitable image for each of these cases using the
// `-gtk-icon-source` property.
// 
// Optionally, the `menubutton` node can carry the `.circular` style class to
// request a round appearance.
// 
// 
// Accessibility
// 
// `GtkMenuButton` uses the K_ACCESSIBLE_ROLE_BUTTON role.
	type MenuButton struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// MenuButtonClass is an interface that the MenuButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MenuButtonClass interface {
		gextras.Objector
		_menuButton()
	}

	func (MenuButton) _menuButton() {}

	
	func marshalMenuButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMenuButton(obj), nil
	}
	

	
	// NewMenuButton creates a new `GtkMenuButton` widget with downwards-pointing
// arrow as the only child.
// 
// You can replace the child widget with another `GtkWidget` should you wish to.
	func NewMenuButton() MenuButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_menu_button_new()


var _menuButton MenuButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_menuButton = MenuButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _menuButton
}
	

	
	// Direction returns the direction the popup will be pointing at when popped up.
	func (m MenuButton) Direction() ArrowType {
var _arg0 *C.GtkMenuButton // out
var _cret C.GtkArrowType // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_direction(_arg0)


var _arrowType ArrowType // out

_arrowType = ArrowType(_cret)

return _arrowType
}
	
	// HasFrame returns whether the button has a frame.
	func (m MenuButton) HasFrame() bool {
var _arg0 *C.GtkMenuButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_has_frame(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconName gets the name of the icon shown in the button.
	func (m MenuButton) IconName() string {
var _arg0 *C.GtkMenuButton // out
var _cret *C.char // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Label gets the label shown in the button
	func (m MenuButton) Label() string {
var _arg0 *C.GtkMenuButton // out
var _cret *C.char // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_label(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// MenuModel returns the `GMenuModel` used to generate the popup.
	func (m MenuButton) MenuModel() gio.MenuModel {
var _arg0 *C.GtkMenuButton // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_menu_model(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// Popover returns the `GtkPopover` that pops out of the button.
// 
// If the button is not using a `GtkPopover`, this function returns nil.
	func (m MenuButton) Popover() Popover {
var _arg0 *C.GtkMenuButton // out
var _cret *C.GtkPopover // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_popover(_arg0)


var _popover Popover // out

_popover = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Popover)

return _popover
}
	
	// UseUnderline returns whether an embedded underline in the text indicates a
// mnemonic.
	func (m MenuButton) UseUnderline() bool {
var _arg0 *C.GtkMenuButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

_cret = C.gtk_menu_button_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Popdown dismiss the menu.
	func (m MenuButton) Popdown()  {
var _arg0 *C.GtkMenuButton // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

C.gtk_menu_button_popdown(_arg0)
}
	
	// Popup: pop up the menu.
	func (m MenuButton) Popup()  {
var _arg0 *C.GtkMenuButton // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))

C.gtk_menu_button_popup(_arg0)
}
	
	// SetDirection sets the direction in which the popup will be popped up.
// 
// If the button is automatically populated with an arrow icon, its direction
// will be changed to match.
// 
// If the does not fit in the available space in the given direction, GTK will
// its best to keep it inside the screen and fully visible.
// 
// If you pass GTK_ARROW_NONE for a @direction, the popup will behave as if you
// passed GTK_ARROW_DOWN (although you wont see any arrows).
	func (m MenuButton) SetDirection(direction ArrowType)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 C.GtkArrowType // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (C.GtkArrowType)(direction)

C.gtk_menu_button_set_direction(_arg0, _arg1)
}
	
	// SetHasFrame sets the style of the button.
	func (m MenuButton) SetHasFrame(hasFrame bool)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
if hasFrame { _arg1 = C.TRUE }

C.gtk_menu_button_set_has_frame(_arg0, _arg1)
}
	
	// SetIconName sets the name of an icon to show inside the menu button.
	func (m MenuButton) SetIconName(iconName string)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_button_set_icon_name(_arg0, _arg1)
}
	
	// SetLabel sets the label to show inside the menu button.
	func (m MenuButton) SetLabel(label string)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.char // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_menu_button_set_label(_arg0, _arg1)
}
	
	// SetMenuModel sets the `GMenuModel` from which the popup will be constructed.
// 
// If @menu_model is nil, the button is disabled.
// 
// A [class@Gtk.Popover] will be created from the menu model with
// [ctor@Gtk.PopoverMenu.new_from_model]. Actions will be connected as
// documented for this function.
// 
// If [property@Gtk.MenuButton:popover] is already set, it will be dissociated
// from the @menu_button, and the property is set to nil.
	func (m MenuButton) SetMenuModel(menuModel gio.MenuModelClass)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(menuModel.Native()))

C.gtk_menu_button_set_menu_model(_arg0, _arg1)
}
	
	// SetPopover sets the `GtkPopover` that will be popped up when the @menu_button
// is clicked.
// 
// If @popover is nil, the button is disabled.
// 
// If [property@Gtk.MenuButton:menu-model] is set, the menu model is dissociated
// from the @menu_button, and the property is set to nil.
	func (m MenuButton) SetPopover(popover WidgetClass)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(popover.Native()))

C.gtk_menu_button_set_popover(_arg0, _arg1)
}
	
	// SetUseUnderline: if true, an underline in the text indicates a mnemonic.
	func (m MenuButton) SetUseUnderline(useUnderline bool)  {
var _arg0 *C.GtkMenuButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkMenuButton)(unsafe.Pointer(m.Native()))
if useUnderline { _arg1 = C.TRUE }

C.gtk_menu_button_set_use_underline(_arg0, _arg1)
}
	


	// MessageDialog: `GtkMessageDialog` presents a dialog with some message text.
// 
// !An example GtkMessageDialog (messagedialog.png)
// 
// Its simply a convenience widget; you could construct the equivalent of
// `GtkMessageDialog` from `GtkDialog` without too much effort, but
// `GtkMessageDialog` saves typing.
// 
// The easiest way to do a modal message dialog is to use the GTK_DIALOG_MODAL
// flag, which will call [method@Gtk.Window.set_modal] internally. The dialog
// will prevent interaction with the parent window until it's hidden or
// destroyed. You can use the [signal@Gtk.Dialog::response] signal to know when
// the user dismissed the dialog.
// 
// An example for using a modal dialog: `c GtkDialogFlags flags =
// GTK_DIALOG_DESTROY_WITH_PARENT | GTK_DIALOG_MODAL; dialog =
// gtk_message_dialog_new (parent_window, flags, GTK_MESSAGE_ERROR,
// GTK_BUTTONS_CLOSE, "Error reading s: s", filename, g_strerror (errno)); //
// Destroy the dialog when the user responds to it // (e.g. clicks a button)
// 
// g_signal_connect (dialog, "response", G_CALLBACK (gtk_window_destroy), NULL);
// `
// 
// You might do a non-modal `GtkMessageDialog` simply by omitting the
// GTK_DIALOG_MODAL flag:
// 
// `c GtkDialogFlags flags = GTK_DIALOG_DESTROY_WITH_PARENT; dialog =
// gtk_message_dialog_new (parent_window, flags, GTK_MESSAGE_ERROR,
// GTK_BUTTONS_CLOSE, "Error reading s: s", filename, g_strerror (errno));
// 
// // Destroy the dialog when the user responds to it // (e.g. clicks a button)
// // g_signal_connect (dialog, "response", G_CALLBACK (gtk_window_destroy), NULL);
// // `
// 
// 
// GtkMessageDialog as GtkBuildable
// 
// The `GtkMessageDialog` implementation of the `GtkBuildable` interface exposes
// the message area as an internal child with the name message_area.
	type MessageDialog struct {
		Dialog
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// MessageDialogClass is an interface that the MessageDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MessageDialogClass interface {
		gextras.Objector
		_messageDialog()
	}

	func (MessageDialog) _messageDialog() {}

	
	func marshalMessageDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMessageDialog(obj), nil
	}
	

	

	
	// MessageArea returns the message area of the dialog.
// 
// This is the box where the dialogs primary and secondary labels are packed.
// You can add your own extra content to that box and it will appear below those
// labels. See [method@Gtk.Dialog.get_content_area] for the corresponding
// function in the parent [class@Gtk.Dialog].
	func (m MessageDialog) MessageArea() Widget {
var _arg0 *C.GtkMessageDialog // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))

_cret = C.gtk_message_dialog_get_message_area(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetMarkup sets the text of the message dialog.
	func (m MessageDialog) SetMarkup(str string)  {
var _arg0 *C.GtkMessageDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkMessageDialog)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_message_dialog_set_markup(_arg0, _arg1)
}
	


	// MnemonicAction: a `GtkShortcutAction` that calls
// gtk_widget_mnemonic_activate().
	type MnemonicAction struct {
		ShortcutAction
		
	}

	// MnemonicActionClass is an interface that the MnemonicAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MnemonicActionClass interface {
		gextras.Objector
		_mnemonicAction()
	}

	func (MnemonicAction) _mnemonicAction() {}

	
	func marshalMnemonicAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMnemonicAction(obj), nil
	}
	

	

	


	// MnemonicTrigger: a `GtkShortcutTrigger` that triggers when a specific
// mnemonic is pressed.
// 
// Mnemonics require a *mnemonic modifier* (typically <kbd>Alt</kbd>) to be
// pressed together with the mnemonic key.
	type MnemonicTrigger struct {
		ShortcutTrigger
		
	}

	// MnemonicTriggerClass is an interface that the MnemonicTrigger class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MnemonicTriggerClass interface {
		gextras.Objector
		_mnemonicTrigger()
	}

	func (MnemonicTrigger) _mnemonicTrigger() {}

	
	func marshalMnemonicTrigger(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMnemonicTrigger(obj), nil
	}
	

	
	// NewMnemonicTrigger creates a `GtkShortcutTrigger` that will trigger whenever
// the key with the given @keyval is pressed and mnemonics have been activated.
// 
// Mnemonics are activated by calling code when a key event with the right
// modifiers is detected.
	func NewMnemonicTrigger(keyval uint) MnemonicTrigger {
var _arg1 C.guint // out
var _cret *C.GtkShortcutTrigger // in

_arg1 = (C.guint)(keyval)

_cret = C.gtk_mnemonic_trigger_new(_arg1)


var _mnemonicTrigger MnemonicTrigger // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mnemonicTrigger = MnemonicTrigger{
ShortcutTrigger: ShortcutTrigger{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mnemonicTrigger
}
	

	
	// Keyval gets the keyval that must be pressed to succeed triggering @self.
	func (s MnemonicTrigger) Keyval() uint {
var _arg0 *C.GtkMnemonicTrigger // out
var _cret C.guint // in

_arg0 = (*C.GtkMnemonicTrigger)(unsafe.Pointer(s.Native()))

_cret = C.gtk_mnemonic_trigger_get_keyval(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	


	// MountOperation: `GtkMountOperation` is an implementation of
// `GMountOperation`.
// 
// The functions and objects described here make working with GTK and GIO more
// convenient.
// 
// `GtkMountOperation` is needed when mounting volumes: It is an implementation
// of `GMountOperation` that can be used with GIO functions for mounting volumes
// such as g_file_mount_enclosing_volume(), g_file_mount_mountable(),
// g_volume_mount(), g_mount_unmount_with_operation() and others.
// 
// When necessary, `GtkMountOperation` shows dialogs to let the user enter
// passwords, ask questions or show processes blocking unmount.
	type MountOperation struct {
		gio.MountOperation
		
	}

	// MountOperationClass is an interface that the MountOperation class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MountOperationClass interface {
		gextras.Objector
		_mountOperation()
	}

	func (MountOperation) _mountOperation() {}

	
	func marshalMountOperation(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMountOperation(obj), nil
	}
	

	
	// NewMountOperation creates a new `GtkMountOperation`.
	func NewMountOperation(parent WindowClass) MountOperation {
var _arg1 *C.GtkWindow // out
var _cret *C.GMountOperation // in

_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_mount_operation_new(_arg1)


var _mountOperation MountOperation // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_mountOperation = MountOperation{
MountOperation: gio.MountOperation{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _mountOperation
}
	

	
	// Display gets the display on which windows of the `GtkMountOperation` will be
// shown.
	func (o MountOperation) Display() gdk.Display {
var _arg0 *C.GtkMountOperation // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_mount_operation_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// Parent gets the transient parent used by the `GtkMountOperation`.
	func (o MountOperation) Parent() Window {
var _arg0 *C.GtkMountOperation // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_mount_operation_get_parent(_arg0)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// IsShowing returns whether the `GtkMountOperation` is currently displaying a
// window.
	func (o MountOperation) IsShowing() bool {
var _arg0 *C.GtkMountOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_mount_operation_is_showing(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetDisplay sets the display to show windows of the `GtkMountOperation` on.
	func (o MountOperation) SetDisplay(display gdk.DisplayClass)  {
var _arg0 *C.GtkMountOperation // out
var _arg1 *C.GdkDisplay // out

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

C.gtk_mount_operation_set_display(_arg0, _arg1)
}
	
	// SetParent sets the transient parent for windows shown by the
// `GtkMountOperation`.
	func (o MountOperation) SetParent(parent WindowClass)  {
var _arg0 *C.GtkMountOperation // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkMountOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

C.gtk_mount_operation_set_parent(_arg0, _arg1)
}
	


	// MultiFilter: `GtkMultiFilter` is the base class for filters that combine
// multiple filters.
	type MultiFilter struct {
		Filter
		gio.ListModel
		Buildable
		
	}

	// MultiFilterClass is an interface that the MultiFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MultiFilterClass interface {
		gextras.Objector
		_multiFilter()
	}

	func (MultiFilter) _multiFilter() {}

	
	func marshalMultiFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMultiFilter(obj), nil
	}
	

	

	
	// Append adds a @filter to @self to use for matching.
	func (s MultiFilter) Append(filter FilterClass)  {
var _arg0 *C.GtkMultiFilter // out
var _arg1 *C.GtkFilter // out

_arg0 = (*C.GtkMultiFilter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkFilter)(unsafe.Pointer(filter.Native()))

C.gtk_multi_filter_append(_arg0, _arg1)
}
	
	// Remove removes the filter at the given @position from the list of filters
// used by @self.
// 
// If @position is larger than the number of filters, nothing happens and the
// function returns.
	func (s MultiFilter) Remove(position uint)  {
var _arg0 *C.GtkMultiFilter // out
var _arg1 C.guint // out

_arg0 = (*C.GtkMultiFilter)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

C.gtk_multi_filter_remove(_arg0, _arg1)
}
	


	// MultiSelection: `GtkMultiSelection` is a `GtkSelectionModel` that allows
// selecting multiple elements.
	type MultiSelection struct {
		**externglib.Object
		gio.ListModel
		SelectionModel
		
	}

	// MultiSelectionClass is an interface that the MultiSelection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MultiSelectionClass interface {
		gextras.Objector
		_multiSelection()
	}

	func (MultiSelection) _multiSelection() {}

	
	func marshalMultiSelection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMultiSelection(obj), nil
	}
	

	
	// NewMultiSelection creates a new selection to handle @model.
	func NewMultiSelection(model gio.ListModel) MultiSelection {
var _arg1 *C.GListModel // out
var _cret *C.GtkMultiSelection // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_multi_selection_new(_arg1)


var _multiSelection MultiSelection // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_multiSelection = MultiSelection{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
SelectionModel: SelectionModel{
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _multiSelection
}
	

	
	// Model returns the underlying model of @self.
	func (s MultiSelection) Model() gio.ListModel {
var _arg0 *C.GtkMultiSelection // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkMultiSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_multi_selection_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// SetModel sets the model that @self should wrap.
// 
// If @model is nil, @self will be empty.
	func (s MultiSelection) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkMultiSelection // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkMultiSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_multi_selection_set_model(_arg0, _arg1)
}
	


	// MultiSorter: `GtkMultiSorter` combines multiple sorters by trying them in
// turn.
// 
// If the first sorter compares two items as equal, the second is tried next,
// and so on.
	type MultiSorter struct {
		Sorter
		gio.ListModel
		Buildable
		
	}

	// MultiSorterClass is an interface that the MultiSorter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type MultiSorterClass interface {
		gextras.Objector
		_multiSorter()
	}

	func (MultiSorter) _multiSorter() {}

	
	func marshalMultiSorter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapMultiSorter(obj), nil
	}
	

	
	// NewMultiSorter creates a new multi sorter.
// 
// This sorter compares items by trying each of the sorters in turn, until one
// returns non-zero. In particular, if no sorter has been added to it, it will
// always compare items as equal.
	func NewMultiSorter() MultiSorter {
var _cret *C.GtkMultiSorter // in

_cret = C.gtk_multi_sorter_new()


var _multiSorter MultiSorter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_multiSorter = MultiSorter{
Sorter: Sorter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _multiSorter
}
	

	
	// Append: add @sorter to @self to use for sorting at the end.
// 
// @self will consult all existing sorters before it will sort with the given
// @sorter.
	func (s MultiSorter) Append(sorter SorterClass)  {
var _arg0 *C.GtkMultiSorter // out
var _arg1 *C.GtkSorter // out

_arg0 = (*C.GtkMultiSorter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

C.gtk_multi_sorter_append(_arg0, _arg1)
}
	
	// Remove removes the sorter at the given @position from the list of sorter used
// by @self.
// 
// If @position is larger than the number of sorters, nothing happens.
	func (s MultiSorter) Remove(position uint)  {
var _arg0 *C.GtkMultiSorter // out
var _arg1 C.guint // out

_arg0 = (*C.GtkMultiSorter)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

C.gtk_multi_sorter_remove(_arg0, _arg1)
}
	


	// NamedAction: a `GtkShortcutAction` that activates an action by name.
	type NamedAction struct {
		ShortcutAction
		
	}

	// NamedActionClass is an interface that the NamedAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NamedActionClass interface {
		gextras.Objector
		_namedAction()
	}

	func (NamedAction) _namedAction() {}

	
	func marshalNamedAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNamedAction(obj), nil
	}
	

	
	// NewNamedAction creates an action that when activated, activates the named
// action on the widget.
// 
// It also passes the given arguments to it.
// 
// See [method@Gtk.Widget.insert_action_group] for how to add actions to
// widgets.
	func NewNamedAction(name string) NamedAction {
var _arg1 *C.char // out
var _cret *C.GtkShortcutAction // in

_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_named_action_new(_arg1)


var _namedAction NamedAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_namedAction = NamedAction{
ShortcutAction: ShortcutAction{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _namedAction
}
	

	
	// ActionName returns the name of the action that will be activated.
	func (s NamedAction) ActionName() string {
var _arg0 *C.GtkNamedAction // out
var _cret *C.char // in

_arg0 = (*C.GtkNamedAction)(unsafe.Pointer(s.Native()))

_cret = C.gtk_named_action_get_action_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	// NativeDialog: native dialogs are platform dialogs that don't use `GtkDialog`.
// 
// They are used in order to integrate better with a platform, by looking the
// same as other native applications and supporting platform specific features.
// 
// The [class@Gtk.Dialog] functions cannot be used on such objects, but we need
// a similar API in order to drive them. The `GtkNativeDialog` object is an API
// that allows you to do this. It allows you to set various common properties on
// the dialog, as well as show and hide it and get a
// [signal@Gtk.NativeDialog::response] signal when the user finished with the
// dialog.
// 
// Note that unlike `GtkDialog`, `GtkNativeDialog` objects are not toplevel
// widgets, and GTK does not keep them alive. It is your responsibility to keep
// a reference until you are done with the object.
	type NativeDialog struct {
		**externglib.Object
		
	}

	// NativeDialogClass is an interface that the NativeDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NativeDialogClass interface {
		gextras.Objector
		_nativeDialog()
	}

	func (NativeDialog) _nativeDialog() {}

	
	func marshalNativeDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNativeDialog(obj), nil
	}
	

	

	
	// Destroy destroys a dialog.
// 
// When a dialog is destroyed, it will break any references it holds to other
// objects.
// 
// If it is visible it will be hidden and any underlying window system resources
// will be destroyed.
// 
// Note that this does not release any reference to the object (as opposed to
// destroying a `GtkWindow`) because there is no reference from the windowing
// system to the `GtkNativeDialog`.
	func (s NativeDialog) Destroy()  {
var _arg0 *C.GtkNativeDialog // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

C.gtk_native_dialog_destroy(_arg0)
}
	
	// Modal returns whether the dialog is modal.
	func (s NativeDialog) Modal() bool {
var _arg0 *C.GtkNativeDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title gets the title of the `GtkNativeDialog`.
	func (s NativeDialog) Title() string {
var _arg0 *C.GtkNativeDialog // out
var _cret *C.char // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TransientFor fetches the transient parent for this window.
	func (s NativeDialog) TransientFor() Window {
var _arg0 *C.GtkNativeDialog // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_transient_for(_arg0)


var _window Window // out

_window = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _window
}
	
	// Visible determines whether the dialog is visible.
	func (s NativeDialog) Visible() bool {
var _arg0 *C.GtkNativeDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

_cret = C.gtk_native_dialog_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Hide hides the dialog if it is visible, aborting any interaction.
// 
// Once this is called the [signal@Gtk.NativeDialog::response] signal will *not*
// be emitted until after the next call to [method@Gtk.NativeDialog.show].
// 
// If the dialog is not visible this does nothing.
	func (s NativeDialog) Hide()  {
var _arg0 *C.GtkNativeDialog // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

C.gtk_native_dialog_hide(_arg0)
}
	
	// SetModal sets a dialog modal or non-modal.
// 
// Modal dialogs prevent interaction with other windows in the same application.
// To keep modal dialogs on top of main application windows, use
// [method@Gtk.NativeDialog.set_transient_for] to make the dialog transient for
// the parent; most window managers will then disallow lowering the dialog below
// the parent.
	func (s NativeDialog) SetModal(modal bool)  {
var _arg0 *C.GtkNativeDialog // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_native_dialog_set_modal(_arg0, _arg1)
}
	
	// SetTitle sets the title of the `GtkNativeDialog.`
	func (s NativeDialog) SetTitle(title string)  {
var _arg0 *C.GtkNativeDialog // out
var _arg1 *C.char // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_native_dialog_set_title(_arg0, _arg1)
}
	
	// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from.
// 
// This allows window managers to e.g. keep the dialog on top of the main
// window, or center the dialog over the main window.
// 
// Passing nil for @parent unsets the current transient window.
	func (s NativeDialog) SetTransientFor(parent WindowClass)  {
var _arg0 *C.GtkNativeDialog // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

C.gtk_native_dialog_set_transient_for(_arg0, _arg1)
}
	
	// Show shows the dialog on the display.
// 
// When the user accepts the state of the dialog the dialog will be
// automatically hidden and the [signal@Gtk.NativeDialog::response] signal will
// be emitted.
// 
// Multiple calls while the dialog is visible will be ignored.
	func (s NativeDialog) Show()  {
var _arg0 *C.GtkNativeDialog // out

_arg0 = (*C.GtkNativeDialog)(unsafe.Pointer(s.Native()))

C.gtk_native_dialog_show(_arg0)
}
	


	// NeverTrigger: a `GtkShortcutTrigger` that never triggers.
	type NeverTrigger struct {
		ShortcutTrigger
		
	}

	// NeverTriggerClass is an interface that the NeverTrigger class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NeverTriggerClass interface {
		gextras.Objector
		_neverTrigger()
	}

	func (NeverTrigger) _neverTrigger() {}

	
	func marshalNeverTrigger(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNeverTrigger(obj), nil
	}
	

	

	


	// NoSelection: `GtkNoSelection` is a `GtkSelectionModel` that does not allow
// selecting anything.
// 
// This model is meant to be used as a simple wrapper around a `GListModel` when
// a `GtkSelectionModel` is required.
	type NoSelection struct {
		**externglib.Object
		gio.ListModel
		SelectionModel
		
	}

	// NoSelectionClass is an interface that the NoSelection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NoSelectionClass interface {
		gextras.Objector
		_noSelection()
	}

	func (NoSelection) _noSelection() {}

	
	func marshalNoSelection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNoSelection(obj), nil
	}
	

	
	// NewNoSelection creates a new selection to handle @model.
	func NewNoSelection(model gio.ListModel) NoSelection {
var _arg1 *C.GListModel // out
var _cret *C.GtkNoSelection // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_no_selection_new(_arg1)


var _noSelection NoSelection // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_noSelection = NoSelection{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
SelectionModel: SelectionModel{
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _noSelection
}
	

	
	// Model gets the model that @self is wrapping.
	func (s NoSelection) Model() gio.ListModel {
var _arg0 *C.GtkNoSelection // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkNoSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_no_selection_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// SetModel sets the model that @self should wrap.
// 
// If @model is nil, this model will be empty.
	func (s NoSelection) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkNoSelection // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkNoSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_no_selection_set_model(_arg0, _arg1)
}
	


	// Notebook: `GtkNotebook` is a container whose children are pages switched
// between using tabs.
// 
// !An example GtkNotebook (notebook.png)
// 
// There are many configuration options for `GtkNotebook`. Among other things,
// you can choose on which edge the tabs appear (see
// [method@Gtk.Notebook.set_tab_pos]), whether, if there are too many tabs to
// fit the notebook should be made bigger or scrolling arrows added (see
// [method@Gtk.Notebook.set_scrollable]), and whether there will be a popup menu
// allowing the users to switch pages. (see [method@Gtk.Notebook.popup_enable]).
// 
// 
// GtkNotebook as GtkBuildable
// 
// The `GtkNotebook` implementation of the `GtkBuildable` interface supports
// placing children into tabs by specifying tab as the type attribute of a
// <child> element. Note that the content of the tab must be created before the
// tab can be filled. A tab child can be specified without specifying a <child>
// type attribute.
// 
// To add a child widget in the notebooks action area, specify "action-start" or
// action-end as the type attribute of the <child> element.
// 
// An example of a UI definition fragment with `GtkNotebook`:
// 
// `xml <object class="GtkNotebook"> <child> <object class="GtkLabel"
// id="notebook-content"> <property name="label">Content</property> </object>
// </child> <child type="tab"> <object class="GtkLabel" id="notebook-tab">
// <property name="label">Tab</property> </object> </child> </object> `
// 
// 
// CSS nodes
// 
// ` notebook  header.top   [<action widget>]   tabs    [arrow]
//    tab     <tab label>       tab[.reorderable-page]   
//  <tab label>    [arrow]   [<action widget>]   stack 
// <child>   <child> `
// 
// `GtkNotebook` has a main CSS node with name `notebook`, a subnode with name
// `header` and below that a subnode with name `tabs` which contains one subnode
// per tab with name `tab`.
// 
// If action widgets are present, their CSS nodes are placed next to the `tabs`
// node. If the notebook is scrollable, CSS nodes with name `arrow` are placed
// as first and last child of the `tabs` node.
// 
// The main node gets the `.frame` style class when the notebook has a border
// (see [method@Gtk.Notebook.set_show_border]).
// 
// The header node gets one of the style class `.top`, `.bottom`, `.left` or
// `.right`, depending on where the tabs are placed. For reorderable pages, the
// tab node gets the `.reorderable-page` class.
// 
// A `tab` node gets the `.dnd` style class while it is moved with
// drag-and-drop.
// 
// The nodes are always arranged from left-to-right, regardless of text
// direction.
// 
// 
// Accessibility
// 
// `GtkNotebook` uses the following roles:
// 
//    - GTK_ACCESSIBLE_ROLE_GROUP for the notebook widget
//    - GTK_ACCESSIBLE_ROLE_TAB_LIST for the list of tabs
//    - GTK_ACCESSIBLE_ROLE_TAB role for each tab
//    - GTK_ACCESSIBLE_ROLE_TAB_PANEL for each page
	type Notebook struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// NotebookClass is an interface that the Notebook class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NotebookClass interface {
		gextras.Objector
		_notebook()
	}

	func (Notebook) _notebook() {}

	
	func marshalNotebook(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNotebook(obj), nil
	}
	

	
	// NewNotebook creates a new `GtkNotebook` widget with no pages.
	func NewNotebook() Notebook {
var _cret *C.GtkWidget // in

_cret = C.gtk_notebook_new()


var _notebook Notebook // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_notebook = Notebook{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _notebook
}
	

	
	// AppendPage appends a page to @notebook.
	func (n Notebook) AppendPage(child WidgetClass, tabLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

_cret = C.gtk_notebook_append_page(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AppendPageMenu appends a page to @notebook, specifying the widget to use as
// the label in the popup menu.
	func (n Notebook) AppendPageMenu(child WidgetClass, tabLabel WidgetClass, menuLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

_cret = C.gtk_notebook_append_page_menu(_arg0, _arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// DetachTab removes the child from the notebook.
// 
// This function is very similar to [method@Gtk.Notebook.remove_page], but
// additionally informs the notebook that the removal is happening as part of a
// tab DND operation, which should not be cancelled.
	func (n Notebook) DetachTab(child WidgetClass)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_notebook_detach_tab(_arg0, _arg1)
}
	
	// ActionWidget gets one of the action widgets.
// 
// See [method@Gtk.Notebook.set_action_widget].
	func (n Notebook) ActionWidget(packType PackType) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 C.GtkPackType // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.GtkPackType)(packType)

_cret = C.gtk_notebook_get_action_widget(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// CurrentPage returns the page number of the current page.
	func (n Notebook) CurrentPage() int {
var _arg0 *C.GtkNotebook // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_current_page(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// GroupName gets the current group name for @notebook.
	func (n Notebook) GroupName() string {
var _arg0 *C.GtkNotebook // out
var _cret *C.char // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_group_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// MenuLabel retrieves the menu label widget of the page containing @child.
	func (n Notebook) MenuLabel(child WidgetClass) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_menu_label(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// MenuLabelText retrieves the text of the menu label for the page containing
// @child.
	func (n Notebook) MenuLabelText(child WidgetClass) string {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_menu_label_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NPages gets the number of pages in a notebook.
	func (n Notebook) NPages() int {
var _arg0 *C.GtkNotebook // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_n_pages(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NthPage returns the child widget contained in page number @page_num.
	func (n Notebook) NthPage(pageNum int) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 C.int // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.int)(pageNum)

_cret = C.gtk_notebook_get_nth_page(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Page returns the `GtkNotebookPage` for @child.
	func (n Notebook) Page(child WidgetClass) NotebookPage {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkNotebookPage // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_page(_arg0, _arg1)


var _notebookPage NotebookPage // out

_notebookPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(NotebookPage)

return _notebookPage
}
	
	// Pages returns a `GListModel` that contains the pages of the notebook.
// 
// This can be used to keep an up-to-date view. The model also implements
// [iface@Gtk.SelectionModel] and can be used to track and modify the visible
// page.
	func (n Notebook) Pages() gio.ListModel {
var _arg0 *C.GtkNotebook // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_pages(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Scrollable returns whether the tab label area has arrows for scrolling.
	func (n Notebook) Scrollable() bool {
var _arg0 *C.GtkNotebook // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_scrollable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowBorder returns whether a bevel will be drawn around the notebook pages.
	func (n Notebook) ShowBorder() bool {
var _arg0 *C.GtkNotebook // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_show_border(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowTabs returns whether the tabs of the notebook are shown.
	func (n Notebook) ShowTabs() bool {
var _arg0 *C.GtkNotebook // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_show_tabs(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TabDetachable returns whether the tab contents can be detached from
// @notebook.
	func (n Notebook) TabDetachable(child WidgetClass) bool {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_detachable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TabLabel returns the tab label widget for the page @child.
// 
// nil is returned if @child is not in @notebook or if no tab label has
// specifically been set for @child.
	func (n Notebook) TabLabel(child WidgetClass) Widget {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_label(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// TabLabelText retrieves the text of the tab label for the page containing
// @child.
	func (n Notebook) TabLabelText(child WidgetClass) string {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_label_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TabPos gets the edge at which the tabs are drawn.
	func (n Notebook) TabPos() PositionType {
var _arg0 *C.GtkNotebook // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

_cret = C.gtk_notebook_get_tab_pos(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// TabReorderable gets whether the tab can be reordered via drag and drop or
// not.
	func (n Notebook) TabReorderable(child WidgetClass) bool {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_get_tab_reorderable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsertPage: insert a page into @notebook at the given position.
	func (n Notebook) InsertPage(child WidgetClass, tabLabel WidgetClass, position int) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 C.int // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (C.int)(position)

_cret = C.gtk_notebook_insert_page(_arg0, _arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InsertPageMenu: insert a page into @notebook at the given position,
// specifying the widget to use as the label in the popup menu.
	func (n Notebook) InsertPageMenu(child WidgetClass, tabLabel WidgetClass, menuLabel WidgetClass, position int) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkWidget // out
var _arg4 C.int // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))
_arg4 = (C.int)(position)

_cret = C.gtk_notebook_insert_page_menu(_arg0, _arg1, _arg2, _arg3, _arg4)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NextPage switches to the next page.
// 
// Nothing happens if the current page is the last page.
	func (n Notebook) NextPage()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_next_page(_arg0)
}
	
	// PageNum finds the index of the page which contains the given child widget.
	func (n Notebook) PageNum(child WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_notebook_page_num(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PopupDisable disables the popup menu.
	func (n Notebook) PopupDisable()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_popup_disable(_arg0)
}
	
	// PopupEnable enables the popup menu.
// 
// If the user clicks with the right mouse button on the tab labels, a menu with
// all the pages will be popped up.
	func (n Notebook) PopupEnable()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_popup_enable(_arg0)
}
	
	// PrependPage prepends a page to @notebook.
	func (n Notebook) PrependPage(child WidgetClass, tabLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

_cret = C.gtk_notebook_prepend_page(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PrependPageMenu prepends a page to @notebook, specifying the widget to use as
// the label in the popup menu.
	func (n Notebook) PrependPageMenu(child WidgetClass, tabLabel WidgetClass, menuLabel WidgetClass) int {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))
_arg3 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

_cret = C.gtk_notebook_prepend_page_menu(_arg0, _arg1, _arg2, _arg3)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PrevPage switches to the previous page.
// 
// Nothing happens if the current page is the first page.
	func (n Notebook) PrevPage()  {
var _arg0 *C.GtkNotebook // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))

C.gtk_notebook_prev_page(_arg0)
}
	
	// RemovePage removes a page from the notebook given its index in the notebook.
	func (n Notebook) RemovePage(pageNum int)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.int // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.int)(pageNum)

C.gtk_notebook_remove_page(_arg0, _arg1)
}
	
	// ReorderChild reorders the page containing @child, so that it appears in
// position @position.
// 
// If @position is greater than or equal to the number of children in the list
// or negative, @child will be moved to the end of the list.
	func (n Notebook) ReorderChild(child WidgetClass, position int)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(position)

C.gtk_notebook_reorder_child(_arg0, _arg1, _arg2)
}
	
	// SetActionWidget sets @widget as one of the action widgets.
// 
// Depending on the pack type the widget will be placed before or after the
// tabs. You can use a `GtkBox` if you need to pack more than one widget on the
// same side.
	func (n Notebook) SetActionWidget(widget WidgetClass, packType PackType)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.GtkPackType // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg2 = (C.GtkPackType)(packType)

C.gtk_notebook_set_action_widget(_arg0, _arg1, _arg2)
}
	
	// SetCurrentPage switches to the page number @page_num.
// 
// Note that due to historical reasons, GtkNotebook refuses to switch to a page
// unless the child widget is visible. Therefore, it is recommended to show
// child widgets before adding them to a notebook.
	func (n Notebook) SetCurrentPage(pageNum int)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.int // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.int)(pageNum)

C.gtk_notebook_set_current_page(_arg0, _arg1)
}
	
	// SetGroupName sets a group name for @notebook.
// 
// Notebooks with the same name will be able to exchange tabs via drag and drop.
// A notebook with a nil group name will not be able to exchange tabs with any
// other notebook.
	func (n Notebook) SetGroupName(groupName string)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.char // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_notebook_set_group_name(_arg0, _arg1)
}
	
	// SetMenuLabel changes the menu label for the page containing @child.
	func (n Notebook) SetMenuLabel(child WidgetClass, menuLabel WidgetClass)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(menuLabel.Native()))

C.gtk_notebook_set_menu_label(_arg0, _arg1, _arg2)
}
	
	// SetMenuLabelText creates a new label and sets it as the menu label of @child.
	func (n Notebook) SetMenuLabelText(child WidgetClass, menuText string)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.char // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.char)(C.CString(menuText))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_notebook_set_menu_label_text(_arg0, _arg1, _arg2)
}
	
	// SetScrollable sets whether the tab label area will have arrows for scrolling
// if there are too many tabs to fit in the area.
	func (n Notebook) SetScrollable(scrollable bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
if scrollable { _arg1 = C.TRUE }

C.gtk_notebook_set_scrollable(_arg0, _arg1)
}
	
	// SetShowBorder sets whether a bevel will be drawn around the notebook pages.
// 
// This only has a visual effect when the tabs are not shown.
	func (n Notebook) SetShowBorder(showBorder bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
if showBorder { _arg1 = C.TRUE }

C.gtk_notebook_set_show_border(_arg0, _arg1)
}
	
	// SetShowTabs sets whether to show the tabs for the notebook or not.
	func (n Notebook) SetShowTabs(showTabs bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
if showTabs { _arg1 = C.TRUE }

C.gtk_notebook_set_show_tabs(_arg0, _arg1)
}
	
	// SetTabDetachable sets whether the tab can be detached from @notebook to
// another notebook or widget.
// 
// Note that two notebooks must share a common group identificator (see
// [method@Gtk.Notebook.set_group_name]) to allow automatic tabs interchange
// between them.
// 
// If you want a widget to interact with a notebook through DnD (i.e.: accept
// dragged tabs from it) it must be set as a drop destination and accept the
// target GTK_NOTEBOOK_TAB. The notebook will fill the selection with a
// GtkWidget** pointing to the child widget that corresponds to the dropped tab.
// 
// Note that you should use [method@Gtk.Notebook.detach_tab] instead of
// [method@Gtk.Notebook.remove_page] if you want to remove the tab from the
// source notebook as part of accepting a drop. Otherwise, the source notebook
// will think that the dragged tab was removed from underneath the ongoing drag
// operation, and will initiate a drag cancel animation.
// 
// `c static void on_drag_data_received (GtkWidget *widget, GdkDrop *drop,
// GtkSelectionData *data, guint time, gpointer user_data) { GtkDrag *drag;
// GtkWidget *notebook; GtkWidget **child;
// 
//    drag = gtk_drop_get_drag (drop);
//    notebook = g_object_get_data (drag, "gtk-notebook-drag-origin");
//    child = (void*) gtk_selection_data_get_data (data);
// 
//    // process_widget (*child);
// 
//    gtk_notebook_detach_tab (GTK_NOTEBOOK (notebook), *child);
// 
// } `
// 
// If you want a notebook to accept drags from other widgets, you will have to
// set your own DnD code to do it.
	func (n Notebook) SetTabDetachable(child WidgetClass, detachable bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if detachable { _arg2 = C.TRUE }

C.gtk_notebook_set_tab_detachable(_arg0, _arg1, _arg2)
}
	
	// SetTabLabel changes the tab label for @child.
// 
// If nil is specified for @tab_label, then the page will have the label page
// N.
	func (n Notebook) SetTabLabel(child WidgetClass, tabLabel WidgetClass)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

C.gtk_notebook_set_tab_label(_arg0, _arg1, _arg2)
}
	
	// SetTabLabelText creates a new label and sets it as the tab label for the page
// containing @child.
	func (n Notebook) SetTabLabelText(child WidgetClass, tabText string)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.char // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.char)(C.CString(tabText))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_notebook_set_tab_label_text(_arg0, _arg1, _arg2)
}
	
	// SetTabPos sets the edge at which the tabs are drawn.
	func (n Notebook) SetTabPos(pos PositionType)  {
var _arg0 *C.GtkNotebook // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (C.GtkPositionType)(pos)

C.gtk_notebook_set_tab_pos(_arg0, _arg1)
}
	
	// SetTabReorderable sets whether the notebook tab can be reordered via drag and
// drop or not.
	func (n Notebook) SetTabReorderable(child WidgetClass, reorderable bool)  {
var _arg0 *C.GtkNotebook // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkNotebook)(unsafe.Pointer(n.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
if reorderable { _arg2 = C.TRUE }

C.gtk_notebook_set_tab_reorderable(_arg0, _arg1, _arg2)
}
	


	// NotebookPage: `GtkNotebookPage` is an auxiliary object used by `GtkNotebook`.
	type NotebookPage struct {
		**externglib.Object
		
	}

	// NotebookPageClass is an interface that the NotebookPage class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NotebookPageClass interface {
		gextras.Objector
		_notebookPage()
	}

	func (NotebookPage) _notebookPage() {}

	
	func marshalNotebookPage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNotebookPage(obj), nil
	}
	

	

	
	// Child returns the notebook child to which @page belongs.
	func (p NotebookPage) Child() Widget {
var _arg0 *C.GtkNotebookPage // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkNotebookPage)(unsafe.Pointer(p.Native()))

_cret = C.gtk_notebook_page_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	


	// NothingAction: a `GtkShortcutAction` that does nothing.
	type NothingAction struct {
		ShortcutAction
		
	}

	// NothingActionClass is an interface that the NothingAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NothingActionClass interface {
		gextras.Objector
		_nothingAction()
	}

	func (NothingAction) _nothingAction() {}

	
	func marshalNothingAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNothingAction(obj), nil
	}
	

	

	


	// NumericSorter: `GtkNumericSorter` is a `GtkSorter` that compares numbers.
// 
// To obtain the numbers to compare, this sorter evaluates a
// [class@Gtk.Expression].
	type NumericSorter struct {
		Sorter
		
	}

	// NumericSorterClass is an interface that the NumericSorter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type NumericSorterClass interface {
		gextras.Objector
		_numericSorter()
	}

	func (NumericSorter) _numericSorter() {}

	
	func marshalNumericSorter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapNumericSorter(obj), nil
	}
	

	
	// NewNumericSorter creates a new numeric sorter using the given @expression.
// 
// Smaller numbers will be sorted first. You can call
// [method@Gtk.NumericSorter.set_sort_order] to change this.
	func NewNumericSorter(expression ExpressionClass) NumericSorter {
var _arg1 *C.GtkExpression // out
var _cret *C.GtkNumericSorter // in

_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

_cret = C.gtk_numeric_sorter_new(_arg1)


var _numericSorter NumericSorter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_numericSorter = NumericSorter{
Sorter: Sorter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _numericSorter
}
	

	
	// Expression gets the expression that is evaluated to obtain numbers from
// items.
	func (s NumericSorter) Expression() Expression {
var _arg0 *C.GtkNumericSorter // out
var _cret *C.GtkExpression // in

_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_numeric_sorter_get_expression(_arg0)


var _expression Expression // out

_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

return _expression
}
	
	// SortOrder gets whether this sorter will sort smaller numbers first.
	func (s NumericSorter) SortOrder() SortType {
var _arg0 *C.GtkNumericSorter // out
var _cret C.GtkSortType // in

_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_numeric_sorter_get_sort_order(_arg0)


var _sortType SortType // out

_sortType = SortType(_cret)

return _sortType
}
	
	// SetExpression sets the expression that is evaluated to obtain numbers from
// items.
// 
// Unless an expression is set on @self, the sorter will always compare items as
// invalid.
// 
// The expression must have a return type that can be compared numerically, such
// as G_TYPE_INT or G_TYPE_DOUBLE.
	func (s NumericSorter) SetExpression(expression ExpressionClass)  {
var _arg0 *C.GtkNumericSorter // out
var _arg1 *C.GtkExpression // out

_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

C.gtk_numeric_sorter_set_expression(_arg0, _arg1)
}
	
	// SetSortOrder sets whether to sort smaller numbers before larger ones.
	func (s NumericSorter) SetSortOrder(sortOrder SortType)  {
var _arg0 *C.GtkNumericSorter // out
var _arg1 C.GtkSortType // out

_arg0 = (*C.GtkNumericSorter)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSortType)(sortOrder)

C.gtk_numeric_sorter_set_sort_order(_arg0, _arg1)
}
	


	// Overlay: `GtkOverlay` is a container which contains a single main child, on
// top of which it can place overlay widgets.
// 
// !An example GtkOverlay (overlay.png)
// 
// The position of each overlay widget is determined by its
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties.
// E.g. a widget with both alignments set to GTK_ALIGN_START will be placed at
// the top left corner of the `GtkOverlay` container, whereas an overlay with
// halign set to GTK_ALIGN_CENTER and valign set to GTK_ALIGN_END will be placed
// a the bottom edge of the `GtkOverlay`, horizontally centered. The position
// can be adjusted by setting the margin properties of the child to non-zero
// values.
// 
// More complicated placement of overlays is possible by connecting to the
// [signal@Gtk.Overlay::get-child-position] signal.
// 
// An overlays minimum and natural sizes are those of its main child. The sizes
// of overlay children are not considered when measuring these preferred sizes.
// 
// 
// GtkOverlay as GtkBuildable
// 
// The `GtkOverlay` implementation of the `GtkBuildable` interface supports
// placing a child as an overlay by specifying overlay as the type attribute
// of a `<child>` element.
// 
// 
// CSS nodes
// 
// `GtkOverlay` has a single CSS node with the name overlay. Overlay children
// whose alignments cause them to be positioned at an edge get the style classes
// .left, .right, .top, and/or .bottom according to their position.
	type Overlay struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// OverlayClass is an interface that the Overlay class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type OverlayClass interface {
		gextras.Objector
		_overlay()
	}

	func (Overlay) _overlay() {}

	
	func marshalOverlay(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapOverlay(obj), nil
	}
	

	
	// NewOverlay creates a new `GtkOverlay`.
	func NewOverlay() Overlay {
var _cret *C.GtkWidget // in

_cret = C.gtk_overlay_new()


var _overlay Overlay // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_overlay = Overlay{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _overlay
}
	

	
	// AddOverlay adds @widget to @overlay.
// 
// The widget will be stacked on top of the main widget added with
// [method@Gtk.Overlay.set_child].
// 
// The position at which @widget is placed is determined from its
// [property@Gtk.Widget:halign] and [property@Gtk.Widget:valign] properties.
	func (o Overlay) AddOverlay(widget WidgetClass)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_overlay_add_overlay(_arg0, _arg1)
}
	
	// Child gets the child widget of @overlay.
	func (o Overlay) Child() Widget {
var _arg0 *C.GtkOverlay // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))

_cret = C.gtk_overlay_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ClipOverlay gets whether @widget should be clipped within the parent.
	func (o Overlay) ClipOverlay(widget WidgetClass) bool {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_overlay_get_clip_overlay(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MeasureOverlay gets whether @widget's size is included in the measurement of
// @overlay.
	func (o Overlay) MeasureOverlay(widget WidgetClass) bool {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_overlay_get_measure_overlay(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveOverlay removes an overlay that was added with
// gtk_overlay_add_overlay().
	func (o Overlay) RemoveOverlay(widget WidgetClass)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_overlay_remove_overlay(_arg0, _arg1)
}
	
	// SetChild sets the child widget of @overlay.
	func (o Overlay) SetChild(child WidgetClass)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_overlay_set_child(_arg0, _arg1)
}
	
	// SetClipOverlay sets whether @widget should be clipped within the parent.
	func (o Overlay) SetClipOverlay(widget WidgetClass, clipOverlay bool)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
if clipOverlay { _arg2 = C.TRUE }

C.gtk_overlay_set_clip_overlay(_arg0, _arg1, _arg2)
}
	
	// SetMeasureOverlay sets whether @widget is included in the measured size of
// @overlay.
// 
// The overlay will request the size of the largest child that has this property
// set to true. Children who are not included may be drawn outside of @overlay's
// allocation if they are too large.
	func (o Overlay) SetMeasureOverlay(widget WidgetClass, measure bool)  {
var _arg0 *C.GtkOverlay // out
var _arg1 *C.GtkWidget // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkOverlay)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
if measure { _arg2 = C.TRUE }

C.gtk_overlay_set_measure_overlay(_arg0, _arg1, _arg2)
}
	


	// OverlayLayout: `GtkOverlayLayout` is the layout manager used by `GtkOverlay`.
// 
// It places widgets as overlays on top of the main child.
// 
// This is not a reusable layout manager, since it expects its widget to be a
// `GtkOverlay`. It only listed here so that its layout properties get
// documented.
	type OverlayLayout struct {
		LayoutManager
		
	}

	// OverlayLayoutClass is an interface that the OverlayLayout class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type OverlayLayoutClass interface {
		gextras.Objector
		_overlayLayout()
	}

	func (OverlayLayout) _overlayLayout() {}

	
	func marshalOverlayLayout(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapOverlayLayout(obj), nil
	}
	

	
	// NewOverlayLayout creates a new `GtkOverlayLayout` instance.
	func NewOverlayLayout() OverlayLayout {
var _cret *C.GtkLayoutManager // in

_cret = C.gtk_overlay_layout_new()


var _overlayLayout OverlayLayout // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_overlayLayout = OverlayLayout{
LayoutManager: LayoutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _overlayLayout
}
	

	


	// OverlayLayoutChild: `GtkLayoutChild` subclass for children in a
// `GtkOverlayLayout`.
	type OverlayLayoutChild struct {
		LayoutChild
		
	}

	// OverlayLayoutChildClass is an interface that the OverlayLayoutChild class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type OverlayLayoutChildClass interface {
		gextras.Objector
		_overlayLayoutChild()
	}

	func (OverlayLayoutChild) _overlayLayoutChild() {}

	
	func marshalOverlayLayoutChild(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapOverlayLayoutChild(obj), nil
	}
	

	

	
	// ClipOverlay retrieves whether the child is clipped.
	func (c OverlayLayoutChild) ClipOverlay() bool {
var _arg0 *C.GtkOverlayLayoutChild // out
var _cret C.gboolean // in

_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_overlay_layout_child_get_clip_overlay(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Measure retrieves whether the child is measured.
	func (c OverlayLayoutChild) Measure() bool {
var _arg0 *C.GtkOverlayLayoutChild // out
var _cret C.gboolean // in

_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))

_cret = C.gtk_overlay_layout_child_get_measure(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetClipOverlay sets whether to clip this child.
	func (c OverlayLayoutChild) SetClipOverlay(clipOverlay bool)  {
var _arg0 *C.GtkOverlayLayoutChild // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))
if clipOverlay { _arg1 = C.TRUE }

C.gtk_overlay_layout_child_set_clip_overlay(_arg0, _arg1)
}
	
	// SetMeasure sets whether to measure this child.
	func (c OverlayLayoutChild) SetMeasure(measure bool)  {
var _arg0 *C.GtkOverlayLayoutChild // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkOverlayLayoutChild)(unsafe.Pointer(c.Native()))
if measure { _arg1 = C.TRUE }

C.gtk_overlay_layout_child_set_measure(_arg0, _arg1)
}
	


	// PadController: `GtkPadController` is an event controller for the pads found
// in drawing tablets.
// 
// Pads are the collection of buttons and tactile sensors often found around the
// stylus-sensitive area.
// 
// These buttons and sensors have no implicit meaning, and by default they
// perform no action. `GtkPadController` is provided to map those to `GAction`
// objects, thus letting the application give them a more semantic meaning.
// 
// Buttons and sensors are not constrained to triggering a single action, some
// GDK_SOURCE_TABLET_PAD devices feature multiple "modes". All these input
// elements have one current mode, which may determine the final action being
// triggered.
// 
// Pad devices often divide buttons and sensors into groups. All elements in a
// group share the same current mode, but different groups may have different
// modes. See [method@Gdk.DevicePad.get_n_groups] and
// [method@Gdk.DevicePad.get_group_n_modes].
// 
// Each of the actions that a given button/strip/ring performs for a given mode
// is defined by a [struct@Gtk.PadActionEntry]. It contains an action name that
// will be looked up in the given `GActionGroup` and activated whenever the
// specified input element and mode are triggered.
// 
// A simple example of `GtkPadController` usage: Assigning button 1 in all modes
// and pad devices to an "invert-selection" action:
// 
// `c GtkPadActionEntry *pad_actions[] = { { GTK_PAD_ACTION_BUTTON, 1, -1,
// "Invert selection", "pad-actions.invert-selection" },  };
// 
//  action_group = g_simple_action_group_new (); action = g_simple_action_new
// ("pad-actions.invert-selection", NULL); g_signal_connect (action, "activate",
// on_invert_selection_activated, NULL); g_action_map_add_action (G_ACTION_MAP
// (action_group), action);  pad_controller = gtk_pad_controller_new
// (action_group, NULL); `
// 
// The actions belonging to rings/strips will be activated with a parameter of
// type G_VARIANT_TYPE_DOUBLE bearing the value of the given axis, it is
// required that those are made stateful and accepting this `GVariantType`.
	type PadController struct {
		EventController
		
	}

	// PadControllerClass is an interface that the PadController class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PadControllerClass interface {
		gextras.Objector
		_padController()
	}

	func (PadController) _padController() {}

	
	func marshalPadController(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPadController(obj), nil
	}
	

	
	// NewPadController creates a new `GtkPadController` that will associate events
// from @pad to actions.
// 
// A nil pad may be provided so the controller manages all pad devices
// generically, it is discouraged to mix `GtkPadController` objects with nil and
// non-nil @pad argument on the same toplevel window, as execution order is not
// guaranteed.
// 
// The `GtkPadController` is created with no mapped actions. In order to map pad
// events to actions, use [method@Gtk.PadController.set_action_entries] or
// [method@Gtk.PadController.set_action].
// 
// Be aware that pad events will only be delivered to `GtkWindow`s, so adding a
// pad controller to any other type of widget will not have an effect.
	func NewPadController(group gio.ActionGroup, pad gdk.DeviceClass) PadController {
var _arg1 *C.GActionGroup // out
var _arg2 *C.GdkDevice // out
var _cret *C.GtkPadController // in

_arg1 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))
_arg2 = (*C.GdkDevice)(unsafe.Pointer(pad.Native()))

_cret = C.gtk_pad_controller_new(_arg1, _arg2)


var _padController PadController // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_padController = PadController{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _padController
}
	

	
	// SetAction adds an individual action to @controller.
// 
// This action will only be activated if the given button/ring/strip number in
// @index is interacted while the current mode is @mode. -1 may be used for
// simple cases, so the action is triggered on all modes.
// 
// The given @label should be considered user-visible, so internationalization
// rules apply. Some windowing systems may be able to use those for user
// feedback.
	func (c PadController) SetAction(typ PadActionType, index int, mode int, label string, actionName string)  {
var _arg0 *C.GtkPadController // out
var _arg1 C.GtkPadActionType // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 *C.char // out
var _arg5 *C.char // out

_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkPadActionType)(typ)
_arg2 = (C.int)(index)
_arg3 = (C.int)(mode)
_arg4 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg4))
_arg5 = (*C.char)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg5))

C.gtk_pad_controller_set_action(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// SetActionEntries: a convenience function to add a group of action entries on
// @controller.
// 
// See [struct@Gtk.PadActionEntry] and [method@Gtk.PadController.set_action].
	func (c PadController) SetActionEntries(entries []PadActionEntry)  {
var _arg0 *C.GtkPadController // out
var _arg1 *C.GtkPadActionEntry
var _arg2 C.int

_arg0 = (*C.GtkPadController)(unsafe.Pointer(c.Native()))
_arg2 = C.int(len(entries))
_arg1 = (*C.GtkPadActionEntry)(unsafe.Pointer(&entries[0]))

C.gtk_pad_controller_set_action_entries(_arg0, _arg1, _arg2)
}
	


	// PageSetup: a `GtkPageSetup` object stores the page size, orientation and
// margins.
// 
// The idea is that you can get one of these from the page setup dialog and then
// pass it to the `GtkPrintOperation` when printing. The benefit of splitting
// this out of the `GtkPrintSettings` is that these affect the actual layout of
// the page, and thus need to be set long before user prints.
// 
// 
// Margins
// 
// The margins specified in this object are the print margins, i.e. the parts
// of the page that the printer cannot print on. These are different from the
// layout margins that a word processor uses; they are typically used to
// determine the minimal size for the layout margins.
// 
// To obtain a `GtkPageSetup` use [ctor@Gtk.PageSetup.new] to get the defaults,
// or use [func@Gtk.print_run_page_setup_dialog] to show the page setup dialog
// and receive the resulting page setup.
// 
// 
// A page setup dialog
// 
// `c static GtkPrintSettings *settings = NULL; static GtkPageSetup *page_setup
// = NULL;
// 
// static void do_page_setup (void) { GtkPageSetup *new_page_setup;
// 
//    if (settings == NULL)
//      settings = gtk_print_settings_new ();
// 
//    new_page_setup = gtk_print_run_page_setup_dialog (GTK_WINDOW (main_window),
//                                                      page_setup, settings);
// 
//    if (page_setup)
//      g_object_unref (page_setup);
// 
//    page_setup = new_page_setup;
// 
// } `
	type PageSetup struct {
		**externglib.Object
		
	}

	// PageSetupClass is an interface that the PageSetup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PageSetupClass interface {
		gextras.Objector
		_pageSetup()
	}

	func (PageSetup) _pageSetup() {}

	
	func marshalPageSetup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPageSetup(obj), nil
	}
	

	
	// NewPageSetup creates a new `GtkPageSetup`.
	func NewPageSetup() PageSetup {
var _cret *C.GtkPageSetup // in

_cret = C.gtk_page_setup_new()


var _pageSetup PageSetup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _pageSetup
}
	
	// NewPageSetupFromFile reads the page setup from the file @file_name.
// 
// Returns a new `GtkPageSetup` object with the restored page setup, or nil if
// an error occurred. See [method@Gtk.PageSetup.to_file].
	func NewPageSetupFromFile(fileName string) (PageSetup, error) {
var _arg1 *C.char // out
var _cret *C.GtkPageSetup // in
var _cerr *C.GError // in

_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_page_setup_new_from_file(_arg1, &_cerr)


var _pageSetup PageSetup // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pageSetup, _goerr
}
	
	// NewPageSetupFromGVariant: desrialize a page setup from an a{sv} variant.
// 
// The variant must be in the format produced by
// [method@Gtk.PageSetup.to_gvariant].
	func NewPageSetupFromGVariant(variant *glib.Variant) PageSetup {
var _arg1 *C.GVariant // out
var _cret *C.GtkPageSetup // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_page_setup_new_from_gvariant(_arg1)


var _pageSetup PageSetup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _pageSetup
}
	
	// NewPageSetupFromKeyFile reads the page setup from the group @group_name in
// the key file @key_file.
// 
// Returns a new `GtkPageSetup` object with the restored page setup, or nil if
// an error occurred.
	func NewPageSetupFromKeyFile(keyFile *glib.KeyFile, groupName string) (PageSetup, error) {
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out
var _cret *C.GtkPageSetup // in
var _cerr *C.GError // in

_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_page_setup_new_from_key_file(_arg1, _arg2, &_cerr)


var _pageSetup PageSetup // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_pageSetup = PageSetup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _pageSetup, _goerr
}
	

	
	// Copy copies a `GtkPageSetup`.
	func (o PageSetup) Copy() PageSetup {
var _arg0 *C.GtkPageSetup // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(o.Native()))

_cret = C.gtk_page_setup_copy(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// BottomMargin gets the bottom margin in units of @unit.
	func (s PageSetup) BottomMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_bottom_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// LeftMargin gets the left margin in units of @unit.
	func (s PageSetup) LeftMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_left_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Orientation gets the page orientation of the `GtkPageSetup`.
	func (s PageSetup) Orientation() PageOrientation {
var _arg0 *C.GtkPageSetup // out
var _cret C.GtkPageOrientation // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_page_setup_get_orientation(_arg0)


var _pageOrientation PageOrientation // out

_pageOrientation = PageOrientation(_cret)

return _pageOrientation
}
	
	// PageHeight returns the page height in units of @unit.
// 
// Note that this function takes orientation and margins into consideration. See
// [method@Gtk.PageSetup.get_paper_height].
	func (s PageSetup) PageHeight(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_page_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageWidth returns the page width in units of @unit.
// 
// Note that this function takes orientation and margins into consideration. See
// [method@Gtk.PageSetup.get_paper_width].
	func (s PageSetup) PageWidth(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_page_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PaperHeight returns the paper height in units of @unit.
// 
// Note that this function takes orientation, but not margins into
// consideration. See [method@Gtk.PageSetup.get_page_height].
	func (s PageSetup) PaperHeight(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_paper_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PaperSize gets the paper size of the `GtkPageSetup`.
	func (s PageSetup) PaperSize() *PaperSize {
var _arg0 *C.GtkPageSetup // out
var _cret *C.GtkPaperSize // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_page_setup_get_paper_size(_arg0)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))

return _paperSize
}
	
	// PaperWidth returns the paper width in units of @unit.
// 
// Note that this function takes orientation, but not margins into
// consideration. See [method@Gtk.PageSetup.get_page_width].
	func (s PageSetup) PaperWidth(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_paper_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// RightMargin gets the right margin in units of @unit.
	func (s PageSetup) RightMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_right_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// TopMargin gets the top margin in units of @unit.
	func (s PageSetup) TopMargin(unit Unit) float64 {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_page_setup_get_top_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// LoadFile reads the page setup from the file @file_name.
// 
// See [method@Gtk.PageSetup.to_file].
	func (s PageSetup) LoadFile(fileName string) error {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_page_setup_load_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LoadKeyFile reads the page setup from the group @group_name in the key file
// @key_file.
	func (s PageSetup) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_page_setup_load_key_file(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetBottomMargin sets the bottom margin of the `GtkPageSetup`.
	func (s PageSetup) SetBottomMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.double // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_bottom_margin(_arg0, _arg1, _arg2)
}
	
	// SetLeftMargin sets the left margin of the `GtkPageSetup`.
	func (s PageSetup) SetLeftMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.double // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_left_margin(_arg0, _arg1, _arg2)
}
	
	// SetOrientation sets the page orientation of the `GtkPageSetup`.
	func (s PageSetup) SetOrientation(orientation PageOrientation)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.GtkPageOrientation // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPageOrientation)(orientation)

C.gtk_page_setup_set_orientation(_arg0, _arg1)
}
	
	// SetPaperSize sets the paper size of the `GtkPageSetup` without changing the
// margins.
// 
// See [method@Gtk.PageSetup.set_paper_size_and_default_margins].
	func (s PageSetup) SetPaperSize(size *PaperSize)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GtkPaperSize // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

C.gtk_page_setup_set_paper_size(_arg0, _arg1)
}
	
	// SetPaperSizeAndDefaultMargins sets the paper size of the `GtkPageSetup` and
// modifies the margins according to the new paper size.
	func (s PageSetup) SetPaperSizeAndDefaultMargins(size *PaperSize)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GtkPaperSize // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size.Native()))

C.gtk_page_setup_set_paper_size_and_default_margins(_arg0, _arg1)
}
	
	// SetRightMargin sets the right margin of the `GtkPageSetup`.
	func (s PageSetup) SetRightMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.double // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_right_margin(_arg0, _arg1, _arg2)
}
	
	// SetTopMargin sets the top margin of the `GtkPageSetup`.
	func (s PageSetup) SetTopMargin(margin float64, unit Unit)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 C.double // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(margin)
_arg2 = (C.GtkUnit)(unit)

C.gtk_page_setup_set_top_margin(_arg0, _arg1, _arg2)
}
	
	// ToFile: this function saves the information from @setup to @file_name.
	func (s PageSetup) ToFile(fileName string) error {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_page_setup_to_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ToGVariant: serialize page setup to an a{sv} variant.
	func (s PageSetup) ToGVariant() *glib.Variant {
var _arg0 *C.GtkPageSetup // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_page_setup_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// ToKeyFile: this function adds the page setup from @setup to @key_file.
	func (s PageSetup) ToKeyFile(keyFile *glib.KeyFile, groupName string)  {
var _arg0 *C.GtkPageSetup // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out

_arg0 = (*C.GtkPageSetup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_page_setup_to_key_file(_arg0, _arg1, _arg2)
}
	


	// PageSetupUnixDialog: `GtkPageSetupUnixDialog` implements a page setup dialog
// for platforms which dont provide a native page setup dialog, like Unix.
// 
// !An example GtkPageSetupUnixDialog (pagesetupdialog.png)
// 
// It can be used very much like any other GTK dialog, at the cost of the
// portability offered by the high-level printing API in
// [class@Gtk.PrintOperation].
	type PageSetupUnixDialog struct {
		Dialog
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// PageSetupUnixDialogClass is an interface that the PageSetupUnixDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PageSetupUnixDialogClass interface {
		gextras.Objector
		_pageSetupUnixDialog()
	}

	func (PageSetupUnixDialog) _pageSetupUnixDialog() {}

	
	func marshalPageSetupUnixDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPageSetupUnixDialog(obj), nil
	}
	

	
	// NewPageSetupUnixDialog creates a new page setup dialog.
	func NewPageSetupUnixDialog(title string, parent WindowClass) PageSetupUnixDialog {
var _arg1 *C.char // out
var _arg2 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_page_setup_unix_dialog_new(_arg1, _arg2)


var _pageSetupUnixDialog PageSetupUnixDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_pageSetupUnixDialog = PageSetupUnixDialog{
Dialog: Dialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _pageSetupUnixDialog
}
	

	
	// PageSetup gets the currently selected page setup from the dialog.
	func (d PageSetupUnixDialog) PageSetup() PageSetup {
var _arg0 *C.GtkPageSetupUnixDialog // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_page_setup_unix_dialog_get_page_setup(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// PrintSettings gets the current print settings from the dialog.
	func (d PageSetupUnixDialog) PrintSettings() PrintSettings {
var _arg0 *C.GtkPageSetupUnixDialog // out
var _cret *C.GtkPrintSettings // in

_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_page_setup_unix_dialog_get_print_settings(_arg0)


var _printSettings PrintSettings // out

_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

return _printSettings
}
	
	// SetPageSetup sets the `GtkPageSetup` from which the page setup dialog takes
// its values.
	func (d PageSetupUnixDialog) SetPageSetup(pageSetup PageSetupClass)  {
var _arg0 *C.GtkPageSetupUnixDialog // out
var _arg1 *C.GtkPageSetup // out

_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

C.gtk_page_setup_unix_dialog_set_page_setup(_arg0, _arg1)
}
	
	// SetPrintSettings sets the `GtkPrintSettings` from which the page setup dialog
// takes its values.
	func (d PageSetupUnixDialog) SetPrintSettings(printSettings PrintSettingsClass)  {
var _arg0 *C.GtkPageSetupUnixDialog // out
var _arg1 *C.GtkPrintSettings // out

_arg0 = (*C.GtkPageSetupUnixDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

C.gtk_page_setup_unix_dialog_set_print_settings(_arg0, _arg1)
}
	


	// Paned: `GtkPaned` has two panes, arranged either horizontally or vertically.
// 
// !An example GtkPaned (panes.png)
// 
// The division between the two panes is adjustable by the user by dragging a
// handle.
// 
// Child widgets are added to the panes of the widget with
// [method@Gtk.Paned.set_start_child] and [method@Gtk.Paned.set_end_child]. The
// division between the two children is set by default from the size requests of
// the children, but it can be adjusted by the user.
// 
// A paned widget draws a separator between the two child widgets and a small
// handle that the user can drag to adjust the division. It does not draw any
// relief around the children or around the separator. (The space in which the
// separator is called the gutter.) Often, it is useful to put each child inside
// a [class@Gtk.Frame] so that the gutter appears as a ridge. No separator is
// drawn if one of the children is missing.
// 
// Each child has two options that can be set, @resize and @shrink. If @resize
// is true, then when the `GtkPaned` is resized, that child will expand or
// shrink along with the paned widget. If @shrink is true, then that child can
// be made smaller than its requisition by the user. Setting @shrink to false
// allows the application to set a minimum size. If @resize is false for both
// children, then this is treated as if @resize is true for both children.
// 
// The application can set the position of the slider as if it were set by the
// user, by calling [method@Gtk.Paned.set_position].
// 
// 
// CSS nodes
// 
// ` paned  <child>  separator[.wide]  <child> `
// 
// `GtkPaned` has a main CSS node with name paned, and a subnode for the
// separator with name separator. The subnode gets a .wide style class when the
// paned is supposed to be wide.
// 
// In horizontal orientation, the nodes are arranged based on the text
// direction, so in left-to-right mode, :first-child will select the leftmost
// child, while it will select the rightmost child in RTL layouts.
// 
// Creating a paned widget with minimum sizes.
// 
// `c GtkWidget *hpaned = gtk_paned_new (GTK_ORIENTATION_HORIZONTAL); GtkWidget
// *frame1 = gtk_frame_new (NULL); GtkWidget *frame2 = gtk_frame_new (NULL);
// 
// gtk_widget_set_size_request (hpaned, 200, -1);
// 
// gtk_paned_set_start_child (GTK_PANED (hpaned), frame1);
// gtk_paned_set_start_child_resize (GTK_PANED (hpaned), TRUE);
// gtk_paned_set_start_child_shrink (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame1, 50, -1);
// 
// gtk_paned_set_end_child (GTK_PANED (hpaned), frame2);
// gtk_paned_set_end_child_resize (GTK_PANED (hpaned), FALSE);
// gtk_paned_set_end_child_shrink (GTK_PANED (hpaned), FALSE);
// gtk_widget_set_size_request (frame2, 50, -1); `
	type Paned struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// PanedClass is an interface that the Paned class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PanedClass interface {
		gextras.Objector
		_paned()
	}

	func (Paned) _paned() {}

	
	func marshalPaned(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPaned(obj), nil
	}
	

	
	// NewPaned creates a new `GtkPaned` widget.
	func NewPaned(orientation Orientation) Paned {
var _arg1 C.GtkOrientation // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_paned_new(_arg1)


var _paned Paned // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_paned = Paned{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _paned
}
	

	
	// EndChild retrieves the end child of the given `GtkPaned`.
// 
// See also: `GtkPaned`:end-child
	func (p Paned) EndChild() Widget {
var _arg0 *C.GtkPaned // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_end_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Position obtains the position of the divider between the two panes.
	func (p Paned) Position() int {
var _arg0 *C.GtkPaned // out
var _cret C.int // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_position(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ResizeEndChild returns whether the end child can be resized.
	func (p Paned) ResizeEndChild() bool {
var _arg0 *C.GtkPaned // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_resize_end_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ResizeStartChild returns whether the start child can be resized.
	func (p Paned) ResizeStartChild() bool {
var _arg0 *C.GtkPaned // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_resize_start_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShrinkEndChild returns whether the end child can be shrunk.
	func (p Paned) ShrinkEndChild() bool {
var _arg0 *C.GtkPaned // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_shrink_end_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShrinkStartChild returns whether the start child can be shrunk.
	func (p Paned) ShrinkStartChild() bool {
var _arg0 *C.GtkPaned // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_shrink_start_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartChild retrieves the start child of the given `GtkPaned`.
// 
// See also: `GtkPaned`:start-child
	func (p Paned) StartChild() Widget {
var _arg0 *C.GtkPaned // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_start_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// WideHandle gets whether the separator should be wide.
	func (p Paned) WideHandle() bool {
var _arg0 *C.GtkPaned // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paned_get_wide_handle(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetEndChild sets the end child of @paned to @child.
	func (p Paned) SetEndChild(child WidgetClass)  {
var _arg0 *C.GtkPaned // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_paned_set_end_child(_arg0, _arg1)
}
	
	// SetPosition sets the position of the divider between the two panes.
	func (p Paned) SetPosition(position int)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.int // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (C.int)(position)

C.gtk_paned_set_position(_arg0, _arg1)
}
	
	// SetResizeEndChild sets the `GtkPaned`:resize-end-child property
	func (p Paned) SetResizeEndChild(resize bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
if resize { _arg1 = C.TRUE }

C.gtk_paned_set_resize_end_child(_arg0, _arg1)
}
	
	// SetResizeStartChild sets the `GtkPaned`:resize-start-child property
	func (p Paned) SetResizeStartChild(resize bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
if resize { _arg1 = C.TRUE }

C.gtk_paned_set_resize_start_child(_arg0, _arg1)
}
	
	// SetShrinkEndChild sets the `GtkPaned`:shrink-end-child property
	func (p Paned) SetShrinkEndChild(resize bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
if resize { _arg1 = C.TRUE }

C.gtk_paned_set_shrink_end_child(_arg0, _arg1)
}
	
	// SetShrinkStartChild sets the `GtkPaned`:shrink-start-child property
	func (p Paned) SetShrinkStartChild(resize bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
if resize { _arg1 = C.TRUE }

C.gtk_paned_set_shrink_start_child(_arg0, _arg1)
}
	
	// SetStartChild sets the start child of @paned to @child.
	func (p Paned) SetStartChild(child WidgetClass)  {
var _arg0 *C.GtkPaned // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_paned_set_start_child(_arg0, _arg1)
}
	
	// SetWideHandle sets whether the separator should be wide.
	func (p Paned) SetWideHandle(wide bool)  {
var _arg0 *C.GtkPaned // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPaned)(unsafe.Pointer(p.Native()))
if wide { _arg1 = C.TRUE }

C.gtk_paned_set_wide_handle(_arg0, _arg1)
}
	


	// PasswordEntry: `GtkPasswordEntry` is an entry that has been tailored for
// entering secrets.
// 
// !An example GtkPasswordEntry (password-entry.png)
// 
// It does not show its contents in clear text, does not allow to copy it to the
// clipboard, and it shows a warning when Caps Lock is engaged. If the
// underlying platform allows it, `GtkPasswordEntry` will also place the text in
// a non-pageable memory area, to avoid it being written out to disk by the
// operating system.
// 
// Optionally, it can offer a way to reveal the contents in clear text.
// 
// `GtkPasswordEntry` provides only minimal API and should be used with the
// [iface@Gtk.Editable] API.
// 
// 
// CSS Nodes
// 
// ` entry.password  text  image.caps-lock-indicator  `
// 
// `GtkPasswordEntry` has a single CSS node with name entry that carries a
// .passwordstyle class. The text Css node below it has a child with name image
// and style class .caps-lock-indicator for the Caps Lock icon, and possibly
// other children.
// 
// 
// Accessibility
// 
// `GtkPasswordEntry` uses the GTK_ACCESSIBLE_ROLE_TEXT_BOX role.
	type PasswordEntry struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Editable
		
	}

	// PasswordEntryClass is an interface that the PasswordEntry class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PasswordEntryClass interface {
		gextras.Objector
		_passwordEntry()
	}

	func (PasswordEntry) _passwordEntry() {}

	
	func marshalPasswordEntry(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPasswordEntry(obj), nil
	}
	

	
	// NewPasswordEntry creates a `GtkPasswordEntry`.
	func NewPasswordEntry() PasswordEntry {
var _cret *C.GtkWidget // in

_cret = C.gtk_password_entry_new()


var _passwordEntry PasswordEntry // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_passwordEntry = PasswordEntry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _passwordEntry
}
	

	
	// ExtraMenu gets the menu model set with gtk_password_entry_set_extra_menu().
	func (e PasswordEntry) ExtraMenu() gio.MenuModel {
var _arg0 *C.GtkPasswordEntry // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_password_entry_get_extra_menu(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// ShowPeekIcon returns whether the entry is showing an icon to reveal the
// contents.
	func (e PasswordEntry) ShowPeekIcon() bool {
var _arg0 *C.GtkPasswordEntry // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_password_entry_get_show_peek_icon(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetExtraMenu sets a menu model to add when constructing the context menu for
// @entry.
	func (e PasswordEntry) SetExtraMenu(model gio.MenuModelClass)  {
var _arg0 *C.GtkPasswordEntry // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.gtk_password_entry_set_extra_menu(_arg0, _arg1)
}
	
	// SetShowPeekIcon sets whether the entry should have a clickable icon to reveal
// the contents.
// 
// Setting this to false also hides the text again.
	func (e PasswordEntry) SetShowPeekIcon(showPeekIcon bool)  {
var _arg0 *C.GtkPasswordEntry // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPasswordEntry)(unsafe.Pointer(e.Native()))
if showPeekIcon { _arg1 = C.TRUE }

C.gtk_password_entry_set_show_peek_icon(_arg0, _arg1)
}
	


	// Picture: the `GtkPicture` widget displays a `GdkPaintable`.
// 
// !An example GtkPicture (picture.png)
// 
// Many convenience functions are provided to make pictures simple to use. For
// example, if you want to load an image from a file, and then display it,
// theres a convenience function to do this:
// 
// `c GtkWidget *widget = gtk_picture_new_for_filename ("myfile.png"); `
// 
// If the file isnt loaded successfully, the picture will contain a broken
// image icon similar to that used in many web browsers. If you want to handle
// errors in loading the file yourself, for example by displaying an error
// message, then load the image with [ctor@Gdk.Texture.new_from_file], then
// create the `GtkPicture` with [ctor@Gtk.Picture.new_for_paintable].
// 
// Sometimes an application will want to avoid depending on external data files,
// such as image files. See the documentation of `GResource` for details. In
// this case, [ctor@Gtk.Picture.new_for_resource] and
// [method@Gtk.Picture.set_resource] should be used.
// 
// `GtkPicture` displays an image at its natural size. See [class@Gtk.Image] if
// you want to display a fixed-size image, such as an icon.
// 
// 
// Sizing the paintable
// 
// You can influence how the paintable is displayed inside the `GtkPicture`. By
// turning off [property@Gtk.Picture:keep-aspect-ratio] you can allow the
// paintable to get stretched. [property@Gtk.Picture:can-shrink] can be unset to
// make sure that paintables are never made smaller than their ideal size - but
// be careful if you do not know the size of the paintable in use (like when
// displaying user-loaded images). This can easily cause the picture to grow
// larger than the screen. And [property@GtkWidget:halign] and
// [property@GtkWidget:valign] can be used to make sure the paintable doesn't
// fill all available space but is instead displayed at its original size.
// 
// 
// CSS nodes
// 
// `GtkPicture` has a single CSS node with the name `picture`.
// 
// 
// Accessibility
// 
// `GtkPicture` uses the `GTK_ACCESSIBLE_ROLE_IMG` role.
	type Picture struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// PictureClass is an interface that the Picture class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PictureClass interface {
		gextras.Objector
		_picture()
	}

	func (Picture) _picture() {}

	
	func marshalPicture(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPicture(obj), nil
	}
	

	
	// NewPicture creates a new empty `GtkPicture` widget.
	func NewPicture() Picture {
var _cret *C.GtkWidget // in

_cret = C.gtk_picture_new()


var _picture Picture // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_picture = Picture{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _picture
}
	
	// NewPictureForFile creates a new `GtkPicture` displaying the given @file.
// 
// If the file isnt found or cant be loaded, the resulting `GtkPicture` is
// empty.
// 
// If you need to detect failures to load the file, use
// [ctor@Gdk.Texture.new_from_file] to load the file yourself, then create the
// `GtkPicture` from the texture.
	func NewPictureForFile(file gio.File) Picture {
var _arg1 *C.GFile // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

_cret = C.gtk_picture_new_for_file(_arg1)


var _picture Picture // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_picture = Picture{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _picture
}
	
	// NewPictureForFilename creates a new `GtkPicture` displaying the file
// @filename.
// 
// This is a utility function that calls [ctor@Gtk.Picture.new_for_file]. See
// that function for details.
	func NewPictureForFilename(filename string) Picture {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_picture_new_for_filename(_arg1)


var _picture Picture // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_picture = Picture{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _picture
}
	
	// NewPictureForPaintable creates a new `GtkPicture` displaying @paintable.
// 
// The `GtkPicture` will track changes to the @paintable and update its size and
// contents in response to it.
	func NewPictureForPaintable(paintable gdk.Paintable) Picture {
var _arg1 *C.GdkPaintable // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

_cret = C.gtk_picture_new_for_paintable(_arg1)


var _picture Picture // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_picture = Picture{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _picture
}
	
	// NewPictureForPixbuf creates a new `GtkPicture` displaying @pixbuf.
// 
// This is a utility function that calls [ctor@Gtk.Picture.new_for_paintable],
// See that function for details.
// 
// The pixbuf must not be modified after passing it to this function.
	func NewPictureForPixbuf(pixbuf gdkpixbuf.PixbufClass) Picture {
var _arg1 *C.GdkPixbuf // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

_cret = C.gtk_picture_new_for_pixbuf(_arg1)


var _picture Picture // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_picture = Picture{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _picture
}
	
	// NewPictureForResource creates a new `GtkPicture` displaying the resource at
// @resource_path.
// 
// This is a utility function that calls [ctor@Gtk.Picture.new_for_file]. See
// that function for details.
	func NewPictureForResource(resourcePath string) Picture {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_picture_new_for_resource(_arg1)


var _picture Picture // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_picture = Picture{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _picture
}
	

	
	// AlternativeText gets the alternative textual description of the picture.
// 
// The returned string will be nil if the picture cannot be described textually.
	func (s Picture) AlternativeText() string {
var _arg0 *C.GtkPicture // out
var _cret *C.char // in

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

_cret = C.gtk_picture_get_alternative_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// CanShrink returns whether the `GtkPicture` respects its contents size.
	func (s Picture) CanShrink() bool {
var _arg0 *C.GtkPicture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

_cret = C.gtk_picture_get_can_shrink(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// File gets the `GFile` currently displayed if @self is displaying a file.
// 
// If @self is not displaying a file, for example when
// [method@Gtk.Picture.set_paintable] was used, then nil is returned.
	func (s Picture) File() gio.File {
var _arg0 *C.GtkPicture // out
var _cret *C.GFile // in

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

_cret = C.gtk_picture_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// KeepAspectRatio returns whether the `GtkPicture` preserves its contents
// aspect ratio.
	func (s Picture) KeepAspectRatio() bool {
var _arg0 *C.GtkPicture // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

_cret = C.gtk_picture_get_keep_aspect_ratio(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Paintable gets the `GdkPaintable` being displayed by the `GtkPicture`.
	func (s Picture) Paintable() gdk.Paintable {
var _arg0 *C.GtkPicture // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))

_cret = C.gtk_picture_get_paintable(_arg0)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// SetAlternativeText sets an alternative textual description for the picture
// contents.
// 
// It is equivalent to the "alt" attribute for images on websites.
// 
// This text will be made available to accessibility tools.
// 
// If the picture cannot be described textually, set this property to nil.
	func (s Picture) SetAlternativeText(alternativeText string)  {
var _arg0 *C.GtkPicture // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(alternativeText))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_picture_set_alternative_text(_arg0, _arg1)
}
	
	// SetCanShrink: if set to true, the @self can be made smaller than its
// contents.
// 
// The contents will then be scaled down when rendering.
// 
// If you want to still force a minimum size manually, consider using
// [method@Gtk.Widget.set_size_request].
// 
// Also of note is that a similar function for growing does not exist because
// the grow behavior can be controlled via [method@Gtk.Widget.set_halign] and
// [method@Gtk.Widget.set_valign].
	func (s Picture) SetCanShrink(canShrink bool)  {
var _arg0 *C.GtkPicture // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
if canShrink { _arg1 = C.TRUE }

C.gtk_picture_set_can_shrink(_arg0, _arg1)
}
	
	// SetFile makes @self load and display @file.
// 
// See [ctor@Gtk.Picture.new_for_file] for details.
	func (s Picture) SetFile(file gio.File)  {
var _arg0 *C.GtkPicture // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_picture_set_file(_arg0, _arg1)
}
	
	// SetFilename makes @self load and display the given @filename.
// 
// This is a utility function that calls [method@Gtk.Picture.set_file].
	func (s Picture) SetFilename(filename string)  {
var _arg0 *C.GtkPicture // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_picture_set_filename(_arg0, _arg1)
}
	
	// SetKeepAspectRatio: if set to true, the @self will render its contents
// according to their aspect ratio.
// 
// That means that empty space may show up at the top/bottom or left/right of
// @self.
// 
// If set to false or if the contents provide no aspect ratio, the contents will
// be stretched over the picture's whole area.
	func (s Picture) SetKeepAspectRatio(keepAspectRatio bool)  {
var _arg0 *C.GtkPicture // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
if keepAspectRatio { _arg1 = C.TRUE }

C.gtk_picture_set_keep_aspect_ratio(_arg0, _arg1)
}
	
	// SetPaintable makes @self display the given @paintable.
// 
// If @paintable is nil, nothing will be displayed.
// 
// See [ctor@Gtk.Picture.new_for_paintable] for details.
	func (s Picture) SetPaintable(paintable gdk.Paintable)  {
var _arg0 *C.GtkPicture // out
var _arg1 *C.GdkPaintable // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

C.gtk_picture_set_paintable(_arg0, _arg1)
}
	
	// SetPixbuf sets a `GtkPicture` to show a `GdkPixbuf`.
// 
// See [ctor@Gtk.Picture.new_for_pixbuf] for details.
// 
// This is a utility function that calls [method@Gtk.Picture.set_paintable].
	func (s Picture) SetPixbuf(pixbuf gdkpixbuf.PixbufClass)  {
var _arg0 *C.GtkPicture // out
var _arg1 *C.GdkPixbuf // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkPixbuf)(unsafe.Pointer(pixbuf.Native()))

C.gtk_picture_set_pixbuf(_arg0, _arg1)
}
	
	// SetResource makes @self load and display the resource at the given
// @resource_path.
// 
// This is a utility function that calls [method@Gtk.Picture.set_file].
	func (s Picture) SetResource(resourcePath string)  {
var _arg0 *C.GtkPicture // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPicture)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_picture_set_resource(_arg0, _arg1)
}
	


	// Popover: `GtkPopover` is a bubble-like context popup.
// 
// !An example GtkPopover (popover.png)
// 
// It is primarily meant to provide context-dependent information or options.
// Popovers are attached to a parent widget. By default, they point to the whole
// widget area, although this behavior can be changed with
// [method@Gtk.Popover.set_pointing_to].
// 
// The position of a popover relative to the widget it is attached to can also
// be changed with [method@Gtk.Popover.set_position]
// 
// By default, `GtkPopover` performs a grab, in order to ensure input events get
// redirected to it while it is shown, and also so the popover is dismissed in
// the expected situations (clicks outside the popover, or the Escape key being
// pressed). If no such modal behavior is desired on a popover,
// [method@Gtk.Popover.set_autohide] may be called on it to tweak its behavior.
// 
// 
// GtkPopover as menu replacement
// 
// `GtkPopover` is often used to replace menus. The best was to do this is to
// use the [class@Gtk.PopoverMenu] subclass which supports being populated from
// a `GMenuModel` with [ctor@Gtk.PopoverMenu.new_from_model].
// 
// `xml <section> <attribute name="display-hint">horizontal-buttons</attribute>
// <item> <attribute name="label">Cut</attribute> <attribute
// name="action">app.cut</attribute> <attribute
// name="verb-icon">edit-cut-symbolic</attribute> </item> <item> <attribute
// name="label">Copy</attribute> <attribute name="action">app.copy</attribute>
// <attribute name="verb-icon">edit-copy-symbolic</attribute> </item> <item>
// <attribute name="label">Paste</attribute> <attribute
// name="action">app.paste</attribute> <attribute
// name="verb-icon">edit-paste-symbolic</attribute> </item> </section> `
// 
// 
// CSS nodes
// 
// ` popover[.menu]  arrow  contents.background  <child> `
// 
// The contents child node always gets the .background style class and the
// popover itself gets the .menu style class if the popover is menu-like (i.e.
// `GtkPopoverMenu`).
// 
// Particular uses of `GtkPopover`, such as touch selection popups or magnifiers
// in `GtkEntry` or `GtkTextView` get style classes like .touch-selection or
// .magnifier to differentiate from plain popovers.
// 
// When styling a popover directly, the popover node should usually not have any
// background. The visible part of the popover can have a shadow. To specify it
// in CSS, set the box-shadow of the contents node.
// 
// Note that, in order to accomplish appropriate arrow visuals, `GtkPopover`
// uses custom drawing for the arrow node. This makes it possible for the arrow
// to change its shape dynamically, but it also limits the possibilities of
// styling it using CSS. In particular, the arrow gets drawn over the content
// node's border and shadow, so they look like one shape, which means that the
// border width of the content node and the arrow node should be the same. The
// arrow also does not support any border shape other than solid, no
// border-radius, only one border width (border-bottom-width is used) and no
// box-shadow.
	type Popover struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Native
		ShortcutManager
		
	}

	// PopoverClass is an interface that the Popover class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PopoverClass interface {
		gextras.Objector
		_popover()
	}

	func (Popover) _popover() {}

	
	func marshalPopover(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPopover(obj), nil
	}
	

	
	// NewPopover creates a new `GtkPopover`.
	func NewPopover() Popover {
var _cret *C.GtkWidget // in

_cret = C.gtk_popover_new()


var _popover Popover // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_popover = Popover{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _popover
}
	

	
	// Autohide returns whether the popover is modal.
// 
// See [method@Gtk.Popover.set_autohide] for the implications of this.
	func (p Popover) Autohide() bool {
var _arg0 *C.GtkPopover // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_autohide(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CascadePopdown returns whether the popover will close after a modal child is
// closed.
	func (p Popover) CascadePopdown() bool {
var _arg0 *C.GtkPopover // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_cascade_popdown(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Child gets the child widget of @popover.
	func (p Popover) Child() Widget {
var _arg0 *C.GtkPopover // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// HasArrow gets whether this popover is showing an arrow pointing at the widget
// that it is relative to.
	func (p Popover) HasArrow() bool {
var _arg0 *C.GtkPopover // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_has_arrow(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MnemonicsVisible gets whether mnemonics are visible.
	func (p Popover) MnemonicsVisible() bool {
var _arg0 *C.GtkPopover // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_mnemonics_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Offset gets the offset previous set with gtk_popover_set_offset().
	func (p Popover) Offset() (xOffset int, yOffset int) {
var _arg0 *C.GtkPopover // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

C.gtk_popover_get_offset(_arg0, &_arg1, &_arg2)

var _xOffset int // out
var _yOffset int // out

_xOffset = (int)(_arg1)
_yOffset = (int)(_arg2)

return _xOffset, _yOffset
}
	
	// PointingTo gets the rectangle that the popover points to.
// 
// If a rectangle to point to has been set, this function will return true and
// fill in @rect with such rectangle, otherwise it will return false and fill in
// @rect with the parent widget coordinates.
	func (p Popover) PointingTo() (gdk.Rectangle, bool) {
var _arg0 *C.GtkPopover // out
var _rect gdk.Rectangle
var _cret C.gboolean // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_pointing_to(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _rect, _ok
}
	
	// Position returns the preferred position of @popover.
	func (p Popover) Position() PositionType {
var _arg0 *C.GtkPopover // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_get_position(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// Popdown pops @popover down.
// 
// This is different from a [method@Gtk.Widget.hide] call in that it may show
// the popover with a transition. If you want to hide the popover without a
// transition, just use [method@Gtk.Widget.hide].
	func (p Popover) Popdown()  {
var _arg0 *C.GtkPopover // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

C.gtk_popover_popdown(_arg0)
}
	
	// Popup pops @popover up.
// 
// This is different from a [method@Gtk.Widget.show() call in that it may show
// the popover with a transition. If you want to show the popover without a
// transition, just use [method@Gtk.Widget.show].
	func (p Popover) Popup()  {
var _arg0 *C.GtkPopover // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

C.gtk_popover_popup(_arg0)
}
	
	// Present presents the popover to the user.
	func (p Popover) Present()  {
var _arg0 *C.GtkPopover // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))

C.gtk_popover_present(_arg0)
}
	
	// SetAutohide sets whether @popover is modal.
// 
// A modal popover will grab the keyboard focus on it when being displayed.
// Clicking outside the popover area or pressing Esc will dismiss the popover.
// 
// Called this function on an already showing popup with a new autohide value
// different from the current one, will cause the popup to be hidden.
	func (p Popover) SetAutohide(autohide bool)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
if autohide { _arg1 = C.TRUE }

C.gtk_popover_set_autohide(_arg0, _arg1)
}
	
	// SetCascadePopdown: if @cascade_popdown is true, the popover will be closed
// when a child modal popover is closed.
// 
// If false, @popover will stay visible.
	func (p Popover) SetCascadePopdown(cascadePopdown bool)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
if cascadePopdown { _arg1 = C.TRUE }

C.gtk_popover_set_cascade_popdown(_arg0, _arg1)
}
	
	// SetChild sets the child widget of @popover.
	func (p Popover) SetChild(child WidgetClass)  {
var _arg0 *C.GtkPopover // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_popover_set_child(_arg0, _arg1)
}
	
	// SetDefaultWidget sets the default widget of a `GtkPopover`.
// 
// The default widget is the widget thats activated when the user presses Enter
// in a dialog (for example). This function sets or unsets the default widget
// for a `GtkPopover`.
	func (p Popover) SetDefaultWidget(widget WidgetClass)  {
var _arg0 *C.GtkPopover // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_popover_set_default_widget(_arg0, _arg1)
}
	
	// SetHasArrow sets whether this popover should draw an arrow pointing at the
// widget it is relative to.
	func (p Popover) SetHasArrow(hasArrow bool)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
if hasArrow { _arg1 = C.TRUE }

C.gtk_popover_set_has_arrow(_arg0, _arg1)
}
	
	// SetMnemonicsVisible sets whether mnemonics should be visible.
	func (p Popover) SetMnemonicsVisible(mnemonicsVisible bool)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
if mnemonicsVisible { _arg1 = C.TRUE }

C.gtk_popover_set_mnemonics_visible(_arg0, _arg1)
}
	
	// SetOffset sets the offset to use when calculating the position of the
// popover.
// 
// These values are used when preparing the [struct@Gdk.PopupLayout] for
// positioning the popover.
	func (p Popover) SetOffset(xOffset int, yOffset int)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (C.int)(xOffset)
_arg2 = (C.int)(yOffset)

C.gtk_popover_set_offset(_arg0, _arg1, _arg2)
}
	
	// SetPointingTo sets the rectangle that @popover points to.
// 
// This is in the coordinate space of the @popover parent.
	func (p Popover) SetPointingTo(rect *gdk.Rectangle)  {
var _arg0 *C.GtkPopover // out
var _arg1 *C.GdkRectangle // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

C.gtk_popover_set_pointing_to(_arg0, _arg1)
}
	
	// SetPosition sets the preferred position for @popover to appear.
// 
// If the @popover is currently visible, it will be immediately updated.
// 
// This preference will be respected where possible, although on lack of space
// (eg. if close to the window edges), the `GtkPopover` may choose to appear on
// the opposite side.
	func (p Popover) SetPosition(position PositionType)  {
var _arg0 *C.GtkPopover // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkPopover)(unsafe.Pointer(p.Native()))
_arg1 = (C.GtkPositionType)(position)

C.gtk_popover_set_position(_arg0, _arg1)
}
	


	// PopoverMenu: `GtkPopoverMenu` is a subclass of `GtkPopover` that implements
// menu behavior.
// 
// !An example GtkPopoverMenu (menu.png)
// 
// `GtkPopoverMenu` treats its children like menus and allows switching between
// them. It can open submenus as traditional, nested submenus, or in a more
// touch-friendly sliding fashion.
// 
// `GtkPopoverMenu` is meant to be used primarily with menu models, using
// [ctor@Gtk.PopoverMenu.new_from_model]. If you need to put other widgets such
// as a `GtkSpinButton` or a `GtkSwitch` into a popover, you can use
// [method@Gtk.PopoverMenu.add_child].
// 
// For more dialog-like behavior, use a plain `GtkPopover`.
// 
// 
// Menu models
// 
// The XML format understood by `GtkBuilder` for `GMenuModel` consists of a
// toplevel `<menu>` element, which contains one or more `<item>` elements. Each
// `<item>` element contains `<attribute>` and `<link>` elements with a
// mandatory name attribute. `<link>` elements have the same content model as
// `<menu>`. Instead of `<link name="submenu>` or `<link name="section">`, you
// can use `<submenu>` or `<section>` elements.
// 
// `xml <menu id='app-menu'> <section> <item> <attribute name='label'
// translatable='yes'>_New Window</attribute> <attribute
// name='action'>app.new</attribute> </item> <item> <attribute name='label'
// translatable='yes'>_About Sunny</attribute> <attribute
// name='action'>app.about</attribute> </item> <item> <attribute name='label'
// translatable='yes'>_Quit</attribute> <attribute
// name='action'>app.quit</attribute> </item> </section> </menu> `
// 
// Attribute values can be translated using gettext, like other `GtkBuilder`
// content. `<attribute>` elements can be marked for translation with a
// `translatable="yes"` attribute. It is also possible to specify message
// context and translator comments, using the context and comments attributes.
// To make use of this, the Builder must have been given the gettext domain to
// use.
// 
// The following attributes are used when constructing menu items:
// 
// - "label": a user-visible string to display - "action": the prefixed name of
// the action to trigger - "target": the parameter to use when activating the
// action - "icon" and "verb-icon": names of icons that may be displayed -
// "submenu-action": name of an action that may be used to determine if a
// submenu can be opened - "hidden-when": a string used to determine when the
// item will be hidden. Possible values include "action-disabled",
// "action-missing", "macos-menubar". This is mainly useful for exported menus,
// see [method@Gtk.Application.set_menubar]. - "custom": a string used to match
// against the ID of a custom child added with
// [method@Gtk.PopoverMenu.add_child], [method@Gtk.PopoverMenuBar.add_child], or
// in the ui file with `<child type="ID">`.
// 
// The following attributes are used when constructing sections:
// 
// - "label": a user-visible string to use as section heading - "display-hint":
// a string used to determine special formatting for the section. Possible
// values include "horizontal-buttons", "circular-buttons" and "inline-buttons".
// They all indicate that section should be displayed as a horizontal row of
// buttons. - "text-direction": a string used to determine the
// `GtkTextDirection` to use when "display-hint" is set to "horizontal-buttons".
// Possible values include "rtl", "ltr", and "none".
// 
// The following attributes are used when constructing submenus:
// 
// - "label": a user-visible string to display - "icon": icon name to display
// 
// Menu items will also show accelerators, which are usually associated with
// actions via [method@Gtk.Application.set_accels_for_action],
// [id@gtk_widget_class_add_binding_action] or
// [method@Gtk.ShortcutController.add_shortcut].
// 
// 
// CSS Nodes
// 
// `GtkPopoverMenu` is just a subclass of `GtkPopover` that adds custom content
// to it, therefore it has the same CSS nodes. It is one of the cases that add a
// .menu style class to the popover's main node.
// 
// 
// Accessibility
// 
// `GtkPopoverMenu` uses the GTK_ACCESSIBLE_ROLE_MENU role, and its items use
// the GTK_ACCESSIBLE_ROLE_MENU_ITEM, GTK_ACCESSIBLE_ROLE_MENU_ITEM_CHECKBOX or
// GTK_ACCESSIBLE_ROLE_MENU_ITEM_RADIO roles, depending on the action they are
// connected to.
	type PopoverMenu struct {
		Popover
		Accessible
		Buildable
		ConstraintTarget
		Native
		ShortcutManager
		
	}

	// PopoverMenuClass is an interface that the PopoverMenu class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PopoverMenuClass interface {
		gextras.Objector
		_popoverMenu()
	}

	func (PopoverMenu) _popoverMenu() {}

	
	func marshalPopoverMenu(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPopoverMenu(obj), nil
	}
	

	
	// NewPopoverMenuFromModel creates a `GtkPopoverMenu` and populates it according
// to @model.
// 
// The created buttons are connected to actions found in the
// `GtkApplicationWindow` to which the popover belongs - typically by means of
// being attached to a widget that is contained within the
// `GtkApplicationWindow`s widget hierarchy.
// 
// Actions can also be added using [method@Gtk.Widget.insert_action_group] on
// the menus attach widget or on any of its parent widgets.
// 
// This function creates menus with sliding submenus. See
// [ctor@Gtk.PopoverMenu.new_from_model_full] for a way to control this.
	func NewPopoverMenuFromModel(model gio.MenuModelClass) PopoverMenu {
var _arg1 *C.GMenuModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_popover_menu_new_from_model(_arg1)


var _popoverMenu PopoverMenu // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_popoverMenu = PopoverMenu{
Popover: Popover{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _popoverMenu
}
	
	// NewPopoverMenuFromModelFull creates a `GtkPopoverMenu` and populates it
// according to @model.
// 
// The created buttons are connected to actions found in the action groups that
// are accessible from the parent widget. This includes the
// `GtkApplicationWindow` to which the popover belongs. Actions can also be
// added using [method@Gtk.Widget.insert_action_group] on the parent widget or
// on any of its parent widgets.
// 
// The only flag that is supported currently is GTK_POPOVER_MENU_NESTED, which
// makes GTK create traditional, nested submenus instead of the default sliding
// submenus.
	func NewPopoverMenuFromModelFull(model gio.MenuModelClass, flags PopoverMenuFlags) PopoverMenu {
var _arg1 *C.GMenuModel // out
var _arg2 C.GtkPopoverMenuFlags // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))
_arg2 = (C.GtkPopoverMenuFlags)(flags)

_cret = C.gtk_popover_menu_new_from_model_full(_arg1, _arg2)


var _popoverMenu PopoverMenu // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_popoverMenu = PopoverMenu{
Popover: Popover{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _popoverMenu
}
	

	
	// AddChild adds a custom widget to a generated menu.
// 
// For this to work, the menu model of @popover must have an item with a
// `custom` attribute that matches @id.
	func (p PopoverMenu) AddChild(child WidgetClass, id string) bool {
var _arg0 *C.GtkPopoverMenu // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_popover_menu_add_child(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MenuModel returns the menu model used to populate the popover.
	func (p PopoverMenu) MenuModel() gio.MenuModel {
var _arg0 *C.GtkPopoverMenu // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))

_cret = C.gtk_popover_menu_get_menu_model(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_add_child().
	func (p PopoverMenu) RemoveChild(child WidgetClass) bool {
var _arg0 *C.GtkPopoverMenu // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_popover_menu_remove_child(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetMenuModel sets a new menu model on @popover.
// 
// The existing contents of @popover are removed, and the @popover is populated
// with new contents according to @model.
	func (p PopoverMenu) SetMenuModel(model gio.MenuModelClass)  {
var _arg0 *C.GtkPopoverMenu // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkPopoverMenu)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.gtk_popover_menu_set_menu_model(_arg0, _arg1)
}
	


	// PopoverMenuBar: `GtkPopoverMenuBar` presents a horizontal bar of items that
// pop up popover menus when clicked.
// 
// !An example GtkPopoverMenuBar (menubar.png)
// 
// The only way to create instances of `GtkPopoverMenuBar` is from a
// `GMenuModel`.
// 
// 
// CSS nodes
// 
// ` menubar  item[.active]   popover  item  popover `
// 
// `GtkPopoverMenuBar` has a single CSS node with name menubar, below which each
// item has its CSS node, and below that the corresponding popover.
// 
// The item whose popover is currently open gets the .active style class.
// 
// 
// Accessibility
// 
// `GtkPopoverMenuBar` uses the GTK_ACCESSIBLE_ROLE_MENU_BAR role, the menu
// items use the GTK_ACCESSIBLE_ROLE_MENU_ITEM role and the menus use the
// GTK_ACCESSIBLE_ROLE_MENU role.
	type PopoverMenuBar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// PopoverMenuBarClass is an interface that the PopoverMenuBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PopoverMenuBarClass interface {
		gextras.Objector
		_popoverMenuBar()
	}

	func (PopoverMenuBar) _popoverMenuBar() {}

	
	func marshalPopoverMenuBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPopoverMenuBar(obj), nil
	}
	

	
	// NewPopoverMenuBarFromModel creates a `GtkPopoverMenuBar` from a `GMenuModel`.
	func NewPopoverMenuBarFromModel(model gio.MenuModelClass) PopoverMenuBar {
var _arg1 *C.GMenuModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_popover_menu_bar_new_from_model(_arg1)


var _popoverMenuBar PopoverMenuBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_popoverMenuBar = PopoverMenuBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _popoverMenuBar
}
	

	
	// AddChild adds a custom widget to a generated menubar.
// 
// For this to work, the menu model of @bar must have an item with a `custom`
// attribute that matches @id.
	func (b PopoverMenuBar) AddChild(child WidgetClass, id string) bool {
var _arg0 *C.GtkPopoverMenuBar // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.char)(C.CString(id))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_popover_menu_bar_add_child(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MenuModel returns the model from which the contents of @bar are taken.
	func (b PopoverMenuBar) MenuModel() gio.MenuModel {
var _arg0 *C.GtkPopoverMenuBar // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_popover_menu_bar_get_menu_model(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// RemoveChild removes a widget that has previously been added with
// gtk_popover_menu_bar_add_child().
	func (b PopoverMenuBar) RemoveChild(child WidgetClass) bool {
var _arg0 *C.GtkPopoverMenuBar // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_popover_menu_bar_remove_child(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetMenuModel sets a menu model from which @bar should take its contents.
	func (b PopoverMenuBar) SetMenuModel(model gio.MenuModelClass)  {
var _arg0 *C.GtkPopoverMenuBar // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkPopoverMenuBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.gtk_popover_menu_bar_set_menu_model(_arg0, _arg1)
}
	


	// PrintContext: a `GtkPrintContext` encapsulates context information that is
// required when drawing pages for printing.
// 
// This includes the cairo context and important parameters like page size and
// resolution. It also lets you easily create [class@Pango.Layout] and
// [class@Pango.Context] objects that match the font metrics of the cairo
// surface.
// 
// `GtkPrintContext` objects get passed to the
// [signal@Gtk.PrintOperation::begin-print],
// [signal@Gtk.PrintOperation::end-print],
// [signal@Gtk.PrintOperation::request-page-setup] and
// [signal@Gtk.PrintOperation::draw-page] signals on the
// [class@Gtk.PrintOperation] object.
// 
// Using GtkPrintContext in a ::draw-page callback
// 
// `c static void draw_page (GtkPrintOperation *operation, GtkPrintContext
// *context, int page_nr) { cairo_t *cr; PangoLayout *layout;
// PangoFontDescription *desc;
// 
//    cr = gtk_print_context_get_cairo_context (context);
// 
//    // Draw a red rectangle, as wide as the paper (inside the margins)
//    cairo_set_source_rgb (cr, 1.0, 0, 0);
//    cairo_rectangle (cr, 0, 0, gtk_print_context_get_width (context), 50);
// 
//    cairo_fill (cr);
// 
//    // Draw some lines
//    cairo_move_to (cr, 20, 10);
//    cairo_line_to (cr, 40, 20);
//    cairo_arc (cr, 60, 60, 20, 0, M_PI);
//    cairo_line_to (cr, 80, 20);
// 
//    cairo_set_source_rgb (cr, 0, 0, 0);
//    cairo_set_line_width (cr, 5);
//    cairo_set_line_cap (cr, CAIRO_LINE_CAP_ROUND);
//    cairo_set_line_join (cr, CAIRO_LINE_JOIN_ROUND);
// 
//    cairo_stroke (cr);
// 
//    // Draw some text
//    layout = gtk_print_context_create_pango_layout (context);
//    pango_layout_set_text (layout, "Hello World! Printing is easy", -1);
//    desc = pango_font_description_from_string ("sans 28");
//    pango_layout_set_font_description (layout, desc);
//    pango_font_description_free (desc);
// 
//    cairo_move_to (cr, 30, 20);
//    pango_cairo_layout_path (cr, layout);
// 
//    // Font Outline
//    cairo_set_source_rgb (cr, 0.93, 1.0, 0.47);
//    cairo_set_line_width (cr, 0.5);
//    cairo_stroke_preserve (cr);
// 
//    // Font Fill
//    cairo_set_source_rgb (cr, 0, 0.0, 1.0);
//    cairo_fill (cr);
// 
//    g_object_unref (layout);
// 
// } `
	type PrintContext struct {
		**externglib.Object
		
	}

	// PrintContextClass is an interface that the PrintContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintContextClass interface {
		gextras.Objector
		_printContext()
	}

	func (PrintContext) _printContext() {}

	
	func marshalPrintContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintContext(obj), nil
	}
	

	

	
	// CreatePangoContext creates a new `PangoContext` that can be used with the
// `GtkPrintContext`.
	func (c PrintContext) CreatePangoContext() pango.Context {
var _arg0 *C.GtkPrintContext // out
var _cret *C.PangoContext // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_create_pango_context(_arg0)


var _ret pango.Context // out

_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

return _ret
}
	
	// CreatePangoLayout creates a new `PangoLayout` that is suitable for use with
// the `GtkPrintContext`.
	func (c PrintContext) CreatePangoLayout() pango.Layout {
var _arg0 *C.GtkPrintContext // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_create_pango_layout(_arg0)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// CairoContext obtains the cairo context that is associated with the
// `GtkPrintContext`.
	func (c PrintContext) CairoContext() *cairo.Context {
var _arg0 *C.GtkPrintContext // out
var _cret *C.cairo_t // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_cairo_context(_arg0)


var _ret *cairo.Context // out

_ret = *(**cairo.Context)(unsafe.Pointer(&_cret))

return _ret
}
	
	// DPIX obtains the horizontal resolution of the `GtkPrintContext`, in dots per
// inch.
	func (c PrintContext) DPIX() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.double // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_dpi_x(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DPIY obtains the vertical resolution of the `GtkPrintContext`, in dots per
// inch.
	func (c PrintContext) DPIY() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.double // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_dpi_y(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// HardMargins obtains the hardware printer margins of the `GtkPrintContext`, in
// units.
	func (c PrintContext) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
var _arg0 *C.GtkPrintContext // out
var _arg1 C.double // in
var _arg2 C.double // in
var _arg3 C.double // in
var _arg4 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)


var _top float64 // out
var _bottom float64 // out
var _left float64 // out
var _right float64 // out
var _ok bool // out

_top = (float64)(_arg1)
_bottom = (float64)(_arg2)
_left = (float64)(_arg3)
_right = (float64)(_arg4)
if _cret != 0 { _ok = true }

return _top, _bottom, _left, _right, _ok
}
	
	// Height obtains the height of the `GtkPrintContext`, in pixels.
	func (c PrintContext) Height() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.double // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_height(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PageSetup obtains the `GtkPageSetup` that determines the page dimensions of
// the `GtkPrintContext`.
	func (c PrintContext) PageSetup() PageSetup {
var _arg0 *C.GtkPrintContext // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_page_setup(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// PangoFontmap returns a `PangoFontMap` that is suitable for use with the
// `GtkPrintContext`.
	func (c PrintContext) PangoFontmap() pango.FontMap {
var _arg0 *C.GtkPrintContext // out
var _cret *C.PangoFontMap // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_pango_fontmap(_arg0)


var _fontMap pango.FontMap // out

_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

return _fontMap
}
	
	// Width obtains the width of the `GtkPrintContext`, in pixels.
	func (c PrintContext) Width() float64 {
var _arg0 *C.GtkPrintContext // out
var _cret C.double // in

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_print_context_get_width(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetCairoContext sets a new cairo context on a print context.
// 
// This function is intended to be used when implementing an internal print
// preview, it is not needed for printing, since GTK itself creates a suitable
// cairo context in that case.
	func (c PrintContext) SetCairoContext(cr *cairo.Context, dpiX float64, dpiY float64)  {
var _arg0 *C.GtkPrintContext // out
var _arg1 *C.cairo_t // out
var _arg2 C.double // out
var _arg3 C.double // out

_arg0 = (*C.GtkPrintContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.cairo_t)(unsafe.Pointer(cr.Native()))
_arg2 = (C.double)(dpiX)
_arg3 = (C.double)(dpiY)

C.gtk_print_context_set_cairo_context(_arg0, _arg1, _arg2, _arg3)
}
	


	// PrintJob: a `GtkPrintJob` object represents a job that is sent to a printer.
// 
// You only need to deal directly with print jobs if you use the non-portable
// [class@Gtk.PrintUnixDialog] API.
// 
// Use [method@Gtk.PrintJob.get_surface] to obtain the cairo surface onto which
// the pages must be drawn. Use [method@Gtk.PrintJob.send] to send the finished
// job to the printer. If you dont use cairo `GtkPrintJob` also supports
// printing of manually generated PostScript, via
// [method@Gtk.PrintJob.set_source_file].
	type PrintJob struct {
		**externglib.Object
		
	}

	// PrintJobClass is an interface that the PrintJob class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintJobClass interface {
		gextras.Objector
		_printJob()
	}

	func (PrintJob) _printJob() {}

	
	func marshalPrintJob(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintJob(obj), nil
	}
	

	
	// NewPrintJob creates a new `GtkPrintJob`.
	func NewPrintJob(title string, printer PrinterClass, settings PrintSettingsClass, pageSetup PageSetupClass) PrintJob {
var _arg1 *C.char // out
var _arg2 *C.GtkPrinter // out
var _arg3 *C.GtkPrintSettings // out
var _arg4 *C.GtkPageSetup // out
var _cret *C.GtkPrintJob // in

_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkPrinter)(unsafe.Pointer(printer.Native()))
_arg3 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))
_arg4 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

_cret = C.gtk_print_job_new(_arg1, _arg2, _arg3, _arg4)


var _printJob PrintJob // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printJob = PrintJob{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _printJob
}
	

	
	// Collate gets whether this job is printed collated.
	func (j PrintJob) Collate() bool {
var _arg0 *C.GtkPrintJob // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_collate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// NUp gets the n-up setting for this job.
	func (j PrintJob) NUp() uint {
var _arg0 *C.GtkPrintJob // out
var _cret C.guint // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_n_up(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// NUpLayout gets the n-up layout setting for this job.
	func (j PrintJob) NUpLayout() NumberUpLayout {
var _arg0 *C.GtkPrintJob // out
var _cret C.GtkNumberUpLayout // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_n_up_layout(_arg0)


var _numberUpLayout NumberUpLayout // out

_numberUpLayout = NumberUpLayout(_cret)

return _numberUpLayout
}
	
	// NumCopies gets the number of copies of this job.
	func (j PrintJob) NumCopies() int {
var _arg0 *C.GtkPrintJob // out
var _cret C.int // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_num_copies(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PageSet gets the `GtkPageSet` setting for this job.
	func (j PrintJob) PageSet() PageSet {
var _arg0 *C.GtkPrintJob // out
var _cret C.GtkPageSet // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_page_set(_arg0)


var _pageSet PageSet // out

_pageSet = PageSet(_cret)

return _pageSet
}
	
	// Pages gets the `GtkPrintPages` setting for this job.
	func (j PrintJob) Pages() PrintPages {
var _arg0 *C.GtkPrintJob // out
var _cret C.GtkPrintPages // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_pages(_arg0)


var _printPages PrintPages // out

_printPages = PrintPages(_cret)

return _printPages
}
	
	// Printer gets the `GtkPrinter` of the print job.
	func (j PrintJob) Printer() Printer {
var _arg0 *C.GtkPrintJob // out
var _cret *C.GtkPrinter // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_printer(_arg0)


var _printer Printer // out

_printer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Printer)

return _printer
}
	
	// Reverse gets whether this job is printed reversed.
	func (j PrintJob) Reverse() bool {
var _arg0 *C.GtkPrintJob // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_reverse(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Rotate gets whether the job is printed rotated.
	func (j PrintJob) Rotate() bool {
var _arg0 *C.GtkPrintJob // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_rotate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Scale gets the scale for this job.
	func (j PrintJob) Scale() float64 {
var _arg0 *C.GtkPrintJob // out
var _cret C.double // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_scale(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Settings gets the `GtkPrintSettings` of the print job.
	func (j PrintJob) Settings() PrintSettings {
var _arg0 *C.GtkPrintJob // out
var _cret *C.GtkPrintSettings // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_settings(_arg0)


var _printSettings PrintSettings // out

_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

return _printSettings
}
	
	// Status gets the status of the print job.
	func (j PrintJob) Status() PrintStatus {
var _arg0 *C.GtkPrintJob // out
var _cret C.GtkPrintStatus // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_status(_arg0)


var _printStatus PrintStatus // out

_printStatus = PrintStatus(_cret)

return _printStatus
}
	
	// Surface gets a cairo surface onto which the pages of the print job should be
// rendered.
	func (j PrintJob) Surface() (*cairo.Surface, error) {
var _arg0 *C.GtkPrintJob // out
var _cret *C.cairo_surface_t // in
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_surface(_arg0, &_cerr)


var _surface *cairo.Surface // out
var _goerr error // out

_surface = *(**cairo.Surface)(unsafe.Pointer(&_cret))
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _surface, _goerr
}
	
	// Title gets the job title.
	func (j PrintJob) Title() string {
var _arg0 *C.GtkPrintJob // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TrackPrintStatus returns whether jobs will be tracked after printing.
// 
// For details, see [method@Gtk.PrintJob.set_track_print_status].
	func (j PrintJob) TrackPrintStatus() bool {
var _arg0 *C.GtkPrintJob // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))

_cret = C.gtk_print_job_get_track_print_status(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCollate sets whether this job is printed collated.
	func (j PrintJob) SetCollate(collate bool)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
if collate { _arg1 = C.TRUE }

C.gtk_print_job_set_collate(_arg0, _arg1)
}
	
	// SetNUp sets the n-up setting for this job.
	func (j PrintJob) SetNUp(nUp uint)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.guint // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (C.guint)(nUp)

C.gtk_print_job_set_n_up(_arg0, _arg1)
}
	
	// SetNUpLayout sets the n-up layout setting for this job.
	func (j PrintJob) SetNUpLayout(layout NumberUpLayout)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.GtkNumberUpLayout // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (C.GtkNumberUpLayout)(layout)

C.gtk_print_job_set_n_up_layout(_arg0, _arg1)
}
	
	// SetNumCopies sets the number of copies for this job.
	func (j PrintJob) SetNumCopies(numCopies int)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (C.int)(numCopies)

C.gtk_print_job_set_num_copies(_arg0, _arg1)
}
	
	// SetPageRanges sets the page ranges for this job.
	func (j PrintJob) SetPageRanges(ranges []PageRange)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 *C.GtkPageRange
var _arg2 C.int

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg2 = C.int(len(ranges))
_arg1 = (*C.GtkPageRange)(C.malloc(C.ulong(len(ranges)) * C.ulong(C.sizeof_GtkPageRange)))
{
out := unsafe.Slice(_arg1, len(ranges))
for i := range ranges {
out[i] = *(*C.GtkPageRange)(unsafe.Pointer(ranges[i].Native()))
}
}

C.gtk_print_job_set_page_ranges(_arg0, _arg1, _arg2)
}
	
	// SetPageSet sets the `GtkPageSet` setting for this job.
	func (j PrintJob) SetPageSet(pageSet PageSet)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.GtkPageSet // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (C.GtkPageSet)(pageSet)

C.gtk_print_job_set_page_set(_arg0, _arg1)
}
	
	// SetPages sets the `GtkPrintPages` setting for this job.
	func (j PrintJob) SetPages(pages PrintPages)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.GtkPrintPages // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (C.GtkPrintPages)(pages)

C.gtk_print_job_set_pages(_arg0, _arg1)
}
	
	// SetReverse sets whether this job is printed reversed.
	func (j PrintJob) SetReverse(reverse bool)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
if reverse { _arg1 = C.TRUE }

C.gtk_print_job_set_reverse(_arg0, _arg1)
}
	
	// SetRotate sets whether this job is printed rotated.
	func (j PrintJob) SetRotate(rotate bool)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
if rotate { _arg1 = C.TRUE }

C.gtk_print_job_set_rotate(_arg0, _arg1)
}
	
	// SetScale sets the scale for this job.
// 
// 1.0 means unscaled.
	func (j PrintJob) SetScale(scale float64)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.double // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (C.double)(scale)

C.gtk_print_job_set_scale(_arg0, _arg1)
}
	
	// SetSourceFd: make the `GtkPrintJob` send an existing document to the printing
// system.
// 
// The file can be in any format understood by the platforms printing system
// (typically PostScript, but on many platforms PDF may work too). See
// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
// 
// This is similar to [method@Gtk.PrintJob.set_source_file], but takes expects
// an open file descriptor for the file, instead of a filename.
	func (j PrintJob) SetSourceFd(fd int) error {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.int // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (C.int)(fd)

C.gtk_print_job_set_source_fd(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetSourceFile: make the `GtkPrintJob` send an existing document to the
// printing system.
// 
// The file can be in any format understood by the platforms printing system
// (typically PostScript, but on many platforms PDF may work too). See
// [method@Gtk.Printer.accepts_pdf] and [method@Gtk.Printer.accepts_ps].
	func (j PrintJob) SetSourceFile(filename string) error {
var _arg0 *C.GtkPrintJob // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_job_set_source_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// SetTrackPrintStatus: if track_status is true, the print job will try to
// continue report on the status of the print job in the printer queues and
// printer.
// 
// This can allow your application to show things like out of paper issues,
// and when the print job actually reaches the printer.
// 
// This function is often implemented using some form of polling, so it should
// not be enabled unless needed.
	func (j PrintJob) SetTrackPrintStatus(trackStatus bool)  {
var _arg0 *C.GtkPrintJob // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintJob)(unsafe.Pointer(j.Native()))
if trackStatus { _arg1 = C.TRUE }

C.gtk_print_job_set_track_print_status(_arg0, _arg1)
}
	


	// PrintOperation: `GtkPrintOperation` is the high-level, portable printing API.
// 
// It looks a bit different than other GTK dialogs such as the `GtkFileChooser`,
// since some platforms dont expose enough infrastructure to implement a good
// print dialog. On such platforms, `GtkPrintOperation` uses the native print
// dialog. On platforms which do not provide a native print dialog, GTK uses its
// own, see [class@Gtk.PrintUnixDialog].
// 
// The typical way to use the high-level printing API is to create a
// `GtkPrintOperation` object with [ctor@Gtk.PrintOperation.new] when the user
// selects to print. Then you set some properties on it, e.g. the page size, any
// [class@Gtk.PrintSettings] from previous print operations, the number of
// pages, the current page, etc.
// 
// Then you start the print operation by calling
// [method@Gtk.PrintOperation.run]. It will then show a dialog, let the user
// select a printer and options. When the user finished the dialog, various
// signals will be emitted on the `GtkPrintOperation`, the main one being
// [signal@Gtk.PrintOperation::draw-page], which you are supposed to handle and
// render the page on the provided [class@Gtk.PrintContext] using Cairo.
// 
// 
// The high-level printing API
// 
// `c static GtkPrintSettings *settings = NULL;
// 
// static void do_print (void) { GtkPrintOperation *print;
// GtkPrintOperationResult res;
// 
//    print = gtk_print_operation_new ();
// 
//    if (settings != NULL)
//      gtk_print_operation_set_print_settings (print, settings);
// 
//    g_signal_connect (print, "begin_print", G_CALLBACK (begin_print), NULL);
//    g_signal_connect (print, "draw_page", G_CALLBACK (draw_page), NULL);
// 
//    res = gtk_print_operation_run (print, GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG,
//                                   GTK_WINDOW (main_window), NULL);
// 
//    if (res == GTK_PRINT_OPERATION_RESULT_APPLY)
//      {
//        if (settings != NULL)
//          g_object_unref (settings);
//        settings = g_object_ref (gtk_print_operation_get_print_settings (print));
//      }
// 
//    g_object_unref (print);
// 
// } `
// 
// By default `GtkPrintOperation` uses an external application to do print
// preview. To implement a custom print preview, an application must connect to
// the preview signal. The functions
// [method@Gtk.PrintOperationPreview.render_page],
// [method@Gtk.PrintOperationPreview.end_preview] and
// [method@Gtk.PrintOperationPreview.is_selected] are useful when implementing a
// print preview.
	type PrintOperation struct {
		**externglib.Object
		PrintOperationPreview
		
	}

	// PrintOperationClass is an interface that the PrintOperation class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintOperationClass interface {
		gextras.Objector
		_printOperation()
	}

	func (PrintOperation) _printOperation() {}

	
	func marshalPrintOperation(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintOperation(obj), nil
	}
	

	
	// NewPrintOperation creates a new `GtkPrintOperation`.
	func NewPrintOperation() PrintOperation {
var _cret *C.GtkPrintOperation // in

_cret = C.gtk_print_operation_new()


var _printOperation PrintOperation // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printOperation = PrintOperation{
Object: &externglib.Object{externglib.ToGObject(obj)},
PrintOperationPreview: PrintOperationPreview{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _printOperation
}
	

	
	// Cancel cancels a running print operation.
// 
// This function may be called from a [signal@Gtk.PrintOperation::begin-print],
// [signal@Gtk.PrintOperation::paginate] or
// [signal@Gtk.PrintOperation::draw-page] signal handler to stop the currently
// running print operation.
	func (o PrintOperation) Cancel()  {
var _arg0 *C.GtkPrintOperation // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_cancel(_arg0)
}
	
	// DrawPageFinish: signal that drawing of particular page is complete.
// 
// It is called after completion of page drawing (e.g. drawing in another
// thread). If [method@Gtk.PrintOperation.set_defer_drawing] was called before,
// then this function has to be called by application. Otherwise it is called by
// GTK itself.
	func (o PrintOperation) DrawPageFinish()  {
var _arg0 *C.GtkPrintOperation // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_draw_page_finish(_arg0)
}
	
	// DefaultPageSetup returns the default page setup.
	func (o PrintOperation) DefaultPageSetup() PageSetup {
var _arg0 *C.GtkPrintOperation // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_default_page_setup(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// EmbedPageSetup gets whether page setup selection combos are embedded
	func (o PrintOperation) EmbedPageSetup() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_embed_page_setup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Error: call this when the result of a print operation is
// GTK_PRINT_OPERATION_RESULT_ERROR.
// 
// It can be called either after [method@Gtk.PrintOperation.run] returns, or in
// the [signal@Gtk.PrintOperation::done] signal handler.
// 
// The returned `GError` will contain more details on what went wrong.
	func (o PrintOperation) Error() error {
var _arg0 *C.GtkPrintOperation // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_get_error(_arg0, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// HasSelection gets whether there is a selection.
	func (o PrintOperation) HasSelection() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_has_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// NPagesToPrint returns the number of pages that will be printed.
// 
// Note that this value is set during print preparation phase
// (GTK_PRINT_STATUS_PREPARING), so this function should never be called before
// the data generation phase (GTK_PRINT_STATUS_GENERATING_DATA). You can connect
// to the [signal@Gtk.PrintOperation::status-changed] signal and call
// gtk_print_operation_get_n_pages_to_print() when print status is
// GTK_PRINT_STATUS_GENERATING_DATA.
// 
// This is typically used to track the progress of print operation.
	func (o PrintOperation) NPagesToPrint() int {
var _arg0 *C.GtkPrintOperation // out
var _cret C.int // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_n_pages_to_print(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PrintSettings returns the current print settings.
// 
// Note that the return value is nil until either
// [method@Gtk.PrintOperation.set_print_settings] or
// [method@Gtk.PrintOperation.run] have been called.
	func (o PrintOperation) PrintSettings() PrintSettings {
var _arg0 *C.GtkPrintOperation // out
var _cret *C.GtkPrintSettings // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_print_settings(_arg0)


var _printSettings PrintSettings // out

_printSettings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PrintSettings)

return _printSettings
}
	
	// Status returns the status of the print operation.
// 
// Also see [method@Gtk.PrintOperation.get_status_string].
	func (o PrintOperation) Status() PrintStatus {
var _arg0 *C.GtkPrintOperation // out
var _cret C.GtkPrintStatus // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_status(_arg0)


var _printStatus PrintStatus // out

_printStatus = PrintStatus(_cret)

return _printStatus
}
	
	// StatusString returns a string representation of the status of the print
// operation.
// 
// The string is translated and suitable for displaying the print status e.g. in
// a `GtkStatusbar`.
// 
// Use [method@Gtk.PrintOperation.get_status] to obtain a status value that is
// suitable for programmatic use.
	func (o PrintOperation) StatusString() string {
var _arg0 *C.GtkPrintOperation // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_status_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SupportSelection gets whether the application supports print of selection
	func (o PrintOperation) SupportSelection() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_get_support_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFinished: a convenience function to find out if the print operation is
// finished.
// 
// a print operation is finished if its status is either
// GTK_PRINT_STATUS_FINISHED or GTK_PRINT_STATUS_FINISHED_ABORTED.
// 
// Note: when you enable print status tracking the print operation can be in a
// non-finished state even after done has been called, as the operation status
// then tracks the print job status on the printer.
	func (o PrintOperation) IsFinished() bool {
var _arg0 *C.GtkPrintOperation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_operation_is_finished(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Run runs the print operation.
// 
// Normally that this function does not return until the rendering of all pages
// is complete. You can connect to the
// [signal@Gtk.PrintOperation::status-changed] signal on @op to obtain some
// information about the progress of the print operation.
// 
// Furthermore, it may use a recursive mainloop to show the print dialog.
// 
// If you set the [Gtk.PrintOperation:allow-async] property, the operation will
// run asynchronously if this is supported on the platform. The
// [signal@Gtk.PrintOperation::done] signal will be emitted with the result of
// the operation when the it is done (i.e. when the dialog is canceled, or when
// the print succeeds or fails).
// 
// `c if (settings != NULL) gtk_print_operation_set_print_settings (print,
// settings);
// 
// if (page_setup != NULL) gtk_print_operation_set_default_page_setup (print,
// page_setup);
// 
// g_signal_connect (print, "begin-print", G_CALLBACK (begin_print), &data);
// g_signal_connect (print, "draw-page", G_CALLBACK (draw_page), &data);
// 
// res = gtk_print_operation_run (print,
// GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG, parent, &error);
// 
// if (res == GTK_PRINT_OPERATION_RESULT_ERROR) { error_dialog =
// gtk_message_dialog_new (GTK_WINDOW (parent), GTK_DIALOG_DESTROY_WITH_PARENT,
// GTK_MESSAGE_ERROR, GTK_BUTTONS_CLOSE, "Error printing file:\ns",
// error->message); g_signal_connect (error_dialog, "response", G_CALLBACK
// (gtk_window_destroy), NULL); gtk_widget_show (error_dialog); g_error_free
// (error); } else if (res == GTK_PRINT_OPERATION_RESULT_APPLY) { if (settings
// != NULL) g_object_unref (settings); settings = g_object_ref
// (gtk_print_operation_get_print_settings (print)); } `
// 
// Note that gtk_print_operation_run() can only be called once on a given
// `GtkPrintOperation`.
	func (o PrintOperation) Run(action PrintOperationAction, parent WindowClass) (PrintOperationResult, error) {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.GtkPrintOperationAction // out
var _arg2 *C.GtkWindow // out
var _cret C.GtkPrintOperationResult // in
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.GtkPrintOperationAction)(action)
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_print_operation_run(_arg0, _arg1, _arg2, &_cerr)


var _printOperationResult PrintOperationResult // out
var _goerr error // out

_printOperationResult = PrintOperationResult(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _printOperationResult, _goerr
}
	
	// SetAllowAsync sets whether gtk_print_operation_run() may return before the
// print operation is completed.
// 
// Note that some platforms may not allow asynchronous operation.
	func (o PrintOperation) SetAllowAsync(allowAsync bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if allowAsync { _arg1 = C.TRUE }

C.gtk_print_operation_set_allow_async(_arg0, _arg1)
}
	
	// SetCurrentPage sets the current page.
// 
// If this is called before [method@Gtk.PrintOperation.run], the user will be
// able to select to print only the current page.
// 
// Note that this only makes sense for pre-paginated documents.
	func (o PrintOperation) SetCurrentPage(currentPage int)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.int)(currentPage)

C.gtk_print_operation_set_current_page(_arg0, _arg1)
}
	
	// SetCustomTabLabel sets the label for the tab holding custom widgets.
	func (o PrintOperation) SetCustomTabLabel(label string)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_operation_set_custom_tab_label(_arg0, _arg1)
}
	
	// SetDefaultPageSetup makes @default_page_setup the default page setup for @op.
// 
// This page setup will be used by [method@Gtk.PrintOperation.run], but it can
// be overridden on a per-page basis by connecting to the
// [signal@Gtk.PrintOperation::request-page-setup] signal.
	func (o PrintOperation) SetDefaultPageSetup(defaultPageSetup PageSetupClass)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.GtkPageSetup // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(defaultPageSetup.Native()))

C.gtk_print_operation_set_default_page_setup(_arg0, _arg1)
}
	
	// SetDeferDrawing sets up the `GtkPrintOperation` to wait for calling of
// [method@Gtk.PrintOperation.draw_page_finish from application.
// 
// This can be used for drawing page in another thread.
// 
// This function must be called in the callback of the
// [signal@Gtk.PrintOperation::draw-page] signal.
	func (o PrintOperation) SetDeferDrawing()  {
var _arg0 *C.GtkPrintOperation // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))

C.gtk_print_operation_set_defer_drawing(_arg0)
}
	
	// SetEmbedPageSetup: embed page size combo box and orientation combo box into
// page setup page.
// 
// Selected page setup is stored as default page setup in `GtkPrintOperation`.
	func (o PrintOperation) SetEmbedPageSetup(embed bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if embed { _arg1 = C.TRUE }

C.gtk_print_operation_set_embed_page_setup(_arg0, _arg1)
}
	
	// SetExportFilename sets up the `GtkPrintOperation` to generate a file instead
// of showing the print dialog.
// 
// The intended use of this function is for implementing Export to PDF
// actions. Currently, PDF is the only supported format.
// 
// Print to PDF support is independent of this and is done by letting the user
// pick the Print to PDF item from the list of printers in the print dialog.
	func (o PrintOperation) SetExportFilename(filename string)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_operation_set_export_filename(_arg0, _arg1)
}
	
	// SetHasSelection sets whether there is a selection to print.
// 
// Application has to set number of pages to which the selection will draw by
// [method@Gtk.PrintOperation.set_n_pages] in a handler for the
// [signal@Gtk.PrintOperation::begin-print] signal.
	func (o PrintOperation) SetHasSelection(hasSelection bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if hasSelection { _arg1 = C.TRUE }

C.gtk_print_operation_set_has_selection(_arg0, _arg1)
}
	
	// SetJobName sets the name of the print job.
// 
// The name is used to identify the job (e.g. in monitoring applications like
// eggcups).
// 
// If you dont set a job name, GTK picks a default one by numbering successive
// print jobs.
	func (o PrintOperation) SetJobName(jobName string)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.char)(C.CString(jobName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_operation_set_job_name(_arg0, _arg1)
}
	
	// SetNPages sets the number of pages in the document.
// 
// This must be set to a positive number before the rendering starts. It may be
// set in a [signal@Gtk.PrintOperation::begin-print] signal handler.
// 
// Note that the page numbers passed to the
// [signal@Gtk.PrintOperation::request-page-setup] and
// [signal@Gtk.PrintOperation::draw-page] signals are 0-based, i.e. if the user
// chooses to print all pages, the last ::draw-page signal will be for page
// @n_pages - 1.
	func (o PrintOperation) SetNPages(nPages int)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.int)(nPages)

C.gtk_print_operation_set_n_pages(_arg0, _arg1)
}
	
	// SetPrintSettings sets the print settings for @op.
// 
// This is typically used to re-establish print settings from a previous print
// operation, see [method@Gtk.PrintOperation.run].
	func (o PrintOperation) SetPrintSettings(printSettings PrintSettingsClass)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 *C.GtkPrintSettings // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(printSettings.Native()))

C.gtk_print_operation_set_print_settings(_arg0, _arg1)
}
	
	// SetShowProgress: if @show_progress is true, the print operation will show a
// progress dialog during the print operation.
	func (o PrintOperation) SetShowProgress(showProgress bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if showProgress { _arg1 = C.TRUE }

C.gtk_print_operation_set_show_progress(_arg0, _arg1)
}
	
	// SetSupportSelection sets whether selection is supported by
// `GtkPrintOperation`.
	func (o PrintOperation) SetSupportSelection(supportSelection bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if supportSelection { _arg1 = C.TRUE }

C.gtk_print_operation_set_support_selection(_arg0, _arg1)
}
	
	// SetTrackPrintStatus: if track_status is true, the print operation will try to
// continue report on the status of the print job in the printer queues and
// printer.
// 
// This can allow your application to show things like out of paper issues,
// and when the print job actually reaches the printer.
// 
// This function is often implemented using some form of polling, so it should
// not be enabled unless needed.
	func (o PrintOperation) SetTrackPrintStatus(trackStatus bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if trackStatus { _arg1 = C.TRUE }

C.gtk_print_operation_set_track_print_status(_arg0, _arg1)
}
	
	// SetUnit sets up the transformation for the cairo context obtained from
// `GtkPrintContext` in such a way that distances are measured in units of
// @unit.
	func (o PrintOperation) SetUnit(unit Unit)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.GtkUnit // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
_arg1 = (C.GtkUnit)(unit)

C.gtk_print_operation_set_unit(_arg0, _arg1)
}
	
	// SetUseFullPage: if @full_page is true, the transformation for the cairo
// context obtained from `GtkPrintContext` puts the origin at the top left
// corner of the page.
// 
// This may not be the top left corner of the sheet, depending on page
// orientation and the number of pages per sheet). Otherwise, the origin is at
// the top left corner of the imageable area (i.e. inside the margins).
	func (o PrintOperation) SetUseFullPage(fullPage bool)  {
var _arg0 *C.GtkPrintOperation // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintOperation)(unsafe.Pointer(o.Native()))
if fullPage { _arg1 = C.TRUE }

C.gtk_print_operation_set_use_full_page(_arg0, _arg1)
}
	


	// PrintSettings: a `GtkPrintSettings` object represents the settings of a print
// dialog in a system-independent way.
// 
// The main use for this object is that once youve printed you can get a
// settings object that represents the settings the user chose, and the next
// time you print you can pass that object in so that the user doesnt have to
// re-set all his settings.
// 
// Its also possible to enumerate the settings so that you can easily save the
// settings for the next time your app runs, or even store them in a document.
// The predefined keys try to use shared values as much as possible so that
// moving such a document between systems still works.
	type PrintSettings struct {
		**externglib.Object
		
	}

	// PrintSettingsClass is an interface that the PrintSettings class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintSettingsClass interface {
		gextras.Objector
		_printSettings()
	}

	func (PrintSettings) _printSettings() {}

	
	func marshalPrintSettings(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintSettings(obj), nil
	}
	

	
	// NewPrintSettings creates a new `GtkPrintSettings` object.
	func NewPrintSettings() PrintSettings {
var _cret *C.GtkPrintSettings // in

_cret = C.gtk_print_settings_new()


var _printSettings PrintSettings // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _printSettings
}
	
	// NewPrintSettingsFromFile reads the print settings from @file_name.
// 
// Returns a new `GtkPrintSettings` object with the restored settings, or nil if
// an error occurred. If the file could not be loaded then error is set to
// either a `GFileError` or `GKeyFileError`.
// 
// See [method@Gtk.PrintSettings.to_file].
	func NewPrintSettingsFromFile(fileName string) (PrintSettings, error) {
var _arg1 *C.char // out
var _cret *C.GtkPrintSettings // in
var _cerr *C.GError // in

_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_new_from_file(_arg1, &_cerr)


var _printSettings PrintSettings // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _printSettings, _goerr
}
	
	// NewPrintSettingsFromGVariant: deserialize print settings from an a{sv}
// variant.
// 
// The variant must be in the format produced by
// [method@Gtk.PrintSettings.to_gvariant].
	func NewPrintSettingsFromGVariant(variant *glib.Variant) PrintSettings {
var _arg1 *C.GVariant // out
var _cret *C.GtkPrintSettings // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_print_settings_new_from_gvariant(_arg1)


var _printSettings PrintSettings // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _printSettings
}
	
	// NewPrintSettingsFromKeyFile reads the print settings from the group
// @group_name in @key_file.
// 
// Returns a new `GtkPrintSettings` object with the restored settings, or nil if
// an error occurred. If the file could not be loaded then error is set to
// either `GFileError` or `GKeyFileError`.
	func NewPrintSettingsFromKeyFile(keyFile *glib.KeyFile, groupName string) (PrintSettings, error) {
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out
var _cret *C.GtkPrintSettings // in
var _cerr *C.GError // in

_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_print_settings_new_from_key_file(_arg1, _arg2, &_cerr)


var _printSettings PrintSettings // out
var _goerr error // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printSettings = PrintSettings{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _printSettings, _goerr
}
	

	
	// Copy copies a `GtkPrintSettings` object.
	func (o PrintSettings) Copy() PrintSettings {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.GtkPrintSettings // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(o.Native()))

_cret = C.gtk_print_settings_copy(_arg0)


var _printSettings PrintSettings // out

_printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PrintSettings)

return _printSettings
}
	
	// Get looks up the string value associated with @key.
	func (s PrintSettings) Get(key string) string {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Bool returns the boolean represented by the value that is associated with
// @key.
// 
// The string true represents true, any other string false.
	func (s PrintSettings) Bool(key string) bool {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get_bool(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Collate gets the value of GTK_PRINT_SETTINGS_COLLATE.
	func (s PrintSettings) Collate() bool {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_collate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DefaultSource gets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	func (s PrintSettings) DefaultSource() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_default_source(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Dither gets the value of GTK_PRINT_SETTINGS_DITHER.
	func (s PrintSettings) Dither() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_dither(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Double returns the double value associated with @key, or 0.
	func (s PrintSettings) Double(key string) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _cret C.double // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get_double(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DoubleWithDefault returns the floating point number represented by the value
// that is associated with @key, or @default_val if the value does not represent
// a floating point number.
// 
// Floating point numbers are parsed with g_ascii_strtod().
	func (s PrintSettings) DoubleWithDefault(key string, def float64) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 C.double // out
var _cret C.double // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.double)(def)

_cret = C.gtk_print_settings_get_double_with_default(_arg0, _arg1, _arg2)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Duplex gets the value of GTK_PRINT_SETTINGS_DUPLEX.
	func (s PrintSettings) Duplex() PrintDuplex {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPrintDuplex // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_duplex(_arg0)


var _printDuplex PrintDuplex // out

_printDuplex = PrintDuplex(_cret)

return _printDuplex
}
	
	// Finishings gets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	func (s PrintSettings) Finishings() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_finishings(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Int returns the integer value of @key, or 0.
	func (s PrintSettings) Int(key string) int {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _cret C.int // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_get_int(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IntWithDefault returns the value of @key, interpreted as an integer, or the
// default value.
	func (s PrintSettings) IntWithDefault(key string, def int) int {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 C.int // out
var _cret C.int // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(def)

_cret = C.gtk_print_settings_get_int_with_default(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Length returns the value associated with @key, interpreted as a length.
// 
// The returned value is converted to @units.
	func (s PrintSettings) Length(key string, unit Unit) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkUnit)(unit)

_cret = C.gtk_print_settings_get_length(_arg0, _arg1, _arg2)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// MediaType gets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
// 
// The set of media types is defined in PWG 5101.1-2002 PWG.
	func (s PrintSettings) MediaType() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_media_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NCopies gets the value of GTK_PRINT_SETTINGS_N_COPIES.
	func (s PrintSettings) NCopies() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.int // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_n_copies(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NumberUp gets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	func (s PrintSettings) NumberUp() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.int // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_number_up(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// NumberUpLayout gets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	func (s PrintSettings) NumberUpLayout() NumberUpLayout {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkNumberUpLayout // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_number_up_layout(_arg0)


var _numberUpLayout NumberUpLayout // out

_numberUpLayout = NumberUpLayout(_cret)

return _numberUpLayout
}
	
	// Orientation: get the value of GTK_PRINT_SETTINGS_ORIENTATION, converted to a
// `GtkPageOrientation`.
	func (s PrintSettings) Orientation() PageOrientation {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPageOrientation // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_orientation(_arg0)


var _pageOrientation PageOrientation // out

_pageOrientation = PageOrientation(_cret)

return _pageOrientation
}
	
	// OutputBin gets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	func (s PrintSettings) OutputBin() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_output_bin(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PageSet gets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	func (s PrintSettings) PageSet() PageSet {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPageSet // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_page_set(_arg0)


var _pageSet PageSet // out

_pageSet = PageSet(_cret)

return _pageSet
}
	
	// PaperHeight gets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT, converted to
// @unit.
	func (s PrintSettings) PaperHeight(unit Unit) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_print_settings_get_paper_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PaperSize gets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT, converted to a
// `GtkPaperSize`.
	func (s PrintSettings) PaperSize() *PaperSize {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.GtkPaperSize // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_paper_size(_arg0)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	// PaperWidth gets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH, converted to
// @unit.
	func (s PrintSettings) PaperWidth(unit Unit) float64 {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_print_settings_get_paper_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// PrintPages gets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	func (s PrintSettings) PrintPages() PrintPages {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPrintPages // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_print_pages(_arg0)


var _printPages PrintPages // out

_printPages = PrintPages(_cret)

return _printPages
}
	
	// Printer: convenience function to obtain the value of
// GTK_PRINT_SETTINGS_PRINTER.
	func (s PrintSettings) Printer() string {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.char // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_printer(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PrinterLpi gets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	func (s PrintSettings) PrinterLpi() float64 {
var _arg0 *C.GtkPrintSettings // out
var _cret C.double // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_printer_lpi(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Quality gets the value of GTK_PRINT_SETTINGS_QUALITY.
	func (s PrintSettings) Quality() PrintQuality {
var _arg0 *C.GtkPrintSettings // out
var _cret C.GtkPrintQuality // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_quality(_arg0)


var _printQuality PrintQuality // out

_printQuality = PrintQuality(_cret)

return _printQuality
}
	
	// Resolution gets the value of GTK_PRINT_SETTINGS_RESOLUTION.
	func (s PrintSettings) Resolution() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.int // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_resolution(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ResolutionX gets the value of GTK_PRINT_SETTINGS_RESOLUTION_X.
	func (s PrintSettings) ResolutionX() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.int // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_resolution_x(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ResolutionY gets the value of GTK_PRINT_SETTINGS_RESOLUTION_Y.
	func (s PrintSettings) ResolutionY() int {
var _arg0 *C.GtkPrintSettings // out
var _cret C.int // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_resolution_y(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Reverse gets the value of GTK_PRINT_SETTINGS_REVERSE.
	func (s PrintSettings) Reverse() bool {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_reverse(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Scale gets the value of GTK_PRINT_SETTINGS_SCALE.
	func (s PrintSettings) Scale() float64 {
var _arg0 *C.GtkPrintSettings // out
var _cret C.double // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_scale(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// UseColor gets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	func (s PrintSettings) UseColor() bool {
var _arg0 *C.GtkPrintSettings // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_get_use_color(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasKey returns true, if a value is associated with @key.
	func (s PrintSettings) HasKey(key string) bool {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_print_settings_has_key(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LoadFile reads the print settings from @file_name.
// 
// If the file could not be loaded then error is set to either a `GFileError` or
// `GKeyFileError`.
// 
// See [method@Gtk.PrintSettings.to_file].
	func (s PrintSettings) LoadFile(fileName string) error {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_load_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// LoadKeyFile reads the print settings from the group @group_name in @key_file.
// 
// If the file could not be loaded then error is set to either a `GFileError` or
// `GKeyFileError`.
	func (s PrintSettings) LoadKeyFile(keyFile *glib.KeyFile, groupName string) error {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_print_settings_load_key_file(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// Set associates @value with @key.
	func (s PrintSettings) Set(key string, value string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(value))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_print_settings_set(_arg0, _arg1, _arg2)
}
	
	// SetBool sets @key to a boolean value.
	func (s PrintSettings) SetBool(key string, value bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
if value { _arg2 = C.TRUE }

C.gtk_print_settings_set_bool(_arg0, _arg1, _arg2)
}
	
	// SetCollate sets the value of GTK_PRINT_SETTINGS_COLLATE.
	func (s PrintSettings) SetCollate(collate bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
if collate { _arg1 = C.TRUE }

C.gtk_print_settings_set_collate(_arg0, _arg1)
}
	
	// SetDefaultSource sets the value of GTK_PRINT_SETTINGS_DEFAULT_SOURCE.
	func (s PrintSettings) SetDefaultSource(defaultSource string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(defaultSource))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_default_source(_arg0, _arg1)
}
	
	// SetDither sets the value of GTK_PRINT_SETTINGS_DITHER.
	func (s PrintSettings) SetDither(dither string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(dither))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_dither(_arg0, _arg1)
}
	
	// SetDouble sets @key to a double value.
	func (s PrintSettings) SetDouble(key string, value float64)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 C.double // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.double)(value)

C.gtk_print_settings_set_double(_arg0, _arg1, _arg2)
}
	
	// SetDuplex sets the value of GTK_PRINT_SETTINGS_DUPLEX.
	func (s PrintSettings) SetDuplex(duplex PrintDuplex)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPrintDuplex // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPrintDuplex)(duplex)

C.gtk_print_settings_set_duplex(_arg0, _arg1)
}
	
	// SetFinishings sets the value of GTK_PRINT_SETTINGS_FINISHINGS.
	func (s PrintSettings) SetFinishings(finishings string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(finishings))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_finishings(_arg0, _arg1)
}
	
	// SetInt sets @key to an integer value.
	func (s PrintSettings) SetInt(key string, value int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 C.int // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(value)

C.gtk_print_settings_set_int(_arg0, _arg1, _arg2)
}
	
	// SetLength associates a length in units of @unit with @key.
	func (s PrintSettings) SetLength(key string, value float64, unit Unit)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _arg2 C.double // out
var _arg3 C.GtkUnit // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.double)(value)
_arg3 = (C.GtkUnit)(unit)

C.gtk_print_settings_set_length(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetMediaType sets the value of GTK_PRINT_SETTINGS_MEDIA_TYPE.
// 
// The set of media types is defined in PWG 5101.1-2002 PWG.
	func (s PrintSettings) SetMediaType(mediaType string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(mediaType))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_media_type(_arg0, _arg1)
}
	
	// SetNCopies sets the value of GTK_PRINT_SETTINGS_N_COPIES.
	func (s PrintSettings) SetNCopies(numCopies int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(numCopies)

C.gtk_print_settings_set_n_copies(_arg0, _arg1)
}
	
	// SetNumberUp sets the value of GTK_PRINT_SETTINGS_NUMBER_UP.
	func (s PrintSettings) SetNumberUp(numberUp int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(numberUp)

C.gtk_print_settings_set_number_up(_arg0, _arg1)
}
	
	// SetNumberUpLayout sets the value of GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT.
	func (s PrintSettings) SetNumberUpLayout(numberUpLayout NumberUpLayout)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkNumberUpLayout // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkNumberUpLayout)(numberUpLayout)

C.gtk_print_settings_set_number_up_layout(_arg0, _arg1)
}
	
	// SetOrientation sets the value of GTK_PRINT_SETTINGS_ORIENTATION.
	func (s PrintSettings) SetOrientation(orientation PageOrientation)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPageOrientation // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPageOrientation)(orientation)

C.gtk_print_settings_set_orientation(_arg0, _arg1)
}
	
	// SetOutputBin sets the value of GTK_PRINT_SETTINGS_OUTPUT_BIN.
	func (s PrintSettings) SetOutputBin(outputBin string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(outputBin))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_output_bin(_arg0, _arg1)
}
	
	// SetPageRanges sets the value of GTK_PRINT_SETTINGS_PAGE_RANGES.
	func (s PrintSettings) SetPageRanges(pageRanges []PageRange)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GtkPageRange
var _arg2 C.int

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg2 = C.int(len(pageRanges))
_arg1 = (*C.GtkPageRange)(unsafe.Pointer(&pageRanges[0]))

C.gtk_print_settings_set_page_ranges(_arg0, _arg1, _arg2)
}
	
	// SetPageSet sets the value of GTK_PRINT_SETTINGS_PAGE_SET.
	func (s PrintSettings) SetPageSet(pageSet PageSet)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPageSet // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPageSet)(pageSet)

C.gtk_print_settings_set_page_set(_arg0, _arg1)
}
	
	// SetPaperHeight sets the value of GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	func (s PrintSettings) SetPaperHeight(height float64, unit Unit)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.double // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(height)
_arg2 = (C.GtkUnit)(unit)

C.gtk_print_settings_set_paper_height(_arg0, _arg1, _arg2)
}
	
	// SetPaperSize sets the value of GTK_PRINT_SETTINGS_PAPER_FORMAT,
// GTK_PRINT_SETTINGS_PAPER_WIDTH and GTK_PRINT_SETTINGS_PAPER_HEIGHT.
	func (s PrintSettings) SetPaperSize(paperSize *PaperSize)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GtkPaperSize // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

C.gtk_print_settings_set_paper_size(_arg0, _arg1)
}
	
	// SetPaperWidth sets the value of GTK_PRINT_SETTINGS_PAPER_WIDTH.
	func (s PrintSettings) SetPaperWidth(width float64, unit Unit)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.double // out
var _arg2 C.GtkUnit // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(width)
_arg2 = (C.GtkUnit)(unit)

C.gtk_print_settings_set_paper_width(_arg0, _arg1, _arg2)
}
	
	// SetPrintPages sets the value of GTK_PRINT_SETTINGS_PRINT_PAGES.
	func (s PrintSettings) SetPrintPages(pages PrintPages)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPrintPages // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPrintPages)(pages)

C.gtk_print_settings_set_print_pages(_arg0, _arg1)
}
	
	// SetPrinter: convenience function to set GTK_PRINT_SETTINGS_PRINTER to
// @printer.
	func (s PrintSettings) SetPrinter(printer string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(printer))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_set_printer(_arg0, _arg1)
}
	
	// SetPrinterLpi sets the value of GTK_PRINT_SETTINGS_PRINTER_LPI.
	func (s PrintSettings) SetPrinterLpi(lpi float64)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.double // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(lpi)

C.gtk_print_settings_set_printer_lpi(_arg0, _arg1)
}
	
	// SetQuality sets the value of GTK_PRINT_SETTINGS_QUALITY.
	func (s PrintSettings) SetQuality(quality PrintQuality)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.GtkPrintQuality // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPrintQuality)(quality)

C.gtk_print_settings_set_quality(_arg0, _arg1)
}
	
	// SetResolution sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	func (s PrintSettings) SetResolution(resolution int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(resolution)

C.gtk_print_settings_set_resolution(_arg0, _arg1)
}
	
	// SetResolutionXY sets the values of GTK_PRINT_SETTINGS_RESOLUTION,
// GTK_PRINT_SETTINGS_RESOLUTION_X and GTK_PRINT_SETTINGS_RESOLUTION_Y.
	func (s PrintSettings) SetResolutionXY(resolutionX int, resolutionY int)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(resolutionX)
_arg2 = (C.int)(resolutionY)

C.gtk_print_settings_set_resolution_xy(_arg0, _arg1, _arg2)
}
	
	// SetReverse sets the value of GTK_PRINT_SETTINGS_REVERSE.
	func (s PrintSettings) SetReverse(reverse bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
if reverse { _arg1 = C.TRUE }

C.gtk_print_settings_set_reverse(_arg0, _arg1)
}
	
	// SetScale sets the value of GTK_PRINT_SETTINGS_SCALE.
	func (s PrintSettings) SetScale(scale float64)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.double // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(scale)

C.gtk_print_settings_set_scale(_arg0, _arg1)
}
	
	// SetUseColor sets the value of GTK_PRINT_SETTINGS_USE_COLOR.
	func (s PrintSettings) SetUseColor(useColor bool)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
if useColor { _arg1 = C.TRUE }

C.gtk_print_settings_set_use_color(_arg0, _arg1)
}
	
	// ToFile: this function saves the print settings from @settings to @file_name.
// 
// If the file could not be written then error is set to either a `GFileError`
// or `GKeyFileError`.
	func (s PrintSettings) ToFile(fileName string) error {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(fileName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_to_file(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// ToGVariant: serialize print settings to an a{sv} variant.
	func (s PrintSettings) ToGVariant() *glib.Variant {
var _arg0 *C.GtkPrintSettings // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))

_cret = C.gtk_print_settings_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// ToKeyFile: this function adds the print settings from @settings to @key_file.
	func (s PrintSettings) ToKeyFile(keyFile *glib.KeyFile, groupName string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_print_settings_to_key_file(_arg0, _arg1, _arg2)
}
	
	// Unset removes any value associated with @key.
// 
// This has the same effect as setting the value to nil.
	func (s PrintSettings) Unset(key string)  {
var _arg0 *C.GtkPrintSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkPrintSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(key))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_print_settings_unset(_arg0, _arg1)
}
	


	// PrintUnixDialog: `GtkPrintUnixDialog` implements a print dialog for platforms
// which dont provide a native print dialog, like Unix.
// 
// !An example GtkPrintUnixDialog (printdialog.png)
// 
// It can be used very much like any other GTK dialog, at the cost of the
// portability offered by the high-level printing API with
// [class@Gtk.PrintOperation].
// 
// In order to print something with `GtkPrintUnixDialog`, you need to use
// [method@Gtk.PrintUnixDialog.get_selected_printer] to obtain a
// [class@Gtk.Printer] object and use it to construct a [class@Gtk.PrintJob]
// using [ctor@Gtk.PrintJob.new].
// 
// `GtkPrintUnixDialog` uses the following response values:
// 
// - GTK_RESPONSE_OK: for the Print button - GTK_RESPONSE_APPLY: for the
// Preview button - GTK_RESPONSE_CANCEL: for the Cancel button
// 
// 
// GtkPrintUnixDialog as GtkBuildable
// 
// The `GtkPrintUnixDialog` implementation of the `GtkBuildable` interface
// exposes its @notebook internal children with the name notebook.
// 
// An example of a `GtkPrintUnixDialog` UI definition fragment:
// 
// `xml <object class="GtkPrintUnixDialog" id="dialog1"> <child
// internal-child="notebook"> <object class="GtkNotebook" id="notebook"> <child>
// <object type="GtkNotebookPage"> <property name="tab_expand">False</property>
// <property name="tab_fill">False</property> <property name="tab"> <object
// class="GtkLabel" id="tablabel"> <property name="label">Tab label</property>
// </object> </property> <property name="child"> <object class="GtkLabel"
// id="tabcontent"> <property name="label">Content on notebook tab</property>
// </object> </property> </object> </child> </object> </child> </object> `
// 
// 
// CSS nodes
// 
// `GtkPrintUnixDialog` has a single CSS node with name window. The style
// classes dialog and print are added.
	type PrintUnixDialog struct {
		Dialog
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// PrintUnixDialogClass is an interface that the PrintUnixDialog class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrintUnixDialogClass interface {
		gextras.Objector
		_printUnixDialog()
	}

	func (PrintUnixDialog) _printUnixDialog() {}

	
	func marshalPrintUnixDialog(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrintUnixDialog(obj), nil
	}
	

	
	// NewPrintUnixDialog creates a new `GtkPrintUnixDialog`.
	func NewPrintUnixDialog(title string, parent WindowClass) PrintUnixDialog {
var _arg1 *C.char // out
var _arg2 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

_cret = C.gtk_print_unix_dialog_new(_arg1, _arg2)


var _printUnixDialog PrintUnixDialog // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_printUnixDialog = PrintUnixDialog{
Dialog: Dialog{
Window: Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _printUnixDialog
}
	

	
	// AddCustomTab adds a custom tab to the print dialog.
	func (d PrintUnixDialog) AddCustomTab(child WidgetClass, tabLabel WidgetClass)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(tabLabel.Native()))

C.gtk_print_unix_dialog_add_custom_tab(_arg0, _arg1, _arg2)
}
	
	// CurrentPage gets the current page of the `GtkPrintUnixDialog`.
	func (d PrintUnixDialog) CurrentPage() int {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret C.int // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_current_page(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// EmbedPageSetup gets whether to embed the page setup.
	func (d PrintUnixDialog) EmbedPageSetup() bool {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_embed_page_setup(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasSelection gets whether there is a selection.
	func (d PrintUnixDialog) HasSelection() bool {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_has_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ManualCapabilities gets the capabilities that have been set on this
// `GtkPrintUnixDialog`.
	func (d PrintUnixDialog) ManualCapabilities() PrintCapabilities {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret C.GtkPrintCapabilities // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_manual_capabilities(_arg0)


var _printCapabilities PrintCapabilities // out

_printCapabilities = PrintCapabilities(_cret)

return _printCapabilities
}
	
	// PageSetup gets the page setup that is used by the `GtkPrintUnixDialog`.
	func (d PrintUnixDialog) PageSetup() PageSetup {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_page_setup(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// PageSetupSet gets whether a page setup was set by the user.
	func (d PrintUnixDialog) PageSetupSet() bool {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_page_setup_set(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectedPrinter gets the currently selected printer.
	func (d PrintUnixDialog) SelectedPrinter() Printer {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret *C.GtkPrinter // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_selected_printer(_arg0)


var _printer Printer // out

_printer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Printer)

return _printer
}
	
	// Settings gets a new `GtkPrintSettings` object that represents the current
// values in the print dialog.
// 
// Note that this creates a new object, and you need to unref it if dont want
// to keep it.
	func (d PrintUnixDialog) Settings() PrintSettings {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret *C.GtkPrintSettings // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_settings(_arg0)


var _printSettings PrintSettings // out

_printSettings = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PrintSettings)

return _printSettings
}
	
	// SupportSelection gets whether the print dialog allows user to print a
// selection.
	func (d PrintUnixDialog) SupportSelection() bool {
var _arg0 *C.GtkPrintUnixDialog // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))

_cret = C.gtk_print_unix_dialog_get_support_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetCurrentPage sets the current page number.
// 
// If @current_page is not -1, this enables the current page choice for the
// range of pages to print.
	func (d PrintUnixDialog) SetCurrentPage(currentPage int)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 C.int // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.int)(currentPage)

C.gtk_print_unix_dialog_set_current_page(_arg0, _arg1)
}
	
	// SetEmbedPageSetup: embed page size combo box and orientation combo box into
// page setup page.
	func (d PrintUnixDialog) SetEmbedPageSetup(embed bool)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
if embed { _arg1 = C.TRUE }

C.gtk_print_unix_dialog_set_embed_page_setup(_arg0, _arg1)
}
	
	// SetHasSelection sets whether a selection exists.
	func (d PrintUnixDialog) SetHasSelection(hasSelection bool)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
if hasSelection { _arg1 = C.TRUE }

C.gtk_print_unix_dialog_set_has_selection(_arg0, _arg1)
}
	
	// SetManualCapabilities: this lets you specify the printing capabilities your
// application supports.
// 
// For instance, if you can handle scaling the output then you pass
// GTK_PRINT_CAPABILITY_SCALE. If you dont pass that, then the dialog will only
// let you select the scale if the printing system automatically handles
// scaling.
	func (d PrintUnixDialog) SetManualCapabilities(capabilities PrintCapabilities)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 C.GtkPrintCapabilities // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
_arg1 = (C.GtkPrintCapabilities)(capabilities)

C.gtk_print_unix_dialog_set_manual_capabilities(_arg0, _arg1)
}
	
	// SetPageSetup sets the page setup of the `GtkPrintUnixDialog`.
	func (d PrintUnixDialog) SetPageSetup(pageSetup PageSetupClass)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 *C.GtkPageSetup // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkPageSetup)(unsafe.Pointer(pageSetup.Native()))

C.gtk_print_unix_dialog_set_page_setup(_arg0, _arg1)
}
	
	// SetSettings sets the `GtkPrintSettings` for the `GtkPrintUnixDialog`.
// 
// Typically, this is used to restore saved print settings from a previous print
// operation before the print dialog is shown.
	func (d PrintUnixDialog) SetSettings(settings PrintSettingsClass)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 *C.GtkPrintSettings // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
_arg1 = (*C.GtkPrintSettings)(unsafe.Pointer(settings.Native()))

C.gtk_print_unix_dialog_set_settings(_arg0, _arg1)
}
	
	// SetSupportSelection sets whether the print dialog allows user to print a
// selection.
	func (d PrintUnixDialog) SetSupportSelection(supportSelection bool)  {
var _arg0 *C.GtkPrintUnixDialog // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkPrintUnixDialog)(unsafe.Pointer(d.Native()))
if supportSelection { _arg1 = C.TRUE }

C.gtk_print_unix_dialog_set_support_selection(_arg0, _arg1)
}
	


	// Printer: a `GtkPrinter` object represents a printer.
// 
// You only need to deal directly with printers if you use the non-portable
// [class@Gtk.PrintUnixDialog] API.
// 
// A `GtkPrinter` allows to get status information about the printer, such as
// its description, its location, the number of queued jobs, etc. Most
// importantly, a `GtkPrinter` object can be used to create a
// [class@Gtk.PrintJob] object, which lets you print to the printer.
	type Printer struct {
		**externglib.Object
		
	}

	// PrinterClass is an interface that the Printer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type PrinterClass interface {
		gextras.Objector
		_printer()
	}

	func (Printer) _printer() {}

	
	func marshalPrinter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapPrinter(obj), nil
	}
	

	
	// NewPrinter creates a new `GtkPrinter`.
	func NewPrinter(name string, backend *PrintBackend, virtual_ bool) Printer {
var _arg1 *C.char // out
var _arg2 *C.GtkPrintBackend // out
var _arg3 C.gboolean // out
var _cret *C.GtkPrinter // in

_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkPrintBackend)(unsafe.Pointer(backend.Native()))
if virtual_ { _arg3 = C.TRUE }

_cret = C.gtk_printer_new(_arg1, _arg2, _arg3)


var _printer Printer // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_printer = Printer{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _printer
}
	

	
	// AcceptsPDF returns whether the printer accepts input in PDF format.
	func (p Printer) AcceptsPDF() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_accepts_pdf(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AcceptsPS returns whether the printer accepts input in PostScript format.
	func (p Printer) AcceptsPS() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_accepts_ps(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Compare compares two printers.
	func (a Printer) Compare(b PrinterClass) int {
var _arg0 *C.GtkPrinter // out
var _arg1 *C.GtkPrinter // out
var _cret C.int // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkPrinter)(unsafe.Pointer(b.Native()))

_cret = C.gtk_printer_compare(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Backend returns the backend of the printer.
	func (p Printer) Backend() *PrintBackend {
var _arg0 *C.GtkPrinter // out
var _cret *C.GtkPrintBackend // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_backend(_arg0)


var _printBackend *PrintBackend // out

_printBackend = *(**PrintBackend)(unsafe.Pointer(&_cret))

return _printBackend
}
	
	// Capabilities returns the printers capabilities.
// 
// This is useful when youre using `GtkPrintUnixDialog`s manual-capabilities
// setting and need to know which settings the printer can handle and which you
// must handle yourself.
// 
// This will return 0 unless the printers details are available, see
// [method@Gtk.Printer.has_details] and [method@Gtk.Printer.request_details].
	func (p Printer) Capabilities() PrintCapabilities {
var _arg0 *C.GtkPrinter // out
var _cret C.GtkPrintCapabilities // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_capabilities(_arg0)


var _printCapabilities PrintCapabilities // out

_printCapabilities = PrintCapabilities(_cret)

return _printCapabilities
}
	
	// DefaultPageSize returns default page size of @printer.
	func (p Printer) DefaultPageSize() PageSetup {
var _arg0 *C.GtkPrinter // out
var _cret *C.GtkPageSetup // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_default_page_size(_arg0)


var _pageSetup PageSetup // out

_pageSetup = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(PageSetup)

return _pageSetup
}
	
	// Description gets the description of the printer.
	func (p Printer) Description() string {
var _arg0 *C.GtkPrinter // out
var _cret *C.char // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_description(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// HardMargins: retrieve the hard margins of @printer.
// 
// These are the margins that define the area at the borders of the paper that
// the printer cannot print to.
// 
// Note: This will not succeed unless the printers details are available, see
// [method@Gtk.Printer.has_details] and [method@Gtk.Printer.request_details].
	func (p Printer) HardMargins() (top float64, bottom float64, left float64, right float64, ok bool) {
var _arg0 *C.GtkPrinter // out
var _arg1 C.double // in
var _arg2 C.double // in
var _arg3 C.double // in
var _arg4 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_hard_margins(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)


var _top float64 // out
var _bottom float64 // out
var _left float64 // out
var _right float64 // out
var _ok bool // out

_top = (float64)(_arg1)
_bottom = (float64)(_arg2)
_left = (float64)(_arg3)
_right = (float64)(_arg4)
if _cret != 0 { _ok = true }

return _top, _bottom, _left, _right, _ok
}
	
	// HardMarginsForPaperSize: retrieve the hard margins of @printer for
// @paper_size.
// 
// These are the margins that define the area at the borders of the paper that
// the printer cannot print to.
// 
// Note: This will not succeed unless the printers details are available, see
// [method@Gtk.Printer.has_details] and [method@Gtk.Printer.request_details].
	func (p Printer) HardMarginsForPaperSize(paperSize *PaperSize) (top float64, bottom float64, left float64, right float64, ok bool) {
var _arg0 *C.GtkPrinter // out
var _arg1 *C.GtkPaperSize // out
var _arg2 C.double // in
var _arg3 C.double // in
var _arg4 C.double // in
var _arg5 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(paperSize.Native()))

_cret = C.gtk_printer_get_hard_margins_for_paper_size(_arg0, _arg1, &_arg2, &_arg3, &_arg4, &_arg5)


var _top float64 // out
var _bottom float64 // out
var _left float64 // out
var _right float64 // out
var _ok bool // out

_top = (float64)(_arg2)
_bottom = (float64)(_arg3)
_left = (float64)(_arg4)
_right = (float64)(_arg5)
if _cret != 0 { _ok = true }

return _top, _bottom, _left, _right, _ok
}
	
	// IconName gets the name of the icon to use for the printer.
	func (p Printer) IconName() string {
var _arg0 *C.GtkPrinter // out
var _cret *C.char // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// JobCount gets the number of jobs currently queued on the printer.
	func (p Printer) JobCount() int {
var _arg0 *C.GtkPrinter // out
var _cret C.int // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_job_count(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Location returns a description of the location of the printer.
	func (p Printer) Location() string {
var _arg0 *C.GtkPrinter // out
var _cret *C.char // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_location(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Name returns the name of the printer.
	func (p Printer) Name() string {
var _arg0 *C.GtkPrinter // out
var _cret *C.char // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// StateMessage returns the state message describing the current state of the
// printer.
	func (p Printer) StateMessage() string {
var _arg0 *C.GtkPrinter // out
var _cret *C.char // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_get_state_message(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// HasDetails returns whether the printer details are available.
	func (p Printer) HasDetails() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_has_details(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsAcceptingJobs returns whether the printer is accepting jobs
	func (p Printer) IsAcceptingJobs() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_is_accepting_jobs(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsActive returns whether the printer is currently active (i.e. accepts new
// jobs).
	func (p Printer) IsActive() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsDefault returns whether the printer is the default printer.
	func (p Printer) IsDefault() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_is_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsPaused returns whether the printer is currently paused.
// 
// A paused printer still accepts jobs, but it is not printing them.
	func (p Printer) IsPaused() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_is_paused(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsVirtual returns whether the printer is virtual (i.e. does not represent
// actual printer hardware, but something like a CUPS class).
	func (p Printer) IsVirtual() bool {
var _arg0 *C.GtkPrinter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

_cret = C.gtk_printer_is_virtual(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RequestDetails requests the printer details.
// 
// When the details are available, the [signal@Gtk.Printer::details-acquired]
// signal will be emitted on @printer.
	func (p Printer) RequestDetails()  {
var _arg0 *C.GtkPrinter // out

_arg0 = (*C.GtkPrinter)(unsafe.Pointer(p.Native()))

C.gtk_printer_request_details(_arg0)
}
	


	// ProgressBar: `GtkProgressBar` is typically used to display the progress of a
// long running operation.
// 
// It provides a visual clue that processing is underway. `GtkProgressBar` can
// be used in two different modes: percentage mode and activity mode.
// 
// !An example GtkProgressBar (progressbar.png)
// 
// When an application can determine how much work needs to take place (e.g.
// read a fixed number of bytes from a file) and can monitor its progress, it
// can use the `GtkProgressBar` in percentage mode and the user sees a growing
// bar indicating the percentage of the work that has been completed. In this
// mode, the application is required to call
// [method@Gtk.ProgressBar.set_fraction] periodically to update the progress
// bar.
// 
// When an application has no accurate way of knowing the amount of work to do,
// it can use the `GtkProgressBar` in activity mode, which shows activity by a
// block moving back and forth within the progress area. In this mode, the
// application is required to call [method@Gtk.ProgressBar.pulse] periodically
// to update the progress bar.
// 
// There is quite a bit of flexibility provided to control the appearance of the
// `GtkProgressBar`. Functions are provided to control the orientation of the
// bar, optional text can be displayed along with the bar, and the step size
// used in activity mode can be set.
// 
// 
// CSS nodes
// 
// ` progressbar[.osd]  [text]  trough[.empty][.full] 
// progress[.pulse] `
// 
// `GtkProgressBar` has a main CSS node with name progressbar and subnodes with
// names text and trough, of which the latter has a subnode named progress. The
// text subnode is only present if text is shown. The progress subnode has the
// style class .pulse when in activity mode. It gets the style classes .left,
// .right, .top or .bottom added when the progress 'touches' the corresponding
// end of the GtkProgressBar. The .osd class on the progressbar node is for use
// in overlays like the one Epiphany has for page loading progress.
// 
// 
// Accessibility
// 
// `GtkProgressBar` uses the K_ACCESSIBLE_ROLE_PROGRESS_BAR role.
	type ProgressBar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// ProgressBarClass is an interface that the ProgressBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ProgressBarClass interface {
		gextras.Objector
		_progressBar()
	}

	func (ProgressBar) _progressBar() {}

	
	func marshalProgressBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapProgressBar(obj), nil
	}
	

	
	// NewProgressBar creates a new `GtkProgressBar`.
	func NewProgressBar() ProgressBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_progress_bar_new()


var _progressBar ProgressBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_progressBar = ProgressBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _progressBar
}
	

	
	// Ellipsize returns the ellipsizing position of the progress bar.
// 
// See [method@Gtk.ProgressBar.set_ellipsize].
	func (p ProgressBar) Ellipsize() pango.EllipsizeMode {
var _arg0 *C.GtkProgressBar // out
var _cret C.PangoEllipsizeMode // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_ellipsize(_arg0)


var _ellipsizeMode pango.EllipsizeMode // out

_ellipsizeMode = pango.EllipsizeMode(_cret)

return _ellipsizeMode
}
	
	// Fraction returns the current fraction of the task thats been completed.
	func (p ProgressBar) Fraction() float64 {
var _arg0 *C.GtkProgressBar // out
var _cret C.double // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_fraction(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Inverted returns whether the progress bar is inverted.
	func (p ProgressBar) Inverted() bool {
var _arg0 *C.GtkProgressBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_inverted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PulseStep retrieves the pulse step.
// 
// See [method@Gtk.ProgressBar.set_pulse_step].
	func (p ProgressBar) PulseStep() float64 {
var _arg0 *C.GtkProgressBar // out
var _cret C.double // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_pulse_step(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// ShowText returns whether the `GtkProgressBar` shows text.
// 
// See [method@Gtk.ProgressBar.set_show_text].
	func (p ProgressBar) ShowText() bool {
var _arg0 *C.GtkProgressBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_show_text(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Text retrieves the text that is displayed with the progress bar.
// 
// The return value is a reference to the text, not a copy of it, so will become
// invalid if you change the text in the progress bar.
	func (p ProgressBar) Text() string {
var _arg0 *C.GtkProgressBar // out
var _cret *C.char // in

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

_cret = C.gtk_progress_bar_get_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Pulse indicates that some progress has been made, but you dont know how
// much.
// 
// Causes the progress bar to enter activity mode, where a block bounces back
// and forth. Each call to [method@Gtk.ProgressBar.pulse] causes the block to
// move by a little bit (the amount of movement per pulse is determined by
// [method@Gtk.ProgressBar.set_pulse_step]).
	func (p ProgressBar) Pulse()  {
var _arg0 *C.GtkProgressBar // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))

C.gtk_progress_bar_pulse(_arg0)
}
	
	// SetEllipsize sets the mode used to ellipsize the text.
// 
// The text is ellipsized if there is not enough space to render the entire
// string.
	func (p ProgressBar) SetEllipsize(mode pango.EllipsizeMode)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.PangoEllipsizeMode // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (C.PangoEllipsizeMode)(mode)

C.gtk_progress_bar_set_ellipsize(_arg0, _arg1)
}
	
	// SetFraction causes the progress bar to fill in the given fraction of the
// bar.
// 
// The fraction should be between 0.0 and 1.0, inclusive.
	func (p ProgressBar) SetFraction(fraction float64)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.double // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (C.double)(fraction)

C.gtk_progress_bar_set_fraction(_arg0, _arg1)
}
	
	// SetInverted sets whether the progress bar is inverted.
// 
// Progress bars normally grow from top to bottom or left to right. Inverted
// progress bars grow in the opposite direction.
	func (p ProgressBar) SetInverted(inverted bool)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
if inverted { _arg1 = C.TRUE }

C.gtk_progress_bar_set_inverted(_arg0, _arg1)
}
	
	// SetPulseStep sets the fraction of total progress bar length to move the
// bouncing block.
// 
// The bouncing block is moved when [method@Gtk.ProgressBar.pulse] is called.
	func (p ProgressBar) SetPulseStep(fraction float64)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.double // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (C.double)(fraction)

C.gtk_progress_bar_set_pulse_step(_arg0, _arg1)
}
	
	// SetShowText sets whether the progress bar will show text next to the bar.
// 
// The shown text is either the value of the [property@Gtk.ProgressBar:text]
// property or, if that is nil, the [property@Gtk.ProgressBar:fraction] value,
// as a percentage.
// 
// To make a progress bar that is styled and sized suitably for containing text
// (even if the actual text is blank), set [property@Gtk.ProgressBar:show-text]
// to true and [property@Gtk.ProgressBar:text] to the empty string (not nil).
	func (p ProgressBar) SetShowText(showText bool)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
if showText { _arg1 = C.TRUE }

C.gtk_progress_bar_set_show_text(_arg0, _arg1)
}
	
	// SetText causes the given @text to appear next to the progress bar.
// 
// If @text is nil and [property@Gtk.ProgressBar:show-text] is true, the current
// value of [property@Gtk.ProgressBar:fraction] will be displayed as a
// percentage.
// 
// If @text is non-nil and [property@Gtk.ProgressBar:show-text] is true, the
// text will be displayed. In this case, it will not display the progress
// percentage. If @text is the empty string, the progress bar will still be
// styled and sized suitably for containing text, as long as
// [property@Gtk.ProgressBar:show-text] is true.
	func (p ProgressBar) SetText(text string)  {
var _arg0 *C.GtkProgressBar // out
var _arg1 *C.char // out

_arg0 = (*C.GtkProgressBar)(unsafe.Pointer(p.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_progress_bar_set_text(_arg0, _arg1)
}
	


	// Range: `GtkRange` is the common base class for widgets which visualize an
// adjustment.
// 
// Widgets that are derived from `GtkRange` include [class@Gtk.Scale] and
// [class@Gtk.Scrollbar].
// 
// Apart from signals for monitoring the parameters of the adjustment,
// `GtkRange` provides properties and methods for setting a fill level on
// range widgets. See [method@Gtk.Range.set_fill_level].
	type Range struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// RangeClass is an interface that the Range class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RangeClass interface {
		gextras.Objector
		__range()
	}

	func (Range) __range() {}

	
	func marshalRange(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRange(obj), nil
	}
	

	

	
	// Adjustment: get the adjustment which is the model object for `GtkRange`.
	func (r Range) Adjustment() Adjustment {
var _arg0 *C.GtkRange // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// FillLevel gets the current position of the fill level indicator.
	func (r Range) FillLevel() float64 {
var _arg0 *C.GtkRange // out
var _cret C.double // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_fill_level(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Flippable gets whether the `GtkRange` respects text direction.
// 
// See [method@Gtk.Range.set_flippable].
	func (r Range) Flippable() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_flippable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Inverted gets whether the range is inverted.
// 
// See [method@Gtk.Range.set_inverted].
	func (r Range) Inverted() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_inverted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RangeRect: this function returns the area that contains the ranges trough,
// in coordinates relative to @range's origin.
// 
// This function is useful mainly for `GtkRange` subclasses.
	func (r Range) RangeRect() gdk.Rectangle {
var _arg0 *C.GtkRange // out
var _rangeRect gdk.Rectangle

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

C.gtk_range_get_range_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_rangeRect)))





return _rangeRect
}
	
	// RestrictToFillLevel gets whether the range is restricted to the fill level.
	func (r Range) RestrictToFillLevel() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_restrict_to_fill_level(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RoundDigits gets the number of digits to round the value to when it changes.
// 
// See [signal@Gtk.Range::change-value].
	func (r Range) RoundDigits() int {
var _arg0 *C.GtkRange // out
var _cret C.int // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_round_digits(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ShowFillLevel gets whether the range displays the fill level graphically.
	func (r Range) ShowFillLevel() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_show_fill_level(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SliderRange: this function returns sliders range along the long dimension, in
// widget->window coordinates.
// 
// This function is useful mainly for `GtkRange` subclasses.
	func (r Range) SliderRange() (sliderStart int, sliderEnd int) {
var _arg0 *C.GtkRange // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

C.gtk_range_get_slider_range(_arg0, &_arg1, &_arg2)

var _sliderStart int // out
var _sliderEnd int // out

_sliderStart = (int)(_arg1)
_sliderEnd = (int)(_arg2)

return _sliderStart, _sliderEnd
}
	
	// SliderSizeFixed: this function is useful mainly for `GtkRange` subclasses.
// 
// See [method@Gtk.Range.set_slider_size_fixed].
	func (r Range) SliderSizeFixed() bool {
var _arg0 *C.GtkRange // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_slider_size_fixed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Value gets the current value of the range.
	func (r Range) Value() float64 {
var _arg0 *C.GtkRange // out
var _cret C.double // in

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))

_cret = C.gtk_range_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetAdjustment sets the adjustment to be used as the model object for the
// `GtkRange`
// 
// The adjustment indicates the current range value, the minimum and maximum
// range values, the step/page increments used for keybindings and scrolling,
// and the page size.
// 
// The page size is normally 0 for `GtkScale` and nonzero for `GtkScrollbar`,
// and indicates the size of the visible area of the widget being scrolled. The
// page size affects the size of the scrollbar slider.
	func (r Range) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkRange // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_range_set_adjustment(_arg0, _arg1)
}
	
	// SetFillLevel: set the new position of the fill level indicator.
// 
// The fill level is probably best described by its most prominent use case,
// which is an indicator for the amount of pre-buffering in a streaming media
// player. In that use case, the value of the range would indicate the current
// play position, and the fill level would be the position up to which the
// file/stream has been downloaded.
// 
// This amount of prebuffering can be displayed on the ranges trough and is
// themeable separately from the trough. To enable fill level display, use
// [method@Gtk.Range.set_show_fill_level]. The range defaults to not showing the
// fill level.
// 
// Additionally, its possible to restrict the ranges slider position to values
// which are smaller than the fill level. This is controlled by
// [method@Gtk.Range.set_restrict_to_fill_level] and is by default enabled.
	func (r Range) SetFillLevel(fillLevel float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.double // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.double)(fillLevel)

C.gtk_range_set_fill_level(_arg0, _arg1)
}
	
	// SetFlippable sets whether the `GtkRange` respects text direction.
// 
// If a range is flippable, it will switch its direction if it is horizontal and
// its direction is GTK_TEXT_DIR_RTL.
// 
// See [method@Gtk.Widget.get_direction].
	func (r Range) SetFlippable(flippable bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if flippable { _arg1 = C.TRUE }

C.gtk_range_set_flippable(_arg0, _arg1)
}
	
	// SetIncrements sets the step and page sizes for the range.
// 
// The step size is used when the user clicks the `GtkScrollbar` arrows or moves
// a `GtkScale` via arrow keys. The page size is used for example when moving
// via Page Up or Page Down keys.
	func (r Range) SetIncrements(step float64, page float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.double // out
var _arg2 C.double // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.double)(step)
_arg2 = (C.double)(page)

C.gtk_range_set_increments(_arg0, _arg1, _arg2)
}
	
	// SetInverted sets whether to invert the range.
// 
// Ranges normally move from lower to higher values as the slider moves from top
// to bottom or left to right. Inverted ranges have higher values at the top or
// on the right rather than on the bottom or left.
	func (r Range) SetInverted(setting bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_range_set_inverted(_arg0, _arg1)
}
	
	// SetRange sets the allowable values in the `GtkRange`.
// 
// The range value is clamped to be between @min and @max. (If the range has a
// non-zero page size, it is clamped between @min and @max - page-size.)
	func (r Range) SetRange(min float64, max float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.double // out
var _arg2 C.double // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.double)(min)
_arg2 = (C.double)(max)

C.gtk_range_set_range(_arg0, _arg1, _arg2)
}
	
	// SetRestrictToFillLevel sets whether the slider is restricted to the fill
// level.
// 
// See [method@Gtk.Range.set_fill_level] for a general description of the fill
// level concept.
	func (r Range) SetRestrictToFillLevel(restrictToFillLevel bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if restrictToFillLevel { _arg1 = C.TRUE }

C.gtk_range_set_restrict_to_fill_level(_arg0, _arg1)
}
	
	// SetRoundDigits sets the number of digits to round the value to when it
// changes.
// 
// See [signal@Gtk.Range::change-value].
	func (r Range) SetRoundDigits(roundDigits int)  {
var _arg0 *C.GtkRange // out
var _arg1 C.int // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.int)(roundDigits)

C.gtk_range_set_round_digits(_arg0, _arg1)
}
	
	// SetShowFillLevel sets whether a graphical fill level is show on the trough.
// 
// See [method@Gtk.Range.set_fill_level] for a general description of the fill
// level concept.
	func (r Range) SetShowFillLevel(showFillLevel bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if showFillLevel { _arg1 = C.TRUE }

C.gtk_range_set_show_fill_level(_arg0, _arg1)
}
	
	// SetSliderSizeFixed sets whether the ranges slider has a fixed size, or a
// size that depends on its adjustments page size.
// 
// This function is useful mainly for `GtkRange` subclasses.
	func (r Range) SetSliderSizeFixed(sizeFixed bool)  {
var _arg0 *C.GtkRange // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
if sizeFixed { _arg1 = C.TRUE }

C.gtk_range_set_slider_size_fixed(_arg0, _arg1)
}
	
	// SetValue sets the current value of the range.
// 
// If the value is outside the minimum or maximum range values, it will be
// clamped to fit inside them. The range emits the
// [signal@Gtk.Range::value-changed] signal if the value changes.
	func (r Range) SetValue(value float64)  {
var _arg0 *C.GtkRange // out
var _arg1 C.double // out

_arg0 = (*C.GtkRange)(unsafe.Pointer(r.Native()))
_arg1 = (C.double)(value)

C.gtk_range_set_value(_arg0, _arg1)
}
	


	// RecentManager: `GtkRecentManager` manages and looks up recently used files.
// 
// Each recently used file is identified by its URI, and has meta-data
// associated to it, like the names and command lines of the applications that
// have registered it, the number of time each application has registered the
// same file, the mime type of the file and whether the file should be displayed
// only by the applications that have registered it.
// 
// The recently used files list is per user.
// 
// `GtkRecentManager` acts like a database of all the recently used files. You
// can create new `GtkRecentManager` objects, but it is more efficient to use
// the default manager created by GTK.
// 
// Adding a new recently used file is as simple as:
// 
// `c GtkRecentManager *manager;
// 
// manager = gtk_recent_manager_get_default (); gtk_recent_manager_add_item
// (manager, file_uri); `
// 
// The `GtkRecentManager` will try to gather all the needed information from the
// file itself through GIO.
// 
// Looking up the meta-data associated with a recently used file given its URI
// requires calling [method@Gtk.RecentManager.lookup_item]:
// 
// `c GtkRecentManager *manager; GtkRecentInfo *info; GError *error = NULL;
// 
// manager = gtk_recent_manager_get_default (); info =
// gtk_recent_manager_lookup_item (manager, file_uri, &error); if (error) {
// g_warning ("Could not find the file: s", error->message); g_error_free
// (error); } else { // Use the info object gtk_recent_info_unref (info); } `
// 
// In order to retrieve the list of recently used files, you can use
// [method@Gtk.RecentManager.get_items], which returns a list of
// [struct@Gtk.RecentInfo].
// 
// Note that the maximum age of the recently used files list is controllable
// through the [property@Gtk.Settings:gtk-recent-files-max-age] property.
	type RecentManager struct {
		**externglib.Object
		
	}

	// RecentManagerClass is an interface that the RecentManager class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RecentManagerClass interface {
		gextras.Objector
		_recentManager()
	}

	func (RecentManager) _recentManager() {}

	
	func marshalRecentManager(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRecentManager(obj), nil
	}
	

	
	// NewRecentManager creates a new recent manager object.
// 
// Recent manager objects are used to handle the list of recently used
// resources. A `GtkRecentManager` object monitors the recently used resources
// list, and emits the [signal@Gtk.RecentManager::changed] signal each time
// something inside the list changes.
// 
// `GtkRecentManager` objects are expensive: be sure to create them only when
// needed. You should use [type_func@Gtk.RecentManager.get_default] instead.
	func NewRecentManager() RecentManager {
var _cret *C.GtkRecentManager // in

_cret = C.gtk_recent_manager_new()


var _recentManager RecentManager // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_recentManager = RecentManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _recentManager
}
	

	
	// AddFull adds a new resource, pointed by @uri, into the recently used
// resources list, using the metadata specified inside the `GtkRecentData`
// passed in @recent_data.
// 
// The passed URI will be used to identify this resource inside the list.
// 
// In order to register the new recently used resource, metadata about the
// resource must be passed as well as the URI; the metadata is stored in a
// `GtkRecentData`, which must contain the MIME type of the resource pointed by
// the URI; the name of the application that is registering the item, and a
// command line to be used when launching the item.
// 
// Optionally, a `GtkRecentData` might contain a UTF-8 string to be used when
// viewing the item instead of the last component of the URI; a short
// description of the item; whether the item should be considered private - that
// is, should be displayed only by the applications that have registered it.
	func (m RecentManager) AddFull(uri string, recentData *RecentData) bool {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.char // out
var _arg2 *C.GtkRecentData // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkRecentData)(unsafe.Pointer(recentData.Native()))

_cret = C.gtk_recent_manager_add_full(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AddItem adds a new resource, pointed by @uri, into the recently used
// resources list.
// 
// This function automatically retrieves some of the needed metadata and setting
// other metadata to common default values; it then feeds the data to
// [method@Gtk.RecentManager.add_full].
// 
// See [method@Gtk.RecentManager.add_full] if you want to explicitly define the
// metadata for the resource pointed by @uri.
	func (m RecentManager) AddItem(uri string) bool {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_manager_add_item(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasItem checks whether there is a recently used resource registered with @uri
// inside the recent manager.
	func (m RecentManager) HasItem(uri string) bool {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_manager_has_item(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LookupItem searches for a URI inside the recently used resources list, and
// returns a `GtkRecentInfo` containing information about the resource like its
// MIME type, or its display name.
	func (m RecentManager) LookupItem(uri string) (*RecentInfo, error) {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.char // out
var _cret *C.GtkRecentInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_manager_lookup_item(_arg0, _arg1, &_cerr)


var _recentInfo *RecentInfo // out
var _goerr error // out

_recentInfo = *(**RecentInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _recentInfo, _goerr
}
	
	// MoveItem changes the location of a recently used resource from @uri to
// @new_uri.
// 
// Please note that this function will not affect the resource pointed by the
// URIs, but only the URI used in the recently used resources list.
	func (m RecentManager) MoveItem(uri string, newUri string) error {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.char // out
var _arg2 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(newUri))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_recent_manager_move_item(_arg0, _arg1, _arg2, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	
	// PurgeItems purges every item from the recently used resources list.
	func (m RecentManager) PurgeItems() (int, error) {
var _arg0 *C.GtkRecentManager // out
var _cret C.int // in
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))

_cret = C.gtk_recent_manager_purge_items(_arg0, &_cerr)


var _gint int // out
var _goerr error // out

_gint = (int)(_cret)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _gint, _goerr
}
	
	// RemoveItem removes a resource pointed by @uri from the recently used
// resources list handled by a recent manager.
	func (m RecentManager) RemoveItem(uri string) error {
var _arg0 *C.GtkRecentManager // out
var _arg1 *C.char // out
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentManager)(unsafe.Pointer(m.Native()))
_arg1 = (*C.char)(C.CString(uri))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_recent_manager_remove_item(_arg0, _arg1, &_cerr)

var _goerr error // out

_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _goerr
}
	


	// Revealer: a `GtkRevealer` animates the transition of its child from invisible
// to visible.
// 
// The style of transition can be controlled with
// [method@Gtk.Revealer.set_transition_type].
// 
// These animations respect the [property@Gtk.Settings:gtk-enable-animations]
// setting.
// 
// 
// CSS nodes
// 
// `GtkRevealer` has a single CSS node with name revealer. When styling
// `GtkRevealer` using CSS, remember that it only hides its contents, not
// itself. That means applied margin, padding and borders will be visible even
// when the [property@Gtk.Revealer:reveal-child] property is set to false.
// 
// 
// Accessibility
// 
// `GtkRevealer` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
// 
// The child of `GtkRevealer`, if set, is always available in the accessibility
// tree, regardless of the state of the revealer widget.
	type Revealer struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// RevealerClass is an interface that the Revealer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type RevealerClass interface {
		gextras.Objector
		_revealer()
	}

	func (Revealer) _revealer() {}

	
	func marshalRevealer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapRevealer(obj), nil
	}
	

	
	// NewRevealer creates a new `GtkRevealer`.
	func NewRevealer() Revealer {
var _cret *C.GtkWidget // in

_cret = C.gtk_revealer_new()


var _revealer Revealer // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_revealer = Revealer{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _revealer
}
	

	
	// Child gets the child widget of @revealer.
	func (r Revealer) Child() Widget {
var _arg0 *C.GtkRevealer // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ChildRevealed returns whether the child is fully revealed.
// 
// In other words, this returns whether the transition to the revealed state is
// completed.
	func (r Revealer) ChildRevealed() bool {
var _arg0 *C.GtkRevealer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_child_revealed(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RevealChild returns whether the child is currently revealed.
// 
// This function returns true as soon as the transition is to the revealed state
// is started. To learn whether the child is fully revealed (ie the transition
// is completed), use [method@Gtk.Revealer.get_child_revealed].
	func (r Revealer) RevealChild() bool {
var _arg0 *C.GtkRevealer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_reveal_child(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TransitionDuration returns the amount of time (in milliseconds) that
// transitions will take.
	func (r Revealer) TransitionDuration() uint {
var _arg0 *C.GtkRevealer // out
var _cret C.guint // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_transition_duration(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// TransitionType gets the type of animation that will be used for transitions
// in @revealer.
	func (r Revealer) TransitionType() RevealerTransitionType {
var _arg0 *C.GtkRevealer // out
var _cret C.GtkRevealerTransitionType // in

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))

_cret = C.gtk_revealer_get_transition_type(_arg0)


var _revealerTransitionType RevealerTransitionType // out

_revealerTransitionType = RevealerTransitionType(_cret)

return _revealerTransitionType
}
	
	// SetChild sets the child widget of @revealer.
	func (r Revealer) SetChild(child WidgetClass)  {
var _arg0 *C.GtkRevealer // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_revealer_set_child(_arg0, _arg1)
}
	
	// SetRevealChild tells the `GtkRevealer` to reveal or conceal its child.
// 
// The transition will be animated with the current transition type of
// @revealer.
	func (r Revealer) SetRevealChild(revealChild bool)  {
var _arg0 *C.GtkRevealer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
if revealChild { _arg1 = C.TRUE }

C.gtk_revealer_set_reveal_child(_arg0, _arg1)
}
	
	// SetTransitionDuration sets the duration that transitions will take.
	func (r Revealer) SetTransitionDuration(duration uint)  {
var _arg0 *C.GtkRevealer // out
var _arg1 C.guint // out

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
_arg1 = (C.guint)(duration)

C.gtk_revealer_set_transition_duration(_arg0, _arg1)
}
	
	// SetTransitionType sets the type of animation that will be used for
// transitions in @revealer.
// 
// Available types include various kinds of fades and slides.
	func (r Revealer) SetTransitionType(transition RevealerTransitionType)  {
var _arg0 *C.GtkRevealer // out
var _arg1 C.GtkRevealerTransitionType // out

_arg0 = (*C.GtkRevealer)(unsafe.Pointer(r.Native()))
_arg1 = (C.GtkRevealerTransitionType)(transition)

C.gtk_revealer_set_transition_type(_arg0, _arg1)
}
	


	// Scale: a `GtkScale` is a slider control used to select a numeric value.
// 
// !An example GtkScale (scales.png)
// 
// To use it, youll probably want to investigate the methods on its base class,
// [class@GtkRange], in addition to the methods for `GtkScale` itself. To set
// the value of a scale, you would normally use [method@Gtk.Range.set_value]. To
// detect changes to the value, you would normally use the
// [signal@Gtk.Range::value-changed] signal.
// 
// Note that using the same upper and lower bounds for the `GtkScale` (through
// the `GtkRange` methods) will hide the slider itself. This is useful for
// applications that want to show an undeterminate value on the scale, without
// changing the layout of the application (such as movie or music players).
// 
// 
// GtkScale as GtkBuildable
// 
// `GtkScale` supports a custom <marks> element, which can contain multiple
// <mark\> elements. The value and position attributes have the same meaning
// as [method@Gtk.Scale.add_mark] parameters of the same name. If the element is
// not empty, its content is taken as the markup to show at the mark. It can be
// translated with the usual translatable and context attributes.
// 
// 
// CSS nodes
// 
// ` scale[.fine-tune][.marks-before][.marks-after] 
// [value][.top][.right][.bottom][.left]  marks.top   mark   
// [label]    indicator     mark  marks.bottom   mark   
// indicator    [label]     mark  trough  [fill] 
// [highlight]  slider `
// 
// `GtkScale` has a main CSS node with name scale and a subnode for its
// contents, with subnodes named trough and slider.
// 
// The main node gets the style class .fine-tune added when the scale is in
// 'fine-tuning' mode.
// 
// If the scale has an origin (see [method@Gtk.Scale.set_has_origin]), there is
// a subnode with name highlight below the trough node that is used for
// rendering the highlighted part of the trough.
// 
// If the scale is showing a fill level (see
// [method@Gtk.Range.set_show_fill_level]), there is a subnode with name fill
// below the trough node that is used for rendering the filled in part of the
// trough.
// 
// If marks are present, there is a marks subnode before or after the trough
// node, below which each mark gets a node with name mark. The marks nodes get
// either the .top or .bottom style class.
// 
// The mark node has a subnode named indicator. If the mark has text, it also
// has a subnode named label. When the mark is either above or left of the
// scale, the label subnode is the first when present. Otherwise, the indicator
// subnode is the first.
// 
// The main CSS node gets the 'marks-before' and/or 'marks-after' style classes
// added depending on what marks are present.
// 
// If the scale is displaying the value (see [property@Gtk.Scale:draw-value]),
// there is subnode with name value. This node will get the .top or .bottom
// style classes similar to the marks node.
// 
// 
// Accessibility
// 
// `GtkScale` uses the GTK_ACCESSIBLE_ROLE_SLIDER role.
	type Scale struct {
		Range
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// ScaleClass is an interface that the Scale class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScaleClass interface {
		gextras.Objector
		_scale()
	}

	func (Scale) _scale() {}

	
	func marshalScale(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScale(obj), nil
	}
	

	
	// NewScale creates a new `GtkScale`.
	func NewScale(orientation Orientation, adjustment AdjustmentClass) Scale {
var _arg1 C.GtkOrientation // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_scale_new(_arg1, _arg2)


var _scale Scale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scale = Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scale
}
	
	// NewScaleWithRange creates a new scale widget with a range from @min to @max.
// 
// The returns scale will have the given orientation and will let the user input
// a number between @min and @max (including @min and @max) with the increment
// @step. @step must be nonzero; its the distance the slider moves when using
// the arrow keys to adjust the scale value.
// 
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// [method@Gtk.Scale.set_digits] to correct it.
	func NewScaleWithRange(orientation Orientation, min float64, max float64, step float64) Scale {
var _arg1 C.GtkOrientation // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 C.double // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (C.double)(min)
_arg3 = (C.double)(max)
_arg4 = (C.double)(step)

_cret = C.gtk_scale_new_with_range(_arg1, _arg2, _arg3, _arg4)


var _scale Scale // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scale = Scale{
Range: Range{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scale
}
	

	
	// AddMark adds a mark at @value.
// 
// A mark is indicated visually by drawing a tick mark next to the scale, and
// GTK makes it easy for the user to position the scale exactly at the marks
// value.
// 
// If @markup is not nil, text is shown next to the tick mark.
// 
// To remove marks from a scale, use [method@Gtk.Scale.clear_marks].
	func (s Scale) AddMark(value float64, position PositionType, markup string)  {
var _arg0 *C.GtkScale // out
var _arg1 C.double // out
var _arg2 C.GtkPositionType // out
var _arg3 *C.char // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(value)
_arg2 = (C.GtkPositionType)(position)
_arg3 = (*C.char)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg3))

C.gtk_scale_add_mark(_arg0, _arg1, _arg2, _arg3)
}
	
	// ClearMarks removes any marks that have been added.
	func (s Scale) ClearMarks()  {
var _arg0 *C.GtkScale // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

C.gtk_scale_clear_marks(_arg0)
}
	
	// Digits gets the number of decimal places that are displayed in the value.
	func (s Scale) Digits() int {
var _arg0 *C.GtkScale // out
var _cret C.int // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_digits(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// DrawValue returns whether the current value is displayed as a string next to
// the slider.
	func (s Scale) DrawValue() bool {
var _arg0 *C.GtkScale // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_draw_value(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasOrigin returns whether the scale has an origin.
	func (s Scale) HasOrigin() bool {
var _arg0 *C.GtkScale // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_has_origin(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Layout gets the `PangoLayout` used to display the scale.
// 
// The returned object is owned by the scale so does not need to be freed by the
// caller.
	func (s Scale) Layout() pango.Layout {
var _arg0 *C.GtkScale // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_layout(_arg0)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// LayoutOffsets obtains the coordinates where the scale will draw the
// `PangoLayout` representing the text in the scale.
// 
// Remember when using the `PangoLayout` function you need to convert to and
// from pixels using `PANGO_PIXELS()` or `PANGO_SCALE`.
// 
// If the [property@GtkScale:draw-value] property is false, the return values
// are undefined.
	func (s Scale) LayoutOffsets() (x int, y int) {
var _arg0 *C.GtkScale // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

C.gtk_scale_get_layout_offsets(_arg0, &_arg1, &_arg2)

var _x int // out
var _y int // out

_x = (int)(_arg1)
_y = (int)(_arg2)

return _x, _y
}
	
	// ValuePos gets the position in which the current value is displayed.
	func (s Scale) ValuePos() PositionType {
var _arg0 *C.GtkScale // out
var _cret C.GtkPositionType // in

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scale_get_value_pos(_arg0)


var _positionType PositionType // out

_positionType = PositionType(_cret)

return _positionType
}
	
	// SetDigits sets the number of decimal places that are displayed in the value.
// 
// Also causes the value of the adjustment to be rounded to this number of
// digits, so the retrieved value matches the displayed one, if
// [property@GtkScale:draw-value] is true when the value changes. If you want to
// enforce rounding the value when [property@GtkScale:draw-value] is false, you
// can set [property@GtkRange:round-digits] instead.
// 
// Note that rounding to a small number of digits can interfere with the smooth
// autoscrolling that is built into `GtkScale`. As an alternative, you can use
// [method@Gtk.Scale.set_format_value_func] to format the displayed value
// yourself.
	func (s Scale) SetDigits(digits int)  {
var _arg0 *C.GtkScale // out
var _arg1 C.int // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(digits)

C.gtk_scale_set_digits(_arg0, _arg1)
}
	
	// SetDrawValue specifies whether the current value is displayed as a string
// next to the slider.
	func (s Scale) SetDrawValue(drawValue bool)  {
var _arg0 *C.GtkScale // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
if drawValue { _arg1 = C.TRUE }

C.gtk_scale_set_draw_value(_arg0, _arg1)
}
	
	// SetHasOrigin sets whether the scale has an origin.
// 
// If [property@GtkScale:has-origin] is set to true (the default), the scale
// will highlight the part of the trough between the origin (bottom or left
// side) and the current value.
	func (s Scale) SetHasOrigin(hasOrigin bool)  {
var _arg0 *C.GtkScale // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
if hasOrigin { _arg1 = C.TRUE }

C.gtk_scale_set_has_origin(_arg0, _arg1)
}
	
	// SetValuePos sets the position in which the current value is displayed.
	func (s Scale) SetValuePos(pos PositionType)  {
var _arg0 *C.GtkScale // out
var _arg1 C.GtkPositionType // out

_arg0 = (*C.GtkScale)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPositionType)(pos)

C.gtk_scale_set_value_pos(_arg0, _arg1)
}
	


	// ScaleButton: `GtkScaleButton` provides a button which pops up a scale widget.
// 
// This kind of widget is commonly used for volume controls in multimedia
// applications, and GTK provides a [class@Gtk.VolumeButton] subclass that is
// tailored for this use case.
// 
// 
// CSS nodes
// 
// `GtkScaleButton` has a single CSS node with name button. To differentiate it
// from a plain `GtkButton`, it gets the .scale style class.
	type ScaleButton struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// ScaleButtonClass is an interface that the ScaleButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScaleButtonClass interface {
		gextras.Objector
		_scaleButton()
	}

	func (ScaleButton) _scaleButton() {}

	
	func marshalScaleButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScaleButton(obj), nil
	}
	

	
	// NewScaleButton creates a `GtkScaleButton`.
// 
// The new scale button has a range between @min and @max, with a stepping of
// @step.
	func NewScaleButton(min float64, max float64, step float64, icons []string) ScaleButton {
var _arg1 C.double // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 **C.char
var _cret *C.GtkWidget // in

_arg1 = (C.double)(min)
_arg2 = (C.double)(max)
_arg3 = (C.double)(step)
_arg4 = (**C.char)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg4))
{
out := unsafe.Slice(_arg4, len(icons))
for i := range icons {
out[i] = (*C.char)(C.CString(icons[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

_cret = C.gtk_scale_button_new(_arg1, _arg2, _arg3, _arg4)


var _scaleButton ScaleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scaleButton = ScaleButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scaleButton
}
	

	
	// Adjustment gets the `GtkAdjustment` associated with the `GtkScaleButton`s
// scale.
// 
// See [method@Gtk.Range.get_adjustment] for details.
	func (b ScaleButton) Adjustment() Adjustment {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// MinusButton retrieves the minus button of the `GtkScaleButton`.
	func (b ScaleButton) MinusButton() Button {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_minus_button(_arg0)


var _ret Button // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

return _ret
}
	
	// PlusButton retrieves the plus button of the `GtkScaleButton.`
	func (b ScaleButton) PlusButton() Button {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_plus_button(_arg0)


var _ret Button // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Button)

return _ret
}
	
	// Popup retrieves the popup of the `GtkScaleButton`.
	func (b ScaleButton) Popup() Widget {
var _arg0 *C.GtkScaleButton // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_popup(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Value gets the current value of the scale button.
	func (b ScaleButton) Value() float64 {
var _arg0 *C.GtkScaleButton // out
var _cret C.double // in

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))

_cret = C.gtk_scale_button_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// SetAdjustment sets the `GtkAdjustment` to be used as a model for the
// `GtkScaleButton`s scale.
// 
// See [method@Gtk.Range.set_adjustment] for details.
	func (b ScaleButton) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkScaleButton // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_scale_button_set_adjustment(_arg0, _arg1)
}
	
	// SetIcons sets the icons to be used by the scale button.
	func (b ScaleButton) SetIcons(icons []string)  {
var _arg0 *C.GtkScaleButton // out
var _arg1 **C.char

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
_arg1 = (**C.char)(C.malloc(C.ulong(len(icons)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(icons))
for i := range icons {
out[i] = (*C.char)(C.CString(icons[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_scale_button_set_icons(_arg0, _arg1)
}
	
	// SetValue sets the current value of the scale.
// 
// If the value is outside the minimum or maximum range values, it will be
// clamped to fit inside them.
// 
// The scale button emits the [signal@Gtk.ScaleButton::value-changed] signal if
// the value changes.
	func (b ScaleButton) SetValue(value float64)  {
var _arg0 *C.GtkScaleButton // out
var _arg1 C.double // out

_arg0 = (*C.GtkScaleButton)(unsafe.Pointer(b.Native()))
_arg1 = (C.double)(value)

C.gtk_scale_button_set_value(_arg0, _arg1)
}
	


	// Scrollbar: the `GtkScrollbar` widget is a horizontal or vertical scrollbar.
// 
// !An example GtkScrollbar (scrollbar.png)
// 
// Its position and movement are controlled by the adjustment that is passed to
// or created by [ctor@Gtk.Scrollbar.new]. See [class.Gtk.Adjustment] for more
// details. The [property@Gtk.Adjustment:value] field sets the position of the
// thumb and must be between [property@Gtk.Adjustment:lower] and
// [property@Gtk.Adjustment:upper] - [property@Gtk.Adjustment:page-size]. The
// [property@Gtk.Adjustment:page-size] represents the size of the visible
// scrollable area.
// 
// The fields [property@Gtk.Adjustment:step-increment] and
// [property@Gtk.Adjustment:page-increment] fields are added to or subtracted
// from the [property@Gtk.Adjustment:value] when the user asks to move by a step
// (using e.g. the cursor arrow keys) or by a page (using e.g. the Page Down/Up
// keys).
// 
// 
// CSS nodes
// 
// ` scrollbar  range[.fine-tune]  trough  slider `
// 
// `GtkScrollbar` has a main CSS node with name scrollbar and a subnode for its
// contents. The main node gets the .horizontal or .vertical style classes
// applied, depending on the scrollbar's orientation.
// 
// The range node gets the style class .fine-tune added when the scrollbar is in
// 'fine-tuning' mode.
// 
// Other style classes that may be added to scrollbars inside
// [class@Gtk.ScrolledWindow] include the positional classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering).
// 
// 
// Accessibility
// 
// `GtkScrollbar` uses the GTK_ACCESSIBLE_ROLE_SCROLLBAR role.
	type Scrollbar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// ScrollbarClass is an interface that the Scrollbar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScrollbarClass interface {
		gextras.Objector
		_scrollbar()
	}

	func (Scrollbar) _scrollbar() {}

	
	func marshalScrollbar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScrollbar(obj), nil
	}
	

	
	// NewScrollbar creates a new scrollbar with the given orientation.
	func NewScrollbar(orientation Orientation, adjustment AdjustmentClass) Scrollbar {
var _arg1 C.GtkOrientation // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

_cret = C.gtk_scrollbar_new(_arg1, _arg2)


var _scrollbar Scrollbar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scrollbar = Scrollbar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scrollbar
}
	

	
	// Adjustment returns the scrollbar's adjustment.
	func (s Scrollbar) Adjustment() Adjustment {
var _arg0 *C.GtkScrollbar // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrollbar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrollbar_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// SetAdjustment makes the scrollbar use the given adjustment.
	func (s Scrollbar) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkScrollbar // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrollbar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_scrollbar_set_adjustment(_arg0, _arg1)
}
	


	// ScrolledWindow: `GtkScrolledWindow` is a container that makes its child
// scrollable.
// 
// It does so using either internally added scrollbars or externally associated
// adjustments, and optionally draws a frame around the child.
// 
// Widgets with native scrolling support, i.e. those whose classes implement the
// [iface@Gtk.Scrollable] interface, are added directly. For other types of
// widget, the class [class@Gtk.Viewport] acts as an adaptor, giving
// scrollability to other widgets. [method@Gtk.ScrolledWindow.set_child]
// intelligently accounts for whether or not the added child is a
// `GtkScrollable`. If it isnt, then it wraps the child in a `GtkViewport`.
// Therefore, you can just add any child widget and not worry about the details.
// 
// If [method@Gtk.ScrolledWindow.set_child] has added a `GtkViewport` for you,
// you can remove both your added child widget from the `GtkViewport`, and the
// `GtkViewport` from the `GtkScrolledWindow`, like this:
// 
// `c GtkWidget *scrolled_window = gtk_scrolled_window_new (); GtkWidget
// *child_widget = gtk_button_new ();
// 
// // GtkButton is not a GtkScrollable, so GtkScrolledWindow will automatically
// // add a GtkViewport. gtk_box_append (GTK_BOX (scrolled_window),
// // child_widget);
// 
// // Either of these will result in child_widget being unparented:
// // gtk_box_remove (GTK_BOX (scrolled_window), child_widget); // or
// // gtk_box_remove (GTK_BOX (scrolled_window), gtk_bin_get_child (GTK_BIN
// // (scrolled_window))); `
// 
// Unless [property@Gtk.ScrolledWindow:hscrollbar-policy] and
// [property@Gtk.ScrolledWindow:vscrollbar-policy] are GTK_POLICY_NEVER or
// GTK_POLICY_EXTERNAL, `GtkScrolledWindow` adds internal `GtkScrollbar` widgets
// around its child. The scroll position of the child, and if applicable the
// scrollbars, is controlled by the [property@Gtk.ScrolledWindow:hadjustment]
// and [property@Gtk.ScrolledWindow:vadjustment] that are associated with the
// `GtkScrolledWindow`. See the docs on [class@Gtk.Scrollbar] for the details,
// but note that the step_increment and page_increment fields are only
// effective if the policy causes scrollbars to be present.
// 
// If a `GtkScrolledWindow` doesnt behave quite as you would like, or doesnt
// have exactly the right layout, its very possible to set up your own
// scrolling with `GtkScrollbar` and for example a `GtkGrid`.
// 
// 
// Touch support
// 
// `GtkScrolledWindow` has built-in support for touch devices. When a
// touchscreen is used, swiping will move the scrolled window, and will expose
// 'kinetic' behavior. This can be turned off with the
// [property@Gtk.ScrolledWindow:kinetic-scrolling] property if it is undesired.
// 
// `GtkScrolledWindow` also displays visual 'overshoot' indication when the
// content is pulled beyond the end, and this situation can be captured with the
// [signal@Gtk.ScrolledWindow::edge-overshot] signal.
// 
// If no mouse device is present, the scrollbars will overlaid as narrow,
// auto-hiding indicators over the content. If traditional scrollbars are
// desired although no mouse is present, this behaviour can be turned off with
// the [property@Gtk.ScrolledWindow:overlay-scrolling] property.
// 
// 
// CSS nodes
// 
// `GtkScrolledWindow` has a main CSS node with name scrolledwindow. It gets a
// .frame style class added when [property@Gtk.ScrolledWindow:has-frame] is
// true.
// 
// It uses subnodes with names overshoot and undershoot to draw the overflow and
// underflow indications. These nodes get the .left, .right, .top or .bottom
// style class added depending on where the indication is drawn.
// 
// `GtkScrolledWindow` also sets the positional style classes (.left, .right,
// .top, .bottom) and style classes related to overlay scrolling
// (.overlay-indicator, .dragging, .hovering) on its scrollbars.
// 
// If both scrollbars are visible, the area where they meet is drawn with a
// subnode named junction.
// 
// 
// Accessibility
// 
// `GtkScrolledWindow` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type ScrolledWindow struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// ScrolledWindowClass is an interface that the ScrolledWindow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ScrolledWindowClass interface {
		gextras.Objector
		_scrolledWindow()
	}

	func (ScrolledWindow) _scrolledWindow() {}

	
	func marshalScrolledWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapScrolledWindow(obj), nil
	}
	

	
	// NewScrolledWindow creates a new scrolled window.
	func NewScrolledWindow() ScrolledWindow {
var _cret *C.GtkWidget // in

_cret = C.gtk_scrolled_window_new()


var _scrolledWindow ScrolledWindow // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_scrolledWindow = ScrolledWindow{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _scrolledWindow
}
	

	
	// Child gets the child widget of @scrolled_window.
	func (s ScrolledWindow) Child() Widget {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// HAdjustment returns the horizontal scrollbars adjustment.
// 
// This is the adjustment used to connect the horizontal scrollbar to the child
// widgets horizontal scroll functionality.
	func (s ScrolledWindow) HAdjustment() Adjustment {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_hadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// HasFrame gets whether the scrolled window draws a frame.
	func (s ScrolledWindow) HasFrame() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_has_frame(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HScrollbar returns the horizontal scrollbar of @scrolled_window.
	func (s ScrolledWindow) HScrollbar() Widget {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_hscrollbar(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// KineticScrolling returns the specified kinetic scrolling behavior.
	func (s ScrolledWindow) KineticScrolling() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_kinetic_scrolling(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MaxContentHeight returns the maximum content height set.
	func (s ScrolledWindow) MaxContentHeight() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.int // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_max_content_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MaxContentWidth returns the maximum content width set.
	func (s ScrolledWindow) MaxContentWidth() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.int // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_max_content_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MinContentHeight gets the minimal content height of @scrolled_window.
	func (s ScrolledWindow) MinContentHeight() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.int // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_min_content_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MinContentWidth gets the minimum content width of @scrolled_window.
	func (s ScrolledWindow) MinContentWidth() int {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.int // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_min_content_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// OverlayScrolling returns whether overlay scrolling is enabled for this
// scrolled window.
	func (s ScrolledWindow) OverlayScrolling() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_overlay_scrolling(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Placement gets the placement of the contents with respect to the scrollbars.
	func (s ScrolledWindow) Placement() CornerType {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.GtkCornerType // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_placement(_arg0)


var _cornerType CornerType // out

_cornerType = CornerType(_cret)

return _cornerType
}
	
	// Policy retrieves the current policy values for the horizontal and vertical
// scrollbars.
// 
// See [method@Gtk.ScrolledWindow.set_policy].
	func (s ScrolledWindow) Policy() (hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType) {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.GtkPolicyType // in
var _arg2 C.GtkPolicyType // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

C.gtk_scrolled_window_get_policy(_arg0, &_arg1, &_arg2)

var _hscrollbarPolicy PolicyType // out
var _vscrollbarPolicy PolicyType // out

_hscrollbarPolicy = PolicyType(_arg1)
_vscrollbarPolicy = PolicyType(_arg2)

return _hscrollbarPolicy, _vscrollbarPolicy
}
	
	// PropagateNaturalHeight reports whether the natural height of the child will
// be calculated and propagated through the scrolled windows requested natural
// height.
	func (s ScrolledWindow) PropagateNaturalHeight() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_propagate_natural_height(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PropagateNaturalWidth reports whether the natural width of the child will be
// calculated and propagated through the scrolled windows requested natural
// width.
	func (s ScrolledWindow) PropagateNaturalWidth() bool {
var _arg0 *C.GtkScrolledWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_propagate_natural_width(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VAdjustment returns the vertical scrollbars adjustment.
// 
// This is the adjustment used to connect the vertical scrollbar to the child
// widgets vertical scroll functionality.
	func (s ScrolledWindow) VAdjustment() Adjustment {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_vadjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// VScrollbar returns the vertical scrollbar of @scrolled_window.
	func (s ScrolledWindow) VScrollbar() Widget {
var _arg0 *C.GtkScrolledWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_scrolled_window_get_vscrollbar(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetChild sets the child widget of @scrolled_window.
	func (s ScrolledWindow) SetChild(child WidgetClass)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_scrolled_window_set_child(_arg0, _arg1)
}
	
	// SetHAdjustment sets the `GtkAdjustment` for the horizontal scrollbar.
	func (s ScrolledWindow) SetHAdjustment(hadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))

C.gtk_scrolled_window_set_hadjustment(_arg0, _arg1)
}
	
	// SetHasFrame changes the frame drawn around the contents of @scrolled_window.
	func (s ScrolledWindow) SetHasFrame(hasFrame bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if hasFrame { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_has_frame(_arg0, _arg1)
}
	
	// SetKineticScrolling turns kinetic scrolling on or off.
// 
// Kinetic scrolling only applies to devices with source GDK_SOURCE_TOUCHSCREEN.
	func (s ScrolledWindow) SetKineticScrolling(kineticScrolling bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if kineticScrolling { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_kinetic_scrolling(_arg0, _arg1)
}
	
	// SetMaxContentHeight sets the maximum height that @scrolled_window should keep
// visible.
// 
// The @scrolled_window will grow up to this height before it starts scrolling
// the content.
// 
// It is a programming error to set the maximum content height to a value
// smaller than [property@Gtk.ScrolledWindow:min-content-height].
	func (s ScrolledWindow) SetMaxContentHeight(height int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.int // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(height)

C.gtk_scrolled_window_set_max_content_height(_arg0, _arg1)
}
	
	// SetMaxContentWidth sets the maximum width that @scrolled_window should keep
// visible.
// 
// The @scrolled_window will grow up to this width before it starts scrolling
// the content.
// 
// It is a programming error to set the maximum content width to a value smaller
// than [property@Gtk.ScrolledWindow:min-content-width].
	func (s ScrolledWindow) SetMaxContentWidth(width int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.int // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(width)

C.gtk_scrolled_window_set_max_content_width(_arg0, _arg1)
}
	
	// SetMinContentHeight sets the minimum height that @scrolled_window should keep
// visible.
// 
// Note that this can and (usually will) be smaller than the minimum size of the
// content.
// 
// It is a programming error to set the minimum content height to a value
// greater than [property@Gtk.ScrolledWindow:max-content-height].
	func (s ScrolledWindow) SetMinContentHeight(height int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.int // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(height)

C.gtk_scrolled_window_set_min_content_height(_arg0, _arg1)
}
	
	// SetMinContentWidth sets the minimum width that @scrolled_window should keep
// visible.
// 
// Note that this can and (usually will) be smaller than the minimum size of the
// content.
// 
// It is a programming error to set the minimum content width to a value greater
// than [property@Gtk.ScrolledWindow:max-content-width].
	func (s ScrolledWindow) SetMinContentWidth(width int)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.int // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(width)

C.gtk_scrolled_window_set_min_content_width(_arg0, _arg1)
}
	
	// SetOverlayScrolling enables or disables overlay scrolling for this scrolled
// window.
	func (s ScrolledWindow) SetOverlayScrolling(overlayScrolling bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if overlayScrolling { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_overlay_scrolling(_arg0, _arg1)
}
	
	// SetPlacement sets the placement of the contents with respect to the
// scrollbars for the scrolled window.
// 
// The default is GTK_CORNER_TOP_LEFT, meaning the child is in the top left,
// with the scrollbars underneath and to the right. Other values in
// [enum@Gtk.CornerType] are GTK_CORNER_TOP_RIGHT, GTK_CORNER_BOTTOM_LEFT, and
// GTK_CORNER_BOTTOM_RIGHT.
// 
// See also [method@Gtk.ScrolledWindow.get_placement] and
// [method@Gtk.ScrolledWindow.unset_placement].
	func (s ScrolledWindow) SetPlacement(windowPlacement CornerType)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.GtkCornerType // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkCornerType)(windowPlacement)

C.gtk_scrolled_window_set_placement(_arg0, _arg1)
}
	
	// SetPolicy sets the scrollbar policy for the horizontal and vertical
// scrollbars.
// 
// The policy determines when the scrollbar should appear; it is a value from
// the [enum@Gtk.PolicyType] enumeration. If GTK_POLICY_ALWAYS, the scrollbar is
// always present; if GTK_POLICY_NEVER, the scrollbar is never present; if
// GTK_POLICY_AUTOMATIC, the scrollbar is present only if needed (that is, if
// the slider part of the bar would be smaller than the trough  the display is
// larger than the page size).
	func (s ScrolledWindow) SetPolicy(hscrollbarPolicy PolicyType, vscrollbarPolicy PolicyType)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.GtkPolicyType // out
var _arg2 C.GtkPolicyType // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPolicyType)(hscrollbarPolicy)
_arg2 = (C.GtkPolicyType)(vscrollbarPolicy)

C.gtk_scrolled_window_set_policy(_arg0, _arg1, _arg2)
}
	
	// SetPropagateNaturalHeight sets whether the natural height of the child should
// be calculated and propagated through the scrolled windows requested natural
// height.
	func (s ScrolledWindow) SetPropagateNaturalHeight(propagate bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if propagate { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_propagate_natural_height(_arg0, _arg1)
}
	
	// SetPropagateNaturalWidth sets whether the natural width of the child should
// be calculated and propagated through the scrolled windows requested natural
// width.
	func (s ScrolledWindow) SetPropagateNaturalWidth(propagate bool)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
if propagate { _arg1 = C.TRUE }

C.gtk_scrolled_window_set_propagate_natural_width(_arg0, _arg1)
}
	
	// SetVAdjustment sets the `GtkAdjustment` for the vertical scrollbar.
	func (s ScrolledWindow) SetVAdjustment(vadjustment AdjustmentClass)  {
var _arg0 *C.GtkScrolledWindow // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

C.gtk_scrolled_window_set_vadjustment(_arg0, _arg1)
}
	
	// UnsetPlacement unsets the placement of the contents with respect to the
// scrollbars.
// 
// If no window placement is set for a scrolled window, it defaults to
// GTK_CORNER_TOP_LEFT.
	func (s ScrolledWindow) UnsetPlacement()  {
var _arg0 *C.GtkScrolledWindow // out

_arg0 = (*C.GtkScrolledWindow)(unsafe.Pointer(s.Native()))

C.gtk_scrolled_window_unset_placement(_arg0)
}
	


	// SearchBar: `GtkSearchBar` is a container made to have a search entry.
// 
// !An example GtkSearchBar (search-bar.png)
// 
// It can also contain additional widgets, such as drop-down menus, or buttons.
// The search bar would appear when a search is started through typing on the
// keyboard, or the applications search mode is toggled on.
// 
// For keyboard presses to start a search, the search bar must be told of a
// widget to capture key events from through
// [method@Gtk.SearchBar.set_key_capture_widget]. This widget will typically be
// the top-level window, or a parent container of the search bar. Common
// shortcuts such as Ctrl+F should be handled as an application action, or
// through the menu items.
// 
// You will also need to tell the search bar about which entry you are using as
// your search entry using [method@Gtk.SearchBar.connect_entry].
// 
// 
// Creating a search bar
// 
// The following example shows you how to create a more complex search entry.
// 
// A simple example
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/examples/search-bar.c)
// 
// 
// CSS nodes
// 
// ` searchbar  revealer  box  [child]  [button.close] `
// 
// `GtkSearchBar` has a main CSS node with name searchbar. It has a child node
// with name revealer that contains a node with name box. The box node contains
// both the CSS node of the child widget as well as an optional button node
// which gets the .close style class applied.
// 
// 
// Accessibility
// 
// `GtkSearchBar` uses the GTK_ACCESSIBLE_ROLE_SEARCH role.
	type SearchBar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// SearchBarClass is an interface that the SearchBar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SearchBarClass interface {
		gextras.Objector
		_searchBar()
	}

	func (SearchBar) _searchBar() {}

	
	func marshalSearchBar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSearchBar(obj), nil
	}
	

	
	// NewSearchBar creates a `GtkSearchBar`.
// 
// You will need to tell it about which widget is going to be your text entry
// using [method@Gtk.SearchBar.connect_entry].
	func NewSearchBar() SearchBar {
var _cret *C.GtkWidget // in

_cret = C.gtk_search_bar_new()


var _searchBar SearchBar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_searchBar = SearchBar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _searchBar
}
	

	
	// ConnectEntry connects the `GtkEditable widget passed as the one to be used in
// this search bar.
// 
// The entry should be a descendant of the search bar. Calling this function
// manually is only required if the entry isnt the direct child of the search
// bar (as in our main example).
	func (b SearchBar) ConnectEntry(entry Editable)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 *C.GtkEditable // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))

C.gtk_search_bar_connect_entry(_arg0, _arg1)
}
	
	// Child gets the child widget of @bar.
	func (b SearchBar) Child() Widget {
var _arg0 *C.GtkSearchBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_search_bar_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// KeyCaptureWidget gets the widget that @bar is capturing key events from.
	func (b SearchBar) KeyCaptureWidget() Widget {
var _arg0 *C.GtkSearchBar // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_search_bar_get_key_capture_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SearchMode returns whether the search mode is on or off.
	func (b SearchBar) SearchMode() bool {
var _arg0 *C.GtkSearchBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_search_bar_get_search_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShowCloseButton returns whether the close button is shown.
	func (b SearchBar) ShowCloseButton() bool {
var _arg0 *C.GtkSearchBar // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))

_cret = C.gtk_search_bar_get_show_close_button(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetChild sets the child widget of @bar.
	func (b SearchBar) SetChild(child WidgetClass)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_search_bar_set_child(_arg0, _arg1)
}
	
	// SetKeyCaptureWidget sets @widget as the widget that @bar will capture key
// events from.
// 
// If key events are handled by the search bar, the bar will be shown, and the
// entry populated with the entered text.
// 
// Note that despite the name of this function, the events are only 'captured'
// in the bubble phase, which means that editable child widgets of @widget will
// receive text input before it gets captured. If that is not desired, you can
// capture and forward the events yourself with
// [method@Gtk.EventControllerKey.forward].
	func (b SearchBar) SetKeyCaptureWidget(widget WidgetClass)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_search_bar_set_key_capture_widget(_arg0, _arg1)
}
	
	// SetSearchMode switches the search mode on or off.
	func (b SearchBar) SetSearchMode(searchMode bool)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
if searchMode { _arg1 = C.TRUE }

C.gtk_search_bar_set_search_mode(_arg0, _arg1)
}
	
	// SetShowCloseButton shows or hides the close button.
// 
// Applications that already have a search toggle button should not show a
// close button in their search bar, as it duplicates the role of the toggle
// button.
	func (b SearchBar) SetShowCloseButton(visible bool)  {
var _arg0 *C.GtkSearchBar // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSearchBar)(unsafe.Pointer(b.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_search_bar_set_show_close_button(_arg0, _arg1)
}
	


	// SearchEntry: `GtkSearchEntry` is an entry widget that has been tailored for
// use as a search entry.
// 
// The main API for interacting with a `GtkSearchEntry` as entry is the
// `GtkEditable` interface.
// 
// !An example GtkSearchEntry (search-entry.png)
// 
// It will show an inactive symbolic find icon when the search entry is empty,
// and a symbolic clear icon when there is text. Clicking on the clear icon
// will empty the search entry.
// 
// To make filtering appear more reactive, it is a good idea to not react to
// every change in the entry text immediately, but only after a short delay. To
// support this, `GtkSearchEntry` emits the
// [signal@Gtk.SearchEntry::search-changed] signal which can be used instead of
// the [signal@Gtk.Editable::changed] signal.
// 
// The [signal@Gtk.SearchEntry::previous-match],
// [signal@Gtk.SearchEntry::next-match] and
// [signal@Gtk.SearchEntry::stop-search] signals can be used to implement moving
// between search results and ending the search.
// 
// Often, `GtkSearchEntry` will be fed events by means of being placed inside a
// [class@Gtk.SearchBar]. If that is not the case, you can use
// [method@Gtk.SearchEntry.set_key_capture_widget] to let it capture key input
// from another widget.
// 
// `GtkSearchEntry` provides only minimal API and should be used with the
// [iface@Gtk.Editable] API.
// 
// 
// CSS Nodes
// 
// ` entry.search  text `
// 
// `GtkSearchEntry` has a single CSS node with name entry that carries a
// `.search` style class, and the text node is a child of that.
// 
// 
// Accessibility
// 
// `GtkSearchEntry` uses the GTK_ACCESSIBLE_ROLE_SEARCH_BOX role.
	type SearchEntry struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Editable
		
	}

	// SearchEntryClass is an interface that the SearchEntry class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SearchEntryClass interface {
		gextras.Objector
		_searchEntry()
	}

	func (SearchEntry) _searchEntry() {}

	
	func marshalSearchEntry(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSearchEntry(obj), nil
	}
	

	
	// NewSearchEntry creates a `GtkSearchEntry`.
	func NewSearchEntry() SearchEntry {
var _cret *C.GtkWidget // in

_cret = C.gtk_search_entry_new()


var _searchEntry SearchEntry // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_searchEntry = SearchEntry{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _searchEntry
}
	

	
	// KeyCaptureWidget gets the widget that @entry is capturing key events from.
	func (e SearchEntry) KeyCaptureWidget() Widget {
var _arg0 *C.GtkSearchEntry // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(e.Native()))

_cret = C.gtk_search_entry_get_key_capture_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetKeyCaptureWidget sets @widget as the widget that @entry will capture key
// events from.
// 
// Key events are consumed by the search entry to start or continue a search.
// 
// If the entry is part of a `GtkSearchBar`, it is preferable to call
// [method@Gtk.SearchBar.set_key_capture_widget] instead, which will reveal the
// entry in addition to triggering the search entry.
// 
// Note that despite the name of this function, the events are only 'captured'
// in the bubble phase, which means that editable child widgets of @widget will
// receive text input before it gets captured. If that is not desired, you can
// capture and forward the events yourself with
// [method@Gtk.EventControllerKey.forward].
	func (e SearchEntry) SetKeyCaptureWidget(widget WidgetClass)  {
var _arg0 *C.GtkSearchEntry // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkSearchEntry)(unsafe.Pointer(e.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_search_entry_set_key_capture_widget(_arg0, _arg1)
}
	


	// SelectionFilterModel: `GtkSelectionFilterModel` is a list model that presents
// the selection from a `GtkSelectionModel`.
	type SelectionFilterModel struct {
		**externglib.Object
		gio.ListModel
		
	}

	// SelectionFilterModelClass is an interface that the SelectionFilterModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SelectionFilterModelClass interface {
		gextras.Objector
		_selectionFilterModel()
	}

	func (SelectionFilterModel) _selectionFilterModel() {}

	
	func marshalSelectionFilterModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSelectionFilterModel(obj), nil
	}
	

	
	// NewSelectionFilterModel creates a new `GtkSelectionFilterModel` that will
// include the selected items from the underlying selection model.
	func NewSelectionFilterModel(model SelectionModel) SelectionFilterModel {
var _arg1 *C.GtkSelectionModel // out
var _cret *C.GtkSelectionFilterModel // in

_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_selection_filter_model_new(_arg1)


var _selectionFilterModel SelectionFilterModel // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_selectionFilterModel = SelectionFilterModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _selectionFilterModel
}
	

	
	// Model gets the model currently filtered or nil if none.
	func (s SelectionFilterModel) Model() SelectionModel {
var _arg0 *C.GtkSelectionFilterModel // out
var _cret *C.GtkSelectionModel // in

_arg0 = (*C.GtkSelectionFilterModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_selection_filter_model_get_model(_arg0)


var _selectionModel SelectionModel // out

_selectionModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(SelectionModel)

return _selectionModel
}
	
	// SetModel sets the model to be filtered.
// 
// Note that GTK makes no effort to ensure that @model conforms to the item type
// of @self. It assumes that the caller knows what they are doing and have set
// up an appropriate filter to ensure that item types match.
	func (s SelectionFilterModel) SetModel(model SelectionModel)  {
var _arg0 *C.GtkSelectionFilterModel // out
var _arg1 *C.GtkSelectionModel // out

_arg0 = (*C.GtkSelectionFilterModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSelectionModel)(unsafe.Pointer(model.Native()))

C.gtk_selection_filter_model_set_model(_arg0, _arg1)
}
	


	// Separator: `GtkSeparator` is a horizontal or vertical separator widget.
// 
// !An example GtkSeparator (separators.png)
// 
// A `GtkSeparator` can be used to group the widgets within a window. It
// displays a line with a shadow to make it appear sunken into the interface.
// 
// 
// CSS nodes
// 
// `GtkSeparator` has a single CSS node with name separator. The node gets one
// of the .horizontal or .vertical style classes.
// 
// 
// Accessibility
// 
// `GtkSeparator` uses the K_ACCESSIBLE_ROLE_SEPARATOR role.
	type Separator struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// SeparatorClass is an interface that the Separator class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SeparatorClass interface {
		gextras.Objector
		_separator()
	}

	func (Separator) _separator() {}

	
	func marshalSeparator(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSeparator(obj), nil
	}
	

	
	// NewSeparator creates a new `GtkSeparator` with the given orientation.
	func NewSeparator(orientation Orientation) Separator {
var _arg1 C.GtkOrientation // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_separator_new(_arg1)


var _separator Separator // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_separator = Separator{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _separator
}
	

	


	// Settings: `GtkSettings` provides a mechanism to share global settings between
// applications.
// 
// On the X window system, this sharing is realized by an XSettings
// (http://www.freedesktop.org/wiki/Specifications/xsettings-spec) manager that
// is usually part of the desktop environment, along with utilities that let the
// user change these settings.
// 
// On Wayland, the settings are obtained either via a settings portal, or by
// reading desktop settings from DConf.
// 
// In the absence of these sharing mechanisms, GTK reads default values for
// settings from `settings.ini` files in `/etc/gtk-4.0`,
// `$XDG_CONFIG_DIRS/gtk-4.0` and `$XDG_CONFIG_HOME/gtk-4.0`. These files must
// be valid key files (see `GKeyFile`), and have a section called Settings.
// Themes can also provide default values for settings by installing a
// `settings.ini` file next to their `gtk.css` file.
// 
// Applications can override system-wide settings by setting the property of the
// `GtkSettings` object with g_object_set(). This should be restricted to
// special cases though; `GtkSettings` are not meant as an application
// configuration facility.
// 
// There is one `GtkSettings` instance per display. It can be obtained with
// [type_func@GtkSettings.get_for_display], but in many cases, it is more
// convenient to use [method@Gtk.Widget.get_settings].
	type Settings struct {
		**externglib.Object
		StyleProvider
		
	}

	// SettingsClass is an interface that the Settings class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SettingsClass interface {
		gextras.Objector
		_settings()
	}

	func (Settings) _settings() {}

	
	func marshalSettings(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSettings(obj), nil
	}
	

	

	
	// ResetProperty undoes the effect of calling g_object_set() to install an
// application-specific value for a setting.
// 
// After this call, the setting will again follow the session-wide value for
// this setting.
	func (s Settings) ResetProperty(name string)  {
var _arg0 *C.GtkSettings // out
var _arg1 *C.char // out

_arg0 = (*C.GtkSettings)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_settings_reset_property(_arg0, _arg1)
}
	


	// Shortcut: a `GtkShortcut` describes a keyboard shortcut.
// 
// It contains a description of how to trigger the shortcut via a
// [class@Gtk.ShortcutTrigger] and a way to activate the shortcut on a widget
// via a [class@Gtk.ShortcutAction].
// 
// The actual work is usually done via [class@Gtk.ShortcutController], which
// decides if and when to activate a shortcut. Using that controller directly
// however is rarely necessary as various higher level convenience APIs exist on
// Widgets that make it easier to use shortcuts in GTK.
// 
// `GtkShortcut` does provide functionality to make it easy for users to work
// with shortcuts, either by providing informational strings for display
// purposes or by allowing shortcuts to be configured.
	type Shortcut struct {
		**externglib.Object
		
	}

	// ShortcutClass is an interface that the Shortcut class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutClass interface {
		gextras.Objector
		_shortcut()
	}

	func (Shortcut) _shortcut() {}

	
	func marshalShortcut(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcut(obj), nil
	}
	

	
	// NewShortcut creates a new `GtkShortcut` that is triggered by @trigger and
// then activates @action.
	func NewShortcut(trigger ShortcutTriggerClass, action ShortcutActionClass) Shortcut {
var _arg1 *C.GtkShortcutTrigger // out
var _arg2 *C.GtkShortcutAction // out
var _cret *C.GtkShortcut // in

_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(trigger.Native()))
_arg2 = (*C.GtkShortcutAction)(unsafe.Pointer(action.Native()))

_cret = C.gtk_shortcut_new(_arg1, _arg2)


var _shortcut Shortcut // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_shortcut = Shortcut{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _shortcut
}
	

	
	// Action gets the action that is activated by this shortcut.
	func (s Shortcut) Action() ShortcutAction {
var _arg0 *C.GtkShortcut // out
var _cret *C.GtkShortcutAction // in

_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_get_action(_arg0)


var _shortcutAction ShortcutAction // out

_shortcutAction = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutAction)

return _shortcutAction
}
	
	// Arguments gets the arguments that are passed when activating the shortcut.
	func (s Shortcut) Arguments() *glib.Variant {
var _arg0 *C.GtkShortcut // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_get_arguments(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// Trigger gets the trigger used to trigger @self.
	func (s Shortcut) Trigger() ShortcutTrigger {
var _arg0 *C.GtkShortcut // out
var _cret *C.GtkShortcutTrigger // in

_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_get_trigger(_arg0)


var _shortcutTrigger ShortcutTrigger // out

_shortcutTrigger = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(ShortcutTrigger)

return _shortcutTrigger
}
	
	// SetAction sets the new action for @self to be @action.
	func (s Shortcut) SetAction(action ShortcutActionClass)  {
var _arg0 *C.GtkShortcut // out
var _arg1 *C.GtkShortcutAction // out

_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkShortcutAction)(unsafe.Pointer(action.Native()))

C.gtk_shortcut_set_action(_arg0, _arg1)
}
	
	// SetArguments sets the arguments to pass when activating the shortcut.
	func (s Shortcut) SetArguments(args *glib.Variant)  {
var _arg0 *C.GtkShortcut // out
var _arg1 *C.GVariant // out

_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GVariant)(unsafe.Pointer(args.Native()))

C.gtk_shortcut_set_arguments(_arg0, _arg1)
}
	
	// SetTrigger sets the new trigger for @self to be @trigger.
	func (s Shortcut) SetTrigger(trigger ShortcutTriggerClass)  {
var _arg0 *C.GtkShortcut // out
var _arg1 *C.GtkShortcutTrigger // out

_arg0 = (*C.GtkShortcut)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkShortcutTrigger)(unsafe.Pointer(trigger.Native()))

C.gtk_shortcut_set_trigger(_arg0, _arg1)
}
	


	// ShortcutAction: `GtkShortcutAction` encodes an action that can be triggered
// by a keyboard shortcut.
// 
// `GtkShortcutActions` contain functions that allow easy presentation to end
// users as well as being printed for debugging.
// 
// All `GtkShortcutActions` are immutable, you can only specify their properties
// during construction. If you want to change a action, you have to replace it
// with a new one. If you need to pass arguments to an action, these are
// specified by the higher-level `GtkShortcut` object.
// 
// To activate a `GtkShortcutAction` manually,
// [method@Gtk.ShortcutAction.activate] can be called.
// 
// GTK provides various actions:
// 
//    - [class@Gtk.MnemonicAction]: a shortcut action that calls
//      gtk_widget_mnemonic_activate()
//    - [class@Gtk.CallbackAction]: a shortcut action that invokes
//      a given callback
//    - [class@Gtk.SignalAction]: a shortcut action that emits a
//      given signal
//    - [class@Gtk.ActivateAction]: a shortcut action that calls
//      gtk_widget_activate()
//    - [class@Gtk.NamedAction]: a shortcut action that calls
//      gtk_widget_activate_action()
//    - [class@Gtk.NothingAction]: a shortcut action that does nothing
	type ShortcutAction struct {
		**externglib.Object
		
	}

	// ShortcutActionClass is an interface that the ShortcutAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutActionClass interface {
		gextras.Objector
		_shortcutAction()
	}

	func (ShortcutAction) _shortcutAction() {}

	
	func marshalShortcutAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutAction(obj), nil
	}
	

	
	// NewShortcutActionParseString tries to parse the given string into an action.
// 
// On success, the parsed action is returned. When parsing failed, nil is
// returned.
// 
// The accepted strings are:
// 
// - `nothing`, for `GtkNothingAction` - `activate`, for `GtkActivateAction` -
// `mnemonic-activate`, for `GtkMnemonicAction` - `action(NAME)`, for a
// `GtkNamedAction` for the action named `NAME` - `signal(NAME)`, for a
// `GtkSignalAction` for the signal `NAME`
	func NewShortcutActionParseString(_string string) ShortcutAction {
var _arg1 *C.char // out
var _cret *C.GtkShortcutAction // in

_arg1 = (*C.char)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_shortcut_action_parse_string(_arg1)


var _shortcutAction ShortcutAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_shortcutAction = ShortcutAction{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _shortcutAction
}
	

	
	// Activate activates the action on the @widget with the given @args.
// 
// Note that some actions ignore the passed in @flags, @widget or @args.
// 
// Activation of an action can fail for various reasons. If the action is not
// supported by the @widget, if the @args don't match the action or if the
// activation otherwise had no effect, false will be returned.
	func (s ShortcutAction) Activate(flags ShortcutActionFlags, widget WidgetClass, args *glib.Variant) bool {
var _arg0 *C.GtkShortcutAction // out
var _arg1 C.GtkShortcutActionFlags // out
var _arg2 *C.GtkWidget // out
var _arg3 *C.GVariant // out
var _cret C.gboolean // in

_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkShortcutActionFlags)(flags)
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))
_arg3 = (*C.GVariant)(unsafe.Pointer(args.Native()))

_cret = C.gtk_shortcut_action_activate(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// String prints the given action into a human-readable string.
// 
// This is a small wrapper around [method@Gtk.ShortcutAction.print] to help when
// debugging.
	func (s ShortcutAction) String() string {
var _arg0 *C.GtkShortcutAction // out
var _cret *C.char // in

_arg0 = (*C.GtkShortcutAction)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_action_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// ShortcutController: `GtkShortcutController` is an event controller that
// manages shortcuts.
// 
// Most common shortcuts are using this controller implicitly, e.g. by adding a
// mnemonic underline to a `GtkLabel`, or by installing a key binding using
// gtk_widget_class_add_binding(), or by adding accelerators to global actions
// using gtk_application_set_accels_for_action().
// 
// But it is possible to create your own shortcut controller, and add shortcuts
// to it.
// 
// `GtkShortcutController` implements `GListModel` for querying the shortcuts
// that have been added to it.
// 
// 
// GtkShortcutController as a GtkBuildable
// 
// `GtkShortcutControllers` can be creates in ui files to set up shortcuts in
// the same place as the widgets.
// 
// An example of a UI definition fragment with `GtkShortcutController`: `xml
// <object class='GtkButton'> <child> <object class='GtkShortcutController'>
// <property name='scope'>managed</property> <child> <object
// class='GtkShortcut'> <property
// name='trigger'>&amp;lt;Control&amp;gt;k</property> <property
// name='action'>activate</property> </object> </child> </object> </child>
// </object> `
// 
// This example creates a [class@Gtk.ActivateAction] for triggering the
// `activate` signal of the `GtkButton`. See
// [ctor@Gtk.ShortcutAction.parse_string] for the syntax for other kinds of
// `GtkShortcutAction`. See [ctor@Gtk.ShortcutTrigger.parse_string] to learn
// more about the syntax for triggers.
	type ShortcutController struct {
		EventController
		gio.ListModel
		Buildable
		
	}

	// ShortcutControllerClass is an interface that the ShortcutController class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutControllerClass interface {
		gextras.Objector
		_shortcutController()
	}

	func (ShortcutController) _shortcutController() {}

	
	func marshalShortcutController(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutController(obj), nil
	}
	

	
	// NewShortcutController creates a new shortcut controller.
	func NewShortcutController() ShortcutController {
var _cret *C.GtkEventController // in

_cret = C.gtk_shortcut_controller_new()


var _shortcutController ShortcutController // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_shortcutController = ShortcutController{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _shortcutController
}
	
	// NewShortcutControllerForModel creates a new shortcut controller that takes
// its shortcuts from the given list model.
// 
// A controller created by this function does not let you add or remove
// individual shortcuts using the shortcut controller api, but you can change
// the contents of the model.
	func NewShortcutControllerForModel(model gio.ListModel) ShortcutController {
var _arg1 *C.GListModel // out
var _cret *C.GtkEventController // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_shortcut_controller_new_for_model(_arg1)


var _shortcutController ShortcutController // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_shortcutController = ShortcutController{
EventController: EventController{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _shortcutController
}
	

	
	// AddShortcut adds @shortcut to the list of shortcuts handled by @self.
// 
// If this controller uses an external shortcut list, this function does
// nothing.
	func (s ShortcutController) AddShortcut(shortcut ShortcutClass)  {
var _arg0 *C.GtkShortcutController // out
var _arg1 *C.GtkShortcut // out

_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkShortcut)(unsafe.Pointer(shortcut.Native()))

C.gtk_shortcut_controller_add_shortcut(_arg0, _arg1)
}
	
	// MnemonicsModifiers gets the mnemonics modifiers for when this controller
// activates its shortcuts.
	func (s ShortcutController) MnemonicsModifiers() gdk.ModifierType {
var _arg0 *C.GtkShortcutController // out
var _cret C.GdkModifierType // in

_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_controller_get_mnemonics_modifiers(_arg0)


var _modifierType gdk.ModifierType // out

_modifierType = gdk.ModifierType(_cret)

return _modifierType
}
	
	// Scope gets the scope for when this controller activates its shortcuts. See
// gtk_shortcut_controller_set_scope() for details.
	func (s ShortcutController) Scope() ShortcutScope {
var _arg0 *C.GtkShortcutController // out
var _cret C.GtkShortcutScope // in

_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_controller_get_scope(_arg0)


var _shortcutScope ShortcutScope // out

_shortcutScope = ShortcutScope(_cret)

return _shortcutScope
}
	
	// RemoveShortcut removes @shortcut from the list of shortcuts handled by @self.
// 
// If @shortcut had not been added to @controller or this controller uses an
// external shortcut list, this function does nothing.
	func (s ShortcutController) RemoveShortcut(shortcut ShortcutClass)  {
var _arg0 *C.GtkShortcutController // out
var _arg1 *C.GtkShortcut // out

_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkShortcut)(unsafe.Pointer(shortcut.Native()))

C.gtk_shortcut_controller_remove_shortcut(_arg0, _arg1)
}
	
	// SetMnemonicsModifiers sets the controller to have the given
// @mnemonics_modifiers.
// 
// The mnemonics modifiers determines which modifiers need to be pressed to
// allow activation of shortcuts with mnemonics triggers.
// 
// GTK normally uses the Alt modifier for mnemonics, except in PopoverMenus,
// where mnemonics can be triggered without any modifiers. It should be very
// rarely necessary to change this, and doing so is likely to interfere with
// other shortcuts.
// 
// This value is only relevant for local shortcut controllers. Global and
// managed shortcut controllers will have their shortcuts activated from other
// places which have their own modifiers for activating mnemonics.
	func (s ShortcutController) SetMnemonicsModifiers(modifiers gdk.ModifierType)  {
var _arg0 *C.GtkShortcutController // out
var _arg1 C.GdkModifierType // out

_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
_arg1 = (C.GdkModifierType)(modifiers)

C.gtk_shortcut_controller_set_mnemonics_modifiers(_arg0, _arg1)
}
	
	// SetScope sets the controller to have the given @scope.
// 
// The scope allows shortcuts to be activated outside of the normal event
// propagation. In particular, it allows installing global keyboard shortcuts
// that can be activated even when a widget does not have focus.
// 
// With GTK_SHORTCUT_SCOPE_LOCAL, shortcuts will only be activated when the
// widget has focus.
	func (s ShortcutController) SetScope(scope ShortcutScope)  {
var _arg0 *C.GtkShortcutController // out
var _arg1 C.GtkShortcutScope // out

_arg0 = (*C.GtkShortcutController)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkShortcutScope)(scope)

C.gtk_shortcut_controller_set_scope(_arg0, _arg1)
}
	


	// ShortcutLabel: `GtkShortcutLabel` displays a single keyboard shortcut or
// gesture.
// 
// The main use case for `GtkShortcutLabel` is inside a
// [class@Gtk.ShortcutsWindow].
	type ShortcutLabel struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// ShortcutLabelClass is an interface that the ShortcutLabel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutLabelClass interface {
		gextras.Objector
		_shortcutLabel()
	}

	func (ShortcutLabel) _shortcutLabel() {}

	
	func marshalShortcutLabel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutLabel(obj), nil
	}
	

	
	// NewShortcutLabel creates a new `GtkShortcutLabel` with @accelerator set.
	func NewShortcutLabel(accelerator string) ShortcutLabel {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_shortcut_label_new(_arg1)


var _shortcutLabel ShortcutLabel // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_shortcutLabel = ShortcutLabel{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _shortcutLabel
}
	

	
	// Accelerator retrieves the current accelerator of @self.
	func (s ShortcutLabel) Accelerator() string {
var _arg0 *C.GtkShortcutLabel // out
var _cret *C.char // in

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_label_get_accelerator(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DisabledText retrieves the text that is displayed when no accelerator is set.
	func (s ShortcutLabel) DisabledText() string {
var _arg0 *C.GtkShortcutLabel // out
var _cret *C.char // in

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_label_get_disabled_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetAccelerator sets the accelerator to be displayed by @self.
	func (s ShortcutLabel) SetAccelerator(accelerator string)  {
var _arg0 *C.GtkShortcutLabel // out
var _arg1 *C.char // out

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(accelerator))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_shortcut_label_set_accelerator(_arg0, _arg1)
}
	
	// SetDisabledText sets the text to be displayed by @self when no accelerator is
// set.
	func (s ShortcutLabel) SetDisabledText(disabledText string)  {
var _arg0 *C.GtkShortcutLabel // out
var _arg1 *C.char // out

_arg0 = (*C.GtkShortcutLabel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(disabledText))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_shortcut_label_set_disabled_text(_arg0, _arg1)
}
	


	// ShortcutTrigger: `GtkShortcutTrigger` tracks how a `GtkShortcut` should be
// activated.
// 
// To find out if a `GtkShortcutTrigger` triggers, you can call
// [method@Gtk.ShortcutTrigger.trigger] on a `GdkEvent`.
// 
// `GtkShortcutTriggers` contain functions that allow easy presentation to end
// users as well as being printed for debugging.
// 
// All `GtkShortcutTriggers` are immutable, you can only specify their
// properties during construction. If you want to change a trigger, you have to
// replace it with a new one.
	type ShortcutTrigger struct {
		**externglib.Object
		
	}

	// ShortcutTriggerClass is an interface that the ShortcutTrigger class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutTriggerClass interface {
		gextras.Objector
		_shortcutTrigger()
	}

	func (ShortcutTrigger) _shortcutTrigger() {}

	
	func marshalShortcutTrigger(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutTrigger(obj), nil
	}
	

	
	// NewShortcutTriggerParseString tries to parse the given string into a trigger.
// 
// On success, the parsed trigger is returned. When parsing failed, nil is
// returned.
// 
// The accepted strings are:
// 
//    - `never`, for `GtkNeverTrigger`
//    - a string parsed by gtk_accelerator_parse(), for a `GtkKeyvalTrigger`, e.g. `<Control>C`
//    - underscore, followed by a single character, for `GtkMnemonicTrigger`, e.g. `_l`
//    - two valid trigger strings, separated by a `|` character, for a
//      `GtkAlternativeTrigger`: `<Control>q|<Control>w`
// 
// Note that you will have to escape the `<` and `>` characters when specifying
// triggers in XML files, such as GtkBuilder ui files. Use `&lt;` instead of `<`
// and `&gt;` instead of `>`.
	func NewShortcutTriggerParseString(_string string) ShortcutTrigger {
var _arg1 *C.char // out
var _cret *C.GtkShortcutTrigger // in

_arg1 = (*C.char)(C.CString(_string))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_shortcut_trigger_parse_string(_arg1)


var _shortcutTrigger ShortcutTrigger // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_shortcutTrigger = ShortcutTrigger{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _shortcutTrigger
}
	

	
	// Compare: the types of @trigger1 and @trigger2 are #gconstpointer only to
// allow use of this function as a Func.
// 
// They must each be a `GtkShortcutTrigger`.
	func (t ShortcutTrigger) Compare(trigger2 ShortcutTriggerClass) int {
var _arg0 C.gconstpointer // out
var _arg1 C.gconstpointer // out
var _cret C.int // in

_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))
_arg1 = (C.gconstpointer)(unsafe.Pointer(trigger2.Native()))

_cret = C.gtk_shortcut_trigger_compare(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Equal checks if @trigger1 and @trigger2 trigger under the same conditions.
// 
// The types of @one and @two are #gconstpointer only to allow use of this
// function with Table. They must each be a `GtkShortcutTrigger`.
	func (t ShortcutTrigger) Equal(trigger2 ShortcutTriggerClass) bool {
var _arg0 C.gconstpointer // out
var _arg1 C.gconstpointer // out
var _cret C.gboolean // in

_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))
_arg1 = (C.gconstpointer)(unsafe.Pointer(trigger2.Native()))

_cret = C.gtk_shortcut_trigger_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Hash generates a hash value for a `GtkShortcutTrigger`.
// 
// The output of this function is guaranteed to be the same for a given value
// only per-process. It may change between different processor architectures or
// even different versions of GTK. Do not use this function as a basis for
// building protocols or file formats.
// 
// The types of @trigger is #gconstpointer only to allow use of this function
// with Table. They must each be a `GtkShortcutTrigger`.
	func (t ShortcutTrigger) Hash() uint {
var _arg0 C.gconstpointer // out
var _cret C.guint // in

_arg0 = (C.gconstpointer)(unsafe.Pointer(t.Native()))

_cret = C.gtk_shortcut_trigger_hash(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// ToLabel gets textual representation for the given trigger.
// 
// This function is returning a translated string for presentation to end users
// for example in menu items or in help texts.
// 
// The @display in use may influence the resulting string in various forms, such
// as resolving hardware keycodes or by causing display-specific modifier names.
// 
// The form of the representation may change at any time and is not guaranteed
// to stay identical.
	func (s ShortcutTrigger) ToLabel(display gdk.DisplayClass) string {
var _arg0 *C.GtkShortcutTrigger // out
var _arg1 *C.GdkDisplay // out
var _cret *C.char // in

_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

_cret = C.gtk_shortcut_trigger_to_label(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// String prints the given trigger into a human-readable string.
// 
// This is a small wrapper around [method@Gtk.ShortcutTrigger.print] to help
// when debugging.
	func (s ShortcutTrigger) String() string {
var _arg0 *C.GtkShortcutTrigger // out
var _cret *C.char // in

_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(s.Native()))

_cret = C.gtk_shortcut_trigger_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Trigger checks if the given @event triggers @self.
	func (s ShortcutTrigger) Trigger(event gdk.EventClass, enableMnemonics bool) gdk.KeyMatch {
var _arg0 *C.GtkShortcutTrigger // out
var _arg1 *C.GdkEvent // out
var _arg2 C.gboolean // out
var _cret C.GdkKeyMatch // in

_arg0 = (*C.GtkShortcutTrigger)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))
if enableMnemonics { _arg2 = C.TRUE }

_cret = C.gtk_shortcut_trigger_trigger(_arg0, _arg1, _arg2)


var _keyMatch gdk.KeyMatch // out

_keyMatch = gdk.KeyMatch(_cret)

return _keyMatch
}
	


	// ShortcutsGroup: a `GtkShortcutsGroup` represents a group of related keyboard
// shortcuts or gestures.
// 
// The group has a title. It may optionally be associated with a view of the
// application, which can be used to show only relevant shortcuts depending on
// the application context.
// 
// This widget is only meant to be used with [class@Gtk.ShortcutsWindow].
	type ShortcutsGroup struct {
		Box
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// ShortcutsGroupClass is an interface that the ShortcutsGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsGroupClass interface {
		gextras.Objector
		_shortcutsGroup()
	}

	func (ShortcutsGroup) _shortcutsGroup() {}

	
	func marshalShortcutsGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsGroup(obj), nil
	}
	

	

	


	// ShortcutsSection: a `GtkShortcutsSection` collects all the keyboard shortcuts
// and gestures for a major application mode.
// 
// If your application needs multiple sections, you should give each section a
// unique [property@Gtk.ShortcutsSection:section-name] and a
// [property@Gtk.ShortcutsSection:title] that can be shown in the section
// selector of the [class@Gtk.ShortcutsWindow].
// 
// The [property@Gtk.ShortcutsSection:max-height] property can be used to
// influence how the groups in the section are distributed over pages and
// columns.
// 
// This widget is only meant to be used with [class@Gtk.ShortcutsWindow].
	type ShortcutsSection struct {
		Box
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// ShortcutsSectionClass is an interface that the ShortcutsSection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsSectionClass interface {
		gextras.Objector
		_shortcutsSection()
	}

	func (ShortcutsSection) _shortcutsSection() {}

	
	func marshalShortcutsSection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsSection(obj), nil
	}
	

	

	


	// ShortcutsShortcut: a `GtkShortcutsShortcut` represents a single keyboard
// shortcut or gesture with a short text.
// 
// This widget is only meant to be used with `GtkShortcutsWindow`.
	type ShortcutsShortcut struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// ShortcutsShortcutClass is an interface that the ShortcutsShortcut class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsShortcutClass interface {
		gextras.Objector
		_shortcutsShortcut()
	}

	func (ShortcutsShortcut) _shortcutsShortcut() {}

	
	func marshalShortcutsShortcut(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsShortcut(obj), nil
	}
	

	

	


	// ShortcutsWindow: a `GtkShortcutsWindow` shows information about the keyboard
// shortcuts and gestures of an application.
// 
// The shortcuts can be grouped, and you can have multiple sections in this
// window, corresponding to the major modes of your application.
// 
// Additionally, the shortcuts can be filtered by the current view, to avoid
// showing information that is not relevant in the current application context.
// 
// The recommended way to construct a `GtkShortcutsWindow` is with
// [class@Gtk.Builder], by populating a `GtkShortcutsWindow` with one or more
// `GtkShortcutsSection` objects, which contain `GtkShortcutsGroups` that in
// turn contain objects of class `GtkShortcutsShortcut`.
// 
// A simple example:
// 
// ! (gedit-shortcuts.png)
// 
// This example has as single section. As you can see, the shortcut groups are
// arranged in columns, and spread across several pages if there are too many to
// find on a single page.
// 
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-gedit.ui).
// 
// An example with multiple views:
// 
// ! (clocks-shortcuts.png)
// 
// This example shows a `GtkShortcutsWindow` that has been configured to show
// only the shortcuts relevant to the "stopwatch" view.
// 
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-clocks.ui).
// 
// An example with multiple sections:
// 
// ! (builder-shortcuts.png)
// 
// This example shows a `GtkShortcutsWindow` with two sections, "Editor
// Shortcuts" and "Terminal Shortcuts".
// 
// The .ui file for this example can be found here
// (https://gitlab.gnome.org/GNOME/gtk/tree/master/demos/gtk-demo/shortcuts-builder.ui).
	type ShortcutsWindow struct {
		Window
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// ShortcutsWindowClass is an interface that the ShortcutsWindow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ShortcutsWindowClass interface {
		gextras.Objector
		_shortcutsWindow()
	}

	func (ShortcutsWindow) _shortcutsWindow() {}

	
	func marshalShortcutsWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapShortcutsWindow(obj), nil
	}
	

	

	


	// SignalAction: a `GtkShortcut`Action that emits a signal.
// 
// Signals that are used in this way are referred to as keybinding signals, and
// they are expected to be defined with the G_SIGNAL_ACTION flag.
	type SignalAction struct {
		ShortcutAction
		
	}

	// SignalActionClass is an interface that the SignalAction class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SignalActionClass interface {
		gextras.Objector
		_signalAction()
	}

	func (SignalAction) _signalAction() {}

	
	func marshalSignalAction(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSignalAction(obj), nil
	}
	

	
	// NewSignalAction creates an action that when activated, emits the given action
// signal on the provided widget.
// 
// It will also unpack the args into arguments passed to the signal.
	func NewSignalAction(signalName string) SignalAction {
var _arg1 *C.char // out
var _cret *C.GtkShortcutAction // in

_arg1 = (*C.char)(C.CString(signalName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_signal_action_new(_arg1)


var _signalAction SignalAction // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_signalAction = SignalAction{
ShortcutAction: ShortcutAction{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _signalAction
}
	

	
	// SignalName returns the name of the signal that will be emitted.
	func (s SignalAction) SignalName() string {
var _arg0 *C.GtkSignalAction // out
var _cret *C.char // in

_arg0 = (*C.GtkSignalAction)(unsafe.Pointer(s.Native()))

_cret = C.gtk_signal_action_get_signal_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	


	// SignalListItemFactory: `GtkSignalListItemFactory` is a `GtkListItemFactory`
// that emits signals to to manage listitems.
// 
// Signals are emitted for every listitem in the same order:
// 
//    1. [signal@Gtk.SignalListItemFactory::setup] is emitted to set up permanent
//    things on the listitem. This usually means constructing the widgets used in
//    the row and adding them to the listitem.
// 
//    2. [signal@Gtk.SignalListItemFactory::bind] is emitted to bind the item passed
//    via [property@Gtk.ListItem:item] to the widgets that have been created in
//    step 1 or to add item-specific widgets. Signals are connected to listen to
//    changes - both to changes in the item to update the widgets or to changes
//    in the widgets to update the item. After this signal has been called, the
//    listitem may be shown in a list widget.
// 
//    3. [signal@Gtk.SignalListItemFactory::unbind] is emitted to undo everything
//    done in step 2. Usually this means disconnecting signal handlers. Once this
//    signal has been called, the listitem will no longer be used in a list
//    widget.
// 
//    4. [signal@Gtk.SignalListItemFactory::bind] and
//    [signal@Gtk.SignalListItemFactory::unbind] may be emitted multiple times
//    again to bind the listitem for use with new items. By reusing listitems,
//    potentially costly setup can be avoided. However, it means code needs to
//    make sure to properly clean up the listitem in step 3 so that no information
//    from the previous use leaks into the next use.
// 
// 5. [signal@Gtk.SignalListItemFactory::teardown] is emitted to allow undoing
// the effects of [signal@Gtk.SignalListItemFactory::setup]. After this signal
// was emitted on a listitem, the listitem will be destroyed and not be used
// again.
// 
// Note that during the signal emissions, changing properties on the ListItems
// passed will not trigger notify signals as the listitem's notifications are
// frozen. See g_object_freeze_notify() for details.
// 
// For tracking changes in other properties in the `GtkListItem`, the ::notify
// signal is recommended. The signal can be connected in the
// [signal@Gtk.SignalListItemFactory::setup] signal and removed again during
// [signal@Gtk.SignalListItemFactory::teardown].
	type SignalListItemFactory struct {
		ListItemFactory
		
	}

	// SignalListItemFactoryClass is an interface that the SignalListItemFactory class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SignalListItemFactoryClass interface {
		gextras.Objector
		_signalListItemFactory()
	}

	func (SignalListItemFactory) _signalListItemFactory() {}

	
	func marshalSignalListItemFactory(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSignalListItemFactory(obj), nil
	}
	

	
	// NewSignalListItemFactory creates a new `GtkSignalListItemFactory`.
// 
// You need to connect signal handlers before you use it.
	func NewSignalListItemFactory() SignalListItemFactory {
var _cret *C.GtkListItemFactory // in

_cret = C.gtk_signal_list_item_factory_new()


var _signalListItemFactory SignalListItemFactory // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_signalListItemFactory = SignalListItemFactory{
ListItemFactory: ListItemFactory{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _signalListItemFactory
}
	

	


	// SingleSelection: `GtkSingleSelection` is a `GtkSelectionModel` that allows
// selecting a single item.
// 
// Note that the selection is *persistent* -- if the selected item is removed
// and re-added in the same ::items-changed emission, it stays selected. In
// particular, this means that changing the sort order of an underlying sort
// model will preserve the selection.
	type SingleSelection struct {
		**externglib.Object
		gio.ListModel
		SelectionModel
		
	}

	// SingleSelectionClass is an interface that the SingleSelection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SingleSelectionClass interface {
		gextras.Objector
		_singleSelection()
	}

	func (SingleSelection) _singleSelection() {}

	
	func marshalSingleSelection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSingleSelection(obj), nil
	}
	

	
	// NewSingleSelection creates a new selection to handle @model.
	func NewSingleSelection(model gio.ListModel) SingleSelection {
var _arg1 *C.GListModel // out
var _cret *C.GtkSingleSelection // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_single_selection_new(_arg1)


var _singleSelection SingleSelection // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_singleSelection = SingleSelection{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
SelectionModel: SelectionModel{
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _singleSelection
}
	

	
	// Autoselect checks if autoselect has been enabled or disabled via
// gtk_single_selection_set_autoselect().
	func (s SingleSelection) Autoselect() bool {
var _arg0 *C.GtkSingleSelection // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_single_selection_get_autoselect(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanUnselect: if true, gtk_selection_model_unselect_item() is supported and
// allows unselecting the selected item.
	func (s SingleSelection) CanUnselect() bool {
var _arg0 *C.GtkSingleSelection // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_single_selection_get_can_unselect(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Model gets the model that @self is wrapping.
	func (s SingleSelection) Model() gio.ListModel {
var _arg0 *C.GtkSingleSelection // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_single_selection_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Selected gets the position of the selected item.
// 
// If no item is selected, GTK_INVALID_LIST_POSITION is returned.
	func (s SingleSelection) Selected() uint {
var _arg0 *C.GtkSingleSelection // out
var _cret C.guint // in

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_single_selection_get_selected(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SelectedItem gets the selected item.
// 
// If no item is selected, nil is returned.
	func (s SingleSelection) SelectedItem() **externglib.Object {
var _arg0 *C.GtkSingleSelection // out
var _cret C.gpointer // in

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_single_selection_get_selected_item(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// SetAutoselect enables or disables autoselect.
// 
// If @autoselect is true, @self will enforce that an item is always selected.
// It will select a new item when the currently selected item is deleted and it
// will disallow unselecting the current item.
	func (s SingleSelection) SetAutoselect(autoselect bool)  {
var _arg0 *C.GtkSingleSelection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
if autoselect { _arg1 = C.TRUE }

C.gtk_single_selection_set_autoselect(_arg0, _arg1)
}
	
	// SetCanUnselect: if true, unselecting the current item via
// gtk_selection_model_unselect_item() is supported.
// 
// Note that setting [property@Gtk.SingleSelection:autoselect] will cause
// unselecting to not work, so it practically makes no sense to set both at the
// same time the same time.
	func (s SingleSelection) SetCanUnselect(canUnselect bool)  {
var _arg0 *C.GtkSingleSelection // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
if canUnselect { _arg1 = C.TRUE }

C.gtk_single_selection_set_can_unselect(_arg0, _arg1)
}
	
	// SetModel sets the model that @self should wrap.
// 
// If @model is nil, @self will be empty.
	func (s SingleSelection) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkSingleSelection // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_single_selection_set_model(_arg0, _arg1)
}
	
	// SetSelected selects the item at the given position.
// 
// If the list does not have an item at @position or GTK_INVALID_LIST_POSITION
// is given, the behavior depends on the value of the
// [property@Gtk.SingleSelection:autoselect] property: If it is set, no change
// will occur and the old item will stay selected. If it is unset, the selection
// will be unset and no item will be selected.
	func (s SingleSelection) SetSelected(position uint)  {
var _arg0 *C.GtkSingleSelection // out
var _arg1 C.guint // out

_arg0 = (*C.GtkSingleSelection)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

C.gtk_single_selection_set_selected(_arg0, _arg1)
}
	


	// SizeGroup: `GtkSizeGroup` groups widgets together so they all request the
// same size.
// 
// This is typically useful when you want a column of widgets to have the same
// size, but you cant use a `GtkGrid`.
// 
// In detail, the size requested for each widget in a `GtkSizeGroup` is the
// maximum of the sizes that would have been requested for each widget in the
// size group if they were not in the size group. The mode of the size group
// (see [method@Gtk.SizeGroup.set_mode]) determines whether this applies to the
// horizontal size, the vertical size, or both sizes.
// 
// Note that size groups only affect the amount of space requested, not the size
// that the widgets finally receive. If you want the widgets in a `GtkSizeGroup`
// to actually be the same size, you need to pack them in such a way that they
// get the size they request and not more.
// 
// `GtkSizeGroup` objects are referenced by each widget in the size group, so
// once you have added all widgets to a `GtkSizeGroup`, you can drop the initial
// reference to the size group with g_object_unref(). If the widgets in the size
// group are subsequently destroyed, then they will be removed from the size
// group and drop their references on the size group; when all widgets have been
// removed, the size group will be freed.
// 
// Widgets can be part of multiple size groups; GTK will compute the horizontal
// size of a widget from the horizontal requisition of all widgets that can be
// reached from the widget by a chain of size groups of type
// GTK_SIZE_GROUP_HORIZONTAL or GTK_SIZE_GROUP_BOTH, and the vertical size from
// the vertical requisition of all widgets that can be reached from the widget
// by a chain of size groups of type GTK_SIZE_GROUP_VERTICAL or
// GTK_SIZE_GROUP_BOTH.
// 
// Note that only non-contextual sizes of every widget are ever consulted by
// size groups (since size groups have no knowledge of what size a widget will
// be allocated in one dimension, it cannot derive how much height a widget will
// receive for a given width). When grouping widgets that trade height for width
// in mode GTK_SIZE_GROUP_VERTICAL or GTK_SIZE_GROUP_BOTH: the height for the
// minimum width will be the requested height for all widgets in the group. The
// same is of course true when horizontally grouping width for height widgets.
// 
// Widgets that trade height-for-width should set a reasonably large minimum
// width by way of [property@Gtk.Label:width-chars] for instance. Widgets with
// static sizes as well as widgets that grow (such as ellipsizing text) need no
// such considerations.
// 
// 
// GtkSizeGroup as GtkBuildable
// 
// Size groups can be specified in a UI definition by placing an <object>
// element with `class="GtkSizeGroup"` somewhere in the UI definition. The
// widgets that belong to the size group are specified by a <widgets> element
// that may contain multiple <widget> elements, one for each member of the size
// group. The name attribute gives the id of the widget.
// 
// An example of a UI definition fragment with `GtkSizeGroup`: `xml <object
// class="GtkSizeGroup"> <property name="mode">horizontal</property> <widgets>
// <widget name="radio1"/> <widget name="radio2"/> </widgets> </object> `
	type SizeGroup struct {
		**externglib.Object
		Buildable
		
	}

	// SizeGroupClass is an interface that the SizeGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SizeGroupClass interface {
		gextras.Objector
		_sizeGroup()
	}

	func (SizeGroup) _sizeGroup() {}

	
	func marshalSizeGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSizeGroup(obj), nil
	}
	

	
	// NewSizeGroup: create a new `GtkSizeGroup`.
	func NewSizeGroup(mode SizeGroupMode) SizeGroup {
var _arg1 C.GtkSizeGroupMode // out
var _cret *C.GtkSizeGroup // in

_arg1 = (C.GtkSizeGroupMode)(mode)

_cret = C.gtk_size_group_new(_arg1)


var _sizeGroup SizeGroup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_sizeGroup = SizeGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _sizeGroup
}
	

	
	// AddWidget adds a widget to a `GtkSizeGroup`.
// 
// In the future, the requisition of the widget will be determined as the
// maximum of its requisition and the requisition of the other widgets in the
// size group. Whether this applies horizontally, vertically, or in both
// directions depends on the mode of the size group. See
// [method@Gtk.SizeGroup.set_mode].
// 
// When the widget is destroyed or no longer referenced elsewhere, it will be
// removed from the size group.
	func (s SizeGroup) AddWidget(widget WidgetClass)  {
var _arg0 *C.GtkSizeGroup // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_size_group_add_widget(_arg0, _arg1)
}
	
	// Mode gets the current mode of the size group.
	func (s SizeGroup) Mode() SizeGroupMode {
var _arg0 *C.GtkSizeGroup // out
var _cret C.GtkSizeGroupMode // in

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))

_cret = C.gtk_size_group_get_mode(_arg0)


var _sizeGroupMode SizeGroupMode // out

_sizeGroupMode = SizeGroupMode(_cret)

return _sizeGroupMode
}
	
	// RemoveWidget removes a widget from a `GtkSizeGroup`.
	func (s SizeGroup) RemoveWidget(widget WidgetClass)  {
var _arg0 *C.GtkSizeGroup // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_size_group_remove_widget(_arg0, _arg1)
}
	
	// SetMode sets the `GtkSizeGroupMode` of the size group.
// 
// The mode of the size group determines whether the widgets in the size group
// should all have the same horizontal requisition (GTK_SIZE_GROUP_HORIZONTAL)
// all have the same vertical requisition (GTK_SIZE_GROUP_VERTICAL), or should
// all have the same requisition in both directions (GTK_SIZE_GROUP_BOTH).
	func (s SizeGroup) SetMode(mode SizeGroupMode)  {
var _arg0 *C.GtkSizeGroup // out
var _arg1 C.GtkSizeGroupMode // out

_arg0 = (*C.GtkSizeGroup)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSizeGroupMode)(mode)

C.gtk_size_group_set_mode(_arg0, _arg1)
}
	


	// SliceListModel: `GtkSliceListModel` is a list model that presents a slice of
// another model.
// 
// This is useful when implementing paging by setting the size to the number of
// elements per page and updating the offset whenever a different page is
// opened.
	type SliceListModel struct {
		**externglib.Object
		gio.ListModel
		
	}

	// SliceListModelClass is an interface that the SliceListModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SliceListModelClass interface {
		gextras.Objector
		_sliceListModel()
	}

	func (SliceListModel) _sliceListModel() {}

	
	func marshalSliceListModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSliceListModel(obj), nil
	}
	

	
	// NewSliceListModel creates a new slice model.
// 
// It presents the slice from @offset to offset + @size of the given @model.
	func NewSliceListModel(model gio.ListModel, offset uint, size uint) SliceListModel {
var _arg1 *C.GListModel // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _cret *C.GtkSliceListModel // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
_arg2 = (C.guint)(offset)
_arg3 = (C.guint)(size)

_cret = C.gtk_slice_list_model_new(_arg1, _arg2, _arg3)


var _sliceListModel SliceListModel // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_sliceListModel = SliceListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _sliceListModel
}
	

	
	// Model gets the model that is currently being used or nil if none.
	func (s SliceListModel) Model() gio.ListModel {
var _arg0 *C.GtkSliceListModel // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_slice_list_model_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Offset gets the offset set via gtk_slice_list_model_set_offset().
	func (s SliceListModel) Offset() uint {
var _arg0 *C.GtkSliceListModel // out
var _cret C.guint // in

_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_slice_list_model_get_offset(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Size gets the size set via gtk_slice_list_model_set_size().
	func (s SliceListModel) Size() uint {
var _arg0 *C.GtkSliceListModel // out
var _cret C.guint // in

_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_slice_list_model_get_size(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// SetModel sets the model to show a slice of.
// 
// The model's item type must conform to @self's item type.
	func (s SliceListModel) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkSliceListModel // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_slice_list_model_set_model(_arg0, _arg1)
}
	
	// SetOffset sets the offset into the original model for this slice.
// 
// If the offset is too large for the sliced model, @self will end up empty.
	func (s SliceListModel) SetOffset(offset uint)  {
var _arg0 *C.GtkSliceListModel // out
var _arg1 C.guint // out

_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(offset)

C.gtk_slice_list_model_set_offset(_arg0, _arg1)
}
	
	// SetSize sets the maximum size. @self will never have more items than @size.
// 
// It can however have fewer items if the offset is too large or the model
// sliced from doesn't have enough items.
	func (s SliceListModel) SetSize(size uint)  {
var _arg0 *C.GtkSliceListModel // out
var _arg1 C.guint // out

_arg0 = (*C.GtkSliceListModel)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(size)

C.gtk_slice_list_model_set_size(_arg0, _arg1)
}
	


	// Snapshot: `GtkSnapshot` assists in creating `GskRenderNodes` for widgets.
// 
// It functions in a similar way to a cairo context, and maintains a stack of
// render nodes and their associated transformations.
// 
// The node at the top of the stack is the the one that gtk_snapshot_append_
// functions operate on. Use the gtk_snapshot_push_ functions and
// gtk_snapshot_pop() to change the current node.
// 
// The typical way to obtain a `GtkSnapshot` object is as an argument to the
// GtkWidgetClass.snapshot() vfunc. If you need to create your own
// `GtkSnapshot`, use [ctor@Gtk.Snapshot.new].
	type Snapshot struct {
		gdk.Snapshot
		
	}

	// SnapshotClass is an interface that the Snapshot class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SnapshotClass interface {
		gextras.Objector
		_snapshot()
	}

	func (Snapshot) _snapshot() {}

	
	func marshalSnapshot(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSnapshot(obj), nil
	}
	

	
	// NewSnapshot creates a new `GtkSnapshot`.
	func NewSnapshot() Snapshot {
var _cret *C.GtkSnapshot // in

_cret = C.gtk_snapshot_new()


var _snapshot Snapshot // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_snapshot = Snapshot{
Snapshot: gdk.Snapshot{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _snapshot
}
	

	
	// AppendBorder appends a stroked border rectangle inside the given @outline.
// 
// The four sides of the border can have different widths and colors.
	func (s Snapshot) AppendBorder(outline *gsk.RoundedRect, borderWidth [4]float32, borderColor [4]gdk.RGBA)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GskRoundedRect // out
var _arg2 *C.float
var _arg3 *C.GdkRGBA

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
_arg2 = (*C.float)(unsafe.Pointer(&borderWidth))
_arg3 = (*C.GdkRGBA)(unsafe.Pointer(&borderColor))

C.gtk_snapshot_append_border(_arg0, _arg1, _arg2, _arg3)
}
	
	// AppendCairo creates a new `GskCairoNode` and appends it to the current render
// node of @snapshot, without changing the current node.
	func (s Snapshot) AppendCairo(bounds *graphene.Rect) *cairo.Context {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out
var _cret *C.cairo_t // in

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

_cret = C.gtk_snapshot_append_cairo(_arg0, _arg1)


var _context *cairo.Context // out

_context = *(**cairo.Context)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_context, func(v *cairo.Context) {
  C.free(unsafe.Pointer(v.Native()))
})

return _context
}
	
	// AppendColor creates a new render node drawing the @color into the given
// @bounds and appends it to the current render node of @snapshot.
// 
// You should try to avoid calling this function if @color is transparent.
	func (s Snapshot) AppendColor(color *gdk.RGBA, bounds *graphene.Rect)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GdkRGBA // out
var _arg2 *C.graphene_rect_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

C.gtk_snapshot_append_color(_arg0, _arg1, _arg2)
}
	
	// AppendConicGradient appends a conic gradient node with the given stops to
// @snapshot.
	func (s Snapshot) AppendConicGradient(bounds *graphene.Rect, center *graphene.Point, rotation float32, stops []gsk.ColorStop)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out
var _arg2 *C.graphene_point_t // out
var _arg3 C.float // out
var _arg4 *C.GskColorStop
var _arg5 C.gsize

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
_arg3 = (C.float)(rotation)
_arg5 = C.gsize(len(stops))
_arg4 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

C.gtk_snapshot_append_conic_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// AppendInsetShadow appends an inset shadow into the box given by @outline.
	func (s Snapshot) AppendInsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GskRoundedRect // out
var _arg2 *C.GdkRGBA // out
var _arg3 C.float // out
var _arg4 C.float // out
var _arg5 C.float // out
var _arg6 C.float // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
_arg3 = (C.float)(dx)
_arg4 = (C.float)(dy)
_arg5 = (C.float)(spread)
_arg6 = (C.float)(blurRadius)

C.gtk_snapshot_append_inset_shadow(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}
	
	
	func (s Snapshot) AppendLayout(layout pango.LayoutClass, color *gdk.RGBA)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.PangoLayout // out
var _arg2 *C.GdkRGBA // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))

C.gtk_snapshot_append_layout(_arg0, _arg1, _arg2)
}
	
	// AppendLinearGradient appends a linear gradient node with the given stops to
// @snapshot.
	func (s Snapshot) AppendLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out
var _arg2 *C.graphene_point_t // out
var _arg3 *C.graphene_point_t // out
var _arg4 *C.GskColorStop
var _arg5 C.gsize

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
_arg2 = (*C.graphene_point_t)(unsafe.Pointer(startPoint.Native()))
_arg3 = (*C.graphene_point_t)(unsafe.Pointer(endPoint.Native()))
_arg5 = C.gsize(len(stops))
_arg4 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

C.gtk_snapshot_append_linear_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// AppendNode appends @node to the current render node of @snapshot, without
// changing the current node.
// 
// If @snapshot does not have a current node yet, @node will become the initial
// node.
	func (s Snapshot) AppendNode(node gsk.RenderNodeClass)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GskRenderNode // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GskRenderNode)(unsafe.Pointer(node.Native()))

C.gtk_snapshot_append_node(_arg0, _arg1)
}
	
	// AppendOutsetShadow appends an outset shadow node around the box given by
// @outline.
	func (s Snapshot) AppendOutsetShadow(outline *gsk.RoundedRect, color *gdk.RGBA, dx float32, dy float32, spread float32, blurRadius float32)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GskRoundedRect // out
var _arg2 *C.GdkRGBA // out
var _arg3 C.float // out
var _arg4 C.float // out
var _arg5 C.float // out
var _arg6 C.float // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(outline.Native()))
_arg2 = (*C.GdkRGBA)(unsafe.Pointer(color.Native()))
_arg3 = (C.float)(dx)
_arg4 = (C.float)(dy)
_arg5 = (C.float)(spread)
_arg6 = (C.float)(blurRadius)

C.gtk_snapshot_append_outset_shadow(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}
	
	// AppendRadialGradient appends a radial gradient node with the given stops to
// @snapshot.
	func (s Snapshot) AppendRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out
var _arg2 *C.graphene_point_t // out
var _arg3 C.float // out
var _arg4 C.float // out
var _arg5 C.float // out
var _arg6 C.float // out
var _arg7 *C.GskColorStop
var _arg8 C.gsize

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
_arg3 = (C.float)(hradius)
_arg4 = (C.float)(vradius)
_arg5 = (C.float)(start)
_arg6 = (C.float)(end)
_arg8 = C.gsize(len(stops))
_arg7 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

C.gtk_snapshot_append_radial_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}
	
	// AppendRepeatingLinearGradient appends a repeating linear gradient node with
// the given stops to @snapshot.
	func (s Snapshot) AppendRepeatingLinearGradient(bounds *graphene.Rect, startPoint *graphene.Point, endPoint *graphene.Point, stops []gsk.ColorStop)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out
var _arg2 *C.graphene_point_t // out
var _arg3 *C.graphene_point_t // out
var _arg4 *C.GskColorStop
var _arg5 C.gsize

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
_arg2 = (*C.graphene_point_t)(unsafe.Pointer(startPoint.Native()))
_arg3 = (*C.graphene_point_t)(unsafe.Pointer(endPoint.Native()))
_arg5 = C.gsize(len(stops))
_arg4 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

C.gtk_snapshot_append_repeating_linear_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// AppendRepeatingRadialGradient appends a repeating radial gradient node with
// the given stops to @snapshot.
	func (s Snapshot) AppendRepeatingRadialGradient(bounds *graphene.Rect, center *graphene.Point, hradius float32, vradius float32, start float32, end float32, stops []gsk.ColorStop)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out
var _arg2 *C.graphene_point_t // out
var _arg3 C.float // out
var _arg4 C.float // out
var _arg5 C.float // out
var _arg6 C.float // out
var _arg7 *C.GskColorStop
var _arg8 C.gsize

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
_arg2 = (*C.graphene_point_t)(unsafe.Pointer(center.Native()))
_arg3 = (C.float)(hradius)
_arg4 = (C.float)(vradius)
_arg5 = (C.float)(start)
_arg6 = (C.float)(end)
_arg8 = C.gsize(len(stops))
_arg7 = (*C.GskColorStop)(unsafe.Pointer(&stops[0]))

C.gtk_snapshot_append_repeating_radial_gradient(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8)
}
	
	// AppendTexture creates a new render node drawing the @texture into the given
// @bounds and appends it to the current render node of @snapshot.
	func (s Snapshot) AppendTexture(texture gdk.TextureClass, bounds *graphene.Rect)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GdkTexture // out
var _arg2 *C.graphene_rect_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GdkTexture)(unsafe.Pointer(texture.Native()))
_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

C.gtk_snapshot_append_texture(_arg0, _arg1, _arg2)
}
	
	// GLShaderPopTexture removes the top element from the stack of render nodes and
// adds it to the nearest `GskGLShaderNode` below it.
// 
// This must be called the same number of times as the number of textures is
// needed for the shader in [method@Gtk.Snapshot.push_gl_shader].
	func (s Snapshot) GLShaderPopTexture()  {
var _arg0 *C.GtkSnapshot // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

C.gtk_snapshot_gl_shader_pop_texture(_arg0)
}
	
	// Perspective applies a perspective projection transform.
// 
// See [method@Gsk.Transform.perspective] for a discussion on the details.
	func (s Snapshot) Perspective(depth float32)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.float // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(depth)

C.gtk_snapshot_perspective(_arg0, _arg1)
}
	
	// Pop removes the top element from the stack of render nodes, and appends it to
// the node underneath it.
	func (s Snapshot) Pop()  {
var _arg0 *C.GtkSnapshot // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

C.gtk_snapshot_pop(_arg0)
}
	
	// PushBlend blends together two images with the given blend mode.
// 
// Until the first call to [method@Gtk.Snapshot.pop], the bottom image for the
// blend operation will be recorded. After that call, the top image to be
// blended will be recorded until the second call to [method@Gtk.Snapshot.pop].
// 
// Calling this function requires two subsequent calls to
// [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushBlend(blendMode gsk.BlendMode)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.GskBlendMode // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.GskBlendMode)(blendMode)

C.gtk_snapshot_push_blend(_arg0, _arg1)
}
	
	// PushBlur blurs an image.
// 
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushBlur(radius float64)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.double // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(radius)

C.gtk_snapshot_push_blur(_arg0, _arg1)
}
	
	// PushClip clips an image to a rectangle.
// 
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushClip(bounds *graphene.Rect)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))

C.gtk_snapshot_push_clip(_arg0, _arg1)
}
	
	// PushColorMatrix modifies the colors of an image by applying an affine
// transformation in RGB space.
// 
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushColorMatrix(colorMatrix *graphene.Matrix, colorOffset *graphene.Vec4)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_matrix_t // out
var _arg2 *C.graphene_vec4_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(colorMatrix.Native()))
_arg2 = (*C.graphene_vec4_t)(unsafe.Pointer(colorOffset.Native()))

C.gtk_snapshot_push_color_matrix(_arg0, _arg1, _arg2)
}
	
	// PushCrossFade snapshots a cross-fade operation between two images with the
// given @progress.
// 
// Until the first call to [method@Gtk.Snapshot.pop], the start image will be
// snapshot. After that call, the end image will be recorded until the second
// call to [method@Gtk.Snapshot.pop].
// 
// Calling this function requires two subsequent calls to
// [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushCrossFade(progress float64)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.double // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(progress)

C.gtk_snapshot_push_cross_fade(_arg0, _arg1)
}
	
	// PushOpacity modifies the opacity of an image.
// 
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushOpacity(opacity float64)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.double // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(opacity)

C.gtk_snapshot_push_opacity(_arg0, _arg1)
}
	
	// PushRepeat creates a node that repeats the child node.
// 
// The child is recorded until the next call to [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushRepeat(bounds *graphene.Rect, childBounds *graphene.Rect)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_rect_t // out
var _arg2 *C.graphene_rect_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_rect_t)(unsafe.Pointer(bounds.Native()))
_arg2 = (*C.graphene_rect_t)(unsafe.Pointer(childBounds.Native()))

C.gtk_snapshot_push_repeat(_arg0, _arg1, _arg2)
}
	
	// PushRoundedClip clips an image to a rounded rectangle.
// 
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushRoundedClip(bounds *gsk.RoundedRect)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GskRoundedRect // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GskRoundedRect)(unsafe.Pointer(bounds.Native()))

C.gtk_snapshot_push_rounded_clip(_arg0, _arg1)
}
	
	// PushShadow applies a shadow to an image.
// 
// The image is recorded until the next call to [method@Gtk.Snapshot.pop].
	func (s Snapshot) PushShadow(shadow *gsk.Shadow, nShadows uint)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GskShadow // out
var _arg2 C.gsize // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GskShadow)(unsafe.Pointer(shadow.Native()))
_arg2 = (C.gsize)(nShadows)

C.gtk_snapshot_push_shadow(_arg0, _arg1, _arg2)
}
	
	// RenderBackground creates a render node for the CSS background according to
// @context, and appends it to the current node of @snapshot, without changing
// the current node.
	func (s Snapshot) RenderBackground(context StyleContextClass, x float64, y float64, width float64, height float64)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.double)(x)
_arg3 = (C.double)(y)
_arg4 = (C.double)(width)
_arg5 = (C.double)(height)

C.gtk_snapshot_render_background(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// RenderFocus creates a render node for the focus outline according to
// @context, and appends it to the current node of @snapshot, without changing
// the current node.
	func (s Snapshot) RenderFocus(context StyleContextClass, x float64, y float64, width float64, height float64)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.double)(x)
_arg3 = (C.double)(y)
_arg4 = (C.double)(width)
_arg5 = (C.double)(height)

C.gtk_snapshot_render_focus(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// RenderFrame creates a render node for the CSS border according to @context,
// and appends it to the current node of @snapshot, without changing the current
// node.
	func (s Snapshot) RenderFrame(context StyleContextClass, x float64, y float64, width float64, height float64)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.double // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.double)(x)
_arg3 = (C.double)(y)
_arg4 = (C.double)(width)
_arg5 = (C.double)(height)

C.gtk_snapshot_render_frame(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// RenderInsertionCursor draws a text caret using @snapshot at the specified
// index of @layout.
	func (s Snapshot) RenderInsertionCursor(context StyleContextClass, x float64, y float64, layout pango.LayoutClass, index int, direction pango.Direction)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 *C.PangoLayout // out
var _arg5 C.int // out
var _arg6 C.PangoDirection // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.double)(x)
_arg3 = (C.double)(y)
_arg4 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
_arg5 = (C.int)(index)
_arg6 = (C.PangoDirection)(direction)

C.gtk_snapshot_render_insertion_cursor(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}
	
	// RenderLayout creates a render node for rendering @layout according to the
// style information in @context, and appends it to the current node of
// @snapshot, without changing the current node.
	func (s Snapshot) RenderLayout(context StyleContextClass, x float64, y float64, layout pango.LayoutClass)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GtkStyleContext // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 *C.PangoLayout // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStyleContext)(unsafe.Pointer(context.Native()))
_arg2 = (C.double)(x)
_arg3 = (C.double)(y)
_arg4 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))

C.gtk_snapshot_render_layout(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Restore restores @snapshot to the state saved by a preceding call to
// gtk_snapshot_save() and removes that state from the stack of saved states.
	func (s Snapshot) Restore()  {
var _arg0 *C.GtkSnapshot // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

C.gtk_snapshot_restore(_arg0)
}
	
	// Rotate rotates @@snapshot's coordinate system by @angle degrees in 2D space -
// or in 3D speak, rotates around the Z axis.
// 
// To rotate around other axes, use [method@Gsk.Transform.rotate_3d].
	func (s Snapshot) Rotate(angle float32)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.float // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(angle)

C.gtk_snapshot_rotate(_arg0, _arg1)
}
	
	// Rotate3D rotates @snapshot's coordinate system by @angle degrees around
// @axis.
// 
// For a rotation in 2D space, use [method@Gsk.Transform.rotate].
	func (s Snapshot) Rotate3D(angle float32, axis *graphene.Vec3)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.float // out
var _arg2 *C.graphene_vec3_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(angle)
_arg2 = (*C.graphene_vec3_t)(unsafe.Pointer(axis.Native()))

C.gtk_snapshot_rotate_3d(_arg0, _arg1, _arg2)
}
	
	// Save makes a copy of the current state of @snapshot and saves it on an
// internal stack.
// 
// When [method@Gtk.Snapshot.restore] is called, @snapshot will be restored to
// the saved state. Multiple calls to gtk_snapshot_save() and
// gtk_snapshot_restore() can be nested; each call to gtk_snapshot_restore()
// restores the state from the matching paired gtk_snapshot_save().
// 
// It is necessary to clear all saved states with corresponding calls to
// gtk_snapshot_restore().
	func (s Snapshot) Save()  {
var _arg0 *C.GtkSnapshot // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

C.gtk_snapshot_save(_arg0)
}
	
	// Scale scales @snapshot's coordinate system in 2-dimensional space by the
// given factors.
// 
// Use [method@Gtk.Snapshot.scale_3d] to scale in all 3 dimensions.
	func (s Snapshot) Scale(factorX float32, factorY float32)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.float // out
var _arg2 C.float // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(factorX)
_arg2 = (C.float)(factorY)

C.gtk_snapshot_scale(_arg0, _arg1, _arg2)
}
	
	// Scale3D scales @snapshot's coordinate system by the given factors.
	func (s Snapshot) Scale3D(factorX float32, factorY float32, factorZ float32)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 C.float // out
var _arg2 C.float // out
var _arg3 C.float // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (C.float)(factorX)
_arg2 = (C.float)(factorY)
_arg3 = (C.float)(factorZ)

C.gtk_snapshot_scale_3d(_arg0, _arg1, _arg2, _arg3)
}
	
	// ToNode returns the render node that was constructed by @snapshot.
// 
// After calling this function, it is no longer possible to add more nodes to
// @snapshot. The only function that should be called after this is
// g_object_unref().
	func (s Snapshot) ToNode() gsk.RenderNode {
var _arg0 *C.GtkSnapshot // out
var _cret *C.GskRenderNode // in

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))

_cret = C.gtk_snapshot_to_node(_arg0)


var _renderNode gsk.RenderNode // out

_renderNode = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gsk.RenderNode)

return _renderNode
}
	
	// ToPaintable returns a paintable encapsulating the render node that was
// constructed by @snapshot.
// 
// After calling this function, it is no longer possible to add more nodes to
// @snapshot. The only function that should be called after this is
// g_object_unref().
	func (s Snapshot) ToPaintable(size *graphene.Size) gdk.Paintable {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_size_t // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_size_t)(unsafe.Pointer(size.Native()))

_cret = C.gtk_snapshot_to_paintable(_arg0, _arg1)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// Transform transforms @snapshot's coordinate system with the given @transform.
	func (s Snapshot) Transform(transform *gsk.Transform)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.GskTransform // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

C.gtk_snapshot_transform(_arg0, _arg1)
}
	
	// TransformMatrix transforms @snapshot's coordinate system with the given
// @matrix.
	func (s Snapshot) TransformMatrix(matrix *graphene.Matrix)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_matrix_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_matrix_t)(unsafe.Pointer(matrix.Native()))

C.gtk_snapshot_transform_matrix(_arg0, _arg1)
}
	
	// Translate translates @snapshot's coordinate system by @point in 2-dimensional
// space.
	func (s Snapshot) Translate(point *graphene.Point)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_point_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

C.gtk_snapshot_translate(_arg0, _arg1)
}
	
	// Translate3D translates @snapshot's coordinate system by @point.
	func (s Snapshot) Translate3D(point *graphene.Point3D)  {
var _arg0 *C.GtkSnapshot // out
var _arg1 *C.graphene_point3d_t // out

_arg0 = (*C.GtkSnapshot)(unsafe.Pointer(s.Native()))
_arg1 = (*C.graphene_point3d_t)(unsafe.Pointer(point.Native()))

C.gtk_snapshot_translate_3d(_arg0, _arg1)
}
	


	// SortListModel: `GtkSortListModel` is a list model that sorts the elements of
// the underlying model according to a `GtkSorter`.
// 
// The model can be set up to do incremental sorting, so that sorting long lists
// doesn't block the UI. See [method@Gtk.SortListModel.set_incremental] for
// details.
// 
// `GtkSortListModel` is a generic model and because of that it cannot take
// advantage of any external knowledge when sorting. If you run into performance
// issues with `GtkSortListModel`, it is strongly recommended that you write
// your own sorting list model.
	type SortListModel struct {
		**externglib.Object
		gio.ListModel
		
	}

	// SortListModelClass is an interface that the SortListModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SortListModelClass interface {
		gextras.Objector
		_sortListModel()
	}

	func (SortListModel) _sortListModel() {}

	
	func marshalSortListModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSortListModel(obj), nil
	}
	

	
	// NewSortListModel creates a new sort list model that uses the @sorter to sort
// @model.
	func NewSortListModel(model gio.ListModel, sorter SorterClass) SortListModel {
var _arg1 *C.GListModel // out
var _arg2 *C.GtkSorter // out
var _cret *C.GtkSortListModel // in

_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

_cret = C.gtk_sort_list_model_new(_arg1, _arg2)


var _sortListModel SortListModel // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_sortListModel = SortListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
ListModel: gio.ListModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _sortListModel
}
	

	
	// Incremental returns whether incremental sorting is enabled.
// 
// See [method@Gtk.SortListModel.set_incremental].
	func (s SortListModel) Incremental() bool {
var _arg0 *C.GtkSortListModel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_sort_list_model_get_incremental(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Model gets the model currently sorted or nil if none.
	func (s SortListModel) Model() gio.ListModel {
var _arg0 *C.GtkSortListModel // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_sort_list_model_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Pending estimates progress of an ongoing sorting operation.
// 
// The estimate is the number of items that would still need to be sorted to
// finish the sorting operation if this was a linear algorithm. So this number
// is not related to how many items are already correctly sorted.
// 
// If you want to estimate the progress, you can use code like this: `c pending
// = gtk_sort_list_model_get_pending (self); model =
// gtk_sort_list_model_get_model (self); progress = 1.0 - pending / (double) MAX
// (1, g_list_model_get_n_items (model)); `
// 
// If no sort operation is ongoing - in particular when
// [property@Gtk.SortListModel:incremental] is false - this function returns 0.
	func (s SortListModel) Pending() uint {
var _arg0 *C.GtkSortListModel // out
var _cret C.guint // in

_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_sort_list_model_get_pending(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Sorter gets the sorter that is used to sort @self.
	func (s SortListModel) Sorter() Sorter {
var _arg0 *C.GtkSortListModel // out
var _cret *C.GtkSorter // in

_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_sort_list_model_get_sorter(_arg0)


var _sorter Sorter // out

_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

return _sorter
}
	
	// SetIncremental sets the sort model to do an incremental sort.
// 
// When incremental sorting is enabled, the `GtkSortListModel` will not do a
// complete sort immediately, but will instead queue an idle handler that
// incrementally sorts the items towards their correct position. This of course
// means that items do not instantly appear in the right place. It also means
// that the total sorting time is a lot slower.
// 
// When your filter blocks the UI while sorting, you might consider turning this
// on. Depending on your model and sorters, this may become interesting around
// 10,000 to 100,000 items.
// 
// By default, incremental sorting is disabled.
// 
// See [method@Gtk.SortListModel.get_pending] for progress information about an
// ongoing incremental sorting operation.
	func (s SortListModel) SetIncremental(incremental bool)  {
var _arg0 *C.GtkSortListModel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))
if incremental { _arg1 = C.TRUE }

C.gtk_sort_list_model_set_incremental(_arg0, _arg1)
}
	
	// SetModel sets the model to be sorted.
// 
// The @model's item type must conform to the item type of @self.
	func (s SortListModel) SetModel(model gio.ListModel)  {
var _arg0 *C.GtkSortListModel // out
var _arg1 *C.GListModel // out

_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GListModel)(unsafe.Pointer(model.Native()))

C.gtk_sort_list_model_set_model(_arg0, _arg1)
}
	
	// SetSorter sets a new sorter on @self.
	func (s SortListModel) SetSorter(sorter SorterClass)  {
var _arg0 *C.GtkSortListModel // out
var _arg1 *C.GtkSorter // out

_arg0 = (*C.GtkSortListModel)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

C.gtk_sort_list_model_set_sorter(_arg0, _arg1)
}
	


	// Sorter: `GtkSorter` is an object to describe sorting criteria.
// 
// Its primary user is [class@Gtk.SortListModel]
// 
// The model will use a sorter to determine the order in which its items should
// appear by calling [method@Gtk.Sorter.compare] for pairs of items.
// 
// Sorters may change their sorting behavior through their lifetime. In that
// case, they will emit the [signal@Gtk.Sorter::changed] signal to notify that
// the sort order is no longer valid and should be updated by calling
// gtk_sorter_compare() again.
// 
// GTK provides various pre-made sorter implementations for common sorting
// operations. [class@Gtk.ColumnView] has built-in support for sorting lists via
// the [property@Gtk.ColumnViewColumn:sorter] property, where the user can
// change the sorting by clicking on list headers.
// 
// Of course, in particular for large lists, it is also possible to subclass
// `GtkSorter` and provide one's own sorter.
	type Sorter struct {
		**externglib.Object
		
	}

	// SorterClass is an interface that the Sorter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SorterClass interface {
		gextras.Objector
		_sorter()
	}

	func (Sorter) _sorter() {}

	
	func marshalSorter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSorter(obj), nil
	}
	

	

	
	// Changed emits the [signal@Gtk.Sorter::changed] signal to notify all users of
// the sorter that it has changed.
// 
// Users of the sorter should then update the sort order via
// gtk_sorter_compare().
// 
// Depending on the @change parameter, it may be possible to update the sort
// order without a full resorting. Refer to the [enum@Gtk.SorterChange]
// documentation for details.
// 
// This function is intended for implementors of `GtkSorter` subclasses and
// should not be called from other functions.
	func (s Sorter) Changed(change SorterChange)  {
var _arg0 *C.GtkSorter // out
var _arg1 C.GtkSorterChange // out

_arg0 = (*C.GtkSorter)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSorterChange)(change)

C.gtk_sorter_changed(_arg0, _arg1)
}
	
	// Compare compares two given items according to the sort order implemented by
// the sorter.
// 
// Sorters implement a partial order:
// 
// * It is reflexive, ie a = a * It is antisymmetric, ie if a < b and b < a,
// then a = b * It is transitive, ie given any 3 items with a  b and b  c,
// then a  c
// 
// The sorter may signal it conforms to additional constraints via the return
// value of [method@Gtk.Sorter.get_order].
	func (s Sorter) Compare(item1 **externglib.Object, item2 **externglib.Object) Ordering {
var _arg0 *C.GtkSorter // out
var _arg1 C.gpointer // out
var _arg2 C.gpointer // out
var _cret C.GtkOrdering // in

_arg0 = (*C.GtkSorter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GObject)(unsafe.Pointer(item1.Native()))
_arg2 = (*C.GObject)(unsafe.Pointer(item2.Native()))

_cret = C.gtk_sorter_compare(_arg0, _arg1, _arg2)


var _ordering Ordering // out

_ordering = Ordering(_cret)

return _ordering
}
	
	// Order gets the order that @self conforms to.
// 
// See [enum@Gtk.SorterOrder] for details of the possible return values.
// 
// This function is intended to allow optimizations.
	func (s Sorter) Order() SorterOrder {
var _arg0 *C.GtkSorter // out
var _cret C.GtkSorterOrder // in

_arg0 = (*C.GtkSorter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_sorter_get_order(_arg0)


var _sorterOrder SorterOrder // out

_sorterOrder = SorterOrder(_cret)

return _sorterOrder
}
	


	// SpinButton: a `GtkSpinButton` is an ideal way to allow the user to set the
// value of some attribute.
// 
// !An example GtkSpinButton (spinbutton.png)
// 
// Rather than having to directly type a number into a `GtkEntry`,
// `GtkSpinButton` allows the user to click on one of two arrows to increment or
// decrement the displayed value. A value can still be typed in, with the bonus
// that it can be checked to ensure it is in a given range.
// 
// The main properties of a `GtkSpinButton` are through an adjustment. See the
// [class@Gtk.Adjustment] documentation for more details about an adjustment's
// properties.
// 
// Note that `GtkSpinButton` will by default make its entry large enough to
// accommodate the lower and upper bounds of the adjustment. If this is not
// desired, the automatic sizing can be turned off by explicitly setting
// [property@Gtk.Editable:width-chars] to a value != -1.
// 
// 
// Using a GtkSpinButton to get an integer
// 
// `c // Provides a function to retrieve an integer value from a GtkSpinButton
// // and creates a spin button to model percentage values.
// 
// int grab_int_value (GtkSpinButton *button, gpointer user_data) { return
// gtk_spin_button_get_value_as_int (button); }
// 
// void create_integer_spin_button (void) {
// 
//    GtkWidget *window, *button;
//    GtkAdjustment *adjustment;
// 
//    adjustment = gtk_adjustment_new (50.0, 0.0, 100.0, 1.0, 5.0, 0.0);
// 
//    window = gtk_window_new ();
// 
//    // creates the spinbutton, with no decimal places
//    button = gtk_spin_button_new (adjustment, 1.0, 0);
//    gtk_window_set_child (GTK_WINDOW (window), button);
// 
//    gtk_widget_show (window);
// 
// } `
// 
// 
// Using a GtkSpinButton to get a floating point value
// 
// `c // Provides a function to retrieve a floating point value from a //
// GtkSpinButton, and creates a high precision spin button.
// 
// float grab_float_value (GtkSpinButton *button, gpointer user_data) { return
// gtk_spin_button_get_value (button); }
// 
// void create_floating_spin_button (void) { GtkWidget *window, *button;
// GtkAdjustment *adjustment;
// 
//    adjustment = gtk_adjustment_new (2.500, 0.0, 5.0, 0.001, 0.1, 0.0);
// 
//    window = gtk_window_new ();
// 
//    // creates the spinbutton, with three decimal places
//    button = gtk_spin_button_new (adjustment, 0.001, 3);
//    gtk_window_set_child (GTK_WINDOW (window), button);
// 
//    gtk_widget_show (window);
// 
// } `
// 
// 
// CSS nodes
// 
// ` spinbutton.horizontal  text   undershoot.left  
// undershoot.right  button.down  button.up `
// 
// ` spinbutton.vertical  button.up  text   undershoot.left  
// undershoot.right  button.down `
// 
// `GtkSpinButton`s main CSS node has the name spinbutton. It creates subnodes
// for the entry and the two buttons, with these names. The button nodes have
// the style classes .up and .down. The `GtkText` subnodes (if present) are put
// below the text node. The orientation of the spin button is reflected in the
// .vertical or .horizontal style class on the main node.
// 
// 
// Accessiblity
// 
// `GtkSpinButton` uses the GTK_ACCESSIBLE_ROLE_SPIN_BUTTON role.
	type SpinButton struct {
		Widget
		Accessible
		Buildable
		CellEditable
		ConstraintTarget
		Editable
		Orientable
		
	}

	// SpinButtonClass is an interface that the SpinButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SpinButtonClass interface {
		gextras.Objector
		_spinButton()
	}

	func (SpinButton) _spinButton() {}

	
	func marshalSpinButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSpinButton(obj), nil
	}
	

	
	// NewSpinButton creates a new `GtkSpinButton`.
	func NewSpinButton(adjustment AdjustmentClass, climbRate float64, digits uint) SpinButton {
var _arg1 *C.GtkAdjustment // out
var _arg2 C.double // out
var _arg3 C.guint // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
_arg2 = (C.double)(climbRate)
_arg3 = (C.guint)(digits)

_cret = C.gtk_spin_button_new(_arg1, _arg2, _arg3)


var _spinButton SpinButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_spinButton = SpinButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _spinButton
}
	
	// NewSpinButtonWithRange creates a new `GtkSpinButton` with the given
// properties.
// 
// This is a convenience constructor that allows creation of a numeric
// `GtkSpinButton` without manually creating an adjustment. The value is
// initially set to the minimum value and a page increment of 10 * @step is the
// default. The precision of the spin button is equivalent to the precision of
// @step.
// 
// Note that the way in which the precision is derived works best if @step is a
// power of ten. If the resulting precision is not suitable for your needs, use
// [method@Gtk.SpinButton.set_digits] to correct it.
	func NewSpinButtonWithRange(min float64, max float64, step float64) SpinButton {
var _arg1 C.double // out
var _arg2 C.double // out
var _arg3 C.double // out
var _cret *C.GtkWidget // in

_arg1 = (C.double)(min)
_arg2 = (C.double)(max)
_arg3 = (C.double)(step)

_cret = C.gtk_spin_button_new_with_range(_arg1, _arg2, _arg3)


var _spinButton SpinButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_spinButton = SpinButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellEditable: CellEditable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _spinButton
}
	

	
	// Configure changes the properties of an existing spin button.
// 
// The adjustment, climb rate, and number of decimal places are updated
// accordingly.
	func (s SpinButton) Configure(adjustment AdjustmentClass, climbRate float64, digits uint)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 *C.GtkAdjustment // out
var _arg2 C.double // out
var _arg3 C.guint // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))
_arg2 = (C.double)(climbRate)
_arg3 = (C.guint)(digits)

C.gtk_spin_button_configure(_arg0, _arg1, _arg2, _arg3)
}
	
	// Adjustment: get the adjustment associated with a `GtkSpinButton`.
	func (s SpinButton) Adjustment() Adjustment {
var _arg0 *C.GtkSpinButton // out
var _cret *C.GtkAdjustment // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_adjustment(_arg0)


var _adjustment Adjustment // out

_adjustment = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Adjustment)

return _adjustment
}
	
	// ClimbRate returns the acceleration rate for repeated changes.
	func (s SpinButton) ClimbRate() float64 {
var _arg0 *C.GtkSpinButton // out
var _cret C.double // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_climb_rate(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Digits fetches the precision of @spin_button.
	func (s SpinButton) Digits() uint {
var _arg0 *C.GtkSpinButton // out
var _cret C.guint // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_digits(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Increments gets the current step and page the increments used by
// @spin_button.
// 
// See [method@Gtk.SpinButton.set_increments].
	func (s SpinButton) Increments() (step float64, page float64) {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.double // in
var _arg2 C.double // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

C.gtk_spin_button_get_increments(_arg0, &_arg1, &_arg2)

var _step float64 // out
var _page float64 // out

_step = (float64)(_arg1)
_page = (float64)(_arg2)

return _step, _page
}
	
	// Numeric returns whether non-numeric text can be typed into the spin button.
	func (s SpinButton) Numeric() bool {
var _arg0 *C.GtkSpinButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_numeric(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Range gets the range allowed for @spin_button.
// 
// See [method@Gtk.SpinButton.set_range].
	func (s SpinButton) Range() (min float64, max float64) {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.double // in
var _arg2 C.double // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

C.gtk_spin_button_get_range(_arg0, &_arg1, &_arg2)

var _min float64 // out
var _max float64 // out

_min = (float64)(_arg1)
_max = (float64)(_arg2)

return _min, _max
}
	
	// SnapToTicks returns whether the values are corrected to the nearest step.
	func (s SpinButton) SnapToTicks() bool {
var _arg0 *C.GtkSpinButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_snap_to_ticks(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// UpdatePolicy gets the update behavior of a spin button.
// 
// See [method@Gtk.SpinButton.set_update_policy].
	func (s SpinButton) UpdatePolicy() SpinButtonUpdatePolicy {
var _arg0 *C.GtkSpinButton // out
var _cret C.GtkSpinButtonUpdatePolicy // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_update_policy(_arg0)


var _spinButtonUpdatePolicy SpinButtonUpdatePolicy // out

_spinButtonUpdatePolicy = SpinButtonUpdatePolicy(_cret)

return _spinButtonUpdatePolicy
}
	
	// Value: get the value in the @spin_button.
	func (s SpinButton) Value() float64 {
var _arg0 *C.GtkSpinButton // out
var _cret C.double // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_value(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// ValueAsInt: get the value @spin_button represented as an integer.
	func (s SpinButton) ValueAsInt() int {
var _arg0 *C.GtkSpinButton // out
var _cret C.int // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_value_as_int(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Wrap returns whether the spin buttons value wraps around to the opposite
// limit when the upper or lower limit of the range is exceeded.
	func (s SpinButton) Wrap() bool {
var _arg0 *C.GtkSpinButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spin_button_get_wrap(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetAdjustment replaces the `GtkAdjustment` associated with @spin_button.
	func (s SpinButton) SetAdjustment(adjustment AdjustmentClass)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 *C.GtkAdjustment // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(adjustment.Native()))

C.gtk_spin_button_set_adjustment(_arg0, _arg1)
}
	
	// SetClimbRate sets the acceleration rate for repeated changes when you hold
// down a button or key.
	func (s SpinButton) SetClimbRate(climbRate float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.double // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(climbRate)

C.gtk_spin_button_set_climb_rate(_arg0, _arg1)
}
	
	// SetDigits: set the precision to be displayed by @spin_button.
// 
// Up to 20 digit precision is allowed.
	func (s SpinButton) SetDigits(digits uint)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.guint // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(digits)

C.gtk_spin_button_set_digits(_arg0, _arg1)
}
	
	// SetIncrements sets the step and page increments for spin_button.
// 
// This affects how quickly the value changes when the spin buttons arrows are
// activated.
	func (s SpinButton) SetIncrements(step float64, page float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.double // out
var _arg2 C.double // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(step)
_arg2 = (C.double)(page)

C.gtk_spin_button_set_increments(_arg0, _arg1, _arg2)
}
	
	// SetNumeric sets the flag that determines if non-numeric text can be typed
// into the spin button.
	func (s SpinButton) SetNumeric(numeric bool)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
if numeric { _arg1 = C.TRUE }

C.gtk_spin_button_set_numeric(_arg0, _arg1)
}
	
	// SetRange sets the minimum and maximum allowable values for @spin_button.
// 
// If the current value is outside this range, it will be adjusted to fit within
// the range, otherwise it will remain unchanged.
	func (s SpinButton) SetRange(min float64, max float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.double // out
var _arg2 C.double // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(min)
_arg2 = (C.double)(max)

C.gtk_spin_button_set_range(_arg0, _arg1, _arg2)
}
	
	// SetSnapToTicks sets the policy as to whether values are corrected to the
// nearest step increment when a spin button is activated after providing an
// invalid value.
	func (s SpinButton) SetSnapToTicks(snapToTicks bool)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
if snapToTicks { _arg1 = C.TRUE }

C.gtk_spin_button_set_snap_to_ticks(_arg0, _arg1)
}
	
	// SetUpdatePolicy sets the update behavior of a spin button.
// 
// This determines whether the spin button is always updated or only when a
// valid value is set.
	func (s SpinButton) SetUpdatePolicy(policy SpinButtonUpdatePolicy)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.GtkSpinButtonUpdatePolicy // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSpinButtonUpdatePolicy)(policy)

C.gtk_spin_button_set_update_policy(_arg0, _arg1)
}
	
	// SetValue sets the value of @spin_button.
	func (s SpinButton) SetValue(value float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.double // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(value)

C.gtk_spin_button_set_value(_arg0, _arg1)
}
	
	// SetWrap sets the flag that determines if a spin button value wraps around to
// the opposite limit when the upper or lower limit of the range is exceeded.
	func (s SpinButton) SetWrap(wrap bool)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
if wrap { _arg1 = C.TRUE }

C.gtk_spin_button_set_wrap(_arg0, _arg1)
}
	
	// Spin: increment or decrement a spin buttons value in a specified direction
// by a specified amount.
	func (s SpinButton) Spin(direction SpinType, increment float64)  {
var _arg0 *C.GtkSpinButton // out
var _arg1 C.GtkSpinType // out
var _arg2 C.double // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSpinType)(direction)
_arg2 = (C.double)(increment)

C.gtk_spin_button_spin(_arg0, _arg1, _arg2)
}
	
	// Update: manually force an update of the spin button.
	func (s SpinButton) Update()  {
var _arg0 *C.GtkSpinButton // out

_arg0 = (*C.GtkSpinButton)(unsafe.Pointer(s.Native()))

C.gtk_spin_button_update(_arg0)
}
	


	// Spinner: a `GtkSpinner` widget displays an icon-size spinning animation.
// 
// It is often used as an alternative to a [class@Gtk.ProgressBar] for
// displaying indefinite activity, instead of actual progress.
// 
// !An example GtkSpinner (spinner.png)
// 
// To start the animation, use [method@Gtk.Spinner.start], to stop it use
// [method@Gtk.Spinner.stop].
// 
// 
// CSS nodes
// 
// `GtkSpinner` has a single CSS node with the name spinner. When the animation
// is active, the :checked pseudoclass is added to this node.
	type Spinner struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// SpinnerClass is an interface that the Spinner class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SpinnerClass interface {
		gextras.Objector
		_spinner()
	}

	func (Spinner) _spinner() {}

	
	func marshalSpinner(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSpinner(obj), nil
	}
	

	
	// NewSpinner returns a new spinner widget. Not yet started.
	func NewSpinner() Spinner {
var _cret *C.GtkWidget // in

_cret = C.gtk_spinner_new()


var _spinner Spinner // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_spinner = Spinner{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _spinner
}
	

	
	// Spinning returns whether the spinner is spinning.
	func (s Spinner) Spinning() bool {
var _arg0 *C.GtkSpinner // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

_cret = C.gtk_spinner_get_spinning(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSpinning sets the activity of the spinner.
	func (s Spinner) SetSpinning(spinning bool)  {
var _arg0 *C.GtkSpinner // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))
if spinning { _arg1 = C.TRUE }

C.gtk_spinner_set_spinning(_arg0, _arg1)
}
	
	// Start starts the animation of the spinner.
	func (s Spinner) Start()  {
var _arg0 *C.GtkSpinner // out

_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

C.gtk_spinner_start(_arg0)
}
	
	// Stop stops the animation of the spinner.
	func (s Spinner) Stop()  {
var _arg0 *C.GtkSpinner // out

_arg0 = (*C.GtkSpinner)(unsafe.Pointer(s.Native()))

C.gtk_spinner_stop(_arg0)
}
	


	// Stack: `GtkStack` is a container which only shows one of its children at a
// time.
// 
// In contrast to `GtkNotebook`, `GtkStack` does not provide a means for users
// to change the visible child. Instead, a separate widget such as
// [class@Gtk.StackSwitcher] or [class@Gtk.StackSidebar] can be used with
// `GtkStack` to provide this functionality.
// 
// Transitions between pages can be animated as slides or fades. This can be
// controlled with [method@Gtk.Stack.set_transition_type]. These animations
// respect the [property@Gtk.Settings:gtk-enable-animations] setting.
// 
// `GtkStack` maintains a [class@Gtk.StackPage] object for each added child,
// which holds additional per-child properties. You obtain the `GtkStackPage`
// for a child with [method@Gtk.Stack.get_page] and you can obtain a
// `GtkSelectionModel` containing all the pages with
// [method@Gtk.Stack.get_pages].
// 
// 
// GtkStack as GtkBuildable
// 
// To set child-specific properties in a .ui file, create `GtkStackPage` objects
// explicitly, and set the child widget as a property on it:
// 
// `xml <object class="GtkStack" id="stack"> <child> <object
// class="GtkStackPage"> <property name="name">page1</property> <property
// name="title">In the beginning</property> <property name="child"> <object
// class="GtkLabel"> <property name="label">It was dark</property> </object>
// </property> </object> </child> `
// 
// 
// CSS nodes
// 
// `GtkStack` has a single CSS node named stack.
// 
// 
// Accessibility
// 
// `GtkStack` uses the GTK_ACCESSIBLE_ROLE_TAB_PANEL for the stack pages, which
// are the accessible parent objects of the child widgets.
	type Stack struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// StackClass is an interface that the Stack class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StackClass interface {
		gextras.Objector
		_stack()
	}

	func (Stack) _stack() {}

	
	func marshalStack(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStack(obj), nil
	}
	

	
	// NewStack creates a new `GtkStack`.
	func NewStack() Stack {
var _cret *C.GtkWidget // in

_cret = C.gtk_stack_new()


var _stack Stack // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_stack = Stack{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stack
}
	

	
	// AddChild adds a child to @stack.
	func (s Stack) AddChild(child WidgetClass) StackPage {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkStackPage // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_stack_add_child(_arg0, _arg1)


var _stackPage StackPage // out

_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

return _stackPage
}
	
	// AddNamed adds a child to @stack.
// 
// The child is identified by the @name.
	func (s Stack) AddNamed(child WidgetClass, name string) StackPage {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.char // out
var _cret *C.GtkStackPage // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_stack_add_named(_arg0, _arg1, _arg2)


var _stackPage StackPage // out

_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

return _stackPage
}
	
	// AddTitled adds a child to @stack.
// 
// The child is identified by the @name. The @title will be used by
// `GtkStackSwitcher` to represent @child in a tab bar, so it should be short.
	func (s Stack) AddTitled(child WidgetClass, name string, title string) StackPage {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.char // out
var _arg3 *C.char // out
var _cret *C.GtkStackPage // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg3))

_cret = C.gtk_stack_add_titled(_arg0, _arg1, _arg2, _arg3)


var _stackPage StackPage // out

_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

return _stackPage
}
	
	// ChildByName finds the child with the name given as the argument.
// 
// Returns nil if there is no child with this name.
	func (s Stack) ChildByName(name string) Widget {
var _arg0 *C.GtkStack // out
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_stack_get_child_by_name(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Hhomogeneous gets whether @stack is horizontally homogeneous.
	func (s Stack) Hhomogeneous() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_hhomogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InterpolateSize returns whether the Stack is set up to interpolate between
// the sizes of children on page switch.
	func (s Stack) InterpolateSize() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_interpolate_size(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Page returns the `GtkStackPage` object for @child.
	func (s Stack) Page(child WidgetClass) StackPage {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out
var _cret *C.GtkStackPage // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

_cret = C.gtk_stack_get_page(_arg0, _arg1)


var _stackPage StackPage // out

_stackPage = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StackPage)

return _stackPage
}
	
	// Pages returns a `GListModel` that contains the pages of the stack.
// 
// This can be used to keep an up-to-date view. The model also implements
// [iface@Gtk.SelectionModel] and can be used to track and modify the visible
// page.
	func (s Stack) Pages() SelectionModel {
var _arg0 *C.GtkStack // out
var _cret *C.GtkSelectionModel // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_pages(_arg0)


var _selectionModel SelectionModel // out

_selectionModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(SelectionModel)

return _selectionModel
}
	
	// TransitionDuration returns the amount of time (in milliseconds) that
// transitions between pages in @stack will take.
	func (s Stack) TransitionDuration() uint {
var _arg0 *C.GtkStack // out
var _cret C.guint // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_transition_duration(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// TransitionRunning returns whether the @stack is currently in a transition
// from one page to another.
	func (s Stack) TransitionRunning() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_transition_running(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TransitionType gets the type of animation that will be used for transitions
// between pages in @stack.
	func (s Stack) TransitionType() StackTransitionType {
var _arg0 *C.GtkStack // out
var _cret C.GtkStackTransitionType // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_transition_type(_arg0)


var _stackTransitionType StackTransitionType // out

_stackTransitionType = StackTransitionType(_cret)

return _stackTransitionType
}
	
	// Vhomogeneous gets whether @stack is vertically homogeneous.
	func (s Stack) Vhomogeneous() bool {
var _arg0 *C.GtkStack // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_vhomogeneous(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VisibleChild gets the currently visible child of @stack.
// 
// Returns nil if there are no visible children.
	func (s Stack) VisibleChild() Widget {
var _arg0 *C.GtkStack // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_visible_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// VisibleChildName returns the name of the currently visible child of @stack.
// 
// Returns nil if there is no visible child.
	func (s Stack) VisibleChildName() string {
var _arg0 *C.GtkStack // out
var _cret *C.char // in

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_get_visible_child_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Remove removes a child widget from @stack.
	func (s Stack) Remove(child WidgetClass)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_stack_remove(_arg0, _arg1)
}
	
	// SetHhomogeneous sets the `GtkStack` to be horizontally homogeneous or not.
// 
// If it is homogeneous, the `GtkStack` will request the same width for all its
// children. If it isn't, the stack may change width when a different child
// becomes visible.
	func (s Stack) SetHhomogeneous(hhomogeneous bool)  {
var _arg0 *C.GtkStack // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
if hhomogeneous { _arg1 = C.TRUE }

C.gtk_stack_set_hhomogeneous(_arg0, _arg1)
}
	
	// SetInterpolateSize sets whether or not @stack will interpolate its size when
// changing the visible child.
// 
// If the [property@Gtk.Stack:interpolate-size] property is set to true, @stack
// will interpolate its size between the current one and the one it'll take
// after changing the visible child, according to the set transition duration.
	func (s Stack) SetInterpolateSize(interpolateSize bool)  {
var _arg0 *C.GtkStack // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
if interpolateSize { _arg1 = C.TRUE }

C.gtk_stack_set_interpolate_size(_arg0, _arg1)
}
	
	// SetTransitionDuration sets the duration that transitions between pages in
// @stack will take.
	func (s Stack) SetTransitionDuration(duration uint)  {
var _arg0 *C.GtkStack // out
var _arg1 C.guint // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(duration)

C.gtk_stack_set_transition_duration(_arg0, _arg1)
}
	
	// SetTransitionType sets the type of animation that will be used for
// transitions between pages in @stack.
// 
// Available types include various kinds of fades and slides.
// 
// The transition type can be changed without problems at runtime, so it is
// possible to change the animation based on the page that is about to become
// current.
	func (s Stack) SetTransitionType(transition StackTransitionType)  {
var _arg0 *C.GtkStack // out
var _arg1 C.GtkStackTransitionType // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkStackTransitionType)(transition)

C.gtk_stack_set_transition_type(_arg0, _arg1)
}
	
	// SetVhomogeneous sets the Stack to be vertically homogeneous or not.
// 
// If it is homogeneous, the `GtkStack` will request the same height for all its
// children. If it isn't, the stack may change height when a different child
// becomes visible.
	func (s Stack) SetVhomogeneous(vhomogeneous bool)  {
var _arg0 *C.GtkStack // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
if vhomogeneous { _arg1 = C.TRUE }

C.gtk_stack_set_vhomogeneous(_arg0, _arg1)
}
	
	// SetVisibleChild makes @child the visible child of @stack.
// 
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of @stack.
// 
// Note that the @child widget has to be visible itself (see
// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	func (s Stack) SetVisibleChild(child WidgetClass)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_stack_set_visible_child(_arg0, _arg1)
}
	
	// SetVisibleChildFull makes the child with the given name visible.
// 
// Note that the child widget has to be visible itself (see
// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	func (s Stack) SetVisibleChildFull(name string, transition StackTransitionType)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.char // out
var _arg2 C.GtkStackTransitionType // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkStackTransitionType)(transition)

C.gtk_stack_set_visible_child_full(_arg0, _arg1, _arg2)
}
	
	// SetVisibleChildName makes the child with the given name visible.
// 
// If @child is different from the currently visible child, the transition
// between the two will be animated with the current transition type of @stack.
// 
// Note that the child widget has to be visible itself (see
// [method@Gtk.Widget.show]) in order to become the visible child of @stack.
	func (s Stack) SetVisibleChildName(name string)  {
var _arg0 *C.GtkStack // out
var _arg1 *C.char // out

_arg0 = (*C.GtkStack)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_stack_set_visible_child_name(_arg0, _arg1)
}
	


	// StackPage: `GtkStackPage` is an auxiliary class used by `GtkStack`.
	type StackPage struct {
		**externglib.Object
		Accessible
		
	}

	// StackPageClass is an interface that the StackPage class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StackPageClass interface {
		gextras.Objector
		_stackPage()
	}

	func (StackPage) _stackPage() {}

	
	func marshalStackPage(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStackPage(obj), nil
	}
	

	

	
	// Child returns the stack child to which @self belongs.
	func (s StackPage) Child() Widget {
var _arg0 *C.GtkStackPage // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_page_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// IconName returns the icon name of the page.
	func (s StackPage) IconName() string {
var _arg0 *C.GtkStackPage // out
var _cret *C.char // in

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_page_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Name returns the name of the page.
	func (s StackPage) Name() string {
var _arg0 *C.GtkStackPage // out
var _cret *C.char // in

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_page_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NeedsAttention returns whether the page is marked as needs attention.
	func (s StackPage) NeedsAttention() bool {
var _arg0 *C.GtkStackPage // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_page_get_needs_attention(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title gets the page title.
	func (s StackPage) Title() string {
var _arg0 *C.GtkStackPage // out
var _cret *C.char // in

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_page_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// UseUnderline gets whether underlines in the page title indicate mnemonics.
	func (s StackPage) UseUnderline() bool {
var _arg0 *C.GtkStackPage // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_page_get_use_underline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Visible returns whether @page is visible in its `GtkStack`.
// 
// This is independent from the [property@Gtk.Widget:visible] property of its
// widget.
	func (s StackPage) Visible() bool {
var _arg0 *C.GtkStackPage // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_page_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetIconName sets the icon name of the page.
	func (s StackPage) SetIconName(setting string)  {
var _arg0 *C.GtkStackPage // out
var _arg1 *C.char // out

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(setting))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_stack_page_set_icon_name(_arg0, _arg1)
}
	
	// SetName sets the name of the page.
	func (s StackPage) SetName(setting string)  {
var _arg0 *C.GtkStackPage // out
var _arg1 *C.char // out

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(setting))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_stack_page_set_name(_arg0, _arg1)
}
	
	// SetNeedsAttention sets whether the page is marked as needs attention.
	func (s StackPage) SetNeedsAttention(setting bool)  {
var _arg0 *C.GtkStackPage // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_stack_page_set_needs_attention(_arg0, _arg1)
}
	
	// SetTitle sets the page title.
	func (s StackPage) SetTitle(setting string)  {
var _arg0 *C.GtkStackPage // out
var _arg1 *C.char // out

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(setting))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_stack_page_set_title(_arg0, _arg1)
}
	
	// SetUseUnderline sets whether underlines in the page title indicate mnemonics.
	func (s StackPage) SetUseUnderline(setting bool)  {
var _arg0 *C.GtkStackPage // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_stack_page_set_use_underline(_arg0, _arg1)
}
	
	// SetVisible sets whether @page is visible in its `GtkStack`.
	func (s StackPage) SetVisible(visible bool)  {
var _arg0 *C.GtkStackPage // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStackPage)(unsafe.Pointer(s.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_stack_page_set_visible(_arg0, _arg1)
}
	


	// StackSidebar: a `GtkStackSidebar` uses a sidebar to switch between `GtkStack`
// pages.
// 
// In order to use a `GtkStackSidebar`, you simply use a `GtkStack` to organize
// your UI flow, and add the sidebar to your sidebar area. You can use
// [method@Gtk.StackSidebar.set_stack] to connect the `GtkStackSidebar` to the
// `GtkStack`.
// 
// 
// CSS nodes
// 
// `GtkStackSidebar` has a single CSS node with name stacksidebar and style
// class .sidebar.
// 
// When circumstances require it, `GtkStackSidebar` adds the .needs-attention
// style class to the widgets representing the stack pages.
	type StackSidebar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// StackSidebarClass is an interface that the StackSidebar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StackSidebarClass interface {
		gextras.Objector
		_stackSidebar()
	}

	func (StackSidebar) _stackSidebar() {}

	
	func marshalStackSidebar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStackSidebar(obj), nil
	}
	

	
	// NewStackSidebar creates a new `GtkStackSidebar`.
	func NewStackSidebar() StackSidebar {
var _cret *C.GtkWidget // in

_cret = C.gtk_stack_sidebar_new()


var _stackSidebar StackSidebar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_stackSidebar = StackSidebar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stackSidebar
}
	

	
	// Stack retrieves the stack.
	func (s StackSidebar) Stack() Stack {
var _arg0 *C.GtkStackSidebar // out
var _cret *C.GtkStack // in

_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_sidebar_get_stack(_arg0)


var _stack Stack // out

_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

return _stack
}
	
	// SetStack: set the `GtkStack` associated with this `GtkStackSidebar`.
// 
// The sidebar widget will automatically update according to the order and items
// within the given `GtkStack`.
	func (s StackSidebar) SetStack(stack StackClass)  {
var _arg0 *C.GtkStackSidebar // out
var _arg1 *C.GtkStack // out

_arg0 = (*C.GtkStackSidebar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

C.gtk_stack_sidebar_set_stack(_arg0, _arg1)
}
	


	// StackSwitcher: the `GtkStackSwitcher` shows a row of buttons to switch
// between `GtkStack` pages.
// 
// !An example GtkStackSwitcher (stackswitcher.png)
// 
// It acts as a controller for the associated `GtkStack`.
// 
// All the content for the buttons comes from the properties of the stacks
// [class@Gtk.StackPage] objects; the button visibility in a `GtkStackSwitcher`
// widget is controlled by the visibility of the child in the `GtkStack`.
// 
// It is possible to associate multiple `GtkStackSwitcher` widgets with the same
// `GtkStack` widget.
// 
// 
// CSS nodes
// 
// `GtkStackSwitcher` has a single CSS node named stackswitcher and style class
// .stack-switcher.
// 
// When circumstances require it, `GtkStackSwitcher` adds the .needs-attention
// style class to the widgets representing the stack pages.
// 
// 
// Accessibility
// 
// `GtkStackSwitcher` uses the GTK_ACCESSIBLE_ROLE_TAB_LIST role and uses the
// GTK_ACCESSIBLE_ROLE_TAB for its buttons.
	type StackSwitcher struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// StackSwitcherClass is an interface that the StackSwitcher class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StackSwitcherClass interface {
		gextras.Objector
		_stackSwitcher()
	}

	func (StackSwitcher) _stackSwitcher() {}

	
	func marshalStackSwitcher(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStackSwitcher(obj), nil
	}
	

	
	// NewStackSwitcher: create a new `GtkStackSwitcher`.
	func NewStackSwitcher() StackSwitcher {
var _cret *C.GtkWidget // in

_cret = C.gtk_stack_switcher_new()


var _stackSwitcher StackSwitcher // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_stackSwitcher = StackSwitcher{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stackSwitcher
}
	

	
	// Stack retrieves the stack.
	func (s StackSwitcher) Stack() Stack {
var _arg0 *C.GtkStackSwitcher // out
var _cret *C.GtkStack // in

_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))

_cret = C.gtk_stack_switcher_get_stack(_arg0)


var _stack Stack // out

_stack = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Stack)

return _stack
}
	
	// SetStack sets the stack to control.
	func (s StackSwitcher) SetStack(stack StackClass)  {
var _arg0 *C.GtkStackSwitcher // out
var _arg1 *C.GtkStack // out

_arg0 = (*C.GtkStackSwitcher)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkStack)(unsafe.Pointer(stack.Native()))

C.gtk_stack_switcher_set_stack(_arg0, _arg1)
}
	


	// Statusbar: a `GtkStatusbar` widget is usually placed along the bottom of an
// application's main [class@Gtk.Window].
// 
// !An example GtkStatusbar (statusbar.png)
// 
// A `GtkStatusBar` may provide a regular commentary of the application's status
// (as is usually the case in a web browser, for example), or may be used to
// simply output a message when the status changes, (when an upload is complete
// in an FTP client, for example).
// 
// Status bars in GTK maintain a stack of messages. The message at the top of
// the each bars stack is the one that will currently be displayed.
// 
// Any messages added to a statusbars stack must specify a context id that is
// used to uniquely identify the source of a message. This context id can be
// generated by [method@Gtk.Statusbar.get_context_id], given a message and the
// statusbar that it will be added to. Note that messages are stored in a stack,
// and when choosing which message to display, the stack structure is adhered
// to, regardless of the context identifier of a message.
// 
// One could say that a statusbar maintains one stack of messages for display
// purposes, but allows multiple message producers to maintain sub-stacks of the
// messages they produced (via context ids).
// 
// Status bars are created using [ctor@Gtk.Statusbar.new].
// 
// Messages are added to the bars stack with [method@Gtk.Statusbar.push].
// 
// The message at the top of the stack can be removed using
// [method@Gtk.Statusbar.pop]. A message can be removed from anywhere in the
// stack if its message id was recorded at the time it was added. This is done
// using [method@Gtk.Statusbar.remove].
// 
// 
// CSS node
// 
// `GtkStatusbar` has a single CSS node with name `statusbar`.
	type Statusbar struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// StatusbarClass is an interface that the Statusbar class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StatusbarClass interface {
		gextras.Objector
		_statusbar()
	}

	func (Statusbar) _statusbar() {}

	
	func marshalStatusbar(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStatusbar(obj), nil
	}
	

	
	// NewStatusbar creates a new `GtkStatusbar` ready for messages.
	func NewStatusbar() Statusbar {
var _cret *C.GtkWidget // in

_cret = C.gtk_statusbar_new()


var _statusbar Statusbar // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_statusbar = Statusbar{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _statusbar
}
	

	
	// ContextID returns a new context identifier, given a description of the actual
// context.
// 
// Note that the description is not shown in the UI.
	func (s Statusbar) ContextID(contextDescription string) uint {
var _arg0 *C.GtkStatusbar // out
var _arg1 *C.char // out
var _cret C.guint // in

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(contextDescription))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_statusbar_get_context_id(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Pop removes the first message in the `GtkStatusbar`s stack with the given
// context id.
// 
// Note that this may not change the displayed message, if the message at the
// top of the stack has a different context id.
	func (s Statusbar) Pop(contextId uint)  {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)

C.gtk_statusbar_pop(_arg0, _arg1)
}
	
	// Push pushes a new message onto a statusbars stack.
	func (s Statusbar) Push(contextId uint, text string) uint {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out
var _arg2 *C.char // out
var _cret C.guint // in

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)
_arg2 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_statusbar_push(_arg0, _arg1, _arg2)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Remove forces the removal of a message from a statusbars stack. The exact
// @context_id and @message_id must be specified.
	func (s Statusbar) Remove(contextId uint, messageId uint)  {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)
_arg2 = (C.guint)(messageId)

C.gtk_statusbar_remove(_arg0, _arg1, _arg2)
}
	
	// RemoveAll forces the removal of all messages from a statusbar's stack with
// the exact @context_id.
	func (s Statusbar) RemoveAll(contextId uint)  {
var _arg0 *C.GtkStatusbar // out
var _arg1 C.guint // out

_arg0 = (*C.GtkStatusbar)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(contextId)

C.gtk_statusbar_remove_all(_arg0, _arg1)
}
	


	// StringFilter: `GtkStringFilter` determines whether to include items by
// comparing strings to a fixed search term.
// 
// The strings are obtained from the items by evaluating a `GtkExpression` set
// with [method@Gtk.StringFilter.set_expression], and they are compared against
// a search term set with [method@Gtk.StringFilter.set_search].
// 
// `GtkStringFilter` has several different modes of comparison - it can match
// the whole string, just a prefix, or any substring. Use
// [method@Gtk.StringFilter.set_match_mode] choose a mode.
// 
// It is also possible to make case-insensitive comparisons, with
// [method@Gtk.StringFilter.set_ignore_case].
	type StringFilter struct {
		Filter
		
	}

	// StringFilterClass is an interface that the StringFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StringFilterClass interface {
		gextras.Objector
		_stringFilter()
	}

	func (StringFilter) _stringFilter() {}

	
	func marshalStringFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStringFilter(obj), nil
	}
	

	
	// NewStringFilter creates a new string filter.
// 
// You will want to set up the filter by providing a string to search for and by
// providing a property to look up on the item.
	func NewStringFilter(expression ExpressionClass) StringFilter {
var _arg1 *C.GtkExpression // out
var _cret *C.GtkStringFilter // in

_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

_cret = C.gtk_string_filter_new(_arg1)


var _stringFilter StringFilter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_stringFilter = StringFilter{
Filter: Filter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stringFilter
}
	

	
	// Expression gets the expression that the string filter uses to obtain strings
// from items.
	func (s StringFilter) Expression() Expression {
var _arg0 *C.GtkStringFilter // out
var _cret *C.GtkExpression // in

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_string_filter_get_expression(_arg0)


var _expression Expression // out

_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

return _expression
}
	
	// IgnoreCase returns whether the filter ignores case differences.
	func (s StringFilter) IgnoreCase() bool {
var _arg0 *C.GtkStringFilter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_string_filter_get_ignore_case(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MatchMode returns the match mode that the filter is using.
	func (s StringFilter) MatchMode() StringFilterMatchMode {
var _arg0 *C.GtkStringFilter // out
var _cret C.GtkStringFilterMatchMode // in

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_string_filter_get_match_mode(_arg0)


var _stringFilterMatchMode StringFilterMatchMode // out

_stringFilterMatchMode = StringFilterMatchMode(_cret)

return _stringFilterMatchMode
}
	
	// Search gets the search term.
	func (s StringFilter) Search() string {
var _arg0 *C.GtkStringFilter // out
var _cret *C.char // in

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_string_filter_get_search(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// SetExpression sets the expression that the string filter uses to obtain
// strings from items.
// 
// The expression must have a value type of G_TYPE_STRING.
	func (s StringFilter) SetExpression(expression ExpressionClass)  {
var _arg0 *C.GtkStringFilter // out
var _arg1 *C.GtkExpression // out

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

C.gtk_string_filter_set_expression(_arg0, _arg1)
}
	
	// SetIgnoreCase sets whether the filter ignores case differences.
	func (s StringFilter) SetIgnoreCase(ignoreCase bool)  {
var _arg0 *C.GtkStringFilter // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
if ignoreCase { _arg1 = C.TRUE }

C.gtk_string_filter_set_ignore_case(_arg0, _arg1)
}
	
	// SetMatchMode sets the match mode for the filter.
	func (s StringFilter) SetMatchMode(mode StringFilterMatchMode)  {
var _arg0 *C.GtkStringFilter // out
var _arg1 C.GtkStringFilterMatchMode // out

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkStringFilterMatchMode)(mode)

C.gtk_string_filter_set_match_mode(_arg0, _arg1)
}
	
	// SetSearch sets the string to search for.
	func (s StringFilter) SetSearch(search string)  {
var _arg0 *C.GtkStringFilter // out
var _arg1 *C.char // out

_arg0 = (*C.GtkStringFilter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(search))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_string_filter_set_search(_arg0, _arg1)
}
	


	// StringSorter: `GtkStringSorter` is a `GtkSorter` that compares strings.
// 
// It does the comparison in a linguistically correct way using the current
// locale by normalizing Unicode strings and possibly case-folding them before
// performing the comparison.
// 
// To obtain the strings to compare, this sorter evaluates a
// [class@Gtk.Expression].
	type StringSorter struct {
		Sorter
		
	}

	// StringSorterClass is an interface that the StringSorter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StringSorterClass interface {
		gextras.Objector
		_stringSorter()
	}

	func (StringSorter) _stringSorter() {}

	
	func marshalStringSorter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStringSorter(obj), nil
	}
	

	
	// NewStringSorter creates a new string sorter that compares items using the
// given @expression.
// 
// Unless an expression is set on it, this sorter will always compare items as
// invalid.
	func NewStringSorter(expression ExpressionClass) StringSorter {
var _arg1 *C.GtkExpression // out
var _cret *C.GtkStringSorter // in

_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

_cret = C.gtk_string_sorter_new(_arg1)


var _stringSorter StringSorter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_stringSorter = StringSorter{
Sorter: Sorter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _stringSorter
}
	

	
	// Expression gets the expression that is evaluated to obtain strings from
// items.
	func (s StringSorter) Expression() Expression {
var _arg0 *C.GtkStringSorter // out
var _cret *C.GtkExpression // in

_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_string_sorter_get_expression(_arg0)


var _expression Expression // out

_expression = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Expression)

return _expression
}
	
	// IgnoreCase gets whether the sorter ignores case differences.
	func (s StringSorter) IgnoreCase() bool {
var _arg0 *C.GtkStringSorter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_string_sorter_get_ignore_case(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetExpression sets the expression that is evaluated to obtain strings from
// items.
// 
// The expression must have the type G_TYPE_STRING.
	func (s StringSorter) SetExpression(expression ExpressionClass)  {
var _arg0 *C.GtkStringSorter // out
var _arg1 *C.GtkExpression // out

_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkExpression)(unsafe.Pointer(expression.Native()))

C.gtk_string_sorter_set_expression(_arg0, _arg1)
}
	
	// SetIgnoreCase sets whether the sorter will ignore case differences.
	func (s StringSorter) SetIgnoreCase(ignoreCase bool)  {
var _arg0 *C.GtkStringSorter // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkStringSorter)(unsafe.Pointer(s.Native()))
if ignoreCase { _arg1 = C.TRUE }

C.gtk_string_sorter_set_ignore_case(_arg0, _arg1)
}
	


	// StyleContext: `GtkStyleContext` stores styling information affecting a
// widget.
// 
// In order to construct the final style information, `GtkStyleContext` queries
// information from all attached `GtkStyleProviders`. Style providers can be
// either attached explicitly to the context through
// [method@Gtk.StyleContext.add_provider], or to the display through
// [func@Gtk.StyleContext.add_provider_for_display]. The resulting style is a
// combination of all providers information in priority order.
// 
// For GTK widgets, any `GtkStyleContext` returned by
// [method@Gtk.Widget.get_style_context] will already have a `GdkDisplay` and
// RTL/LTR information set. The style context will also be updated automatically
// if any of these settings change on the widget.
// 
// 
// Style Classes
// 
// Widgets can add style classes to their context, which can be used to
// associate different styles by class. The documentation for individual widgets
// lists which style classes it uses itself, and which style classes may be
// added by applications to affect their appearance.
// 
// 
// Custom styling in UI libraries and applications
// 
// If you are developing a library with custom widgets that render differently
// than standard components, you may need to add a `GtkStyleProvider` yourself
// with the GTK_STYLE_PROVIDER_PRIORITY_FALLBACK priority, either a
// `GtkCssProvider` or a custom object implementing the `GtkStyleProvider`
// interface. This way themes may still attempt to style your UI elements in a
// different way if needed so.
// 
// If you are using custom styling on an applications, you probably want then to
// make your style information prevail to the themes, so you must use a
// `GtkStyleProvider` with the GTK_STYLE_PROVIDER_PRIORITY_APPLICATION priority,
// keep in mind that the user settings in `XDG_CONFIG_HOME/gtk-4.0/gtk.css` will
// still take precedence over your changes, as it uses the
// GTK_STYLE_PROVIDER_PRIORITY_USER priority.
	type StyleContext struct {
		**externglib.Object
		
	}

	// StyleContextClass is an interface that the StyleContext class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type StyleContextClass interface {
		gextras.Objector
		_styleContext()
	}

	func (StyleContext) _styleContext() {}

	
	func marshalStyleContext(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapStyleContext(obj), nil
	}
	

	

	
	// AddClass adds a style class to @context, so later uses of the style context
// will make use of this new class for styling.
// 
// In the CSS file format, a `GtkEntry` defining a search class, would be
// matched by:
// 
// `css entry.search { ... } `
// 
// While any widget defining a search class would be matched by: `css .search
// { ... } `
	func (c StyleContext) AddClass(className string)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.char // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(className))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_style_context_add_class(_arg0, _arg1)
}
	
	// AddProvider adds a style provider to @context, to be used in style
// construction.
// 
// Note that a style provider added by this function only affects the style of
// the widget to which @context belongs. If you want to affect the style of all
// widgets, use [func@Gtk.StyleContext.add_provider_for_display].
// 
// Note: If both priorities are the same, a `GtkStyleProvider` added through
// this function takes precedence over another added through
// [func@Gtk.StyleContext.add_provider_for_display].
	func (c StyleContext) AddProvider(provider StyleProvider, priority uint)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GtkStyleProvider // out
var _arg2 C.guint // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))
_arg2 = (C.guint)(priority)

C.gtk_style_context_add_provider(_arg0, _arg1, _arg2)
}
	
	// Border gets the border for a given state as a `GtkBorder`.
	func (c StyleContext) Border() Border {
var _arg0 *C.GtkStyleContext // out
var _border Border

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_get_border(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_border)))





return _border
}
	
	// Color gets the foreground color for a given state.
	func (c StyleContext) Color() gdk.RGBA {
var _arg0 *C.GtkStyleContext // out
var _color gdk.RGBA

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_get_color(_arg0, (*C.GdkRGBA)(unsafe.Pointer(&_color)))





return _color
}
	
	// Display returns the `GdkDisplay` to which @context is attached.
	func (c StyleContext) Display() gdk.Display {
var _arg0 *C.GtkStyleContext // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// Margin gets the margin for a given state as a `GtkBorder`.
	func (c StyleContext) Margin() Border {
var _arg0 *C.GtkStyleContext // out
var _margin Border

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_get_margin(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_margin)))





return _margin
}
	
	// Padding gets the padding for a given state as a `GtkBorder`.
	func (c StyleContext) Padding() Border {
var _arg0 *C.GtkStyleContext // out
var _padding Border

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_get_padding(_arg0, (*C.GtkBorder)(unsafe.Pointer(&_padding)))





return _padding
}
	
	// Scale returns the scale used for assets.
	func (c StyleContext) Scale() int {
var _arg0 *C.GtkStyleContext // out
var _cret C.int // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_scale(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// State returns the state used for style matching.
// 
// This method should only be used to retrieve the `GtkStateFlags` to pass to
// `GtkStyleContext` methods, like [method@Gtk.StyleContext.get_padding]. If you
// need to retrieve the current state of a `GtkWidget`, use
// [method@Gtk.Widget.get_state_flags].
	func (c StyleContext) State() StateFlags {
var _arg0 *C.GtkStyleContext // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_style_context_get_state(_arg0)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// HasClass returns true if @context currently has defined the given class name.
	func (c StyleContext) HasClass(className string) bool {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(className))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_context_has_class(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LookupColor looks up and resolves a color name in the @context color map.
	func (c StyleContext) LookupColor(colorName string) (gdk.RGBA, bool) {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.char // out
var _color gdk.RGBA
var _cret C.gboolean // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(colorName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_style_context_lookup_color(_arg0, _arg1, (*C.GdkRGBA)(unsafe.Pointer(&_color)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _color, _ok
}
	
	// RemoveClass removes @class_name from @context.
	func (c StyleContext) RemoveClass(className string)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.char // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.char)(C.CString(className))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_style_context_remove_class(_arg0, _arg1)
}
	
	// RemoveProvider removes @provider from the style providers list in @context.
	func (c StyleContext) RemoveProvider(provider StyleProvider)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GtkStyleProvider // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GtkStyleProvider)(unsafe.Pointer(provider.Native()))

C.gtk_style_context_remove_provider(_arg0, _arg1)
}
	
	// Restore restores @context state to a previous stage.
// 
// See [method@Gtk.StyleContext.save].
	func (c StyleContext) Restore()  {
var _arg0 *C.GtkStyleContext // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_restore(_arg0)
}
	
	// Save saves the @context state.
// 
// This allows temporary modifications done through
// [method@Gtk.StyleContext.add_class], [method@Gtk.StyleContext.remove_class],
// [method@Gtk.StyleContext.set_state] to be quickly reverted in one go through
// [method@Gtk.StyleContext.restore].
// 
// The matching call to [method@Gtk.StyleContext.restore] must be done before
// GTK returns to the main loop.
	func (c StyleContext) Save()  {
var _arg0 *C.GtkStyleContext // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))

C.gtk_style_context_save(_arg0)
}
	
	// SetDisplay attaches @context to the given display.
// 
// The display is used to add style information from global style providers,
// such as the display's `GtkSettings` instance.
// 
// If you are using a `GtkStyleContext` returned from
// [method@Gtk.Widget.get_style_context], you do not need to call this yourself.
	func (c StyleContext) SetDisplay(display gdk.DisplayClass)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 *C.GdkDisplay // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

C.gtk_style_context_set_display(_arg0, _arg1)
}
	
	// SetScale sets the scale to use when getting image assets for the style.
	func (c StyleContext) SetScale(scale int)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.int // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.int)(scale)

C.gtk_style_context_set_scale(_arg0, _arg1)
}
	
	// SetState sets the state to be used for style matching.
	func (c StyleContext) SetState(flags StateFlags)  {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStateFlags // out

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStateFlags)(flags)

C.gtk_style_context_set_state(_arg0, _arg1)
}
	
	// String converts the style context into a string representation.
// 
// The string representation always includes information about the name, state,
// id, visibility and style classes of the CSS node that is backing @context.
// Depending on the flags, more information may be included.
// 
// This function is intended for testing and debugging of the CSS implementation
// in GTK. There are no guarantees about the format of the returned string, it
// may change.
	func (c StyleContext) String(flags StyleContextPrintFlags) string {
var _arg0 *C.GtkStyleContext // out
var _arg1 C.GtkStyleContextPrintFlags // out
var _cret *C.char // in

_arg0 = (*C.GtkStyleContext)(unsafe.Pointer(c.Native()))
_arg1 = (C.GtkStyleContextPrintFlags)(flags)

_cret = C.gtk_style_context_to_string(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	


	// Switch: `GtkSwitch` is a "light switch" that has two states: on or off.
// 
// !An example GtkSwitch (switch.png)
// 
// The user can control which state should be active by clicking the empty area,
// or by dragging the handle.
// 
// `GtkSwitch` can also handle situations where the underlying state changes
// with a delay. See [signal@GtkSwitch::state-set] for details.
// 
// 
// CSS nodes
// 
// ` switch  label  label  slider `
// 
// `GtkSwitch` has four css nodes, the main node with the name switch and
// subnodes for the slider and the on and off labels. Neither of them is using
// any style classes.
// 
// 
// Accessibility
// 
// `GtkSwitch` uses the GTK_ACCESSIBLE_ROLE_SWITCH role.
	type Switch struct {
		Widget
		Accessible
		Actionable
		Buildable
		ConstraintTarget
		
	}

	// SwitchClass is an interface that the Switch class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type SwitchClass interface {
		gextras.Objector
		__switch()
	}

	func (Switch) __switch() {}

	
	func marshalSwitch(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapSwitch(obj), nil
	}
	

	
	// NewSwitch creates a new `GtkSwitch` widget.
	func NewSwitch() Switch {
var _cret *C.GtkWidget // in

_cret = C.gtk_switch_new()


var __switch Switch // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
__switch = Switch{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return __switch
}
	

	
	// Active gets whether the `GtkSwitch` is in its on or off state.
	func (s Switch) Active() bool {
var _arg0 *C.GtkSwitch // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

_cret = C.gtk_switch_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// State gets the underlying state of the `GtkSwitch`.
	func (s Switch) State() bool {
var _arg0 *C.GtkSwitch // out
var _cret C.gboolean // in

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))

_cret = C.gtk_switch_get_state(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive changes the state of @self to the desired one.
	func (s Switch) SetActive(isActive bool)  {
var _arg0 *C.GtkSwitch // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
if isActive { _arg1 = C.TRUE }

C.gtk_switch_set_active(_arg0, _arg1)
}
	
	// SetState sets the underlying state of the `GtkSwitch`.
// 
// Normally, this is the same as [property@Gtk.Switch:active], unless the switch
// is set up for delayed state changes. This function is typically called from a
// [signal@Gtk.Switch`::state-set] signal handler.
// 
// See [signal@Gtk.Switch::state-set] for details.
	func (s Switch) SetState(state bool)  {
var _arg0 *C.GtkSwitch // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkSwitch)(unsafe.Pointer(s.Native()))
if state { _arg1 = C.TRUE }

C.gtk_switch_set_state(_arg0, _arg1)
}
	


	// Text: the `GtkText` widget is a single-line text entry widget.
// 
// `GtkText` is the common implementation of single-line text editing that is
// shared between `GtkEntry`, `GtkPasswordEntry, `GtkSpinButton` and other
// widgets. In all of these, `GtkText` is used as the delegate for the
// [iface@Gtk.Editable] implementation.
// 
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
// 
// When using an entry for passwords and other sensitive information, it can be
// put into password mode using [method@Gtk.Text.set_visibility]. In this
// mode, entered text is displayed using a invisible character. By default,
// GTK picks the best invisible character that is available in the current font,
// but it can be changed with [method@Gtk.Text.set_invisible_char].
// 
// If you are looking to add icons or progress display in an entry, look at
// `GtkEntry`. There other alternatives for more specialized use cases, such as
// `GtkSearchEntry`.
// 
// If you need multi-line editable text, look at `GtkTextView`.
// 
// 
// CSS nodes
// 
// ` text[.read-only]  placeholder  undershoot.left  undershoot.right
//  [selection]  [block-cursor]  [window.popup] `
// 
// `GtkText` has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
// 
// When the entry has a selection, it adds a subnode with the name selection.
// 
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
// 
// The CSS node for a context menu is added as a subnode below text as well.
// 
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
// 
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
// 
// 
// Accessibility
// 
// `GtkText` uses the GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be
// skipped for accessibility. This is because `GtkText` is expected to be used
// as a delegate for a `GtkEditable` implementation that will be represented to
// accessibility.
	type Text struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Editable
		
	}

	// TextClass is an interface that the Text class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextClass interface {
		gextras.Objector
		_text()
	}

	func (Text) _text() {}

	
	func marshalText(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapText(obj), nil
	}
	

	
	// NewText creates a new `GtkText`.
	func NewText() Text {
var _cret *C.GtkWidget // in

_cret = C.gtk_text_new()


var _text Text // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_text = Text{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _text
}
	
	// NewTextWithBuffer creates a new `GtkText` with the specified text buffer.
	func NewTextWithBuffer(buffer EntryBufferClass) Text {
var _arg1 *C.GtkEntryBuffer // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_text_new_with_buffer(_arg1)


var _text Text // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_text = Text{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Editable: Editable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
}
}

return _text
}
	

	
	// ActivatesDefault retrieves the value set by gtk_text_set_activates_default().
	func (s Text) ActivatesDefault() bool {
var _arg0 *C.GtkText // out
var _cret C.gboolean // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_activates_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Attributes gets the attribute list that was set on the `GtkText` using
// gtk_text_set_attributes().
	func (s Text) Attributes() *pango.AttrList {
var _arg0 *C.GtkText // out
var _cret *C.PangoAttrList // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_attributes(_arg0)


var _attrList *pango.AttrList // out

_attrList = *(**pango.AttrList)(unsafe.Pointer(&_cret))

return _attrList
}
	
	// Buffer: get the `GtkEntryBuffer` object which holds the text for this self.
	func (s Text) Buffer() EntryBuffer {
var _arg0 *C.GtkText // out
var _cret *C.GtkEntryBuffer // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_buffer(_arg0)


var _entryBuffer EntryBuffer // out

_entryBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(EntryBuffer)

return _entryBuffer
}
	
	// EnableEmojiCompletion returns whether Emoji completion is enabled for this
// `GtkText` widget.
	func (s Text) EnableEmojiCompletion() bool {
var _arg0 *C.GtkText // out
var _cret C.gboolean // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_enable_emoji_completion(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
	func (s Text) ExtraMenu() gio.MenuModel {
var _arg0 *C.GtkText // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_extra_menu(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// InputHints gets the input hints of the `GtkText`.
	func (s Text) InputHints() InputHints {
var _arg0 *C.GtkText // out
var _cret C.GtkInputHints // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_input_hints(_arg0)


var _inputHints InputHints // out

_inputHints = InputHints(_cret)

return _inputHints
}
	
	// InputPurpose gets the input purpose of the `GtkText`.
	func (s Text) InputPurpose() InputPurpose {
var _arg0 *C.GtkText // out
var _cret C.GtkInputPurpose // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_input_purpose(_arg0)


var _inputPurpose InputPurpose // out

_inputPurpose = InputPurpose(_cret)

return _inputPurpose
}
	
	// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false.
// 
// Note that GTK does not compute this value unless it needs it, so the value
// returned by this function is not very useful unless it has been explicitly
// set with [method@Gtk.Text.set_invisible_char].
	func (s Text) InvisibleChar() uint32 {
var _arg0 *C.GtkText // out
var _cret C.gunichar // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_invisible_char(_arg0)


var _gunichar uint32 // out

_gunichar = (uint32)(_cret)

return _gunichar
}
	
	// MaxLength retrieves the maximum allowed length of the text in @self.
// 
// See [method@Gtk.Text.set_max_length].
// 
// This is equivalent to getting @self's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.get_max_length] on it.
	func (s Text) MaxLength() int {
var _arg0 *C.GtkText // out
var _cret C.int // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_max_length(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
	func (s Text) OverwriteMode() bool {
var _arg0 *C.GtkText // out
var _cret C.gboolean // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_overwrite_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PlaceholderText retrieves the text that will be displayed when @self is empty
// and unfocused
	func (s Text) PlaceholderText() string {
var _arg0 *C.GtkText // out
var _cret *C.char // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_placeholder_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PropagateTextWidth returns whether the `GtkText` will grow and shrink with
// the content.
	func (s Text) PropagateTextWidth() bool {
var _arg0 *C.GtkText // out
var _cret C.gboolean // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_propagate_text_width(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Tabs gets the tabstops that were set on the `GtkText` using
// gtk_text_set_tabs().
	func (s Text) Tabs() *pango.TabArray {
var _arg0 *C.GtkText // out
var _cret *C.PangoTabArray // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_tabs(_arg0)


var _tabArray *pango.TabArray // out

_tabArray = *(**pango.TabArray)(unsafe.Pointer(&_cret))

return _tabArray
}
	
	// TextLength retrieves the current length of the text in @self.
// 
// This is equivalent to getting @self's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.get_length] on it.
	func (s Text) TextLength() uint16 {
var _arg0 *C.GtkText // out
var _cret C.guint16 // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_text_length(_arg0)


var _guint16 uint16 // out

_guint16 = (uint16)(_cret)

return _guint16
}
	
	// TruncateMultiline returns whether the `GtkText` will truncate multi-line text
// that is pasted into the widget
	func (s Text) TruncateMultiline() bool {
var _arg0 *C.GtkText // out
var _cret C.gboolean // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_truncate_multiline(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Visibility retrieves whether the text in @self is visible.
	func (s Text) Visibility() bool {
var _arg0 *C.GtkText // out
var _cret C.gboolean // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_get_visibility(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GrabFocusWithoutSelecting causes @self to have keyboard focus.
// 
// It behaves like [method@Gtk.Widget.grab_focus], except that it doesn't select
// the contents of @self. You only want to call this on some special entries
// which the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
	func (s Text) GrabFocusWithoutSelecting() bool {
var _arg0 *C.GtkText // out
var _cret C.gboolean // in

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

_cret = C.gtk_text_grab_focus_without_selecting(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActivatesDefault: if @activates is true, pressing Enter in the @self will
// activate the default widget for the window containing @self.
// 
// This usually means that the dialog containing the `GtkText` will be closed,
// since the default widget is usually one of the dialog buttons.
	func (s Text) SetActivatesDefault(activates bool)  {
var _arg0 *C.GtkText // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
if activates { _arg1 = C.TRUE }

C.gtk_text_set_activates_default(_arg0, _arg1)
}
	
	// SetAttributes sets attributes that are applied to the text.
	func (s Text) SetAttributes(attrs *pango.AttrList)  {
var _arg0 *C.GtkText // out
var _arg1 *C.PangoAttrList // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

C.gtk_text_set_attributes(_arg0, _arg1)
}
	
	// SetBuffer: set the `GtkEntryBuffer` object which holds the text for this
// widget.
	func (s Text) SetBuffer(buffer EntryBufferClass)  {
var _arg0 *C.GtkText // out
var _arg1 *C.GtkEntryBuffer // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

C.gtk_text_set_buffer(_arg0, _arg1)
}
	
	// SetEnableEmojiCompletion sets whether Emoji completion is enabled.
// 
// If it is, typing ':', followed by a recognized keyword, will pop up a window
// with suggested Emojis matching the keyword.
	func (s Text) SetEnableEmojiCompletion(enableEmojiCompletion bool)  {
var _arg0 *C.GtkText // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
if enableEmojiCompletion { _arg1 = C.TRUE }

C.gtk_text_set_enable_emoji_completion(_arg0, _arg1)
}
	
	// SetExtraMenu sets a menu model to add when constructing the context menu for
// @self.
	func (s Text) SetExtraMenu(model gio.MenuModelClass)  {
var _arg0 *C.GtkText // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.gtk_text_set_extra_menu(_arg0, _arg1)
}
	
	// SetInputHints sets input hints that allow input methods to fine-tune their
// behaviour.
	func (s Text) SetInputHints(hints InputHints)  {
var _arg0 *C.GtkText // out
var _arg1 C.GtkInputHints // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkInputHints)(hints)

C.gtk_text_set_input_hints(_arg0, _arg1)
}
	
	// SetInputPurpose sets the input purpose of the `GtkText`.
// 
// This can be used by on-screen keyboards and other input methods to adjust
// their behaviour.
	func (s Text) SetInputPurpose(purpose InputPurpose)  {
var _arg0 *C.GtkText // out
var _arg1 C.GtkInputPurpose // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkInputPurpose)(purpose)

C.gtk_text_set_input_purpose(_arg0, _arg1)
}
	
	// SetInvisibleChar sets the character to use in place of the actual text when
// in password mode.
// 
// By default, GTK picks the best invisible char available in the current font.
// If you set the invisible char to 0, then the user will get no feedback at
// all; there will be no text on the screen as they type.
	func (s Text) SetInvisibleChar(ch uint32)  {
var _arg0 *C.GtkText // out
var _arg1 C.gunichar // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (C.gunichar)(ch)

C.gtk_text_set_invisible_char(_arg0, _arg1)
}
	
	// SetMaxLength sets the maximum allowed length of the contents of the widget.
// 
// If the current contents are longer than the given length, then they will be
// truncated to fit.
// 
// This is equivalent to getting @self's `GtkEntryBuffer` and calling
// [method@Gtk.EntryBuffer.set_max_length] on it.
	func (s Text) SetMaxLength(length int)  {
var _arg0 *C.GtkText // out
var _arg1 C.int // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (C.int)(length)

C.gtk_text_set_max_length(_arg0, _arg1)
}
	
	// SetOverwriteMode sets whether the text is overwritten when typing in the
// `GtkText`.
	func (s Text) SetOverwriteMode(overwrite bool)  {
var _arg0 *C.GtkText // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
if overwrite { _arg1 = C.TRUE }

C.gtk_text_set_overwrite_mode(_arg0, _arg1)
}
	
	// SetPlaceholderText sets text to be displayed in @self when it is empty.
// 
// This can be used to give a visual hint of the expected contents of the
// `GtkText`.
	func (s Text) SetPlaceholderText(text string)  {
var _arg0 *C.GtkText // out
var _arg1 *C.char // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_text_set_placeholder_text(_arg0, _arg1)
}
	
	// SetPropagateTextWidth sets whether the `GtkText` should grow and shrink with
// the content.
	func (s Text) SetPropagateTextWidth(propagateTextWidth bool)  {
var _arg0 *C.GtkText // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
if propagateTextWidth { _arg1 = C.TRUE }

C.gtk_text_set_propagate_text_width(_arg0, _arg1)
}
	
	// SetTabs sets tabstops that are applied to the text.
	func (s Text) SetTabs(tabs *pango.TabArray)  {
var _arg0 *C.GtkText // out
var _arg1 *C.PangoTabArray // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

C.gtk_text_set_tabs(_arg0, _arg1)
}
	
	// SetTruncateMultiline sets whether the `GtkText` should truncate multi-line
// text that is pasted into the widget.
	func (s Text) SetTruncateMultiline(truncateMultiline bool)  {
var _arg0 *C.GtkText // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
if truncateMultiline { _arg1 = C.TRUE }

C.gtk_text_set_truncate_multiline(_arg0, _arg1)
}
	
	// SetVisibility sets whether the contents of the `GtkText` are visible or not.
// 
// When visibility is set to false, characters are displayed as the invisible
// char, and will also appear that way when the text in the widget is copied to
// the clipboard.
// 
// By default, GTK picks the best invisible character available in the current
// font, but it can be changed with [method@Gtk.Text.set_invisible_char].
// 
// Note that you probably want to set [property@Gtk.Text:input-purpose] to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this self, in addition to setting visibility to false.
	func (s Text) SetVisibility(visible bool)  {
var _arg0 *C.GtkText // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_text_set_visibility(_arg0, _arg1)
}
	
	// UnsetInvisibleChar unsets the invisible char.
// 
// After calling this, the default invisible char is used again.
	func (s Text) UnsetInvisibleChar()  {
var _arg0 *C.GtkText // out

_arg0 = (*C.GtkText)(unsafe.Pointer(s.Native()))

C.gtk_text_unset_invisible_char(_arg0)
}
	


	// TextBuffer stores text and attributes for display in a `GtkTextView`.
// 
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
	type TextBuffer struct {
		**externglib.Object
		
	}

	// TextBufferClass is an interface that the TextBuffer class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextBufferClass interface {
		gextras.Objector
		_textBuffer()
	}

	func (TextBuffer) _textBuffer() {}

	
	func marshalTextBuffer(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextBuffer(obj), nil
	}
	

	
	// NewTextBuffer creates a new text buffer.
	func NewTextBuffer(table TextTagTableClass) TextBuffer {
var _arg1 *C.GtkTextTagTable // out
var _cret *C.GtkTextBuffer // in

_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))

_cret = C.gtk_text_buffer_new(_arg1)


var _textBuffer TextBuffer // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textBuffer = TextBuffer{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textBuffer
}
	

	
	// AddMark adds the mark at position @where.
// 
// The mark must not be added to another buffer, and if its name is not nil then
// there must not be another mark in the buffer with the same name.
// 
// Emits the `GtkTextBuffer`::mark-set signal as notification of the mark's
// initial placement.
	func (b TextBuffer) AddMark(mark TextMarkClass, where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextMark // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
}
	
	// AddSelectionClipboard adds @clipboard to the list of clipboards in which the
// selection contents of @buffer are available.
// 
// In most cases, @clipboard will be the `GdkClipboard` returned by
// [method@Gtk.Widget.get_primary_clipboard] for a view of @buffer.
	func (b TextBuffer) AddSelectionClipboard(clipboard gdk.ClipboardClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GdkClipboard // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
}
	
	// ApplyTag emits the apply-tag signal on @buffer.
// 
// The default handler for the signal applies @tag to the given range. @start
// and @end do not have to be in order.
	func (b TextBuffer) ApplyTag(tag TextTagClass, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextTag // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
}
	
	// ApplyTagByName emits the apply-tag signal on @buffer.
// 
// Calls [method@Gtk.TextTagTable.lookup] on the buffers tag table to get a
// `GtkTextTag`, then calls [method@Gtk.TextBuffer.apply_tag].
	func (b TextBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}
	
	// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by @iter.
// 
// In the normal case a single character will be deleted, but when combining
// accents are involved, more than one character can be deleted, and when
// precomposed character and accent combinations are involved, less than one
// character will be deleted.
// 
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the @iter will be re-initialized to
// point to the location where text was deleted.
	func (b TextBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.gboolean // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
if interactive { _arg2 = C.TRUE }
if defaultEditable { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BeginIrreversibleAction denotes the beginning of an action that may not be
// undone.
// 
// This will cause any previous operations in the undo/redo queue to be cleared.
// 
// This should be paired with a call to
// [method@Gtk.TextBuffer.end_irreversible_action] after the irreversible action
// has completed.
// 
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
	func (b TextBuffer) BeginIrreversibleAction()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_begin_irreversible_action(_arg0)
}
	
	// BeginUserAction: called to indicate that the buffer operations between here
// and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
// 
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating an undo
// stack. `GtkTextBuffer` maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call to
// gtk_text_buffer_end_user_action(), and emits the begin-user-action and
// end-user-action signals only for the outermost pair of calls. This allows
// you to build user actions from other user actions.
// 
// The interactive buffer mutation functions, such as
// [method@Gtk.TextBuffer.insert_interactive], automatically call begin/end user
// action around the buffer operations they perform, so there's no need to add
// extra calls if you user action consists solely of a single call to one of
// those functions.
	func (b TextBuffer) BeginUserAction()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_begin_user_action(_arg0)
}
	
	// CopyClipboard copies the currently-selected text to a clipboard.
	func (b TextBuffer) CopyClipboard(clipboard gdk.ClipboardClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GdkClipboard // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
}
	
	// CreateChildAnchor creates and inserts a child anchor.
// 
// This is a convenience function which simply creates a child anchor with
// [ctor@Gtk.TextChildAnchor.new] and inserts it into the buffer with
// [method@Gtk.TextBuffer.insert_child_anchor].
// 
// The new anchor is owned by the buffer; no reference count is returned to the
// caller of this function.
	func (b TextBuffer) CreateChildAnchor(iter *TextIter) TextChildAnchor {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _cret *C.GtkTextChildAnchor // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)


var _textChildAnchor TextChildAnchor // out

_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

return _textChildAnchor
}
	
	// CreateMark creates a mark at position @where.
// 
// If @mark_name is nil, the mark is anonymous; otherwise, the mark can be
// retrieved by name using [method@Gtk.TextBuffer.get_mark]. If a mark has left
// gravity, and text is inserted at the marks current location, the mark will
// be moved to the left of the newly-inserted text. If the mark has right
// gravity (@left_gravity = false), the mark will end up on the right of
// newly-inserted text. The standard left-to-right cursor is a mark with right
// gravity (when you type, the cursor stays on the right side of the text youre
// typing).
// 
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
// 
// Emits the `GtkTextBuffer`::mark-set signal as notification of the mark's
// initial placement.
	func (b TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) TextMark {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(markName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))
if leftGravity { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if its editable.
	func (b TextBuffer) CutClipboard(clipboard gdk.ClipboardClass, defaultEditable bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GdkClipboard // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
if defaultEditable { _arg2 = C.TRUE }

C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
}
	
	// Delete deletes text between @start and @end.
// 
// The order of @start and @end is not actually relevant;
// gtk_text_buffer_delete() will reorder them.
// 
// This function actually emits the delete-range signal, and the default
// handler of that signal deletes the text. Because the buffer is modified, all
// outstanding iterators become invalid after calling this function; however,
// the @start and @end will be re-initialized to point to the location where
// text was deleted.
	func (b TextBuffer) Delete(start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
}
	
	// DeleteInteractive deletes all editable text in the given range.
// 
// Calls [method@Gtk.TextBuffer.delete] for each editable sub-range of
// [@start,@end). @start and @end are revalidated to point to the location of
// the last deleted range, or left untouched if no text was deleted.
	func (b TextBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(startIter.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(endIter.Native()))
if defaultEditable { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DeleteMark deletes @mark, so that its no longer located anywhere in the
// buffer.
// 
// Removes the reference the buffer holds to the mark, so if you havent called
// g_object_ref() on the mark, it will be freed. Even if the mark isnt freed,
// most operations on @mark become invalid, until it gets added to a buffer
// again with [method@Gtk.TextBuffer.add_mark]. Use
// [method@Gtk.TextMark.get_deleted] to find out if a mark has been removed from
// its buffer.
// 
// The [signal@Gtk.TextBuffer::mark-deleted] signal will be emitted as
// notification after the mark is deleted.
	func (b TextBuffer) DeleteMark(mark TextMarkClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextMark // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

C.gtk_text_buffer_delete_mark(_arg0, _arg1)
}
	
	// DeleteMarkByName deletes the mark named @name; the mark must exist.
// 
// See [method@Gtk.TextBuffer.delete_mark] for details.
	func (b TextBuffer) DeleteMarkByName(name string)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
}
	
	// DeleteSelection deletes the range between the insert and selection_bound
// marks, that is, the currently-selected text.
// 
// If @interactive is true, the editability of the selection will be considered
// (users cant delete uneditable text).
	func (b TextBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.gboolean // out
var _arg2 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
if interactive { _arg1 = C.TRUE }
if defaultEditable { _arg2 = C.TRUE }

_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndIrreversibleAction denotes the end of an action that may not be undone.
// 
// This will cause any previous operations in the undo/redo queue to be cleared.
// 
// This should be called after completing modifications to the text buffer after
// gtk_text_buffer_begin_irreversible_action() was called.
// 
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
	func (b TextBuffer) EndIrreversibleAction()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_end_irreversible_action(_arg0)
}
	
	// EndUserAction ends a user-visible operation.
// 
// Should be paired with a call to [method@Gtk.TextBuffer.begin_user_action].
// See that function for a full explanation.
	func (b TextBuffer) EndUserAction()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_end_user_action(_arg0)
}
	
	// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [@start,@end).
	func (b TextBuffer) Bounds() (start TextIter, end TextIter) {
var _arg0 *C.GtkTextBuffer // out
var _start TextIter
var _end TextIter

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_get_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))







return _start, _end
}
	
	// CanRedo gets whether there is a redoable action in the history.
	func (b TextBuffer) CanRedo() bool {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_can_redo(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanUndo gets whether there is an undoable action in the history.
	func (b TextBuffer) CanUndo() bool {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_can_undo(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CharCount gets the number of characters in the buffer.
// 
// Note that characters and bytes are not the same, you cant e.g. expect the
// contents of the buffer in string form to be this many bytes long.
// 
// The character count is cached, so this function is very fast.
	func (b TextBuffer) CharCount() int {
var _arg0 *C.GtkTextBuffer // out
var _cret C.int // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_char_count(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// EnableUndo gets whether the buffer is saving modifications to the buffer to
// allow for undo and redo actions.
// 
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
// buffer that cannot be undone.
	func (b TextBuffer) EnableUndo() bool {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_enable_undo(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndIter initializes @iter with the end iterator, one past the last valid
// character in the text buffer.
// 
// If dereferenced with [method@Gtk.TextIter.get_char], the end iterator has a
// character value of 0. The entire buffer lies in the range from the first
// position in the buffer (call [method@Gtk.TextBuffer.get_start_iter] to get
// character position 0) to the end iterator.
	func (b TextBuffer) EndIter() TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_get_end_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// HasSelection indicates whether the buffer has some text currently selected.
	func (b TextBuffer) HasSelection() bool {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_has_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GetInsert returns the mark that represents the cursor (insertion point).
// 
// Equivalent to calling [method@Gtk.TextBuffer.get_mark] to get the mark named
// insert, but very slightly more efficient, and involves less typing.
	func (b TextBuffer) GetInsert() TextMark {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_insert(_arg0)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// IterAtChildAnchor obtains the location of @anchor within @buffer.
	func (b TextBuffer) IterAtChildAnchor(anchor TextChildAnchorClass) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 *C.GtkTextChildAnchor // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// IterAtLine initializes @iter to the start of the given line.
// 
// If @line_number is greater than or equal to the number of lines in the
// @buffer, the end iterator is returned.
	func (b TextBuffer) IterAtLine(lineNumber int) (TextIter, bool) {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.int)(lineNumber)

_cret = C.gtk_text_buffer_get_iter_at_line(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterAtLineIndex obtains an iterator pointing to @byte_index within the given
// line.
// 
// @byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
// 
// If @line_number is greater than or equal to the number of lines in the
// @buffer, the end iterator is returned. And if @byte_index is off the end of
// the line, the iterator at the end of the line is returned.
	func (b TextBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool) {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.int // out
var _arg3 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.int)(lineNumber)
_arg3 = (C.int)(byteIndex)

_cret = C.gtk_text_buffer_get_iter_at_line_index(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterAtLineOffset obtains an iterator pointing to @char_offset within the
// given line.
// 
// Note characters, not bytes; UTF-8 may encode one character as multiple bytes.
// 
// If @line_number is greater than or equal to the number of lines in the
// @buffer, the end iterator is returned. And if @char_offset is off the end of
// the line, the iterator at the end of the line is returned.
	func (b TextBuffer) IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool) {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.int // out
var _arg3 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.int)(lineNumber)
_arg3 = (C.int)(charOffset)

_cret = C.gtk_text_buffer_get_iter_at_line_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterAtMark initializes @iter with the current position of @mark.
	func (b TextBuffer) IterAtMark(mark TextMarkClass) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 *C.GtkTextMark // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

C.gtk_text_buffer_get_iter_at_mark(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// IterAtOffset initializes @iter to a position @char_offset chars from the
// start of the entire buffer.
// 
// If @char_offset is -1 or greater than the number of characters in the buffer,
// @iter is initialized to the end iterator, the iterator one past the last
// valid character in the buffer.
	func (b TextBuffer) IterAtOffset(charOffset int) TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter
var _arg2 C.int // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg2 = (C.int)(charOffset)

C.gtk_text_buffer_get_iter_at_offset(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// LineCount obtains the number of lines in the buffer.
// 
// This value is cached, so the function is very fast.
	func (b TextBuffer) LineCount() int {
var _arg0 *C.GtkTextBuffer // out
var _cret C.int // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_line_count(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Mark returns the mark named @name in buffer @buffer, or nil if no such mark
// exists in the buffer.
	func (b TextBuffer) Mark(name string) TextMark {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// MaxUndoLevels gets the maximum number of undo levels to perform.
// 
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
	func (b TextBuffer) MaxUndoLevels() uint {
var _arg0 *C.GtkTextBuffer // out
var _cret C.guint // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_max_undo_levels(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Modified indicates whether the buffer has been modified since the last call
// to [method@Gtk.TextBuffer.set_modified] set the modification flag to false.
// 
// Used for example to enable a save function in a text editor.
	func (b TextBuffer) Modified() bool {
var _arg0 *C.GtkTextBuffer // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_modified(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectionBound returns the mark that represents the selection bound.
// 
// Equivalent to calling [method@Gtk.TextBuffer.get_mark] to get the mark named
// selection_bound, but very slightly more efficient, and involves less
// typing.
// 
// The currently-selected text in @buffer is the region between the
// selection_bound and insert marks. If selection_bound and insert are
// in the same place, then there is no current selection.
// [method@Gtk.TextBuffer.get_selection_bounds] is another convenient function
// for handling the selection, if you just want to know whether theres a
// selection and what its bounds are.
	func (b TextBuffer) SelectionBound() TextMark {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTextMark // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_selection_bound(_arg0)


var _textMark TextMark // out

_textMark = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextMark)

return _textMark
}
	
	// SelectionBounds returns true if some text is selected; places the bounds of
// the selection in @start and @end.
// 
// If the selection has length 0, then @start and @end are filled in with the
// same value. @start and @end will be in ascending order. If @start and @end
// are nil, then they are not filled in, but the return value still indicates
// whether text is selected.
	func (b TextBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
var _arg0 *C.GtkTextBuffer // out
var _start TextIter
var _end TextIter
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_start)), (*C.GtkTextIter)(unsafe.Pointer(&_end)))




var _ok bool // out



if _cret != 0 { _ok = true }

return _start, _end, _ok
}
	
	// SelectionContent: get a content provider for this buffer.
// 
// It can be used to make the content of @buffer available in a `GdkClipboard`,
// see [method@Gdk.Clipboard.set_content].
	func (b TextBuffer) SelectionContent() gdk.ContentProvider {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GdkContentProvider // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_selection_content(_arg0)


var _contentProvider gdk.ContentProvider // out

_contentProvider = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.ContentProvider)

return _contentProvider
}
	
	// Slice returns the text in the range [@start,@end).
// 
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if @include_hidden_chars is false. The returned string includes a
// 0xFFFC character whenever the buffer contains embedded images, so byte and
// character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with
// [method@Gtk.TextBuffer.get_text]. Note that 0xFFFC can occur in normal text
// as well, so it is not a reliable indicator that a paintable or widget is in
// the buffer.
	func (b TextBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret *C.char // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
if includeHiddenChars { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// StartIter: initialized @iter with the first position in the text buffer.
// 
// This is the same as using [method@Gtk.TextBuffer.get_iter_at_offset] to get
// the iter at character offset 0.
	func (b TextBuffer) StartIter() TextIter {
var _arg0 *C.GtkTextBuffer // out
var _iter TextIter

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_get_start_iter(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)))





return _iter
}
	
	// TagTable: get the `GtkTextTagTable` associated with this buffer.
	func (b TextBuffer) TagTable() TextTagTable {
var _arg0 *C.GtkTextBuffer // out
var _cret *C.GtkTextTagTable // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

_cret = C.gtk_text_buffer_get_tag_table(_arg0)


var _textTagTable TextTagTable // out

_textTagTable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTagTable)

return _textTagTable
}
	
	// Text returns the text in the range [@start,@end).
// 
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if @include_hidden_chars is false. Does not include characters
// representing embedded images, so byte and character indexes into the returned
// string do not correspond to byte and character indexes into the buffer.
// Contrast with [method@Gtk.TextBuffer.get_slice].
	func (b TextBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out
var _cret *C.char // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
if includeHiddenChars { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Insert inserts @len bytes of @text at position @iter.
// 
// If @len is -1, @text must be nul-terminated and will be inserted in its
// entirety. Emits the insert-text signal; insertion actually occurs in the
// default handler for the signal. @iter is invalidated when insertion occurs
// (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
	func (b TextBuffer) Insert(iter *TextIter, text string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.char // out
var _arg3 C.int // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(len)

C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertAtCursor inserts @text in @buffer.
// 
// Simply calls [method@Gtk.TextBuffer.insert], using the current cursor
// position as the insertion point.
	func (b TextBuffer) InsertAtCursor(text string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _arg2 C.int // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(len)

C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
}
	
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
// @iter.
// 
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// object replacement character 0xFFFC. Note that the slice variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the text variants do not. E.g. see
// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
// 
// Consider [method@Gtk.TextBuffer.create_child_anchor] as a more convenient
// alternative to this function. The buffer will add a reference to the anchor,
// so you can unref it after insertion.
	func (b TextBuffer) InsertChildAnchor(iter *TextIter, anchor TextChildAnchorClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextChildAnchor // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
}
	
	// InsertInteractive inserts @text in @buffer.
// 
// Like [method@Gtk.TextBuffer.insert], but the insertion will not occur if
// @iter is at a non-editable location in the buffer. Usually you want to
// prevent insertions at ineditable locations if the insertion results from a
// user action (is interactive).
// 
// @default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// [method@Gtk.TextView.get_editable] is appropriate here.
	func (b TextBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.char // out
var _arg3 C.int // out
var _arg4 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(len)
if defaultEditable { _arg4 = C.TRUE }

_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsertInteractiveAtCursor inserts @text in @buffer.
// 
// Calls [method@Gtk.TextBuffer.insert_interactive] at the cursor position.
// 
// @default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// [method@Gtk.TextView.get_editable] is appropriate here.
	func (b TextBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _arg2 C.int // out
var _arg3 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(len)
if defaultEditable { _arg3 = C.TRUE }

_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsertMarkup inserts the text in @markup at position @iter.
// 
// @markup will be inserted in its entirety and must be nul-terminated and valid
// UTF-8. Emits the [signal@Gtk.TextBuffer::insert-text] signal, possibly
// multiple times; insertion actually occurs in the default handler for the
// signal. @iter will point to the end of the inserted text on return.
	func (b TextBuffer) InsertMarkup(iter *TextIter, markup string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.char // out
var _arg3 C.int // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.char)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(len)

C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertPaintable inserts an image into the text buffer at @iter.
// 
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// object replacement character 0xFFFC. Note that the slice variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the text variants do not. e.g. see
// [method@Gtk.TextBuffer.get_slice] and [method@Gtk.TextBuffer.get_text].
	func (b TextBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintable)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GdkPaintable // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

C.gtk_text_buffer_insert_paintable(_arg0, _arg1, _arg2)
}
	
	// InsertRange copies text, tags, and paintables between @start and @end and
// inserts the copy at @iter.
// 
// The order of @start and @end doesnt matter.
// 
// Used instead of simply getting/inserting text because it preserves images and
// tags. If @start and @end are in a different buffer from @buffer, the two
// buffers must share the same tag table.
// 
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
	func (b TextBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
}
	
	// InsertRangeInteractive copies text, tags, and paintables between @start and
// @end and inserts the copy at @iter.
// 
// Same as [method@Gtk.TextBuffer.insert_range], but does nothing if the
// insertion point isnt editable. The @default_editable parameter indicates
// whether the text is editable at @iter if no tags enclosing @iter affect
// editability. Typically the result of [method@Gtk.TextView.get_editable] is
// appropriate here.
	func (b TextBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out
var _arg4 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))
if defaultEditable { _arg4 = C.TRUE }

_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveMark moves @mark to the new location @where.
// 
// Emits the `GtkTextBuffer`::mark-set signal as notification of the move.
	func (b TextBuffer) MoveMark(mark TextMarkClass, where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextMark // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
}
	
	// MoveMarkByName moves the mark named @name (which must exist) to location
// @where.
// 
// See [method@Gtk.TextBuffer.move_mark] for details.
	func (b TextBuffer) MoveMarkByName(name string, where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
}
	
	// PasteClipboard pastes the contents of a clipboard.
// 
// If @override_location is nil, the pasted text will be inserted at the cursor
// position, or the buffer selection will be replaced if the selection is
// non-empty.
// 
// Note: pasting is asynchronous, that is, well ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
	func (b TextBuffer) PasteClipboard(clipboard gdk.ClipboardClass, overrideLocation *TextIter, defaultEditable bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GdkClipboard // out
var _arg2 *C.GtkTextIter // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(overrideLocation.Native()))
if defaultEditable { _arg3 = C.TRUE }

C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
}
	
	// PlaceCursor: this function moves the insert and selection_bound marks
// simultaneously.
// 
// If you move them to the same place in two steps with
// [method@Gtk.TextBuffer.move_mark], you will temporarily select a region in
// between their old and new locations, which can be pretty inefficient since
// the temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
	func (b TextBuffer) PlaceCursor(where *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(where.Native()))

C.gtk_text_buffer_place_cursor(_arg0, _arg1)
}
	
	// Redo redoes the next redoable action on the buffer, if there is one.
	func (b TextBuffer) Redo()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_redo(_arg0)
}
	
	// RemoveAllTags removes all tags in the range between @start and @end.
// 
// Be careful with this function; it could remove tags added in code unrelated
// to the code youre currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that add
// tags.
	func (b TextBuffer) RemoveAllTags(start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
}
	
	// RemoveSelectionClipboard removes a `GdkClipboard` added with
// gtk_text_buffer_add_selection_clipboard().
	func (b TextBuffer) RemoveSelectionClipboard(clipboard gdk.ClipboardClass)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GdkClipboard // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
}
	
	// RemoveTag emits the remove-tag signal.
// 
// The default handler for the signal removes all occurrences of @tag from the
// given range. @start and @end dont have to be in order.
	func (b TextBuffer) RemoveTag(tag TextTagClass, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextTag // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
}
	
	// RemoveTagByName emits the remove-tag signal.
// 
// Calls [method@Gtk.TextTagTable.lookup] on the buffers tag table to get a
// `GtkTextTag`, then calls [method@Gtk.TextBuffer.remove_tag].
	func (b TextBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _arg2 *C.GtkTextIter // out
var _arg3 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
}
	
	// SelectRange: this function moves the insert and selection_bound marks
// simultaneously.
// 
// If you move them in two steps with [method@Gtk.TextBuffer.move_mark], you
// will temporarily select a region in between their old and new locations,
// which can be pretty inefficient since the temporarily-selected region will
// force stuff to be recalculated. This function moves them as a unit, which can
// be optimized.
	func (b TextBuffer) SelectRange(ins *TextIter, bound *TextIter)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(ins.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(bound.Native()))

C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
}
	
	// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer.
// 
// If enabled, the user will be able to undo the last number of actions up to
// [method@Gtk.TextBuffer.get_max_undo_levels].
// 
// See [method@Gtk.TextBuffer.begin_irreversible_action] and
// [method@Gtk.TextBuffer.end_irreversible_action] to create changes to the
// buffer that cannot be undone.
	func (b TextBuffer) SetEnableUndo(enableUndo bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
if enableUndo { _arg1 = C.TRUE }

C.gtk_text_buffer_set_enable_undo(_arg0, _arg1)
}
	
	// SetMaxUndoLevels sets the maximum number of undo levels to perform.
// 
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
	func (b TextBuffer) SetMaxUndoLevels(maxUndoLevels uint)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.guint // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (C.guint)(maxUndoLevels)

C.gtk_text_buffer_set_max_undo_levels(_arg0, _arg1)
}
	
	// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved.
// 
// Whenever the buffer is saved to disk, call `gtk_text_buffer_set_modified
// (@buffer, FALSE)`. When the buffer is modified, it will automatically toggled
// on the modified bit again. When the modified bit flips, the buffer emits the
// [signal@Gtk.TextBuffer::modified-changed] signal.
	func (b TextBuffer) SetModified(setting bool)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_buffer_set_modified(_arg0, _arg1)
}
	
	// SetText deletes current contents of @buffer, and inserts @text instead.
// 
// If @len is -1, @text must be nul-terminated. @text must be valid UTF-8.
	func (b TextBuffer) SetText(text string, len int)  {
var _arg0 *C.GtkTextBuffer // out
var _arg1 *C.char // out
var _arg2 C.int // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.int)(len)

C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
}
	
	// Undo undoes the last undoable action on the buffer, if there is one.
	func (b TextBuffer) Undo()  {
var _arg0 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(b.Native()))

C.gtk_text_buffer_undo(_arg0)
}
	


	// TextChildAnchor: a `GtkTextChildAnchor` is a spot in a `GtkTextBuffer` where
// child widgets can be anchored.
// 
// The anchor can have multiple widgets anchored, to allow for multiple views.
	type TextChildAnchor struct {
		**externglib.Object
		
	}

	// TextChildAnchorClass is an interface that the TextChildAnchor class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextChildAnchorClass interface {
		gextras.Objector
		_textChildAnchor()
	}

	func (TextChildAnchor) _textChildAnchor() {}

	
	func marshalTextChildAnchor(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextChildAnchor(obj), nil
	}
	

	
	// NewTextChildAnchor creates a new `GtkTextChildAnchor`.
// 
// Usually you would then insert it into a `GtkTextBuffer` with
// [method@Gtk.TextBuffer.insert_child_anchor]. To perform the creation and
// insertion in one step, use the convenience function
// [method@Gtk.TextBuffer.create_child_anchor].
	func NewTextChildAnchor() TextChildAnchor {
var _cret *C.GtkTextChildAnchor // in

_cret = C.gtk_text_child_anchor_new()


var _textChildAnchor TextChildAnchor // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textChildAnchor = TextChildAnchor{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textChildAnchor
}
	

	
	// Deleted determines whether a child anchor has been deleted from the buffer.
// 
// Keep in mind that the child anchor will be unreferenced when removed from the
// buffer, so you need to hold your own reference (with g_object_ref()) if you
// plan to use this function  otherwise all deleted child anchors will also be
// finalized.
	func (a TextChildAnchor) Deleted() bool {
var _arg0 *C.GtkTextChildAnchor // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextChildAnchor)(unsafe.Pointer(a.Native()))

_cret = C.gtk_text_child_anchor_get_deleted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// TextMark: a `GtkTextMark` is a position in a `GtkTextbuffer` that is
// preserved across modifications.
// 
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
// 
// A `GtkTextMark` is like a bookmark in a text buffer; it preserves a position
// in the text. You can convert the mark to an iterator using
// [method@Gtk.TextBuffer.get_iter_at_mark]. Unlike iterators, marks remain
// valid across buffer mutations, because their behavior is defined when text is
// inserted or deleted. When text containing a mark is deleted, the mark remains
// in the position originally occupied by the deleted text. When text is
// inserted at a mark, a mark with left gravity will be moved to the beginning
// of the newly-inserted text, and a mark with right gravity will be moved to
// the end.
// 
// Note that left and right here refer to logical direction (left is the
// toward the start of the buffer); in some languages such as Hebrew the
// logically-leftmost text is not actually on the left when displayed.
// 
// Marks are reference counted, but the reference count only controls the
// validity of the memory; marks can be deleted from the buffer at any time with
// [method@Gtk.TextBuffer.delete_mark]. Once deleted from the buffer, a mark is
// essentially useless.
// 
// Marks optionally have names; these can be convenient to avoid passing the
// `GtkTextMark` object around.
// 
// Marks are typically created using the [method@Gtk.TextBuffer.create_mark]
// function.
	type TextMark struct {
		**externglib.Object
		
	}

	// TextMarkClass is an interface that the TextMark class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextMarkClass interface {
		gextras.Objector
		_textMark()
	}

	func (TextMark) _textMark() {}

	
	func marshalTextMark(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextMark(obj), nil
	}
	

	
	// NewTextMark creates a text mark.
// 
// Add it to a buffer using [method@Gtk.TextBuffer.add_mark]. If @name is nil,
// the mark is anonymous; otherwise, the mark can be retrieved by name using
// [method@Gtk.TextBuffer.get_mark]. If a mark has left gravity, and text is
// inserted at the marks current location, the mark will be moved to the left
// of the newly-inserted text. If the mark has right gravity (@left_gravity =
// false), the mark will end up on the right of newly-inserted text. The
// standard left-to-right cursor is a mark with right gravity (when you type,
// the cursor stays on the right side of the text youre typing).
	func NewTextMark(name string, leftGravity bool) TextMark {
var _arg1 *C.char // out
var _arg2 C.gboolean // out
var _cret *C.GtkTextMark // in

_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
if leftGravity { _arg2 = C.TRUE }

_cret = C.gtk_text_mark_new(_arg1, _arg2)


var _textMark TextMark // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textMark = TextMark{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textMark
}
	

	
	// Buffer gets the buffer this mark is located inside.
// 
// Returns nil if the mark is deleted.
	func (m TextMark) Buffer() TextBuffer {
var _arg0 *C.GtkTextMark // out
var _cret *C.GtkTextBuffer // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_buffer(_arg0)


var _textBuffer TextBuffer // out

_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

return _textBuffer
}
	
	// Deleted returns true if the mark has been removed from its buffer.
// 
// See [method@Gtk.TextBuffer.add_mark] for a way to add it to a buffer again.
	func (m TextMark) Deleted() bool {
var _arg0 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_deleted(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LeftGravity determines whether the mark has left gravity.
	func (m TextMark) LeftGravity() bool {
var _arg0 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_left_gravity(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Name returns the mark name.
// 
// Returns nil for anonymous marks.
	func (m TextMark) Name() string {
var _arg0 *C.GtkTextMark // out
var _cret *C.char // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Visible returns true if the mark is visible.
// 
// A cursor is displayed for visible marks.
	func (m TextMark) Visible() bool {
var _arg0 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))

_cret = C.gtk_text_mark_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	
	func (m TextMark) SetVisible(setting bool)  {
var _arg0 *C.GtkTextMark // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextMark)(unsafe.Pointer(m.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_mark_set_visible(_arg0, _arg1)
}
	


	// TextTag: a tag that can be applied to text contained in a `GtkTextBuffer`.
// 
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
// 
// Tags should be in the [class@Gtk.TextTagTable] for a given `GtkTextBuffer`
// before using them with that buffer.
// 
// [method@Gtk.TextBuffer.create_tag] is the best way to create tags. See
// gtk4-demo for numerous examples.
// 
// For each property of `GtkTextTag`, there is a set property, e.g. font-set
// corresponds to font. These set properties reflect whether a property has
// been set or not.
// 
// They are maintained by GTK and you should not set them independently.
	type TextTag struct {
		**externglib.Object
		
	}

	// TextTagClass is an interface that the TextTag class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextTagClass interface {
		gextras.Objector
		_textTag()
	}

	func (TextTag) _textTag() {}

	
	func marshalTextTag(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextTag(obj), nil
	}
	

	
	// NewTextTag creates a `GtkTextTag`.
	func NewTextTag(name string) TextTag {
var _arg1 *C.char // out
var _cret *C.GtkTextTag // in

_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_tag_new(_arg1)


var _textTag TextTag // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textTag = TextTag{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _textTag
}
	

	
	// Changed emits the [signal@Gtk.TextTagTable::tag-changed] signal on the
// `GtkTextTagTable` where the tag is included.
// 
// The signal is already emitted when setting a `GtkTextTag` property. This
// function is useful for a `GtkTextTag` subclass.
	func (t TextTag) Changed(sizeChanged bool)  {
var _arg0 *C.GtkTextTag // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
if sizeChanged { _arg1 = C.TRUE }

C.gtk_text_tag_changed(_arg0, _arg1)
}
	
	// Priority: get the tag priority.
	func (t TextTag) Priority() int {
var _arg0 *C.GtkTextTag // out
var _cret C.int // in

_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_tag_get_priority(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SetPriority sets the priority of a `GtkTextTag`.
// 
// Valid priorities start at 0 and go to one less than
// [method@Gtk.TextTagTable.get_size]. Each tag in a table has a unique
// priority; setting the priority of one tag shifts the priorities of all the
// other tags in the table to maintain a unique priority for each tag.
// 
// Higher priority tags win if two tags both set the same text attribute. When
// adding a tag to a tag table, it will be assigned the highest priority in the
// table by default; so normally the precedence of a set of tags is the order in
// which they were added to the table, or created with
// [method@Gtk.TextBuffer.create_tag], which adds the tag to the buffers table
// automatically.
	func (t TextTag) SetPriority(priority int)  {
var _arg0 *C.GtkTextTag // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextTag)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(priority)

C.gtk_text_tag_set_priority(_arg0, _arg1)
}
	


	// TextTagTable: the collection of tags in a `GtkTextBuffer`
// 
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
// 
// 
// GtkTextTagTables as GtkBuildable
// 
// The `GtkTextTagTable` implementation of the `GtkBuildable` interface supports
// adding tags by specifying tag as the type attribute of a <child> element.
// 
// An example of a UI definition fragment specifying tags: `xml <object
// class="GtkTextTagTable"> <child type="tag"> <object class="GtkTextTag"/>
// </child> </object> `
	type TextTagTable struct {
		**externglib.Object
		Buildable
		
	}

	// TextTagTableClass is an interface that the TextTagTable class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextTagTableClass interface {
		gextras.Objector
		_textTagTable()
	}

	func (TextTagTable) _textTagTable() {}

	
	func marshalTextTagTable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextTagTable(obj), nil
	}
	

	
	// NewTextTagTable creates a new `GtkTextTagTable`.
// 
// The table contains no tags by default.
	func NewTextTagTable() TextTagTable {
var _cret *C.GtkTextTagTable // in

_cret = C.gtk_text_tag_table_new()


var _textTagTable TextTagTable // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_textTagTable = TextTagTable{
Object: &externglib.Object{externglib.ToGObject(obj)},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _textTagTable
}
	

	
	// Add: add a tag to the table.
// 
// The tag is assigned the highest priority in the table.
// 
// @tag must not be in a tag table already, and may not have the same name as an
// already-added tag.
	func (t TextTagTable) Add(tag TextTagClass) bool {
var _arg0 *C.GtkTextTagTable // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_tag_table_add(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Size returns the size of the table (number of tags)
	func (t TextTagTable) Size() int {
var _arg0 *C.GtkTextTagTable // out
var _cret C.int // in

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_tag_table_get_size(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Lookup: look up a named tag.
	func (t TextTagTable) Lookup(name string) TextTag {
var _arg0 *C.GtkTextTagTable // out
var _arg1 *C.char // out
var _cret *C.GtkTextTag // in

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_text_tag_table_lookup(_arg0, _arg1)


var _textTag TextTag // out

_textTag = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextTag)

return _textTag
}
	
	// Remove: remove a tag from the table.
// 
// If a `GtkTextBuffer` has @table as its tag table, the tag is removed from the
// buffer. The tables reference to the tag is removed, so the tag will end up
// destroyed if you dont have a reference to it.
	func (t TextTagTable) Remove(tag TextTagClass)  {
var _arg0 *C.GtkTextTagTable // out
var _arg1 *C.GtkTextTag // out

_arg0 = (*C.GtkTextTagTable)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

C.gtk_text_tag_table_remove(_arg0, _arg1)
}
	


	// TextView: a widget that displays the contents of a [class@Gtk.TextBuffer].
// 
// !An example GtkTextview (multiline-text.png)
// 
// You may wish to begin by reading the conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
// 
// 
// CSS nodes
// 
// ` textview.view  border.top  border.left  text   [selection]
//  border.right  border.bottom  [window.popup] `
// 
// `GtkTextView` has a main css node with name textview and style class .view,
// and subnodes for each of the border windows, and the main text area, with
// names border and text, respectively. The border nodes each get one of the
// style classes .left, .right, .top or .bottom.
// 
// A node representing the selection will appear below the text node.
// 
// If a context menu is opened, the window node will appear as a subnode of the
// main node.
// 
// 
// Accessibility
// 
// `GtkTextView` uses the K_ACCESSIBLE_ROLE_TEXT_BOX role.
	type TextView struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Scrollable
		
	}

	// TextViewClass is an interface that the TextView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TextViewClass interface {
		gextras.Objector
		_textView()
	}

	func (TextView) _textView() {}

	
	func marshalTextView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTextView(obj), nil
	}
	

	
	// NewTextView creates a new `GtkTextView`.
// 
// If you dont call [method@Gtk.TextView.set_buffer] before using the text
// view, an empty default buffer will be created for you. Get the buffer with
// [method@Gtk.TextView.get_buffer]. If you want to specify your own buffer,
// consider [ctor@Gtk.TextView.new_with_buffer].
	func NewTextView() TextView {
var _cret *C.GtkWidget // in

_cret = C.gtk_text_view_new()


var _textView TextView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_textView = TextView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _textView
}
	
	// NewTextViewWithBuffer creates a new `GtkTextView` widget displaying the
// buffer @buffer.
// 
// One buffer can be shared among many widgets. @buffer may be nil to create a
// default buffer, in which case this function is equivalent to
// [ctor@Gtk.TextView.new]. The text view adds its own reference count to the
// buffer; it does not take over an existing reference.
	func NewTextViewWithBuffer(buffer TextBufferClass) TextView {
var _arg1 *C.GtkTextBuffer // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

_cret = C.gtk_text_view_new_with_buffer(_arg1)


var _textView TextView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_textView = TextView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _textView
}
	

	
	// AddChildAtAnchor adds a child widget in the text buffer, at the given
// @anchor.
	func (t TextView) AddChildAtAnchor(child WidgetClass, anchor TextChildAnchorClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkTextChildAnchor // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

C.gtk_text_view_add_child_at_anchor(_arg0, _arg1, _arg2)
}
	
	// AddOverlay adds @child at a fixed coordinate in the `GtkTextView`'s text
// window.
// 
// The @xpos and @ypos must be in buffer coordinates (see
// [method@Gtk.TextView.get_iter_location] to convert to buffer coordinates).
// 
// @child will scroll with the text view.
// 
// If instead you want a widget that will not move with the `GtkTextView`
// contents see Overlay.
	func (t TextView) AddOverlay(child WidgetClass, xpos int, ypos int)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out
var _arg3 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(xpos)
_arg3 = (C.int)(ypos)

C.gtk_text_view_add_overlay(_arg0, _arg1, _arg2, _arg3)
}
	
	// BackwardDisplayLine moves the given @iter backward by one display (wrapped)
// line.
// 
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
	func (t TextView) BackwardDisplayLine(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_backward_display_line(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardDisplayLineStart moves the given @iter backward to the next display
// line start.
// 
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
	func (t TextView) BackwardDisplayLineStart(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_backward_display_line_start(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BufferToWindowCoords converts buffer coordinates to window coordinates.
	func (t TextView) BufferToWindowCoords(win TextWindowType, bufferX int, bufferY int) (windowX int, windowY int) {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 C.int // in
var _arg5 C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(win)
_arg2 = (C.int)(bufferX)
_arg3 = (C.int)(bufferY)

C.gtk_text_view_buffer_to_window_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _windowX int // out
var _windowY int // out

_windowX = (int)(_arg4)
_windowY = (int)(_arg5)

return _windowX, _windowY
}
	
	// ForwardDisplayLine moves the given @iter forward by one display (wrapped)
// line.
// 
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
	func (t TextView) ForwardDisplayLine(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_forward_display_line(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardDisplayLineEnd moves the given @iter forward to the next display line
// end.
// 
// A display line is different from a paragraph. Paragraphs are separated by
// newlines or other paragraph separator characters. Display lines are created
// by line-wrapping a paragraph. If wrapping is turned off, display lines and
// paragraphs will be the same. Display lines are divided differently for each
// view, since they depend on the views width; paragraphs are the same in all
// views, since they depend on the contents of the `GtkTextBuffer`.
	func (t TextView) ForwardDisplayLineEnd(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_forward_display_line_end(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AcceptsTab returns whether pressing the Tab key inserts a tab characters.
// 
// See [method@Gtk.TextView.set_accepts_tab].
	func (t TextView) AcceptsTab() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_accepts_tab(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BottomMargin gets the bottom margin for text in the @text_view.
	func (t TextView) BottomMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_bottom_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Buffer returns the `GtkTextBuffer` being displayed by this text view.
// 
// The reference count on the buffer is not incremented; the caller of this
// function wont own a new reference.
	func (t TextView) Buffer() TextBuffer {
var _arg0 *C.GtkTextView // out
var _cret *C.GtkTextBuffer // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_buffer(_arg0)


var _textBuffer TextBuffer // out

_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

return _textBuffer
}
	
	// CursorLocations: determine the positions of the strong and weak cursors if
// the insertion point is at @iter.
// 
// The position of each cursor is stored as a zero-width rectangle. The strong
// cursor location is the location where characters of the directionality equal
// to the base direction of the paragraph are inserted. The weak cursor location
// is the location where characters of the directionality opposite to the base
// direction of the paragraph are inserted.
// 
// If @iter is nil, the actual cursor position is used.
// 
// Note that if @iter happens to be the actual cursor position, and there is
// currently an IM preedit sequence being entered, the returned locations will
// be adjusted to account for the preedit cursors offset within the preedit
// sequence.
// 
// The rectangle position is in buffer coordinates; use
// [method@Gtk.TextView.buffer_to_window_coords] to convert these coordinates to
// coordinates for one of the windows in the text view.
	func (t TextView) CursorLocations(iter *TextIter) (strong gdk.Rectangle, weak gdk.Rectangle) {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _strong gdk.Rectangle
var _weak gdk.Rectangle

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

C.gtk_text_view_get_cursor_locations(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_strong)), (*C.GdkRectangle)(unsafe.Pointer(&_weak)))







return _strong, _weak
}
	
	// CursorVisible: find out whether the cursor should be displayed.
	func (t TextView) CursorVisible() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_cursor_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Editable returns the default editability of the `GtkTextView`.
// 
// Tags in the buffer may override this setting for some ranges of text.
	func (t TextView) Editable() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_editable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ExtraMenu gets the menu model that gets added to the context menu or nil if
// none has been set.
	func (t TextView) ExtraMenu() gio.MenuModel {
var _arg0 *C.GtkTextView // out
var _cret *C.GMenuModel // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_extra_menu(_arg0)


var _menuModel gio.MenuModel // out

_menuModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.MenuModel)

return _menuModel
}
	
	// Gutter gets a `GtkWidget` that has previously been set as gutter.
// 
// See [method@Gtk.TextView.set_gutter].
// 
// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	func (t TextView) Gutter(win TextWindowType) Widget {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(win)

_cret = C.gtk_text_view_get_gutter(_arg0, _arg1)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Indent gets the default indentation of paragraphs in @text_view.
// 
// Tags in the views buffer may override the default. The indentation may be
// negative.
	func (t TextView) Indent() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_indent(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// InputHints gets the `input-hints` of the `GtkTextView`.
	func (t TextView) InputHints() InputHints {
var _arg0 *C.GtkTextView // out
var _cret C.GtkInputHints // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_input_hints(_arg0)


var _inputHints InputHints // out

_inputHints = InputHints(_cret)

return _inputHints
}
	
	// InputPurpose gets the `input-purpose` of the `GtkTextView`.
	func (t TextView) InputPurpose() InputPurpose {
var _arg0 *C.GtkTextView // out
var _cret C.GtkInputPurpose // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_input_purpose(_arg0)


var _inputPurpose InputPurpose // out

_inputPurpose = InputPurpose(_cret)

return _inputPurpose
}
	
	// IterAtLocation retrieves the iterator at buffer coordinates @x and @y.
// 
// Buffer coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// [method@Gtk.TextView.window_to_buffer_coords].
	func (t TextView) IterAtLocation(x int, y int) (TextIter, bool) {
var _arg0 *C.GtkTextView // out
var _iter TextIter
var _arg2 C.int // out
var _arg3 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg2 = (C.int)(x)
_arg3 = (C.int)(y)

_cret = C.gtk_text_view_get_iter_at_location(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)



var _ok bool // out


if _cret != 0 { _ok = true }

return _iter, _ok
}
	
	// IterAtPosition retrieves the iterator pointing to the character at buffer
// coordinates @x and @y.
// 
// Buffer coordinates are coordinates for the entire buffer, not just the
// currently-displayed portion. If you have coordinates from an event, you have
// to convert those to buffer coordinates with
// [method@Gtk.TextView.window_to_buffer_coords].
// 
// Note that this is different from [method@Gtk.TextView.get_iter_at_location],
// which returns cursor locations, i.e. positions between characters.
	func (t TextView) IterAtPosition(x int, y int) (TextIter, int, bool) {
var _arg0 *C.GtkTextView // out
var _iter TextIter
var _arg2 C.int // in
var _arg3 C.int // out
var _arg4 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg3 = (C.int)(x)
_arg4 = (C.int)(y)

_cret = C.gtk_text_view_get_iter_at_position(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_iter)), &_arg2, _arg3, _arg4)



var _trailing int // out
var _ok bool // out


_trailing = (int)(_arg2)
if _cret != 0 { _ok = true }

return _iter, _trailing, _ok
}
	
	// IterLocation gets a rectangle which roughly contains the character at @iter.
// 
// The rectangle position is in buffer coordinates; use
// [method@Gtk.TextView.buffer_to_window_coords] to convert these coordinates to
// coordinates for one of the windows in the text view.
	func (t TextView) IterLocation(iter *TextIter) gdk.Rectangle {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _location gdk.Rectangle

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

C.gtk_text_view_get_iter_location(_arg0, _arg1, (*C.GdkRectangle)(unsafe.Pointer(&_location)))





return _location
}
	
	// Justification gets the default justification of paragraphs in @text_view.
// 
// Tags in the buffer may override the default.
	func (t TextView) Justification() Justification {
var _arg0 *C.GtkTextView // out
var _cret C.GtkJustification // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_justification(_arg0)


var _justification Justification // out

_justification = Justification(_cret)

return _justification
}
	
	// LeftMargin gets the default left margin size of paragraphs in the @text_view.
// 
// Tags in the buffer may override the default.
	func (t TextView) LeftMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_left_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LineAtY gets the `GtkTextIter` at the start of the line containing the
// coordinate @y.
// 
// @y is in buffer coordinates, convert from window coordinates with
// [method@Gtk.TextView.window_to_buffer_coords]. If non-nil, @line_top will be
// filled with the coordinate of the top edge of the line.
	func (t TextView) LineAtY(y int) (TextIter, int) {
var _arg0 *C.GtkTextView // out
var _targetIter TextIter
var _arg2 C.int // out
var _arg3 C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg2 = (C.int)(y)

C.gtk_text_view_get_line_at_y(_arg0, (*C.GtkTextIter)(unsafe.Pointer(&_targetIter)), _arg2, &_arg3)


var _lineTop int // out


_lineTop = (int)(_arg3)

return _targetIter, _lineTop
}
	
	// LineYrange gets the y coordinate of the top of the line containing @iter, and
// the height of the line.
// 
// The coordinate is a buffer coordinate; convert to window coordinates with
// [method@Gtk.TextView.buffer_to_window_coords].
	func (t TextView) LineYrange(iter *TextIter) (y int, height int) {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.int // in
var _arg3 C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

C.gtk_text_view_get_line_yrange(_arg0, _arg1, &_arg2, &_arg3)

var _y int // out
var _height int // out

_y = (int)(_arg2)
_height = (int)(_arg3)

return _y, _height
}
	
	// Monospace gets whether the `GtkTextView` uses monospace styling.
	func (t TextView) Monospace() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_monospace(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Overwrite returns whether the `GtkTextView` is in overwrite mode or not.
	func (t TextView) Overwrite() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_overwrite(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PixelsAboveLines gets the default number of pixels to put above paragraphs.
// 
// Adding this function with [method@Gtk.TextView.get_pixels_below_lines] is
// equal to the line space between each paragraph.
	func (t TextView) PixelsAboveLines() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_pixels_above_lines(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PixelsBelowLines gets the default number of pixels to put below paragraphs.
// 
// The line space is the sum of the value returned by this function and the
// value returned by [method@Gtk.TextView.get_pixels_above_lines].
	func (t TextView) PixelsBelowLines() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_pixels_below_lines(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PixelsInsideWrap gets the default number of pixels to put between wrapped
// lines inside a paragraph.
	func (t TextView) PixelsInsideWrap() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_pixels_inside_wrap(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// RightMargin gets the default right margin for text in @text_view.
// 
// Tags in the buffer may override the default.
	func (t TextView) RightMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_right_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Tabs gets the default tabs for @text_view.
// 
// Tags in the buffer may override the defaults. The returned array will be nil
// if standard (8-space) tabs are used. Free the return value with
// [method@Pango.TabArray.free].
	func (t TextView) Tabs() *pango.TabArray {
var _arg0 *C.GtkTextView // out
var _cret *C.PangoTabArray // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_tabs(_arg0)


var _tabArray *pango.TabArray // out

_tabArray = *(**pango.TabArray)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_tabArray, func(v *pango.TabArray) {
  C.free(unsafe.Pointer(v.Native()))
})

return _tabArray
}
	
	// TopMargin gets the top margin for text in the @text_view.
	func (t TextView) TopMargin() int {
var _arg0 *C.GtkTextView // out
var _cret C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_top_margin(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in buffer coordinates.
// 
// Convert to window coordinates with
// [method@Gtk.TextView.buffer_to_window_coords].
	func (t TextView) VisibleRect() gdk.Rectangle {
var _arg0 *C.GtkTextView // out
var _visibleRect gdk.Rectangle

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

C.gtk_text_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))





return _visibleRect
}
	
	// WrapMode gets the line wrapping for the view.
	func (t TextView) WrapMode() WrapMode {
var _arg0 *C.GtkTextView // out
var _cret C.GtkWrapMode // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_get_wrap_mode(_arg0)


var _wrapMode WrapMode // out

_wrapMode = WrapMode(_cret)

return _wrapMode
}
	
	// ImContextFilterKeypress: allow the `GtkTextView` input method to internally
// handle key press and release events.
// 
// If this function returns true, then no further processing should be done for
// this key event. See [method@Gtk.IMContext.filter_keypress].
// 
// Note that you are expected to call this function from your handler when
// overriding key event handling. This is needed in the case when you need to
// insert your own key handling between the input method and the default key
// event handling of the `GtkTextView`.
// 
// `c static gboolean gtk_foo_bar_key_press_event (GtkWidget *widget, GdkEvent
// *event) { guint keyval;
// 
//    gdk_event_get_keyval ((GdkEvent*)event, &keyval);
// 
//    if (keyval == GDK_KEY_Return || keyval == GDK_KEY_KP_Enter)
//      {
//        if (gtk_text_view_im_context_filter_keypress (GTK_TEXT_VIEW (widget), event))
//          return TRUE;
//      }
// 
//    // Do some stuff
// 
//    return GTK_WIDGET_CLASS (gtk_foo_bar_parent_class)->key_press_event (widget, event);
// 
// } `
	func (t TextView) ImContextFilterKeypress(event gdk.EventClass) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GdkEvent // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkEvent)(unsafe.Pointer(event.Native()))

_cret = C.gtk_text_view_im_context_filter_keypress(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveMarkOnscreen moves a mark within the buffer so that it's located within
// the currently-visible text area.
	func (t TextView) MoveMarkOnscreen(mark TextMarkClass) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextMark // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

_cret = C.gtk_text_view_move_mark_onscreen(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveOverlay updates the position of a child.
// 
// See [method@Gtk.TextView.add_overlay].
	func (t TextView) MoveOverlay(child WidgetClass, xpos int, ypos int)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkWidget // out
var _arg2 C.int // out
var _arg3 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (C.int)(xpos)
_arg3 = (C.int)(ypos)

C.gtk_text_view_move_overlay(_arg0, _arg1, _arg2, _arg3)
}
	
	// MoveVisually: move the iterator a given number of characters visually,
// treating it as the strong cursor position.
// 
// If @count is positive, then the new strong cursor position will be @count
// positions to the right of the old cursor position. If @count is negative then
// the new strong cursor position will be @count positions to the left of the
// old cursor position.
// 
// In the presence of bi-directional text, the correspondence between logical
// and visual order will depend on the direction of the current run, and there
// may be jumps when the cursor is moved off of the end of a run.
	func (t TextView) MoveVisually(iter *TextIter, count int) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.int)(count)

_cret = C.gtk_text_view_move_visually(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PlaceCursorOnscreen moves the cursor to the currently visible region of the
// buffer.
	func (t TextView) PlaceCursorOnscreen() bool {
var _arg0 *C.GtkTextView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_text_view_place_cursor_onscreen(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Remove removes a child widget from @text_view.
	func (t TextView) Remove(child WidgetClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_text_view_remove(_arg0, _arg1)
}
	
	// ResetCursorBlink ensures that the cursor is shown.
// 
// This also resets the time that it will stay blinking (or visible, in case
// blinking is disabled).
// 
// This function should be called in response to user input (e.g. from derived
// classes that override the textview's event handlers).
	func (t TextView) ResetCursorBlink()  {
var _arg0 *C.GtkTextView // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

C.gtk_text_view_reset_cursor_blink(_arg0)
}
	
	// ResetImContext: reset the input method context of the text view if needed.
// 
// This can be necessary in the case where modifying the buffer would confuse
// on-going input method behavior.
	func (t TextView) ResetImContext()  {
var _arg0 *C.GtkTextView // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))

C.gtk_text_view_reset_im_context(_arg0)
}
	
	// ScrollMarkOnscreen scrolls @text_view the minimum distance such that @mark is
// contained within the visible area of the widget.
	func (t TextView) ScrollMarkOnscreen(mark TextMarkClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextMark // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

C.gtk_text_view_scroll_mark_onscreen(_arg0, _arg1)
}
	
	// ScrollToIter scrolls @text_view so that @iter is on the screen in the
// position indicated by @xalign and @yalign.
// 
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If @use_align is false, the text scrolls the minimal distance
// to get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size @within_margin.
// 
// Note that this function uses the currently-computed height of the lines in
// the text buffer. Line heights are computed in an idle handler; so this
// function may not have the desired effect if its called before the height
// computations. To avoid oddness, consider using
// [method@Gtk.TextView.scroll_to_mark] which saves a point to be scrolled to
// after line validation.
	func (t TextView) ScrollToIter(iter *TextIter, withinMargin float64, useAlign bool, xalign float64, yalign float64) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _arg2 C.double // out
var _arg3 C.gboolean // out
var _arg4 C.double // out
var _arg5 C.double // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.double)(withinMargin)
if useAlign { _arg3 = C.TRUE }
_arg4 = (C.double)(xalign)
_arg5 = (C.double)(yalign)

_cret = C.gtk_text_view_scroll_to_iter(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ScrollToMark scrolls @text_view so that @mark is on the screen in the
// position indicated by @xalign and @yalign.
// 
// An alignment of 0.0 indicates left or top, 1.0 indicates right or bottom, 0.5
// means center. If @use_align is false, the text scrolls the minimal distance
// to get the mark onscreen, possibly not scrolling at all. The effective screen
// for purposes of this function is reduced by a margin of size @within_margin.
	func (t TextView) ScrollToMark(mark TextMarkClass, withinMargin float64, useAlign bool, xalign float64, yalign float64)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextMark // out
var _arg2 C.double // out
var _arg3 C.gboolean // out
var _arg4 C.double // out
var _arg5 C.double // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
_arg2 = (C.double)(withinMargin)
if useAlign { _arg3 = C.TRUE }
_arg4 = (C.double)(xalign)
_arg5 = (C.double)(yalign)

C.gtk_text_view_scroll_to_mark(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// SetAcceptsTab sets the behavior of the text widget when the Tab key is
// pressed.
// 
// If @accepts_tab is true, a tab character is inserted. If @accepts_tab is
// false the keyboard focus is moved to the next widget in the focus chain.
	func (t TextView) SetAcceptsTab(acceptsTab bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if acceptsTab { _arg1 = C.TRUE }

C.gtk_text_view_set_accepts_tab(_arg0, _arg1)
}
	
	// SetBottomMargin sets the bottom margin for text in @text_view.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetBottomMargin(bottomMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(bottomMargin)

C.gtk_text_view_set_bottom_margin(_arg0, _arg1)
}
	
	// SetBuffer sets @buffer as the buffer being displayed by @text_view.
// 
// The previous buffer displayed by the text view is unreferenced, and a
// reference is added to @buffer. If you owned a reference to @buffer before
// passing it to this function, you must remove that reference yourself;
// `GtkTextView` will not adopt it.
	func (t TextView) SetBuffer(buffer TextBufferClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextBuffer // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

C.gtk_text_view_set_buffer(_arg0, _arg1)
}
	
	// SetCursorVisible toggles whether the insertion point should be displayed.
// 
// A buffer with no editable text probably shouldnt have a visible cursor, so
// you may want to turn the cursor off.
// 
// Note that this property may be overridden by the
// [property@GtkSettings:gtk-keynav-use-caret] setting.
	func (t TextView) SetCursorVisible(setting bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_view_set_cursor_visible(_arg0, _arg1)
}
	
	// SetEditable sets the default editability of the `GtkTextView`.
// 
// You can override this default setting with tags in the buffer, using the
// editable attribute of tags.
	func (t TextView) SetEditable(setting bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_text_view_set_editable(_arg0, _arg1)
}
	
	// SetExtraMenu sets a menu model to add when constructing the context menu for
// @text_view.
// 
// You can pass nil to remove a previously set extra menu.
	func (t TextView) SetExtraMenu(model gio.MenuModelClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GMenuModel // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GMenuModel)(unsafe.Pointer(model.Native()))

C.gtk_text_view_set_extra_menu(_arg0, _arg1)
}
	
	// SetGutter places @widget into the gutter specified by @win.
// 
// @win must be one of GTK_TEXT_WINDOW_LEFT, GTK_TEXT_WINDOW_RIGHT,
// GTK_TEXT_WINDOW_TOP, or GTK_TEXT_WINDOW_BOTTOM.
	func (t TextView) SetGutter(win TextWindowType, widget WidgetClass)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(win)
_arg2 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_text_view_set_gutter(_arg0, _arg1, _arg2)
}
	
	// SetIndent sets the default indentation for paragraphs in @text_view.
// 
// Tags in the buffer may override the default.
	func (t TextView) SetIndent(indent int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(indent)

C.gtk_text_view_set_indent(_arg0, _arg1)
}
	
	// SetInputHints sets the `input-hints` of the `GtkTextView`.
// 
// The `input-hints` allow input methods to fine-tune their behaviour.
	func (t TextView) SetInputHints(hints InputHints)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkInputHints // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkInputHints)(hints)

C.gtk_text_view_set_input_hints(_arg0, _arg1)
}
	
	// SetInputPurpose sets the `input-purpose` of the `GtkTextView`.
// 
// The `input-purpose` can be used by on-screen keyboards and other input
// methods to adjust their behaviour.
	func (t TextView) SetInputPurpose(purpose InputPurpose)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkInputPurpose // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkInputPurpose)(purpose)

C.gtk_text_view_set_input_purpose(_arg0, _arg1)
}
	
	// SetJustification sets the default justification of text in @text_view.
// 
// Tags in the views buffer may override the default.
	func (t TextView) SetJustification(justification Justification)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkJustification // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkJustification)(justification)

C.gtk_text_view_set_justification(_arg0, _arg1)
}
	
	// SetLeftMargin sets the default left margin for text in @text_view.
// 
// Tags in the buffer may override the default.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetLeftMargin(leftMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(leftMargin)

C.gtk_text_view_set_left_margin(_arg0, _arg1)
}
	
	// SetMonospace sets whether the `GtkTextView` should display text in monospace
// styling.
	func (t TextView) SetMonospace(monospace bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if monospace { _arg1 = C.TRUE }

C.gtk_text_view_set_monospace(_arg0, _arg1)
}
	
	// SetOverwrite changes the `GtkTextView` overwrite mode.
	func (t TextView) SetOverwrite(overwrite bool)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
if overwrite { _arg1 = C.TRUE }

C.gtk_text_view_set_overwrite(_arg0, _arg1)
}
	
	// SetPixelsAboveLines sets the default number of blank pixels above paragraphs
// in @text_view.
// 
// Tags in the buffer for @text_view may override the defaults.
	func (t TextView) SetPixelsAboveLines(pixelsAboveLines int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(pixelsAboveLines)

C.gtk_text_view_set_pixels_above_lines(_arg0, _arg1)
}
	
	// SetPixelsBelowLines sets the default number of pixels of blank space to put
// below paragraphs in @text_view.
// 
// May be overridden by tags applied to @text_views buffer.
	func (t TextView) SetPixelsBelowLines(pixelsBelowLines int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(pixelsBelowLines)

C.gtk_text_view_set_pixels_below_lines(_arg0, _arg1)
}
	
	// SetPixelsInsideWrap sets the default number of pixels of blank space to leave
// between display/wrapped lines within a paragraph.
// 
// May be overridden by tags in @text_views buffer.
	func (t TextView) SetPixelsInsideWrap(pixelsInsideWrap int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(pixelsInsideWrap)

C.gtk_text_view_set_pixels_inside_wrap(_arg0, _arg1)
}
	
	// SetRightMargin sets the default right margin for text in the text view.
// 
// Tags in the buffer may override the default.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetRightMargin(rightMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(rightMargin)

C.gtk_text_view_set_right_margin(_arg0, _arg1)
}
	
	// SetTabs sets the default tab stops for paragraphs in @text_view.
// 
// Tags in the buffer may override the default.
	func (t TextView) SetTabs(tabs *pango.TabArray)  {
var _arg0 *C.GtkTextView // out
var _arg1 *C.PangoTabArray // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

C.gtk_text_view_set_tabs(_arg0, _arg1)
}
	
	// SetTopMargin sets the top margin for text in @text_view.
// 
// Note that this function is confusingly named. In CSS terms, the value set
// here is padding.
	func (t TextView) SetTopMargin(topMargin int)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(topMargin)

C.gtk_text_view_set_top_margin(_arg0, _arg1)
}
	
	// SetWrapMode sets the line wrapping for the view.
	func (t TextView) SetWrapMode(wrapMode WrapMode)  {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkWrapMode // out

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkWrapMode)(wrapMode)

C.gtk_text_view_set_wrap_mode(_arg0, _arg1)
}
	
	// StartsDisplayLine determines whether @iter is at the start of a display line.
// 
// See [method@Gtk.TextView.forward_display_line] for an explanation of display
// lines vs. paragraphs.
	func (t TextView) StartsDisplayLine(iter *TextIter) bool {
var _arg0 *C.GtkTextView // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_text_view_starts_display_line(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// WindowToBufferCoords converts coordinates on the window identified by @win to
// buffer coordinates.
	func (t TextView) WindowToBufferCoords(win TextWindowType, windowX int, windowY int) (bufferX int, bufferY int) {
var _arg0 *C.GtkTextView // out
var _arg1 C.GtkTextWindowType // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 C.int // in
var _arg5 C.int // in

_arg0 = (*C.GtkTextView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTextWindowType)(win)
_arg2 = (C.int)(windowX)
_arg3 = (C.int)(windowY)

C.gtk_text_view_window_to_buffer_coords(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)

var _bufferX int // out
var _bufferY int // out

_bufferX = (int)(_arg4)
_bufferY = (int)(_arg5)

return _bufferX, _bufferY
}
	


	// ToggleButton: a `GtkToggleButton` is a button which remains pressed-in when
// clicked.
// 
// Clicking again will cause the toggle button to return to its normal state.
// 
// A toggle button is created by calling either [ctor@Gtk.ToggleButton.new] or
// [ctor@Gtk.ToggleButton.new_with_label]. If using the former, it is advisable
// to pack a widget, (such as a `GtkLabel` and/or a `GtkImage`), into the toggle
// buttons container. (See [class@Gtk.Button] for more information).
// 
// The state of a `GtkToggleButton` can be set specifically using
// [method@Gtk.ToggleButton.set_active], and retrieved using
// [method@Gtk.ToggleButton.get_active].
// 
// To simply switch the state of a toggle button, use
// [method@Gtk.ToggleButton.toggled].
// 
// 
// Grouping
// 
// Toggle buttons can be grouped together, to form mutually exclusive groups -
// only one of the buttons can be toggled at a time, and toggling another one
// will switch the currently toggled one off.
// 
// To add a `GtkToggleButton` to a group, use
// [method@Gtk.ToggleButton.set_group].
// 
// 
// CSS nodes
// 
// `GtkToggleButton` has a single CSS node with name button. To differentiate it
// from a plain `GtkButton`, it gets the .toggle style class.
// 
// Creating two `GtkToggleButton` widgets.
// 
// `c static void output_state (GtkToggleButton *source, gpointer user_data) {
// printf ("Active: d\n", gtk_toggle_button_get_active (source)); }
// 
// void make_toggles (void) { GtkWidget *window, *toggle1, *toggle2; GtkWidget
// *box; const char *text;
// 
//    window = gtk_window_new ();
//    box = gtk_box_new (GTK_ORIENTATION_VERTICAL, 12);
// 
//    text = "Hi, Im a toggle button.";
//    toggle1 = gtk_toggle_button_new_with_label (text);
// 
//    g_signal_connect (toggle1, "toggled",
//                      G_CALLBACK (output_state),
//                      NULL);
//    gtk_box_append (GTK_BOX (box), toggle1);
// 
//    text = "Hi, Im a toggle button.";
//    toggle2 = gtk_toggle_button_new_with_label (text);
//    g_signal_connect (toggle2, "toggled",
//                      G_CALLBACK (output_state),
//                      NULL);
//    gtk_box_append (GTK_BOX (box), toggle2);
// 
//    gtk_window_set_child (GTK_WINDOW (window), box);
//    gtk_widget_show (window);
// 
// } `
	type ToggleButton struct {
		Button
		Accessible
		Actionable
		Buildable
		ConstraintTarget
		
	}

	// ToggleButtonClass is an interface that the ToggleButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ToggleButtonClass interface {
		gextras.Objector
		_toggleButton()
	}

	func (ToggleButton) _toggleButton() {}

	
	func marshalToggleButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapToggleButton(obj), nil
	}
	

	
	// NewToggleButton creates a new toggle button.
// 
// A widget should be packed into the button, as in [ctor@Gtk.Button.new].
	func NewToggleButton() ToggleButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_toggle_button_new()


var _toggleButton ToggleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleButton = ToggleButton{
Button: Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleButton
}
	
	// NewToggleButtonWithLabel creates a new toggle button with a text label.
	func NewToggleButtonWithLabel(label string) ToggleButton {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_toggle_button_new_with_label(_arg1)


var _toggleButton ToggleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleButton = ToggleButton{
Button: Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleButton
}
	
	// NewToggleButtonWithMnemonic creates a new `GtkToggleButton` containing a
// label.
// 
// The label will be created using [ctor@Gtk.Label.new_with_mnemonic], so
// underscores in @label indicate the mnemonic for the button.
	func NewToggleButtonWithMnemonic(label string) ToggleButton {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(label))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_toggle_button_new_with_mnemonic(_arg1)


var _toggleButton ToggleButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_toggleButton = ToggleButton{
Button: Button{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Actionable: Actionable{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _toggleButton
}
	

	
	// Active queries a `GtkToggleButton` and returns its current state.
// 
// Returns true if the toggle button is pressed in and false if it is raised.
	func (t ToggleButton) Active() bool {
var _arg0 *C.GtkToggleButton // out
var _cret C.gboolean // in

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

_cret = C.gtk_toggle_button_get_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetActive sets the status of the toggle button.
// 
// Set to true if you want the `GtkToggleButton` to be pressed in, and false
// to raise it.
// 
// If the status of the button changes, this action causes the
// [signal@GtkToggleButton::toggled] signal to be emitted.
	func (t ToggleButton) SetActive(isActive bool)  {
var _arg0 *C.GtkToggleButton // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
if isActive { _arg1 = C.TRUE }

C.gtk_toggle_button_set_active(_arg0, _arg1)
}
	
	// SetGroup adds @self to the group of @group.
// 
// In a group of multiple toggle buttons, only one button can be active at a
// time.
// 
// Setting up groups in a cycle leads to undefined behavior.
// 
// Note that the same effect can be achieved via the [interface@Gtk.Actionable]
// API, by using the same action with parameter type and state type 's' for all
// buttons in the group, and giving each button its own target value.
	func (t ToggleButton) SetGroup(group ToggleButtonClass)  {
var _arg0 *C.GtkToggleButton // out
var _arg1 *C.GtkToggleButton // out

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkToggleButton)(unsafe.Pointer(group.Native()))

C.gtk_toggle_button_set_group(_arg0, _arg1)
}
	
	// Toggled emits the ::toggled signal on the `GtkToggleButton`.
// 
// There is no good reason for an application ever to call this function.
	func (t ToggleButton) Toggled()  {
var _arg0 *C.GtkToggleButton // out

_arg0 = (*C.GtkToggleButton)(unsafe.Pointer(t.Native()))

C.gtk_toggle_button_toggled(_arg0)
}
	


	// Tooltip: `GtkTooltip` is an object representing a widget tooltip.
// 
// Basic tooltips can be realized simply by using
// [method@Gtk.Widget.set_tooltip_text] or
// [method@Gtk.Widget.set_tooltip_markup] without any explicit tooltip object.
// 
// When you need a tooltip with a little more fancy contents, like adding an
// image, or you want the tooltip to have different contents per `GtkTreeView`
// row or cell, you will have to do a little more work:
// 
// - Set the [property@Gtk.Widget:has-tooltip] property to true. This will make
// GTK monitor the widget for motion and related events which are needed to
// determine when and where to show a tooltip.
// 
// - Connect to the [signal@Gtk.Widget::query-tooltip] signal. This signal will
// be emitted when a tooltip is supposed to be shown. One of the arguments
// passed to the signal handler is a `GtkTooltip` object. This is the object
// that we are about to display as a tooltip, and can be manipulated in your
// callback using functions like [method@Gtk.Tooltip.set_icon]. There are
// functions for setting the tooltips markup, setting an image from a named
// icon, or even putting in a custom widget.
// 
// - Return true from your ::query-tooltip handler. This causes the tooltip to
// be show. If you return false, it will not be shown.
	type Tooltip struct {
		**externglib.Object
		
	}

	// TooltipClass is an interface that the Tooltip class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TooltipClass interface {
		gextras.Objector
		_tooltip()
	}

	func (Tooltip) _tooltip() {}

	
	func marshalTooltip(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTooltip(obj), nil
	}
	

	

	
	// SetCustom replaces the widget packed into the tooltip with @custom_widget.
// @custom_widget does not get destroyed when the tooltip goes away. By default
// a box with a Image and Label is embedded in the tooltip, which can be
// configured using gtk_tooltip_set_markup() and gtk_tooltip_set_icon().
	func (t Tooltip) SetCustom(customWidget WidgetClass)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(customWidget.Native()))

C.gtk_tooltip_set_custom(_arg0, _arg1)
}
	
	// SetIcon sets the icon of the tooltip (which is in front of the text) to be
// @paintable. If @paintable is nil, the image will be hidden.
	func (t Tooltip) SetIcon(paintable gdk.Paintable)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GdkPaintable // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

C.gtk_tooltip_set_icon(_arg0, _arg1)
}
	
	// SetIconFromGIcon sets the icon of the tooltip (which is in front of the text)
// to be the icon indicated by @gicon with the size indicated by @size. If
// @gicon is nil, the image will be hidden.
	func (t Tooltip) SetIconFromGIcon(gicon gio.Icon)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GIcon // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GIcon)(unsafe.Pointer(gicon.Native()))

C.gtk_tooltip_set_icon_from_gicon(_arg0, _arg1)
}
	
	// SetIconFromIconName sets the icon of the tooltip (which is in front of the
// text) to be the icon indicated by @icon_name with the size indicated by
// @size. If @icon_name is nil, the image will be hidden.
	func (t Tooltip) SetIconFromIconName(iconName string)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.char // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.char)(C.CString(iconName))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tooltip_set_icon_from_icon_name(_arg0, _arg1)
}
	
	// SetMarkup sets the text of the tooltip to be @markup.
// 
// The string must be marked up with Pango markup. If @markup is nil, the label
// will be hidden.
	func (t Tooltip) SetMarkup(markup string)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.char // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.char)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tooltip_set_markup(_arg0, _arg1)
}
	
	// SetText sets the text of the tooltip to be @text.
// 
// If @text is nil, the label will be hidden. See also
// [method@Gtk.Tooltip.set_markup].
	func (t Tooltip) SetText(text string)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.char // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tooltip_set_text(_arg0, _arg1)
}
	
	// SetTipArea sets the area of the widget, where the contents of this tooltip
// apply, to be @rect (in widget coordinates). This is especially useful for
// properly setting tooltips on TreeView rows and cells, IconViews, etc.
// 
// For setting tooltips on TreeView, please refer to the convenience functions
// for this: gtk_tree_view_set_tooltip_row() and
// gtk_tree_view_set_tooltip_cell().
	func (t Tooltip) SetTipArea(rect *gdk.Rectangle)  {
var _arg0 *C.GtkTooltip // out
var _arg1 *C.GdkRectangle // out

_arg0 = (*C.GtkTooltip)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkRectangle)(unsafe.Pointer(rect.Native()))

C.gtk_tooltip_set_tip_area(_arg0, _arg1)
}
	


	// TreeExpander: `GtkTreeExpander` is a widget that provides an expander for a
// list.
// 
// It is typically placed as a bottommost child into a `GtkListView` to allow
// users to expand and collapse children in a list with a
// [class@Gtk.TreeListModel]. `GtkTreeExpander` provides the common UI elements,
// gestures and keybindings for this purpose.
// 
// On top of this, the "listitem.expand", "listitem.collapse" and
// "listitem.toggle-expand" actions are provided to allow adding custom UI for
// managing expanded state.
// 
// The `GtkTreeListModel` must be set to not be passthrough. Then it will
// provide [class@Gtk.TreeListRow] items which can be set via
// [method@Gtk.TreeExpander.set_list_row] on the expander. The expander will
// then watch that row item automatically. [method@Gtk.TreeExpander.set_child]
// sets the widget that displays the actual row contents.
// 
// 
// CSS nodes
// 
// ` treeexpander  [indent]*  [expander]  <child> `
// 
// `GtkTreeExpander` has zero or one CSS nodes with the name "expander" that
// should display the expander icon. The node will be `:checked` when it is
// expanded. If the node is not expandable, an "indent" node will be displayed
// instead.
// 
// For every level of depth, another "indent" node is prepended.
// 
// 
// Accessibility
// 
// `GtkTreeExpander` uses the GTK_ACCESSIBLE_ROLE_GROUP role. The expander icon
// is represented as a GTK_ACCESSIBLE_ROLE_BUTTON, labelled by the expander's
// child, and toggling it will change the GTK_ACCESSIBLE_STATE_EXPANDED state.
	type TreeExpander struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// TreeExpanderClass is an interface that the TreeExpander class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeExpanderClass interface {
		gextras.Objector
		_treeExpander()
	}

	func (TreeExpander) _treeExpander() {}

	
	func marshalTreeExpander(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeExpander(obj), nil
	}
	

	
	// NewTreeExpander creates a new `GtkTreeExpander`
	func NewTreeExpander() TreeExpander {
var _cret *C.GtkWidget // in

_cret = C.gtk_tree_expander_new()


var _treeExpander TreeExpander // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeExpander = TreeExpander{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeExpander
}
	

	
	// Child gets the child widget displayed by @self.
	func (s TreeExpander) Child() Widget {
var _arg0 *C.GtkTreeExpander // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_expander_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Item forwards the item set on the `GtkTreeListRow` that @self is managing.
// 
// This call is essentially equivalent to calling:
// 
// `c gtk_tree_list_row_get_item (gtk_tree_expander_get_list_row (@self)); `
	func (s TreeExpander) Item() **externglib.Object {
var _arg0 *C.GtkTreeExpander // out
var _cret C.gpointer // in

_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_expander_get_item(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// ListRow gets the list row managed by @self.
	func (s TreeExpander) ListRow() TreeListRow {
var _arg0 *C.GtkTreeExpander // out
var _cret *C.GtkTreeListRow // in

_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_expander_get_list_row(_arg0)


var _treeListRow TreeListRow // out

_treeListRow = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeListRow)

return _treeListRow
}
	
	// SetChild sets the content widget to display.
	func (s TreeExpander) SetChild(child WidgetClass)  {
var _arg0 *C.GtkTreeExpander // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_tree_expander_set_child(_arg0, _arg1)
}
	
	// SetListRow sets the tree list row that this expander should manage.
	func (s TreeExpander) SetListRow(listRow TreeListRowClass)  {
var _arg0 *C.GtkTreeExpander // out
var _arg1 *C.GtkTreeListRow // out

_arg0 = (*C.GtkTreeExpander)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeListRow)(unsafe.Pointer(listRow.Native()))

C.gtk_tree_expander_set_list_row(_arg0, _arg1)
}
	


	// TreeListModel: `GtkTreeListModel` is a list model that can create child
// models on demand.
	type TreeListModel struct {
		**externglib.Object
		gio.ListModel
		
	}

	// TreeListModelClass is an interface that the TreeListModel class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeListModelClass interface {
		gextras.Objector
		_treeListModel()
	}

	func (TreeListModel) _treeListModel() {}

	
	func marshalTreeListModel(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeListModel(obj), nil
	}
	

	

	
	// Autoexpand gets whether the model is set to automatically expand new rows
// that get added.
// 
// This can be either rows added by changes to the underlying models or via
// [method@Gtk.TreeListRow.set_expanded].
	func (s TreeListModel) Autoexpand() bool {
var _arg0 *C.GtkTreeListModel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_model_get_autoexpand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildRow gets the row item corresponding to the child at index @position for
// @self's root model.
// 
// If @position is greater than the number of children in the root model, nil is
// returned.
// 
// Do not confuse this function with [method@Gtk.TreeListModel.get_row].
	func (s TreeListModel) ChildRow(position uint) TreeListRow {
var _arg0 *C.GtkTreeListModel // out
var _arg1 C.guint // out
var _cret *C.GtkTreeListRow // in

_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

_cret = C.gtk_tree_list_model_get_child_row(_arg0, _arg1)


var _treeListRow TreeListRow // out

_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

return _treeListRow
}
	
	// Model gets the root model that @self was created with.
	func (s TreeListModel) Model() gio.ListModel {
var _arg0 *C.GtkTreeListModel // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_model_get_model(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Passthrough gets whether the model is passing through original row items.
// 
// If this function returns false, the `GListModel` functions for @self return
// custom `GtkTreeListRow` objects. You need to call
// [method@Gtk.TreeListRow.get_item] on these objects to get the original item.
// 
// If true, the values of the child models are passed through in their original
// state. You then need to call [method@Gtk.TreeListModel.get_row] to get the
// custom `GtkTreeListRow`s.
	func (s TreeListModel) Passthrough() bool {
var _arg0 *C.GtkTreeListModel // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_model_get_passthrough(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Row gets the row object for the given row.
// 
// If @position is greater than the number of items in @self, nil is returned.
// 
// The row object can be used to expand and collapse rows as well as to inspect
// its position in the tree. See its documentation for details.
// 
// This row object is persistent and will refer to the current item as long as
// the row is present in @self, independent of other rows being added or
// removed.
// 
// If @self is set to not be passthrough, this function is equivalent to calling
// g_list_model_get_item().
// 
// Do not confuse this function with [method@Gtk.TreeListModel.get_child_row].
	func (s TreeListModel) Row(position uint) TreeListRow {
var _arg0 *C.GtkTreeListModel // out
var _arg1 C.guint // out
var _cret *C.GtkTreeListRow // in

_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

_cret = C.gtk_tree_list_model_get_row(_arg0, _arg1)


var _treeListRow TreeListRow // out

_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

return _treeListRow
}
	
	// SetAutoexpand sets whether the model should autoexpand.
// 
// If set to true, the model will recursively expand all rows that get added to
// the model. This can be either rows added by changes to the underlying models
// or via [method@Gtk.TreeListRow.set_expanded].
	func (s TreeListModel) SetAutoexpand(autoexpand bool)  {
var _arg0 *C.GtkTreeListModel // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeListModel)(unsafe.Pointer(s.Native()))
if autoexpand { _arg1 = C.TRUE }

C.gtk_tree_list_model_set_autoexpand(_arg0, _arg1)
}
	


	// TreeListRow: `GtkTreeListRow` is used by `GtkTreeListModel` to represent
// items.
// 
// It allows navigating the model as a tree and modify the state of rows.
// 
// `GtkTreeListRow` instances are created by a `GtkTreeListModel` only when the
// [property@Gtk.TreeListModel:passthrough] property is not set.
// 
// There are various support objects that can make use of `GtkTreeListRow`
// objects, such as the [class@Gtk.TreeExpander] widget that allows displaying
// an icon to expand or collapse a row or [class@Gtk.TreeListRowSorter] that
// makes it possible to sort trees properly.
	type TreeListRow struct {
		**externglib.Object
		
	}

	// TreeListRowClass is an interface that the TreeListRow class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeListRowClass interface {
		gextras.Objector
		_treeListRow()
	}

	func (TreeListRow) _treeListRow() {}

	
	func marshalTreeListRow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeListRow(obj), nil
	}
	

	

	
	// ChildRow: if @self is not expanded or @position is greater than the number of
// children, nil is returned.
	func (s TreeListRow) ChildRow(position uint) TreeListRow {
var _arg0 *C.GtkTreeListRow // out
var _arg1 C.guint // out
var _cret *C.GtkTreeListRow // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)

_cret = C.gtk_tree_list_row_get_child_row(_arg0, _arg1)


var _treeListRow TreeListRow // out

_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

return _treeListRow
}
	
	// Children: if the row is expanded, gets the model holding the children of
// @self.
// 
// This model is the model created by the
// [callback@Gtk.TreeListModelCreateModelFunc] and contains the original items,
// no matter what value [property@Gtk.TreeListModel:passthrough] is set to.
	func (s TreeListRow) Children() gio.ListModel {
var _arg0 *C.GtkTreeListRow // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_get_children(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Depth gets the depth of this row.
// 
// Rows that correspond to items in the root model have a depth of zero, rows
// corresponding to items of models of direct children of the root model have a
// depth of 1 and so on.
// 
// The depth of a row never changes until the row is destroyed.
	func (s TreeListRow) Depth() uint {
var _arg0 *C.GtkTreeListRow // out
var _cret C.guint // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_get_depth(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Expanded gets if a row is currently expanded.
	func (s TreeListRow) Expanded() bool {
var _arg0 *C.GtkTreeListRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_get_expanded(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Item gets the item corresponding to this row,
// 
// The value returned by this function never changes until the row is destroyed.
	func (s TreeListRow) Item() **externglib.Object {
var _arg0 *C.GtkTreeListRow // out
var _cret C.gpointer // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_get_item(_arg0)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// Parent gets the row representing the parent for @self.
// 
// That is the row that would need to be collapsed to make this row disappear.
// 
// If @self is a row corresponding to the root model, nil is returned.
// 
// The value returned by this function never changes until the row is destroyed.
	func (s TreeListRow) Parent() TreeListRow {
var _arg0 *C.GtkTreeListRow // out
var _cret *C.GtkTreeListRow // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_get_parent(_arg0)


var _treeListRow TreeListRow // out

_treeListRow = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeListRow)

return _treeListRow
}
	
	// Position returns the position in the `GtkTreeListModel` that @self occupies
// at the moment.
	func (s TreeListRow) Position() uint {
var _arg0 *C.GtkTreeListRow // out
var _cret C.guint // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_get_position(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// IsExpandable checks if a row can be expanded.
// 
// This does not mean that the row is actually expanded, this can be checked
// with [method@Gtk.TreeListRow.get_expanded].
// 
// If a row is expandable never changes until the row is destroyed.
	func (s TreeListRow) IsExpandable() bool {
var _arg0 *C.GtkTreeListRow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_is_expandable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetExpanded expands or collapses a row.
// 
// If a row is expanded, the model of calling the
// [callback@Gtk.TreeListModelCreateModelFunc] for the row's item will be
// inserted after this row. If a row is collapsed, those items will be removed
// from the model.
// 
// If the row is not expandable, this function does nothing.
	func (s TreeListRow) SetExpanded(expanded bool)  {
var _arg0 *C.GtkTreeListRow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeListRow)(unsafe.Pointer(s.Native()))
if expanded { _arg1 = C.TRUE }

C.gtk_tree_list_row_set_expanded(_arg0, _arg1)
}
	


	// TreeListRowSorter: `GtkTreeListRowSorter` is a special-purpose sorter that
// will apply a given sorter to the levels in a tree.
// 
// Here is an example for setting up a column view with a tree model and a
// `GtkTreeListSorter`:
// 
// `c column_sorter = gtk_column_view_get_sorter (view); sorter =
// gtk_tree_list_row_sorter_new (g_object_ref (column_sorter)); sort_model =
// gtk_sort_list_model_new (tree_model, sorter); selection =
// gtk_single_selection_new (sort_model); gtk_column_view_set_model (view,
// G_LIST_MODEL (selection)); `
	type TreeListRowSorter struct {
		Sorter
		
	}

	// TreeListRowSorterClass is an interface that the TreeListRowSorter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeListRowSorterClass interface {
		gextras.Objector
		_treeListRowSorter()
	}

	func (TreeListRowSorter) _treeListRowSorter() {}

	
	func marshalTreeListRowSorter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeListRowSorter(obj), nil
	}
	

	
	// NewTreeListRowSorter: create a special-purpose sorter that applies the
// sorting of @sorter to the levels of a `GtkTreeListModel`.
// 
// Note that this sorter relies on [property@Gtk.TreeListModel:passthrough]
// being false as it can only sort [class@Gtk.TreeListRow]s.
	func NewTreeListRowSorter(sorter SorterClass) TreeListRowSorter {
var _arg1 *C.GtkSorter // out
var _cret *C.GtkTreeListRowSorter // in

_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

_cret = C.gtk_tree_list_row_sorter_new(_arg1)


var _treeListRowSorter TreeListRowSorter // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_treeListRowSorter = TreeListRowSorter{
Sorter: Sorter{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeListRowSorter
}
	

	
	// GetSorter returns the sorter used by @self.
	func (s TreeListRowSorter) GetSorter() Sorter {
var _arg0 *C.GtkTreeListRowSorter // out
var _cret *C.GtkSorter // in

_arg0 = (*C.GtkTreeListRowSorter)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_list_row_sorter_get_sorter(_arg0)


var _sorter Sorter // out

_sorter = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Sorter)

return _sorter
}
	
	// SetSorter sets the sorter to use for items with the same parent.
// 
// This sorter will be passed the [property@Gtk.TreeListRow:item] of the tree
// list rows passed to @self.
	func (s TreeListRowSorter) SetSorter(sorter SorterClass)  {
var _arg0 *C.GtkTreeListRowSorter // out
var _arg1 *C.GtkSorter // out

_arg0 = (*C.GtkTreeListRowSorter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkSorter)(unsafe.Pointer(sorter.Native()))

C.gtk_tree_list_row_sorter_set_sorter(_arg0, _arg1)
}
	


	// TreeModelFilter: a GtkTreeModel which hides parts of an underlying tree model
// 
// A TreeModelFilter is a tree model which wraps another tree model, and can do
// the following things:
// 
// - Filter specific rows, based on data from a visible column, a column
// storing booleans indicating whether the row should be filtered or not, or
// based on the return value of a visible function, which gets a model, iter
// and user_data and returns a boolean indicating whether the row should be
// filtered or not.
// 
// - Modify the appearance of the model, using a modify function. This is
// extremely powerful and allows for just changing some values and also for
// creating a completely different model based on the given child model.
// 
// - Set a different root node, also known as a virtual root. You can pass in
// a TreePath indicating the root node for the filter at construction time.
// 
// The basic API is similar to TreeModelSort. For an example on its usage, see
// the section on TreeModelSort.
// 
// When using TreeModelFilter, it is important to realize that TreeModelFilter
// maintains an internal cache of all nodes which are visible in its clients.
// The cache is likely to be a subtree of the tree exposed by the child model.
// TreeModelFilter will not cache the entire child model when unnecessary to not
// compromise the caching mechanism that is exposed by the reference counting
// scheme. If the child model implements reference counting, unnecessary signals
// may not be emitted because of reference counting rule 3, see the TreeModel
// documentation. (Note that e.g. TreeStore does not implement reference
// counting and will always emit all signals, even when the receiving node is
// not visible).
// 
// Because of this, limitations for possible visible functions do apply. In
// general, visible functions should only use data or properties from the node
// for which the visibility state must be determined, its siblings or its
// parents. Usually, having a dependency on the state of any child node is not
// possible, unless references are taken on these explicitly. When no such
// reference exists, no signals may be received for these child nodes (see
// reference counting rule number 3 in the TreeModel section).
// 
// Determining the visibility state of a given node based on the state of its
// child nodes is a frequently occurring use case. Therefore, TreeModelFilter
// explicitly supports this. For example, when a node does not have any
// children, you might not want the node to be visible. As soon as the first row
// is added to the nodes child level (or the last row removed), the nodes
// visibility should be updated.
// 
// This introduces a dependency from the node on its child nodes. In order to
// accommodate this, TreeModelFilter must make sure the necessary signals are
// received from the child model. This is achieved by building, for all nodes
// which are exposed as visible nodes to TreeModelFilter's clients, the child
// level (if any) and take a reference on the first node in this level.
// Furthermore, for every row-inserted, row-changed or row-deleted signal (also
// these which were not handled because the node was not cached),
// TreeModelFilter will check if the visibility state of any parent node has
// changed.
// 
// Beware, however, that this explicit support is limited to these two cases.
// For example, if you want a node to be visible only if two nodes in a childs
// child level (2 levels deeper) are visible, you are on your own. In this case,
// either rely on TreeStore to emit all signals because it does not implement
// reference counting, or for models that do implement reference counting,
// obtain references on these child levels yourself.
	type TreeModelFilter struct {
		**externglib.Object
		TreeDragSource
		TreeModel
		
	}

	// TreeModelFilterClass is an interface that the TreeModelFilter class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeModelFilterClass interface {
		gextras.Objector
		_treeModelFilter()
	}

	func (TreeModelFilter) _treeModelFilter() {}

	
	func marshalTreeModelFilter(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeModelFilter(obj), nil
	}
	

	

	
	// ClearCache: this function should almost never be called. It clears the
// @filter of any cached iterators that havent been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// filtered is static (and doesnt change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
	func (f TreeModelFilter) ClearCache()  {
var _arg0 *C.GtkTreeModelFilter // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

C.gtk_tree_model_filter_clear_cache(_arg0)
}
	
	// ConvertChildIterToIter sets @filter_iter to point to the row in @filter that
// corresponds to the row pointed at by @child_iter. If @filter_iter was not
// set, false is returned.
	func (f TreeModelFilter) ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModelFilter // out
var _filterIter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

_cret = C.gtk_tree_model_filter_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_filterIter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _filterIter, _ok
}
	
	// ConvertChildPathToPath converts @child_path to a path relative to @filter.
// That is, @child_path points to a path in the child model. The rerturned path
// will point to the same row in the filtered model. If @child_path isnt a
// valid path on the child model or points to a row which is not visible in
// @filter, then nil is returned.
	func (f TreeModelFilter) ConvertChildPathToPath(childPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelFilter // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

_cret = C.gtk_tree_model_filter_convert_child_path_to_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @filter_iter.
	func (f TreeModelFilter) ConvertIterToChildIter(filterIter *TreeIter) TreeIter {
var _arg0 *C.GtkTreeModelFilter // out
var _childIter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(filterIter.Native()))

C.gtk_tree_model_filter_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)





return _childIter
}
	
	// ConvertPathToChildPath converts @filter_path to a path on the child model of
// @filter. That is, @filter_path points to a location in @filter. The returned
// path will point to the same location in the model not being filtered. If
// @filter_path does not point to a location in the child model, nil is
// returned.
	func (f TreeModelFilter) ConvertPathToChildPath(filterPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelFilter // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(filterPath.Native()))

_cret = C.gtk_tree_model_filter_convert_path_to_child_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Model returns a pointer to the child model of @filter.
	func (f TreeModelFilter) Model() TreeModel {
var _arg0 *C.GtkTreeModelFilter // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

_cret = C.gtk_tree_model_filter_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// Refilter emits ::row_changed for each row in the child model, which causes
// the filter to re-evaluate whether a row is visible or not.
	func (f TreeModelFilter) Refilter()  {
var _arg0 *C.GtkTreeModelFilter // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))

C.gtk_tree_model_filter_refilter(_arg0)
}
	
	// SetVisibleColumn sets @column of the child_model to be the column where
// @filter should look for visibility information. @columns should be a column
// of type G_TYPE_BOOLEAN, where true means that a row is visible, and false if
// not.
// 
// Note that gtk_tree_model_filter_set_visible_func() or
// gtk_tree_model_filter_set_visible_column() can only be called once for a
// given filter model.
	func (f TreeModelFilter) SetVisibleColumn(column int)  {
var _arg0 *C.GtkTreeModelFilter // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeModelFilter)(unsafe.Pointer(f.Native()))
_arg1 = (C.int)(column)

C.gtk_tree_model_filter_set_visible_column(_arg0, _arg1)
}
	


	// TreeModelSort: a GtkTreeModel which makes an underlying tree model sortable
// 
// The TreeModelSort is a model which implements the TreeSortable interface. It
// does not hold any data itself, but rather is created with a child model and
// proxies its data. It has identical column types to this child model, and the
// changes in the child are propagated. The primary purpose of this model is to
// provide a way to sort a different model without modifying it. Note that the
// sort function used by TreeModelSort is not guaranteed to be stable.
// 
// The use of this is best demonstrated through an example. In the following
// sample code we create two TreeView widgets each with a view of the same data.
// As the model is wrapped here by a TreeModelSort, the two TreeViews can each
// sort their view of the data without affecting the other. By contrast, if we
// simply put the same model in each widget, then sorting the first would sort
// the second.
// 
// Using a TreeModelSort
// 
//    void
//    selection_changed (GtkTreeSelection *selection, gpointer data)
//    {
//      GtkTreeModel *sort_model = NULL;
//      GtkTreeModel *child_model;
//      GtkTreeIter sort_iter;
//      GtkTreeIter child_iter;
//      char *some_data = NULL;
//      char *modified_data;
// 
//      // Get the current selected row and the model.
//      if (! gtk_tree_selection_get_selected (selection,
//                                             &sort_model,
//                                             &sort_iter))
//        return;
// 
//      // Look up the current value on the selected row and get
//      // a new value to change it to.
//      gtk_tree_model_get (GTK_TREE_MODEL (sort_model), &sort_iter,
//                          COLUMN_1, &some_data,
//                          -1);
// 
//      modified_data = change_the_data (some_data);
//      g_free (some_data);
// 
//      // Get an iterator on the child model, instead of the sort model.
//      gtk_tree_model_sort_convert_iter_to_child_iter (GTK_TREE_MODEL_SORT (sort_model),
//                                                      &child_iter,
//                                                      &sort_iter);
// 
//      // Get the child model and change the value of the row. In this
//      // example, the child model is a GtkListStore. It could be any other
//      // type of model, though.
//      child_model = gtk_tree_model_sort_get_model (GTK_TREE_MODEL_SORT (sort_model));
//      gtk_list_store_set (GTK_LIST_STORE (child_model), &child_iter,
//                          COLUMN_1, &modified_data,
//                          -1);
//      g_free (modified_data);
//    }
	type TreeModelSort struct {
		**externglib.Object
		TreeDragSource
		TreeModel
		TreeSortable
		
	}

	// TreeModelSortClass is an interface that the TreeModelSort class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeModelSortClass interface {
		gextras.Objector
		_treeModelSort()
	}

	func (TreeModelSort) _treeModelSort() {}

	
	func marshalTreeModelSort(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeModelSort(obj), nil
	}
	

	
	// NewTreeModelSortWithModel creates a new TreeModelSort, with @child_model as
// the child model.
	func NewTreeModelSortWithModel(childModel TreeModel) TreeModelSort {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkTreeModel // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(childModel.Native()))

_cret = C.gtk_tree_model_sort_new_with_model(_arg1)


var _treeModelSort TreeModelSort // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_treeModelSort = TreeModelSort{
Object: &externglib.Object{externglib.ToGObject(obj)},
TreeDragSource: TreeDragSource{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
TreeModel: TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
TreeSortable: TreeSortable{
TreeModel: TreeModel{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
}
}

return _treeModelSort
}
	

	
	// ClearCache: this function should almost never be called. It clears the
// @tree_model_sort of any cached iterators that havent been reffed with
// gtk_tree_model_ref_node(). This might be useful if the child model being
// sorted is static (and doesnt change often) and there has been a lot of
// unreffed access to nodes. As a side effect of this function, all unreffed
// iters will be invalid.
	func (t TreeModelSort) ClearCache()  {
var _arg0 *C.GtkTreeModelSort // out

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

C.gtk_tree_model_sort_clear_cache(_arg0)
}
	
	// ConvertChildIterToIter sets @sort_iter to point to the row in
// @tree_model_sort that corresponds to the row pointed at by @child_iter. If
// @sort_iter was not set, false is returned. Note: a boolean is only returned
// since 2.14.
	func (t TreeModelSort) ConvertChildIterToIter(childIter *TreeIter) (TreeIter, bool) {
var _arg0 *C.GtkTreeModelSort // out
var _sortIter TreeIter
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(childIter.Native()))

_cret = C.gtk_tree_model_sort_convert_child_iter_to_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_sortIter)), _arg2)



var _ok bool // out


if _cret != 0 { _ok = true }

return _sortIter, _ok
}
	
	// ConvertChildPathToPath converts @child_path to a path relative to
// @tree_model_sort. That is, @child_path points to a path in the child model.
// The returned path will point to the same row in the sorted model. If
// @child_path isnt a valid path on the child model, then nil is returned.
	func (t TreeModelSort) ConvertChildPathToPath(childPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelSort // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(childPath.Native()))

_cret = C.gtk_tree_model_sort_convert_child_path_to_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// ConvertIterToChildIter sets @child_iter to point to the row pointed to by
// @sorted_iter.
	func (t TreeModelSort) ConvertIterToChildIter(sortedIter *TreeIter) TreeIter {
var _arg0 *C.GtkTreeModelSort // out
var _childIter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(sortedIter.Native()))

C.gtk_tree_model_sort_convert_iter_to_child_iter(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_childIter)), _arg2)





return _childIter
}
	
	// ConvertPathToChildPath converts @sorted_path to a path on the child model of
// @tree_model_sort. That is, @sorted_path points to a location in
// @tree_model_sort. The returned path will point to the same location in the
// model not being sorted. If @sorted_path does not point to a location in the
// child model, nil is returned.
	func (t TreeModelSort) ConvertPathToChildPath(sortedPath *TreePath) *TreePath {
var _arg0 *C.GtkTreeModelSort // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(sortedPath.Native()))

_cret = C.gtk_tree_model_sort_convert_path_to_child_path(_arg0, _arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Model returns the model the TreeModelSort is sorting.
	func (t TreeModelSort) Model() TreeModel {
var _arg0 *C.GtkTreeModelSort // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_model_sort_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// IterIsValid: > This function is slow. Only use it for debugging and/or
// testing > purposes.
// 
// Checks if the given iter is a valid iter for this TreeModelSort.
	func (t TreeModelSort) IterIsValid(iter *TreeIter) bool {
var _arg0 *C.GtkTreeModelSort // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_model_sort_iter_is_valid(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ResetDefaultSortFunc: this resets the default sort function to be in the
// unsorted state. That is, it is in the same order as the child model. It
// will re-sort the model to be in the same order as the child model only if the
// TreeModelSort is in unsorted state.
	func (t TreeModelSort) ResetDefaultSortFunc()  {
var _arg0 *C.GtkTreeModelSort // out

_arg0 = (*C.GtkTreeModelSort)(unsafe.Pointer(t.Native()))

C.gtk_tree_model_sort_reset_default_sort_func(_arg0)
}
	


	// TreeSelection: the selection object for GtkTreeView
// 
// The TreeSelection object is a helper object to manage the selection for a
// TreeView widget. The TreeSelection object is automatically created when a new
// TreeView widget is created, and cannot exist independently of this widget.
// The primary reason the TreeSelection objects exists is for cleanliness of
// code and API. That is, there is no conceptual reason all these functions
// could not be methods on the TreeView widget instead of a separate function.
// 
// The TreeSelection object is gotten from a TreeView by calling
// gtk_tree_view_get_selection(). It can be manipulated to check the selection
// status of the tree, as well as select and deselect individual rows. Selection
// is done completely view side. As a result, multiple views of the same model
// can have completely different selections. Additionally, you cannot change the
// selection of a row on the model that is not currently displayed by the view
// without expanding its parents first.
// 
// One of the important things to remember when monitoring the selection of a
// view is that the TreeSelection::changed signal is mostly a hint. That is, it
// may only emit one signal when a range of rows is selected. Additionally, it
// may on occasion emit a TreeSelection::changed signal when nothing has
// happened (mostly as a result of programmers calling select_row on an already
// selected row).
	type TreeSelection struct {
		**externglib.Object
		
	}

	// TreeSelectionClass is an interface that the TreeSelection class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeSelectionClass interface {
		gextras.Objector
		_treeSelection()
	}

	func (TreeSelection) _treeSelection() {}

	
	func marshalTreeSelection(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeSelection(obj), nil
	}
	

	

	
	// CountSelectedRows returns the number of rows that have been selected in
// @tree.
	func (s TreeSelection) CountSelectedRows() int {
var _arg0 *C.GtkTreeSelection // out
var _cret C.int // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_count_selected_rows(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Mode gets the selection mode for @selection. See
// gtk_tree_selection_set_mode().
	func (s TreeSelection) Mode() SelectionMode {
var _arg0 *C.GtkTreeSelection // out
var _cret C.GtkSelectionMode // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_get_mode(_arg0)


var _selectionMode SelectionMode // out

_selectionMode = SelectionMode(_cret)

return _selectionMode
}
	
	// Selected sets @iter to the currently selected node if @selection is set to
// K_SELECTION_SINGLE or K_SELECTION_BROWSE. @iter may be NULL if you just want
// to test if @selection has any selected nodes. @model is filled with the
// current model as a convenience. This function will not work if you use
// @selection is K_SELECTION_MULTIPLE.
	func (s TreeSelection) Selected() (TreeModel, TreeIter, bool) {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeModel // in
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_get_selected(_arg0, &_arg1, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))


var _model TreeModel // out

var _ok bool // out

_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg1))).(TreeModel)

if _cret != 0 { _ok = true }

return _model, _iter, _ok
}
	
	// TreeView returns the tree view associated with @selection.
	func (s TreeSelection) TreeView() TreeView {
var _arg0 *C.GtkTreeSelection // out
var _cret *C.GtkTreeView // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_tree_selection_get_tree_view(_arg0)


var _treeView TreeView // out

_treeView = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeView)

return _treeView
}
	
	// IterIsSelected returns true if the row at @iter is currently selected.
	func (s TreeSelection) IterIsSelected(iter *TreeIter) bool {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_selection_iter_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// PathIsSelected returns true if the row pointed to by @path is currently
// selected. If @path does not point to a valid location, false is returned
	func (s TreeSelection) PathIsSelected(path *TreePath) bool {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_selection_path_is_selected(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SelectAll selects all the nodes. @selection must be set to
// K_SELECTION_MULTIPLE mode.
	func (s TreeSelection) SelectAll()  {
var _arg0 *C.GtkTreeSelection // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

C.gtk_tree_selection_select_all(_arg0)
}
	
	// SelectIter selects the specified iterator.
	func (s TreeSelection) SelectIter(iter *TreeIter)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_selection_select_iter(_arg0, _arg1)
}
	
	// SelectPath: select the row at @path.
	func (s TreeSelection) SelectPath(path *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_selection_select_path(_arg0, _arg1)
}
	
	// SelectRange selects a range of nodes, determined by @start_path and @end_path
// inclusive. @selection must be set to K_SELECTION_MULTIPLE mode.
	func (s TreeSelection) SelectRange(startPath *TreePath, endPath *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

C.gtk_tree_selection_select_range(_arg0, _arg1, _arg2)
}
	
	// SetMode sets the selection mode of the @selection. If the previous type was
// K_SELECTION_MULTIPLE, then the anchor is kept selected, if it was previously
// selected.
	func (s TreeSelection) SetMode(typ SelectionMode)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 C.GtkSelectionMode // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkSelectionMode)(typ)

C.gtk_tree_selection_set_mode(_arg0, _arg1)
}
	
	// UnselectAll unselects all the nodes.
	func (s TreeSelection) UnselectAll()  {
var _arg0 *C.GtkTreeSelection // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))

C.gtk_tree_selection_unselect_all(_arg0)
}
	
	// UnselectIter unselects the specified iterator.
	func (s TreeSelection) UnselectIter(iter *TreeIter)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

C.gtk_tree_selection_unselect_iter(_arg0, _arg1)
}
	
	// UnselectPath unselects the row at @path.
	func (s TreeSelection) UnselectPath(path *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_selection_unselect_path(_arg0, _arg1)
}
	
	// UnselectRange unselects a range of nodes, determined by @start_path and
// @end_path inclusive.
	func (s TreeSelection) UnselectRange(startPath *TreePath, endPath *TreePath)  {
var _arg0 *C.GtkTreeSelection // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeSelection)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(startPath.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(endPath.Native()))

C.gtk_tree_selection_unselect_range(_arg0, _arg1, _arg2)
}
	


	// TreeStore: a tree-like data structure that can be used with the GtkTreeView
// 
// The TreeStore object is a list model for use with a TreeView widget. It
// implements the TreeModel interface, and consequently, can use all of the
// methods available there. It also implements the TreeSortable interface so it
// can be sorted by the view. Finally, it also implements the tree [drag and
// drop][gtk3-GtkTreeView-drag-and-drop] interfaces.
// 
// 
// GtkTreeStore as GtkBuildable
// 
// The GtkTreeStore implementation of the Buildable interface allows to specify
// the model columns with a <columns> element that may contain multiple <column>
// elements, each specifying one model column. The type attribute specifies
// the data type for the column.
// 
// An example of a UI Definition fragment for a tree store:
// 
//    <object class="GtkTreeStore">
//      <columns>
//        <column type="gchararray"/>
//        <column type="gchararray"/>
//        <column type="gint"/>
//      </columns>
//    </object>
	type TreeStore struct {
		**externglib.Object
		Buildable
		TreeDragDest
		TreeDragSource
		TreeModel
		TreeSortable
		
	}

	// TreeStoreClass is an interface that the TreeStore class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeStoreClass interface {
		gextras.Objector
		_treeStore()
	}

	func (TreeStore) _treeStore() {}

	
	func marshalTreeStore(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeStore(obj), nil
	}
	

	
	// NewTreeStoreV: non vararg creation function. Used primarily by language
// bindings.
	func NewTreeStoreV(types []externglib.Type) TreeStore {
var _arg2 *C.GType
var _arg1 C.int
var _cret *C.GtkTreeStore // in

_arg1 = C.int(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

_cret = C.gtk_tree_store_newv(_arg1, _arg2)


var _treeStore TreeStore // out

_treeStore = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(TreeStore)

return _treeStore
}
	

	
	// Append appends a new row to @tree_store. If @parent is non-nil, then it will
// append the new row after the last child of @parent, otherwise it will append
// a row to the top level. @iter will be changed to point to this new row. The
// row will be empty after this function is called. To fill in values, you need
// to call gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) Append(parent *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

C.gtk_tree_store_append(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// Clear removes all rows from @tree_store
	func (t TreeStore) Clear()  {
var _arg0 *C.GtkTreeStore // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))

C.gtk_tree_store_clear(_arg0)
}
	
	// Insert creates a new row at @position. If parent is non-nil, then the row
// will be made a child of @parent. Otherwise, the row will be created at the
// toplevel. If @position is -1 or is larger than the number of rows at that
// level, then the new row will be inserted to the end of the list. @iter will
// be changed to point to this new row. The row will be empty after this
// function is called. To fill in values, you need to call gtk_tree_store_set()
// or gtk_tree_store_set_value().
	func (t TreeStore) Insert(parent *TreeIter, position int) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 C.int // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (C.int)(position)

C.gtk_tree_store_insert(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// InsertAfter inserts a new row after @sibling. If @sibling is nil, then the
// row will be prepended to @parent s children. If @parent and @sibling are
// nil, then the row will be prepended to the toplevel. If both @sibling and
// @parent are set, then @parent must be the parent of @sibling. When @sibling
// is set, @parent is optional.
// 
// @iter will be changed to point to this new row. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) InsertAfter(parent *TreeIter, sibling *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_tree_store_insert_after(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// InsertBefore inserts a new row before @sibling. If @sibling is nil, then the
// row will be appended to @parent s children. If @parent and @sibling are nil,
// then the row will be appended to the toplevel. If both @sibling and @parent
// are set, then @parent must be the parent of @sibling. When @sibling is set,
// @parent is optional.
// 
// @iter will be changed to point to this new row. The row will be empty after
// this function is called. To fill in values, you need to call
// gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) InsertBefore(parent *TreeIter, sibling *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (*C.GtkTreeIter)(unsafe.Pointer(sibling.Native()))

C.gtk_tree_store_insert_before(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3)





return _iter
}
	
	// InsertWithValuesv: a variant of gtk_tree_store_insert_with_values() which
// takes the columns and values as two arrays, instead of varargs. This function
// is mainly intended for language bindings.
	func (t TreeStore) InsertWithValuesv(parent *TreeIter, position int, columns []int, values []**externglib.Value) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out
var _arg3 C.int // out
var _arg4 *C.int
var _arg6 C.int
var _arg5 *C.GValue
var _arg6 C.int

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))
_arg3 = (C.int)(position)
_arg6 = C.int(len(columns))
_arg4 = (*C.int)(unsafe.Pointer(&columns[0]))
_arg6 = C.int(len(values))
_arg5 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg5))
{
out := unsafe.Slice(_arg5, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_tree_store_insert_with_valuesv(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2, _arg3, _arg4, _arg5, _arg6)





return _iter
}
	
	// IsAncestor returns true if @iter is an ancestor of @descendant. That is,
// @iter is the parent (or grandparent or great-grandparent) of @descendant.
	func (t TreeStore) IsAncestor(iter *TreeIter, descendant *TreeIter) bool {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(descendant.Native()))

_cret = C.gtk_tree_store_is_ancestor(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IterDepth returns the depth of @iter. This will be 0 for anything on the root
// level, 1 for anything down a level, etc.
	func (t TreeStore) IterDepth(iter *TreeIter) int {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.int // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_store_iter_depth(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IterIsValid: WARNING: This function is slow. Only use it for debugging and/or
// testing purposes.
// 
// Checks if the given iter is a valid iter for this TreeStore.
	func (t TreeStore) IterIsValid(iter *TreeIter) bool {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_store_iter_is_valid(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveAfter moves @iter in @tree_store to the position after @position. @iter
// and @position should be in the same level. Note that this function only works
// with unsorted stores. If @position is nil, @iter will be moved to the start
// of the level.
	func (t TreeStore) MoveAfter(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_tree_store_move_after(_arg0, _arg1, _arg2)
}
	
	// MoveBefore moves @iter in @tree_store to the position before @position. @iter
// and @position should be in the same level. Note that this function only works
// with unsorted stores. If @position is nil, @iter will be moved to the end of
// the level.
	func (t TreeStore) MoveBefore(iter *TreeIter, position *TreeIter)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(position.Native()))

C.gtk_tree_store_move_before(_arg0, _arg1, _arg2)
}
	
	// Prepend prepends a new row to @tree_store. If @parent is non-nil, then it
// will prepend the new row before the first child of @parent, otherwise it will
// prepend a row to the top level. @iter will be changed to point to this new
// row. The row will be empty after this function is called. To fill in values,
// you need to call gtk_tree_store_set() or gtk_tree_store_set_value().
	func (t TreeStore) Prepend(parent *TreeIter) TreeIter {
var _arg0 *C.GtkTreeStore // out
var _iter TreeIter
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(parent.Native()))

C.gtk_tree_store_prepend(_arg0, (*C.GtkTreeIter)(unsafe.Pointer(&_iter)), _arg2)





return _iter
}
	
	// Remove removes @iter from @tree_store. After being removed, @iter is set to
// the next valid row at that level, or invalidated if it previously pointed to
// the last one.
	func (t TreeStore) Remove(iter *TreeIter) bool {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))

_cret = C.gtk_tree_store_remove(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetColumnTypes: this function is meant primarily for #GObjects that inherit
// from TreeStore, and should only be used when constructing a new TreeStore. It
// will not function after a row has been added, or a method on the TreeModel
// interface is called.
	func (t TreeStore) SetColumnTypes(types []externglib.Type)  {
var _arg0 *C.GtkTreeStore // out
var _arg2 *C.GType
var _arg1 C.int

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = C.int(len(types))
_arg2 = (*C.GType)(C.malloc(C.ulong(len(types)) * C.ulong(C.sizeof_GType)))
defer C.free(unsafe.Pointer(_arg2))
{
out := unsafe.Slice(_arg2, len(types))
for i := range types {
out[i] = C.GType(types[i])
}
}

C.gtk_tree_store_set_column_types(_arg0, _arg1, _arg2)
}
	
	// SetValue sets the data in the cell specified by @iter and @column. The type
// of @value must be convertible to the type of the column.
	func (t TreeStore) SetValue(iter *TreeIter, column int, value **externglib.Value)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 C.int // out
var _arg3 *C.GValue // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg2 = (C.int)(column)
_arg3 = (*C.GValue)(value.GValue)

C.gtk_tree_store_set_value(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetValuesv: a variant of gtk_tree_store_set_valist() which takes the columns
// and values as two arrays, instead of varargs. This function is mainly
// intended for language bindings or in case the number of columns to change is
// not known until run-time.
	func (t TreeStore) SetValuesv(iter *TreeIter, columns []int, values []**externglib.Value)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.int
var _arg4 C.int
var _arg3 *C.GValue
var _arg4 C.int

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
_arg4 = C.int(len(columns))
_arg2 = (*C.int)(unsafe.Pointer(&columns[0]))
_arg4 = C.int(len(values))
_arg3 = (*C.GValue)(C.malloc(C.ulong(len(values)) * C.ulong(C.sizeof_GValue)))
defer C.free(unsafe.Pointer(_arg3))
{
out := unsafe.Slice(_arg3, len(values))
for i := range values {
out[i] = (*C.GValue)(values[i].GValue)
}
}

C.gtk_tree_store_set_valuesv(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Swap swaps @a and @b in the same level of @tree_store. Note that this
// function only works with unsorted stores.
	func (t TreeStore) Swap(a *TreeIter, b *TreeIter)  {
var _arg0 *C.GtkTreeStore // out
var _arg1 *C.GtkTreeIter // out
var _arg2 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeStore)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeIter)(unsafe.Pointer(a.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(b.Native()))

C.gtk_tree_store_swap(_arg0, _arg1, _arg2)
}
	


	// TreeView: a widget for displaying both trees and lists
// 
// Widget that displays any object that implements the [iface@Gtk.TreeModel]
// interface.
// 
// Please refer to the tree widget conceptual overview
// (section-tree-widget.html) for an overview of all the objects and data types
// related to the tree widget and how they work together.
// 
// 
// Coordinate systems in GtkTreeView API
// 
// Several different coordinate systems are exposed in the `GtkTreeView` API.
// These are:
// 
// ! (tree-view-coordinates.png)
// 
// - Widget coordinates: Coordinates relative to the widget (usually
// `widget->window`).
// 
// - Bin window coordinates: Coordinates relative to the window that GtkTreeView
// renders to.
// 
// - Tree coordinates: Coordinates relative to the entire scrollable area of
// GtkTreeView. These coordinates start at (0, 0) for row 0 of the tree.
// 
// Several functions are available for converting between the different
// coordinate systems. The most common translations are between widget and bin
// window coordinates and between bin window and tree coordinates. For the
// former you can use [method@Gtk.TreeView.convert_widget_to_bin_window_coords]
// (and vice versa), for the latter
// [method@Gtk.TreeView.convert_bin_window_to_tree_coords] (and vice versa).
// 
// `GtkTreeView` as `GtkBuildable`
// 
// The `GtkTreeView` implementation of the `GtkBuildable` interface accepts
// [class@Gtk.TreeViewColumn] objects as `<child>` elements and exposes the
// internal [class@Gtk.TreeSelection] in UI definitions.
// 
// An example of a UI definition fragment with `GtkTreeView`:
// 
// `xml <object class="GtkTreeView" id="treeview"> <property
// name="model">liststore1</property> <child> <object class="GtkTreeViewColumn"
// id="test-column"> <property name="title">Test</property> <child> <object
// class="GtkCellRendererText" id="test-renderer"/> <attributes> <attribute
// name="text">1</attribute> </attributes> </child> </object> </child> <child
// internal-child="selection"> <object class="GtkTreeSelection" id="selection">
// <signal name="changed" handler="on_treeview_selection_changed"/> </object>
// </child> </object> `
// 
// 
// CSS nodes
// 
// ` treeview.view  header   button    [sort-indicator]    
// button   [sort-indicator]   [rubberband]  [dndtarget] `
// 
// `GtkTreeView` has a main CSS node with name `treeview` and style class
// `.view`. It has a subnode with name `header`, which is the parent for all the
// column header widgets' CSS nodes.
// 
// Each column header consists of a `button`, which among other content, has a
// child with name `sort-indicator`, which carries the `.ascending` or
// `.descending` style classes when the column header should show a sort
// indicator. The CSS is expected to provide a suitable image using the
// `-gtk-icon-source` property.
// 
// For rubberband selection, a subnode with name `rubberband` is used.
// 
// For the drop target location during DND, a subnode with name `dndtarget` is
// used.
	type TreeView struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Scrollable
		
	}

	// TreeViewClass is an interface that the TreeView class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeViewClass interface {
		gextras.Objector
		_treeView()
	}

	func (TreeView) _treeView() {}

	
	func marshalTreeView(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeView(obj), nil
	}
	

	
	// NewTreeView creates a new TreeView widget.
	func NewTreeView() TreeView {
var _cret *C.GtkWidget // in

_cret = C.gtk_tree_view_new()


var _treeView TreeView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeView = TreeView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeView
}
	
	// NewTreeViewWithModel creates a new TreeView widget with the model initialized
// to @model.
	func NewTreeViewWithModel(model TreeModel) TreeView {
var _arg1 *C.GtkTreeModel // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

_cret = C.gtk_tree_view_new_with_model(_arg1)


var _treeView TreeView // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeView = TreeView{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeView
}
	

	
	// AppendColumn appends @column to the list of columns. If @tree_view has
// fixed_height mode enabled, then @column must have its sizing property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
	func (t TreeView) AppendColumn(column TreeViewColumnClass) int {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

_cret = C.gtk_tree_view_append_column(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// CollapseAll: recursively collapses all visible, expanded nodes in @tree_view.
	func (t TreeView) CollapseAll()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_collapse_all(_arg0)
}
	
	// CollapseRow collapses a row (hides its child rows, if they exist).
	func (t TreeView) CollapseRow(path *TreePath) bool {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_view_collapse_row(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ColumnsAutosize resizes all columns to their optimal width. Only works after
// the treeview has been realized.
	func (t TreeView) ColumnsAutosize()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_columns_autosize(_arg0)
}
	
	// ConvertBinWindowToTreeCoords converts bin_window coordinates to coordinates
// for the tree (the full scrollable area of the tree).
	func (t TreeView) ConvertBinWindowToTreeCoords(bx int, by int) (tx int, ty int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(bx)
_arg2 = (C.int)(by)

C.gtk_tree_view_convert_bin_window_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _tx int // out
var _ty int // out

_tx = (int)(_arg3)
_ty = (int)(_arg4)

return _tx, _ty
}
	
	// ConvertBinWindowToWidgetCoords converts bin_window coordinates to widget
// relative coordinates.
	func (t TreeView) ConvertBinWindowToWidgetCoords(bx int, by int) (wx int, wy int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(bx)
_arg2 = (C.int)(by)

C.gtk_tree_view_convert_bin_window_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _wx int // out
var _wy int // out

_wx = (int)(_arg3)
_wy = (int)(_arg4)

return _wx, _wy
}
	
	// ConvertTreeToBinWindowCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to bin_window coordinates.
	func (t TreeView) ConvertTreeToBinWindowCoords(tx int, ty int) (bx int, by int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(tx)
_arg2 = (C.int)(ty)

C.gtk_tree_view_convert_tree_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _bx int // out
var _by int // out

_bx = (int)(_arg3)
_by = (int)(_arg4)

return _bx, _by
}
	
	// ConvertTreeToWidgetCoords converts tree coordinates (coordinates in full
// scrollable area of the tree) to widget coordinates.
	func (t TreeView) ConvertTreeToWidgetCoords(tx int, ty int) (wx int, wy int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(tx)
_arg2 = (C.int)(ty)

C.gtk_tree_view_convert_tree_to_widget_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _wx int // out
var _wy int // out

_wx = (int)(_arg3)
_wy = (int)(_arg4)

return _wx, _wy
}
	
	// ConvertWidgetToBinWindowCoords converts widget coordinates to coordinates for
// the bin_window.
	func (t TreeView) ConvertWidgetToBinWindowCoords(wx int, wy int) (bx int, by int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(wx)
_arg2 = (C.int)(wy)

C.gtk_tree_view_convert_widget_to_bin_window_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _bx int // out
var _by int // out

_bx = (int)(_arg3)
_by = (int)(_arg4)

return _bx, _by
}
	
	// ConvertWidgetToTreeCoords converts widget coordinates to coordinates for the
// tree (the full scrollable area of the tree).
	func (t TreeView) ConvertWidgetToTreeCoords(wx int, wy int) (tx int, ty int) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(wx)
_arg2 = (C.int)(wy)

C.gtk_tree_view_convert_widget_to_tree_coords(_arg0, _arg1, _arg2, &_arg3, &_arg4)

var _tx int // out
var _ty int // out

_tx = (int)(_arg3)
_ty = (int)(_arg4)

return _tx, _ty
}
	
	// CreateRowDragIcon creates a #cairo_surface_t representation of the row at
// @path. This image is used for a drag icon.
	func (t TreeView) CreateRowDragIcon(path *TreePath) gdk.Paintable {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_view_create_row_drag_icon(_arg0, _arg1)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// EnableModelDragDest turns @tree_view into a drop destination for automatic
// DND. Calling this method sets TreeView:reorderable to false.
	func (t TreeView) EnableModelDragDest(formats *gdk.ContentFormats, actions gdk.DragAction)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GdkContentFormats // out
var _arg2 C.GdkDragAction // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
_arg2 = (C.GdkDragAction)(actions)

C.gtk_tree_view_enable_model_drag_dest(_arg0, _arg1, _arg2)
}
	
	// EnableModelDragSource turns @tree_view into a drag source for automatic DND.
// Calling this method sets TreeView:reorderable to false.
	func (t TreeView) EnableModelDragSource(startButtonMask gdk.ModifierType, formats *gdk.ContentFormats, actions gdk.DragAction)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.GdkModifierType // out
var _arg2 *C.GdkContentFormats // out
var _arg3 C.GdkDragAction // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GdkModifierType)(startButtonMask)
_arg2 = (*C.GdkContentFormats)(unsafe.Pointer(formats.Native()))
_arg3 = (C.GdkDragAction)(actions)

C.gtk_tree_view_enable_model_drag_source(_arg0, _arg1, _arg2, _arg3)
}
	
	// ExpandAll: recursively expands all nodes in the @tree_view.
	func (t TreeView) ExpandAll()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_expand_all(_arg0)
}
	
	// ExpandRow opens the row so its children are visible.
	func (t TreeView) ExpandRow(path *TreePath, openAll bool) bool {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
if openAll { _arg2 = C.TRUE }

_cret = C.gtk_tree_view_expand_row(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ExpandToPath expands the row at @path. This will also expand all parent rows
// of @path as necessary.
	func (t TreeView) ExpandToPath(path *TreePath)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_view_expand_to_path(_arg0, _arg1)
}
	
	// ActivateOnSingleClick gets the setting set by
// gtk_tree_view_set_activate_on_single_click().
	func (t TreeView) ActivateOnSingleClick() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_activate_on_single_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackgroundArea fills the bounding rectangle in bin_window coordinates for the
// cell at the row specified by @path and the column specified by @column. If
// @path is nil, or points to a node not found in the tree, the @y and @height
// fields of the rectangle will be filled with 0. If @column is nil, the @x and
// @width fields will be filled with 0. The returned rectangle is equivalent to
// the @background_area passed to gtk_cell_renderer_render(). These background
// areas tile to cover the entire bin window. Contrast with the @cell_area,
// returned by gtk_tree_view_get_cell_area(), which returns only the cell
// itself, excluding surrounding borders and the tree expander area.
	func (t TreeView) BackgroundArea(path *TreePath, column TreeViewColumnClass) gdk.Rectangle {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _rect gdk.Rectangle

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_get_background_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))





return _rect
}
	
	// CellArea fills the bounding rectangle in bin_window coordinates for the cell
// at the row specified by @path and the column specified by @column. If @path
// is nil, or points to a path not currently displayed, the @y and @height
// fields of the rectangle will be filled with 0. If @column is nil, the @x and
// @width fields will be filled with 0. The sum of all cell rects does not cover
// the entire tree; there are extra pixels in between rows, for example. The
// returned rectangle is equivalent to the @cell_area passed to
// gtk_cell_renderer_render(). This function is only valid if @tree_view is
// realized.
	func (t TreeView) CellArea(path *TreePath, column TreeViewColumnClass) gdk.Rectangle {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _rect gdk.Rectangle

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_get_cell_area(_arg0, _arg1, _arg2, (*C.GdkRectangle)(unsafe.Pointer(&_rect)))





return _rect
}
	
	// Column gets the TreeViewColumn at the given position in the #tree_view.
	func (t TreeView) Column(n int) TreeViewColumn {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _cret *C.GtkTreeViewColumn // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(n)

_cret = C.gtk_tree_view_get_column(_arg0, _arg1)


var _treeViewColumn TreeViewColumn // out

_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

return _treeViewColumn
}
	
	// Cursor fills in @path and @focus_column with the current path and focus
// column. If the cursor isnt currently set, then *@path will be nil. If no
// column currently has focus, then *@focus_column will be nil.
// 
// The returned TreePath must be freed with gtk_tree_path_free() when you are
// done with it.
	func (t TreeView) Cursor() (*TreePath, TreeViewColumn) {
var _arg0 *C.GtkTreeView // out
var _path *TreePath
var _arg2 *C.GtkTreeViewColumn // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_get_cursor(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)


var _focusColumn TreeViewColumn // out


_focusColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg2))).(TreeViewColumn)

return _path, _focusColumn
}
	
	// DestRowAtPos determines the destination row for a given position. @drag_x and
// @drag_y are expected to be in widget coordinates. This function is only
// meaningful if @tree_view is realized. Therefore this function will always
// return false if @tree_view is not realized or does not have a model.
	func (t TreeView) DestRowAtPos(dragX int, dragY int) (*TreePath, TreeViewDropPosition, bool) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _path *TreePath
var _arg4 C.GtkTreeViewDropPosition // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(dragX)
_arg2 = (C.int)(dragY)

_cret = C.gtk_tree_view_get_dest_row_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4)



var _pos TreeViewDropPosition // out
var _ok bool // out


_pos = TreeViewDropPosition(_arg4)
if _cret != 0 { _ok = true }

return _path, _pos, _ok
}
	
	// DragDestRow gets information about the row that is highlighted for feedback.
	func (t TreeView) DragDestRow() (*TreePath, TreeViewDropPosition) {
var _arg0 *C.GtkTreeView // out
var _path *TreePath
var _arg2 C.GtkTreeViewDropPosition // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_get_drag_dest_row(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg2)


var _pos TreeViewDropPosition // out


_pos = TreeViewDropPosition(_arg2)

return _path, _pos
}
	
	// EnableSearch returns whether or not the tree allows to start interactive
// searching by typing in text.
	func (t TreeView) EnableSearch() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_enable_search(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EnableTreeLines returns whether or not tree lines are drawn in @tree_view.
	func (t TreeView) EnableTreeLines() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_enable_tree_lines(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ExpanderColumn returns the column that is the current expander column, or nil
// if none has been set. This column has the expander arrow drawn next to it.
	func (t TreeView) ExpanderColumn() TreeViewColumn {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkTreeViewColumn // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_expander_column(_arg0)


var _treeViewColumn TreeViewColumn // out

_treeViewColumn = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeViewColumn)

return _treeViewColumn
}
	
	// FixedHeightMode returns whether fixed height mode is turned on for
// @tree_view.
	func (t TreeView) FixedHeightMode() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_fixed_height_mode(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// GridLines returns which grid lines are enabled in @tree_view.
	func (t TreeView) GridLines() TreeViewGridLines {
var _arg0 *C.GtkTreeView // out
var _cret C.GtkTreeViewGridLines // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_grid_lines(_arg0)


var _treeViewGridLines TreeViewGridLines // out

_treeViewGridLines = TreeViewGridLines(_cret)

return _treeViewGridLines
}
	
	// HeadersClickable returns whether all header columns are clickable.
	func (t TreeView) HeadersClickable() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_headers_clickable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HeadersVisible returns true if the headers on the @tree_view are visible.
	func (t TreeView) HeadersVisible() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_headers_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HoverExpand returns whether hover expansion mode is turned on for @tree_view.
	func (t TreeView) HoverExpand() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_hover_expand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HoverSelection returns whether hover selection mode is turned on for
// @tree_view.
	func (t TreeView) HoverSelection() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_hover_selection(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LevelIndentation returns the amount, in pixels, of extra indentation for
// child levels in @tree_view.
	func (t TreeView) LevelIndentation() int {
var _arg0 *C.GtkTreeView // out
var _cret C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_level_indentation(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Model returns the model the TreeView is based on. Returns nil if the model is
// unset.
	func (t TreeView) Model() TreeModel {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// NColumns queries the number of columns in the given @tree_view.
	func (t TreeView) NColumns() uint {
var _arg0 *C.GtkTreeView // out
var _cret C.guint // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_n_columns(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// PathAtPos finds the path at the point (@x, @y), relative to bin_window
// coordinates. That is, @x and @y are relative to an events coordinates.
// Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords(). It is primarily for
// things like popup menus. If @path is non-nil, then it will be filled with the
// TreePath at that point. This path should be freed with gtk_tree_path_free().
// If @column is non-nil, then it will be filled with the column at that point.
// @cell_x and @cell_y return the coordinates relative to the cell background
// (i.e. the @background_area passed to gtk_cell_renderer_render()). This
// function is only meaningful if @tree_view is realized. Therefore this
// function will always return false if @tree_view is not realized or does not
// have a model.
// 
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
	func (t TreeView) PathAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _path *TreePath
var _arg4 *C.GtkTreeViewColumn // in
var _arg5 C.int // in
var _arg6 C.int // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)

_cret = C.gtk_tree_view_get_path_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)



var _column TreeViewColumn // out
var _cellX int // out
var _cellY int // out
var _ok bool // out


_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
_cellX = (int)(_arg5)
_cellY = (int)(_arg6)
if _cret != 0 { _ok = true }

return _path, _column, _cellX, _cellY, _ok
}
	
	// Reorderable retrieves whether the user can reorder the tree via
// drag-and-drop. See gtk_tree_view_set_reorderable().
	func (t TreeView) Reorderable() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_reorderable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RubberBanding returns whether rubber banding is turned on for @tree_view. If
// the selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the
// user to select multiple rows by dragging the mouse.
	func (t TreeView) RubberBanding() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_rubber_banding(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SearchColumn gets the column searched on by the interactive search code.
	func (t TreeView) SearchColumn() int {
var _arg0 *C.GtkTreeView // out
var _cret C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_search_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SearchEntry returns the Entry which is currently in use as interactive search
// entry for @tree_view. In case the built-in entry is being used, nil will be
// returned.
	func (t TreeView) SearchEntry() Editable {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkEditable // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_search_entry(_arg0)


var _editable Editable // out

_editable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Editable)

return _editable
}
	
	// Selection gets the TreeSelection associated with @tree_view.
	func (t TreeView) Selection() TreeSelection {
var _arg0 *C.GtkTreeView // out
var _cret *C.GtkTreeSelection // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_selection(_arg0)


var _treeSelection TreeSelection // out

_treeSelection = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeSelection)

return _treeSelection
}
	
	// ShowExpanders returns whether or not expanders are drawn in @tree_view.
	func (t TreeView) ShowExpanders() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_show_expanders(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TooltipColumn returns the column of @tree_views model which is being used
// for displaying tooltips on @tree_views rows.
	func (t TreeView) TooltipColumn() int {
var _arg0 *C.GtkTreeView // out
var _cret C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_tooltip_column(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// TooltipContext: this function is supposed to be used in a
// Widget::query-tooltip signal handler for TreeView. The @x, @y and
// @keyboard_tip values which are received in the signal handler, should be
// passed to this function without modification.
// 
// The return value indicates whether there is a tree view row at the given
// coordinates (true) or not (false) for mouse tooltips. For keyboard tooltips
// the row returned will be the cursor row. When true, then any of @model, @path
// and @iter which have been provided will be set to point to that row and the
// corresponding model. @x and @y will always be converted to be relative to
// @tree_views bin_window if @keyboard_tooltip is false.
	func (t TreeView) TooltipContext(x int, y int, keyboardTip bool) (TreeModel, *TreePath, TreeIter, bool) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.gboolean // out
var _arg4 *C.GtkTreeModel // in
var _path *TreePath
var _iter TreeIter
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)
if keyboardTip { _arg3 = C.TRUE }

_cret = C.gtk_tree_view_get_tooltip_context(_arg0, _arg1, _arg2, _arg3, &_arg4, (**C.GtkTreePath)(unsafe.Pointer(&_path)), (*C.GtkTreeIter)(unsafe.Pointer(&_iter)))


var _model TreeModel // out


var _ok bool // out

_model = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeModel)


if _cret != 0 { _ok = true }

return _model, _path, _iter, _ok
}
	
	// VisibleRange sets @start_path and @end_path to be the first and last visible
// path. Note that there may be invisible paths in between.
// 
// The paths should be freed with gtk_tree_path_free() after use.
	func (t TreeView) VisibleRange() (startPath *TreePath, endPath *TreePath, ok bool) {
var _arg0 *C.GtkTreeView // out
var _startPath *TreePath
var _endPath *TreePath
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_get_visible_range(_arg0, (**C.GtkTreePath)(unsafe.Pointer(&_startPath)), (**C.GtkTreePath)(unsafe.Pointer(&_endPath)))




var _ok bool // out



if _cret != 0 { _ok = true }

return _startPath, _endPath, _ok
}
	
	// VisibleRect fills @visible_rect with the currently-visible region of the
// buffer, in tree coordinates. Convert to bin_window coordinates with
// gtk_tree_view_convert_tree_to_bin_window_coords(). Tree coordinates start at
// 0,0 for row 0 of the tree, and cover the entire scrollable area of the tree.
	func (t TreeView) VisibleRect() gdk.Rectangle {
var _arg0 *C.GtkTreeView // out
var _visibleRect gdk.Rectangle

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_get_visible_rect(_arg0, (*C.GdkRectangle)(unsafe.Pointer(&_visibleRect)))





return _visibleRect
}
	
	// InsertColumn: this inserts the @column into the @tree_view at @position. If
// @position is -1, then the column is inserted at the end. If @tree_view has
// fixed_height mode enabled, then @column must have its sizing property set
// to be GTK_TREE_VIEW_COLUMN_FIXED.
	func (t TreeView) InsertColumn(column TreeViewColumnClass, position int) int {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _arg2 C.int // out
var _cret C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
_arg2 = (C.int)(position)

_cret = C.gtk_tree_view_insert_column(_arg0, _arg1, _arg2)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsBlankAtPos: determine whether the point (@x, @y) in @tree_view is blank,
// that is no cell content nor an expander arrow is drawn at the location. If
// so, the location can be considered as the background. You might wish to take
// special action on clicks on the background, such as clearing a current
// selection, having a custom context menu or starting rubber banding.
// 
// The @x and @y coordinate that are provided must be relative to bin_window
// coordinates. Widget-relative coordinates must be converted using
// gtk_tree_view_convert_widget_to_bin_window_coords().
// 
// For converting widget coordinates (eg. the ones you get from
// GtkWidget::query-tooltip), please see
// gtk_tree_view_convert_widget_to_bin_window_coords().
// 
// The @path, @column, @cell_x and @cell_y arguments will be filled in likewise
// as for gtk_tree_view_get_path_at_pos(). Please see
// gtk_tree_view_get_path_at_pos() for more information.
	func (t TreeView) IsBlankAtPos(x int, y int) (path *TreePath, column TreeViewColumn, cellX int, cellY int, ok bool) {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out
var _path *TreePath
var _arg4 *C.GtkTreeViewColumn // in
var _arg5 C.int // in
var _arg6 C.int // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(x)
_arg2 = (C.int)(y)

_cret = C.gtk_tree_view_is_blank_at_pos(_arg0, _arg1, _arg2, (**C.GtkTreePath)(unsafe.Pointer(&_path)), &_arg4, &_arg5, &_arg6)



var _column TreeViewColumn // out
var _cellX int // out
var _cellY int // out
var _ok bool // out


_column = gextras.CastObject(externglib.Take(unsafe.Pointer(_arg4))).(TreeViewColumn)
_cellX = (int)(_arg5)
_cellY = (int)(_arg6)
if _cret != 0 { _ok = true }

return _path, _column, _cellX, _cellY, _ok
}
	
	// IsRubberBandingActive returns whether a rubber banding operation is currently
// being done in @tree_view.
	func (t TreeView) IsRubberBandingActive() bool {
var _arg0 *C.GtkTreeView // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_is_rubber_banding_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MoveColumnAfter moves @column to be after to @base_column. If @base_column is
// nil, then @column is placed in the first position.
	func (t TreeView) MoveColumnAfter(column TreeViewColumnClass, baseColumn TreeViewColumnClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _arg2 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(baseColumn.Native()))

C.gtk_tree_view_move_column_after(_arg0, _arg1, _arg2)
}
	
	// RemoveColumn removes @column from @tree_view.
	func (t TreeView) RemoveColumn(column TreeViewColumnClass) int {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

_cret = C.gtk_tree_view_remove_column(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// RowActivated activates the cell determined by @path and @column.
	func (t TreeView) RowActivated(path *TreePath, column TreeViewColumnClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_row_activated(_arg0, _arg1, _arg2)
}
	
	// RowExpanded returns true if the node pointed to by @path is expanded in
// @tree_view.
	func (t TreeView) RowExpanded(path *TreePath) bool {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_view_row_expanded(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ScrollToCell moves the alignments of @tree_view to the position specified by
// @column and @path. If @column is nil, then no horizontal scrolling occurs.
// Likewise, if @path is nil no vertical scrolling occurs. At a minimum, one of
// @column or @path need to be non-nil. @row_align determines where the row is
// placed, and @col_align determines where @column is placed. Both are expected
// to be between 0.0 and 1.0. 0.0 means left/top alignment, 1.0 means
// right/bottom alignment, 0.5 means center.
// 
// If @use_align is false, then the alignment arguments are ignored, and the
// tree does the minimum amount of work to scroll the cell onto the screen. This
// means that the cell will be scrolled to the edge closest to its current
// position. If the cell is currently visible on the screen, nothing is done.
// 
// This function only works if the model is set, and @path is a valid row on the
// model. If the model changes before the @tree_view is realized, the centered
// path will be modified to reflect this change.
	func (t TreeView) ScrollToCell(path *TreePath, column TreeViewColumnClass, useAlign bool, rowAlign float32, colAlign float32)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _arg3 C.gboolean // out
var _arg4 C.float // out
var _arg5 C.float // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
if useAlign { _arg3 = C.TRUE }
_arg4 = (C.float)(rowAlign)
_arg5 = (C.float)(colAlign)

C.gtk_tree_view_scroll_to_cell(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}
	
	// ScrollToPoint scrolls the tree view such that the top-left corner of the
// visible area is @tree_x, @tree_y, where @tree_x and @tree_y are specified in
// tree coordinates. The @tree_view must be realized before this function is
// called. If it isn't, you probably want to be using
// gtk_tree_view_scroll_to_cell().
// 
// If either @tree_x or @tree_y are -1, then that direction isnt scrolled.
	func (t TreeView) ScrollToPoint(treeX int, treeY int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(treeX)
_arg2 = (C.int)(treeY)

C.gtk_tree_view_scroll_to_point(_arg0, _arg1, _arg2)
}
	
	// SetActivateOnSingleClick: cause the TreeView::row-activated signal to be
// emitted on a single click instead of a double click.
	func (t TreeView) SetActivateOnSingleClick(single bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if single { _arg1 = C.TRUE }

C.gtk_tree_view_set_activate_on_single_click(_arg0, _arg1)
}
	
	// SetCursor sets the current keyboard focus to be at @path, and selects it.
// This is useful when you want to focus the users attention on a particular
// row. If @focus_column is not nil, then focus is given to the column specified
// by it. Additionally, if @focus_column is specified, and @start_editing is
// true, then editing should be started in the specified cell. This function is
// often followed by @gtk_widget_grab_focus (@tree_view) in order to give
// keyboard focus to the widget. Please note that editing can only happen when
// the widget is realized.
// 
// If @path is invalid for @model, the current cursor (if any) will be unset and
// the function will return without failing.
	func (t TreeView) SetCursor(path *TreePath, focusColumn TreeViewColumnClass, startEditing bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _arg3 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
if startEditing { _arg3 = C.TRUE }

C.gtk_tree_view_set_cursor(_arg0, _arg1, _arg2, _arg3)
}
	
	// SetCursorOnCell sets the current keyboard focus to be at @path, and selects
// it. This is useful when you want to focus the users attention on a
// particular row. If @focus_column is not nil, then focus is given to the
// column specified by it. If @focus_column and @focus_cell are not nil, and
// @focus_column contains 2 or more editable or activatable cells, then focus is
// given to the cell specified by @focus_cell. Additionally, if @focus_column is
// specified, and @start_editing is true, then editing should be started in the
// specified cell. This function is often followed by @gtk_widget_grab_focus
// (@tree_view) in order to give keyboard focus to the widget. Please note that
// editing can only happen when the widget is realized.
// 
// If @path is invalid for @model, the current cursor (if any) will be unset and
// the function will return without failing.
	func (t TreeView) SetCursorOnCell(path *TreePath, focusColumn TreeViewColumnClass, focusCell CellRendererClass, startEditing bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 *C.GtkTreeViewColumn // out
var _arg3 *C.GtkCellRenderer // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (*C.GtkTreeViewColumn)(unsafe.Pointer(focusColumn.Native()))
_arg3 = (*C.GtkCellRenderer)(unsafe.Pointer(focusCell.Native()))
if startEditing { _arg4 = C.TRUE }

C.gtk_tree_view_set_cursor_on_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetDragDestRow sets the row that is highlighted for feedback. If @path is
// nil, an existing highlight is removed.
	func (t TreeView) SetDragDestRow(path *TreePath, pos TreeViewDropPosition)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreePath // out
var _arg2 C.GtkTreeViewDropPosition // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg2 = (C.GtkTreeViewDropPosition)(pos)

C.gtk_tree_view_set_drag_dest_row(_arg0, _arg1, _arg2)
}
	
	// SetEnableSearch: if @enable_search is set, then the user can type in text to
// search through the tree interactively (this is sometimes called "typeahead
// find").
// 
// Note that even if this is false, the user can still initiate a search using
// the start-interactive-search key binding.
	func (t TreeView) SetEnableSearch(enableSearch bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enableSearch { _arg1 = C.TRUE }

C.gtk_tree_view_set_enable_search(_arg0, _arg1)
}
	
	// SetEnableTreeLines sets whether to draw lines interconnecting the expanders
// in @tree_view. This does not have any visible effects for lists.
	func (t TreeView) SetEnableTreeLines(enabled bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enabled { _arg1 = C.TRUE }

C.gtk_tree_view_set_enable_tree_lines(_arg0, _arg1)
}
	
	// SetExpanderColumn sets the column to draw the expander arrow at. It must be
// in @tree_view. If @column is nil, then the expander arrow is always at the
// first visible column.
// 
// If you do not want expander arrow to appear in your tree, set the expander
// column to a hidden column.
	func (t TreeView) SetExpanderColumn(column TreeViewColumnClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))

C.gtk_tree_view_set_expander_column(_arg0, _arg1)
}
	
	// SetFixedHeightMode enables or disables the fixed height mode of @tree_view.
// Fixed height mode speeds up TreeView by assuming that all rows have the same
// height. Only enable this option if all rows are the same height and all
// columns are of type GTK_TREE_VIEW_COLUMN_FIXED.
	func (t TreeView) SetFixedHeightMode(enable bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enable { _arg1 = C.TRUE }

C.gtk_tree_view_set_fixed_height_mode(_arg0, _arg1)
}
	
	// SetGridLines sets which grid lines to draw in @tree_view.
	func (t TreeView) SetGridLines(gridLines TreeViewGridLines)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.GtkTreeViewGridLines // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTreeViewGridLines)(gridLines)

C.gtk_tree_view_set_grid_lines(_arg0, _arg1)
}
	
	// SetHeadersClickable: allow the column title buttons to be clicked.
	func (t TreeView) SetHeadersClickable(setting bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_tree_view_set_headers_clickable(_arg0, _arg1)
}
	
	// SetHeadersVisible sets the visibility state of the headers.
	func (t TreeView) SetHeadersVisible(headersVisible bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if headersVisible { _arg1 = C.TRUE }

C.gtk_tree_view_set_headers_visible(_arg0, _arg1)
}
	
	// SetHoverExpand enables or disables the hover expansion mode of @tree_view.
// Hover expansion makes rows expand or collapse if the pointer moves over them.
	func (t TreeView) SetHoverExpand(expand bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_tree_view_set_hover_expand(_arg0, _arg1)
}
	
	// SetHoverSelection enables or disables the hover selection mode of @tree_view.
// Hover selection makes the selected row follow the pointer. Currently, this
// works only for the selection modes GTK_SELECTION_SINGLE and
// GTK_SELECTION_BROWSE.
	func (t TreeView) SetHoverSelection(hover bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if hover { _arg1 = C.TRUE }

C.gtk_tree_view_set_hover_selection(_arg0, _arg1)
}
	
	// SetLevelIndentation sets the amount of extra indentation for child levels to
// use in @tree_view in addition to the default indentation. The value should be
// specified in pixels, a value of 0 disables this feature and in this case only
// the default indentation will be used. This does not have any visible effects
// for lists.
	func (t TreeView) SetLevelIndentation(indentation int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(indentation)

C.gtk_tree_view_set_level_indentation(_arg0, _arg1)
}
	
	// SetModel sets the model for a TreeView. If the @tree_view already has a model
// set, it will remove it before setting the new model. If @model is nil, then
// it will unset the old model.
	func (t TreeView) SetModel(model TreeModel)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTreeModel // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))

C.gtk_tree_view_set_model(_arg0, _arg1)
}
	
	// SetReorderable: this function is a convenience function to allow you to
// reorder models that support the TreeDragSourceIface and the
// TreeDragDestIface. Both TreeStore and ListStore support these. If
// @reorderable is true, then the user can reorder the model by dragging and
// dropping rows. The developer can listen to these changes by connecting to the
// models TreeModel::row-inserted and TreeModel::row-deleted signals. The
// reordering is implemented by setting up the tree view as a drag source and
// destination. Therefore, drag and drop can not be used in a reorderable view
// for any other purpose.
// 
// This function does not give you any degree of control over the order -- any
// reordering is allowed. If more control is needed, you should probably handle
// drag and drop manually.
	func (t TreeView) SetReorderable(reorderable bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if reorderable { _arg1 = C.TRUE }

C.gtk_tree_view_set_reorderable(_arg0, _arg1)
}
	
	// SetRubberBanding enables or disables rubber banding in @tree_view. If the
// selection mode is K_SELECTION_MULTIPLE, rubber banding will allow the user to
// select multiple rows by dragging the mouse.
	func (t TreeView) SetRubberBanding(enable bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enable { _arg1 = C.TRUE }

C.gtk_tree_view_set_rubber_banding(_arg0, _arg1)
}
	
	// SetSearchColumn sets @column as the column where the interactive search code
// should search in for the current model.
// 
// If the search column is set, users can use the start-interactive-search key
// binding to bring up search popup. The enable-search property controls whether
// simply typing text will also start an interactive search.
// 
// Note that @column refers to a column of the current model. The search column
// is reset to -1 when the model is changed.
	func (t TreeView) SetSearchColumn(column int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(column)

C.gtk_tree_view_set_search_column(_arg0, _arg1)
}
	
	// SetSearchEntry sets the entry which the interactive search code will use for
// this @tree_view. This is useful when you want to provide a search entry in
// our interface at all time at a fixed position. Passing nil for @entry will
// make the interactive search code use the built-in popup entry again.
	func (t TreeView) SetSearchEntry(entry Editable)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkEditable // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkEditable)(unsafe.Pointer(entry.Native()))

C.gtk_tree_view_set_search_entry(_arg0, _arg1)
}
	
	// SetShowExpanders sets whether to draw and enable expanders and indent child
// rows in @tree_view. When disabled there will be no expanders visible in trees
// and there will be no way to expand and collapse rows by default. Also note
// that hiding the expanders will disable the default indentation. You can set a
// custom indentation in this case using gtk_tree_view_set_level_indentation().
// This does not have any visible effects for lists.
	func (t TreeView) SetShowExpanders(enabled bool)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
if enabled { _arg1 = C.TRUE }

C.gtk_tree_view_set_show_expanders(_arg0, _arg1)
}
	
	// SetTooltipCell sets the tip area of @tooltip to the area @path, @column and
// @cell have in common. For example if @path is nil and @column is set, the tip
// area will be set to the full area covered by @column. See also
// gtk_tooltip_set_tip_area().
// 
// Note that if @path is not specified and @cell is set and part of a column
// containing the expander, the tooltip might not show and hide at the correct
// position. In such cases @path must be set to the current node under the mouse
// cursor for this function to operate correctly.
// 
// See also gtk_tree_view_set_tooltip_column() for a simpler alternative.
	func (t TreeView) SetTooltipCell(tooltip TooltipClass, path *TreePath, column TreeViewColumnClass, cell CellRendererClass)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out
var _arg3 *C.GtkTreeViewColumn // out
var _arg4 *C.GtkCellRenderer // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))
_arg3 = (*C.GtkTreeViewColumn)(unsafe.Pointer(column.Native()))
_arg4 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_tree_view_set_tooltip_cell(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// SetTooltipColumn: if you only plan to have simple (text-only) tooltips on
// full rows, you can use this function to have TreeView handle these
// automatically for you. @column should be set to the column in @tree_views
// model containing the tooltip texts, or -1 to disable this feature.
// 
// When enabled, Widget:has-tooltip will be set to true and @tree_view will
// connect a Widget::query-tooltip signal handler.
// 
// Note that the signal handler sets the text with gtk_tooltip_set_markup(), so
// &, <, etc have to be escaped in the text.
	func (t TreeView) SetTooltipColumn(column int)  {
var _arg0 *C.GtkTreeView // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(column)

C.gtk_tree_view_set_tooltip_column(_arg0, _arg1)
}
	
	// SetTooltipRow sets the tip area of @tooltip to be the area covered by the row
// at @path. See also gtk_tree_view_set_tooltip_column() for a simpler
// alternative. See also gtk_tooltip_set_tip_area().
	func (t TreeView) SetTooltipRow(tooltip TooltipClass, path *TreePath)  {
var _arg0 *C.GtkTreeView // out
var _arg1 *C.GtkTooltip // out
var _arg2 *C.GtkTreePath // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTooltip)(unsafe.Pointer(tooltip.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

C.gtk_tree_view_set_tooltip_row(_arg0, _arg1, _arg2)
}
	
	// UnsetRowsDragDest undoes the effect of
// gtk_tree_view_enable_model_drag_dest(). Calling this method sets
// TreeView:reorderable to false.
	func (t TreeView) UnsetRowsDragDest()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_unset_rows_drag_dest(_arg0)
}
	
	// UnsetRowsDragSource undoes the effect of
// gtk_tree_view_enable_model_drag_source(). Calling this method sets
// TreeView:reorderable to false.
	func (t TreeView) UnsetRowsDragSource()  {
var _arg0 *C.GtkTreeView // out

_arg0 = (*C.GtkTreeView)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_unset_rows_drag_source(_arg0)
}
	


	// TreeViewColumn: a visible column in a GtkTreeView widget
// 
// The GtkTreeViewColumn object represents a visible column in a TreeView
// widget. It allows to set properties of the column header, and functions as a
// holding pen for the cell renderers which determine how the data in the column
// is displayed.
// 
// Please refer to the [tree widget conceptual overview][TreeWidget] for an
// overview of all the objects and data types related to the tree widget and how
// they work together, and to the TreeView documentation for specifics about the
// CSS node structure for treeviews and their headers.
	type TreeViewColumn struct {
		externglib.InitiallyUnowned
		Buildable
		CellLayout
		
	}

	// TreeViewColumnClass is an interface that the TreeViewColumn class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type TreeViewColumnClass interface {
		gextras.Objector
		_treeViewColumn()
	}

	func (TreeViewColumn) _treeViewColumn() {}

	
	func marshalTreeViewColumn(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapTreeViewColumn(obj), nil
	}
	

	
	// NewTreeViewColumn creates a new TreeViewColumn.
	func NewTreeViewColumn() TreeViewColumn {
var _cret *C.GtkTreeViewColumn // in

_cret = C.gtk_tree_view_column_new()


var _treeViewColumn TreeViewColumn // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeViewColumn = TreeViewColumn{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeViewColumn
}
	
	// NewTreeViewColumnWithArea creates a new TreeViewColumn using @area to render
// its cells.
	func NewTreeViewColumnWithArea(area CellAreaClass) TreeViewColumn {
var _arg1 *C.GtkCellArea // out
var _cret *C.GtkTreeViewColumn // in

_arg1 = (*C.GtkCellArea)(unsafe.Pointer(area.Native()))

_cret = C.gtk_tree_view_column_new_with_area(_arg1)


var _treeViewColumn TreeViewColumn // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_treeViewColumn = TreeViewColumn{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
CellLayout: CellLayout{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _treeViewColumn
}
	

	
	// AddAttribute adds an attribute mapping to the list in @tree_column. The
// @column is the column of the model to get a value from, and the @attribute is
// the parameter on @cell_renderer to be set from the value. So for example if
// column 2 of the model contains strings, you could have the text attribute
// of a CellRendererText get its values from column 2.
	func (t TreeViewColumn) AddAttribute(cellRenderer CellRendererClass, attribute string, column int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 *C.char // out
var _arg3 C.int // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))
_arg2 = (*C.char)(C.CString(attribute))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.int)(column)

C.gtk_tree_view_column_add_attribute(_arg0, _arg1, _arg2, _arg3)
}
	
	// CellGetPosition obtains the horizontal position and size of a cell in a
// column. If the cell is not found in the column, @start_pos and @width are not
// changed and false is returned.
	func (t TreeViewColumn) CellGetPosition(cellRenderer CellRendererClass) (xOffset int, width int, ok bool) {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.int // in
var _arg3 C.int // in
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

_cret = C.gtk_tree_view_column_cell_get_position(_arg0, _arg1, &_arg2, &_arg3)


var _xOffset int // out
var _width int // out
var _ok bool // out

_xOffset = (int)(_arg2)
_width = (int)(_arg3)
if _cret != 0 { _ok = true }

return _xOffset, _width, _ok
}
	
	// CellGetSize obtains the width and height needed to render the column. This is
// used primarily by the TreeView.
	func (t TreeViewColumn) CellGetSize() (xOffset int, yOffset int, width int, height int) {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.int // in
var _arg2 C.int // in
var _arg3 C.int // in
var _arg4 C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_column_cell_get_size(_arg0, &_arg1, &_arg2, &_arg3, &_arg4)

var _xOffset int // out
var _yOffset int // out
var _width int // out
var _height int // out

_xOffset = (int)(_arg1)
_yOffset = (int)(_arg2)
_width = (int)(_arg3)
_height = (int)(_arg4)

return _xOffset, _yOffset, _width, _height
}
	
	// CellIsVisible returns true if any of the cells packed into the @tree_column
// are visible. For this to be meaningful, you must first initialize the cells
// with gtk_tree_view_column_cell_set_cell_data()
	func (t TreeViewColumn) CellIsVisible() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_cell_is_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CellSetCellData sets the cell renderer based on the @tree_model and @iter.
// That is, for every attribute mapping in @tree_column, it will get a value
// from the set column on the @iter, and use that value to set the attribute on
// the cell renderer. This is used primarily by the TreeView.
	func (t TreeViewColumn) CellSetCellData(treeModel TreeModel, iter *TreeIter, isExpander bool, isExpanded bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkTreeModel // out
var _arg2 *C.GtkTreeIter // out
var _arg3 C.gboolean // out
var _arg4 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(treeModel.Native()))
_arg2 = (*C.GtkTreeIter)(unsafe.Pointer(iter.Native()))
if isExpander { _arg3 = C.TRUE }
if isExpanded { _arg4 = C.TRUE }

C.gtk_tree_view_column_cell_set_cell_data(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Clear unsets all the mappings on all renderers on the @tree_column.
	func (t TreeViewColumn) Clear()  {
var _arg0 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_column_clear(_arg0)
}
	
	// ClearAttributes clears all existing attributes previously set with
// gtk_tree_view_column_set_attributes().
	func (t TreeViewColumn) ClearAttributes(cellRenderer CellRendererClass)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cellRenderer.Native()))

C.gtk_tree_view_column_clear_attributes(_arg0, _arg1)
}
	
	// Clicked emits the clicked signal on the column. This function will only
// work if @tree_column is clickable.
	func (t TreeViewColumn) Clicked()  {
var _arg0 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_column_clicked(_arg0)
}
	
	// FocusCell sets the current keyboard focus to be at @cell, if the column
// contains 2 or more editable and activatable cells.
	func (t TreeViewColumn) FocusCell(cell CellRendererClass)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))

C.gtk_tree_view_column_focus_cell(_arg0, _arg1)
}
	
	// Alignment returns the current x alignment of @tree_column. This value can
// range between 0.0 and 1.0.
	func (t TreeViewColumn) Alignment() float32 {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.float // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_alignment(_arg0)


var _gfloat float32 // out

_gfloat = (float32)(_cret)

return _gfloat
}
	
	// Button returns the button used in the treeview column header
	func (t TreeViewColumn) Button() Widget {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_button(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Clickable returns true if the user can click on the header for the column.
	func (t TreeViewColumn) Clickable() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_clickable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Expand returns true if the column expands to fill available space.
	func (t TreeViewColumn) Expand() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_expand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FixedWidth gets the fixed width of the column. This may not be the actual
// displayed width of the column; for that, use
// gtk_tree_view_column_get_width().
	func (t TreeViewColumn) FixedWidth() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_fixed_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MaxWidth returns the maximum width in pixels of the @tree_column, or -1 if no
// maximum width is set.
	func (t TreeViewColumn) MaxWidth() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_max_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MinWidth returns the minimum width in pixels of the @tree_column, or -1 if no
// minimum width is set.
	func (t TreeViewColumn) MinWidth() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_min_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Reorderable returns true if the @tree_column can be reordered by the user.
	func (t TreeViewColumn) Reorderable() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_reorderable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Resizable returns true if the @tree_column can be resized by the end user.
	func (t TreeViewColumn) Resizable() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_resizable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Sizing returns the current type of @tree_column.
	func (t TreeViewColumn) Sizing() TreeViewColumnSizing {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.GtkTreeViewColumnSizing // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sizing(_arg0)


var _treeViewColumnSizing TreeViewColumnSizing // out

_treeViewColumnSizing = TreeViewColumnSizing(_cret)

return _treeViewColumnSizing
}
	
	// SortColumnID gets the logical @sort_column_id that the model sorts on when
// this column is selected for sorting. See
// gtk_tree_view_column_set_sort_column_id().
	func (t TreeViewColumn) SortColumnID() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sort_column_id(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SortIndicator gets the value set by
// gtk_tree_view_column_set_sort_indicator().
	func (t TreeViewColumn) SortIndicator() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sort_indicator(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SortOrder gets the value set by gtk_tree_view_column_set_sort_order().
	func (t TreeViewColumn) SortOrder() SortType {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.GtkSortType // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_sort_order(_arg0)


var _sortType SortType // out

_sortType = SortType(_cret)

return _sortType
}
	
	// Spacing returns the spacing of @tree_column.
	func (t TreeViewColumn) Spacing() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_spacing(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Title returns the title of the widget.
	func (t TreeViewColumn) Title() string {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.char // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TreeView returns the TreeView wherein @tree_column has been inserted. If
// @column is currently not inserted in any tree view, nil is returned.
	func (t TreeViewColumn) TreeView() Widget {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_tree_view(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Visible returns true if @tree_column is visible.
	func (t TreeViewColumn) Visible() bool {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Widget returns the Widget in the button on the column header. If a custom
// widget has not been set then nil is returned.
	func (t TreeViewColumn) Widget() Widget {
var _arg0 *C.GtkTreeViewColumn // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Width returns the current size of @tree_column in pixels.
	func (t TreeViewColumn) Width() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// XOffset returns the current X offset of @tree_column in pixels.
	func (t TreeViewColumn) XOffset() int {
var _arg0 *C.GtkTreeViewColumn // out
var _cret C.int // in

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

_cret = C.gtk_tree_view_column_get_x_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// PackEnd adds the @cell to end of the column. If @expand is false, then the
// @cell is allocated no more space than it needs. Any unused space is divided
// evenly between cells for which @expand is true.
	func (t TreeViewColumn) PackEnd(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_tree_view_column_pack_end(_arg0, _arg1, _arg2)
}
	
	// PackStart packs the @cell into the beginning of the column. If @expand is
// false, then the @cell is allocated no more space than it needs. Any unused
// space is divided evenly between cells for which @expand is true.
	func (t TreeViewColumn) PackStart(cell CellRendererClass, expand bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkCellRenderer // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkCellRenderer)(unsafe.Pointer(cell.Native()))
if expand { _arg2 = C.TRUE }

C.gtk_tree_view_column_pack_start(_arg0, _arg1, _arg2)
}
	
	// QueueResize flags the column, and the cell renderers added to this column, to
// have their sizes renegotiated.
	func (t TreeViewColumn) QueueResize()  {
var _arg0 *C.GtkTreeViewColumn // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))

C.gtk_tree_view_column_queue_resize(_arg0)
}
	
	// SetAlignment sets the alignment of the title or custom widget inside the
// column header. The alignment determines its location inside the button -- 0.0
// for left, 0.5 for center, 1.0 for right.
	func (t TreeViewColumn) SetAlignment(xalign float32)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.float // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.float)(xalign)

C.gtk_tree_view_column_set_alignment(_arg0, _arg1)
}
	
	// SetClickable sets the header to be active if @clickable is true. When the
// header is active, then it can take keyboard focus, and can be clicked.
	func (t TreeViewColumn) SetClickable(clickable bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if clickable { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_clickable(_arg0, _arg1)
}
	
	// SetExpand sets the column to take available extra space. This space is shared
// equally amongst all columns that have the expand set to true. If no column
// has this option set, then the last column gets all extra space. By default,
// every column is created with this false.
// 
// Along with fixed-width, the expand property changes when the column is
// resized by the user.
	func (t TreeViewColumn) SetExpand(expand bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_expand(_arg0, _arg1)
}
	
	// SetFixedWidth: if @fixed_width is not -1, sets the fixed width of
// @tree_column; otherwise unsets it. The effective value of @fixed_width is
// clamped between the minimum and maximum width of the column; however, the
// value stored in the fixed-width property is not clamped. If the column
// sizing is K_TREE_VIEW_COLUMN_GROW_ONLY or K_TREE_VIEW_COLUMN_AUTOSIZE,
// setting a fixed width overrides the automatically calculated width. Note that
// @fixed_width is only a hint to GTK; the width actually allocated to the
// column may be greater or less than requested.
// 
// Along with expand, the fixed-width property changes when the column is
// resized by the user.
	func (t TreeViewColumn) SetFixedWidth(fixedWidth int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(fixedWidth)

C.gtk_tree_view_column_set_fixed_width(_arg0, _arg1)
}
	
	// SetMaxWidth sets the maximum width of the @tree_column. If @max_width is -1,
// then the maximum width is unset. Note, the column can actually be wider than
// max width if its the last column in a view. In this case, the column expands
// to fill any extra space.
	func (t TreeViewColumn) SetMaxWidth(maxWidth int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(maxWidth)

C.gtk_tree_view_column_set_max_width(_arg0, _arg1)
}
	
	// SetMinWidth sets the minimum width of the @tree_column. If @min_width is -1,
// then the minimum width is unset.
	func (t TreeViewColumn) SetMinWidth(minWidth int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(minWidth)

C.gtk_tree_view_column_set_min_width(_arg0, _arg1)
}
	
	// SetReorderable: if @reorderable is true, then the column can be reordered by
// the end user dragging the header.
	func (t TreeViewColumn) SetReorderable(reorderable bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if reorderable { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_reorderable(_arg0, _arg1)
}
	
	// SetResizable: if @resizable is true, then the user can explicitly resize the
// column by grabbing the outer edge of the column button. If resizable is true
// and sizing mode of the column is K_TREE_VIEW_COLUMN_AUTOSIZE, then the sizing
// mode is changed to K_TREE_VIEW_COLUMN_GROW_ONLY.
	func (t TreeViewColumn) SetResizable(resizable bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if resizable { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_resizable(_arg0, _arg1)
}
	
	// SetSizing sets the growth behavior of @tree_column to @type.
	func (t TreeViewColumn) SetSizing(typ TreeViewColumnSizing)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.GtkTreeViewColumnSizing // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkTreeViewColumnSizing)(typ)

C.gtk_tree_view_column_set_sizing(_arg0, _arg1)
}
	
	// SetSortColumnID sets the logical @sort_column_id that this column sorts on
// when this column is selected for sorting. Doing so makes the column header
// clickable.
	func (t TreeViewColumn) SetSortColumnID(sortColumnId int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(sortColumnId)

C.gtk_tree_view_column_set_sort_column_id(_arg0, _arg1)
}
	
	// SetSortIndicator: call this function with a @setting of true to display an
// arrow in the header button indicating the column is sorted. Call
// gtk_tree_view_column_set_sort_order() to change the direction of the arrow.
	func (t TreeViewColumn) SetSortIndicator(setting bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_sort_indicator(_arg0, _arg1)
}
	
	// SetSortOrder changes the appearance of the sort indicator.
// 
// This does not actually sort the model. Use
// gtk_tree_view_column_set_sort_column_id() if you want automatic sorting
// support. This function is primarily for custom sorting behavior, and should
// be used in conjunction with gtk_tree_sortable_set_sort_column_id() to do
// that. For custom models, the mechanism will vary.
// 
// The sort indicator changes direction to indicate normal sort or reverse sort.
// Note that you must have the sort indicator enabled to see anything when
// calling this function; see gtk_tree_view_column_set_sort_indicator().
	func (t TreeViewColumn) SetSortOrder(order SortType)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.GtkSortType // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.GtkSortType)(order)

C.gtk_tree_view_column_set_sort_order(_arg0, _arg1)
}
	
	// SetSpacing sets the spacing field of @tree_column, which is the number of
// pixels to place between cell renderers packed into it.
	func (t TreeViewColumn) SetSpacing(spacing int)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (C.int)(spacing)

C.gtk_tree_view_column_set_spacing(_arg0, _arg1)
}
	
	// SetTitle sets the title of the @tree_column. If a custom widget has been set,
// then this value is ignored.
	func (t TreeViewColumn) SetTitle(title string)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.char // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_tree_view_column_set_title(_arg0, _arg1)
}
	
	// SetVisible sets the visibility of @tree_column.
	func (t TreeViewColumn) SetVisible(visible bool)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_tree_view_column_set_visible(_arg0, _arg1)
}
	
	// SetWidget sets the widget in the header to be @widget. If widget is nil, then
// the header button is set with a Label set to the title of @tree_column.
	func (t TreeViewColumn) SetWidget(widget WidgetClass)  {
var _arg0 *C.GtkTreeViewColumn // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkTreeViewColumn)(unsafe.Pointer(t.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_tree_view_column_set_widget(_arg0, _arg1)
}
	


	// Video: `GtkVideo` is a widget to show a `GtkMediaStream` with media controls.
// 
// !An example GtkVideo (video.png)
// 
// The controls are available separately as [class@Gtk.MediaControls]. If you
// just want to display a video without controls, you can treat it like any
// other paintable and for example put it into a [class@Gtk.Picture].
// 
// `GtkVideo` aims to cover use cases such as previews, embedded animations,
// etc. It supports autoplay, looping, and simple media controls. It does not
// have support for video overlays, multichannel audio, device selection, or
// input. If you are writing a full-fledged video player, you may want to use
// the [class@Gdk.Paintable] API and a media framework such as Gstreamer
// directly.
	type Video struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// VideoClass is an interface that the Video class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VideoClass interface {
		gextras.Objector
		_video()
	}

	func (Video) _video() {}

	
	func marshalVideo(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVideo(obj), nil
	}
	

	
	// NewVideo creates a new empty `GtkVideo`.
	func NewVideo() Video {
var _cret *C.GtkWidget // in

_cret = C.gtk_video_new()


var _video Video // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_video = Video{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _video
}
	
	// NewVideoForFile creates a `GtkVideo` to play back the given @file.
	func NewVideoForFile(file gio.File) Video {
var _arg1 *C.GFile // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

_cret = C.gtk_video_new_for_file(_arg1)


var _video Video // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_video = Video{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _video
}
	
	// NewVideoForFilename creates a `GtkVideo` to play back the given @filename.
// 
// This is a utility function that calls [ctor@Gtk.Video.new_for_file], See that
// function for details.
	func NewVideoForFilename(filename string) Video {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_video_new_for_filename(_arg1)


var _video Video // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_video = Video{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _video
}
	
	// NewVideoForMediaStream creates a `GtkVideo` to play back the given @stream.
	func NewVideoForMediaStream(stream MediaStreamClass) Video {
var _arg1 *C.GtkMediaStream // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

_cret = C.gtk_video_new_for_media_stream(_arg1)


var _video Video // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_video = Video{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _video
}
	
	// NewVideoForResource creates a `GtkVideo` to play back the resource at the
// given @resource_path.
// 
// This is a utility function that calls [ctor@Gtk.Video.new_for_file].
	func NewVideoForResource(resourcePath string) Video {
var _arg1 *C.char // out
var _cret *C.GtkWidget // in

_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_video_new_for_resource(_arg1)


var _video Video // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_video = Video{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _video
}
	

	
	// Autoplay returns true if videos have been set to loop.
	func (s Video) Autoplay() bool {
var _arg0 *C.GtkVideo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

_cret = C.gtk_video_get_autoplay(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// File gets the file played by @self or nil if not playing back a file.
	func (s Video) File() gio.File {
var _arg0 *C.GtkVideo // out
var _cret *C.GFile // in

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

_cret = C.gtk_video_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// Loop returns true if videos have been set to loop.
	func (s Video) Loop() bool {
var _arg0 *C.GtkVideo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

_cret = C.gtk_video_get_loop(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MediaStream gets the media stream managed by @self or nil if none.
	func (s Video) MediaStream() MediaStream {
var _arg0 *C.GtkVideo // out
var _cret *C.GtkMediaStream // in

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))

_cret = C.gtk_video_get_media_stream(_arg0)


var _mediaStream MediaStream // out

_mediaStream = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(MediaStream)

return _mediaStream
}
	
	// SetAutoplay sets whether @self automatically starts playback when it becomes
// visible or when a new file gets loaded.
	func (s Video) SetAutoplay(autoplay bool)  {
var _arg0 *C.GtkVideo // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
if autoplay { _arg1 = C.TRUE }

C.gtk_video_set_autoplay(_arg0, _arg1)
}
	
	// SetFile makes @self play the given @file.
	func (s Video) SetFile(file gio.File)  {
var _arg0 *C.GtkVideo // out
var _arg1 *C.GFile // out

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))

C.gtk_video_set_file(_arg0, _arg1)
}
	
	// SetFilename makes @self play the given @filename.
// 
// This is a utility function that calls gtk_video_set_file(),
	func (s Video) SetFilename(filename string)  {
var _arg0 *C.GtkVideo // out
var _arg1 *C.char // out

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(filename))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_video_set_filename(_arg0, _arg1)
}
	
	// SetLoop sets whether new files loaded by @self should be set to loop.
	func (s Video) SetLoop(loop bool)  {
var _arg0 *C.GtkVideo // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
if loop { _arg1 = C.TRUE }

C.gtk_video_set_loop(_arg0, _arg1)
}
	
	// SetMediaStream sets the media stream to be played back.
// 
// @self will take full control of managing the media stream. If you want to
// manage a media stream yourself, consider using a [class@Gtk.Picture] for
// display.
// 
// If you want to display a file, consider using [method@Gtk.Video.set_file]
// instead.
	func (s Video) SetMediaStream(stream MediaStreamClass)  {
var _arg0 *C.GtkVideo // out
var _arg1 *C.GtkMediaStream // out

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkMediaStream)(unsafe.Pointer(stream.Native()))

C.gtk_video_set_media_stream(_arg0, _arg1)
}
	
	// SetResource makes @self play the resource at the given @resource_path.
// 
// This is a utility function that calls [method@Gtk.Video.set_file].
	func (s Video) SetResource(resourcePath string)  {
var _arg0 *C.GtkVideo // out
var _arg1 *C.char // out

_arg0 = (*C.GtkVideo)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(resourcePath))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_video_set_resource(_arg0, _arg1)
}
	


	// Viewport: `GtkViewport` implements scrollability for widgets that lack their
// own scrolling capabilities.
// 
// Use `GtkViewport` to scroll child widgets such as `GtkGrid`, `GtkBox`, and so
// on.
// 
// The `GtkViewport` will start scrolling content only if allocated less than
// the child widgets minimum size in a given orientation.
// 
// 
// CSS nodes
// 
// `GtkViewport` has a single CSS node with name `viewport`.
// 
// 
// Accessibility
// 
// `GtkViewport` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type Viewport struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Scrollable
		
	}

	// ViewportClass is an interface that the Viewport class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type ViewportClass interface {
		gextras.Objector
		_viewport()
	}

	func (Viewport) _viewport() {}

	
	func marshalViewport(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapViewport(obj), nil
	}
	

	
	// NewViewport creates a new `GtkViewport`.
// 
// The new viewport uses the given adjustments, or default adjustments if none
// are given.
	func NewViewport(hadjustment AdjustmentClass, vadjustment AdjustmentClass) Viewport {
var _arg1 *C.GtkAdjustment // out
var _arg2 *C.GtkAdjustment // out
var _cret *C.GtkWidget // in

_arg1 = (*C.GtkAdjustment)(unsafe.Pointer(hadjustment.Native()))
_arg2 = (*C.GtkAdjustment)(unsafe.Pointer(vadjustment.Native()))

_cret = C.gtk_viewport_new(_arg1, _arg2)


var _viewport Viewport // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_viewport = Viewport{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Scrollable: Scrollable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _viewport
}
	

	
	// Child gets the child widget of @viewport.
	func (v Viewport) Child() Widget {
var _arg0 *C.GtkViewport // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

_cret = C.gtk_viewport_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// ScrollToFocus gets whether the viewport is scrolling to keep the focused
// child in view.
	func (v Viewport) ScrollToFocus() bool {
var _arg0 *C.GtkViewport // out
var _cret C.gboolean // in

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))

_cret = C.gtk_viewport_get_scroll_to_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetChild sets the child widget of @viewport.
	func (v Viewport) SetChild(child WidgetClass)  {
var _arg0 *C.GtkViewport // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_viewport_set_child(_arg0, _arg1)
}
	
	// SetScrollToFocus sets whether the viewport should automatically scroll to
// keep the focused child in view.
	func (v Viewport) SetScrollToFocus(scrollToFocus bool)  {
var _arg0 *C.GtkViewport // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkViewport)(unsafe.Pointer(v.Native()))
if scrollToFocus { _arg1 = C.TRUE }

C.gtk_viewport_set_scroll_to_focus(_arg0, _arg1)
}
	


	// VolumeButton: `GtkVolumeButton` is a `GtkScaleButton` subclass tailored for
// volume control.
// 
// !An example GtkVolumeButton (volumebutton.png)
	type VolumeButton struct {
		ScaleButton
		Accessible
		Buildable
		ConstraintTarget
		Orientable
		
	}

	// VolumeButtonClass is an interface that the VolumeButton class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type VolumeButtonClass interface {
		gextras.Objector
		_volumeButton()
	}

	func (VolumeButton) _volumeButton() {}

	
	func marshalVolumeButton(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapVolumeButton(obj), nil
	}
	

	
	// NewVolumeButton creates a `GtkVolumeButton`.
// 
// The button has a range between 0.0 and 1.0, with a stepping of 0.02. Volume
// values can be obtained and modified using the functions from
// [class@Gtk.ScaleButton].
	func NewVolumeButton() VolumeButton {
var _cret *C.GtkWidget // in

_cret = C.gtk_volume_button_new()


var _volumeButton VolumeButton // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_volumeButton = VolumeButton{
ScaleButton: ScaleButton{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Orientable: Orientable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _volumeButton
}
	

	


	// Widget: the base class for all widgets.
// 
// `GtkWidget` is the base class all widgets in GTK derive from. It manages the
// widget lifecycle, layout, states and style.
// 
// 
// Height-for-width Geometry Management
// 
// GTK uses a height-for-width (and width-for-height) geometry management
// system. Height-for-width means that a widget can change how much vertical
// space it needs, depending on the amount of horizontal space that it is given
// (and similar for width-for-height). The most common example is a label that
// reflows to fill up the available width, wraps to fewer lines, and therefore
// needs less height.
// 
// Height-for-width geometry management is implemented in GTK by way of two
// virtual methods:
// 
// - [vfunc@Gtk.Widget.get_request_mode] - [vfunc@Gtk.Widget.measure]
// 
// There are some important things to keep in mind when implementing
// height-for-width and when using it in widget implementations.
// 
// If you implement a direct `GtkWidget` subclass that supports height-for-width
// or width-for-height geometry management for itself or its child widgets, the
// [vfunc@Gtk.Widget.get_request_mode] virtual function must be implemented as
// well and return the widget's preferred request mode. The default
// implementation of this virtual function returns
// GTK_SIZE_REQUEST_CONSTANT_SIZE, which means that the widget will only ever
// get -1 passed as the for_size value to its [vfunc@Gtk.Widget.measure]
// implementation.
// 
// The geometry management system will query a widget hierarchy in only one
// orientation at a time. When widgets are initially queried for their minimum
// sizes it is generally done in two initial passes in the
// [enum@Gtk.SizeRequestMode] chosen by the toplevel.
// 
// For example, when queried in the normal GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH
// mode:
// 
// First, the default minimum and natural width for each widget in the interface
// will be computed using [id@gtk_widget_measure] with an orientation of
// GTK_ORIENTATION_HORIZONTAL and a for_size of -1. Because the preferred widths
// for each widget depend on the preferred widths of their children, this
// information propagates up the hierarchy, and finally a minimum and natural
// width is determined for the entire toplevel. Next, the toplevel will use the
// minimum width to query for the minimum height contextual to that width using
// [id@gtk_widget_measure] with an orientation of GTK_ORIENTATION_VERTICAL and a
// for_size of the just computed width. This will also be a highly recursive
// operation. The minimum height for the minimum width is normally used to set
// the minimum size constraint on the toplevel.
// 
// After the toplevel window has initially requested its size in both dimensions
// it can go on to allocate itself a reasonable size (or a size previously
// specified with [method@Gtk.Window.set_default_size]). During the recursive
// allocation process its important to note that request cycles will be
// recursively executed while widgets allocate their children. Each widget, once
// allocated a size, will go on to first share the space in one orientation
// among its children and then request each child's height for its target
// allocated width or its width for allocated height, depending. In this way a
// `GtkWidget` will typically be requested its size a number of times before
// actually being allocated a size. The size a widget is finally allocated can
// of course differ from the size it has requested. For this reason, `GtkWidget`
// caches a small number of results to avoid re-querying for the same sizes in
// one allocation cycle.
// 
// If a widget does move content around to intelligently use up the allocated
// size then it must support the request in both `GtkSizeRequestMode`s even if
// the widget in question only trades sizes in a single orientation.
// 
// For instance, a [class@Gtk.Label] that does height-for-width word wrapping
// will not expect to have [vfunc@Gtk.Widget.measure] with an orientation of
// GTK_ORIENTATION_VERTICAL called because that call is specific to a
// width-for-height request. In this case the label must return the height
// required for its own minimum possible width. By following this rule any
// widget that handles height-for-width or width-for-height requests will always
// be allocated at least enough space to fit its own content.
// 
// Here are some examples of how a GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH widget
// generally deals with width-for-height requests:
// 
// `c static void foo_widget_measure (GtkWidget *widget, GtkOrientation
// orientation, int for_size, int *minimum_size, int *natural_size, int
// *minimum_baseline, int *natural_baseline) { if (orientation ==
// GTK_ORIENTATION_HORIZONTAL) { // Calculate minimum and natural width } else
// // VERTICAL { if (i_am_in_height_for_width_mode) { int min_width, dummy;
// 
//          // First, get the minimum width of our widget
//          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_HORIZONTAL, -1,
//                                                  &min_width, &dummy, &dummy, &dummy);
// 
//          // Now use the minimum width to retrieve the minimum and natural height to display
//          // that width.
//          GTK_WIDGET_GET_CLASS (widget)->measure (widget, GTK_ORIENTATION_VERTICAL, min_width,
//                                                  minimum_size, natural_size, &dummy, &dummy);
//        }
//      else
//        {
//          // ... some widgets do both.
//        }
//    }
// 
// } `
// 
// Often a widget needs to get its own request during size request or
// allocation. For example, when computing height it may need to also compute
// width. Or when deciding how to use an allocation, the widget may need to know
// its natural size. In these cases, the widget should be careful to call its
// virtual methods directly, like in the code example above.
// 
// It will not work to use the wrapper function [method@Gtk.Widget.measure]
// inside your own [vfunc@Gtk.Widget.size_allocate] implementation. These return
// a request adjusted by [class@Gtk.SizeGroup], the widget's align and expand
// flags, as well as its CSS style.
// 
// If a widget used the wrappers inside its virtual method implementations, then
// the adjustments (such as widget margins) would be applied twice. GTK
// therefore does not allow this and will warn if you try to do it.
// 
// Of course if you are getting the size request for another widget, such as a
// child widget, you must use [id@gtk_widget_measure]; otherwise, you would not
// properly consider widget margins, [class@Gtk.SizeGroup], and so forth.
// 
// GTK also supports baseline vertical alignment of widgets. This means that
// widgets are positioned such that the typographical baseline of widgets in the
// same row are aligned. This happens if a widget supports baselines, has a
// vertical alignment of GTK_ALIGN_BASELINE, and is inside a widget that
// supports baselines and has a natural row that it aligns to the baseline, or
// a baseline assigned to it by the grandparent.
// 
// Baseline alignment support for a widget is also done by the
// [vfunc@Gtk.Widget.measure] virtual function. It allows you to report both a
// minimum and natural size.
// 
// If a widget ends up baseline aligned it will be allocated all the space in
// the parent as if it was GTK_ALIGN_FILL, but the selected baseline can be
// found via [id@gtk_widget_get_allocated_baseline]. If the baseline has a value
// other than -1 you need to align the widget such that the baseline appears at
// the position.
// 
// 
// GtkWidget as GtkBuildable
// 
// The `GtkWidget` implementation of the `GtkBuildable` interface supports
// various custom elements to specify additional aspects of widgets that are not
// directly expressed as properties.
// 
// If the widget uses a [class@Gtk.LayoutManager], `GtkWidget` supports a custom
// `<layout>` element, used to define layout properties:
// 
// `xml <object class="GtkGrid" id="my_grid"> <child> <object class="GtkLabel"
// id="label1"> <property name="label">Description</property> <layout> <property
// name="column">0</property> <property name="row">0</property> <property
// name="row-span">1</property> <property name="column-span">1</property>
// </layout> </object> </child> <child> <object class="GtkEntry"
// id="description_entry"> <layout> <property name="column">1</property>
// <property name="row">0</property> <property name="row-span">1</property>
// <property name="column-span">1</property> </layout> </object> </child>
// </object> `
// 
// `GtkWidget` allows style information such as style classes to be associated
// with widgets, using the custom `<style>` element:
// 
// `xml <object class="GtkButton" id="button1"> <style> <class
// name="my-special-button-class"/> <class name="dark-button"/> </style>
// </object> `
// 
// `GtkWidget` allows defining accessibility information, such as properties,
// relations, and states, using the custom `<accessibility>` element:
// 
// `xml <object class="GtkButton" id="button1"> <accessibility> <property
// name="label">Download</property> <relation
// name="labelled-by">label1</relation> </accessibility> </object> `
// 
// 
// Building composite widgets from template XML
// 
// `GtkWidget `exposes some facilities to automate the procedure of creating
// composite widgets using "templates".
// 
// To create composite widgets with `GtkBuilder` XML, one must associate the
// interface description with the widget class at class initialization time
// using [method@Gtk.WidgetClass.set_template].
// 
// The interface description semantics expected in composite template
// descriptions is slightly different from regular [class@Gtk.Builder] XML.
// 
// Unlike regular interface descriptions, [method@Gtk.WidgetClass.set_template]
// will expect a `<template>` tag as a direct child of the toplevel
// `<interface>` tag. The `<template>` tag must specify the class attribute
// which must be the type name of the widget. Optionally, the parent attribute
// may be specified to specify the direct parent type of the widget type, this
// is ignored by `GtkBuilder` but required for UI design tools like Glade
// (https://glade.gnome.org/) to introspect what kind of properties and internal
// children exist for a given type when the actual type does not exist.
// 
// The XML which is contained inside the `<template>` tag behaves as if it were
// added to the `<object>` tag defining the widget itself. You may set
// properties on a widget by inserting `<property>` tags into the `<template>`
// tag, and also add `<child>` tags to add children and extend a widget in the
// normal way you would with `<object>` tags.
// 
// Additionally, `<object>` tags can also be added before and after the initial
// `<template>` tag in the normal way, allowing one to define auxiliary objects
// which might be referenced by other widgets declared as children of the
// `<template>` tag.
// 
// An example of a template definition:
// 
// `xml <interface> <template class="FooWidget" parent="GtkBox"> <property
// name="orientation">horizontal</property> <property
// name="spacing">4</property> <child> <object class="GtkButton"
// id="hello_button"> <property name="label">Hello World</property> <signal
// name="clicked" handler="hello_button_clicked" object="FooWidget"
// swapped="yes"/> </object> </child> <child> <object class="GtkButton"
// id="goodbye_button"> <property name="label">Goodbye World</property>
// </object> </child> </template> </interface> `
// 
// Typically, you'll place the template fragment into a file that is bundled
// with your project, using `GResource`. In order to load the template, you need
// to call [method@Gtk.WidgetClass.set_template_from_resource] from the class
// initialization of your `GtkWidget` type:
// 
// `c static void foo_widget_class_init (FooWidgetClass *klass) { // ...
// 
//    gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
//                                                 "/com/example/ui/foowidget.ui");
// 
// } `
// 
// You will also need to call [method@Gtk.Widget.init_template] from the
// instance initialization function:
// 
// `c static void foo_widget_init (FooWidget *self) { // ...
// gtk_widget_init_template (GTK_WIDGET (self)); } `
// 
// You can access widgets defined in the template using the
// [id@gtk_widget_get_template_child] function, but you will typically declare a
// pointer in the instance private data structure of your type using the same
// name as the widget in the template definition, and call
// [method@Gtk.WidgetClass.bind_template_child_full] (or one of its wrapper
// macros [func@Gtk.widget_class_bind_template_child] and
// [func@Gtk.widget_class_bind_template_child_private]) with that name, e.g.
// 
// `c typedef struct { GtkWidget *hello_button; GtkWidget *goodbye_button; }
// FooWidgetPrivate;
// 
// G_DEFINE_TYPE_WITH_PRIVATE (FooWidget, foo_widget, GTK_TYPE_BOX)
// 
// static void foo_widget_class_init (FooWidgetClass *klass) { // ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui"); gtk_widget_class_bind_template_child_private
// (GTK_WIDGET_CLASS (klass), FooWidget, hello_button);
// gtk_widget_class_bind_template_child_private (GTK_WIDGET_CLASS (klass),
// FooWidget, goodbye_button); }
// 
// static void foo_widget_init (FooWidget *widget) {
// 
// } `
// 
// You can also use [method@Gtk.WidgetClass.bind_template_callback_full] (or is
// wrapper macro [func@Gtk.widget_class_bind_template_callback]) to connect a
// signal callback defined in the template with a function visible in the scope
// of the class, e.g.
// 
// `c // the signal handler has the instance and user data swapped // because
// of the swapped="yes" attribute in the template XML static void
// hello_button_clicked (FooWidget *self, GtkButton *button) { g_print ("Hello,
// world!\n"); }
// 
// static void foo_widget_class_init (FooWidgetClass *klass) { // ...
// gtk_widget_class_set_template_from_resource (GTK_WIDGET_CLASS (klass),
// "/com/example/ui/foowidget.ui"); gtk_widget_class_bind_template_callback
// (GTK_WIDGET_CLASS (klass), hello_button_clicked); } `
	type Widget struct {
		externglib.InitiallyUnowned
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// WidgetClass is an interface that the Widget class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WidgetClass interface {
		gextras.Objector
		_widget()
	}

	func (Widget) _widget() {}

	
	func marshalWidget(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWidget(obj), nil
	}
	

	

	
	// ActionSetEnabled: enable or disable an action installed with
// gtk_widget_class_install_action().
	func (w Widget) ActionSetEnabled(actionName string, enabled bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(actionName))
defer C.free(unsafe.Pointer(_arg1))
if enabled { _arg2 = C.TRUE }

C.gtk_widget_action_set_enabled(_arg0, _arg1, _arg2)
}
	
	// Activate: for widgets that can be activated (buttons, menu items, etc.)
// this function activates them.
// 
// The activation will emit the signal set using
// gtk_widget_class_set_activate_signal() during class initialization.
// 
// Activation is what happens when you press Enter on a widget during key
// navigation.
// 
// If you wish to handle the activation keybinding yourself, it is recommended
// to use gtk_widget_class_add_shortcut() with an action created with
// gtk_signal_action_new().
// 
// If @widget isn't activatable, the function returns false.
	func (w Widget) Activate() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_activate(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ActivateActionVariant looks up the action in the action groups associated
// with @widget and its ancestors, and activates it.
// 
// If the action is in an action group added with
// [method@Gtk.Widget.insert_action_group], the @name is expected to be prefixed
// with the prefix that was used when the group was inserted.
// 
// The arguments must match the actions expected parameter type, as returned by
// `g_action_get_parameter_type()`.
	func (w Widget) ActivateActionVariant(name string, args *glib.Variant) bool {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out
var _arg2 *C.GVariant // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GVariant)(unsafe.Pointer(args.Native()))

_cret = C.gtk_widget_activate_action_variant(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ActivateDefault activates the `default.activate` action from @widget.
	func (w Widget) ActivateDefault()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_activate_default(_arg0)
}
	
	// AddController adds @controller to @widget so that it will receive events.
// 
// You will usually want to call this function right after creating any kind of
// [class@Gtk.EventController].
	func (w Widget) AddController(controller EventControllerClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkEventController // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkEventController)(unsafe.Pointer(controller.Native()))

C.gtk_widget_add_controller(_arg0, _arg1)
}
	
	// AddCSSClass adds a style class to @widget.
// 
// After calling this function, the widgets style will match for @css_class,
// according to CSS matching rules.
// 
// Use [method@Gtk.Widget.remove_css_class] to remove the style again.
	func (w Widget) AddCSSClass(cssClass string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(cssClass))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_add_css_class(_arg0, _arg1)
}
	
	// AddMnemonicLabel adds a widget to the list of mnemonic labels for this
// widget.
// 
// See [method@Gtk.Widget.list_mnemonic_labels]. Note the list of mnemonic
// labels for the widget is cleared when the widget is destroyed, so the caller
// must make sure to update its internal state at this point as well, by using a
// connection to the [signal@Gtk.Widget::destroy] signal or a weak notifier.
	func (w Widget) AddMnemonicLabel(label WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

C.gtk_widget_add_mnemonic_label(_arg0, _arg1)
}
	
	// Allocate: this function is only used by `GtkWidget` subclasses, to assign a
// size, position and (optionally) baseline to their child widgets.
// 
// In this function, the allocation and baseline may be adjusted. The given
// allocation will be forced to be bigger than the widget's minimum size, as
// well as at least 00 in size.
// 
// For a version that does not take a transform, see
// [method@Gtk.Widget.size_allocate].
	func (w Widget) Allocate(width int, height int, baseline int, transform *gsk.Transform)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 *C.GskTransform // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)
_arg3 = (C.int)(baseline)
_arg4 = (*C.GskTransform)(unsafe.Pointer(transform.Native()))

C.gtk_widget_allocate(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// ChildFocus: called by widgets as the user moves around the window using
// keyboard shortcuts.
// 
// The @direction argument indicates what kind of motion is taking place (up,
// down, left, right, tab forward, tab backward).
// 
// This function calls the [vfunc@Gtk.Widget.focus] virtual function; widgets
// can override the virtual function in order to implement appropriate focus
// behavior.
// 
// The default `focus()` virtual function for a widget should return `TRUE` if
// moving in @direction left the focus on a focusable location inside that
// widget, and `FALSE` if moving in @direction moved the focus outside the
// widget. When returning `TRUE`, widgets normallycall
// [method@Gtk.Widget.grab_focus] to place the focus accordingly; when returning
// `FALSE`, they dont modify the current focus location.
// 
// This function is used by custom widget implementations; if you're writing an
// app, youd use [method@Gtk.Widget.grab_focus] to move the focus to a
// particular widget.
	func (w Widget) ChildFocus(direction DirectionType) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkDirectionType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkDirectionType)(direction)

_cret = C.gtk_widget_child_focus(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ComputeBounds computes the bounds for @widget in the coordinate space of
// @target.
// 
// FIXME: Explain what "bounds" are.
// 
// If the operation is successful, true is returned. If @widget has no bounds or
// the bounds cannot be expressed in @target's coordinate space (for example if
// both widgets are in different windows), false is returned and @bounds is set
// to the zero rectangle.
// 
// It is valid for @widget and @target to be the same widget.
	func (w Widget) ComputeBounds(target WidgetClass) (graphene.Rect, bool) {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _outBounds graphene.Rect
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

_cret = C.gtk_widget_compute_bounds(_arg0, _arg1, (*C.graphene_rect_t)(unsafe.Pointer(&_outBounds)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _outBounds, _ok
}
	
	// ComputeExpand computes whether a container should give this widget extra
// space when possible.
// 
// Containers should check this, rather than looking at
// [method@Gtk.Widget.get_hexpand] or [method@Gtk.Widget.get_vexpand].
// 
// This function already checks whether the widget is visible, so visibility
// does not need to be checked separately. Non-visible widgets are not expanded.
// 
// The computed expand value uses either the expand setting explicitly set on
// the widget itself, or, if none has been explicitly set, the widget may expand
// if some of its children do.
	func (w Widget) ComputeExpand(orientation Orientation) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkOrientation // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_widget_compute_expand(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ComputePoint translates the given @point in @widget's coordinates to
// coordinates relative to @targets coordinate system.
// 
// In order to perform this operation, both widgets must share a common
// ancestor.
	func (w Widget) ComputePoint(target WidgetClass, point *graphene.Point) (graphene.Point, bool) {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.graphene_point_t // out
var _outPoint graphene.Point
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))
_arg2 = (*C.graphene_point_t)(unsafe.Pointer(point.Native()))

_cret = C.gtk_widget_compute_point(_arg0, _arg1, _arg2, (*C.graphene_point_t)(unsafe.Pointer(&_outPoint)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _outPoint, _ok
}
	
	// ComputeTransform computes a matrix suitable to describe a transformation from
// @widget's coordinate system into @target's coordinate system.
	func (w Widget) ComputeTransform(target WidgetClass) (graphene.Matrix, bool) {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _outTransform graphene.Matrix
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(target.Native()))

_cret = C.gtk_widget_compute_transform(_arg0, _arg1, (*C.graphene_matrix_t)(unsafe.Pointer(&_outTransform)))



var _ok bool // out


if _cret != 0 { _ok = true }

return _outTransform, _ok
}
	
	// Contains tests if the point at (@x, @y) is contained in @widget.
// 
// The coordinates for (@x, @y) must be in widget coordinates, so (0, 0) is
// assumed to be the top left of @widget's content area.
	func (w Widget) Contains(x float64, y float64) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.double // out
var _arg2 C.double // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.double)(x)
_arg2 = (C.double)(y)

_cret = C.gtk_widget_contains(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CreatePangoContext creates a new `PangoContext` with the appropriate font
// map, font options, font description, and base direction for drawing text for
// this widget.
// 
// See also [method@Gtk.Widget.get_pango_context].
	func (w Widget) CreatePangoContext() pango.Context {
var _arg0 *C.GtkWidget // out
var _cret *C.PangoContext // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_create_pango_context(_arg0)


var _context pango.Context // out

_context = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Context)

return _context
}
	
	// CreatePangoLayout creates a new `PangoLayout` with the appropriate font map,
// font description, and base direction for drawing text for this widget.
// 
// If you keep a `PangoLayout` created in this way around, you need to re-create
// it when the widget `PangoContext` is replaced. This can be tracked by
// listening to changes of the [property@Gtk.Widget:root] property on the
// widget.
	func (w Widget) CreatePangoLayout(text string) pango.Layout {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out
var _cret *C.PangoLayout // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_widget_create_pango_layout(_arg0, _arg1)


var _layout pango.Layout // out

_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(pango.Layout)

return _layout
}
	
	// DragCheckThreshold checks to see if a drag movement has passed the GTK drag
// threshold.
	func (w Widget) DragCheckThreshold(startX int, startY int, currentX int, currentY int) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // out
var _arg2 C.int // out
var _arg3 C.int // out
var _arg4 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(startX)
_arg2 = (C.int)(startY)
_arg3 = (C.int)(currentX)
_arg4 = (C.int)(currentY)

_cret = C.gtk_drag_check_threshold(_arg0, _arg1, _arg2, _arg3, _arg4)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ErrorBell notifies the user about an input-related error on this widget.
// 
// If the [property@Gtk.Settings:gtk-error-bell] setting is true, it calls
// [method@Gdk.Surface.beep], otherwise it does nothing.
// 
// Note that the effect of [method@Gdk.Surface.beep] can be configured in many
// ways, depending on the windowing backend and the desktop environment or
// window manager that is used.
	func (w Widget) ErrorBell()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_error_bell(_arg0)
}
	
	// AllocatedBaseline returns the baseline that has currently been allocated to
// @widget.
// 
// This function is intended to be used when implementing handlers for the
// `GtkWidget`Class.snapshot() function, and when allocating child widgets in
// `GtkWidget`Class.size_allocate().
	func (w Widget) AllocatedBaseline() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_allocated_baseline(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AllocatedHeight returns the height that has currently been allocated to
// @widget.
	func (w Widget) AllocatedHeight() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_allocated_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// AllocatedWidth returns the width that has currently been allocated to
// @widget.
	func (w Widget) AllocatedWidth() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_allocated_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Ancestor gets the first ancestor of @widget with type @widget_type.
// 
// For example, `gtk_widget_get_ancestor (widget, GTK_TYPE_BOX)` gets the first
// `GtkBox` thats an ancestor of @widget. No reference will be added to the
// returned widget; it should not be unreferenced.
// 
// Note that unlike [method@Gtk.Widget.is_ancestor], this function considers
// @widget to be an ancestor of itself.
	func (w Widget) Ancestor(widgetType externglib.Type) Widget {
var _arg0 *C.GtkWidget // out
var _arg1 C.GType // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = C.GType(widgetType)

_cret = C.gtk_widget_get_ancestor(_arg0, _arg1)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// CanFocus determines whether the input focus can enter @widget or any of its
// children.
// 
// See [method@Gtk.Widget.set_focusable].
	func (w Widget) CanFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_can_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanTarget queries whether @widget can be the target of pointer events.
	func (w Widget) CanTarget() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_can_target(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ChildVisible gets the value set with gtk_widget_set_child_visible().
// 
// If you feel a need to use this function, your code probably needs
// reorganization.
// 
// This function is only useful for container implementations and should never
// be called by an application.
	func (w Widget) ChildVisible() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_child_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Clipboard gets the clipboard object for @widget.
// 
// This is a utility function to get the clipboard object for the `GdkDisplay`
// that @widget is using.
// 
// Note that this function always works, even when @widget is not realized yet.
	func (w Widget) Clipboard() gdk.Clipboard {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkClipboard // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_clipboard(_arg0)


var _clipboard gdk.Clipboard // out

_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Clipboard)

return _clipboard
}
	
	// CSSClasses returns the list of style classes applied to @widget.
	func (w Widget) CSSClasses() []string {
var _arg0 *C.GtkWidget // out
var _cret **C.char

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_css_classes(_arg0)


var _utf8s []string

{
var i int
var z *C.char
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
defer C.free(unsafe.Pointer(src[i]))
}
}

return _utf8s
}
	
	// CSSName returns the CSS name that is used for @self.
	func (s Widget) CSSName() string {
var _arg0 *C.GtkWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))

_cret = C.gtk_widget_get_css_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Cursor queries the cursor set on @widget.
// 
// See [method@Gtk.Widget.set_cursor] for details.
	func (w Widget) Cursor() gdk.Cursor {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkCursor // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_cursor(_arg0)


var _cursor gdk.Cursor // out

_cursor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Cursor)

return _cursor
}
	
	// Direction gets the reading direction for a particular widget.
// 
// See [method@Gtk.Widget.set_direction].
	func (w Widget) Direction() TextDirection {
var _arg0 *C.GtkWidget // out
var _cret C.GtkTextDirection // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_direction(_arg0)


var _textDirection TextDirection // out

_textDirection = TextDirection(_cret)

return _textDirection
}
	
	// Display: get the `GdkDisplay` for the toplevel window associated with this
// widget.
// 
// This function can only be called after the widget has been added to a widget
// hierarchy with a `GtkWindow` at the top.
// 
// In general, you should only create display specific resources when a widget
// has been realized, and you should free those resources when the widget is
// unrealized.
	func (w Widget) Display() gdk.Display {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkDisplay // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_display(_arg0)


var _display gdk.Display // out

_display = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Display)

return _display
}
	
	// FirstChild returns the widgets first child.
// 
// This API is primarily meant for widget implementations.
	func (w Widget) FirstChild() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_first_child(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// FocusChild returns the current focus child of @widget.
	func (w Widget) FocusChild() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_focus_child(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// FocusOnClick returns whether the widget should grab focus when it is clicked
// with the mouse.
// 
// See [method@Gtk.Widget.set_focus_on_click].
	func (w Widget) FocusOnClick() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_focus_on_click(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Focusable determines whether @widget can own the input focus.
// 
// See [method@Gtk.Widget.set_focusable].
	func (w Widget) Focusable() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_focusable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// FontMap gets the font map of @widget.
// 
// See [method@Gtk.Widget.set_font_map].
	func (w Widget) FontMap() pango.FontMap {
var _arg0 *C.GtkWidget // out
var _cret *C.PangoFontMap // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_font_map(_arg0)


var _fontMap pango.FontMap // out

_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.FontMap)

return _fontMap
}
	
	// FontOptions returns the `cairo_font_options_t` used for Pango rendering.
// 
// When not set, the defaults font options for the `GdkDisplay` will be used.
	func (w Widget) FontOptions() *cairo.FontOptions {
var _arg0 *C.GtkWidget // out
var _cret *C.cairo_font_options_t // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_font_options(_arg0)


var _fontOptions *cairo.FontOptions // out

_fontOptions = *(**cairo.FontOptions)(unsafe.Pointer(&_cret))

return _fontOptions
}
	
	// FrameClock obtains the frame clock for a widget.
// 
// The frame clock is a global ticker that can be used to drive animations and
// repaints. The most common reason to get the frame clock is to call
// [method@Gdk.FrameClock.get_frame_time], in order to get a time to use for
// animating. For example you might record the start of the animation with an
// initial value from [method@Gdk.FrameClock.get_frame_time], and then update
// the animation by calling [method@Gdk.FrameClock.get_frame_time] again during
// each repaint.
// 
// [method@Gdk.FrameClock.request_phase] will result in a new frame on the
// clock, but wont necessarily repaint any widgets. To repaint a widget, you
// have to use [method@Gtk.Widget.queue_draw] which invalidates the widget (thus
// scheduling it to receive a draw on the next frame). gtk_widget_queue_draw()
// will also end up requesting a frame on the appropriate frame clock.
// 
// A widgets frame clock will not change while the widget is mapped.
// Reparenting a widget (which implies a temporary unmap) can change the
// widgets frame clock.
// 
// Unrealized widgets do not have a frame clock.
	func (w Widget) FrameClock() gdk.FrameClock {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkFrameClock // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_frame_clock(_arg0)


var _frameClock gdk.FrameClock // out

_frameClock = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.FrameClock)

return _frameClock
}
	
	// Halign gets the horizontal alignment of @widget.
// 
// For backwards compatibility reasons this method will never return
// GTK_ALIGN_BASELINE, but instead it will convert it to GTK_ALIGN_FILL.
// Baselines are not supported for horizontal alignment.
	func (w Widget) Halign() Align {
var _arg0 *C.GtkWidget // out
var _cret C.GtkAlign // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_halign(_arg0)


var _align Align // out

_align = Align(_cret)

return _align
}
	
	// HasTooltip returns the current value of the `has-tooltip` property.
	func (w Widget) HasTooltip() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_has_tooltip(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Height returns the content height of the widget.
// 
// This function returns the size passed to its size-allocate implementation,
// which is the size you should be using in GtkWidgetClass.snapshot().
// 
// For pointer events, see [method@Gtk.Widget.contains].
	func (w Widget) Height() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_height(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Hexpand gets whether the widget would like any available extra horizontal
// space.
// 
// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally receive
// the extra space. For example, a list or scrollable area or document in your
// window would often be set to expand.
// 
// Containers should use [method@Gtk.Widget.compute_expand] rather than this
// function, to see whether a widget, or any of its children, has the expand
// flag set. If any child of a widget wants to expand, the parent may ask to
// expand also.
// 
// This function only looks at the widgets own hexpand flag, rather than
// computing whether the entire widget tree rooted at this widget wants to
// expand.
	func (w Widget) Hexpand() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_hexpand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HexpandSet gets whether gtk_widget_set_hexpand() has been used to explicitly
// set the expand flag on this widget.
// 
// If [property@Gtk.Widget:hexpand] property is set, then it overrides any
// computed expand value based on child widgets. If `hexpand` is not set, then
// the expand value depends on whether any children of the widget would like to
// expand.
// 
// There are few reasons to use this function, but its here for completeness
// and consistency.
	func (w Widget) HexpandSet() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_hexpand_set(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LastChild returns the widgets last child.
// 
// This API is primarily meant for widget implementations.
	func (w Widget) LastChild() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_last_child(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// LayoutManager retrieves the layout manager used by @widget
// 
// See [method@Gtk.Widget.set_layout_manager].
	func (w Widget) LayoutManager() LayoutManager {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkLayoutManager // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_layout_manager(_arg0)


var _layoutManager LayoutManager // out

_layoutManager = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(LayoutManager)

return _layoutManager
}
	
	// Mapped: whether the widget is mapped.
	func (w Widget) Mapped() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_mapped(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// MarginBottom gets the bottom margin of @widget.
	func (w Widget) MarginBottom() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_bottom(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginEnd gets the end margin of @widget.
	func (w Widget) MarginEnd() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_end(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginStart gets the start margin of @widget.
	func (w Widget) MarginStart() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_start(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// MarginTop gets the top margin of @widget.
	func (w Widget) MarginTop() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_margin_top(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Name retrieves the name of a widget.
// 
// See [method@Gtk.Widget.set_name] for the significance of widget names.
	func (w Widget) Name() string {
var _arg0 *C.GtkWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// NativeWidget returns the `GtkNative` widget that contains @widget.
// 
// This function will return nil if the widget is not contained inside a widget
// tree with a native ancestor.
// 
// `GtkNative` widgets will return themselves here.
	func (w Widget) NativeWidget() Native {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkNative // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_native(_arg0)


var _native Native // out

_native = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Native)

return _native
}
	
	// NextSibling returns the widgets next sibling.
// 
// This API is primarily meant for widget implementations.
	func (w Widget) NextSibling() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_next_sibling(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// Opacity #Fetches the requested opacity for this widget.
// 
// See [method@Gtk.Widget.set_opacity].
	func (w Widget) Opacity() float64 {
var _arg0 *C.GtkWidget // out
var _cret C.double // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_opacity(_arg0)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Overflow returns the widgets overflow value.
	func (w Widget) Overflow() Overflow {
var _arg0 *C.GtkWidget // out
var _cret C.GtkOverflow // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_overflow(_arg0)


var _overflow Overflow // out

_overflow = Overflow(_cret)

return _overflow
}
	
	// PangoContext gets a `PangoContext` with the appropriate font map, font
// description, and base direction for this widget.
// 
// Unlike the context returned by [method@Gtk.Widget.create_pango_context], this
// context is owned by the widget (it can be used until the screen for the
// widget changes or the widget is removed from its toplevel), and will be
// updated to match any changes to the widgets attributes. This can be tracked
// by listening to changes of the [property@Gtk.Widget:root] property on the
// widget.
	func (w Widget) PangoContext() pango.Context {
var _arg0 *C.GtkWidget // out
var _cret *C.PangoContext // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_pango_context(_arg0)


var _context pango.Context // out

_context = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(pango.Context)

return _context
}
	
	// Parent returns the parent widget of @widget.
	func (w Widget) Parent() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_parent(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// PreferredSize retrieves the minimum and natural size of a widget, taking into
// account the widgets preference for height-for-width management.
// 
// This is used to retrieve a suitable size by container widgets which do not
// impose any restrictions on the child placement. It can be used to deduce
// toplevel window and menu sizes as well as child widgets in free-form
// containers such as `GtkFixed`.
// 
// Handle with care. Note that the natural height of a height-for-width widget
// will generally be a smaller size than the minimum height, since the required
// height for the natural width is generally smaller than the required height
// for the minimum width.
// 
// Use [id@gtk_widget_measure] if you want to support baseline alignment.
	func (w Widget) PreferredSize() (minimumSize Requisition, naturalSize Requisition) {
var _arg0 *C.GtkWidget // out
var _minimumSize Requisition
var _naturalSize Requisition

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_preferred_size(_arg0, (*C.GtkRequisition)(unsafe.Pointer(&_minimumSize)), (*C.GtkRequisition)(unsafe.Pointer(&_naturalSize)))







return _minimumSize, _naturalSize
}
	
	// PrevSibling returns the widgets previous sibling.
// 
// This API is primarily meant for widget implementations.
	func (w Widget) PrevSibling() Widget {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_prev_sibling(_arg0)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// PrimaryClipboard gets the primary clipboard of @widget.
// 
// This is a utility function to get the primary clipboard object for the
// `GdkDisplay` that @widget is using.
// 
// Note that this function always works, even when @widget is not realized yet.
	func (w Widget) PrimaryClipboard() gdk.Clipboard {
var _arg0 *C.GtkWidget // out
var _cret *C.GdkClipboard // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_primary_clipboard(_arg0)


var _clipboard gdk.Clipboard // out

_clipboard = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Clipboard)

return _clipboard
}
	
	// Realized determines whether @widget is realized.
	func (w Widget) Realized() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_realized(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ReceivesDefault determines whether @widget is always treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
// 
// See [method@Gtk.Widget.set_receives_default].
	func (w Widget) ReceivesDefault() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_receives_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RequestMode gets whether the widget prefers a height-for-width layout or a
// width-for-height layout.
// 
// Single-child widgets generally propagate the preference of their child, more
// complex widgets need to request something either in context of their children
// or in context of their allocation capabilities.
	func (w Widget) RequestMode() SizeRequestMode {
var _arg0 *C.GtkWidget // out
var _cret C.GtkSizeRequestMode // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_request_mode(_arg0)


var _sizeRequestMode SizeRequestMode // out

_sizeRequestMode = SizeRequestMode(_cret)

return _sizeRequestMode
}
	
	// Root returns the `GtkRoot` widget of @widget.
// 
// This function will return nil if the widget is not contained inside a widget
// tree with a root widget.
// 
// `GtkRoot` widgets will return themselves here.
	func (w Widget) Root() Root {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkRoot // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_root(_arg0)


var _root Root // out

_root = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Root)

return _root
}
	
	// ScaleFactor retrieves the internal scale factor that maps from window
// coordinates to the actual device pixels.
// 
// On traditional systems this is 1, on high density outputs, it can be a higher
// value (typically 2).
// 
// See [method@Gdk.Surface.get_scale_factor].
	func (w Widget) ScaleFactor() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_scale_factor(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Sensitive returns the widgets sensitivity.
// 
// This function returns the value that has been set using
// [method@Gtk.Widget.set_sensitive]).
// 
// The effective sensitivity of a widget is however determined by both its own
// and its parent widgets sensitivity. See [method@Gtk.Widget.is_sensitive].
	func (w Widget) Sensitive() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Settings gets the settings object holding the settings used for this widget.
// 
// Note that this function can only be called when the `GtkWidget` is attached
// to a toplevel, since the settings object is specific to a particular
// `GdkDisplay`. If you want to monitor the widget for changes in its settings,
// connect to notify::display.
	func (w Widget) Settings() Settings {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkSettings // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_settings(_arg0)


var _settings Settings // out

_settings = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Settings)

return _settings
}
	
	// Size returns the content width or height of the widget.
// 
// Which dimension is returned depends on @orientation.
// 
// This is equivalent to calling [method@Gtk.Widget.get_width] for
// GTK_ORIENTATION_HORIZONTAL or [method@Gtk.Widget.get_height] for
// GTK_ORIENTATION_VERTICAL, but can be used when writing
// orientation-independent code, such as when implementing
// [iface@Gtk.Orientable] widgets.
	func (w Widget) Size(orientation Orientation) int {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkOrientation // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkOrientation)(orientation)

_cret = C.gtk_widget_get_size(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// SizeRequest gets the size request that was explicitly set for the widget
// using gtk_widget_set_size_request().
// 
// A value of -1 stored in @width or @height indicates that that dimension has
// not been set explicitly and the natural requisition of the widget will be
// used instead. See [method@Gtk.Widget.set_size_request]. To get the size a
// widget will actually request, call [method@Gtk.Widget.measure] instead of
// this function.
	func (w Widget) SizeRequest() (width int, height int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_get_size_request(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// StateFlags returns the widget state as a flag set.
// 
// It is worth mentioning that the effective GTK_STATE_FLAG_INSENSITIVE state
// will be returned, that is, also based on parent insensitivity, even if
// @widget itself is sensitive.
// 
// Also note that if you are looking for a way to obtain the
// [flags@Gtk.StateFlags] to pass to a [class@Gtk.StyleContext] method, you
// should look at [method@Gtk.StyleContext.get_state].
	func (w Widget) StateFlags() StateFlags {
var _arg0 *C.GtkWidget // out
var _cret C.GtkStateFlags // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_state_flags(_arg0)


var _stateFlags StateFlags // out

_stateFlags = StateFlags(_cret)

return _stateFlags
}
	
	// StyleContext returns the style context associated to @widget.
// 
// The returned object is guaranteed to be the same for the lifetime of @widget.
	func (w Widget) StyleContext() StyleContext {
var _arg0 *C.GtkWidget // out
var _cret *C.GtkStyleContext // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_style_context(_arg0)


var _styleContext StyleContext // out

_styleContext = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(StyleContext)

return _styleContext
}
	
	// TemplateChild: fetch an object build from the template XML for @widget_type
// in this @widget instance.
// 
// This will only report children which were previously declared with
// [method@Gtk.WidgetClass.bind_template_child_full] or one of its variants.
// 
// This function is only meant to be called for code which is private to the
// @widget_type which declared the child and is meant for language bindings
// which cannot easily make use of the GObject structure offsets.
	func (w Widget) TemplateChild(widgetType externglib.Type, name string) **externglib.Object {
var _arg0 *C.GtkWidget // out
var _arg1 C.GType // out
var _arg2 *C.char // out
var _cret *C.GObject // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = C.GType(widgetType)
_arg2 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_widget_get_template_child(_arg0, _arg1, _arg2)


var _object **externglib.Object // out

_object = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(**externglib.Object)

return _object
}
	
	// TooltipMarkup gets the contents of the tooltip for @widget.
// 
// If the tooltip has not been set using [method@Gtk.Widget.set_tooltip_markup],
// this function returns nil.
	func (w Widget) TooltipMarkup() string {
var _arg0 *C.GtkWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_tooltip_markup(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// TooltipText gets the contents of the tooltip for @widget.
// 
// If the @widget's tooltip was set using
// [method@Gtk.Widget.set_tooltip_markup], this function will return the escaped
// text.
	func (w Widget) TooltipText() string {
var _arg0 *C.GtkWidget // out
var _cret *C.char // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_tooltip_text(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Valign gets the vertical alignment of @widget.
	func (w Widget) Valign() Align {
var _arg0 *C.GtkWidget // out
var _cret C.GtkAlign // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_valign(_arg0)


var _align Align // out

_align = Align(_cret)

return _align
}
	
	// Vexpand gets whether the widget would like any available extra vertical
// space.
// 
// See [method@Gtk.Widget.get_hexpand] for more detail.
	func (w Widget) Vexpand() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_vexpand(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// VexpandSet gets whether gtk_widget_set_vexpand() has been used to explicitly
// set the expand flag on this widget.
// 
// See [method@Gtk.Widget.get_hexpand_set] for more detail.
	func (w Widget) VexpandSet() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_vexpand_set(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Visible determines whether the widget is visible.
// 
// If you want to take into account whether the widgets parent is also marked
// as visible, use [method@Gtk.Widget.is_visible] instead.
// 
// This function does not check if the widget is obscured in any way.
// 
// See [method@Gtk.Widget.set_visible].
	func (w Widget) Visible() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Width returns the content width of the widget.
// 
// This function returns the size passed to its size-allocate implementation,
// which is the size you should be using in GtkWidgetClass.snapshot().
// 
// For pointer events, see [method@Gtk.Widget.contains].
	func (w Widget) Width() int {
var _arg0 *C.GtkWidget // out
var _cret C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_get_width(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// GrabFocus causes @widget to have the keyboard focus for the `GtkWindow` it's
// inside.
// 
// If @widget is not focusable, or its ::grab_focus implementation cannot
// transfer the focus to a descendant of @widget that is focusable, it will not
// take focus and false will be returned.
// 
// Calling [method@Gtk.Widget.grab_focus] on an already focused widget is
// allowed, should not have an effect, and return true.
	func (w Widget) GrabFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_grab_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasCSSClass returns whether @css_class is currently applied to @widget.
	func (w Widget) HasCSSClass(cssClass string) bool {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(cssClass))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_widget_has_css_class(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasDefault determines whether @widget is the current default widget within
// its toplevel.
	func (w Widget) HasDefault() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_default(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasFocus determines if the widget has the global input focus.
// 
// See [method@Gtk.Widget.is_focus] for the difference between having the global
// input focus, and only having the focus within a toplevel.
	func (w Widget) HasFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasVisibleFocus determines if the widget should show a visible indication
// that it has the global input focus.
// 
// This is a convenience function that takes into account whether focus
// indication should currently be shown in the toplevel window of @widget. See
// [method@Gtk.Window.get_focus_visible] for more information about focus
// indication.
// 
// To find out if the widget has the global input focus, use
// [method@Gtk.Widget.has_focus].
	func (w Widget) HasVisibleFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_has_visible_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Hide reverses the effects of gtk_widget_show().
// 
// This is causing the widget to be hidden (invisible to the user).
	func (w Widget) Hide()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_hide(_arg0)
}
	
	// InDestruction returns whether the widget is currently being destroyed.
// 
// This information can sometimes be used to avoid doing unnecessary work.
	func (w Widget) InDestruction() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_in_destruction(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InitTemplate creates and initializes child widgets defined in templates.
// 
// This function must be called in the instance initializer for any class which
// assigned itself a template using [method@Gtk.WidgetClass.set_template].
// 
// It is important to call this function in the instance initializer of a
// `GtkWidget` subclass and not in `GObject.constructed()` or
// `GObject.constructor()` for two reasons:
// 
//    - derived widgets will assume that the composite widgets
//      defined by its parent classes have been created in their
//      relative instance initializers
//    - when calling `g_object_new()` on a widget with composite templates,
//      its important to build the composite widgets before the construct
//      properties are set. Properties passed to `g_object_new()` should
//      take precedence over properties set in the private template XML
// 
// A good rule of thumb is to call this function as the first thing in an
// instance initialization function.
	func (w Widget) InitTemplate()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_init_template(_arg0)
}
	
	// InsertActionGroup inserts @group into @widget.
// 
// Children of @widget that implement [iface@Gtk.Actionable] can then be
// associated with actions in @group by setting their action-name to
// @prefix.`action-name`.
// 
// Note that inheritance is defined for individual actions. I.e. even if you
// insert a group with prefix @prefix, actions with the same prefix will still
// be inherited from the parent, unless the group contains an action with the
// same name.
// 
// If @group is nil, a previously inserted group for @name is removed from
// @widget.
	func (w Widget) InsertActionGroup(name string, group gio.ActionGroup)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out
var _arg2 *C.GActionGroup // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.GActionGroup)(unsafe.Pointer(group.Native()))

C.gtk_widget_insert_action_group(_arg0, _arg1, _arg2)
}
	
	// InsertAfter inserts @widget into the child widget list of @parent.
// 
// It will be placed after @previous_sibling, or at the beginning if
// @previous_sibling is nil.
// 
// After calling this function, `gtk_widget_get_prev_sibling(widget)` will
// return @previous_sibling.
// 
// If @parent is already set as the parent widget of @widget, this function can
// also be used to reorder @widget in the child widget list of @parent.
// 
// This API is primarily meant for widget implementations; if you are just using
// a widget, you *must* use its own API for adding children.
	func (w Widget) InsertAfter(parent WidgetClass, previousSibling WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(previousSibling.Native()))

C.gtk_widget_insert_after(_arg0, _arg1, _arg2)
}
	
	// InsertBefore inserts @widget into the child widget list of @parent.
// 
// It will be placed before @next_sibling, or at the end if @next_sibling is
// nil.
// 
// After calling this function, `gtk_widget_get_next_sibling(widget)` will
// return @next_sibling.
// 
// If @parent is already set as the parent widget of @widget, this function can
// also be used to reorder @widget in the child widget list of @parent.
// 
// This API is primarily meant for widget implementations; if you are just using
// a widget, you *must* use its own API for adding children.
	func (w Widget) InsertBefore(parent WidgetClass, nextSibling WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))
_arg2 = (*C.GtkWidget)(unsafe.Pointer(nextSibling.Native()))

C.gtk_widget_insert_before(_arg0, _arg1, _arg2)
}
	
	// IsAncestor determines whether @widget is somewhere inside @ancestor, possibly
// with intermediate containers.
	func (w Widget) IsAncestor(ancestor WidgetClass) bool {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(ancestor.Native()))

_cret = C.gtk_widget_is_ancestor(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsDrawable determines whether @widget can be drawn to.
// 
// A widget can be drawn if it is mapped and visible.
	func (w Widget) IsDrawable() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_drawable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFocus determines if the widget is the focus widget within its toplevel.
// 
// This does not mean that the [property@Gtk.Widget:has-focus] property is
// necessarily set; [property@Gtk,Widget:has-focus] will only be set if the
// toplevel widget additionally has the global input focus.)
	func (w Widget) IsFocus() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_focus(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsSensitive returns the widgets effective sensitivity.
// 
// This means it is sensitive itself and also its parent widget is sensitive.
	func (w Widget) IsSensitive() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_sensitive(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsVisible determines whether the widget and all its parents are marked as
// visible.
// 
// This function does not check if the widget is obscured in any way.
// 
// See also [method@Gtk.Widget.get_visible] and [method@Gtk.Widget.set_visible].
	func (w Widget) IsVisible() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_is_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// KeynavFailed emits the `::keynav-failed` signal on the widget.
// 
// This function should be called whenever keyboard navigation within a single
// widget hits a boundary.
// 
// The return value of this function should be interpreted in a way similar to
// the return value of [method@Gtk.Widget.child_focus]. When true is returned,
// stay in the widget, the failed keyboard navigation is OK and/or there is
// nowhere we can/should move the focus to. When false is returned, the caller
// should continue with keyboard navigation outside the widget, e.g. by calling
// [method@Gtk.Widget.child_focus] on the widgets toplevel.
// 
// The default [signal@Gtk.Widget::keynav-failed] handler returns false for
// GTK_DIR_TAB_FORWARD and GTK_DIR_TAB_BACKWARD. For the other values of
// DirectionType it returns true.
// 
// Whenever the default handler returns true, it also calls
// [method@Gtk.Widget.error_bell] to notify the user of the failed keyboard
// navigation.
// 
// A use case for providing an own implementation of ::keynav-failed (either by
// connecting to it or by overriding it) would be a row of [class@Gtk.Entry]
// widgets where the user should be able to navigate the entire row with the
// cursor keys, as e.g. known from user interfaces that require entering license
// keys.
	func (w Widget) KeynavFailed(direction DirectionType) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkDirectionType // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkDirectionType)(direction)

_cret = C.gtk_widget_keynav_failed(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Map causes a widget to be mapped if it isnt already.
// 
// This function is only for use in widget implementations.
	func (w Widget) Map()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_map(_arg0)
}
	
	// Measure measures @widget in the orientation @orientation and for the given
// @for_size.
// 
// As an example, if @orientation is GTK_ORIENTATION_HORIZONTAL and @for_size is
// 300, this functions will compute the minimum and natural width of @widget if
// it is allocated at a height of 300 pixels.
// 
// See GtkWidgets geometry management section
// (class.Widget.html#height-for-width-geometry-management) for a more details
// on implementing WidgetClass.measure().
	func (w Widget) Measure(orientation Orientation, forSize int) (minimum int, natural int, minimumBaseline int, naturalBaseline int) {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkOrientation // out
var _arg2 C.int // out
var _arg3 C.int // in
var _arg4 C.int // in
var _arg5 C.int // in
var _arg6 C.int // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkOrientation)(orientation)
_arg2 = (C.int)(forSize)

C.gtk_widget_measure(_arg0, _arg1, _arg2, &_arg3, &_arg4, &_arg5, &_arg6)

var _minimum int // out
var _natural int // out
var _minimumBaseline int // out
var _naturalBaseline int // out

_minimum = (int)(_arg3)
_natural = (int)(_arg4)
_minimumBaseline = (int)(_arg5)
_naturalBaseline = (int)(_arg6)

return _minimum, _natural, _minimumBaseline, _naturalBaseline
}
	
	// MnemonicActivate emits the `GtkWidget`::mnemonic-activate signal.
	func (w Widget) MnemonicActivate(groupCycling bool) bool {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if groupCycling { _arg1 = C.TRUE }

_cret = C.gtk_widget_mnemonic_activate(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ObserveChildren returns a `GListModel` to track the children of @widget.
// 
// Calling this function will enable extra internal bookkeeping to track
// children and emit signals on the returned listmodel. It may slow down
// operations a lot.
// 
// Applications should try hard to avoid calling this function because of the
// slowdowns.
	func (w Widget) ObserveChildren() gio.ListModel {
var _arg0 *C.GtkWidget // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_observe_children(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// ObserveControllers returns a `GListModel` to track the
// [class@Gtk.EventController]s of @widget.
// 
// Calling this function will enable extra internal bookkeeping to track
// controllers and emit signals on the returned listmodel. It may slow down
// operations a lot.
// 
// Applications should try hard to avoid calling this function because of the
// slowdowns.
	func (w Widget) ObserveControllers() gio.ListModel {
var _arg0 *C.GtkWidget // out
var _cret *C.GListModel // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_observe_controllers(_arg0)


var _listModel gio.ListModel // out

_listModel = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.ListModel)

return _listModel
}
	
	// Pick finds the descendant of @widget closest to the screen at the point (@x,
// @y).
// 
// The point must be given in widget coordinates, so (0, 0) is assumed to be the
// top left of @widget's content area.
// 
// Usually widgets will return nil if the given coordinate is not contained in
// @widget checked via [method@Gtk.Widget.contains]. Otherwise they will
// recursively try to find a child that does not return nil. Widgets are however
// free to customize their picking algorithm.
// 
// This function is used on the toplevel to determine the widget below the mouse
// cursor for purposes of hover highlighting and delivering events.
	func (w Widget) Pick(x float64, y float64, flags PickFlags) Widget {
var _arg0 *C.GtkWidget // out
var _arg1 C.double // out
var _arg2 C.double // out
var _arg3 C.GtkPickFlags // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.double)(x)
_arg2 = (C.double)(y)
_arg3 = (C.GtkPickFlags)(flags)

_cret = C.gtk_widget_pick(_arg0, _arg1, _arg2, _arg3)


var _ret Widget // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _ret
}
	
	// QueueAllocate flags the widget for a rerun of the
// GtkWidgetClass::size_allocate function.
// 
// Use this function instead of [method@Gtk.Widget.queue_resize] when the
// @widget's size request didn't change but it wants to reposition its contents.
// 
// An example user of this function is [method@Gtk.Widget.set_halign].
// 
// This function is only for use in widget implementations.
	func (w Widget) QueueAllocate()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_allocate(_arg0)
}
	
	// QueueDraw schedules this widget to be redrawn in paint phase of the current
// or the next frame.
// 
// This means @widget's GtkWidgetClass.snapshot() implementation will be called.
	func (w Widget) QueueDraw()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_draw(_arg0)
}
	
	// QueueResize flags a widget to have its size renegotiated.
// 
// This should be called when a widget for some reason has a new size request.
// For example, when you change the text in a [class@Gtk.Label], the label
// queues a resize to ensure theres enough space for the new text.
// 
// Note that you cannot call gtk_widget_queue_resize() on a widget from inside
// its implementation of the GtkWidgetClass::size_allocate virtual method. Calls
// to gtk_widget_queue_resize() from inside GtkWidgetClass::size_allocate will
// be silently ignored.
// 
// This function is only for use in widget implementations.
	func (w Widget) QueueResize()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_queue_resize(_arg0)
}
	
	// Realize creates the GDK resources associated with a widget.
// 
// Normally realization happens implicitly; if you show a widget and all its
// parent containers, then the widget will be realized and mapped automatically.
// 
// Realizing a widget requires all the widgets parent widgets to be realized;
// calling this function realizes the widgets parents in addition to @widget
// itself. If a widget is not yet inside a toplevel window when you realize it,
// bad things will happen.
// 
// This function is primarily used in widget implementations, and isnt very
// useful otherwise. Many times when you think you might need it, a better
// approach is to connect to a signal that will be called after the widget is
// realized automatically, such as [signal@Gtk.Widget::realize].
	func (w Widget) Realize()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_realize(_arg0)
}
	
	// RemoveController removes @controller from @widget, so that it doesn't process
// events anymore.
// 
// It should not be used again.
// 
// Widgets will remove all event controllers automatically when they are
// destroyed, there is normally no need to call this function.
	func (w Widget) RemoveController(controller EventControllerClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkEventController // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkEventController)(unsafe.Pointer(controller.Native()))

C.gtk_widget_remove_controller(_arg0, _arg1)
}
	
	// RemoveCSSClass removes a style from @widget.
// 
// After this, the style of @widget will stop matching for @css_class.
	func (w Widget) RemoveCSSClass(cssClass string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(cssClass))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_remove_css_class(_arg0, _arg1)
}
	
	// RemoveMnemonicLabel removes a widget from the list of mnemonic labels for
// this widget.
// 
// See [method@Gtk.Widget.list_mnemonic_labels]. The widget must have previously
// been added to the list with [method@Gtk.Widget.add_mnemonic_label].
	func (w Widget) RemoveMnemonicLabel(label WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(label.Native()))

C.gtk_widget_remove_mnemonic_label(_arg0, _arg1)
}
	
	// RemoveTickCallback removes a tick callback previously registered with
// gtk_widget_add_tick_callback().
	func (w Widget) RemoveTickCallback(id uint)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.guint // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint)(id)

C.gtk_widget_remove_tick_callback(_arg0, _arg1)
}
	
	// SetCanFocus specifies whether the input focus can enter the widget or any of
// its children.
// 
// Applications should set @can_focus to false to mark a widget as for
// pointer/touch use only.
// 
// Note that having @can_focus be true is only one of the necessary conditions
// for being focusable. A widget must also be sensitive and focusable and not
// have an ancestor that is marked as not can-focus in order to receive input
// focus.
// 
// See [method@Gtk.Widget.grab_focus] for actually setting the input focus on a
// widget.
	func (w Widget) SetCanFocus(canFocus bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if canFocus { _arg1 = C.TRUE }

C.gtk_widget_set_can_focus(_arg0, _arg1)
}
	
	// SetCanTarget sets whether @widget can be the target of pointer events.
	func (w Widget) SetCanTarget(canTarget bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if canTarget { _arg1 = C.TRUE }

C.gtk_widget_set_can_target(_arg0, _arg1)
}
	
	// SetChildVisible sets whether @widget should be mapped along with its parent.
// 
// The child visibility can be set for widget before it is added to a container
// with [method@Gtk.Widget.set_parent], to avoid mapping children unnecessary
// before immediately unmapping them. However it will be reset to its default
// state of true when the widget is removed from a container.
// 
// Note that changing the child visibility of a widget does not queue a resize
// on the widget. Most of the time, the size of a widget is computed from all
// visible children, whether or not they are mapped. If this is not the case,
// the container can queue a resize itself.
// 
// This function is only useful for container implementations and should never
// be called by an application.
	func (w Widget) SetChildVisible(childVisible bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if childVisible { _arg1 = C.TRUE }

C.gtk_widget_set_child_visible(_arg0, _arg1)
}
	
	// SetCSSClasses: will clear all style classes applied to @widget and replace
// them with @classes.
	func (w Widget) SetCSSClasses(classes []string)  {
var _arg0 *C.GtkWidget // out
var _arg1 **C.char

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (**C.char)(C.malloc(C.ulong(len(classes)+1) * C.ulong(unsafe.Sizeof(uint(0)))))
defer C.free(unsafe.Pointer(_arg1))
{
out := unsafe.Slice(_arg1, len(classes))
for i := range classes {
out[i] = (*C.char)(C.CString(classes[i]))
defer C.free(unsafe.Pointer(out[i]))
}
}

C.gtk_widget_set_css_classes(_arg0, _arg1)
}
	
	// SetCursor sets the cursor to be shown when pointer devices point towards
// @widget.
// 
// If the @cursor is NULL, @widget will use the cursor inherited from the parent
// widget.
	func (w Widget) SetCursor(cursor gdk.CursorClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GdkCursor // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkCursor)(unsafe.Pointer(cursor.Native()))

C.gtk_widget_set_cursor(_arg0, _arg1)
}
	
	// SetCursorFromName sets a named cursor to be shown when pointer devices point
// towards @widget.
// 
// This is a utility function that creates a cursor via
// [ctor@Gdk.Cursor.new_from_name] and then sets it on @widget with
// [method@Gtk.Widget.set_cursor]. See those functions for details.
// 
// On top of that, this function allows @name to be nil, which will do the same
// as calling [method@Gtk.Widget.set_cursor] with a nil cursor.
	func (w Widget) SetCursorFromName(name string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_cursor_from_name(_arg0, _arg1)
}
	
	// SetDirection sets the reading direction on a particular widget.
// 
// This direction controls the primary direction for widgets containing text,
// and also the direction in which the children of a container are packed. The
// ability to set the direction is present in order so that correct localization
// into languages with right-to-left reading directions can be done. Generally,
// applications will let the default reading direction present, except for
// containers where the containers are arranged in an order that is explicitly
// visual rather than logical (such as buttons for text justification).
// 
// If the direction is set to GTK_TEXT_DIR_NONE, then the value set by
// [func@Gtk.Widget.set_default_direction] will be used.
	func (w Widget) SetDirection(dir TextDirection)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkTextDirection // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkTextDirection)(dir)

C.gtk_widget_set_direction(_arg0, _arg1)
}
	
	// SetFocusChild: set @child as the current focus child of @widget.
// 
// The previous focus child will be unset.
// 
// This function is only suitable for widget implementations. If you want a
// certain widget to get the input focus, call [method@Gtk.Widget.grab_focus] on
// it.
	func (w Widget) SetFocusChild(child WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_widget_set_focus_child(_arg0, _arg1)
}
	
	// SetFocusOnClick sets whether the widget should grab focus when it is clicked
// with the mouse.
// 
// Making mouse clicks not grab focus is useful in places like toolbars where
// you dont want the keyboard focus removed from the main area of the
// application.
	func (w Widget) SetFocusOnClick(focusOnClick bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if focusOnClick { _arg1 = C.TRUE }

C.gtk_widget_set_focus_on_click(_arg0, _arg1)
}
	
	// SetFocusable specifies whether @widget can own the input focus.
// 
// Widget implementations should set @focusable to true in their init() function
// if they want to receive keyboard input.
// 
// Note that having @focusable be true is only one of the necessary conditions
// for being focusable. A widget must also be sensitive and can-focus and not
// have an ancestor that is marked as not can-focus in order to receive input
// focus.
// 
// See [method@Gtk.Widget.grab_focus] for actually setting the input focus on a
// widget.
	func (w Widget) SetFocusable(focusable bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if focusable { _arg1 = C.TRUE }

C.gtk_widget_set_focusable(_arg0, _arg1)
}
	
	// SetFontMap sets the font map to use for Pango rendering.
// 
// The font map is the object that is used to look up fonts. Setting a custom
// font map can be useful in special situations, e.g. when you need to add
// application-specific fonts to the set of available fonts.
// 
// When not set, the widget will inherit the font map from its parent.
	func (w Widget) SetFontMap(fontMap pango.FontMapClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.PangoFontMap // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontMap.Native()))

C.gtk_widget_set_font_map(_arg0, _arg1)
}
	
	// SetFontOptions sets the `cairo_font_options_t` used for Pango rendering in
// this widget.
// 
// When not set, the default font options for the `GdkDisplay` will be used.
	func (w Widget) SetFontOptions(options *cairo.FontOptions)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.cairo_font_options_t // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.cairo_font_options_t)(unsafe.Pointer(options.Native()))

C.gtk_widget_set_font_options(_arg0, _arg1)
}
	
	// SetHalign sets the horizontal alignment of @widget.
	func (w Widget) SetHalign(align Align)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkAlign // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkAlign)(align)

C.gtk_widget_set_halign(_arg0, _arg1)
}
	
	// SetHasTooltip sets the `has-tooltip` property on @widget to @has_tooltip.
	func (w Widget) SetHasTooltip(hasTooltip bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if hasTooltip { _arg1 = C.TRUE }

C.gtk_widget_set_has_tooltip(_arg0, _arg1)
}
	
	// SetHexpand sets whether the widget would like any available extra horizontal
// space.
// 
// When a user resizes a `GtkWindow`, widgets with expand=TRUE generally receive
// the extra space. For example, a list or scrollable area or document in your
// window would often be set to expand.
// 
// Call this function to set the expand flag if you would like your widget to
// become larger horizontally when the window has extra room.
// 
// By default, widgets automatically expand if any of their children want to
// expand. (To see if a widget will automatically expand given its current
// children and state, call [method@Gtk.Widget.compute_expand]. A container can
// decide how the expandability of children affects the expansion of the
// container by overriding the compute_expand virtual method on `GtkWidget`.).
// 
// Setting hexpand explicitly with this function will override the automatic
// expand behavior.
// 
// This function forces the widget to expand or not to expand, regardless of
// children. The override occurs because [method@Gtk.Widget.set_hexpand] sets
// the hexpand-set property (see [method@Gtk.Widget.set_hexpand_set]) which
// causes the widgets hexpand value to be used, rather than looking at children
// and widget state.
	func (w Widget) SetHexpand(expand bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_widget_set_hexpand(_arg0, _arg1)
}
	
	// SetHexpandSet sets whether the hexpand flag will be used.
// 
// The [property@Gtk.Widget:hexpand-set] property will be set automatically when
// you call [method@Gtk.Widget.set_hexpand] to set hexpand, so the most likely
// reason to use this function would be to unset an explicit expand flag.
// 
// If hexpand is set, then it overrides any computed expand value based on child
// widgets. If hexpand is not set, then the expand value depends on whether any
// children of the widget would like to expand.
// 
// There are few reasons to use this function, but its here for completeness
// and consistency.
	func (w Widget) SetHexpandSet(set bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if set { _arg1 = C.TRUE }

C.gtk_widget_set_hexpand_set(_arg0, _arg1)
}
	
	// SetLayoutManager sets the layout manager delegate instance that provides an
// implementation for measuring and allocating the children of @widget.
	func (w Widget) SetLayoutManager(layoutManager LayoutManagerClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkLayoutManager // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkLayoutManager)(unsafe.Pointer(layoutManager.Native()))

C.gtk_widget_set_layout_manager(_arg0, _arg1)
}
	
	// SetMarginBottom sets the bottom margin of @widget.
	func (w Widget) SetMarginBottom(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(margin)

C.gtk_widget_set_margin_bottom(_arg0, _arg1)
}
	
	// SetMarginEnd sets the end margin of @widget.
	func (w Widget) SetMarginEnd(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(margin)

C.gtk_widget_set_margin_end(_arg0, _arg1)
}
	
	// SetMarginStart sets the start margin of @widget.
	func (w Widget) SetMarginStart(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(margin)

C.gtk_widget_set_margin_start(_arg0, _arg1)
}
	
	// SetMarginTop sets the top margin of @widget.
	func (w Widget) SetMarginTop(margin int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(margin)

C.gtk_widget_set_margin_top(_arg0, _arg1)
}
	
	// SetName sets a widgets name.
// 
// Setting a name allows you to refer to the widget from a CSS file. You can
// apply a style to widgets with a particular name in the CSS file. See the
// documentation for the CSS syntax (on the same page as the docs for
// [class@Gtk.StyleContext].
// 
// Note that the CSS syntax has certain special characters to delimit and
// represent elements in a selector (period, #, >, *...), so using these will
// make your widget impossible to match by name. Any combination of alphanumeric
// symbols, dashes and underscores will suffice.
	func (w Widget) SetName(name string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_name(_arg0, _arg1)
}
	
	// SetOpacity: request the @widget to be rendered partially transparent.
// 
// An opacity of 0 is fully transparent and an opacity of 1 is fully opaque.
// 
// Opacity works on both toplevel widgets and child widgets, although there are
// some limitations: For toplevel widgets, applying opacity depends on the
// capabilities of the windowing system. On X11, this has any effect only on X
// displays with a compositing manager, see gdk_display_is_composited(). On
// Windows and Wayland it should always work, although setting a windows
// opacity after the window has been shown may cause some flicker.
// 
// Note that the opacity is inherited through inclusion  if you set a toplevel
// to be partially translucent, all of its content will appear translucent,
// since it is ultimatively rendered on that toplevel. The opacity value itself
// is not inherited by child widgets (since that would make widgets deeper in
// the hierarchy progressively more translucent). As a consequence,
// [class@Gtk.Popover]s and other [class@Gtk.Native] widgets with their own
// surface will use their own opacity value, and thus by default appear
// non-translucent, even if they are attached to a toplevel that is translucent.
	func (w Widget) SetOpacity(opacity float64)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.double // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.double)(opacity)

C.gtk_widget_set_opacity(_arg0, _arg1)
}
	
	// SetOverflow sets how @widget treats content that is drawn outside the
// widget's content area.
// 
// See the definition of [enum@Gtk.Overflow] for details.
// 
// This setting is provided for widget implementations and should not be used by
// application code.
// 
// The default value is GTK_OVERFLOW_VISIBLE.
	func (w Widget) SetOverflow(overflow Overflow)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkOverflow // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkOverflow)(overflow)

C.gtk_widget_set_overflow(_arg0, _arg1)
}
	
	// SetParent sets @parent as the parent widget of @widget.
// 
// This takes care of details such as updating the state and style of the child
// to reflect its new location and resizing the parent. The opposite function is
// [method@Gtk.Widget.unparent].
// 
// This function is useful only when implementing subclasses of `GtkWidget`.
	func (w Widget) SetParent(parent WidgetClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(parent.Native()))

C.gtk_widget_set_parent(_arg0, _arg1)
}
	
	// SetReceivesDefault specifies whether @widget will be treated as the default
// widget within its toplevel when it has the focus, even if another widget is
// the default.
	func (w Widget) SetReceivesDefault(receivesDefault bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if receivesDefault { _arg1 = C.TRUE }

C.gtk_widget_set_receives_default(_arg0, _arg1)
}
	
	// SetSensitive sets the sensitivity of a widget.
// 
// A widget is sensitive if the user can interact with it. Insensitive widgets
// are grayed out and the user cant interact with them. Insensitive widgets
// are known as inactive, disabled, or ghosted in some other toolkits.
	func (w Widget) SetSensitive(sensitive bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if sensitive { _arg1 = C.TRUE }

C.gtk_widget_set_sensitive(_arg0, _arg1)
}
	
	// SetSizeRequest sets the minimum size of a widget.
// 
// That is, the widgets size request will be at least @width by @height. You
// can use this function to force a widget to be larger than it normally would
// be.
// 
// In most cases, [method@Gtk.Window.set_default_size] is a better choice for
// toplevel windows than this function; setting the default size will still
// allow users to shrink the window. Setting the size request will force them to
// leave the window at least as large as the size request.
// 
// Note the inherent danger of setting any fixed size - themes, translations
// into other languages, different fonts, and user action can all change the
// appropriate size for a given widget. So, it's basically impossible to
// hardcode a size that will always be correct.
// 
// The size request of a widget is the smallest size a widget can accept while
// still functioning well and drawing itself correctly. However in some strange
// cases a widget may be allocated less than its requested size, and in many
// cases a widget may be allocated more space than it requested.
// 
// If the size request in a given direction is -1 (unset), then the natural
// size request of the widget will be used instead.
// 
// The size request set here does not include any margin from the properties
// [property@Gtk.Widget:margin-start], [property@Gtk.Widget:margin-end],
// [property@Gtk.Widget:margin-top], and [property@Gtk.Widget:margin-bottom],
// but it does include pretty much all other padding or border properties set by
// any subclass of `GtkWidget`.
	func (w Widget) SetSizeRequest(width int, height int)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)

C.gtk_widget_set_size_request(_arg0, _arg1, _arg2)
}
	
	// SetStateFlags turns on flag values in the current widget state.
// 
// Typical widget states are insensitive, prelighted, etc.
// 
// This function accepts the values GTK_STATE_FLAG_DIR_LTR and
// GTK_STATE_FLAG_DIR_RTL but ignores them. If you want to set the widget's
// direction, use [method@Gtk.Widget.set_direction].
// 
// This function is for use in widget implementations.
	func (w Widget) SetStateFlags(flags StateFlags, clear bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateFlags // out
var _arg2 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateFlags)(flags)
if clear { _arg2 = C.TRUE }

C.gtk_widget_set_state_flags(_arg0, _arg1, _arg2)
}
	
	// SetTooltipMarkup sets @markup as the contents of the tooltip, which is marked
// up with Pango markup.
// 
// This function will take care of setting the [property@Gtk.Widget:has-tooltip]
// as a side effect, and of the default handler for the
// [signal@Gtk.Widget::query-tooltip] signal.
// 
// See also [method@Gtk.Tooltip.set_markup].
	func (w Widget) SetTooltipMarkup(markup string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(markup))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_tooltip_markup(_arg0, _arg1)
}
	
	// SetTooltipText sets @text as the contents of the tooltip.
// 
// If @text contains any markup, it will be escaped.
// 
// This function will take care of setting [property@Gtk.Widget:has-tooltip] as
// a side effect, and of the default handler for the
// [signal@Gtk.Widget::query-tooltip] signal.
// 
// See also [method@Gtk.Tooltip.set_text].
	func (w Widget) SetTooltipText(text string)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(text))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_widget_set_tooltip_text(_arg0, _arg1)
}
	
	// SetValign sets the vertical alignment of @widget.
	func (w Widget) SetValign(align Align)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkAlign // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkAlign)(align)

C.gtk_widget_set_valign(_arg0, _arg1)
}
	
	// SetVexpand sets whether the widget would like any available extra vertical
// space.
// 
// See [method@Gtk.Widget.set_hexpand] for more detail.
	func (w Widget) SetVexpand(expand bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if expand { _arg1 = C.TRUE }

C.gtk_widget_set_vexpand(_arg0, _arg1)
}
	
	// SetVexpandSet sets whether the vexpand flag will be used.
// 
// See [method@Gtk.Widget.set_hexpand_set] for more detail.
	func (w Widget) SetVexpandSet(set bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if set { _arg1 = C.TRUE }

C.gtk_widget_set_vexpand_set(_arg0, _arg1)
}
	
	// SetVisible sets the visibility state of @widget.
// 
// Note that setting this to true doesnt mean the widget is actually viewable,
// see [method@Gtk.Widget.get_visible].
// 
// This function simply calls [method@Gtk.Widget.show] or
// [method@Gtk.Widget.hide] but is nicer to use when the visibility of the
// widget depends on some condition.
	func (w Widget) SetVisible(visible bool)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
if visible { _arg1 = C.TRUE }

C.gtk_widget_set_visible(_arg0, _arg1)
}
	
	// ShouldLayout returns whether @widget should contribute to the measuring and
// allocation of its parent.
// 
// This is false for invisible children, but also for children that have their
// own surface.
	func (w Widget) ShouldLayout() bool {
var _arg0 *C.GtkWidget // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

_cret = C.gtk_widget_should_layout(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Show flags a widget to be displayed.
// 
// Any widget that isnt shown will not appear on the screen.
// 
// Remember that you have to show the containers containing a widget, in
// addition to the widget itself, before it will appear onscreen.
// 
// When a toplevel container is shown, it is immediately realized and mapped;
// other shown widgets are realized and mapped when their toplevel container is
// realized and mapped.
	func (w Widget) Show()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_show(_arg0)
}
	
	// SnapshotChild: snapshot the a child of @widget.
// 
// When a widget receives a call to the snapshot function, it must send
// synthetic `GtkWidget`Class.snapshot() calls to all children. This function
// provides a convenient way of doing this. A widget, when it receives a call to
// its `GtkWidget`Class.snapshot() function, calls gtk_widget_snapshot_child()
// once for each child, passing in the @snapshot the widget received.
// 
// gtk_widget_snapshot_child() takes care of translating the origin of
// @snapshot, and deciding whether the child needs to be snapshot.
// 
// This function does nothing for children that implement `GtkNative`.
	func (w Widget) SnapshotChild(child WidgetClass, snapshot SnapshotClass)  {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _arg2 *C.GtkSnapshot // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))
_arg2 = (*C.GtkSnapshot)(unsafe.Pointer(snapshot.Native()))

C.gtk_widget_snapshot_child(_arg0, _arg1, _arg2)
}
	
	// TranslateCoordinates: translate coordinates relative to @src_widgets
// allocation to coordinates relative to @dest_widgets allocations.
// 
// In order to perform this operation, both widget must share a common ancestor.
	func (s Widget) TranslateCoordinates(destWidget WidgetClass, srcX float64, srcY float64) (destX float64, destY float64, ok bool) {
var _arg0 *C.GtkWidget // out
var _arg1 *C.GtkWidget // out
var _arg2 C.double // out
var _arg3 C.double // out
var _arg4 C.double // in
var _arg5 C.double // in
var _cret C.gboolean // in

_arg0 = (*C.GtkWidget)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(destWidget.Native()))
_arg2 = (C.double)(srcX)
_arg3 = (C.double)(srcY)

_cret = C.gtk_widget_translate_coordinates(_arg0, _arg1, _arg2, _arg3, &_arg4, &_arg5)


var _destX float64 // out
var _destY float64 // out
var _ok bool // out

_destX = (float64)(_arg4)
_destY = (float64)(_arg5)
if _cret != 0 { _ok = true }

return _destX, _destY, _ok
}
	
	// TriggerTooltipQuery triggers a tooltip query on the display where the
// toplevel of @widget is located.
	func (w Widget) TriggerTooltipQuery()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_trigger_tooltip_query(_arg0)
}
	
	// Unmap causes a widget to be unmapped if its currently mapped.
// 
// This function is only for use in widget implementations.
	func (w Widget) Unmap()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_unmap(_arg0)
}
	
	// Unparent: dissociate @widget from its parent.
// 
// This function is only for use in widget implementations, typically in
// dispose.
	func (w Widget) Unparent()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_unparent(_arg0)
}
	
	// Unrealize causes a widget to be unrealized (frees all GDK resources
// associated with the widget).
// 
// This function is only useful in widget implementations.
	func (w Widget) Unrealize()  {
var _arg0 *C.GtkWidget // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))

C.gtk_widget_unrealize(_arg0)
}
	
	// UnsetStateFlags turns off flag values for the current widget state.
// 
// See [method@Gtk.Widget.set_state_flags].
// 
// This function is for use in widget implementations.
	func (w Widget) UnsetStateFlags(flags StateFlags)  {
var _arg0 *C.GtkWidget // out
var _arg1 C.GtkStateFlags // out

_arg0 = (*C.GtkWidget)(unsafe.Pointer(w.Native()))
_arg1 = (C.GtkStateFlags)(flags)

C.gtk_widget_unset_state_flags(_arg0, _arg1)
}
	


	// WidgetPaintable: `GtkWidgetPaintable` is a `GdkPaintable` that displays the
// contents of a widget.
// 
// `GtkWidgetPaintable` will also take care of the widget not being in a state
// where it can be drawn (like when it isn't shown) and just draw nothing or
// where it does not have a size (like when it is hidden) and report no size in
// that case.
// 
// Of course, `GtkWidgetPaintable` allows you to monitor widgets for size
// changes by emitting the [signal@Gdk.Paintable::invalidate-size] signal
// whenever the size of the widget changes as well as for visual changes by
// emitting the [signal@Gdk.Paintable::invalidate-contents] signal whenever the
// widget changes.
// 
// You can use a `GtkWidgetPaintable` everywhere a `GdkPaintable` is allowed,
// including using it on a `GtkPicture` (or one of its parents) that it was set
// on itself via gtk_picture_set_paintable(). The paintable will take care of
// recursion when this happens. If you do this however, ensure that the
// [property@Gtk.Picture:can-shrink] property is set to true or you might end up
// with an infinitely growing widget.
	type WidgetPaintable struct {
		**externglib.Object
		gdk.Paintable
		
	}

	// WidgetPaintableClass is an interface that the WidgetPaintable class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WidgetPaintableClass interface {
		gextras.Objector
		_widgetPaintable()
	}

	func (WidgetPaintable) _widgetPaintable() {}

	
	func marshalWidgetPaintable(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWidgetPaintable(obj), nil
	}
	

	
	// NewWidgetPaintable creates a new widget paintable observing the given widget.
	func NewWidgetPaintable(widget WidgetClass) WidgetPaintable {
var _arg1 *C.GtkWidget // out
var _cret *C.GdkPaintable // in

_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

_cret = C.gtk_widget_paintable_new(_arg1)


var _widgetPaintable WidgetPaintable // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_widgetPaintable = WidgetPaintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
Paintable: gdk.Paintable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _widgetPaintable
}
	

	
	// Widget returns the widget that is observed or nil if none.
	func (s WidgetPaintable) Widget() Widget {
var _arg0 *C.GtkWidgetPaintable // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWidgetPaintable)(unsafe.Pointer(s.Native()))

_cret = C.gtk_widget_paintable_get_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetWidget sets the widget that should be observed.
	func (s WidgetPaintable) SetWidget(widget WidgetClass)  {
var _arg0 *C.GtkWidgetPaintable // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWidgetPaintable)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(widget.Native()))

C.gtk_widget_paintable_set_widget(_arg0, _arg1)
}
	


	// Window: a `GtkWindow` is a toplevel window which can contain other widgets.
// 
// !An example GtkWindow (window.png)
// 
// Windows normally have decorations that are under the control of the windowing
// system and allow the user to manipulate the window (resize it, move it, close
// it,...).
// 
// 
// GtkWindow as GtkBuildable
// 
// The `GtkWindow` implementation of the [iface@Gtk.Buildable] interface
// supports setting a child as the titlebar by specifying titlebar as the
// type attribute of a <child> element.
// 
// 
// CSS nodes
// 
// ` window.background [.csd / .solid-csd / .ssd] [.maximized / .fullscreen /
// .tiled]  <child>  <titlebar child>.titlebar [.default-decoration] `
// 
// `GtkWindow` has a main CSS node with name window and style class .background.
// 
// Style classes that are typically used with the main CSS node are .csd (when
// client-side decorations are in use), .solid-csd (for client-side decorations
// without invisible borders), .ssd (used by mutter when rendering server-side
// decorations). GtkWindow also represents window states with the following
// style classes on the main node: .maximized, .fullscreen, .tiled (when
// supported, also .tiled-top, .tiled-left, .tiled-right, .tiled-bottom).
// 
// `GtkWindow` subclasses often add their own discriminating style classes, such
// as .dialog, .popup or .tooltip.
// 
// Generally, some CSS properties don't make sense on the toplevel window node,
// such as margins or padding. When client-side decorations without invisible
// borders are in use (i.e. the .solid-csd style class is added to the main
// window node), the CSS border of the toplevel window is used for resize drags.
// In the .csd case, the shadow area outside of the window can be used to resize
// it.
// 
// `GtkWindow` adds the .titlebar and .default-decoration style classes to the
// widget that is added as a titlebar child.
// 
// 
// Accessibility
// 
// `GtkWindow` uses the GTK_ACCESSIBLE_ROLE_WINDOW role.
	type Window struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		Native
		Root
		ShortcutManager
		
	}

	// WindowClass is an interface that the Window class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WindowClass interface {
		gextras.Objector
		_window()
	}

	func (Window) _window() {}

	
	func marshalWindow(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWindow(obj), nil
	}
	

	
	// NewWindow creates a new `GtkWindow`.
// 
// To get an undecorated window (no window borders), use
// [method@Gtk.Window.set_decorated].
// 
// All top-level windows created by gtk_window_new() are stored in an internal
// top-level window list. This list can be obtained from
// [func@Gtk.Window.list_toplevels]. Due to GTK keeping a reference to the
// window internally, gtk_window_new() does not return a reference to the
// caller.
// 
// To delete a `GtkWindow`, call [method@Gtk.Window.destroy].
	func NewWindow() Window {
var _cret *C.GtkWidget // in

_cret = C.gtk_window_new()


var _window Window // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_window = Window{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Root: Root{
Native: Native{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
},
ShortcutManager: ShortcutManager{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _window
}
	

	
	// Close requests that the window is closed.
// 
// This is similar to what happens when a window manager close button is
// clicked.
// 
// This function can be used with close buttons in custom titlebars.
	func (w Window) Close()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_close(_arg0)
}
	
	// Destroy: drop the internal reference GTK holds on toplevel windows.
	func (w Window) Destroy()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_destroy(_arg0)
}
	
	// Fullscreen asks to place @window in the fullscreen state.
// 
// Note that you shouldnt assume the window is definitely fullscreen afterward,
// because other entities (e.g. the user or window manager unfullscreen it
// again, and not all window managers honor requests to fullscreen windows.
// 
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to notifications of
// the [property@Gtk.Window:fullscreened] property.
	func (w Window) Fullscreen()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_fullscreen(_arg0)
}
	
	// FullscreenOnMonitor asks to place @window in the fullscreen state on the
// given @monitor.
// 
// Note that you shouldn't assume the window is definitely fullscreen afterward,
// or that the windowing system allows fullscreen windows on any given monitor.
// 
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to notifications of
// the [property@Gtk.Window:fullscreened] property.
	func (w Window) FullscreenOnMonitor(monitor gdk.MonitorClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GdkMonitor // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkMonitor)(unsafe.Pointer(monitor.Native()))

C.gtk_window_fullscreen_on_monitor(_arg0, _arg1)
}
	
	// Application gets the `GtkApplication` associated with the window.
	func (w Window) Application() Application {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkApplication // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_application(_arg0)


var _application Application // out

_application = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Application)

return _application
}
	
	// Child gets the child widget of @window.
	func (w Window) Child() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Decorated returns whether the window has been set to have decorations.
	func (w Window) Decorated() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_decorated(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DefaultSize gets the default size of the window.
// 
// A value of 0 for the width or height indicates that a default size has not
// been explicitly set for that dimension, so the natural size of the window
// will be used.
	func (w Window) DefaultSize() (width int, height int) {
var _arg0 *C.GtkWindow // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_get_default_size(_arg0, &_arg1, &_arg2)

var _width int // out
var _height int // out

_width = (int)(_arg1)
_height = (int)(_arg2)

return _width, _height
}
	
	// DefaultWidget returns the default widget for @window.
	func (w Window) DefaultWidget() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_default_widget(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// Deletable returns whether the window has been set to have a close button.
	func (w Window) Deletable() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_deletable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// DestroyWithParent returns whether the window will be destroyed with its
// transient parent.
	func (w Window) DestroyWithParent() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_destroy_with_parent(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Focus retrieves the current focused widget within the window.
// 
// Note that this is the widget that would have the focus if the toplevel window
// focused; if the toplevel window is not focused then `gtk_widget_has_focus
// (widget)` will not be true for the widget.
	func (w Window) Focus() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_focus(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// FocusVisible gets whether focus rectangles are supposed to be visible.
	func (w Window) FocusVisible() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_focus_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Group returns the group for @window.
// 
// If the window has no group, then the default group is returned.
	func (w Window) Group() WindowGroup {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWindowGroup // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_group(_arg0)


var _windowGroup WindowGroup // out

_windowGroup = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(WindowGroup)

return _windowGroup
}
	
	// HandleMenubarAccel returns whether this window reacts to F10 key presses by
// activating a menubar it contains.
	func (w Window) HandleMenubarAccel() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_handle_menubar_accel(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HideOnClose returns whether the window will be hidden when the close button
// is clicked.
	func (w Window) HideOnClose() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_hide_on_close(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IconName returns the name of the themed icon for the window.
	func (w Window) IconName() string {
var _arg0 *C.GtkWindow // out
var _cret *C.char // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_icon_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// MnemonicsVisible gets whether mnemonics are supposed to be visible.
	func (w Window) MnemonicsVisible() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_mnemonics_visible(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Modal returns whether the window is modal.
	func (w Window) Modal() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_modal(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Resizable gets the value set by gtk_window_set_resizable().
	func (w Window) Resizable() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_resizable(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Title retrieves the title of the window.
	func (w Window) Title() string {
var _arg0 *C.GtkWindow // out
var _cret *C.char // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_title(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Titlebar returns the custom titlebar that has been set with
// gtk_window_set_titlebar().
	func (w Window) Titlebar() Widget {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_titlebar(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// TransientFor fetches the transient parent for this window.
	func (w Window) TransientFor() Window {
var _arg0 *C.GtkWindow // out
var _cret *C.GtkWindow // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_get_transient_for(_arg0)


var _ret Window // out

_ret = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Window)

return _ret
}
	
	// HasGroup returns whether @window has an explicit window group.
	func (w Window) HasGroup() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_has_group(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsActive returns whether the window is part of the current active toplevel.
// 
// The active toplevel is the window receiving keystrokes.
// 
// The return value is true if the window is active toplevel itself. You might
// use this function if you wanted to draw a widget differently in an active
// window from a widget in an inactive window.
	func (w Window) IsActive() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_is_active(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsFullscreen retrieves the current fullscreen state of @window.
// 
// Note that since fullscreening is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldnt assume the
// return value of this function changing immediately (or at all), as an effect
// of calling [method@Gtk.Window.fullscreen] or
// [method@Gtk.Window.unfullscreen].
// 
// If the window isn't yet mapped, the value returned will whether the initial
// requested state is fullscreen.
	func (w Window) IsFullscreen() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_is_fullscreen(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsMaximized retrieves the current maximized state of @window.
// 
// Note that since maximization is ultimately handled by the window manager and
// happens asynchronously to an application request, you shouldnt assume the
// return value of this function changing immediately (or at all), as an effect
// of calling [method@Gtk.Window.maximize] or [method@Gtk.Window.unmaximize].
// 
// If the window isn't yet mapped, the value returned will whether the initial
// requested state is maximized.
	func (w Window) IsMaximized() bool {
var _arg0 *C.GtkWindow // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

_cret = C.gtk_window_is_maximized(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Maximize asks to maximize @window, so that it fills the screen.
// 
// Note that you shouldnt assume the window is definitely maximized afterward,
// because other entities (e.g. the user or window manager could unmaximize it
// again, and not all window managers support maximization.
// 
// Its permitted to call this function before showing a window, in which case
// the window will be maximized when it appears onscreen initially.
// 
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to notifications on
// the [property@Gtk.Window:maximized] property.
	func (w Window) Maximize()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_maximize(_arg0)
}
	
	// Minimize asks to minimize the specified @window.
// 
// Note that you shouldnt assume the window is definitely minimized afterward,
// because the windowing system might not support this functionality; other
// entities (e.g. the user or the window manager could unminimize it again, or
// there may not be a window manager in which case minimization isnt possible,
// etc.
// 
// Its permitted to call this function before showing a window, in which case
// the window will be minimized before it ever appears onscreen.
// 
// You can track result of this operation via the [property@Gdk.Toplevel:state]
// property.
	func (w Window) Minimize()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_minimize(_arg0)
}
	
	// Present presents a window to the user.
// 
// This function should not be used as when it is called, it is too late to
// gather a valid timestamp to allow focus stealing prevention to work
// correctly.
	func (w Window) Present()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_present(_arg0)
}
	
	// PresentWithTime presents a window to the user.
// 
// This may mean raising the window in the stacking order, unminimizing it,
// moving it to the current desktop, and/or giving it the keyboard focus,
// possibly dependent on the users platform, window manager, and preferences.
// 
// If @window is hidden, this function calls [method@Gtk.Widget.show] as well.
// 
// This function should be used when the user tries to open a window thats
// already open. Say for example the preferences dialog is currently open, and
// the user chooses Preferences from the menu a second time; use
// [method@Gtk.Window.present] to move the already-open dialog where the user
// can see it.
// 
// Presents a window to the user in response to a user interaction. The
// timestamp should be gathered when the window was requested to be shown (when
// clicking a link for example), rather than once the window is ready to be
// shown.
	func (w Window) PresentWithTime(timestamp uint32)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.guint32 // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.guint32)(timestamp)

C.gtk_window_present_with_time(_arg0, _arg1)
}
	
	// SetApplication sets or unsets the `GtkApplication` associated with the
// window.
// 
// The application will be kept alive for at least as long as it has any windows
// associated with it (see g_application_hold() for a way to keep it alive
// without windows).
// 
// Normally, the connection between the application and the window will remain
// until the window is destroyed, but you can explicitly remove it by setting
// the @application to nil.
// 
// This is equivalent to calling [method@Gtk.Application.remove_window] and/or
// [method@Gtk.Application.add_window] on the old/new applications as relevant.
	func (w Window) SetApplication(application ApplicationClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkApplication // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkApplication)(unsafe.Pointer(application.Native()))

C.gtk_window_set_application(_arg0, _arg1)
}
	
	// SetChild sets the child widget of @window.
	func (w Window) SetChild(child WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_window_set_child(_arg0, _arg1)
}
	
	// SetDecorated sets whether the window should be decorated.
// 
// By default, windows are decorated with a title bar, resize controls, etc.
// Some window managers allow GTK to disable these decorations, creating a
// borderless window. If you set the decorated property to false using this
// function, GTK will do its best to convince the window manager not to decorate
// the window. Depending on the system, this function may not have any effect
// when called on a window that is already visible, so you should call it before
// calling [method@Gtk.Widget.show].
// 
// On Windows, this function always works, since theres no window manager
// policy involved.
	func (w Window) SetDecorated(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_decorated(_arg0, _arg1)
}
	
	// SetDefaultSize sets the default size of a window.
// 
// If the windows natural size (its size request) is larger than the default,
// the default will be ignored.
// 
// Unlike [method@Gtk.Widget.set_size_request], which sets a size request for a
// widget and thus would keep users from shrinking the window, this function
// only sets the initial size, just as if the user had resized the window
// themselves. Users can still shrink the window again as they normally would.
// Setting a default size of -1 means to use the natural default size (the
// size request of the window).
// 
// The default size of a window only affects the first time a window is shown;
// if a window is hidden and re-shown, it will remember the size it had prior to
// hiding, rather than using the default size.
// 
// Windows cant actually be 0x0 in size, they must be at least 1x1, but passing
// 0 for @width and @height is OK, resulting in a 1x1 default size.
// 
// If you use this function to reestablish a previously saved window size, note
// that the appropriate size to save is the one returned by
// [method@Gtk.Window.get_default_size]. Using the window allocation directly
// will not work in all circumstances and can lead to growing or shrinking
// windows.
	func (w Window) SetDefaultSize(width int, height int)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.int // out
var _arg2 C.int // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (C.int)(width)
_arg2 = (C.int)(height)

C.gtk_window_set_default_size(_arg0, _arg1, _arg2)
}
	
	// SetDefaultWidget sets the default widget.
// 
// The default widget is the widget that is activated when the user presses
// Enter in a dialog (for example).
	func (w Window) SetDefaultWidget(defaultWidget WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(defaultWidget.Native()))

C.gtk_window_set_default_widget(_arg0, _arg1)
}
	
	// SetDeletable sets whether the window should be deletable.
// 
// By default, windows have a close button in the window frame. Some window
// managers allow GTK to disable this button. If you set the deletable property
// to false using this function, GTK will do its best to convince the window
// manager not to show a close button. Depending on the system, this function
// may not have any effect when called on a window that is already visible, so
// you should call it before calling [method@Gtk.Widget.show].
// 
// On Windows, this function always works, since theres no window manager
// policy involved.
	func (w Window) SetDeletable(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_deletable(_arg0, _arg1)
}
	
	// SetDestroyWithParent: if @setting is true, then destroying the transient
// parent of @window will also destroy @window itself.
// 
// This is useful for dialogs that shouldnt persist beyond the lifetime of the
// main window they are associated with, for example.
	func (w Window) SetDestroyWithParent(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_destroy_with_parent(_arg0, _arg1)
}
	
	// SetDisplay sets the `GdkDisplay` where the @window is displayed.
// 
// If the window is already mapped, it will be unmapped, and then remapped on
// the new display.
	func (w Window) SetDisplay(display gdk.DisplayClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GdkDisplay // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GdkDisplay)(unsafe.Pointer(display.Native()))

C.gtk_window_set_display(_arg0, _arg1)
}
	
	// SetFocus sets the focus widget.
// 
// If @focus is not the current focus widget, and is focusable, sets it as the
// focus widget for the window. If @focus is nil, unsets the focus widget for
// this window. To set the focus to a particular widget in the toplevel, it is
// usually more convenient to use [method@Gtk.Widget.grab_focus] instead of this
// function.
	func (w Window) SetFocus(focus WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(focus.Native()))

C.gtk_window_set_focus(_arg0, _arg1)
}
	
	// SetFocusVisible sets whether focus rectangles are supposed to be visible.
	func (w Window) SetFocusVisible(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_focus_visible(_arg0, _arg1)
}
	
	// SetHandleMenubarAccel sets whether this window should react to F10 key
// presses by activating a menubar it contains.
	func (w Window) SetHandleMenubarAccel(handleMenubarAccel bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if handleMenubarAccel { _arg1 = C.TRUE }

C.gtk_window_set_handle_menubar_accel(_arg0, _arg1)
}
	
	// SetHideOnClose: if @setting is true, then clicking the close button on the
// window will not destroy it, but only hide it.
	func (w Window) SetHideOnClose(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_hide_on_close(_arg0, _arg1)
}
	
	// SetIconName sets the icon for the window from a named themed icon.
// 
// See the docs for [class@Gtk.IconTheme] for more details. On some platforms,
// the window icon is not used at all.
// 
// Note that this has nothing to do with the WM_ICON_NAME property which is
// mentioned in the ICCCM.
	func (w Window) SetIconName(name string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_icon_name(_arg0, _arg1)
}
	
	// SetMnemonicsVisible sets whether mnemonics are supposed to be visible.
	func (w Window) SetMnemonicsVisible(setting bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if setting { _arg1 = C.TRUE }

C.gtk_window_set_mnemonics_visible(_arg0, _arg1)
}
	
	// SetModal sets a window modal or non-modal.
// 
// Modal windows prevent interaction with other windows in the same application.
// To keep modal dialogs on top of main application windows, use
// [method@Gtk.Window.set_transient_for] to make the dialog transient for the
// parent; most window managers will then disallow lowering the dialog below the
// parent.
	func (w Window) SetModal(modal bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if modal { _arg1 = C.TRUE }

C.gtk_window_set_modal(_arg0, _arg1)
}
	
	// SetResizable sets whether the user can resize a window.
// 
// Windows are user resizable by default.
	func (w Window) SetResizable(resizable bool)  {
var _arg0 *C.GtkWindow // out
var _arg1 C.gboolean // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
if resizable { _arg1 = C.TRUE }

C.gtk_window_set_resizable(_arg0, _arg1)
}
	
	// SetStartupID sets the startup notification ID.
// 
// Startup notification identifiers are used by desktop environment to track
// application startup, to provide user feedback and other features. This
// function changes the corresponding property on the underlying `GdkSurface`.
// 
// Normally, startup identifier is managed automatically and you should only use
// this function in special cases like transferring focus from other processes.
// You should use this function before calling [method@Gtk.Window.present] or
// any equivalent function generating a window map event.
// 
// This function is only useful on X11, not with other GTK targets.
	func (w Window) SetStartupID(startupId string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(startupId))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_startup_id(_arg0, _arg1)
}
	
	// SetTitle sets the title of the `GtkWindow`.
// 
// The title of a window will be displayed in its title bar; on the X Window
// System, the title bar is rendered by the window manager so exactly how the
// title appears to users may vary according to a users exact configuration.
// The title should help a user distinguish this window from other windows they
// may have open. A good title might include the application name and current
// document filename, for example.
// 
// Passing nil does the same as setting the title to an empty string.
	func (w Window) SetTitle(title string)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.char)(C.CString(title))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_set_title(_arg0, _arg1)
}
	
	// SetTitlebar sets a custom titlebar for @window.
// 
// A typical widget used here is [class@Gtk.HeaderBar], as it provides various
// features expected of a titlebar while allowing the addition of child widgets
// to it.
// 
// If you set a custom titlebar, GTK will do its best to convince the window
// manager not to put its own titlebar on the window. Depending on the system,
// this function may not work for a window that is already visible, so you set
// the titlebar before calling [method@Gtk.Widget.show].
	func (w Window) SetTitlebar(titlebar WidgetClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(titlebar.Native()))

C.gtk_window_set_titlebar(_arg0, _arg1)
}
	
	// SetTransientFor: dialog windows should be set transient for the main
// application window they were spawned from. This allows window managers to
// e.g. keep the dialog on top of the main window, or center the dialog over the
// main window. [ctor@Gtk.Dialog.new_with_buttons] and other convenience
// functions in GTK will sometimes call gtk_window_set_transient_for() on your
// behalf.
// 
// Passing nil for @parent unsets the current transient window.
// 
// On Windows, this function puts the child window on top of the parent, much as
// the window manager would have done on X.
	func (w Window) SetTransientFor(parent WindowClass)  {
var _arg0 *C.GtkWindow // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(parent.Native()))

C.gtk_window_set_transient_for(_arg0, _arg1)
}
	
	// Unfullscreen asks to remove the fullscreen state for @window, and return to
// its previous state.
// 
// Note that you shouldnt assume the window is definitely not fullscreen
// afterward, because other entities (e.g. the user or window manager could
// fullscreen it again, and not all window managers honor requests to
// unfullscreen windows; normally the window will end up restored to its normal
// state. Just dont write code that crashes if not.
// 
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to notifications of
// the [property@Gtk.Window:fullscreened] property.
	func (w Window) Unfullscreen()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_unfullscreen(_arg0)
}
	
	// Unmaximize asks to unmaximize @window.
// 
// Note that you shouldnt assume the window is definitely unmaximized
// afterward, because other entities (e.g. the user or window manager maximize
// it again, and not all window managers honor requests to unmaximize.
// 
// You can track the result of this operation via the
// [property@Gdk.Toplevel:state] property, or by listening to notifications on
// the [property@Gtk.Window:maximized] property.
	func (w Window) Unmaximize()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_unmaximize(_arg0)
}
	
	// Unminimize asks to unminimize the specified @window.
// 
// Note that you shouldnt assume the window is definitely unminimized
// afterward, because the windowing system might not support this functionality;
// other entities (e.g. the user or the window manager could minimize it again,
// or there may not be a window manager in which case minimization isnt
// possible, etc.
// 
// You can track result of this operation via the [property@Gdk.Toplevel:state]
// property.
	func (w Window) Unminimize()  {
var _arg0 *C.GtkWindow // out

_arg0 = (*C.GtkWindow)(unsafe.Pointer(w.Native()))

C.gtk_window_unminimize(_arg0)
}
	


	// WindowControls: `GtkWindowControls` shows window frame controls.
// 
// Typical window frame controls are minimize, maximize and close buttons, and
// the window icon.
// 
// !An example GtkWindowControls (windowcontrols.png)
// 
// `GtkWindowControls` only displays start or end side of the controls (see
// [property@Gtk.WindowControls:side]), so it's intended to be always used in
// pair with another `GtkWindowControls` for the opposite side, for example:
// 
// `xml <object class="GtkBox"> <child> <object class="GtkWindowControls">
// <property name="side">start</property> </object> </child>
// 
//    ...
// 
//    <child>
//      <object class="GtkWindowControls">
//        <property name="side">end</property>
//      </object>
//    </child>
// 
// </object> `
// 
// 
// CSS nodes
// 
// ` windowcontrols  [image.icon]  [button.minimize] 
// [button.maximize]  [button.close] `
// 
// A `GtkWindowControls`' CSS node is called windowcontrols. It contains
// subnodes corresponding to each title button. Which of the title buttons exist
// and where they are placed exactly depends on the desktop environment and
// [property@Gtk.WindowControls:decoration-layout] value.
// 
// When [property@Gtk.WindowControls:empty] is true, it gets the .empty style
// class.
// 
// 
// Accessibility
// 
// `GtkWindowControls` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type WindowControls struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// WindowControlsClass is an interface that the WindowControls class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WindowControlsClass interface {
		gextras.Objector
		_windowControls()
	}

	func (WindowControls) _windowControls() {}

	
	func marshalWindowControls(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWindowControls(obj), nil
	}
	

	
	// NewWindowControls creates a new `GtkWindowControls`.
	func NewWindowControls(side PackType) WindowControls {
var _arg1 C.GtkPackType // out
var _cret *C.GtkWidget // in

_arg1 = (C.GtkPackType)(side)

_cret = C.gtk_window_controls_new(_arg1)


var _windowControls WindowControls // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_windowControls = WindowControls{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _windowControls
}
	

	
	// DecorationLayout gets the decoration layout of this `GtkWindowControls`.
	func (s WindowControls) DecorationLayout() string {
var _arg0 *C.GtkWindowControls // out
var _cret *C.char // in

_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))

_cret = C.gtk_window_controls_get_decoration_layout(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Empty gets whether the widget has any window buttons.
	func (s WindowControls) Empty() bool {
var _arg0 *C.GtkWindowControls // out
var _cret C.gboolean // in

_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))

_cret = C.gtk_window_controls_get_empty(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Side gets the side to which this `GtkWindowControls` instance belongs.
	func (s WindowControls) Side() PackType {
var _arg0 *C.GtkWindowControls // out
var _cret C.GtkPackType // in

_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))

_cret = C.gtk_window_controls_get_side(_arg0)


var _packType PackType // out

_packType = PackType(_cret)

return _packType
}
	
	// SetDecorationLayout sets the decoration layout for the title buttons.
// 
// This overrides the [property@Gtk.Settings:gtk-decoration-layout] setting.
// 
// The format of the string is button names, separated by commas. A colon
// separates the buttons that should appear on the left from those on the right.
// Recognized button names are minimize, maximize, close and icon (the window
// icon).
// 
// For example, icon:minimize,maximize,close specifies a icon on the left, and
// minimize, maximize and close buttons on the right.
// 
// If [property@Gtk.WindowControls:side] value is @GTK_PACK_START, @self will
// display the part before the colon, otherwise after that.
	func (s WindowControls) SetDecorationLayout(layout string)  {
var _arg0 *C.GtkWindowControls // out
var _arg1 *C.char // out

_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))
_arg1 = (*C.char)(C.CString(layout))
defer C.free(unsafe.Pointer(_arg1))

C.gtk_window_controls_set_decoration_layout(_arg0, _arg1)
}
	
	// SetSide determines which part of decoration layout the `GtkWindowControls`
// uses.
// 
// See [property@Gtk.WindowControls:decoration-layout].
	func (s WindowControls) SetSide(side PackType)  {
var _arg0 *C.GtkWindowControls // out
var _arg1 C.GtkPackType // out

_arg0 = (*C.GtkWindowControls)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkPackType)(side)

C.gtk_window_controls_set_side(_arg0, _arg1)
}
	


	// WindowGroup: `GtkWindowGroup` makes group of windows behave like separate
// applications.
// 
// It achieves this by limiting the effect of GTK grabs and modality to windows
// in the same group.
// 
// A window can be a member in at most one window group at a time. Windows that
// have not been explicitly assigned to a group are implicitly treated like
// windows of the default window group.
// 
// `GtkWindowGroup` objects are referenced by each window in the group, so once
// you have added all windows to a `GtkWindowGroup`, you can drop the initial
// reference to the window group with g_object_unref(). If the windows in the
// window group are subsequently destroyed, then they will be removed from the
// window group and drop their references on the window group; when all window
// have been removed, the window group will be freed.
	type WindowGroup struct {
		**externglib.Object
		
	}

	// WindowGroupClass is an interface that the WindowGroup class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WindowGroupClass interface {
		gextras.Objector
		_windowGroup()
	}

	func (WindowGroup) _windowGroup() {}

	
	func marshalWindowGroup(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWindowGroup(obj), nil
	}
	

	
	// NewWindowGroup creates a new `GtkWindowGroup` object.
// 
// Modality of windows only affects windows within the same `GtkWindowGroup`.
	func NewWindowGroup() WindowGroup {
var _cret *C.GtkWindowGroup // in

_cret = C.gtk_window_group_new()


var _windowGroup WindowGroup // out

{
obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
_windowGroup = WindowGroup{
Object: &externglib.Object{externglib.ToGObject(obj)},
}
}

return _windowGroup
}
	

	
	// AddWindow adds a window to a `GtkWindowGroup`.
	func (w WindowGroup) AddWindow(window WindowClass)  {
var _arg0 *C.GtkWindowGroup // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_window_group_add_window(_arg0, _arg1)
}
	
	// RemoveWindow removes a window from a `GtkWindowGroup`.
	func (w WindowGroup) RemoveWindow(window WindowClass)  {
var _arg0 *C.GtkWindowGroup // out
var _arg1 *C.GtkWindow // out

_arg0 = (*C.GtkWindowGroup)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GtkWindow)(unsafe.Pointer(window.Native()))

C.gtk_window_group_remove_window(_arg0, _arg1)
}
	


	// WindowHandle: `GtkWindowHandle` is a titlebar area widget.
// 
// When added into a window, it can be dragged to move the window, and handles
// right click, double click and middle click as expected of a titlebar.
// 
// 
// CSS nodes
// 
// `GtkWindowHandle` has a single CSS node with the name `windowhandle`.
// 
// 
// Accessibility
// 
// `GtkWindowHandle` uses the GTK_ACCESSIBLE_ROLE_GROUP role.
	type WindowHandle struct {
		Widget
		Accessible
		Buildable
		ConstraintTarget
		
	}

	// WindowHandleClass is an interface that the WindowHandle class always
	// implements. It is only used for parameters that take in not just this
	// class but any other class that extends it.
	type WindowHandleClass interface {
		gextras.Objector
		_windowHandle()
	}

	func (WindowHandle) _windowHandle() {}

	
	func marshalWindowHandle(p uintptr) (interface{}, error) {
		val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
		obj := externglib.Take(unsafe.Pointer(val))
		return WrapWindowHandle(obj), nil
	}
	

	
	// NewWindowHandle creates a new `GtkWindowHandle`.
	func NewWindowHandle() WindowHandle {
var _cret *C.GtkWidget // in

_cret = C.gtk_window_handle_new()


var _windowHandle WindowHandle // out

{
obj := externglib.Take(unsafe.Pointer(_cret))
_windowHandle = WindowHandle{
Widget: Widget{
externglib.InitiallyUnowned: externglib.InitiallyUnowned{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
},
Accessible: Accessible{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
Buildable: Buildable{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
ConstraintTarget: ConstraintTarget{
Object: &externglib.Object{externglib.ToGObject(obj)},
},
}
}

return _windowHandle
}
	

	
	// Child gets the child widget of @self.
	func (s WindowHandle) Child() Widget {
var _arg0 *C.GtkWindowHandle // out
var _cret *C.GtkWidget // in

_arg0 = (*C.GtkWindowHandle)(unsafe.Pointer(s.Native()))

_cret = C.gtk_window_handle_get_child(_arg0)


var _widget Widget // out

_widget = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Widget)

return _widget
}
	
	// SetChild sets the child widget of @self.
	func (s WindowHandle) SetChild(child WidgetClass)  {
var _arg0 *C.GtkWindowHandle // out
var _arg1 *C.GtkWidget // out

_arg0 = (*C.GtkWindowHandle)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkWidget)(unsafe.Pointer(child.Native()))

C.gtk_window_handle_set_child(_arg0, _arg1)
}
	


	// Bitset: a `GtkBitset` represents a set of unsigned integers.
// 
// Another name for this data structure is "bitmap".
// 
// The current implementation is based on roaring bitmaps
// (https://roaringbitmap.org/).
// 
// A bitset allows adding a set of integers and provides support for set
// operations like unions, intersections and checks for equality or if a value
// is contained in the set. `GtkBitset` also contains various functions to query
// metadata about the bitset, such as the minimum or maximum values or its size.
// 
// The fastest way to iterate values in a bitset is [struct@Gtk.BitsetIter].
// 
// The main use case for `GtkBitset` is implementing complex selections for
// [iface@Gtk.SelectionModel].
	type Bitset struct {
		Native C.GtkBitset
	}

	
	func marshalBitset(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*Bitset)(unsafe.Pointer(b))
	}
	

	
	
	// NewBitsetEmpty constructs a struct Bitset.
	func NewBitsetEmpty() *Bitset {
var _cret *C.GtkBitset // in

_cret = C.gtk_bitset_new_empty()


var _bitset *Bitset // out

_bitset = *(**Bitset)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_bitset, func(v *Bitset) {
  C.free(unsafe.Pointer(v.Native()))
})

return _bitset
}
	
	
	
	// NewBitsetRange constructs a struct Bitset.
	func NewBitsetRange(start uint, nItems uint) *Bitset {
var _arg1 C.guint // out
var _arg2 C.guint // out
var _cret *C.GtkBitset // in

_arg1 = (C.guint)(start)
_arg2 = (C.guint)(nItems)

_cret = C.gtk_bitset_new_range(_arg1, _arg2)


var _bitset *Bitset // out

_bitset = *(**Bitset)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_bitset, func(v *Bitset) {
  C.free(unsafe.Pointer(v.Native()))
})

return _bitset
}
	
	

	

	// Native returns the underlying C source pointer.
	func (b *Bitset) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	
	// Add adds @value to @self if it wasn't part of it before.
	func (s *Bitset) Add(value uint) bool {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(value)

_cret = C.gtk_bitset_add(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// AddRange adds all values from @start (inclusive) to @start + @n_items
// (exclusive) in @self.
	func (s *Bitset) AddRange(start uint, nItems uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(start)
_arg2 = (C.guint)(nItems)

C.gtk_bitset_add_range(_arg0, _arg1, _arg2)
}
	
	// AddRangeClosed adds the closed range [@first, @last], so @first, @last and
// all values in between. @first must be smaller than @last.
	func (s *Bitset) AddRangeClosed(first uint, last uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(first)
_arg2 = (C.guint)(last)

C.gtk_bitset_add_range_closed(_arg0, _arg1, _arg2)
}
	
	// AddRectangle interprets the values as a 2-dimensional boolean grid with the
// given @stride and inside that grid, adds a rectangle with the given @width
// and @height.
	func (s *Bitset) AddRectangle(start uint, width uint, height uint, stride uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(start)
_arg2 = (C.guint)(width)
_arg3 = (C.guint)(height)
_arg4 = (C.guint)(stride)

C.gtk_bitset_add_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// Contains checks if the given @value has been added to @self
	func (s *Bitset) Contains(value uint) bool {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(value)

_cret = C.gtk_bitset_contains(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Copy creates a copy of @self.
	func (s *Bitset) Copy() *Bitset {
var _arg0 *C.GtkBitset // out
var _cret *C.GtkBitset // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bitset_copy(_arg0)


var _bitset *Bitset // out

_bitset = *(**Bitset)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_bitset, func(v *Bitset) {
  C.free(unsafe.Pointer(v.Native()))
})

return _bitset
}
	
	// Difference sets @self to be the symmetric difference of @self and @other.
// 
// The symmetric difference is set @self to contain all values that were either
// contained in @self or in @other, but not in both. This operation is also
// called an XOR.
// 
// It is allowed for @self and @other to be the same bitset. The bitset will be
// emptied in that case.
	func (s *Bitset) Difference(other *Bitset)  {
var _arg0 *C.GtkBitset // out
var _arg1 *C.GtkBitset // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

C.gtk_bitset_difference(_arg0, _arg1)
}
	
	// Equals returns true if @self and @other contain the same values.
	func (s *Bitset) Equals(other *Bitset) bool {
var _arg0 *C.GtkBitset // out
var _arg1 *C.GtkBitset // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

_cret = C.gtk_bitset_equals(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Maximum returns the largest value in @self.
// 
// If @self is empty, 0 is returned.
	func (s *Bitset) Maximum() uint {
var _arg0 *C.GtkBitset // out
var _cret C.guint // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bitset_get_maximum(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Minimum returns the smallest value in @self.
// 
// If @self is empty, `G_MAXUINT` is returned.
	func (s *Bitset) Minimum() uint {
var _arg0 *C.GtkBitset // out
var _cret C.guint // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bitset_get_minimum(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Nth returns the value of the @nth item in self.
// 
// If @nth is >= the size of @self, 0 is returned.
	func (s *Bitset) Nth(nth uint) uint {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _cret C.guint // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(nth)

_cret = C.gtk_bitset_get_nth(_arg0, _arg1)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// Size gets the number of values that were added to the set.
// 
// For example, if the set is empty, 0 is returned.
// 
// Note that this function returns a `guint64`, because when all values are set,
// the return value is `G_MAXUINT + 1`. Unless you are sure this cannot happen
// (it can't with `GListModel`), be sure to use a 64bit type.
	func (s *Bitset) Size() uint64 {
var _arg0 *C.GtkBitset // out
var _cret C.guint64 // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bitset_get_size(_arg0)


var _guint64 uint64 // out

_guint64 = (uint64)(_cret)

return _guint64
}
	
	// SizeInRange gets the number of values that are part of the set from @first to
// @last (inclusive).
// 
// Note that this function returns a `guint64`, because when all values are set,
// the return value is `G_MAXUINT + 1`. Unless you are sure this cannot happen
// (it can't with `GListModel`), be sure to use a 64bit type.
	func (s *Bitset) SizeInRange(first uint, last uint) uint64 {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _cret C.guint64 // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(first)
_arg2 = (C.guint)(last)

_cret = C.gtk_bitset_get_size_in_range(_arg0, _arg1, _arg2)


var _guint64 uint64 // out

_guint64 = (uint64)(_cret)

return _guint64
}
	
	// Intersect sets @self to be the intersection of @self and @other.
// 
// In other words, remove all values from @self that are not part of @other.
// 
// It is allowed for @self and @other to be the same bitset. Nothing will happen
// in that case.
	func (s *Bitset) Intersect(other *Bitset)  {
var _arg0 *C.GtkBitset // out
var _arg1 *C.GtkBitset // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

C.gtk_bitset_intersect(_arg0, _arg1)
}
	
	// IsEmpty: check if no value is contained in bitset.
	func (s *Bitset) IsEmpty() bool {
var _arg0 *C.GtkBitset // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bitset_is_empty(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ref acquires a reference on the given `GtkBitset`.
	func (s *Bitset) Ref() *Bitset {
var _arg0 *C.GtkBitset // out
var _cret *C.GtkBitset // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

_cret = C.gtk_bitset_ref(_arg0)


var _bitset *Bitset // out

_bitset = *(**Bitset)(unsafe.Pointer(&_cret))

return _bitset
}
	
	// Remove removes @value from @self if it was part of it before.
	func (s *Bitset) Remove(value uint) bool {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(value)

_cret = C.gtk_bitset_remove(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// RemoveAll removes all values from the bitset so that it is empty again.
	func (s *Bitset) RemoveAll()  {
var _arg0 *C.GtkBitset // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

C.gtk_bitset_remove_all(_arg0)
}
	
	// RemoveRange removes all values from @start (inclusive) to @start + @n_items
// (exclusive) in @self.
	func (s *Bitset) RemoveRange(start uint, nItems uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(start)
_arg2 = (C.guint)(nItems)

C.gtk_bitset_remove_range(_arg0, _arg1, _arg2)
}
	
	// RemoveRangeClosed removes the closed range [@first, @last], so @first, @last
// and all values in between. @first must be smaller than @last.
	func (s *Bitset) RemoveRangeClosed(first uint, last uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(first)
_arg2 = (C.guint)(last)

C.gtk_bitset_remove_range_closed(_arg0, _arg1, _arg2)
}
	
	// RemoveRectangle interprets the values as a 2-dimensional boolean grid with
// the given @stride and inside that grid, removes a rectangle with the given
// @width and @height.
	func (s *Bitset) RemoveRectangle(start uint, width uint, height uint, stride uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.guint // out
var _arg4 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(start)
_arg2 = (C.guint)(width)
_arg3 = (C.guint)(height)
_arg4 = (C.guint)(stride)

C.gtk_bitset_remove_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4)
}
	
	// ShiftLeft shifts all values in @self to the left by @amount.
// 
// Values smaller than @amount are discarded.
	func (s *Bitset) ShiftLeft(amount uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(amount)

C.gtk_bitset_shift_left(_arg0, _arg1)
}
	
	// ShiftRight shifts all values in @self to the right by @amount.
// 
// Values that end up too large to be held in a #guint are discarded.
	func (s *Bitset) ShiftRight(amount uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(amount)

C.gtk_bitset_shift_right(_arg0, _arg1)
}
	
	// Splice: this is a support function for `GListModel` handling, by mirroring
// the `GlistModel::items-changed` signal.
// 
// First, it "cuts" the values from @position to @removed from the bitset. That
// is, it removes all those values and shifts all larger values to the left by
// @removed places.
// 
// Then, it "pastes" new room into the bitset by shifting all values larger than
// @position by @added spaces to the right. This frees up space that can then be
// filled.
	func (s *Bitset) Splice(position uint, removed uint, added uint)  {
var _arg0 *C.GtkBitset // out
var _arg1 C.guint // out
var _arg2 C.guint // out
var _arg3 C.guint // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (C.guint)(position)
_arg2 = (C.guint)(removed)
_arg3 = (C.guint)(added)

C.gtk_bitset_splice(_arg0, _arg1, _arg2, _arg3)
}
	
	// Subtract sets @self to be the subtraction of @other from @self.
// 
// In other words, remove all values from @self that are part of @other.
// 
// It is allowed for @self and @other to be the same bitset. The bitset will be
// emptied in that case.
	func (s *Bitset) Subtract(other *Bitset)  {
var _arg0 *C.GtkBitset // out
var _arg1 *C.GtkBitset // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

C.gtk_bitset_subtract(_arg0, _arg1)
}
	
	// Union sets @self to be the union of @self and @other.
// 
// That is, add all values from @other into @self that weren't part of it.
// 
// It is allowed for @self and @other to be the same bitset. Nothing will happen
// in that case.
	func (s *Bitset) Union(other *Bitset)  {
var _arg0 *C.GtkBitset // out
var _arg1 *C.GtkBitset // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkBitset)(unsafe.Pointer(other.Native()))

C.gtk_bitset_union(_arg0, _arg1)
}
	
	// Unref releases a reference on the given `GtkBitset`.
// 
// If the reference was the last, the resources associated to the @self are
// freed.
	func (s *Bitset) Unref()  {
var _arg0 *C.GtkBitset // out

_arg0 = (*C.GtkBitset)(unsafe.Pointer(s.Native()))

C.gtk_bitset_unref(_arg0)
}
	


	// BitsetIter: an opaque, stack-allocated struct for iterating over the elements
// of a `GtkBitset`.
// 
// Before a `GtkBitsetIter` can be used, it needs to be initialized with
// [func@Gtk.BitsetIter.init_first], [func@Gtk.BitsetIter.init_last] or
// [func@Gtk.BitsetIter.init_at].
	type BitsetIter struct {
		Native C.GtkBitsetIter
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (b *BitsetIter) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	
	// Value gets the current value that @iter points to.
// 
// If @iter is not valid and [method@Gtk.BitsetIter.is_valid] returns false,
// this function returns 0.
	func (i *BitsetIter) Value() uint {
var _arg0 *C.GtkBitsetIter // out
var _cret C.guint // in

_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_bitset_iter_get_value(_arg0)


var _guint uint // out

_guint = (uint)(_cret)

return _guint
}
	
	// IsValid checks if @iter points to a valid value.
	func (i *BitsetIter) IsValid() bool {
var _arg0 *C.GtkBitsetIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_bitset_iter_is_valid(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Next moves @iter to the next value in the set.
// 
// If it was already pointing to the last value in the set, false is returned
// and @iter is invalidated.
	func (i *BitsetIter) Next() (uint, bool) {
var _arg0 *C.GtkBitsetIter // out
var _arg1 C.guint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_bitset_iter_next(_arg0, &_arg1)


var _value uint // out
var _ok bool // out

_value = (uint)(_arg1)
if _cret != 0 { _ok = true }

return _value, _ok
}
	
	// Previous moves @iter to the previous value in the set.
// 
// If it was already pointing to the first value in the set, false is returned
// and @iter is invalidated.
	func (i *BitsetIter) Previous() (uint, bool) {
var _arg0 *C.GtkBitsetIter // out
var _arg1 C.guint // in
var _cret C.gboolean // in

_arg0 = (*C.GtkBitsetIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_bitset_iter_previous(_arg0, &_arg1)


var _value uint // out
var _ok bool // out

_value = (uint)(_arg1)
if _cret != 0 { _ok = true }

return _value, _ok
}
	


	// Border: a struct that specifies a border around a rectangular area.
// 
// Each side can have different width.
	type Border struct {
		Native C.GtkBorder
	}

	
	func marshalBorder(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*Border)(unsafe.Pointer(b))
	}
	

	
	
	// NewBorder constructs a struct Border.
	func NewBorder() *Border {
var _cret *C.GtkBorder // in

_cret = C.gtk_border_new()


var _border *Border // out

_border = *(**Border)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_border, func(v *Border) {
  C.free(unsafe.Pointer(v.Native()))
})

return _border
}
	
	

	

	// Native returns the underlying C source pointer.
	func (b *Border) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	
	// Copy copies a Border-struct.
	func (b *Border) Copy() *Border {
var _arg0 *C.GtkBorder // out
var _cret *C.GtkBorder // in

_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

_cret = C.gtk_border_copy(_arg0)


var _border *Border // out

_border = *(**Border)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_border, func(v *Border) {
  C.free(unsafe.Pointer(v.Native()))
})

return _border
}
	
	// Free frees a Border-struct.
	func (b *Border) Free()  {
var _arg0 *C.GtkBorder // out

_arg0 = (*C.GtkBorder)(unsafe.Pointer(b.Native()))

C.gtk_border_free(_arg0)
}
	


	// BuildableParseContext: an opaque context struct for `GtkBuildableParser`.
	type BuildableParseContext struct {
		Native C.GtkBuildableParseContext
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (b *BuildableParseContext) Native() uintptr {
		return uintptr(unsafe.Pointer(&b.Native))
	}

	

	
	// Element retrieves the name of the currently open element.
// 
// If called from the start_element or end_element handlers this will give the
// element_name as passed to those functions. For the parent elements, see
// gtk_buildable_parse_context_get_element_stack().
	func (c *BuildableParseContext) Element() string {
var _arg0 *C.GtkBuildableParseContext // out
var _cret *C.char // in

_arg0 = (*C.GtkBuildableParseContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_buildable_parse_context_get_element(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// ElementStack retrieves the element stack from the internal state of the
// parser.
// 
// The returned Array is an array of strings where the last item is the
// currently open tag (as would be returned by
// gtk_buildable_parse_context_get_element()) and the previous item is its
// immediate parent.
// 
// This function is intended to be used in the start_element and end_element
// handlers where gtk_buildable_parse_context_get_element() would merely return
// the name of the element that is being processed.
	func (c *BuildableParseContext) ElementStack() []string {
var _arg0 *C.GtkBuildableParseContext // out
var _cret *C.GPtrArray

_arg0 = (*C.GtkBuildableParseContext)(unsafe.Pointer(c.Native()))

_cret = C.gtk_buildable_parse_context_get_element_stack(_arg0)


var _utf8s []string

{
var i int
var z C.GPtrArray
for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
  i++
}

src := unsafe.Slice(_cret, i)
_utf8s = make([]string, i)
for i := range src {
_utf8s[i] = C.GoString(src[i])
}
}

return _utf8s
}
	
	// Position retrieves the current line number and the number of the character on
// that line. Intended for use in error messages; there are no strict semantics
// for what constitutes the "current" line number other than "the best number we
// could come up with for error messages."
	func (c *BuildableParseContext) Position() (lineNumber int, charNumber int) {
var _arg0 *C.GtkBuildableParseContext // out
var _arg1 C.int // in
var _arg2 C.int // in

_arg0 = (*C.GtkBuildableParseContext)(unsafe.Pointer(c.Native()))

C.gtk_buildable_parse_context_get_position(_arg0, &_arg1, &_arg2)

var _lineNumber int // out
var _charNumber int // out

_lineNumber = (int)(_arg1)
_charNumber = (int)(_arg2)

return _lineNumber, _charNumber
}
	


	// CSSLocation represents a location in a file or other source of data parsed by
// the CSS engine.
// 
// The @bytes and @line_bytes offsets are meant to be used to programmatically
// match data. The @lines and @line_chars offsets can be used for printing the
// location in a file.
// 
// Note that the @lines parameter starts from 0 and is increased whenever a CSS
// line break is encountered. (CSS defines the C character sequences "\r\n",
// "\r", "\n" and "\f" as newlines.) If your document uses different rules for
// line breaking, you might want run into problems here.
	type CSSLocation struct {
		Native C.GtkCssLocation
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (c *CSSLocation) Native() uintptr {
		return uintptr(unsafe.Pointer(&c.Native))
	}

	

	


	// CSSSection defines a part of a CSS document.
// 
// Because sections are nested into one another, you can use
// gtk_css_section_get_parent() to get the containing region.
	type CSSSection struct {
		Native C.GtkCssSection
	}

	
	func marshalCSSSection(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*CSSSection)(unsafe.Pointer(b))
	}
	

	
	
	// NewCSSSection constructs a struct CSSSection.
	func NewCSSSection(file gio.File, start *CSSLocation, end *CSSLocation) *CSSSection {
var _arg1 *C.GFile // out
var _arg2 *C.GtkCssLocation // out
var _arg3 *C.GtkCssLocation // out
var _cret *C.GtkCssSection // in

_arg1 = (*C.GFile)(unsafe.Pointer(file.Native()))
_arg2 = (*C.GtkCssLocation)(unsafe.Pointer(start.Native()))
_arg3 = (*C.GtkCssLocation)(unsafe.Pointer(end.Native()))

_cret = C.gtk_css_section_new(_arg1, _arg2, _arg3)


var _cssSection *CSSSection // out

_cssSection = *(**CSSSection)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_cssSection, func(v *CSSSection) {
  C.free(unsafe.Pointer(v.Native()))
})

return _cssSection
}
	
	

	

	// Native returns the underlying C source pointer.
	func (c *CSSSection) Native() uintptr {
		return uintptr(unsafe.Pointer(&c.Native))
	}

	

	
	// EndLocation returns the location in the CSS document where this section ends.
	func (s *CSSSection) EndLocation() *CSSLocation {
var _arg0 *C.GtkCssSection // out
var _cret *C.GtkCssLocation // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_end_location(_arg0)


var _cssLocation *CSSLocation // out

_cssLocation = *(**CSSLocation)(unsafe.Pointer(&_cret))

return _cssLocation
}
	
	// File gets the file that @section was parsed from.
// 
// If no such file exists, for example because the CSS was loaded via
// [method@Gtk.CssProvider.load_from_data], then `NULL` is returned.
	func (s *CSSSection) File() gio.File {
var _arg0 *C.GtkCssSection // out
var _cret *C.GFile // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_file(_arg0)


var _file gio.File // out

_file = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gio.File)

return _file
}
	
	// Parent gets the parent section for the given `section`.
// 
// The parent section is the section that contains this `section`. A special
// case are sections of type `GTK_CSS_SECTION_DOCUMEN`T. Their parent will
// either be `NULL` if they are the original CSS document that was loaded by
// [method@Gtk.CssProvider.load_from_file] or a section of type
// `GTK_CSS_SECTION_IMPORT` if it was loaded with an `@import` rule from a
// different file.
	func (s *CSSSection) Parent() *CSSSection {
var _arg0 *C.GtkCssSection // out
var _cret *C.GtkCssSection // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_parent(_arg0)


var _cssSection *CSSSection // out

_cssSection = *(**CSSSection)(unsafe.Pointer(&_cret))

return _cssSection
}
	
	// StartLocation returns the location in the CSS document where this section
// starts.
	func (s *CSSSection) StartLocation() *CSSLocation {
var _arg0 *C.GtkCssSection // out
var _cret *C.GtkCssLocation // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_get_start_location(_arg0)


var _cssLocation *CSSLocation // out

_cssLocation = *(**CSSLocation)(unsafe.Pointer(&_cret))

return _cssLocation
}
	
	// Ref increments the reference count on `section`.
	func (s *CSSSection) Ref() *CSSSection {
var _arg0 *C.GtkCssSection // out
var _cret *C.GtkCssSection // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_ref(_arg0)


var _cssSection *CSSSection // out

_cssSection = *(**CSSSection)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_cssSection, func(v *CSSSection) {
  C.free(unsafe.Pointer(v.Native()))
})

return _cssSection
}
	
	// String prints the section into a human-readable text form using
// [method@Gtk.CssSection.print].
	func (s *CSSSection) String() string {
var _arg0 *C.GtkCssSection // out
var _cret *C.char // in

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

_cret = C.gtk_css_section_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Unref decrements the reference count on `section`, freeing the structure if
// the reference count reaches 0.
	func (s *CSSSection) Unref()  {
var _arg0 *C.GtkCssSection // out

_arg0 = (*C.GtkCssSection)(unsafe.Pointer(s.Native()))

C.gtk_css_section_unref(_arg0)
}
	


	
	type CSSStyleChange struct {
		Native C.GtkCssStyleChange
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (c *CSSStyleChange) Native() uintptr {
		return uintptr(unsafe.Pointer(&c.Native))
	}

	

	


	// ExpressionWatch: an opaque structure representing a watched `GtkExpression`.
// 
// The contents of `GtkExpressionWatch` should only be accessed through the
// provided API.
	type ExpressionWatch struct {
		Native C.GtkExpressionWatch
	}

	
	func marshalExpressionWatch(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*ExpressionWatch)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (e *ExpressionWatch) Native() uintptr {
		return uintptr(unsafe.Pointer(&e.Native))
	}

	

	
	// Evaluate evaluates the watched expression and on success stores the result in
// `value`.
// 
// This is equivalent to calling [method@Gtk.Expression.evaluate] with the
// expression and this pointer originally used to create `watch`.
	func (w *ExpressionWatch) Evaluate(value **externglib.Value) bool {
var _arg0 *C.GtkExpressionWatch // out
var _arg1 *C.GValue // out
var _cret C.gboolean // in

_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))
_arg1 = (*C.GValue)(value.GValue)

_cret = C.gtk_expression_watch_evaluate(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ref acquires a reference on the given `GtkExpressionWatch`.
	func (w *ExpressionWatch) Ref() *ExpressionWatch {
var _arg0 *C.GtkExpressionWatch // out
var _cret *C.GtkExpressionWatch // in

_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))

_cret = C.gtk_expression_watch_ref(_arg0)


var _expressionWatch *ExpressionWatch // out

_expressionWatch = *(**ExpressionWatch)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_expressionWatch, func(v *ExpressionWatch) {
  C.free(unsafe.Pointer(v.Native()))
})

return _expressionWatch
}
	
	// Unref releases a reference on the given `GtkExpressionWatch`.
// 
// If the reference was the last, the resources associated to `self` are freed.
	func (w *ExpressionWatch) Unref()  {
var _arg0 *C.GtkExpressionWatch // out

_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))

C.gtk_expression_watch_unref(_arg0)
}
	
	// Unwatch stops watching an expression.
// 
// See [method@Gtk.Expression.watch] for how the watch was established.
	func (w *ExpressionWatch) Unwatch()  {
var _arg0 *C.GtkExpressionWatch // out

_arg0 = (*C.GtkExpressionWatch)(unsafe.Pointer(w.Native()))

C.gtk_expression_watch_unwatch(_arg0)
}
	


	// PadActionEntry: struct defining a pad action entry.
	type PadActionEntry struct {
		Native C.GtkPadActionEntry
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (p *PadActionEntry) Native() uintptr {
		return uintptr(unsafe.Pointer(&p.Native))
	}

	

	


	// PageRange: a range of pages to print.
// 
// See also [method@Gtk.PrintSettings.set_page_ranges].
	type PageRange struct {
		Native C.GtkPageRange
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (p *PageRange) Native() uintptr {
		return uintptr(unsafe.Pointer(&p.Native))
	}

	

	


	// PaperSize: `GtkPaperSize` handles paper sizes.
// 
// It uses the standard called PWG 5101.1-2002 PWG: Standard for Media
// Standardized Names (http://www.pwg.org/standards.html) to name the paper
// sizes (and to get the data for the page sizes). In addition to standard paper
// sizes, `GtkPaperSize` allows to construct custom paper sizes with arbitrary
// dimensions.
// 
// The `GtkPaperSize` object stores not only the dimensions (width and height)
// of a paper size and its name, it also provides default print margins.
	type PaperSize struct {
		Native C.GtkPaperSize
	}

	
	func marshalPaperSize(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*PaperSize)(unsafe.Pointer(b))
	}
	

	
	
	// NewPaperSize constructs a struct PaperSize.
	func NewPaperSize(name string) *PaperSize {
var _arg1 *C.char // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_paper_size_new(_arg1)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeCustom constructs a struct PaperSize.
	func NewPaperSizeCustom(name string, displayName string, width float64, height float64, unit Unit) *PaperSize {
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 C.double // out
var _arg4 C.double // out
var _arg5 C.GtkUnit // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.char)(C.CString(name))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(displayName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.double)(width)
_arg4 = (C.double)(height)
_arg5 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_new_custom(_arg1, _arg2, _arg3, _arg4, _arg5)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeFromGVariant constructs a struct PaperSize.
	func NewPaperSizeFromGVariant(variant *glib.Variant) *PaperSize {
var _arg1 *C.GVariant // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.GVariant)(unsafe.Pointer(variant.Native()))

_cret = C.gtk_paper_size_new_from_gvariant(_arg1)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeFromIpp constructs a struct PaperSize.
	func NewPaperSizeFromIpp(ippName string, width float64, height float64) *PaperSize {
var _arg1 *C.char // out
var _arg2 C.double // out
var _arg3 C.double // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.char)(C.CString(ippName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.double)(width)
_arg3 = (C.double)(height)

_cret = C.gtk_paper_size_new_from_ipp(_arg1, _arg2, _arg3)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	
	
	// NewPaperSizeFromKeyFile constructs a struct PaperSize.
	func NewPaperSizeFromKeyFile(keyFile *glib.KeyFile, groupName string) (*PaperSize, error) {
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out
var _cret *C.GtkPaperSize // in
var _cerr *C.GError // in

_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

_cret = C.gtk_paper_size_new_from_key_file(_arg1, _arg2, &_cerr)


var _paperSize *PaperSize // out
var _goerr error // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _paperSize, _goerr
}
	
	
	
	// NewPaperSizeFromPpd constructs a struct PaperSize.
	func NewPaperSizeFromPpd(ppdName string, ppdDisplayName string, width float64, height float64) *PaperSize {
var _arg1 *C.char // out
var _arg2 *C.char // out
var _arg3 C.double // out
var _arg4 C.double // out
var _cret *C.GtkPaperSize // in

_arg1 = (*C.char)(C.CString(ppdName))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (*C.char)(C.CString(ppdDisplayName))
defer C.free(unsafe.Pointer(_arg2))
_arg3 = (C.double)(width)
_arg4 = (C.double)(height)

_cret = C.gtk_paper_size_new_from_ppd(_arg1, _arg2, _arg3, _arg4)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	

	

	// Native returns the underlying C source pointer.
	func (p *PaperSize) Native() uintptr {
		return uintptr(unsafe.Pointer(&p.Native))
	}

	

	
	// Copy copies an existing `GtkPaperSize`.
	func (o *PaperSize) Copy() *PaperSize {
var _arg0 *C.GtkPaperSize // out
var _cret *C.GtkPaperSize // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(o.Native()))

_cret = C.gtk_paper_size_copy(_arg0)


var _paperSize *PaperSize // out

_paperSize = *(**PaperSize)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_paperSize, func(v *PaperSize) {
  C.free(unsafe.Pointer(v.Native()))
})

return _paperSize
}
	
	// Free: free the given `GtkPaperSize` object.
	func (s *PaperSize) Free()  {
var _arg0 *C.GtkPaperSize // out

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

C.gtk_paper_size_free(_arg0)
}
	
	// DefaultBottomMargin gets the default bottom margin for the `GtkPaperSize`.
	func (s *PaperSize) DefaultBottomMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_bottom_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DefaultLeftMargin gets the default left margin for the `GtkPaperSize`.
	func (s *PaperSize) DefaultLeftMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_left_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DefaultRightMargin gets the default right margin for the `GtkPaperSize`.
	func (s *PaperSize) DefaultRightMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_right_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DefaultTopMargin gets the default top margin for the `GtkPaperSize`.
	func (s *PaperSize) DefaultTopMargin(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_default_top_margin(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// DisplayName gets the human-readable name of the `GtkPaperSize`.
	func (s *PaperSize) DisplayName() string {
var _arg0 *C.GtkPaperSize // out
var _cret *C.char // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_get_display_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Height gets the paper height of the `GtkPaperSize`, in units of @unit.
	func (s *PaperSize) Height(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_height(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// Name gets the name of the `GtkPaperSize`.
	func (s *PaperSize) Name() string {
var _arg0 *C.GtkPaperSize // out
var _cret *C.char // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_get_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PpdName gets the PPD name of the `GtkPaperSize`, which may be nil.
	func (s *PaperSize) PpdName() string {
var _arg0 *C.GtkPaperSize // out
var _cret *C.char // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_get_ppd_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// Width gets the paper width of the `GtkPaperSize`, in units of @unit.
	func (s *PaperSize) Width(unit Unit) float64 {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.GtkUnit // out
var _cret C.double // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.GtkUnit)(unit)

_cret = C.gtk_paper_size_get_width(_arg0, _arg1)


var _gdouble float64 // out

_gdouble = (float64)(_cret)

return _gdouble
}
	
	// IsCustom returns true if @size is not a standard paper size.
	func (s *PaperSize) IsCustom() bool {
var _arg0 *C.GtkPaperSize // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_is_custom(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsEqual compares two `GtkPaperSize` objects.
	func (s *PaperSize) IsEqual(size2 *PaperSize) bool {
var _arg0 *C.GtkPaperSize // out
var _arg1 *C.GtkPaperSize // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkPaperSize)(unsafe.Pointer(size2.Native()))

_cret = C.gtk_paper_size_is_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsIpp returns true if @size is an IPP standard paper size.
	func (s *PaperSize) IsIpp() bool {
var _arg0 *C.GtkPaperSize // out
var _cret C.gboolean // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))

_cret = C.gtk_paper_size_is_ipp(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// SetSize changes the dimensions of a @size to @width x @height.
	func (s *PaperSize) SetSize(width float64, height float64, unit Unit)  {
var _arg0 *C.GtkPaperSize // out
var _arg1 C.double // out
var _arg2 C.double // out
var _arg3 C.GtkUnit // out

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (C.double)(width)
_arg2 = (C.double)(height)
_arg3 = (C.GtkUnit)(unit)

C.gtk_paper_size_set_size(_arg0, _arg1, _arg2, _arg3)
}
	
	// ToGVariant: serialize a paper size to an `a{sv}` variant.
	func (p *PaperSize) ToGVariant() *glib.Variant {
var _arg0 *C.GtkPaperSize // out
var _cret *C.GVariant // in

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(p.Native()))

_cret = C.gtk_paper_size_to_gvariant(_arg0)


var _variant *glib.Variant // out

_variant = *(**glib.Variant)(unsafe.Pointer(&_cret))

return _variant
}
	
	// ToKeyFile: this function adds the paper size from @size to @key_file.
	func (s *PaperSize) ToKeyFile(keyFile *glib.KeyFile, groupName string)  {
var _arg0 *C.GtkPaperSize // out
var _arg1 *C.GKeyFile // out
var _arg2 *C.char // out

_arg0 = (*C.GtkPaperSize)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GKeyFile)(unsafe.Pointer(keyFile.Native()))
_arg2 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg2))

C.gtk_paper_size_to_key_file(_arg0, _arg1, _arg2)
}
	


	
	type PrintBackend struct {
		Native C.GtkPrintBackend
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (p *PrintBackend) Native() uintptr {
		return uintptr(unsafe.Pointer(&p.Native))
	}

	

	


	// RecentData: meta-data to be passed to gtk_recent_manager_add_full() when
// registering a recently used resource.
	type RecentData struct {
		Native C.GtkRecentData
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (r *RecentData) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	


	// RecentInfo: `GtkRecentInfo` contains the metadata associated with an item in
// the recently used files list.
	type RecentInfo struct {
		Native C.GtkRecentInfo
	}

	
	func marshalRecentInfo(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*RecentInfo)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (r *RecentInfo) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	
	// CreateAppInfo creates a `GAppInfo` for the specified `GtkRecentInfo`
	func (i *RecentInfo) CreateAppInfo(appName string) (gio.AppInfo, error) {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.char // out
var _cret *C.GAppInfo // in
var _cerr *C.GError // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(appName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_info_create_app_info(_arg0, _arg1, &_cerr)


var _appInfo gio.AppInfo // out
var _goerr error // out

_appInfo = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.AppInfo)
_goerr = gerror.Take(unsafe.Pointer(_cerr))

return _appInfo, _goerr
}
	
	// Exists checks whether the resource pointed by @info still exists. At the
// moment this check is done only on resources pointing to local files.
	func (i *RecentInfo) Exists() bool {
var _arg0 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_exists(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Age gets the number of days elapsed since the last update of the resource
// pointed by @info.
	func (i *RecentInfo) Age() int {
var _arg0 *C.GtkRecentInfo // out
var _cret C.int // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_age(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Description gets the (short) description of the resource.
	func (i *RecentInfo) Description() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.char // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_description(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// DisplayName gets the name of the resource.
// 
// If none has been defined, the basename of the resource is obtained.
	func (i *RecentInfo) DisplayName() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.char // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_display_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// GIcon retrieves the icon associated to the resource MIME type.
	func (i *RecentInfo) GIcon() gio.Icon {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.GIcon // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_gicon(_arg0)


var _icon gio.Icon // out

_icon = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(gio.Icon)

return _icon
}
	
	// MIMEType gets the MIME type of the resource.
	func (i *RecentInfo) MIMEType() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.char // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_mime_type(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// PrivateHint gets the value of the private flag.
// 
// Resources in the recently used list that have this flag set to true should
// only be displayed by the applications that have registered them.
	func (i *RecentInfo) PrivateHint() bool {
var _arg0 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_private_hint(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ShortName computes a valid UTF-8 string that can be used as the name of the
// item in a menu or list.
// 
// For example, calling this function on an item that refers to
// file:///foo/bar.txt will yield bar.txt.
	func (i *RecentInfo) ShortName() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.char // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_short_name(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// URI gets the URI of the resource.
	func (i *RecentInfo) URI() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.char // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_uri(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)

return _utf8
}
	
	// URIDisplay gets a displayable version of the resources URI.
// 
// If the resource is local, it returns a local path; if the resource is not
// local, it returns the UTF-8 encoded content of
// [method@Gtk.RecentInfo.get_uri].
	func (i *RecentInfo) URIDisplay() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.char // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_get_uri_display(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// HasApplication checks whether an application registered this resource using
// @app_name.
	func (i *RecentInfo) HasApplication(appName string) bool {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(appName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_info_has_application(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// HasGroup checks whether @group_name appears inside the groups registered for
// the recently used item @info.
	func (i *RecentInfo) HasGroup(groupName string) bool {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.char // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(groupName))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_recent_info_has_group(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsLocal checks whether the resource is local or not by looking at the scheme
// of its URI.
	func (i *RecentInfo) IsLocal() bool {
var _arg0 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_is_local(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// LastApplication gets the name of the last application that have registered
// the recently used resource represented by @info.
	func (i *RecentInfo) LastApplication() string {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.char // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_last_application(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Match checks whether two `GtkRecentInfo` point to the same resource.
	func (i *RecentInfo) Match(infoB *RecentInfo) bool {
var _arg0 *C.GtkRecentInfo // out
var _arg1 *C.GtkRecentInfo // out
var _cret C.gboolean // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkRecentInfo)(unsafe.Pointer(infoB.Native()))

_cret = C.gtk_recent_info_match(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Ref increases the reference count of @recent_info by one.
	func (i *RecentInfo) Ref() *RecentInfo {
var _arg0 *C.GtkRecentInfo // out
var _cret *C.GtkRecentInfo // in

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

_cret = C.gtk_recent_info_ref(_arg0)


var _recentInfo *RecentInfo // out

_recentInfo = *(**RecentInfo)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_recentInfo, func(v *RecentInfo) {
  C.free(unsafe.Pointer(v.Native()))
})

return _recentInfo
}
	
	// Unref decreases the reference count of @info by one.
// 
// If the reference count reaches zero, @info is deallocated, and the memory
// freed.
	func (i *RecentInfo) Unref()  {
var _arg0 *C.GtkRecentInfo // out

_arg0 = (*C.GtkRecentInfo)(unsafe.Pointer(i.Native()))

C.gtk_recent_info_unref(_arg0)
}
	


	// RequestedSize represents a request of a screen object in a given orientation.
// These are primarily used in container implementations when allocating a
// natural size for children calling. See gtk_distribute_natural_allocation().
	type RequestedSize struct {
		Native C.GtkRequestedSize
	}

	

	

	

	// Native returns the underlying C source pointer.
	func (r *RequestedSize) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	


	// Requisition: a Requisition-struct represents the desired size of a widget.
// See [GtkWidgets geometry management section][geometry-management] for more
// information.
	type Requisition struct {
		Native C.GtkRequisition
	}

	
	func marshalRequisition(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*Requisition)(unsafe.Pointer(b))
	}
	

	
	
	// NewRequisition constructs a struct Requisition.
	func NewRequisition() *Requisition {
var _cret *C.GtkRequisition // in

_cret = C.gtk_requisition_new()


var _requisition *Requisition // out

_requisition = *(**Requisition)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_requisition, func(v *Requisition) {
  C.free(unsafe.Pointer(v.Native()))
})

return _requisition
}
	
	

	

	// Native returns the underlying C source pointer.
	func (r *Requisition) Native() uintptr {
		return uintptr(unsafe.Pointer(&r.Native))
	}

	

	
	// Copy copies a `GtkRequisition`.
	func (r *Requisition) Copy() *Requisition {
var _arg0 *C.GtkRequisition // out
var _cret *C.GtkRequisition // in

_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

_cret = C.gtk_requisition_copy(_arg0)


var _ret *Requisition // out

_ret = *(**Requisition)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_ret, func(v *Requisition) {
  C.free(unsafe.Pointer(v.Native()))
})

return _ret
}
	
	// Free frees a `GtkRequisition`.
	func (r *Requisition) Free()  {
var _arg0 *C.GtkRequisition // out

_arg0 = (*C.GtkRequisition)(unsafe.Pointer(r.Native()))

C.gtk_requisition_free(_arg0)
}
	


	// TextIter: an iterator for the contents of a `GtkTextBuffer`.
// 
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
	type TextIter struct {
		Native C.GtkTextIter
	}

	
	func marshalTextIter(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TextIter)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (t *TextIter) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Assign assigns the value of @other to @iter.
// 
// This function is not useful in applications, because iterators can be
// assigned with `GtkTextIter i = j;`.
// 
// The function is used by language bindings.
	func (i *TextIter) Assign(other *TextIter)  {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(other.Native()))

C.gtk_text_iter_assign(_arg0, _arg1)
}
	
	// BackwardChar moves backward by one character offset.
// 
// Returns true if movement was possible; if @iter was the first in the buffer
// (character offset 0), this function returns false for convenience when
// writing loops.
	func (i *TextIter) BackwardChar() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_char(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardChars moves @count characters backward, if possible.
// 
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
// 
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false.
	func (i *TextIter) BackwardChars(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_chars(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
	func (i *TextIter) BackwardCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardCursorPositions moves up to @count cursor positions.
// 
// See [method@Gtk.TextIter.forward_cursor_position] for details.
	func (i *TextIter) BackwardCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardLine moves @iter to the start of the previous line.
// 
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore, if @iter was already on line 0,
// but not at the start of the line, @iter is snapped to the start of the line
// and the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
	func (i *TextIter) BackwardLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardLines moves @count lines backward, if possible.
// 
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
// 
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves forward by 0 - @count lines.
	func (i *TextIter) BackwardLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
// 
// @match_end will never be set to a `GtkTextIter` located after @iter, even if
// there is a possible @match_start before or at @iter.
	func (i *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.char // out
var _arg2 C.GtkTextSearchFlags // out
var _matchStart TextIter
var _matchEnd TextIter
var _arg5 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkTextSearchFlags)(flags)
_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

_cret = C.gtk_text_iter_backward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)




var _ok bool // out



if _cret != 0 { _ok = true }

return _matchStart, _matchEnd, _ok
}
	
	// BackwardSentenceStart moves backward to the previous sentence start.
// 
// If @iter is already at the start of a sentence, moves backward to the next
// one.
// 
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
	func (i *TextIter) BackwardSentenceStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_sentence_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// @count times.
// 
// If @count is negative, moves forward instead of backward.
	func (i *TextIter) BackwardSentenceStarts(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_sentence_starts(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardToTagToggle moves backward to the next toggle (on or off) of the
// @tag, or to the next toggle of any tag if @tag is nil.
// 
// If no matching tag toggles are found, returns false, otherwise true. Does not
// return toggles located at @iter, only toggles before @iter. Sets @iter to the
// location of the toggle, or the start of the buffer if no toggle is found.
	func (i *TextIter) BackwardToTagToggle(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_backward_to_tag_toggle(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleCursorPosition moves @iter forward to the previous visible
// cursor position.
// 
// See [method@Gtk.TextIter.backward_cursor_position] for details.
	func (i *TextIter) BackwardVisibleCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_visible_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleCursorPositions moves up to @count visible cursor positions.
// 
// See [method@Gtk.TextIter.backward_cursor_position] for details.
	func (i *TextIter) BackwardVisibleCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_visible_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleLine moves @iter to the start of the previous visible line.
// 
// Returns true if @iter could be moved; i.e. if @iter was at character offset
// 0, this function returns false. Therefore if @iter was already on line 0, but
// not at the start of the line, @iter is snapped to the start of the line and
// the function returns true. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
	func (i *TextIter) BackwardVisibleLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_visible_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleLines moves @count visible lines backward, if possible.
// 
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
// 
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves forward by 0 - @count lines.
	func (i *TextIter) BackwardVisibleLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_visible_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleWordStart moves backward to the previous visible word start.
// 
// If @iter is currently on a word start, moves backward to the next one after
// that.
// 
// Word breaks are determined by Pango and should be correct for nearly any
// language.
	func (i *TextIter) BackwardVisibleWordStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_visible_word_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to @count times.
	func (i *TextIter) BackwardVisibleWordStarts(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_visible_word_starts(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardWordStart moves backward to the previous word start.
// 
// If @iter is currently on a word start, moves backward to the next one after
// that.
// 
// Word breaks are determined by Pango and should be correct for nearly any
// language
	func (i *TextIter) BackwardWordStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_backward_word_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to @count
// times.
	func (i *TextIter) BackwardWordStarts(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_backward_word_starts(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at @iter would be
// editable.
// 
// If text inserted at @iter would be editable then the user should be allowed
// to insert text at @iter. [method@Gtk.TextBuffer.insert_interactive] uses this
// function to decide whether insertions are allowed at a given position.
	func (i *TextIter) CanInsert(defaultEditability bool) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
if defaultEditability { _arg1 = C.TRUE }

_cret = C.gtk_text_iter_can_insert(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Compare: a qsort()-style function that returns negative if @lhs is less than
// @rhs, positive if @lhs is greater than @rhs, and 0 if theyre equal.
// 
// Ordering is in character offset order, i.e. the first character in the buffer
// is less than the second character in the buffer.
	func (l *TextIter) Compare(rhs *TextIter) int {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

_cret = C.gtk_text_iter_compare(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Copy creates a dynamically-allocated copy of an iterator.
// 
// This function is not useful in applications, because iterators can be copied
// with a simple assignment (`GtkTextIter i = j;`).
// 
// The function is used by language bindings.
	func (i *TextIter) Copy() *TextIter {
var _arg0 *C.GtkTextIter // out
var _cret *C.GtkTextIter // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_copy(_arg0)


var _textIter *TextIter // out

_textIter = *(**TextIter)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_textIter, func(v *TextIter) {
  C.free(unsafe.Pointer(v.Native()))
})

return _textIter
}
	
	// Editable returns whether the character at @iter is within an editable region
// of text.
// 
// Non-editable text is locked and cant be changed by the user via TextView.
// If no tags applied to this text affect editability, @default_setting will be
// returned.
// 
// You dont want to use this function to decide whether text can be inserted at
// @iter, because for insertion you dont want to know whether the char at @iter
// is inside an editable range, you want to know whether a new character
// inserted at @iter would be inside an editable range. Use
// [method@Gtk.TextIter.can_insert] to handle this case.
	func (i *TextIter) Editable(defaultSetting bool) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.gboolean // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
if defaultSetting { _arg1 = C.TRUE }

_cret = C.gtk_text_iter_editable(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsLine returns true if @iter points to the start of the paragraph delimiter
// characters for a line.
// 
// Delimiters will be either a newline, a carriage return, a carriage return
// followed by a newline, or a Unicode paragraph separator character.
// 
// Note that an iterator pointing to the \n of a \r\n pair will not be counted
// as the end of a line, the line ends before the \r. The end iterator is
// considered to be at the end of a line, even though there are no paragraph
// delimiter chars there.
	func (i *TextIter) EndsLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_ends_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsSentence determines whether @iter ends a sentence.
// 
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
	func (i *TextIter) EndsSentence() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_ends_sentence(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsTag returns true if @tag is toggled off at exactly this point.
// 
// If @tag is nil, returns true if any tag is toggled off at this point.
// 
// Note that if this function returns true, it means that @iter is at the end of
// the tagged range, but that the character at @iter is outside the tagged
// range. In other words, unlike [method@Gtk.TextIter.starts_tag], if this
// function returns true, [method@Gtk.TextIter.has_tag] will return false for
// the same parameters.
	func (i *TextIter) EndsTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_ends_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// EndsWord determines whether @iter ends a natural-language word.
// 
// Word breaks are determined by Pango and should be correct for nearly any
// language.
	func (i *TextIter) EndsWord() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_ends_word(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Equal tests whether two iterators are equal, using the fastest possible
// mechanism.
// 
// This function is very fast; you can expect it to perform better than e.g.
// getting the character offset for each iterator and comparing the offsets
// yourself. Also, its a bit faster than [method@Gtk.TextIter.compare].
	func (l *TextIter) Equal(rhs *TextIter) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(l.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs.Native()))

_cret = C.gtk_text_iter_equal(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardChar moves @iter forward by one character offset.
// 
// Note that images embedded in the buffer occupy 1 character slot, so this
// function may actually move onto an image instead of a character, if you have
// images in your buffer. If @iter is the end iterator or one character before
// it, @iter will now point at the end iterator, and this function returns false
// for convenience when writing loops.
	func (i *TextIter) ForwardChar() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_char(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardChars moves @count characters if possible.
// 
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
// 
// The return value indicates whether the new position of @iter is different
// from its original position, and dereferenceable (the last iterator in the
// buffer is not dereferenceable). If @count is 0, the function does nothing and
// returns false.
	func (i *TextIter) ForwardChars(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_chars(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardCursorPosition moves @iter forward by a single cursor position.
// 
// Cursor positions are (unsurprisingly) positions where the cursor can appear.
// Perhaps surprisingly, there may not be a cursor position between all
// characters. The most common example for European languages would be a
// carriage return/newline sequence.
// 
// For some Unicode characters, the equivalent of say the letter a with an
// accent mark will be represented as two characters, first the letter then a
// "combining mark" that causes the accent to be rendered; so the cursor cant
// go between those two characters.
// 
// See also the [struct@Pango.LogAttr] struct and the [func@Pango.break]
// function.
	func (i *TextIter) ForwardCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardCursorPositions moves up to @count cursor positions.
// 
// See [method@Gtk.TextIter.forward_cursor_position] for details.
	func (i *TextIter) ForwardCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardLine moves @iter to the start of the next line.
// 
// If the iter is already on the last line of the buffer, moves the iter to the
// end of the current line. If after the operation, the iter is at the end of
// the buffer and not dereferenceable, returns false. Otherwise, returns true.
	func (i *TextIter) ForwardLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardLines moves @count lines forward, if possible.
// 
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
// 
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves backward by 0 - @count lines.
	func (i *TextIter) ForwardLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardSearch searches forward for @str.
// 
// Any match is returned by setting @match_start to the first character of the
// match and @match_end to the first character after the match. The search will
// not continue past @limit. Note that a search is a linear or O(n) operation,
// so you may wish to use @limit to avoid locking up your UI on large buffers.
// 
// @match_start will never be set to a `GtkTextIter` located before @iter, even
// if there is a possible @match_end after or at @iter.
	func (i *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.char // out
var _arg2 C.GtkTextSearchFlags // out
var _matchStart TextIter
var _matchEnd TextIter
var _arg5 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.char)(C.CString(str))
defer C.free(unsafe.Pointer(_arg1))
_arg2 = (C.GtkTextSearchFlags)(flags)
_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit.Native()))

_cret = C.gtk_text_iter_forward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)




var _ok bool // out



if _cret != 0 { _ok = true }

return _matchStart, _matchEnd, _ok
}
	
	// ForwardSentenceEnd moves forward to the next sentence end.
// 
// If @iter is at the end of a sentence, moves to the next end of sentence.
// 
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
	func (i *TextIter) ForwardSentenceEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_sentence_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() @count times.
// 
// If @count is negative, moves backward instead of forward.
	func (i *TextIter) ForwardSentenceEnds(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_sentence_ends(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardToEnd moves @iter forward to the end iterator, which points one past
// the last valid character in the buffer.
// 
// gtk_text_iter_get_char() called on the end iterator returns 0, which is
// convenient for writing loops.
	func (i *TextIter) ForwardToEnd()  {
var _arg0 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

C.gtk_text_iter_forward_to_end(_arg0)
}
	
	// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters.
// 
// The possible characters are either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character.
// 
// If the iterator is already at the paragraph delimiter characters, moves to
// the paragraph delimiter characters for the next line. If @iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns false.
	func (i *TextIter) ForwardToLineEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_to_line_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardToTagToggle moves forward to the next toggle (on or off) of the @tag,
// or to the next toggle of any tag if @tag is nil.
// 
// If no matching tag toggles are found, returns false, otherwise true. Does not
// return toggles located at @iter, only toggles after @iter. Sets @iter to the
// location of the toggle, or to the end of the buffer if no toggle is found.
	func (i *TextIter) ForwardToTagToggle(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_forward_to_tag_toggle(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleCursorPosition moves @iter forward to the next visible cursor
// position.
// 
// See [method@Gtk.TextIter.forward_cursor_position] for details.
	func (i *TextIter) ForwardVisibleCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_visible_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleCursorPositions moves up to @count visible cursor positions.
// 
// See [method@Gtk.TextIter.forward_cursor_position] for details.
	func (i *TextIter) ForwardVisibleCursorPositions(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_visible_cursor_positions(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleLine moves @iter to the start of the next visible line.
// 
// Returns true if there was a next line to move to, and false if @iter was
// simply moved to the end of the buffer and is now not dereferenceable, or if
// @iter was already at the end of the buffer.
	func (i *TextIter) ForwardVisibleLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_visible_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleLines moves @count visible lines forward, if possible.
// 
// If @count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
// 
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didnt move, or moved onto the end iterator, then
// false is returned. If @count is 0, the function does nothing and returns
// false. If @count is negative, moves backward by 0 - @count lines.
	func (i *TextIter) ForwardVisibleLines(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_visible_lines(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleWordEnd moves forward to the next visible word end.
// 
// If @iter is currently on a word end, moves forward to the next one after
// that.
// 
// Word breaks are determined by Pango and should be correct for nearly any
// language
	func (i *TextIter) ForwardVisibleWordEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_visible_word_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// @count times.
	func (i *TextIter) ForwardVisibleWordEnds(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_visible_word_ends(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardWordEnd moves forward to the next word end.
// 
// If @iter is currently on a word end, moves forward to the next one after
// that.
// 
// Word breaks are determined by Pango and should be correct for nearly any
// language.
	func (i *TextIter) ForwardWordEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_forward_word_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to @count times.
	func (i *TextIter) ForwardWordEnds(count int) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(count)

_cret = C.gtk_text_iter_forward_word_ends(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Free: free an iterator allocated on the heap.
// 
// This function is intended for use in language bindings, and is not especially
// useful for applications, because iterators can simply be allocated on the
// stack.
	func (i *TextIter) Free()  {
var _arg0 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

C.gtk_text_iter_free(_arg0)
}
	
	// Buffer returns the `GtkTextBuffer` this iterator is associated with.
	func (i *TextIter) Buffer() TextBuffer {
var _arg0 *C.GtkTextIter // out
var _cret *C.GtkTextBuffer // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_buffer(_arg0)


var _textBuffer TextBuffer // out

_textBuffer = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextBuffer)

return _textBuffer
}
	
	// BytesInLine returns the number of bytes in the line containing @iter,
// including the paragraph delimiters.
	func (i *TextIter) BytesInLine() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_bytes_in_line(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Char: the Unicode character at this iterator is returned.
// 
// Equivalent to operator* on a C++ iterator. If the element at this iterator is
// a non-character element, such as an image embedded in the buffer, the Unicode
// unknown character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character.
// 
// So you can write a loop which ends when this function returns 0.
	func (i *TextIter) Char() uint32 {
var _arg0 *C.GtkTextIter // out
var _cret C.gunichar // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_char(_arg0)


var _gunichar uint32 // out

_gunichar = (uint32)(_cret)

return _gunichar
}
	
	// CharsInLine returns the number of characters in the line containing @iter,
// including the paragraph delimiters.
	func (i *TextIter) CharsInLine() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_chars_in_line(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// ChildAnchor: if the location at @iter contains a child anchor, the anchor is
// returned.
// 
// Otherwise, nil is returned.
	func (i *TextIter) ChildAnchor() TextChildAnchor {
var _arg0 *C.GtkTextIter // out
var _cret *C.GtkTextChildAnchor // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_child_anchor(_arg0)


var _textChildAnchor TextChildAnchor // out

_textChildAnchor = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TextChildAnchor)

return _textChildAnchor
}
	
	// Language returns the language in effect at @iter.
// 
// If no tags affecting language apply to @iter, the return value is identical
// to that of [func@Gtk.get_default_language].
	func (i *TextIter) Language() *pango.Language {
var _arg0 *C.GtkTextIter // out
var _cret *C.PangoLanguage // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_language(_arg0)


var _language *pango.Language // out

_language = *(**pango.Language)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_language, func(v *pango.Language) {
  C.free(unsafe.Pointer(v.Native()))
})

return _language
}
	
	// Line returns the line number containing the iterator.
// 
// Lines in a `GtkTextBuffer` are numbered beginning with 0 for the first line
// in the buffer.
	func (i *TextIter) Line() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_line(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line.
// 
// Remember that `GtkTextBuffer` encodes text in UTF-8, and that characters can
// require a variable number of bytes to represent.
	func (i *TextIter) LineIndex() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_line_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line.
// 
// The first character on the line has offset 0.
	func (i *TextIter) LineOffset() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_line_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Offset returns the character offset of an iterator.
// 
// Each character in a `GtkTextBuffer` has an offset, starting with 0 for the
// first character in the buffer. Use [method@Gtk,TextBuffer.get_iter_at_offset]
// to convert an offset back into an iterator.
	func (i *TextIter) Offset() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Paintable: if the element at @iter is a paintable, the paintable is returned.
// 
// Otherwise, nil is returned.
	func (i *TextIter) Paintable() gdk.Paintable {
var _arg0 *C.GtkTextIter // out
var _cret *C.GdkPaintable // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_paintable(_arg0)


var _paintable gdk.Paintable // out

_paintable = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(gdk.Paintable)

return _paintable
}
	
	// Slice returns the text in the given range.
// 
// A slice is an array of characters encoded in UTF-8 format, including the
// Unicode unknown character 0xFFFC for iterable non-character elements in the
// buffer, such as images. Because images are encoded in the slice, byte and
// character offsets in the returned array will correspond to byte offsets in
// the text buffer. Note that 0xFFFC can occur in normal text as well, so it is
// not a reliable indicator that a paintable or widget is in the buffer.
	func (s *TextIter) Slice(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.char // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_slice(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Text returns text in the given range.
// 
// If the range contains non-text elements such as images, the character and
// byte offsets in the returned string will not correspond to character and byte
// offsets in the buffer. If you want offsets to correspond, see
// [method@Gtk.TextIter.get_slice].
	func (s *TextIter) Text(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.char // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// VisibleLineIndex returns the number of bytes from the start of the line to
// the given @iter, not counting bytes that are invisible due to tags with the
// invisible flag toggled on.
	func (i *TextIter) VisibleLineIndex() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_visible_line_index(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VisibleLineOffset returns the offset in characters from the start of the line
// to the given @iter, not counting characters that are invisible due to tags
// with the invisible flag toggled on.
	func (i *TextIter) VisibleLineOffset() int {
var _arg0 *C.GtkTextIter // out
var _cret C.int // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_get_visible_line_offset(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// VisibleSlice returns visible text in the given range.
// 
// Like [method@Gtk.TextIter.get_slice], but invisible text is not included.
// Invisible text is usually invisible because a `GtkTextTag` with the
// invisible attribute turned on has been applied to it.
	func (s *TextIter) VisibleSlice(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.char // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_visible_slice(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// VisibleText returns visible text in the given range.
// 
// Like [method@Gtk.TextIter.get_text], but invisible text is not included.
// Invisible text is usually invisible because a `GtkTextTag` with the
// invisible attribute turned on has been applied to it.
	func (s *TextIter) VisibleText(end *TextIter) string {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _cret *C.char // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(s.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_get_visible_text(_arg0, _arg1)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// HasTag returns true if @iter points to a character that is part of a range
// tagged with @tag.
// 
// See also [method@Gtk.TextIter.starts_tag] and [method@Gtk.TextIter.ends_tag].
	func (i *TextIter) HasTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_has_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InRange checks whether @iter falls in the range [@start, @end).
// 
// @start and @end must be in ascending order.
	func (i *TextIter) InRange(start *TextIter, end *TextIter) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out
var _arg2 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start.Native()))
_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end.Native()))

_cret = C.gtk_text_iter_in_range(_arg0, _arg1, _arg2)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsideSentence determines whether @iter is inside a sentence (as opposed to
// in between two sentences, e.g. after a period and before the first letter of
// the next sentence).
// 
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
	func (i *TextIter) InsideSentence() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_inside_sentence(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// InsideWord determines whether the character pointed by @iter is part of a
// natural-language word (as opposed to say inside some whitespace).
// 
// Word breaks are determined by Pango and should be correct for nearly any
// language.
// 
// Note that if [method@Gtk.TextIter.starts_word] returns true, then this
// function returns true too, since @iter points to the first character of the
// word.
	func (i *TextIter) InsideWord() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_inside_word(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsCursorPosition: determine if @iter is at a cursor position.
// 
// See [method@Gtk.TextIter.forward_cursor_position] or [struct@Pango.LogAttr]
// or [func@Pango.break] for details on what a cursor position is.
	func (i *TextIter) IsCursorPosition() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_is_cursor_position(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsEnd returns true if @iter is the end iterator.
// 
// This means it is one past the last dereferenceable iterator in the buffer.
// gtk_text_iter_is_end() is the most efficient way to check whether an iterator
// is the end iterator.
	func (i *TextIter) IsEnd() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_is_end(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsStart returns true if @iter is the first iterator in the buffer.
	func (i *TextIter) IsStart() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_is_start(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Order swaps the value of @first and @second if @second comes before @first in
// the buffer.
// 
// That is, ensures that @first and @second are in sequence. Most text buffer
// functions that take a range call this automatically on your behalf, so
// theres no real reason to call it yourself in those cases. There are some
// exceptions, such as [method@Gtk.TextIter.in_range], that expect a pre-sorted
// range.
	func (f *TextIter) Order(second *TextIter)  {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextIter // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(f.Native()))
_arg1 = (*C.GtkTextIter)(unsafe.Pointer(second.Native()))

C.gtk_text_iter_order(_arg0, _arg1)
}
	
	// SetLine moves iterator @iter to the start of the line @line_number.
// 
// If @line_number is negative or larger than or equal to the number of lines in
// the buffer, moves @iter to the start of the last line in the buffer.
	func (i *TextIter) SetLine(lineNumber int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(lineNumber)

C.gtk_text_iter_set_line(_arg0, _arg1)
}
	
	// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it cant be
// in the middle of a UTF-8 encoded character.
	func (i *TextIter) SetLineIndex(byteOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(byteOnLine)

C.gtk_text_iter_set_line_index(_arg0, _arg1)
}
	
	// SetLineOffset moves @iter within a line, to a new character (not byte)
// offset.
// 
// The given character offset must be less than or equal to the number of
// characters in the line; if equal, @iter moves to the start of the next line.
// See [method@Gtk.TextIter.set_line_index] if you have a byte index rather than
// a character offset.
	func (i *TextIter) SetLineOffset(charOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(charOnLine)

C.gtk_text_iter_set_line_offset(_arg0, _arg1)
}
	
	// SetOffset sets @iter to point to @char_offset.
// 
// @char_offset counts from the start of the entire text buffer, starting with
// 0.
	func (i *TextIter) SetOffset(charOffset int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(charOffset)

C.gtk_text_iter_set_offset(_arg0, _arg1)
}
	
	// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
	func (i *TextIter) SetVisibleLineIndex(byteOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(byteOnLine)

C.gtk_text_iter_set_visible_line_index(_arg0, _arg1)
}
	
	// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
	func (i *TextIter) SetVisibleLineOffset(charOnLine int)  {
var _arg0 *C.GtkTextIter // out
var _arg1 C.int // out

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (C.int)(charOnLine)

C.gtk_text_iter_set_visible_line_offset(_arg0, _arg1)
}
	
	// StartsLine returns true if @iter begins a paragraph.
// 
// This is the case if [method@Gtk.TextIter.get_line_offset] would return 0.
// However this function is potentially more efficient than
// [method@Gtk.TextIter.get_line_offset], because it doesnt have to compute the
// offset, it just has to see whether its 0.
	func (i *TextIter) StartsLine() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_starts_line(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartsSentence determines whether @iter begins a sentence.
// 
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
	func (i *TextIter) StartsSentence() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_starts_sentence(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartsTag returns true if @tag is toggled on at exactly this point.
// 
// If @tag is nil, returns true if any tag is toggled on at this point.
// 
// Note that if this function returns true, it means that @iter is at the
// beginning of the tagged range, and that the character at @iter is inside the
// tagged range. In other words, unlike [method@Gtk.TextIter.ends_tag], if this
// function returns true, [method@Gtk.TextIter.has_tag will also return true for
// the same parameters.
	func (i *TextIter) StartsTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_starts_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// StartsWord determines whether @iter begins a natural-language word.
// 
// Word breaks are determined by Pango and should be correct for nearly any
// language.
	func (i *TextIter) StartsWord() bool {
var _arg0 *C.GtkTextIter // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_text_iter_starts_word(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// TogglesTag gets whether a range with @tag applied to it begins or ends at
// @iter.
// 
// This is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag())
	func (i *TextIter) TogglesTag(tag TextTagClass) bool {
var _arg0 *C.GtkTextIter // out
var _arg1 *C.GtkTextTag // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTextIter)(unsafe.Pointer(i.Native()))
_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

_cret = C.gtk_text_iter_toggles_tag(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// TreeIter: the TreeIter is the primary structure for accessing a TreeModel.
// Models are expected to put a unique integer in the @stamp member, and put
// model-specific data in the three @user_data members.
	type TreeIter struct {
		Native C.GtkTreeIter
	}

	
	func marshalTreeIter(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TreeIter)(unsafe.Pointer(b))
	}
	

	

	

	// Native returns the underlying C source pointer.
	func (t *TreeIter) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Copy creates a dynamically allocated tree iterator as a copy of @iter.
// 
// This function is not intended for use in applications, because you can just
// copy the structs by value (`GtkTreeIter new_iter = iter;`). You must free
// this iter with gtk_tree_iter_free().
	func (i *TreeIter) Copy() *TreeIter {
var _arg0 *C.GtkTreeIter // out
var _cret *C.GtkTreeIter // in

_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

_cret = C.gtk_tree_iter_copy(_arg0)


var _treeIter *TreeIter // out

_treeIter = *(**TreeIter)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeIter, func(v *TreeIter) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeIter
}
	
	// Free frees an iterator that has been allocated by gtk_tree_iter_copy().
// 
// This function is mainly used for language bindings.
	func (i *TreeIter) Free()  {
var _arg0 *C.GtkTreeIter // out

_arg0 = (*C.GtkTreeIter)(unsafe.Pointer(i.Native()))

C.gtk_tree_iter_free(_arg0)
}
	


	// TreePath: an opaque structure representing a path to a row in a model.
	type TreePath struct {
		Native C.GtkTreePath
	}

	
	func marshalTreePath(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TreePath)(unsafe.Pointer(b))
	}
	

	
	
	// NewTreePath constructs a struct TreePath.
	func NewTreePath() *TreePath {
var _cret *C.GtkTreePath // in

_cret = C.gtk_tree_path_new()


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	
	
	// NewTreePathFirst constructs a struct TreePath.
	func NewTreePathFirst() *TreePath {
var _cret *C.GtkTreePath // in

_cret = C.gtk_tree_path_new_first()


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	
	
	
	
	// NewTreePathFromIndicesv constructs a struct TreePath.
	func NewTreePathFromIndicesv(indices []int) *TreePath {
var _arg1 *C.int
var _arg2 C.gsize
var _cret *C.GtkTreePath // in

_arg2 = C.gsize(len(indices))
_arg1 = (*C.int)(unsafe.Pointer(&indices[0]))

_cret = C.gtk_tree_path_new_from_indicesv(_arg1, _arg2)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	
	
	// NewTreePathFromString constructs a struct TreePath.
	func NewTreePathFromString(path string) *TreePath {
var _arg1 *C.char // out
var _cret *C.GtkTreePath // in

_arg1 = (*C.char)(C.CString(path))
defer C.free(unsafe.Pointer(_arg1))

_cret = C.gtk_tree_path_new_from_string(_arg1)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	

	

	// Native returns the underlying C source pointer.
	func (t *TreePath) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// AppendIndex appends a new index to a path.
// 
// As a result, the depth of the path is increased.
	func (p *TreePath) AppendIndex(index_ int)  {
var _arg0 *C.GtkTreePath // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (C.int)(index_)

C.gtk_tree_path_append_index(_arg0, _arg1)
}
	
	// Compare compares two paths.
// 
// If @a appears before @b in a tree, then -1 is returned. If @b appears before
// @a, then 1 is returned. If the two nodes are equal, then 0 is returned.
	func (a *TreePath) Compare(b *TreePath) int {
var _arg0 *C.GtkTreePath // out
var _arg1 *C.GtkTreePath // out
var _cret C.int // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(a.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(b.Native()))

_cret = C.gtk_tree_path_compare(_arg0, _arg1)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// Copy creates a new TreePath-struct as a copy of @path.
	func (p *TreePath) Copy() *TreePath {
var _arg0 *C.GtkTreePath // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_copy(_arg0)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Down moves @path to point to the first child of the current path.
	func (p *TreePath) Down()  {
var _arg0 *C.GtkTreePath // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

C.gtk_tree_path_down(_arg0)
}
	
	// Free frees @path. If @path is nil, it simply returns.
	func (p *TreePath) Free()  {
var _arg0 *C.GtkTreePath // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

C.gtk_tree_path_free(_arg0)
}
	
	// Depth returns the current depth of @path.
	func (p *TreePath) Depth() int {
var _arg0 *C.GtkTreePath // out
var _cret C.int // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_get_depth(_arg0)


var _gint int // out

_gint = (int)(_cret)

return _gint
}
	
	// IsAncestor returns true if @descendant is a descendant of @path.
	func (p *TreePath) IsAncestor(descendant *TreePath) bool {
var _arg0 *C.GtkTreePath // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(descendant.Native()))

_cret = C.gtk_tree_path_is_ancestor(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// IsDescendant returns true if @path is a descendant of @ancestor.
	func (p *TreePath) IsDescendant(ancestor *TreePath) bool {
var _arg0 *C.GtkTreePath // out
var _arg1 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (*C.GtkTreePath)(unsafe.Pointer(ancestor.Native()))

_cret = C.gtk_tree_path_is_descendant(_arg0, _arg1)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// Next moves the @path to point to the next node at the current depth.
	func (p *TreePath) Next()  {
var _arg0 *C.GtkTreePath // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

C.gtk_tree_path_next(_arg0)
}
	
	// PrependIndex prepends a new index to a path.
// 
// As a result, the depth of the path is increased.
	func (p *TreePath) PrependIndex(index_ int)  {
var _arg0 *C.GtkTreePath // out
var _arg1 C.int // out

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))
_arg1 = (C.int)(index_)

C.gtk_tree_path_prepend_index(_arg0, _arg1)
}
	
	// Prev moves the @path to point to the previous node at the current depth, if
// it exists.
	func (p *TreePath) Prev() bool {
var _arg0 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_prev(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
	// String generates a string representation of the path.
// 
// This string is a : separated list of numbers. For example, 4:10:0:3 would
// be an acceptable return value for this string. If the path has depth 0, nil
// is returned.
	func (p *TreePath) String() string {
var _arg0 *C.GtkTreePath // out
var _cret *C.char // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_to_string(_arg0)


var _utf8 string // out

_utf8 = C.GoString(_cret)
defer C.free(unsafe.Pointer(_cret))

return _utf8
}
	
	// Up moves the @path to point to its parent node, if it has a parent.
	func (p *TreePath) Up() bool {
var _arg0 *C.GtkTreePath // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreePath)(unsafe.Pointer(p.Native()))

_cret = C.gtk_tree_path_up(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	


	// TreeRowReference: a GtkTreeRowReference tracks model changes so that it
// always refers to the same row (a TreePath refers to a position, not a fixed
// row). Create a new GtkTreeRowReference with gtk_tree_row_reference_new().
	type TreeRowReference struct {
		Native C.GtkTreeRowReference
	}

	
	func marshalTreeRowReference(p uintptr) (interface{}, error) {
		b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
		return (*TreeRowReference)(unsafe.Pointer(b))
	}
	

	
	
	// NewTreeRowReference constructs a struct TreeRowReference.
	func NewTreeRowReference(model TreeModel, path *TreePath) *TreeRowReference {
var _arg1 *C.GtkTreeModel // out
var _arg2 *C.GtkTreePath // out
var _cret *C.GtkTreeRowReference // in

_arg1 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
_arg2 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_row_reference_new(_arg1, _arg2)


var _treeRowReference *TreeRowReference // out

_treeRowReference = *(**TreeRowReference)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeRowReference
}
	
	
	
	// NewTreeRowReferenceProXY constructs a struct TreeRowReference.
	func NewTreeRowReferenceProXY(proxy **externglib.Object, model TreeModel, path *TreePath) *TreeRowReference {
var _arg1 *C.GObject // out
var _arg2 *C.GtkTreeModel // out
var _arg3 *C.GtkTreePath // out
var _cret *C.GtkTreeRowReference // in

_arg1 = (*C.GObject)(unsafe.Pointer(proxy.Native()))
_arg2 = (*C.GtkTreeModel)(unsafe.Pointer(model.Native()))
_arg3 = (*C.GtkTreePath)(unsafe.Pointer(path.Native()))

_cret = C.gtk_tree_row_reference_new_proxy(_arg1, _arg2, _arg3)


var _treeRowReference *TreeRowReference // out

_treeRowReference = *(**TreeRowReference)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeRowReference
}
	
	

	

	// Native returns the underlying C source pointer.
	func (t *TreeRowReference) Native() uintptr {
		return uintptr(unsafe.Pointer(&t.Native))
	}

	

	
	// Copy copies a TreeRowReference.
	func (r *TreeRowReference) Copy() *TreeRowReference {
var _arg0 *C.GtkTreeRowReference // out
var _cret *C.GtkTreeRowReference // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_copy(_arg0)


var _treeRowReference *TreeRowReference // out

_treeRowReference = *(**TreeRowReference)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treeRowReference, func(v *TreeRowReference) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treeRowReference
}
	
	// Free frees @reference. @reference may be nil
	func (r *TreeRowReference) Free()  {
var _arg0 *C.GtkTreeRowReference // out

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

C.gtk_tree_row_reference_free(_arg0)
}
	
	// Model returns the model that the row reference is monitoring.
	func (r *TreeRowReference) Model() TreeModel {
var _arg0 *C.GtkTreeRowReference // out
var _cret *C.GtkTreeModel // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_get_model(_arg0)


var _treeModel TreeModel // out

_treeModel = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(TreeModel)

return _treeModel
}
	
	// Path returns a path that the row reference currently points to, or nil if the
// path pointed to is no longer valid.
	func (r *TreeRowReference) Path() *TreePath {
var _arg0 *C.GtkTreeRowReference // out
var _cret *C.GtkTreePath // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_get_path(_arg0)


var _treePath *TreePath // out

_treePath = *(**TreePath)(unsafe.Pointer(&_cret))
runtime.SetFinalizer(_treePath, func(v *TreePath) {
  C.free(unsafe.Pointer(v.Native()))
})

return _treePath
}
	
	// Valid returns true if the @reference is non-nil and refers to a current valid
// path.
	func (r *TreeRowReference) Valid() bool {
var _arg0 *C.GtkTreeRowReference // out
var _cret C.gboolean // in

_arg0 = (*C.GtkTreeRowReference)(unsafe.Pointer(r.Native()))

_cret = C.gtk_tree_row_reference_valid(_arg0)


var _ok bool // out

if _cret != 0 { _ok = true }

return _ok
}
	
