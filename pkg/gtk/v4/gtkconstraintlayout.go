// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"reflect"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/internal/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_constraint_layout_get_type()), F: marshalConstraintLayout},
		{T: externglib.Type(C.gtk_constraint_layout_child_get_type()), F: marshalConstraintLayoutChild},
	})
}

// ConstraintLayout: a layout manager using constraints to describe relations
// between widgets.
//
// `GtkConstraintLayout` is a layout manager that uses relations between widget
// attributes, expressed via [class@Gtk.Constraint] instances, to measure and
// allocate widgets.
//
//
// How do constraints work
//
// Constraints are objects defining the relationship between attributes of a
// widget; you can read the description of the [class@Gtk.Constraint] class to
// have a more in depth definition.
//
// By taking multiple constraints and applying them to the children of a widget
// using `GtkConstraintLayout`, it's possible to describe complex layout
// policies; each constraint applied to a child or to the parent widgets
// contributes to the full description of the layout, in terms of parameters for
// resolving the value of each attribute.
//
// It is important to note that a layout is defined by the totality of
// constraints; removing a child, or a constraint, from an existing layout
// without changing the remaining constraints may result in an unstable or
// unsolvable layout.
//
// Constraints have an implicit "reading order"; you should start describing
// each edge of each child, as well as their relationship with the parent
// container, from the top left (or top right, in RTL languages), horizontally
// first, and then vertically.
//
// A constraint-based layout with too few constraints can become "unstable",
// that is: have more than one solution. The behavior of an unstable layout is
// undefined.
//
// A constraint-based layout with conflicting constraints may be unsolvable, and
// lead to an unstable layout. You can use the
// [property@Gtk.Constraint:strength] property of [class@Gtk.Constraint] to
// "nudge" the layout towards a solution.
//
//
// GtkConstraintLayout as GtkBuildable
//
// `GtkConstraintLayout` implements the [iface@Gtk.Buildable] interface and has
// a custom "constraints" element which allows describing constraints in a
// [class@Gtk.Builder] UI file.
//
// An example of a UI definition fragment specifying a constraint:
//
// “`xml <object class="GtkConstraintLayout"> <constraints> <constraint
// target="button" target-attribute="start" relation="eq" source="super"
// source-attribute="start" constant="12" strength="required" /> <constraint
// target="button" target-attribute="width" relation="ge" constant="250"
// strength="strong" /> </constraints> </object> “`
//
// The definition above will add two constraints to the GtkConstraintLayout:
//
//    - a required constraint between the leading edge of "button" and
//      the leading edge of the widget using the constraint layout, plus
//      12 pixels
//    - a strong, constant constraint making the width of "button" greater
//      than, or equal to 250 pixels
//
// The "target" and "target-attribute" attributes are required.
//
// The "source" and "source-attribute" attributes of the "constraint" element
// are optional; if they are not specified, the constraint is assumed to be a
// constant.
//
// The "relation" attribute is optional; if not specified, the constraint is
// assumed to be an equality.
//
// The "strength" attribute is optional; if not specified, the constraint is
// assumed to be required.
//
// The "source" and "target" attributes can be set to "super" to indicate that
// the constraint target is the widget using the GtkConstraintLayout.
//
// There can be "constant" and "multiplier" attributes.
//
// Additionally, the "constraints" element can also contain a description of the
// ConstraintGuides used by the layout:
//
// “`xml <constraints> <guide min-width="100" max-width="500" name="hspace"/>
// <guide min-height="64" nat-height="128" name="vspace" strength="strong"/>
// </constraints> “`
//
// The "guide" element has the following optional attributes:
//
//    - "min-width", "nat-width", and "max-width", describe the minimum,
//      natural, and maximum width of the guide, respectively
//    - "min-height", "nat-height", and "max-height", describe the minimum,
//      natural, and maximum height of the guide, respectively
//    - "strength" describes the strength of the constraint on the natural
//      size of the guide; if not specified, the constraint is assumed to
//      have a medium strength
//    - "name" describes a name for the guide, useful when debugging
//
//
// Using the Visual Format Language
//
// Complex constraints can be described using a compact syntax called VFL, or
// *Visual Format Language*.
//
// The Visual Format Language describes all the constraints on a row or column,
// typically starting from the leading edge towards the trailing one. Each
// element of the layout is composed by "views", which identify a
// [iface@Gtk.ConstraintTarget].
//
// For instance:
//
// “` [button]-[textField] “`
//
// Describes a constraint that binds the trailing edge of "button" to the
// leading edge of "textField", leaving a default space between the two.
//
// Using VFL is also possible to specify predicates that describe constraints on
// attributes like width and height:
//
// “` // Width must be greater than, or equal to 50 [button(>=50)]
//
//    // Width of button1 must be equal to width of button2
//    [button1(==button2)]
//
// “`
//
// The default orientation for a VFL description is horizontal, unless otherwise
// specified:
//
// “` // horizontal orientation, default attribute: width H:[button(>=150)]
//
//    // vertical orientation, default attribute: height
//    V:[button1(==button2)]
//
// “`
//
// It's also possible to specify multiple predicates, as well as their strength:
//
// “` // minimum width of button must be 150 // natural width of button can be
// 250 [button(>=150@required, ==250@medium)] “`
//
// Finally, it's also possible to use simple arithmetic operators:
//
// “` // width of button1 must be equal to width of button2 // divided by 2 plus
// 12 [button1(button2 / 2 + 12)] “`
type ConstraintLayout interface {
	LayoutManager
	Buildable

	// AddConstraint adds a constraint to the layout manager.
	//
	// The [property@Gtk.Constraint:source] and [property@Gtk.Constraint:target]
	// properties of `constraint` can be:
	//
	//    - set to `NULL` to indicate that the constraint refers to the
	//      widget using `layout`
	//    - set to the [class@Gtk.Widget] using `layout`
	//    - set to a child of the [class@Gtk.Widget] using `layout`
	//    - set to a [class@Gtk.ConstraintGuide] that is part of `layout`
	//
	// The @layout acquires the ownership of @constraint after calling this
	// function.
	AddConstraint(constraint Constraint)
	// AddConstraintsFromDescriptionv creates a list of constraints from a VFL
	// description.
	//
	// The Visual Format Language, VFL, is based on Apple's AutoLayout VFL
	// (https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
	//
	// The `views` dictionary is used to match [iface@Gtk.ConstraintTarget]
	// instances to the symbolic view name inside the VFL.
	//
	// The VFL grammar is:
	//
	// “` <visualFormatString> = (<orientation>)? (<superview><connection>)?
	// <view>(<connection><view>)* (<connection><superview>)? <orientation> =
	// 'H' | 'V' <superview> = '|' <connection> = ” | '-' <predicateList> '-' |
	// '-' <predicateList> = <simplePredicate> | <predicateListWithParens>
	// <simplePredicate> = <metricName> | <positiveNumber>
	// <predicateListWithParens> = '(' <predicate> (',' <predicate>)* ')'
	// <predicate> = (<relation>)? <objectOfPredicate> (<operatorList>)? ('@'
	// <priority>)? <relation> = '==' | '<=' | '>=' <objectOfPredicate> =
	// <constant> | <viewName> | ('.' <attributeName>)? <priority> =
	// <positiveNumber> | 'required' | 'strong' | 'medium' | 'weak' <constant> =
	// <number> <operatorList> = (<multiplyOperator>)? (<addOperator>)?
	// <multiplyOperator> = [ '*' | '/' ] <positiveNumber> <addOperator> = [ '+'
	// | '-' ] <positiveNumber> <viewName> = A-Za-z_ ([A-Za-z0-9_]*) // A C
	// identifier <metricName> = A-Za-z_ ([A-Za-z0-9_]*) // A C identifier
	// <attributeName> = 'top' | 'bottom' | 'left' | 'right' | 'width' |
	// 'height' | 'start' | 'end' | 'centerX' | 'centerY' | 'baseline'
	// <positiveNumber> // A positive real number parseable by g_ascii_strtod()
	// <number> // A real number parseable by g_ascii_strtod() “`
	//
	// **Note**: The VFL grammar used by GTK is slightly different than the one
	// defined by Apple, as it can use symbolic values for the constraint's
	// strength instead of numeric values; additionally, GTK allows adding
	// simple arithmetic operations inside predicates.
	//
	// Examples of VFL descriptions are:
	//
	// “` // Default spacing [button]-[textField]
	//
	//    // Width constraint
	//    [button(>=50)]
	//
	//    // Connection to super view
	//    |-50-[purpleBox]-50-|
	//
	//    // Vertical layout
	//    V:[topField]-10-[bottomField]
	//
	//    // Flush views
	//    [maroonView][blueView]
	//
	//    // Priority
	//    [button(100@strong)]
	//
	//    // Equal widths
	//    [button1(==button2)]
	//
	//    // Multiple predicates
	//    [flexibleButton(>=70,<=100)]
	//
	//    // A complete line of layout
	//    |-[find]-[findNext]-[findField(>=20)]-|
	//
	//    // Operators
	//    [button1(button2 / 3 + 50)]
	//
	//    // Named attributes
	//    [button1(==button2.height)]
	//
	// “`
	AddConstraintsFromDescriptionv(lines []string, hspacing int, vspacing int, views *glib.HashTable) (list *glib.List, err error)
	// AddGuide adds a guide to `layout`.
	//
	// A guide can be used as the source or target of constraints, like a
	// widget, but it is not visible.
	//
	// The `layout` acquires the ownership of `guide` after calling this
	// function.
	AddGuide(guide ConstraintGuide)
	// ObserveConstraints returns a `GListModel` to track the constraints that
	// are part of the layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// constraints and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveConstraints() gio.ListModel
	// ObserveGuides returns a `GListModel` to track the guides that are part of
	// the layout.
	//
	// Calling this function will enable extra internal bookkeeping to track
	// guides and emit signals on the returned listmodel. It may slow down
	// operations a lot.
	//
	// Applications should try hard to avoid calling this function because of
	// the slowdowns.
	ObserveGuides() gio.ListModel
	// RemoveAllConstraints removes all constraints from the layout manager.
	RemoveAllConstraints()
	// RemoveConstraint removes `constraint` from the layout manager, so that it
	// no longer influences the layout.
	RemoveConstraint(constraint Constraint)
	// RemoveGuide removes `guide` from the layout manager, so that it no longer
	// influences the layout.
	RemoveGuide(guide ConstraintGuide)
}

// constraintLayout implements the ConstraintLayout interface.
type constraintLayout struct {
	LayoutManager
	Buildable
}

var _ ConstraintLayout = (*constraintLayout)(nil)

// WrapConstraintLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintLayout(obj *externglib.Object) ConstraintLayout {
	return ConstraintLayout{
		LayoutManager: WrapLayoutManager(obj),
		Buildable:     WrapBuildable(obj),
	}
}

func marshalConstraintLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintLayout(obj), nil
}

// NewConstraintLayout constructs a class ConstraintLayout.
func NewConstraintLayout() ConstraintLayout {
	ret := C.gtk_constraint_layout_new()

	var ret0 ConstraintLayout

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(ConstraintLayout)

	return ret0
}

// AddConstraint adds a constraint to the layout manager.
//
// The [property@Gtk.Constraint:source] and [property@Gtk.Constraint:target]
// properties of `constraint` can be:
//
//    - set to `NULL` to indicate that the constraint refers to the
//      widget using `layout`
//    - set to the [class@Gtk.Widget] using `layout`
//    - set to a child of the [class@Gtk.Widget] using `layout`
//    - set to a [class@Gtk.ConstraintGuide] that is part of `layout`
//
// The @layout acquires the ownership of @constraint after calling this
// function.
func (l constraintLayout) AddConstraint(constraint Constraint) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraint

	arg0 = (*C.GtkConstraintLayout)(l.Native())
	arg1 = (*C.GtkConstraint)(constraint.Native())

	C.gtk_constraint_layout_add_constraint(arg0, arg1)
}

// AddConstraintsFromDescriptionv creates a list of constraints from a VFL
// description.
//
// The Visual Format Language, VFL, is based on Apple's AutoLayout VFL
// (https://developer.apple.com/library/content/documentation/UserExperience/Conceptual/AutolayoutPG/VisualFormatLanguage.html).
//
// The `views` dictionary is used to match [iface@Gtk.ConstraintTarget]
// instances to the symbolic view name inside the VFL.
//
// The VFL grammar is:
//
// “` <visualFormatString> = (<orientation>)? (<superview><connection>)?
// <view>(<connection><view>)* (<connection><superview>)? <orientation> =
// 'H' | 'V' <superview> = '|' <connection> = ” | '-' <predicateList> '-' |
// '-' <predicateList> = <simplePredicate> | <predicateListWithParens>
// <simplePredicate> = <metricName> | <positiveNumber>
// <predicateListWithParens> = '(' <predicate> (',' <predicate>)* ')'
// <predicate> = (<relation>)? <objectOfPredicate> (<operatorList>)? ('@'
// <priority>)? <relation> = '==' | '<=' | '>=' <objectOfPredicate> =
// <constant> | <viewName> | ('.' <attributeName>)? <priority> =
// <positiveNumber> | 'required' | 'strong' | 'medium' | 'weak' <constant> =
// <number> <operatorList> = (<multiplyOperator>)? (<addOperator>)?
// <multiplyOperator> = [ '*' | '/' ] <positiveNumber> <addOperator> = [ '+'
// | '-' ] <positiveNumber> <viewName> = A-Za-z_ ([A-Za-z0-9_]*) // A C
// identifier <metricName> = A-Za-z_ ([A-Za-z0-9_]*) // A C identifier
// <attributeName> = 'top' | 'bottom' | 'left' | 'right' | 'width' |
// 'height' | 'start' | 'end' | 'centerX' | 'centerY' | 'baseline'
// <positiveNumber> // A positive real number parseable by g_ascii_strtod()
// <number> // A real number parseable by g_ascii_strtod() “`
//
// **Note**: The VFL grammar used by GTK is slightly different than the one
// defined by Apple, as it can use symbolic values for the constraint's
// strength instead of numeric values; additionally, GTK allows adding
// simple arithmetic operations inside predicates.
//
// Examples of VFL descriptions are:
//
// “` // Default spacing [button]-[textField]
//
//    // Width constraint
//    [button(>=50)]
//
//    // Connection to super view
//    |-50-[purpleBox]-50-|
//
//    // Vertical layout
//    V:[topField]-10-[bottomField]
//
//    // Flush views
//    [maroonView][blueView]
//
//    // Priority
//    [button(100@strong)]
//
//    // Equal widths
//    [button1(==button2)]
//
//    // Multiple predicates
//    [flexibleButton(>=70,<=100)]
//
//    // A complete line of layout
//    |-[find]-[findNext]-[findField(>=20)]-|
//
//    // Operators
//    [button1(button2 / 3 + 50)]
//
//    // Named attributes
//    [button1(==button2.height)]
//
// “`
func (l constraintLayout) AddConstraintsFromDescriptionv(lines []string, hspacing int, vspacing int, views *glib.HashTable) (list *glib.List, err error) {
	var arg0 *C.GtkConstraintLayout
	var arg1 **C.char
	var arg2 C.gsize
	var arg3 C.int
	var arg4 C.int
	var arg5 *C.GHashTable
	var gError *C.GError

	arg0 = (*C.GtkConstraintLayout)(l.Native())
	{
		var dst []*C.char
		ptr := C.malloc(unsafe.Sizeof((*struct{})(nil)) * len(lines))
		sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&dst))
		sliceHeader.Data = uintptr(unsafe.Pointer(ptr))
		sliceHeader.Len = len(lines)
		sliceHeader.Cap = len(lines)
		defer C.free(unsafe.Pointer(ptr))

		for i := 0; i < len(lines); i++ {
			src := lines[i]
			dst[i] = (*C.gchar)(C.CString(src))
			defer C.free(unsafe.Pointer(dst[i]))
		}

		arg1 = (**C.char)(unsafe.Pointer(ptr))
		arg2 = len(lines)
	}
	arg3 = C.int(hspacing)
	arg4 = C.int(vspacing)
	arg5 = (*C.GHashTable)(views.Native())

	ret := C.gtk_constraint_layout_add_constraints_from_descriptionv(arg0, arg1, arg2, arg3, arg4, arg5, &gError)

	var ret0 *glib.List
	var goError error

	{
		ret0 = glib.WrapList(unsafe.Pointer(ret))
		runtime.SetFinalizer(ret0, func(v *glib.List) {
			C.free(unsafe.Pointer(v.Native()))
		})
	}

	if gError != nil {
		goError = fmt.Errorf("%d: %s", gError.code, C.GoString(gError.message))
		C.g_error_free(gError)
	}

	return ret0, goError
}

// AddGuide adds a guide to `layout`.
//
// A guide can be used as the source or target of constraints, like a
// widget, but it is not visible.
//
// The `layout` acquires the ownership of `guide` after calling this
// function.
func (l constraintLayout) AddGuide(guide ConstraintGuide) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraintGuide

	arg0 = (*C.GtkConstraintLayout)(l.Native())
	arg1 = (*C.GtkConstraintGuide)(guide.Native())

	C.gtk_constraint_layout_add_guide(arg0, arg1)
}

// ObserveConstraints returns a `GListModel` to track the constraints that
// are part of the layout.
//
// Calling this function will enable extra internal bookkeeping to track
// constraints and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (l constraintLayout) ObserveConstraints() gio.ListModel {
	var arg0 *C.GtkConstraintLayout

	arg0 = (*C.GtkConstraintLayout)(l.Native())

	ret := C.gtk_constraint_layout_observe_constraints(arg0)

	var ret0 gio.ListModel

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.ListModel)

	return ret0
}

// ObserveGuides returns a `GListModel` to track the guides that are part of
// the layout.
//
// Calling this function will enable extra internal bookkeeping to track
// guides and emit signals on the returned listmodel. It may slow down
// operations a lot.
//
// Applications should try hard to avoid calling this function because of
// the slowdowns.
func (l constraintLayout) ObserveGuides() gio.ListModel {
	var arg0 *C.GtkConstraintLayout

	arg0 = (*C.GtkConstraintLayout)(l.Native())

	ret := C.gtk_constraint_layout_observe_guides(arg0)

	var ret0 gio.ListModel

	ret0 = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(ret.Native()))).(gio.ListModel)

	return ret0
}

// RemoveAllConstraints removes all constraints from the layout manager.
func (l constraintLayout) RemoveAllConstraints() {
	var arg0 *C.GtkConstraintLayout

	arg0 = (*C.GtkConstraintLayout)(l.Native())

	C.gtk_constraint_layout_remove_all_constraints(arg0)
}

// RemoveConstraint removes `constraint` from the layout manager, so that it
// no longer influences the layout.
func (l constraintLayout) RemoveConstraint(constraint Constraint) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraint

	arg0 = (*C.GtkConstraintLayout)(l.Native())
	arg1 = (*C.GtkConstraint)(constraint.Native())

	C.gtk_constraint_layout_remove_constraint(arg0, arg1)
}

// RemoveGuide removes `guide` from the layout manager, so that it no longer
// influences the layout.
func (l constraintLayout) RemoveGuide(guide ConstraintGuide) {
	var arg0 *C.GtkConstraintLayout
	var arg1 *C.GtkConstraintGuide

	arg0 = (*C.GtkConstraintLayout)(l.Native())
	arg1 = (*C.GtkConstraintGuide)(guide.Native())

	C.gtk_constraint_layout_remove_guide(arg0, arg1)
}

// ConstraintLayoutChild: `GtkLayoutChild` subclass for children in a
// `GtkConstraintLayout`.
type ConstraintLayoutChild interface {
	LayoutChild
}

// constraintLayoutChild implements the ConstraintLayoutChild interface.
type constraintLayoutChild struct {
	LayoutChild
}

var _ ConstraintLayoutChild = (*constraintLayoutChild)(nil)

// WrapConstraintLayoutChild wraps a GObject to the right type. It is
// primarily used internally.
func WrapConstraintLayoutChild(obj *externglib.Object) ConstraintLayoutChild {
	return ConstraintLayoutChild{
		LayoutChild: WrapLayoutChild(obj),
	}
}

func marshalConstraintLayoutChild(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapConstraintLayoutChild(obj), nil
}
