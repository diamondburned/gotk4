// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/girepository"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #cgo pkg-config: gobject-2.0
// #include <stdlib.h>
// #include <glib.h>
// extern GtkEditable* _gotk4_gtk4_EditableInterface_get_delegate(GtkEditable*);
// extern char* _gotk4_gtk4_EditableInterface_get_text(GtkEditable*);
// extern void _gotk4_gtk4_EditableInterface_changed(GtkEditable*);
// extern void _gotk4_gtk4_Editable_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_gtk4_Editable_ConnectDeleteText(gpointer, gint, gint, guintptr);
import "C"

// glib.Type values for gtkeditable.go.
var GTypeEditable = coreglib.Type(C.gtk_editable_get_type())

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		{T: GTypeEditable, F: marshalEditable},
	})
}

// EditableOverrider contains methods that are overridable.
type EditableOverrider interface {
	Changed()
	// Delegate gets the GtkEditable that editable is delegating its
	// implementation to.
	//
	// Typically, the delegate is a gtk.Text widget.
	//
	// The function returns the following values:
	//
	//    - ret (optional): delegate GtkEditable.
	//
	Delegate() *Editable
	// Text retrieves the contents of editable.
	//
	// The returned string is owned by GTK and must not be modified or freed.
	//
	// The function returns the following values:
	//
	//    - utf8: pointer to the contents of the editable.
	//
	Text() string
}

// Editable: GtkEditable is an interface for text editing widgets.
//
// Typical examples of editable widgets are gtk.Entry and gtk.SpinButton. It
// contains functions for generically manipulating an editable widget, a large
// number of action signals used for key bindings, and several signals that an
// application can connect to modify the behavior of a widget.
//
// As an example of the latter usage, by connecting the following handler to
// gtk.Editable::insert-text, an application can convert all entry into a widget
// into uppercase.
//
// Forcing entry to uppercase.
//
//    #include <ctype.h>
//
//    void
//    insert_text_handler (GtkEditable *editable,
//                         const char  *text,
//                         int          length,
//                         int         *position,
//                         gpointer     data)
//    {
//      char *result = g_utf8_strup (text, length);
//
//      g_signal_handlers_block_by_func (editable,
//                                   (gpointer) insert_text_handler, data);
//      gtk_editable_insert_text (editable, result, length, position);
//      g_signal_handlers_unblock_by_func (editable,
//                                         (gpointer) insert_text_handler, data);
//
//      g_signal_stop_emission_by_name (editable, "insert_text");
//
//      g_free (result);
//    }
//
//
//
// Implementing GtkEditable
//
// The most likely scenario for implementing GtkEditable on your own widget is
// that you will embed a Text inside a complex widget, and want to delegate the
// editable functionality to that text widget. GtkEditable provides some utility
// functions to make this easy.
//
// In your class_init function, call gtk.Editable().InstallProperties, passing
// the first available property ID:
//
//    static void
//    my_class_init (MyClass *class)
//    {
//      ...
//      g_object_class_install_properties (object_class, NUM_PROPERTIES, props);
//      gtk_editable_install_properties (object_clas, NUM_PROPERTIES);
//      ...
//    }
//
//
// In your interface_init function for the GtkEditable interface, provide an
// implementation for the get_delegate vfunc that returns your text widget:
//
//    GtkEditable *
//    get_editable_delegate (GtkEditable *editable)
//    {
//      return GTK_EDITABLE (MY_WIDGET (editable)->text_widget);
//    }
//
//    static void
//    my_editable_init (GtkEditableInterface *iface)
//    {
//      iface->get_delegate = get_editable_delegate;
//    }
//
//
// You don't need to provide any other vfuncs. The default implementations work
// by forwarding to the delegate that the GtkEditableInterface.get_delegate()
// vfunc returns.
//
// In your instance_init function, create your text widget, and then call
// gtk.Editable.InitDelegate():
//
//    static void
//    my_widget_init (MyWidget *self)
//    {
//      ...
//      self->text_widget = gtk_text_new ();
//      gtk_editable_init_delegate (GTK_EDITABLE (self));
//      ...
//    }
//
//
// In your dispose function, call gtk.Editable.FinishDelegate() before
// destroying your text widget:
//
//    static void
//    my_widget_dispose (GObject *object)
//    {
//      ...
//      gtk_editable_finish_delegate (GTK_EDITABLE (self));
//      g_clear_pointer (&self->text_widget, gtk_widget_unparent);
//      ...
//    }
//
//
// Finally, use gtk.Editable().DelegateSetProperty in your set_property function
// (and similar for get_property), to set the editable properties:
//
//      ...
//      if (gtk_editable_delegate_set_property (object, prop_id, value, pspec))
//        return;
//
//      switch (prop_id)
//      ...
//
//
// It is important to note that if you create a GtkEditable that uses a
// delegate, the low level gtk.Editable::insert-text and
// gtk.Editable::delete-text signals will be propagated from the "wrapper"
// editable to the delegate, but they will not be propagated from the delegate
// to the "wrapper" editable, as they would cause an infinite recursion. If you
// wish to connect to the gtk.Editable::insert-text and
// gtk.Editable::delete-text signals, you will need to connect to them on the
// delegate obtained via gtk.Editable.GetDelegate().
//
// Editable wraps an interface. This means the user can get the
// underlying type by calling Cast().
type Editable struct {
	_ [0]func() // equal guard
	Widget
}

var (
	_ Widgetter = (*Editable)(nil)
)

// Editabler describes Editable's interface methods.
type Editabler interface {
	coreglib.Objector

	// DeleteSelection deletes the currently selected text of the editable.
	DeleteSelection()
	// FinishDelegate undoes the setup done by gtk.Editable.InitDelegate().
	FinishDelegate()
	// Delegate gets the GtkEditable that editable is delegating its
	// implementation to.
	Delegate() *Editable
	// Editable retrieves whether editable is editable.
	Editable() bool
	// EnableUndo gets if undo/redo actions are enabled for editable.
	EnableUndo() bool
	// Text retrieves the contents of editable.
	Text() string
	// InitDelegate sets up a delegate for GtkEditable.
	InitDelegate()
	// SetEditable determines if the user can edit the text in the editable
	// widget.
	SetEditable(isEditable bool)
	// SetEnableUndo: if enabled, changes to editable will be saved for
	// undo/redo actions.
	SetEnableUndo(enableUndo bool)
	// SetText sets the text in the editable to the given value.
	SetText(text string)

	// Changed is emitted at the end of a single user-visible operation on the
	// contents.
	ConnectChanged(func()) coreglib.SignalHandle
	// Delete-text is emitted when text is deleted from the widget by the user.
	ConnectDeleteText(func(startPos, endPos int)) coreglib.SignalHandle
}

var _ Editabler = (*Editable)(nil)

func ifaceInitEditabler(gifacePtr, data C.gpointer) {
	iface := (*C.GtkEditableInterface)(unsafe.Pointer(gifacePtr))
	iface.changed = (*[0]byte)(C._gotk4_gtk4_EditableInterface_changed)
	iface.get_delegate = (*[0]byte)(C._gotk4_gtk4_EditableInterface_get_delegate)
	iface.get_text = (*[0]byte)(C._gotk4_gtk4_EditableInterface_get_text)
}

//export _gotk4_gtk4_EditableInterface_changed
func _gotk4_gtk4_EditableInterface_changed(arg0 *C.GtkEditable) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(EditableOverrider)

	iface.Changed()
}

//export _gotk4_gtk4_EditableInterface_get_delegate
func _gotk4_gtk4_EditableInterface_get_delegate(arg0 *C.GtkEditable) (cret *C.GtkEditable) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(EditableOverrider)

	ret := iface.Delegate()

	if ret != nil {
		cret = (*C.void)(unsafe.Pointer(coreglib.InternObject(ret).Native()))
	}

	return cret
}

//export _gotk4_gtk4_EditableInterface_get_text
func _gotk4_gtk4_EditableInterface_get_text(arg0 *C.GtkEditable) (cret *C.char) {
	goval := coreglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(EditableOverrider)

	utf8 := iface.Text()

	cret = (*C.void)(unsafe.Pointer(C.CString(utf8)))
	defer C.free(unsafe.Pointer(cret))

	return cret
}

func wrapEditable(obj *coreglib.Object) *Editable {
	return &Editable{
		Widget: Widget{
			InitiallyUnowned: coreglib.InitiallyUnowned{
				Object: obj,
			},
			Object: obj,
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
	}
}

func marshalEditable(p uintptr) (interface{}, error) {
	return wrapEditable(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_gtk4_Editable_ConnectChanged
func _gotk4_gtk4_Editable_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectChanged is emitted at the end of a single user-visible operation on
// the contents.
//
// E.g., a paste operation that replaces the contents of the selection will
// cause only one signal emission (even though it is implemented by first
// deleting the selection, then inserting the new content, and may cause
// multiple ::notify::text signals to be emitted).
func (editable *Editable) ConnectChanged(f func()) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(editable, "changed", false, unsafe.Pointer(C._gotk4_gtk4_Editable_ConnectChanged), f)
}

//export _gotk4_gtk4_Editable_ConnectDeleteText
func _gotk4_gtk4_Editable_ConnectDeleteText(arg0 C.gpointer, arg1 C.gint, arg2 C.gint, arg3 C.guintptr) {
	var f func(startPos, endPos int)
	{
		closure := coreglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(startPos, endPos int))
	}

	var _startPos int // out
	var _endPos int   // out

	_startPos = int(arg1)
	_endPos = int(arg2)

	f(_startPos, _endPos)
}

// ConnectDeleteText is emitted when text is deleted from the widget by the
// user.
//
// The default handler for this signal will normally be responsible for deleting
// the text, so by connecting to this signal and then stopping the signal with
// g_signal_stop_emission(), it is possible to modify the range of deleted text,
// or prevent it from being deleted entirely.
//
// The start_pos and end_pos parameters are interpreted as for
// gtk.Editable.DeleteText().
func (editable *Editable) ConnectDeleteText(f func(startPos, endPos int)) coreglib.SignalHandle {
	return coreglib.ConnectGeneratedClosure(editable, "delete-text", false, unsafe.Pointer(C._gotk4_gtk4_Editable_ConnectDeleteText), f)
}

// DeleteSelection deletes the currently selected text of the editable.
//
// This call doesnâ€™t do anything if there is no selected text.
func (editable *Editable) DeleteSelection() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	*(**Editable)(unsafe.Pointer(&args[0])) = _arg0

	runtime.KeepAlive(editable)
}

// FinishDelegate undoes the setup done by gtk.Editable.InitDelegate().
//
// This is a helper function that should be called from dispose, before removing
// the delegate object.
func (editable *Editable) FinishDelegate() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	*(**Editable)(unsafe.Pointer(&args[0])) = _arg0

	runtime.KeepAlive(editable)
}

// Delegate gets the GtkEditable that editable is delegating its implementation
// to.
//
// Typically, the delegate is a gtk.Text widget.
//
// The function returns the following values:
//
//    - ret (optional): delegate GtkEditable.
//
func (editable *Editable) Delegate() *Editable {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	*(**Editable)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(editable)

	var _ret *Editable // out

	if _cret != nil {
		_ret = wrapEditable(coreglib.Take(unsafe.Pointer(_cret)))
	}

	return _ret
}

// Editable retrieves whether editable is editable.
//
// The function returns the following values:
//
//    - ok: TRUE if editable is editable.
//
func (editable *Editable) Editable() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	*(**Editable)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(editable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EnableUndo gets if undo/redo actions are enabled for editable.
//
// The function returns the following values:
//
//    - ok: TRUE if undo is enabled.
//
func (editable *Editable) EnableUndo() bool {
	var args [1]girepository.Argument
	var _arg0 *C.void    // out
	var _cret C.gboolean // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	*(**Editable)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(*C.gboolean)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(editable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Text retrieves the contents of editable.
//
// The returned string is owned by GTK and must not be modified or freed.
//
// The function returns the following values:
//
//    - utf8: pointer to the contents of the editable.
//
func (editable *Editable) Text() string {
	var args [1]girepository.Argument
	var _arg0 *C.void // out
	var _cret *C.void // in

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	*(**Editable)(unsafe.Pointer(&args[0])) = _arg0

	_cret = *(**C.void)(unsafe.Pointer(&_gret))

	runtime.KeepAlive(editable)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// InitDelegate sets up a delegate for GtkEditable.
//
// This is assuming that the get_delegate vfunc in the GtkEditable interface has
// been set up for the editable's type.
//
// This is a helper function that should be called in instance init, after
// creating the delegate object.
func (editable *Editable) InitDelegate() {
	var args [1]girepository.Argument
	var _arg0 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	*(**Editable)(unsafe.Pointer(&args[0])) = _arg0

	runtime.KeepAlive(editable)
}

// SetEditable determines if the user can edit the text in the editable widget.
//
// The function takes the following parameters:
//
//    - isEditable: TRUE if the user is allowed to edit the text in the widget.
//
func (editable *Editable) SetEditable(isEditable bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	if isEditable {
		_arg1 = C.TRUE
	}
	*(**Editable)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(editable)
	runtime.KeepAlive(isEditable)
}

// SetEnableUndo: if enabled, changes to editable will be saved for undo/redo
// actions.
//
// This results in an additional copy of text changes and are not stored in
// secure memory. As such, undo is forcefully disabled when gtk.Text:visibility
// is set to FALSE.
//
// The function takes the following parameters:
//
//    - enableUndo: if undo/redo should be enabled.
//
func (editable *Editable) SetEnableUndo(enableUndo bool) {
	var args [2]girepository.Argument
	var _arg0 *C.void    // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}
	*(**Editable)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(editable)
	runtime.KeepAlive(enableUndo)
}

// SetText sets the text in the editable to the given value.
//
// This is replacing the current contents.
//
// The function takes the following parameters:
//
//    - text to set.
//
func (editable *Editable) SetText(text string) {
	var args [2]girepository.Argument
	var _arg0 *C.void // out
	var _arg1 *C.void // out

	_arg0 = (*C.void)(unsafe.Pointer(coreglib.InternObject(editable).Native()))
	_arg1 = (*C.void)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	*(**Editable)(unsafe.Pointer(&args[1])) = _arg1

	runtime.KeepAlive(editable)
	runtime.KeepAlive(text)
}
