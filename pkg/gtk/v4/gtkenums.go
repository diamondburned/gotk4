// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

// GType values.
var (
	GTypeAccessibleAutocomplete   = coreglib.Type(C.gtk_accessible_autocomplete_get_type())
	GTypeAccessibleInvalidState   = coreglib.Type(C.gtk_accessible_invalid_state_get_type())
	GTypeAccessibleProperty       = coreglib.Type(C.gtk_accessible_property_get_type())
	GTypeAccessibleRelation       = coreglib.Type(C.gtk_accessible_relation_get_type())
	GTypeAccessibleRole           = coreglib.Type(C.gtk_accessible_role_get_type())
	GTypeAccessibleSort           = coreglib.Type(C.gtk_accessible_sort_get_type())
	GTypeAccessibleState          = coreglib.Type(C.gtk_accessible_state_get_type())
	GTypeAccessibleTristate       = coreglib.Type(C.gtk_accessible_tristate_get_type())
	GTypeAlign                    = coreglib.Type(C.gtk_align_get_type())
	GTypeArrowType                = coreglib.Type(C.gtk_arrow_type_get_type())
	GTypeBaselinePosition         = coreglib.Type(C.gtk_baseline_position_get_type())
	GTypeBorderStyle              = coreglib.Type(C.gtk_border_style_get_type())
	GTypeConstraintAttribute      = coreglib.Type(C.gtk_constraint_attribute_get_type())
	GTypeConstraintRelation       = coreglib.Type(C.gtk_constraint_relation_get_type())
	GTypeConstraintStrength       = coreglib.Type(C.gtk_constraint_strength_get_type())
	GTypeConstraintVflParserError = coreglib.Type(C.gtk_constraint_vfl_parser_error_get_type())
	GTypeDeleteType               = coreglib.Type(C.gtk_delete_type_get_type())
	GTypeDirectionType            = coreglib.Type(C.gtk_direction_type_get_type())
	GTypeEventSequenceState       = coreglib.Type(C.gtk_event_sequence_state_get_type())
	GTypeIconSize                 = coreglib.Type(C.gtk_icon_size_get_type())
	GTypeInputPurpose             = coreglib.Type(C.gtk_input_purpose_get_type())
	GTypeJustification            = coreglib.Type(C.gtk_justification_get_type())
	GTypeLevelBarMode             = coreglib.Type(C.gtk_level_bar_mode_get_type())
	GTypeMessageType              = coreglib.Type(C.gtk_message_type_get_type())
	GTypeMovementStep             = coreglib.Type(C.gtk_movement_step_get_type())
	GTypeNumberUpLayout           = coreglib.Type(C.gtk_number_up_layout_get_type())
	GTypeOrdering                 = coreglib.Type(C.gtk_ordering_get_type())
	GTypeOrientation              = coreglib.Type(C.gtk_orientation_get_type())
	GTypeOverflow                 = coreglib.Type(C.gtk_overflow_get_type())
	GTypePackType                 = coreglib.Type(C.gtk_pack_type_get_type())
	GTypePageOrientation          = coreglib.Type(C.gtk_page_orientation_get_type())
	GTypePageSet                  = coreglib.Type(C.gtk_page_set_get_type())
	GTypePanDirection             = coreglib.Type(C.gtk_pan_direction_get_type())
	GTypePositionType             = coreglib.Type(C.gtk_position_type_get_type())
	GTypePrintDuplex              = coreglib.Type(C.gtk_print_duplex_get_type())
	GTypePrintPages               = coreglib.Type(C.gtk_print_pages_get_type())
	GTypePrintQuality             = coreglib.Type(C.gtk_print_quality_get_type())
	GTypePropagationLimit         = coreglib.Type(C.gtk_propagation_limit_get_type())
	GTypePropagationPhase         = coreglib.Type(C.gtk_propagation_phase_get_type())
	GTypeScrollStep               = coreglib.Type(C.gtk_scroll_step_get_type())
	GTypeScrollType               = coreglib.Type(C.gtk_scroll_type_get_type())
	GTypeScrollablePolicy         = coreglib.Type(C.gtk_scrollable_policy_get_type())
	GTypeSelectionMode            = coreglib.Type(C.gtk_selection_mode_get_type())
	GTypeSensitivityType          = coreglib.Type(C.gtk_sensitivity_type_get_type())
	GTypeShortcutScope            = coreglib.Type(C.gtk_shortcut_scope_get_type())
	GTypeSizeGroupMode            = coreglib.Type(C.gtk_size_group_mode_get_type())
	GTypeSizeRequestMode          = coreglib.Type(C.gtk_size_request_mode_get_type())
	GTypeSortType                 = coreglib.Type(C.gtk_sort_type_get_type())
	GTypeSystemSetting            = coreglib.Type(C.gtk_system_setting_get_type())
	GTypeTextDirection            = coreglib.Type(C.gtk_text_direction_get_type())
	GTypeTreeViewGridLines        = coreglib.Type(C.gtk_tree_view_grid_lines_get_type())
	GTypeUnit                     = coreglib.Type(C.gtk_unit_get_type())
	GTypeWrapMode                 = coreglib.Type(C.gtk_wrap_mode_get_type())
	GTypeInputHints               = coreglib.Type(C.gtk_input_hints_get_type())
	GTypePickFlags                = coreglib.Type(C.gtk_pick_flags_get_type())
	GTypeStateFlags               = coreglib.Type(C.gtk_state_flags_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeAccessibleAutocomplete, F: marshalAccessibleAutocomplete},
		coreglib.TypeMarshaler{T: GTypeAccessibleInvalidState, F: marshalAccessibleInvalidState},
		coreglib.TypeMarshaler{T: GTypeAccessibleProperty, F: marshalAccessibleProperty},
		coreglib.TypeMarshaler{T: GTypeAccessibleRelation, F: marshalAccessibleRelation},
		coreglib.TypeMarshaler{T: GTypeAccessibleRole, F: marshalAccessibleRole},
		coreglib.TypeMarshaler{T: GTypeAccessibleSort, F: marshalAccessibleSort},
		coreglib.TypeMarshaler{T: GTypeAccessibleState, F: marshalAccessibleState},
		coreglib.TypeMarshaler{T: GTypeAccessibleTristate, F: marshalAccessibleTristate},
		coreglib.TypeMarshaler{T: GTypeAlign, F: marshalAlign},
		coreglib.TypeMarshaler{T: GTypeArrowType, F: marshalArrowType},
		coreglib.TypeMarshaler{T: GTypeBaselinePosition, F: marshalBaselinePosition},
		coreglib.TypeMarshaler{T: GTypeBorderStyle, F: marshalBorderStyle},
		coreglib.TypeMarshaler{T: GTypeConstraintAttribute, F: marshalConstraintAttribute},
		coreglib.TypeMarshaler{T: GTypeConstraintRelation, F: marshalConstraintRelation},
		coreglib.TypeMarshaler{T: GTypeConstraintStrength, F: marshalConstraintStrength},
		coreglib.TypeMarshaler{T: GTypeConstraintVflParserError, F: marshalConstraintVflParserError},
		coreglib.TypeMarshaler{T: GTypeDeleteType, F: marshalDeleteType},
		coreglib.TypeMarshaler{T: GTypeDirectionType, F: marshalDirectionType},
		coreglib.TypeMarshaler{T: GTypeEventSequenceState, F: marshalEventSequenceState},
		coreglib.TypeMarshaler{T: GTypeIconSize, F: marshalIconSize},
		coreglib.TypeMarshaler{T: GTypeInputPurpose, F: marshalInputPurpose},
		coreglib.TypeMarshaler{T: GTypeJustification, F: marshalJustification},
		coreglib.TypeMarshaler{T: GTypeLevelBarMode, F: marshalLevelBarMode},
		coreglib.TypeMarshaler{T: GTypeMessageType, F: marshalMessageType},
		coreglib.TypeMarshaler{T: GTypeMovementStep, F: marshalMovementStep},
		coreglib.TypeMarshaler{T: GTypeNumberUpLayout, F: marshalNumberUpLayout},
		coreglib.TypeMarshaler{T: GTypeOrdering, F: marshalOrdering},
		coreglib.TypeMarshaler{T: GTypeOrientation, F: marshalOrientation},
		coreglib.TypeMarshaler{T: GTypeOverflow, F: marshalOverflow},
		coreglib.TypeMarshaler{T: GTypePackType, F: marshalPackType},
		coreglib.TypeMarshaler{T: GTypePageOrientation, F: marshalPageOrientation},
		coreglib.TypeMarshaler{T: GTypePageSet, F: marshalPageSet},
		coreglib.TypeMarshaler{T: GTypePanDirection, F: marshalPanDirection},
		coreglib.TypeMarshaler{T: GTypePositionType, F: marshalPositionType},
		coreglib.TypeMarshaler{T: GTypePrintDuplex, F: marshalPrintDuplex},
		coreglib.TypeMarshaler{T: GTypePrintPages, F: marshalPrintPages},
		coreglib.TypeMarshaler{T: GTypePrintQuality, F: marshalPrintQuality},
		coreglib.TypeMarshaler{T: GTypePropagationLimit, F: marshalPropagationLimit},
		coreglib.TypeMarshaler{T: GTypePropagationPhase, F: marshalPropagationPhase},
		coreglib.TypeMarshaler{T: GTypeScrollStep, F: marshalScrollStep},
		coreglib.TypeMarshaler{T: GTypeScrollType, F: marshalScrollType},
		coreglib.TypeMarshaler{T: GTypeScrollablePolicy, F: marshalScrollablePolicy},
		coreglib.TypeMarshaler{T: GTypeSelectionMode, F: marshalSelectionMode},
		coreglib.TypeMarshaler{T: GTypeSensitivityType, F: marshalSensitivityType},
		coreglib.TypeMarshaler{T: GTypeShortcutScope, F: marshalShortcutScope},
		coreglib.TypeMarshaler{T: GTypeSizeGroupMode, F: marshalSizeGroupMode},
		coreglib.TypeMarshaler{T: GTypeSizeRequestMode, F: marshalSizeRequestMode},
		coreglib.TypeMarshaler{T: GTypeSortType, F: marshalSortType},
		coreglib.TypeMarshaler{T: GTypeSystemSetting, F: marshalSystemSetting},
		coreglib.TypeMarshaler{T: GTypeTextDirection, F: marshalTextDirection},
		coreglib.TypeMarshaler{T: GTypeTreeViewGridLines, F: marshalTreeViewGridLines},
		coreglib.TypeMarshaler{T: GTypeUnit, F: marshalUnit},
		coreglib.TypeMarshaler{T: GTypeWrapMode, F: marshalWrapMode},
		coreglib.TypeMarshaler{T: GTypeInputHints, F: marshalInputHints},
		coreglib.TypeMarshaler{T: GTypePickFlags, F: marshalPickFlags},
		coreglib.TypeMarshaler{T: GTypeStateFlags, F: marshalStateFlags},
	})
}

// ACCESSIBLE_VALUE_UNDEFINED: undefined value. The accessible attribute is
// either unset, or its value is undefined.
const ACCESSIBLE_VALUE_UNDEFINED = -1

// AccessibleAutocomplete: possible values for the
// GTK_ACCESSIBLE_PROPERTY_AUTOCOMPLETE accessible property.
type AccessibleAutocomplete C.gint

const (
	// AccessibleAutocompleteNone: automatic suggestions are not displayed.
	AccessibleAutocompleteNone AccessibleAutocomplete = iota
	// AccessibleAutocompleteInline: when a user is providing input, text
	// suggesting one way to complete the provided input may be dynamically
	// inserted after the caret.
	AccessibleAutocompleteInline
	// AccessibleAutocompleteList: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed.
	AccessibleAutocompleteList
	// AccessibleAutocompleteBoth: when a user is providing input, an element
	// containing a collection of values that could complete the provided input
	// may be displayed. If displayed, one value in the collection is
	// automatically selected, and the text needed to complete the automatically
	// selected value appears after the caret in the input.
	AccessibleAutocompleteBoth
)

func marshalAccessibleAutocomplete(p uintptr) (interface{}, error) {
	return AccessibleAutocomplete(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleAutocomplete.
func (a AccessibleAutocomplete) String() string {
	switch a {
	case AccessibleAutocompleteNone:
		return "None"
	case AccessibleAutocompleteInline:
		return "Inline"
	case AccessibleAutocompleteList:
		return "List"
	case AccessibleAutocompleteBoth:
		return "Both"
	default:
		return fmt.Sprintf("AccessibleAutocomplete(%d)", a)
	}
}

// AccessibleInvalidState: possible values for the GTK_ACCESSIBLE_STATE_INVALID
// accessible state.
//
// Note that the GTK_ACCESSIBLE_INVALID_FALSE and GTK_ACCESSIBLE_INVALID_TRUE
// have the same values as FALSE and TRUE.
type AccessibleInvalidState C.gint

const (
	// AccessibleInvalidFalse: there are no detected errors in the value.
	AccessibleInvalidFalse AccessibleInvalidState = iota
	// AccessibleInvalidTrue: value entered by the user has failed validation.
	AccessibleInvalidTrue
	// AccessibleInvalidGrammar: grammatical error was detected.
	AccessibleInvalidGrammar
	// AccessibleInvalidSpelling: spelling error was detected.
	AccessibleInvalidSpelling
)

func marshalAccessibleInvalidState(p uintptr) (interface{}, error) {
	return AccessibleInvalidState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleInvalidState.
func (a AccessibleInvalidState) String() string {
	switch a {
	case AccessibleInvalidFalse:
		return "False"
	case AccessibleInvalidTrue:
		return "True"
	case AccessibleInvalidGrammar:
		return "Grammar"
	case AccessibleInvalidSpelling:
		return "Spelling"
	default:
		return fmt.Sprintf("AccessibleInvalidState(%d)", a)
	}
}

// AccessibleProperty: possible accessible properties of a GtkAccessible.
type AccessibleProperty C.gint

const (
	// AccessiblePropertyAutocomplete indicates whether inputting text could
	// trigger display of one or more predictions of the user's intended value
	// for a combobox, searchbox, or textbox and specifies how predictions would
	// be presented if they were made. Value type: AccessibleAutocomplete.
	AccessiblePropertyAutocomplete AccessibleProperty = iota
	// AccessiblePropertyDescription defines a string value that describes or
	// annotates the current element. Value type: string.
	AccessiblePropertyDescription
	// AccessiblePropertyHasPopup indicates the availability and type of
	// interactive popup element, such as menu or dialog, that can be triggered
	// by an element.
	AccessiblePropertyHasPopup
	// AccessiblePropertyKeyShortcuts indicates keyboard shortcuts that an
	// author has implemented to activate or give focus to an element. Value
	// type: string.
	AccessiblePropertyKeyShortcuts
	// AccessiblePropertyLabel defines a string value that labels the current
	// element. Value type: string.
	AccessiblePropertyLabel
	// AccessiblePropertyLevel defines the hierarchical level of an element
	// within a structure. Value type: integer.
	AccessiblePropertyLevel
	// AccessiblePropertyModal indicates whether an element is modal when
	// displayed. Value type: boolean.
	AccessiblePropertyModal
	// AccessiblePropertyMultiLine indicates whether a text box accepts multiple
	// lines of input or only a single line. Value type: boolean.
	AccessiblePropertyMultiLine
	// AccessiblePropertyMultiSelectable indicates that the user may select more
	// than one item from the current selectable descendants. Value type:
	// boolean.
	AccessiblePropertyMultiSelectable
	// AccessiblePropertyOrientation indicates whether the element's orientation
	// is horizontal, vertical, or unknown/ambiguous. Value type: Orientation.
	AccessiblePropertyOrientation
	// AccessiblePropertyPlaceholder defines a short hint (a word or short
	// phrase) intended to aid the user with data entry when the control has no
	// value. A hint could be a sample value or a brief description of the
	// expected format. Value type: string.
	AccessiblePropertyPlaceholder
	// AccessiblePropertyReadOnly indicates that the element is not editable,
	// but is otherwise operable. Value type: boolean.
	AccessiblePropertyReadOnly
	// AccessiblePropertyRequired indicates that user input is required on the
	// element before a form may be submitted. Value type: boolean.
	AccessiblePropertyRequired
	// AccessiblePropertyRoleDescription defines a human-readable,
	// author-localized description for the role of an element. Value type:
	// string.
	AccessiblePropertyRoleDescription
	// AccessiblePropertySort indicates if items in a table or grid are sorted
	// in ascending or descending order. Possible property values are in the
	// AccessibleSort enumeration. Value type: AccessibleSort.
	AccessiblePropertySort
	// AccessiblePropertyValueMax defines the maximum allowed value for a range
	// widget. Value type: double.
	AccessiblePropertyValueMax
	// AccessiblePropertyValueMin defines the minimum allowed value for a range
	// widget. Value type: double.
	AccessiblePropertyValueMin
	// AccessiblePropertyValueNow defines the current value for a range widget.
	// Value type: double.
	AccessiblePropertyValueNow
	// AccessiblePropertyValueText defines the human readable text alternative
	// of aria-valuenow for a range widget. Value type: string.
	AccessiblePropertyValueText
)

func marshalAccessibleProperty(p uintptr) (interface{}, error) {
	return AccessibleProperty(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleProperty.
func (a AccessibleProperty) String() string {
	switch a {
	case AccessiblePropertyAutocomplete:
		return "Autocomplete"
	case AccessiblePropertyDescription:
		return "Description"
	case AccessiblePropertyHasPopup:
		return "HasPopup"
	case AccessiblePropertyKeyShortcuts:
		return "KeyShortcuts"
	case AccessiblePropertyLabel:
		return "Label"
	case AccessiblePropertyLevel:
		return "Level"
	case AccessiblePropertyModal:
		return "Modal"
	case AccessiblePropertyMultiLine:
		return "MultiLine"
	case AccessiblePropertyMultiSelectable:
		return "MultiSelectable"
	case AccessiblePropertyOrientation:
		return "Orientation"
	case AccessiblePropertyPlaceholder:
		return "Placeholder"
	case AccessiblePropertyReadOnly:
		return "ReadOnly"
	case AccessiblePropertyRequired:
		return "Required"
	case AccessiblePropertyRoleDescription:
		return "RoleDescription"
	case AccessiblePropertySort:
		return "Sort"
	case AccessiblePropertyValueMax:
		return "ValueMax"
	case AccessiblePropertyValueMin:
		return "ValueMin"
	case AccessiblePropertyValueNow:
		return "ValueNow"
	case AccessiblePropertyValueText:
		return "ValueText"
	default:
		return fmt.Sprintf("AccessibleProperty(%d)", a)
	}
}

// AccessibleRelation: possible accessible relations of a GtkAccessible.
//
// Accessible relations can be references to other widgets, integers or strings.
type AccessibleRelation C.gint

const (
	// AccessibleRelationActiveDescendant identifies the currently active
	// element when focus is on a composite widget, combobox, textbox, group, or
	// application. Value type: reference.
	AccessibleRelationActiveDescendant AccessibleRelation = iota
	// AccessibleRelationColCount defines the total number of columns in a
	// table, grid, or treegrid. Value type: integer.
	AccessibleRelationColCount
	// AccessibleRelationColIndex defines an element's column index or position
	// with respect to the total number of columns within a table, grid, or
	// treegrid. Value type: integer.
	AccessibleRelationColIndex
	// AccessibleRelationColIndexText defines a human readable text alternative
	// of GTK_ACCESSIBLE_RELATION_COL_INDEX. Value type: string.
	AccessibleRelationColIndexText
	// AccessibleRelationColSpan defines the number of columns spanned by a cell
	// or gridcell within a table, grid, or treegrid. Value type: integer.
	AccessibleRelationColSpan
	// AccessibleRelationControls identifies the element (or elements) whose
	// contents or presence are controlled by the current element. Value type:
	// reference.
	AccessibleRelationControls
	// AccessibleRelationDescribedBy identifies the element (or elements) that
	// describes the object. Value type: reference.
	AccessibleRelationDescribedBy
	// AccessibleRelationDetails identifies the element (or elements) that
	// provide additional information related to the object. Value type:
	// reference.
	AccessibleRelationDetails
	// AccessibleRelationErrorMessage identifies the element that provides an
	// error message for an object. Value type: reference.
	AccessibleRelationErrorMessage
	// AccessibleRelationFlowTo identifies the next element (or elements) in an
	// alternate reading order of content which, at the user's discretion,
	// allows assistive technology to override the general default of reading in
	// document source order. Value type: reference.
	AccessibleRelationFlowTo
	// AccessibleRelationLabelledBy identifies the element (or elements) that
	// labels the current element. Value type: reference.
	AccessibleRelationLabelledBy
	// AccessibleRelationOwns identifies an element (or elements) in order to
	// define a visual, functional, or contextual parent/child relationship
	// between elements where the widget hierarchy cannot be used to represent
	// the relationship. Value type: reference.
	AccessibleRelationOwns
	// AccessibleRelationPosInSet defines an element's number or position in the
	// current set of listitems or treeitems. Value type: integer.
	AccessibleRelationPosInSet
	// AccessibleRelationRowCount defines the total number of rows in a table,
	// grid, or treegrid. Value type: integer.
	AccessibleRelationRowCount
	// AccessibleRelationRowIndex defines an element's row index or position
	// with respect to the total number of rows within a table, grid, or
	// treegrid. Value type: integer.
	AccessibleRelationRowIndex
	// AccessibleRelationRowIndexText defines a human readable text alternative
	// of aria-rowindex. Value type: string.
	AccessibleRelationRowIndexText
	// AccessibleRelationRowSpan defines the number of rows spanned by a cell or
	// gridcell within a table, grid, or treegrid. Value type: integer.
	AccessibleRelationRowSpan
	// AccessibleRelationSetSize defines the number of items in the current set
	// of listitems or treeitems. Value type: integer.
	AccessibleRelationSetSize
)

func marshalAccessibleRelation(p uintptr) (interface{}, error) {
	return AccessibleRelation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleRelation.
func (a AccessibleRelation) String() string {
	switch a {
	case AccessibleRelationActiveDescendant:
		return "ActiveDescendant"
	case AccessibleRelationColCount:
		return "ColCount"
	case AccessibleRelationColIndex:
		return "ColIndex"
	case AccessibleRelationColIndexText:
		return "ColIndexText"
	case AccessibleRelationColSpan:
		return "ColSpan"
	case AccessibleRelationControls:
		return "Controls"
	case AccessibleRelationDescribedBy:
		return "DescribedBy"
	case AccessibleRelationDetails:
		return "Details"
	case AccessibleRelationErrorMessage:
		return "ErrorMessage"
	case AccessibleRelationFlowTo:
		return "FlowTo"
	case AccessibleRelationLabelledBy:
		return "LabelledBy"
	case AccessibleRelationOwns:
		return "Owns"
	case AccessibleRelationPosInSet:
		return "PosInSet"
	case AccessibleRelationRowCount:
		return "RowCount"
	case AccessibleRelationRowIndex:
		return "RowIndex"
	case AccessibleRelationRowIndexText:
		return "RowIndexText"
	case AccessibleRelationRowSpan:
		return "RowSpan"
	case AccessibleRelationSetSize:
		return "SetSize"
	default:
		return fmt.Sprintf("AccessibleRelation(%d)", a)
	}
}

// AccessibleRole: accessible role for a GtkAccessible implementation.
//
// Abstract roles are only used as part of the ontology; application developers
// must not use abstract roles in their code.
type AccessibleRole C.gint

const (
	// AccessibleRoleAlert: element with important, and usually time-sensitive,
	// information.
	AccessibleRoleAlert AccessibleRole = iota
	// AccessibleRoleAlertDialog: type of dialog that contains an alert message.
	AccessibleRoleAlertDialog
	// AccessibleRoleBanner: unused.
	AccessibleRoleBanner
	// AccessibleRoleButton: input element that allows for user-triggered
	// actions when clicked or pressed.
	AccessibleRoleButton
	// AccessibleRoleCaption: unused.
	AccessibleRoleCaption
	// AccessibleRoleCell: unused.
	AccessibleRoleCell
	// AccessibleRoleCheckbox: checkable input element that has three possible
	// values: true, false, or mixed.
	AccessibleRoleCheckbox
	// AccessibleRoleColumnHeader: header in a columned list.
	AccessibleRoleColumnHeader
	// AccessibleRoleComboBox: input that controls another element, such as a
	// list or a grid, that can dynamically pop up to help the user set the
	// value of the input.
	AccessibleRoleComboBox
	// AccessibleRoleCommand: abstract role.
	AccessibleRoleCommand
	// AccessibleRoleComposite: abstract role.
	AccessibleRoleComposite
	// AccessibleRoleDialog: dialog is a window that is designed to interrupt
	// the current processing of an application in order to prompt the user to
	// enter information or require a response.
	AccessibleRoleDialog
	// AccessibleRoleDocument: unused.
	AccessibleRoleDocument
	// AccessibleRoleFeed: unused.
	AccessibleRoleFeed
	// AccessibleRoleForm: unused.
	AccessibleRoleForm
	// AccessibleRoleGeneric: unused.
	AccessibleRoleGeneric
	// AccessibleRoleGrid: grid of items.
	AccessibleRoleGrid
	// AccessibleRoleGridCell: item in a grid or tree grid.
	AccessibleRoleGridCell
	// AccessibleRoleGroup: element that groups multiple widgets. GTK uses this
	// role for various containers, like Box, Viewport, and HeaderBar.
	AccessibleRoleGroup
	// AccessibleRoleHeading: unused.
	AccessibleRoleHeading
	// AccessibleRoleImg: image.
	AccessibleRoleImg
	// AccessibleRoleInput: abstract role.
	AccessibleRoleInput
	// AccessibleRoleLabel: visible name or caption for a user interface
	// component.
	AccessibleRoleLabel
	// AccessibleRoleLandmark: abstract role.
	AccessibleRoleLandmark
	// AccessibleRoleLegend: unused.
	AccessibleRoleLegend
	// AccessibleRoleLink: clickable link.
	AccessibleRoleLink
	// AccessibleRoleList: list of items.
	AccessibleRoleList
	// AccessibleRoleListBox: unused.
	AccessibleRoleListBox
	// AccessibleRoleListItem: item in a list.
	AccessibleRoleListItem
	// AccessibleRoleLog: unused.
	AccessibleRoleLog
	// AccessibleRoleMain: unused.
	AccessibleRoleMain
	// AccessibleRoleMarquee: unused.
	AccessibleRoleMarquee
	// AccessibleRoleMath: unused.
	AccessibleRoleMath
	// AccessibleRoleMeter: element that represents a value within a known
	// range.
	AccessibleRoleMeter
	// AccessibleRoleMenu: menu.
	AccessibleRoleMenu
	// AccessibleRoleMenuBar: menubar.
	AccessibleRoleMenuBar
	// AccessibleRoleMenuItem: item in a menu.
	AccessibleRoleMenuItem
	// AccessibleRoleMenuItemCheckbox: check item in a menu.
	AccessibleRoleMenuItemCheckbox
	// AccessibleRoleMenuItemRadio: radio item in a menu.
	AccessibleRoleMenuItemRadio
	// AccessibleRoleNavigation: unused.
	AccessibleRoleNavigation
	// AccessibleRoleNone: element that is not represented to accessibility
	// technologies.
	AccessibleRoleNone
	// AccessibleRoleNote: unused.
	AccessibleRoleNote
	// AccessibleRoleOption: unused.
	AccessibleRoleOption
	// AccessibleRolePresentation: element that is not represented to
	// accessibility technologies.
	AccessibleRolePresentation
	// AccessibleRoleProgressBar: element that displays the progress status for
	// tasks that take a long time.
	AccessibleRoleProgressBar
	// AccessibleRoleRadio: checkable input in a group of radio roles, only one
	// of which can be checked at a time.
	AccessibleRoleRadio
	// AccessibleRoleRadioGroup: unused.
	AccessibleRoleRadioGroup
	// AccessibleRoleRange: abstract role.
	AccessibleRoleRange
	// AccessibleRoleRegion: unused.
	AccessibleRoleRegion
	// AccessibleRoleRow: row in a columned list.
	AccessibleRoleRow
	// AccessibleRoleRowGroup: unused.
	AccessibleRoleRowGroup
	// AccessibleRoleRowHeader: unused.
	AccessibleRoleRowHeader
	// AccessibleRoleScrollbar: graphical object that controls the scrolling of
	// content within a viewing area, regardless of whether the content is fully
	// displayed within the viewing area.
	AccessibleRoleScrollbar
	// AccessibleRoleSearch: unused.
	AccessibleRoleSearch
	// AccessibleRoleSearchBox: type of textbox intended for specifying search
	// criteria.
	AccessibleRoleSearchBox
	// AccessibleRoleSection: abstract role.
	AccessibleRoleSection
	// AccessibleRoleSectionHead: abstract role.
	AccessibleRoleSectionHead
	// AccessibleRoleSelect: abstract role.
	AccessibleRoleSelect
	// AccessibleRoleSeparator: divider that separates and distinguishes
	// sections of content or groups of menuitems.
	AccessibleRoleSeparator
	// AccessibleRoleSlider: user input where the user selects a value from
	// within a given range.
	AccessibleRoleSlider
	// AccessibleRoleSpinButton: form of range that expects the user to select
	// from among discrete choices.
	AccessibleRoleSpinButton
	// AccessibleRoleStatus: unused.
	AccessibleRoleStatus
	// AccessibleRoleStructure: abstract role.
	AccessibleRoleStructure
	// AccessibleRoleSwitch: type of checkbox that represents on/off values, as
	// opposed to checked/unchecked values.
	AccessibleRoleSwitch
	// AccessibleRoleTab: item in a list of tab used for switching pages.
	AccessibleRoleTab
	// AccessibleRoleTable: unused.
	AccessibleRoleTable
	// AccessibleRoleTabList: list of tabs for switching pages.
	AccessibleRoleTabList
	// AccessibleRoleTabPanel: page in a notebook or stack.
	AccessibleRoleTabPanel
	// AccessibleRoleTextBox: type of input that allows free-form text as its
	// value.
	AccessibleRoleTextBox
	// AccessibleRoleTime: unused.
	AccessibleRoleTime
	// AccessibleRoleTimer: unused.
	AccessibleRoleTimer
	// AccessibleRoleToolbar: unused.
	AccessibleRoleToolbar
	// AccessibleRoleTooltip: unused.
	AccessibleRoleTooltip
	// AccessibleRoleTree: unused.
	AccessibleRoleTree
	// AccessibleRoleTreeGrid: treeview-like, columned list.
	AccessibleRoleTreeGrid
	// AccessibleRoleTreeItem: unused.
	AccessibleRoleTreeItem
	// AccessibleRoleWidget: interactive component of a graphical user
	// interface. This is the role that GTK uses by default for widgets.
	AccessibleRoleWidget
	// AccessibleRoleWindow: application window.
	AccessibleRoleWindow
)

func marshalAccessibleRole(p uintptr) (interface{}, error) {
	return AccessibleRole(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleRole.
func (a AccessibleRole) String() string {
	switch a {
	case AccessibleRoleAlert:
		return "Alert"
	case AccessibleRoleAlertDialog:
		return "AlertDialog"
	case AccessibleRoleBanner:
		return "Banner"
	case AccessibleRoleButton:
		return "Button"
	case AccessibleRoleCaption:
		return "Caption"
	case AccessibleRoleCell:
		return "Cell"
	case AccessibleRoleCheckbox:
		return "Checkbox"
	case AccessibleRoleColumnHeader:
		return "ColumnHeader"
	case AccessibleRoleComboBox:
		return "ComboBox"
	case AccessibleRoleCommand:
		return "Command"
	case AccessibleRoleComposite:
		return "Composite"
	case AccessibleRoleDialog:
		return "Dialog"
	case AccessibleRoleDocument:
		return "Document"
	case AccessibleRoleFeed:
		return "Feed"
	case AccessibleRoleForm:
		return "Form"
	case AccessibleRoleGeneric:
		return "Generic"
	case AccessibleRoleGrid:
		return "Grid"
	case AccessibleRoleGridCell:
		return "GridCell"
	case AccessibleRoleGroup:
		return "Group"
	case AccessibleRoleHeading:
		return "Heading"
	case AccessibleRoleImg:
		return "Img"
	case AccessibleRoleInput:
		return "Input"
	case AccessibleRoleLabel:
		return "Label"
	case AccessibleRoleLandmark:
		return "Landmark"
	case AccessibleRoleLegend:
		return "Legend"
	case AccessibleRoleLink:
		return "Link"
	case AccessibleRoleList:
		return "List"
	case AccessibleRoleListBox:
		return "ListBox"
	case AccessibleRoleListItem:
		return "ListItem"
	case AccessibleRoleLog:
		return "Log"
	case AccessibleRoleMain:
		return "Main"
	case AccessibleRoleMarquee:
		return "Marquee"
	case AccessibleRoleMath:
		return "Math"
	case AccessibleRoleMeter:
		return "Meter"
	case AccessibleRoleMenu:
		return "Menu"
	case AccessibleRoleMenuBar:
		return "MenuBar"
	case AccessibleRoleMenuItem:
		return "MenuItem"
	case AccessibleRoleMenuItemCheckbox:
		return "MenuItemCheckbox"
	case AccessibleRoleMenuItemRadio:
		return "MenuItemRadio"
	case AccessibleRoleNavigation:
		return "Navigation"
	case AccessibleRoleNone:
		return "None"
	case AccessibleRoleNote:
		return "Note"
	case AccessibleRoleOption:
		return "Option"
	case AccessibleRolePresentation:
		return "Presentation"
	case AccessibleRoleProgressBar:
		return "ProgressBar"
	case AccessibleRoleRadio:
		return "Radio"
	case AccessibleRoleRadioGroup:
		return "RadioGroup"
	case AccessibleRoleRange:
		return "Range"
	case AccessibleRoleRegion:
		return "Region"
	case AccessibleRoleRow:
		return "Row"
	case AccessibleRoleRowGroup:
		return "RowGroup"
	case AccessibleRoleRowHeader:
		return "RowHeader"
	case AccessibleRoleScrollbar:
		return "Scrollbar"
	case AccessibleRoleSearch:
		return "Search"
	case AccessibleRoleSearchBox:
		return "SearchBox"
	case AccessibleRoleSection:
		return "Section"
	case AccessibleRoleSectionHead:
		return "SectionHead"
	case AccessibleRoleSelect:
		return "Select"
	case AccessibleRoleSeparator:
		return "Separator"
	case AccessibleRoleSlider:
		return "Slider"
	case AccessibleRoleSpinButton:
		return "SpinButton"
	case AccessibleRoleStatus:
		return "Status"
	case AccessibleRoleStructure:
		return "Structure"
	case AccessibleRoleSwitch:
		return "Switch"
	case AccessibleRoleTab:
		return "Tab"
	case AccessibleRoleTable:
		return "Table"
	case AccessibleRoleTabList:
		return "TabList"
	case AccessibleRoleTabPanel:
		return "TabPanel"
	case AccessibleRoleTextBox:
		return "TextBox"
	case AccessibleRoleTime:
		return "Time"
	case AccessibleRoleTimer:
		return "Timer"
	case AccessibleRoleToolbar:
		return "Toolbar"
	case AccessibleRoleTooltip:
		return "Tooltip"
	case AccessibleRoleTree:
		return "Tree"
	case AccessibleRoleTreeGrid:
		return "TreeGrid"
	case AccessibleRoleTreeItem:
		return "TreeItem"
	case AccessibleRoleWidget:
		return "Widget"
	case AccessibleRoleWindow:
		return "Window"
	default:
		return fmt.Sprintf("AccessibleRole(%d)", a)
	}
}

// AccessibleSort: possible values for the GTK_ACCESSIBLE_PROPERTY_SORT
// accessible property.
type AccessibleSort C.gint

const (
	// AccessibleSortNone: there is no defined sort applied to the column.
	AccessibleSortNone AccessibleSort = iota
	// AccessibleSortAscending items are sorted in ascending order by this
	// column.
	AccessibleSortAscending
	// AccessibleSortDescending items are sorted in descending order by this
	// column.
	AccessibleSortDescending
	// AccessibleSortOther: sort algorithm other than ascending or descending
	// has been applied.
	AccessibleSortOther
)

func marshalAccessibleSort(p uintptr) (interface{}, error) {
	return AccessibleSort(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleSort.
func (a AccessibleSort) String() string {
	switch a {
	case AccessibleSortNone:
		return "None"
	case AccessibleSortAscending:
		return "Ascending"
	case AccessibleSortDescending:
		return "Descending"
	case AccessibleSortOther:
		return "Other"
	default:
		return fmt.Sprintf("AccessibleSort(%d)", a)
	}
}

// AccessibleState: possible accessible states of a GtkAccessible.
type AccessibleState C.gint

const (
	// AccessibleStateBusy: “busy” state. This state has boolean values.
	AccessibleStateBusy AccessibleState = iota
	// AccessibleStateChecked: “checked” state; indicates the current state of a
	// CheckButton. Value type: AccessibleTristate.
	AccessibleStateChecked
	// AccessibleStateDisabled: “disabled” state; corresponds to the
	// Widget:sensitive property on Widget. It indicates a UI element that is
	// perceivable, but not editable or operable. Value type: boolean.
	AccessibleStateDisabled
	// AccessibleStateExpanded: “expanded” state; corresponds to the
	// Expander:expanded property on Expander. Value type: boolean or undefined.
	AccessibleStateExpanded
	// AccessibleStateHidden: “hidden” state; corresponds to the Widget:visible
	// property on Widget. You can use this state explicitly on UI elements that
	// should not be exposed to an assistive technology. Value type: boolean See
	// also: GTK_ACCESSIBLE_STATE_DISABLED.
	AccessibleStateHidden
	// AccessibleStateInvalid: “invalid” state; set when a widget is showing an
	// error. Value type: AccessibleInvalidState.
	AccessibleStateInvalid
	// AccessibleStatePressed: “pressed” state; indicates the current state of a
	// ToggleButton. Value type: AccessibleTristate enumeration.
	AccessibleStatePressed
	// AccessibleStateSelected: “selected” state; set when a widget is selected.
	// Value type: boolean or undefined.
	AccessibleStateSelected
)

func marshalAccessibleState(p uintptr) (interface{}, error) {
	return AccessibleState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleState.
func (a AccessibleState) String() string {
	switch a {
	case AccessibleStateBusy:
		return "Busy"
	case AccessibleStateChecked:
		return "Checked"
	case AccessibleStateDisabled:
		return "Disabled"
	case AccessibleStateExpanded:
		return "Expanded"
	case AccessibleStateHidden:
		return "Hidden"
	case AccessibleStateInvalid:
		return "Invalid"
	case AccessibleStatePressed:
		return "Pressed"
	case AccessibleStateSelected:
		return "Selected"
	default:
		return fmt.Sprintf("AccessibleState(%d)", a)
	}
}

// AccessibleTristate: possible values for the GTK_ACCESSIBLE_STATE_PRESSED
// accessible state.
//
// Note that the GTK_ACCESSIBLE_TRISTATE_FALSE and GTK_ACCESSIBLE_TRISTATE_TRUE
// have the same values as FALSE and TRUE.
type AccessibleTristate C.gint

const (
	// AccessibleTristateFalse: state is false.
	AccessibleTristateFalse AccessibleTristate = iota
	// AccessibleTristateTrue: state is true.
	AccessibleTristateTrue
	// AccessibleTristateMixed: state is mixed.
	AccessibleTristateMixed
)

func marshalAccessibleTristate(p uintptr) (interface{}, error) {
	return AccessibleTristate(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for AccessibleTristate.
func (a AccessibleTristate) String() string {
	switch a {
	case AccessibleTristateFalse:
		return "False"
	case AccessibleTristateTrue:
		return "True"
	case AccessibleTristateMixed:
		return "Mixed"
	default:
		return fmt.Sprintf("AccessibleTristate(%d)", a)
	}
}

// Align controls how a widget deals with extra space in a single dimension.
//
// Alignment only matters if the widget receives a “too large” allocation, for
// example if you packed the widget with the gtk.Widget:hexpand property inside
// a GtkBox, then the widget might get extra space. If you have for example a
// 16x16 icon inside a 32x32 space, the icon could be scaled and stretched, it
// could be centered, or it could be positioned to one side of the space.
//
// Note that in horizontal context GTK_ALIGN_START and GTK_ALIGN_END are
// interpreted relative to text direction.
//
// GTK_ALIGN_BASELINE support is optional for containers and widgets, and it is
// only supported for vertical alignment. When it's not supported by a child or
// a container it is treated as GTK_ALIGN_FILL.
type Align C.gint

const (
	// AlignFill: stretch to fill all space if possible, center if no meaningful
	// way to stretch.
	AlignFill Align = iota
	// AlignStart: snap to left or top side, leaving space on right or bottom.
	AlignStart
	// AlignEnd: snap to right or bottom side, leaving space on left or top.
	AlignEnd
	// AlignCenter: center natural width of widget inside the allocation.
	AlignCenter
	// AlignBaseline: align the widget according to the baseline. See Widget.
	AlignBaseline
)

func marshalAlign(p uintptr) (interface{}, error) {
	return Align(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Align.
func (a Align) String() string {
	switch a {
	case AlignFill:
		return "Fill"
	case AlignStart:
		return "Start"
	case AlignEnd:
		return "End"
	case AlignCenter:
		return "Center"
	case AlignBaseline:
		return "Baseline"
	default:
		return fmt.Sprintf("Align(%d)", a)
	}
}

// ArrowType: used to indicate the direction in which an arrow should point.
type ArrowType C.gint

const (
	// ArrowUp represents an upward pointing arrow.
	ArrowUp ArrowType = iota
	// ArrowDown represents a downward pointing arrow.
	ArrowDown
	// ArrowLeft represents a left pointing arrow.
	ArrowLeft
	// ArrowRight represents a right pointing arrow.
	ArrowRight
	// ArrowNone: no arrow.
	ArrowNone
)

func marshalArrowType(p uintptr) (interface{}, error) {
	return ArrowType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ArrowType.
func (a ArrowType) String() string {
	switch a {
	case ArrowUp:
		return "Up"
	case ArrowDown:
		return "Down"
	case ArrowLeft:
		return "Left"
	case ArrowRight:
		return "Right"
	case ArrowNone:
		return "None"
	default:
		return fmt.Sprintf("ArrowType(%d)", a)
	}
}

// BaselinePosition: baseline position in a row of widgets.
//
// Whenever a container has some form of natural row it may align children in
// that row along a common typographical baseline. If the amount of vertical
// space in the row is taller than the total requested height of the
// baseline-aligned children then it can use a GtkBaselinePosition to select
// where to put the baseline inside the extra available space.
type BaselinePosition C.gint

const (
	// BaselinePositionTop: align the baseline at the top.
	BaselinePositionTop BaselinePosition = iota
	// BaselinePositionCenter: center the baseline.
	BaselinePositionCenter
	// BaselinePositionBottom: align the baseline at the bottom.
	BaselinePositionBottom
)

func marshalBaselinePosition(p uintptr) (interface{}, error) {
	return BaselinePosition(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BaselinePosition.
func (b BaselinePosition) String() string {
	switch b {
	case BaselinePositionTop:
		return "Top"
	case BaselinePositionCenter:
		return "Center"
	case BaselinePositionBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("BaselinePosition(%d)", b)
	}
}

// BorderStyle describes how the border of a UI element should be rendered.
type BorderStyle C.gint

const (
	// BorderStyleNone: no visible border.
	BorderStyleNone BorderStyle = iota
	// BorderStyleHidden: same as GTK_BORDER_STYLE_NONE.
	BorderStyleHidden
	// BorderStyleSolid: single line segment.
	BorderStyleSolid
	// BorderStyleInset looks as if the content is sunken into the canvas.
	BorderStyleInset
	// BorderStyleOutset looks as if the content is coming out of the canvas.
	BorderStyleOutset
	// BorderStyleDotted series of round dots.
	BorderStyleDotted
	// BorderStyleDashed series of square-ended dashes.
	BorderStyleDashed
	// BorderStyleDouble: two parallel lines with some space between them.
	BorderStyleDouble
	// BorderStyleGroove looks as if it were carved in the canvas.
	BorderStyleGroove
	// BorderStyleRidge looks as if it were coming out of the canvas.
	BorderStyleRidge
)

func marshalBorderStyle(p uintptr) (interface{}, error) {
	return BorderStyle(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for BorderStyle.
func (b BorderStyle) String() string {
	switch b {
	case BorderStyleNone:
		return "None"
	case BorderStyleHidden:
		return "Hidden"
	case BorderStyleSolid:
		return "Solid"
	case BorderStyleInset:
		return "Inset"
	case BorderStyleOutset:
		return "Outset"
	case BorderStyleDotted:
		return "Dotted"
	case BorderStyleDashed:
		return "Dashed"
	case BorderStyleDouble:
		return "Double"
	case BorderStyleGroove:
		return "Groove"
	case BorderStyleRidge:
		return "Ridge"
	default:
		return fmt.Sprintf("BorderStyle(%d)", b)
	}
}

// ConstraintAttribute: widget attributes that can be used when creating a
// GtkConstraint.
type ConstraintAttribute C.gint

const (
	// ConstraintAttributeNone: no attribute, used for constant relations.
	ConstraintAttributeNone ConstraintAttribute = iota
	// ConstraintAttributeLeft: left edge of a widget, regardless of text
	// direction.
	ConstraintAttributeLeft
	// ConstraintAttributeRight: right edge of a widget, regardless of text
	// direction.
	ConstraintAttributeRight
	// ConstraintAttributeTop: top edge of a widget.
	ConstraintAttributeTop
	// ConstraintAttributeBottom: bottom edge of a widget.
	ConstraintAttributeBottom
	// ConstraintAttributeStart: leading edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_LEFT for LTR languages,
	// and GTK_CONSTRAINT_ATTRIBUTE_RIGHT for RTL ones.
	ConstraintAttributeStart
	// ConstraintAttributeEnd: trailing edge of a widget, depending on text
	// direction; equivalent to GTK_CONSTRAINT_ATTRIBUTE_RIGHT for LTR
	// languages, and GTK_CONSTRAINT_ATTRIBUTE_LEFT for RTL ones.
	ConstraintAttributeEnd
	// ConstraintAttributeWidth: width of a widget.
	ConstraintAttributeWidth
	// ConstraintAttributeHeight: height of a widget.
	ConstraintAttributeHeight
	// ConstraintAttributeCenterX: center of a widget, on the horizontal axis.
	ConstraintAttributeCenterX
	// ConstraintAttributeCenterY: center of a widget, on the vertical axis.
	ConstraintAttributeCenterY
	// ConstraintAttributeBaseline: baseline of a widget.
	ConstraintAttributeBaseline
)

func marshalConstraintAttribute(p uintptr) (interface{}, error) {
	return ConstraintAttribute(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintAttribute.
func (c ConstraintAttribute) String() string {
	switch c {
	case ConstraintAttributeNone:
		return "None"
	case ConstraintAttributeLeft:
		return "Left"
	case ConstraintAttributeRight:
		return "Right"
	case ConstraintAttributeTop:
		return "Top"
	case ConstraintAttributeBottom:
		return "Bottom"
	case ConstraintAttributeStart:
		return "Start"
	case ConstraintAttributeEnd:
		return "End"
	case ConstraintAttributeWidth:
		return "Width"
	case ConstraintAttributeHeight:
		return "Height"
	case ConstraintAttributeCenterX:
		return "CenterX"
	case ConstraintAttributeCenterY:
		return "CenterY"
	case ConstraintAttributeBaseline:
		return "Baseline"
	default:
		return fmt.Sprintf("ConstraintAttribute(%d)", c)
	}
}

// ConstraintRelation: relation between two terms of a constraint.
type ConstraintRelation C.gint

const (
	// ConstraintRelationLE less than, or equal.
	ConstraintRelationLE ConstraintRelation = -1
	// ConstraintRelationEq: equal.
	ConstraintRelationEq ConstraintRelation = 0
	// ConstraintRelationGE: greater than, or equal.
	ConstraintRelationGE ConstraintRelation = 1
)

func marshalConstraintRelation(p uintptr) (interface{}, error) {
	return ConstraintRelation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintRelation.
func (c ConstraintRelation) String() string {
	switch c {
	case ConstraintRelationLE:
		return "LE"
	case ConstraintRelationEq:
		return "Eq"
	case ConstraintRelationGE:
		return "GE"
	default:
		return fmt.Sprintf("ConstraintRelation(%d)", c)
	}
}

// ConstraintStrength: strength of a constraint, expressed as a symbolic
// constant.
//
// The strength of a Constraint can be expressed with any positive integer; the
// values of this enumeration can be used for readability.
type ConstraintStrength C.gint

const (
	// ConstraintStrengthRequired: constraint is required towards solving the
	// layout.
	ConstraintStrengthRequired ConstraintStrength = 1001001000
	// ConstraintStrengthStrong: strong constraint.
	ConstraintStrengthStrong ConstraintStrength = 1000000000
	// ConstraintStrengthMedium: medium constraint.
	ConstraintStrengthMedium ConstraintStrength = 1000
	// ConstraintStrengthWeak: weak constraint.
	ConstraintStrengthWeak ConstraintStrength = 1
)

func marshalConstraintStrength(p uintptr) (interface{}, error) {
	return ConstraintStrength(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintStrength.
func (c ConstraintStrength) String() string {
	switch c {
	case ConstraintStrengthRequired:
		return "Required"
	case ConstraintStrengthStrong:
		return "Strong"
	case ConstraintStrengthMedium:
		return "Medium"
	case ConstraintStrengthWeak:
		return "Weak"
	default:
		return fmt.Sprintf("ConstraintStrength(%d)", c)
	}
}

// ConstraintVflParserError: domain for VFL parsing errors.
type ConstraintVflParserError C.gint

const (
	// ConstraintVflParserErrorInvalidSymbol: invalid or unknown symbol.
	ConstraintVflParserErrorInvalidSymbol ConstraintVflParserError = iota
	// ConstraintVflParserErrorInvalidAttribute: invalid or unknown attribute.
	ConstraintVflParserErrorInvalidAttribute
	// ConstraintVflParserErrorInvalidView: invalid or unknown view.
	ConstraintVflParserErrorInvalidView
	// ConstraintVflParserErrorInvalidMetric: invalid or unknown metric.
	ConstraintVflParserErrorInvalidMetric
	// ConstraintVflParserErrorInvalidPriority: invalid or unknown priority.
	ConstraintVflParserErrorInvalidPriority
	// ConstraintVflParserErrorInvalidRelation: invalid or unknown relation.
	ConstraintVflParserErrorInvalidRelation
)

func marshalConstraintVflParserError(p uintptr) (interface{}, error) {
	return ConstraintVflParserError(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ConstraintVflParserError.
func (c ConstraintVflParserError) String() string {
	switch c {
	case ConstraintVflParserErrorInvalidSymbol:
		return "Symbol"
	case ConstraintVflParserErrorInvalidAttribute:
		return "Attribute"
	case ConstraintVflParserErrorInvalidView:
		return "View"
	case ConstraintVflParserErrorInvalidMetric:
		return "Metric"
	case ConstraintVflParserErrorInvalidPriority:
		return "Priority"
	case ConstraintVflParserErrorInvalidRelation:
		return "Relation"
	default:
		return fmt.Sprintf("ConstraintVflParserError(%d)", c)
	}
}

// DeleteType: passed to various keybinding signals for deleting text.
type DeleteType C.gint

const (
	// DeleteChars: delete characters.
	DeleteChars DeleteType = iota
	// DeleteWordEnds: delete only the portion of the word to the left/right of
	// cursor if we’re in the middle of a word.
	DeleteWordEnds
	// DeleteWords: delete words.
	DeleteWords
	// DeleteDisplayLines: delete display-lines. Display-lines refers to the
	// visible lines, with respect to the current line breaks. As opposed to
	// paragraphs, which are defined by line breaks in the input.
	DeleteDisplayLines
	// DeleteDisplayLineEnds: delete only the portion of the display-line to the
	// left/right of cursor.
	DeleteDisplayLineEnds
	// DeleteParagraphEnds: delete to the end of the paragraph. Like C-k in
	// Emacs (or its reverse).
	DeleteParagraphEnds
	// DeleteParagraphs: delete entire line. Like C-k in pico.
	DeleteParagraphs
	// DeleteWhitespace: delete only whitespace. Like M-\ in Emacs.
	DeleteWhitespace
)

func marshalDeleteType(p uintptr) (interface{}, error) {
	return DeleteType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DeleteType.
func (d DeleteType) String() string {
	switch d {
	case DeleteChars:
		return "Chars"
	case DeleteWordEnds:
		return "WordEnds"
	case DeleteWords:
		return "Words"
	case DeleteDisplayLines:
		return "DisplayLines"
	case DeleteDisplayLineEnds:
		return "DisplayLineEnds"
	case DeleteParagraphEnds:
		return "ParagraphEnds"
	case DeleteParagraphs:
		return "Paragraphs"
	case DeleteWhitespace:
		return "Whitespace"
	default:
		return fmt.Sprintf("DeleteType(%d)", d)
	}
}

// DirectionType focus movement types.
type DirectionType C.gint

const (
	// DirTabForward: move forward.
	DirTabForward DirectionType = iota
	// DirTabBackward: move backward.
	DirTabBackward
	// DirUp: move up.
	DirUp
	// DirDown: move down.
	DirDown
	// DirLeft: move left.
	DirLeft
	// DirRight: move right.
	DirRight
)

func marshalDirectionType(p uintptr) (interface{}, error) {
	return DirectionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for DirectionType.
func (d DirectionType) String() string {
	switch d {
	case DirTabForward:
		return "TabForward"
	case DirTabBackward:
		return "TabBackward"
	case DirUp:
		return "Up"
	case DirDown:
		return "Down"
	case DirLeft:
		return "Left"
	case DirRight:
		return "Right"
	default:
		return fmt.Sprintf("DirectionType(%d)", d)
	}
}

// EventSequenceState describes the state of a GdkEventSequence in a GtkGesture.
type EventSequenceState C.gint

const (
	// EventSequenceNone: sequence is handled, but not grabbed.
	EventSequenceNone EventSequenceState = iota
	// EventSequenceClaimed: sequence is handled and grabbed.
	EventSequenceClaimed
	// EventSequenceDenied: sequence is denied.
	EventSequenceDenied
)

func marshalEventSequenceState(p uintptr) (interface{}, error) {
	return EventSequenceState(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for EventSequenceState.
func (e EventSequenceState) String() string {
	switch e {
	case EventSequenceNone:
		return "None"
	case EventSequenceClaimed:
		return "Claimed"
	case EventSequenceDenied:
		return "Denied"
	default:
		return fmt.Sprintf("EventSequenceState(%d)", e)
	}
}

// IconSize: built-in icon sizes.
//
// Icon sizes default to being inherited. Where they cannot be inherited, text
// size is the default.
//
// All widgets which use GtkIconSize set the normal-icons or large-icons style
// classes correspondingly, and let themes determine the actual size to be used
// with the -gtk-icon-size CSS property.
type IconSize C.gint

const (
	// IconSizeInherit: keep the size of the parent element.
	IconSizeInherit IconSize = iota
	// IconSizeNormal: size similar to text size.
	IconSizeNormal
	// IconSizeLarge: large size, for example in an icon view.
	IconSizeLarge
)

func marshalIconSize(p uintptr) (interface{}, error) {
	return IconSize(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for IconSize.
func (i IconSize) String() string {
	switch i {
	case IconSizeInherit:
		return "Inherit"
	case IconSizeNormal:
		return "Normal"
	case IconSizeLarge:
		return "Large"
	default:
		return fmt.Sprintf("IconSize(%d)", i)
	}
}

// InputPurpose describes primary purpose of the input widget.
//
// This information is useful for on-screen keyboards and similar input methods
// to decide which keys should be presented to the user.
//
// Note that the purpose is not meant to impose a totally strict rule about
// allowed characters, and does not replace input validation. It is fine for an
// on-screen keyboard to let the user override the character set restriction
// that is expressed by the purpose. The application is expected to validate the
// entry contents, even if it specified a purpose.
//
// The difference between GTK_INPUT_PURPOSE_DIGITS and GTK_INPUT_PURPOSE_NUMBER
// is that the former accepts only digits while the latter also some punctuation
// (like commas or points, plus, minus) and “e” or “E” as in 3.14E+000.
//
// This enumeration may be extended in the future; input methods should
// interpret unknown values as “free form”.
type InputPurpose C.gint

const (
	// InputPurposeFreeForm: allow any character.
	InputPurposeFreeForm InputPurpose = iota
	// InputPurposeAlpha: allow only alphabetic characters.
	InputPurposeAlpha
	// InputPurposeDigits: allow only digits.
	InputPurposeDigits
	// InputPurposeNumber: edited field expects numbers.
	InputPurposeNumber
	// InputPurposePhone: edited field expects phone number.
	InputPurposePhone
	// InputPurposeURL: edited field expects URL.
	InputPurposeURL
	// InputPurposeEmail: edited field expects email address.
	InputPurposeEmail
	// InputPurposeName: edited field expects the name of a person.
	InputPurposeName
	// InputPurposePassword: like GTK_INPUT_PURPOSE_FREE_FORM, but characters
	// are hidden.
	InputPurposePassword
	// InputPurposePIN: like GTK_INPUT_PURPOSE_DIGITS, but characters are
	// hidden.
	InputPurposePIN
	// InputPurposeTerminal: allow any character, in addition to control codes.
	InputPurposeTerminal
)

func marshalInputPurpose(p uintptr) (interface{}, error) {
	return InputPurpose(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for InputPurpose.
func (i InputPurpose) String() string {
	switch i {
	case InputPurposeFreeForm:
		return "FreeForm"
	case InputPurposeAlpha:
		return "Alpha"
	case InputPurposeDigits:
		return "Digits"
	case InputPurposeNumber:
		return "Number"
	case InputPurposePhone:
		return "Phone"
	case InputPurposeURL:
		return "URL"
	case InputPurposeEmail:
		return "Email"
	case InputPurposeName:
		return "Name"
	case InputPurposePassword:
		return "Password"
	case InputPurposePIN:
		return "PIN"
	case InputPurposeTerminal:
		return "Terminal"
	default:
		return fmt.Sprintf("InputPurpose(%d)", i)
	}
}

// Justification: used for justifying the text inside a GtkLabel widget.
type Justification C.gint

const (
	// JustifyLeft: text is placed at the left edge of the label.
	JustifyLeft Justification = iota
	// JustifyRight: text is placed at the right edge of the label.
	JustifyRight
	// JustifyCenter: text is placed in the center of the label.
	JustifyCenter
	// JustifyFill: text is placed is distributed across the label.
	JustifyFill
)

func marshalJustification(p uintptr) (interface{}, error) {
	return Justification(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Justification.
func (j Justification) String() string {
	switch j {
	case JustifyLeft:
		return "Left"
	case JustifyRight:
		return "Right"
	case JustifyCenter:
		return "Center"
	case JustifyFill:
		return "Fill"
	default:
		return fmt.Sprintf("Justification(%d)", j)
	}
}

// LevelBarMode describes how GtkLevelBar contents should be rendered.
//
// Note that this enumeration could be extended with additional modes in the
// future.
type LevelBarMode C.gint

const (
	// LevelBarModeContinuous: bar has a continuous mode.
	LevelBarModeContinuous LevelBarMode = iota
	// LevelBarModeDiscrete: bar has a discrete mode.
	LevelBarModeDiscrete
)

func marshalLevelBarMode(p uintptr) (interface{}, error) {
	return LevelBarMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for LevelBarMode.
func (l LevelBarMode) String() string {
	switch l {
	case LevelBarModeContinuous:
		return "Continuous"
	case LevelBarModeDiscrete:
		return "Discrete"
	default:
		return fmt.Sprintf("LevelBarMode(%d)", l)
	}
}

// MessageType: type of message being displayed in a GtkMessageDialog.
type MessageType C.gint

const (
	// MessageInfo: informational message.
	MessageInfo MessageType = iota
	// MessageWarning: non-fatal warning message.
	MessageWarning
	// MessageQuestion: question requiring a choice.
	MessageQuestion
	// MessageError: fatal error message.
	MessageError
	// MessageOther: none of the above.
	MessageOther
)

func marshalMessageType(p uintptr) (interface{}, error) {
	return MessageType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MessageType.
func (m MessageType) String() string {
	switch m {
	case MessageInfo:
		return "Info"
	case MessageWarning:
		return "Warning"
	case MessageQuestion:
		return "Question"
	case MessageError:
		return "Error"
	case MessageOther:
		return "Other"
	default:
		return fmt.Sprintf("MessageType(%d)", m)
	}
}

// MovementStep: passed as argument to various keybinding signals for moving the
// cursor position.
type MovementStep C.gint

const (
	// MovementLogicalPositions: move forward or back by graphemes.
	MovementLogicalPositions MovementStep = iota
	// MovementVisualPositions: move left or right by graphemes.
	MovementVisualPositions
	// MovementWords: move forward or back by words.
	MovementWords
	// MovementDisplayLines: move up or down lines (wrapped lines).
	MovementDisplayLines
	// MovementDisplayLineEnds: move to either end of a line.
	MovementDisplayLineEnds
	// MovementParagraphs: move up or down paragraphs (newline-ended lines).
	MovementParagraphs
	// MovementParagraphEnds: move to either end of a paragraph.
	MovementParagraphEnds
	// MovementPages: move by pages.
	MovementPages
	// MovementBufferEnds: move to ends of the buffer.
	MovementBufferEnds
	// MovementHorizontalPages: move horizontally by pages.
	MovementHorizontalPages
)

func marshalMovementStep(p uintptr) (interface{}, error) {
	return MovementStep(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for MovementStep.
func (m MovementStep) String() string {
	switch m {
	case MovementLogicalPositions:
		return "LogicalPositions"
	case MovementVisualPositions:
		return "VisualPositions"
	case MovementWords:
		return "Words"
	case MovementDisplayLines:
		return "DisplayLines"
	case MovementDisplayLineEnds:
		return "DisplayLineEnds"
	case MovementParagraphs:
		return "Paragraphs"
	case MovementParagraphEnds:
		return "ParagraphEnds"
	case MovementPages:
		return "Pages"
	case MovementBufferEnds:
		return "BufferEnds"
	case MovementHorizontalPages:
		return "HorizontalPages"
	default:
		return fmt.Sprintf("MovementStep(%d)", m)
	}
}

// NumberUpLayout: used to determine the layout of pages on a sheet when
// printing multiple pages per sheet.
type NumberUpLayout C.gint

const (
	// NumberUpLayoutLeftToRightTopToBottom: ! (layout-lrtb.png).
	NumberUpLayoutLeftToRightTopToBottom NumberUpLayout = iota
	// NumberUpLayoutLeftToRightBottomToTop: ! (layout-lrbt.png).
	NumberUpLayoutLeftToRightBottomToTop
	// NumberUpLayoutRightToLeftTopToBottom: ! (layout-rltb.png).
	NumberUpLayoutRightToLeftTopToBottom
	// NumberUpLayoutRightToLeftBottomToTop: ! (layout-rlbt.png).
	NumberUpLayoutRightToLeftBottomToTop
	// NumberUpLayoutTopToBottomLeftToRight: ! (layout-tblr.png).
	NumberUpLayoutTopToBottomLeftToRight
	// NumberUpLayoutTopToBottomRightToLeft: ! (layout-tbrl.png).
	NumberUpLayoutTopToBottomRightToLeft
	// NumberUpLayoutBottomToTopLeftToRight: ! (layout-btlr.png).
	NumberUpLayoutBottomToTopLeftToRight
	// NumberUpLayoutBottomToTopRightToLeft: ! (layout-btrl.png).
	NumberUpLayoutBottomToTopRightToLeft
)

func marshalNumberUpLayout(p uintptr) (interface{}, error) {
	return NumberUpLayout(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for NumberUpLayout.
func (n NumberUpLayout) String() string {
	switch n {
	case NumberUpLayoutLeftToRightTopToBottom:
		return "Lrtb"
	case NumberUpLayoutLeftToRightBottomToTop:
		return "Lrbt"
	case NumberUpLayoutRightToLeftTopToBottom:
		return "Rltb"
	case NumberUpLayoutRightToLeftBottomToTop:
		return "Rlbt"
	case NumberUpLayoutTopToBottomLeftToRight:
		return "Tblr"
	case NumberUpLayoutTopToBottomRightToLeft:
		return "Tbrl"
	case NumberUpLayoutBottomToTopLeftToRight:
		return "Btlr"
	case NumberUpLayoutBottomToTopRightToLeft:
		return "Btrl"
	default:
		return fmt.Sprintf("NumberUpLayout(%d)", n)
	}
}

// Ordering describes the way two values can be compared.
//
// These values can be used with a GCompareFunc. However, a GCompareFunc is
// allowed to return any integer values. For converting such a value to a
// GtkOrdering value, use gtk.Ordering().FromCmpfunc.
type Ordering C.gint

const (
	// OrderingSmaller: first value is smaller than the second.
	OrderingSmaller Ordering = -1
	// OrderingEqual: two values are equal.
	OrderingEqual Ordering = 0
	// OrderingLarger: first value is larger than the second.
	OrderingLarger Ordering = 1
)

func marshalOrdering(p uintptr) (interface{}, error) {
	return Ordering(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Ordering.
func (o Ordering) String() string {
	switch o {
	case OrderingSmaller:
		return "Smaller"
	case OrderingEqual:
		return "Equal"
	case OrderingLarger:
		return "Larger"
	default:
		return fmt.Sprintf("Ordering(%d)", o)
	}
}

// OrderingFromCmpfunc converts the result of a GCompareFunc like strcmp() to a
// GtkOrdering value.
//
// The function takes the following parameters:
//
//    - cmpfuncResult: result of a comparison function.
//
// The function returns the following values:
//
//    - ordering: corresponding GtkOrdering.
//
func OrderingFromCmpfunc(cmpfuncResult int) Ordering {
	var _arg1 C.int         // out
	var _cret C.GtkOrdering // in

	_arg1 = C.int(cmpfuncResult)

	_cret = C.gtk_ordering_from_cmpfunc(_arg1)
	runtime.KeepAlive(cmpfuncResult)

	var _ordering Ordering // out

	_ordering = Ordering(_cret)

	return _ordering
}

// Orientation represents the orientation of widgets and other objects.
//
// Typical examples are GtkBox or GtkGesturePan`.
type Orientation C.gint

const (
	// OrientationHorizontal: element is in horizontal orientation.
	OrientationHorizontal Orientation = iota
	// OrientationVertical: element is in vertical orientation.
	OrientationVertical
)

func marshalOrientation(p uintptr) (interface{}, error) {
	return Orientation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Orientation.
func (o Orientation) String() string {
	switch o {
	case OrientationHorizontal:
		return "Horizontal"
	case OrientationVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("Orientation(%d)", o)
	}
}

// Overflow defines how content overflowing a given area should be handled.
//
// This is used in gtk.Widget.SetOverflow(). The gtk.Widget:overflow property is
// modeled after the CSS overflow property, but implements it only partially.
type Overflow C.gint

const (
	// OverflowVisible: no change is applied. Content is drawn at the specified
	// position.
	OverflowVisible Overflow = iota
	// OverflowHidden: content is clipped to the bounds of the area. Content
	// outside the area is not drawn and cannot be interacted with.
	OverflowHidden
)

func marshalOverflow(p uintptr) (interface{}, error) {
	return Overflow(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Overflow.
func (o Overflow) String() string {
	switch o {
	case OverflowVisible:
		return "Visible"
	case OverflowHidden:
		return "Hidden"
	default:
		return fmt.Sprintf("Overflow(%d)", o)
	}
}

// PackType represents the packing location of a children in its parent.
//
// See GtkWindowControls for example.
type PackType C.gint

const (
	// PackStart: child is packed into the start of the widget.
	PackStart PackType = iota
	// PackEnd: child is packed into the end of the widget.
	PackEnd
)

func marshalPackType(p uintptr) (interface{}, error) {
	return PackType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PackType.
func (p PackType) String() string {
	switch p {
	case PackStart:
		return "Start"
	case PackEnd:
		return "End"
	default:
		return fmt.Sprintf("PackType(%d)", p)
	}
}

// PageOrientation: see also gtk_print_settings_set_orientation().
type PageOrientation C.gint

const (
	// PageOrientationPortrait: portrait mode.
	PageOrientationPortrait PageOrientation = iota
	// PageOrientationLandscape: landscape mode.
	PageOrientationLandscape
	// PageOrientationReversePortrait: reverse portrait mode.
	PageOrientationReversePortrait
	// PageOrientationReverseLandscape: reverse landscape mode.
	PageOrientationReverseLandscape
)

func marshalPageOrientation(p uintptr) (interface{}, error) {
	return PageOrientation(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PageOrientation.
func (p PageOrientation) String() string {
	switch p {
	case PageOrientationPortrait:
		return "Portrait"
	case PageOrientationLandscape:
		return "Landscape"
	case PageOrientationReversePortrait:
		return "ReversePortrait"
	case PageOrientationReverseLandscape:
		return "ReverseLandscape"
	default:
		return fmt.Sprintf("PageOrientation(%d)", p)
	}
}

// PageSet: see also gtk_print_job_set_page_set().
type PageSet C.gint

const (
	// PageSetAll: all pages.
	PageSetAll PageSet = iota
	// PageSetEven: even pages.
	PageSetEven
	// PageSetOdd: odd pages.
	PageSetOdd
)

func marshalPageSet(p uintptr) (interface{}, error) {
	return PageSet(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PageSet.
func (p PageSet) String() string {
	switch p {
	case PageSetAll:
		return "All"
	case PageSetEven:
		return "Even"
	case PageSetOdd:
		return "Odd"
	default:
		return fmt.Sprintf("PageSet(%d)", p)
	}
}

// PanDirection describes the panning direction of a GtkGesturePan.
type PanDirection C.gint

const (
	// PanDirectionLeft: panned towards the left.
	PanDirectionLeft PanDirection = iota
	// PanDirectionRight: panned towards the right.
	PanDirectionRight
	// PanDirectionUp: panned upwards.
	PanDirectionUp
	// PanDirectionDown: panned downwards.
	PanDirectionDown
)

func marshalPanDirection(p uintptr) (interface{}, error) {
	return PanDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PanDirection.
func (p PanDirection) String() string {
	switch p {
	case PanDirectionLeft:
		return "Left"
	case PanDirectionRight:
		return "Right"
	case PanDirectionUp:
		return "Up"
	case PanDirectionDown:
		return "Down"
	default:
		return fmt.Sprintf("PanDirection(%d)", p)
	}
}

// PositionType describes which edge of a widget a certain feature is positioned
// at.
//
// For examples, see the tabs of a GtkNotebook, or the label of a GtkScale.
type PositionType C.gint

const (
	// PosLeft: feature is at the left edge.
	PosLeft PositionType = iota
	// PosRight: feature is at the right edge.
	PosRight
	// PosTop: feature is at the top edge.
	PosTop
	// PosBottom: feature is at the bottom edge.
	PosBottom
)

func marshalPositionType(p uintptr) (interface{}, error) {
	return PositionType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PositionType.
func (p PositionType) String() string {
	switch p {
	case PosLeft:
		return "Left"
	case PosRight:
		return "Right"
	case PosTop:
		return "Top"
	case PosBottom:
		return "Bottom"
	default:
		return fmt.Sprintf("PositionType(%d)", p)
	}
}

// PrintDuplex: see also gtk_print_settings_set_duplex().
type PrintDuplex C.gint

const (
	// PrintDuplexSimplex: no duplex.
	PrintDuplexSimplex PrintDuplex = iota
	// PrintDuplexHorizontal: horizontal duplex.
	PrintDuplexHorizontal
	// PrintDuplexVertical: vertical duplex.
	PrintDuplexVertical
)

func marshalPrintDuplex(p uintptr) (interface{}, error) {
	return PrintDuplex(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintDuplex.
func (p PrintDuplex) String() string {
	switch p {
	case PrintDuplexSimplex:
		return "Simplex"
	case PrintDuplexHorizontal:
		return "Horizontal"
	case PrintDuplexVertical:
		return "Vertical"
	default:
		return fmt.Sprintf("PrintDuplex(%d)", p)
	}
}

// PrintPages: see also gtk_print_job_set_pages().
type PrintPages C.gint

const (
	// PrintPagesAll: all pages.
	PrintPagesAll PrintPages = iota
	// PrintPagesCurrent: current page.
	PrintPagesCurrent
	// PrintPagesRanges: range of pages.
	PrintPagesRanges
	// PrintPagesSelection: selected pages.
	PrintPagesSelection
)

func marshalPrintPages(p uintptr) (interface{}, error) {
	return PrintPages(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintPages.
func (p PrintPages) String() string {
	switch p {
	case PrintPagesAll:
		return "All"
	case PrintPagesCurrent:
		return "Current"
	case PrintPagesRanges:
		return "Ranges"
	case PrintPagesSelection:
		return "Selection"
	default:
		return fmt.Sprintf("PrintPages(%d)", p)
	}
}

// PrintQuality: see also gtk_print_settings_set_quality().
type PrintQuality C.gint

const (
	// PrintQualityLow: low quality.
	PrintQualityLow PrintQuality = iota
	// PrintQualityNormal: normal quality.
	PrintQualityNormal
	// PrintQualityHigh: high quality.
	PrintQualityHigh
	// PrintQualityDraft: draft quality.
	PrintQualityDraft
)

func marshalPrintQuality(p uintptr) (interface{}, error) {
	return PrintQuality(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PrintQuality.
func (p PrintQuality) String() string {
	switch p {
	case PrintQualityLow:
		return "Low"
	case PrintQualityNormal:
		return "Normal"
	case PrintQualityHigh:
		return "High"
	case PrintQualityDraft:
		return "Draft"
	default:
		return fmt.Sprintf("PrintQuality(%d)", p)
	}
}

// PropagationLimit describes limits of a GtkEventController for handling events
// targeting other widgets.
type PropagationLimit C.gint

const (
	// LimitNone events are handled regardless of what their target is.
	LimitNone PropagationLimit = iota
	// LimitSameNative events are only handled if their target is in the same
	// Native as the event controllers widget. Note that some event types have
	// two targets (origin and destination).
	LimitSameNative
)

func marshalPropagationLimit(p uintptr) (interface{}, error) {
	return PropagationLimit(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PropagationLimit.
func (p PropagationLimit) String() string {
	switch p {
	case LimitNone:
		return "None"
	case LimitSameNative:
		return "SameNative"
	default:
		return fmt.Sprintf("PropagationLimit(%d)", p)
	}
}

// PropagationPhase describes the stage at which events are fed into a
// GtkEventController.
type PropagationPhase C.gint

const (
	// PhaseNone events are not delivered.
	PhaseNone PropagationPhase = iota
	// PhaseCapture events are delivered in the capture phase. The capture phase
	// happens before the bubble phase, runs from the toplevel down to the event
	// widget. This option should only be used on containers that might possibly
	// handle events before their children do.
	PhaseCapture
	// PhaseBubble events are delivered in the bubble phase. The bubble phase
	// happens after the capture phase, and before the default handlers are run.
	// This phase runs from the event widget, up to the toplevel.
	PhaseBubble
	// PhaseTarget events are delivered in the default widget event handlers,
	// note that widget implementations must chain up on button, motion, touch
	// and grab broken handlers for controllers in this phase to be run.
	PhaseTarget
)

func marshalPropagationPhase(p uintptr) (interface{}, error) {
	return PropagationPhase(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for PropagationPhase.
func (p PropagationPhase) String() string {
	switch p {
	case PhaseNone:
		return "None"
	case PhaseCapture:
		return "Capture"
	case PhaseBubble:
		return "Bubble"
	case PhaseTarget:
		return "Target"
	default:
		return fmt.Sprintf("PropagationPhase(%d)", p)
	}
}

// ScrollStep: passed as argument to various keybinding signals.
type ScrollStep C.gint

const (
	// ScrollSteps: scroll in steps.
	ScrollSteps ScrollStep = iota
	// ScrollPages: scroll by pages.
	ScrollPages
	// ScrollEnds: scroll to ends.
	ScrollEnds
	// ScrollHorizontalSteps: scroll in horizontal steps.
	ScrollHorizontalSteps
	// ScrollHorizontalPages: scroll by horizontal pages.
	ScrollHorizontalPages
	// ScrollHorizontalEnds: scroll to the horizontal ends.
	ScrollHorizontalEnds
)

func marshalScrollStep(p uintptr) (interface{}, error) {
	return ScrollStep(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollStep.
func (s ScrollStep) String() string {
	switch s {
	case ScrollSteps:
		return "Steps"
	case ScrollPages:
		return "Pages"
	case ScrollEnds:
		return "Ends"
	case ScrollHorizontalSteps:
		return "HorizontalSteps"
	case ScrollHorizontalPages:
		return "HorizontalPages"
	case ScrollHorizontalEnds:
		return "HorizontalEnds"
	default:
		return fmt.Sprintf("ScrollStep(%d)", s)
	}
}

// ScrollType: scrolling types.
type ScrollType C.gint

const (
	// ScrollNone: no scrolling.
	ScrollNone ScrollType = iota
	// ScrollJump: jump to new location.
	ScrollJump
	// ScrollStepBackward: step backward.
	ScrollStepBackward
	// ScrollStepForward: step forward.
	ScrollStepForward
	// ScrollPageBackward: page backward.
	ScrollPageBackward
	// ScrollPageForward: page forward.
	ScrollPageForward
	// ScrollStepUp: step up.
	ScrollStepUp
	// ScrollStepDown: step down.
	ScrollStepDown
	// ScrollPageUp: page up.
	ScrollPageUp
	// ScrollPageDown: page down.
	ScrollPageDown
	// ScrollStepLeft: step to the left.
	ScrollStepLeft
	// ScrollStepRight: step to the right.
	ScrollStepRight
	// ScrollPageLeft: page to the left.
	ScrollPageLeft
	// ScrollPageRight: page to the right.
	ScrollPageRight
	// ScrollStart: scroll to start.
	ScrollStart
	// ScrollEnd: scroll to end.
	ScrollEnd
)

func marshalScrollType(p uintptr) (interface{}, error) {
	return ScrollType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollType.
func (s ScrollType) String() string {
	switch s {
	case ScrollNone:
		return "None"
	case ScrollJump:
		return "Jump"
	case ScrollStepBackward:
		return "StepBackward"
	case ScrollStepForward:
		return "StepForward"
	case ScrollPageBackward:
		return "PageBackward"
	case ScrollPageForward:
		return "PageForward"
	case ScrollStepUp:
		return "StepUp"
	case ScrollStepDown:
		return "StepDown"
	case ScrollPageUp:
		return "PageUp"
	case ScrollPageDown:
		return "PageDown"
	case ScrollStepLeft:
		return "StepLeft"
	case ScrollStepRight:
		return "StepRight"
	case ScrollPageLeft:
		return "PageLeft"
	case ScrollPageRight:
		return "PageRight"
	case ScrollStart:
		return "Start"
	case ScrollEnd:
		return "End"
	default:
		return fmt.Sprintf("ScrollType(%d)", s)
	}
}

// ScrollablePolicy defines the policy to be used in a scrollable widget when
// updating the scrolled window adjustments in a given orientation.
type ScrollablePolicy C.gint

const (
	// ScrollMinimum: scrollable adjustments are based on the minimum size.
	ScrollMinimum ScrollablePolicy = iota
	// ScrollNatural: scrollable adjustments are based on the natural size.
	ScrollNatural
)

func marshalScrollablePolicy(p uintptr) (interface{}, error) {
	return ScrollablePolicy(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ScrollablePolicy.
func (s ScrollablePolicy) String() string {
	switch s {
	case ScrollMinimum:
		return "Minimum"
	case ScrollNatural:
		return "Natural"
	default:
		return fmt.Sprintf("ScrollablePolicy(%d)", s)
	}
}

// SelectionMode: used to control what selections users are allowed to make.
type SelectionMode C.gint

const (
	// SelectionNone: no selection is possible.
	SelectionNone SelectionMode = iota
	// SelectionSingle: zero or one element may be selected.
	SelectionSingle
	// SelectionBrowse: exactly one element is selected. In some circumstances,
	// such as initially or during a search operation, it’s possible for no
	// element to be selected with GTK_SELECTION_BROWSE. What is really enforced
	// is that the user can’t deselect a currently selected element except by
	// selecting another element.
	SelectionBrowse
	// SelectionMultiple: any number of elements may be selected. The Ctrl key
	// may be used to enlarge the selection, and Shift key to select between the
	// focus and the child pointed to. Some widgets may also allow Click-drag to
	// select a range of elements.
	SelectionMultiple
)

func marshalSelectionMode(p uintptr) (interface{}, error) {
	return SelectionMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SelectionMode.
func (s SelectionMode) String() string {
	switch s {
	case SelectionNone:
		return "None"
	case SelectionSingle:
		return "Single"
	case SelectionBrowse:
		return "Browse"
	case SelectionMultiple:
		return "Multiple"
	default:
		return fmt.Sprintf("SelectionMode(%d)", s)
	}
}

// SensitivityType determines how GTK handles the sensitivity of various
// controls, such as combo box buttons.
type SensitivityType C.gint

const (
	// SensitivityAuto: control is made insensitive if no action can be
	// triggered.
	SensitivityAuto SensitivityType = iota
	// SensitivityOn: control is always sensitive.
	SensitivityOn
	// SensitivityOff: control is always insensitive.
	SensitivityOff
)

func marshalSensitivityType(p uintptr) (interface{}, error) {
	return SensitivityType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SensitivityType.
func (s SensitivityType) String() string {
	switch s {
	case SensitivityAuto:
		return "Auto"
	case SensitivityOn:
		return "On"
	case SensitivityOff:
		return "Off"
	default:
		return fmt.Sprintf("SensitivityType(%d)", s)
	}
}

// ShortcutScope describes where GtkShortcuts added to a GtkShortcutController
// get handled.
type ShortcutScope C.gint

const (
	// ShortcutScopeLocal shortcuts are handled inside the widget the controller
	// belongs to.
	ShortcutScopeLocal ShortcutScope = iota
	// ShortcutScopeManaged shortcuts are handled by the first ancestor that is
	// a ShortcutManager.
	ShortcutScopeManaged
	// ShortcutScopeGlobal shortcuts are handled by the root widget.
	ShortcutScopeGlobal
)

func marshalShortcutScope(p uintptr) (interface{}, error) {
	return ShortcutScope(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for ShortcutScope.
func (s ShortcutScope) String() string {
	switch s {
	case ShortcutScopeLocal:
		return "Local"
	case ShortcutScopeManaged:
		return "Managed"
	case ShortcutScopeGlobal:
		return "Global"
	default:
		return fmt.Sprintf("ShortcutScope(%d)", s)
	}
}

// SizeGroupMode: mode of the size group determines the directions in which the
// size group affects the requested sizes of its component widgets.
type SizeGroupMode C.gint

const (
	// SizeGroupNone: group has no effect.
	SizeGroupNone SizeGroupMode = iota
	// SizeGroupHorizontal: group affects horizontal requisition.
	SizeGroupHorizontal
	// SizeGroupVertical: group affects vertical requisition.
	SizeGroupVertical
	// SizeGroupBoth: group affects both horizontal and vertical requisition.
	SizeGroupBoth
)

func marshalSizeGroupMode(p uintptr) (interface{}, error) {
	return SizeGroupMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SizeGroupMode.
func (s SizeGroupMode) String() string {
	switch s {
	case SizeGroupNone:
		return "None"
	case SizeGroupHorizontal:
		return "Horizontal"
	case SizeGroupVertical:
		return "Vertical"
	case SizeGroupBoth:
		return "Both"
	default:
		return fmt.Sprintf("SizeGroupMode(%d)", s)
	}
}

// SizeRequestMode specifies a preference for height-for-width or
// width-for-height geometry management.
type SizeRequestMode C.gint

const (
	// SizeRequestHeightForWidth: prefer height-for-width geometry management.
	SizeRequestHeightForWidth SizeRequestMode = iota
	// SizeRequestWidthForHeight: prefer width-for-height geometry management.
	SizeRequestWidthForHeight
	// SizeRequestConstantSize: don’t trade height-for-width or
	// width-for-height.
	SizeRequestConstantSize
)

func marshalSizeRequestMode(p uintptr) (interface{}, error) {
	return SizeRequestMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SizeRequestMode.
func (s SizeRequestMode) String() string {
	switch s {
	case SizeRequestHeightForWidth:
		return "HeightForWidth"
	case SizeRequestWidthForHeight:
		return "WidthForHeight"
	case SizeRequestConstantSize:
		return "ConstantSize"
	default:
		return fmt.Sprintf("SizeRequestMode(%d)", s)
	}
}

// SortType determines the direction of a sort.
type SortType C.gint

const (
	// SortAscending: sorting is in ascending order.
	SortAscending SortType = iota
	// SortDescending: sorting is in descending order.
	SortDescending
)

func marshalSortType(p uintptr) (interface{}, error) {
	return SortType(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SortType.
func (s SortType) String() string {
	switch s {
	case SortAscending:
		return "Ascending"
	case SortDescending:
		return "Descending"
	default:
		return fmt.Sprintf("SortType(%d)", s)
	}
}

// SystemSetting values that can be passed to the
// GtkWidgetClass.system_setting_changed vfunc.
//
// The values indicate which system setting has changed. Widgets may need to
// drop caches, or react otherwise.
//
// Most of the values correspond to GtkSettings properties.
//
// More values may be added over time.
type SystemSetting C.gint

const (
	// SystemSettingDPI setting has changed.
	SystemSettingDPI SystemSetting = iota
	// SystemSettingFontName setting has changed.
	SystemSettingFontName
	// SystemSettingFontConfig: font configuration has changed in a way that
	// requires text to be redrawn. This can be any of the
	// Settings:gtk-xft-antialias, Settings:gtk-xft-hinting,
	// Settings:gtk-xft-hintstyle, Settings:gtk-xft-rgba or
	// Settings:gtk-fontconfig-timestamp settings.
	SystemSettingFontConfig
	// SystemSettingDisplay: display has changed.
	SystemSettingDisplay
	// SystemSettingIconTheme: icon theme has changed in a way that requires
	// icons to be looked up again.
	SystemSettingIconTheme
)

func marshalSystemSetting(p uintptr) (interface{}, error) {
	return SystemSetting(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for SystemSetting.
func (s SystemSetting) String() string {
	switch s {
	case SystemSettingDPI:
		return "DPI"
	case SystemSettingFontName:
		return "FontName"
	case SystemSettingFontConfig:
		return "FontConfig"
	case SystemSettingDisplay:
		return "Display"
	case SystemSettingIconTheme:
		return "IconTheme"
	default:
		return fmt.Sprintf("SystemSetting(%d)", s)
	}
}

// TextDirection: reading directions for text.
type TextDirection C.gint

const (
	// TextDirNone: no direction.
	TextDirNone TextDirection = iota
	// TextDirLTR: left to right text direction.
	TextDirLTR
	// TextDirRTL: right to left text direction.
	TextDirRTL
)

func marshalTextDirection(p uintptr) (interface{}, error) {
	return TextDirection(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TextDirection.
func (t TextDirection) String() string {
	switch t {
	case TextDirNone:
		return "None"
	case TextDirLTR:
		return "LTR"
	case TextDirRTL:
		return "RTL"
	default:
		return fmt.Sprintf("TextDirection(%d)", t)
	}
}

// TreeViewGridLines: used to indicate which grid lines to draw in a tree view.
type TreeViewGridLines C.gint

const (
	// TreeViewGridLinesNone: no grid lines.
	TreeViewGridLinesNone TreeViewGridLines = iota
	// TreeViewGridLinesHorizontal: horizontal grid lines.
	TreeViewGridLinesHorizontal
	// TreeViewGridLinesVertical: vertical grid lines.
	TreeViewGridLinesVertical
	// TreeViewGridLinesBoth: horizontal and vertical grid lines.
	TreeViewGridLinesBoth
)

func marshalTreeViewGridLines(p uintptr) (interface{}, error) {
	return TreeViewGridLines(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TreeViewGridLines.
func (t TreeViewGridLines) String() string {
	switch t {
	case TreeViewGridLinesNone:
		return "None"
	case TreeViewGridLinesHorizontal:
		return "Horizontal"
	case TreeViewGridLinesVertical:
		return "Vertical"
	case TreeViewGridLinesBoth:
		return "Both"
	default:
		return fmt.Sprintf("TreeViewGridLines(%d)", t)
	}
}

// Unit: see also gtk_print_settings_set_paper_width().
type Unit C.gint

const (
	// UnitNone: no units.
	UnitNone Unit = iota
	// UnitPoints dimensions in points.
	UnitPoints
	// UnitInch dimensions in inches.
	UnitInch
	// UnitMm dimensions in millimeters.
	UnitMm
)

func marshalUnit(p uintptr) (interface{}, error) {
	return Unit(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for Unit.
func (u Unit) String() string {
	switch u {
	case UnitNone:
		return "None"
	case UnitPoints:
		return "Points"
	case UnitInch:
		return "Inch"
	case UnitMm:
		return "Mm"
	default:
		return fmt.Sprintf("Unit(%d)", u)
	}
}

// WrapMode describes a type of line wrapping.
type WrapMode C.gint

const (
	// WrapNone: do not wrap lines; just make the text area wider.
	WrapNone WrapMode = iota
	// WrapChar: wrap text, breaking lines anywhere the cursor can appear
	// (between characters, usually - if you want to be technical, between
	// graphemes, see pango_get_log_attrs()).
	WrapChar
	// WrapWord: wrap text, breaking lines in between words.
	WrapWord
	// WrapWordChar: wrap text, breaking lines in between words, or if that is
	// not enough, also between graphemes.
	WrapWordChar
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(coreglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for WrapMode.
func (w WrapMode) String() string {
	switch w {
	case WrapNone:
		return "None"
	case WrapChar:
		return "Char"
	case WrapWord:
		return "Word"
	case WrapWordChar:
		return "WordChar"
	default:
		return fmt.Sprintf("WrapMode(%d)", w)
	}
}

// InputHints describes hints that might be taken into account by input methods
// or applications.
//
// Note that input methods may already tailor their behaviour according to the
// GtkInputPurpose of the entry.
//
// Some common sense is expected when using these flags - mixing
// GTK_INPUT_HINT_LOWERCASE with any of the uppercase hints makes no sense.
//
// This enumeration may be extended in the future; input methods should ignore
// unknown values.
type InputHints C.guint

const (
	// InputHintNone: no special behaviour suggested.
	InputHintNone InputHints = 0b0
	// InputHintSpellcheck: suggest checking for typos.
	InputHintSpellcheck InputHints = 0b1
	// InputHintNoSpellcheck: suggest not checking for typos.
	InputHintNoSpellcheck InputHints = 0b10
	// InputHintWordCompletion: suggest word completion.
	InputHintWordCompletion InputHints = 0b100
	// InputHintLowercase: suggest to convert all text to lowercase.
	InputHintLowercase InputHints = 0b1000
	// InputHintUppercaseChars: suggest to capitalize all text.
	InputHintUppercaseChars InputHints = 0b10000
	// InputHintUppercaseWords: suggest to capitalize the first character of
	// each word.
	InputHintUppercaseWords InputHints = 0b100000
	// InputHintUppercaseSentences: suggest to capitalize the first word of each
	// sentence.
	InputHintUppercaseSentences InputHints = 0b1000000
	// InputHintInhibitOSK: suggest to not show an onscreen keyboard (e.g for a
	// calculator that already has all the keys).
	InputHintInhibitOSK InputHints = 0b10000000
	// InputHintVerticalWriting: text is vertical.
	InputHintVerticalWriting InputHints = 0b100000000
	// InputHintEmoji: suggest offering Emoji support.
	InputHintEmoji InputHints = 0b1000000000
	// InputHintNoEmoji: suggest not offering Emoji support.
	InputHintNoEmoji InputHints = 0b10000000000
	// InputHintPrivate: request that the input method should not update
	// personalized data (like typing history).
	InputHintPrivate InputHints = 0b100000000000
)

func marshalInputHints(p uintptr) (interface{}, error) {
	return InputHints(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for InputHints.
func (i InputHints) String() string {
	if i == 0 {
		return "InputHints(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case InputHintNone:
			builder.WriteString("None|")
		case InputHintSpellcheck:
			builder.WriteString("Spellcheck|")
		case InputHintNoSpellcheck:
			builder.WriteString("NoSpellcheck|")
		case InputHintWordCompletion:
			builder.WriteString("WordCompletion|")
		case InputHintLowercase:
			builder.WriteString("Lowercase|")
		case InputHintUppercaseChars:
			builder.WriteString("UppercaseChars|")
		case InputHintUppercaseWords:
			builder.WriteString("UppercaseWords|")
		case InputHintUppercaseSentences:
			builder.WriteString("UppercaseSentences|")
		case InputHintInhibitOSK:
			builder.WriteString("InhibitOSK|")
		case InputHintVerticalWriting:
			builder.WriteString("VerticalWriting|")
		case InputHintEmoji:
			builder.WriteString("Emoji|")
		case InputHintNoEmoji:
			builder.WriteString("NoEmoji|")
		case InputHintPrivate:
			builder.WriteString("Private|")
		default:
			builder.WriteString(fmt.Sprintf("InputHints(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i InputHints) Has(other InputHints) bool {
	return (i & other) == other
}

// PickFlags flags that influence the behavior of gtk_widget_pick().
type PickFlags C.guint

const (
	// PickDefault: default behavior, include widgets that are receiving events.
	PickDefault PickFlags = 0b0
	// PickInsensitive: include widgets that are insensitive.
	PickInsensitive PickFlags = 0b1
	// PickNonTargetable: include widgets that are marked as non-targetable. See
	// Widget:can-target.
	PickNonTargetable PickFlags = 0b10
)

func marshalPickFlags(p uintptr) (interface{}, error) {
	return PickFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for PickFlags.
func (p PickFlags) String() string {
	if p == 0 {
		return "PickFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(45)

	for p != 0 {
		next := p & (p - 1)
		bit := p - next

		switch bit {
		case PickDefault:
			builder.WriteString("Default|")
		case PickInsensitive:
			builder.WriteString("Insensitive|")
		case PickNonTargetable:
			builder.WriteString("NonTargetable|")
		default:
			builder.WriteString(fmt.Sprintf("PickFlags(0b%b)|", bit))
		}

		p = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if p contains other.
func (p PickFlags) Has(other PickFlags) bool {
	return (p & other) == other
}

// StateFlags describes a widget state.
//
// Widget states are used to match the widget against CSS pseudo-classes. Note
// that GTK extends the regular CSS classes and sometimes uses different names.
type StateFlags C.guint

const (
	// StateFlagNormal: state during normal operation.
	StateFlagNormal StateFlags = 0b0
	// StateFlagActive: widget is active.
	StateFlagActive StateFlags = 0b1
	// StateFlagPrelight: widget has a mouse pointer over it.
	StateFlagPrelight StateFlags = 0b10
	// StateFlagSelected: widget is selected.
	StateFlagSelected StateFlags = 0b100
	// StateFlagInsensitive: widget is insensitive.
	StateFlagInsensitive StateFlags = 0b1000
	// StateFlagInconsistent: widget is inconsistent.
	StateFlagInconsistent StateFlags = 0b10000
	// StateFlagFocused: widget has the keyboard focus.
	StateFlagFocused StateFlags = 0b100000
	// StateFlagBackdrop: widget is in a background toplevel window.
	StateFlagBackdrop StateFlags = 0b1000000
	// StateFlagDirLTR: widget is in left-to-right text direction.
	StateFlagDirLTR StateFlags = 0b10000000
	// StateFlagDirRTL: widget is in right-to-left text direction.
	StateFlagDirRTL StateFlags = 0b100000000
	// StateFlagLink: widget is a link.
	StateFlagLink StateFlags = 0b1000000000
	// StateFlagVisited: location the widget points to has already been visited.
	StateFlagVisited StateFlags = 0b10000000000
	// StateFlagChecked: widget is checked.
	StateFlagChecked StateFlags = 0b100000000000
	// StateFlagDropActive: widget is highlighted as a drop target for DND.
	StateFlagDropActive StateFlags = 0b1000000000000
	// StateFlagFocusVisible: widget has the visible focus.
	StateFlagFocusVisible StateFlags = 0b10000000000000
	// StateFlagFocusWithin: widget contains the keyboard focus.
	StateFlagFocusWithin StateFlags = 0b100000000000000
)

func marshalStateFlags(p uintptr) (interface{}, error) {
	return StateFlags(coreglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for StateFlags.
func (s StateFlags) String() string {
	if s == 0 {
		return "StateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(256)

	for s != 0 {
		next := s & (s - 1)
		bit := s - next

		switch bit {
		case StateFlagNormal:
			builder.WriteString("Normal|")
		case StateFlagActive:
			builder.WriteString("Active|")
		case StateFlagPrelight:
			builder.WriteString("Prelight|")
		case StateFlagSelected:
			builder.WriteString("Selected|")
		case StateFlagInsensitive:
			builder.WriteString("Insensitive|")
		case StateFlagInconsistent:
			builder.WriteString("Inconsistent|")
		case StateFlagFocused:
			builder.WriteString("Focused|")
		case StateFlagBackdrop:
			builder.WriteString("Backdrop|")
		case StateFlagDirLTR:
			builder.WriteString("DirLTR|")
		case StateFlagDirRTL:
			builder.WriteString("DirRTL|")
		case StateFlagLink:
			builder.WriteString("Link|")
		case StateFlagVisited:
			builder.WriteString("Visited|")
		case StateFlagChecked:
			builder.WriteString("Checked|")
		case StateFlagDropActive:
			builder.WriteString("DropActive|")
		case StateFlagFocusVisible:
			builder.WriteString("FocusVisible|")
		case StateFlagFocusWithin:
			builder.WriteString("FocusWithin|")
		default:
			builder.WriteString(fmt.Sprintf("StateFlags(0b%b)|", bit))
		}

		s = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if s contains other.
func (s StateFlags) Has(other StateFlags) bool {
	return (s & other) == other
}
