// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_get_type()), F: marshalTexter},
	})
}

// Text: GtkText widget is a single-line text entry widget.
//
// GtkText is the common implementation of single-line text editing that is
// shared between GtkEntry, GtkPasswordEntry, GtkSpinButton and other widgets.
// In all of these, GtkText` is used as the delegate for the gtk.Editable
// implementation.
//
// A fairly large set of key bindings are supported by default. If the entered
// text is longer than the allocation of the widget, the widget will scroll so
// that the cursor position is visible.
//
// When using an entry for passwords and other sensitive information, it can be
// put into “password mode” using gtk.Text.SetVisibility(). In this mode,
// entered text is displayed using a “invisible” character. By default, GTK
// picks the best invisible character that is available in the current font, but
// it can be changed with gtk.Text.SetInvisibleChar().
//
// If you are looking to add icons or progress display in an entry, look at
// GtkEntry. There other alternatives for more specialized use cases, such as
// GtkSearchEntry.
//
// If you need multi-line editable text, look at GtkTextView.
//
// CSS nodes
//
//    text[.read-only]
//    ├── placeholder
//    ├── undershoot.left
//    ├── undershoot.right
//    ├── [selection]
//    ├── [block-cursor]
//    ╰── [window.popup]
//
//
// GtkText has a main node with the name text. Depending on the properties of
// the widget, the .read-only style class may appear.
//
// When the entry has a selection, it adds a subnode with the name selection.
//
// When the entry is in overwrite mode, it adds a subnode with the name
// block-cursor that determines how the block cursor is drawn.
//
// The CSS node for a context menu is added as a subnode below text as well.
//
// The undershoot nodes are used to draw the underflow indication when content
// is scrolled out of view. These nodes get the .left and .right style classes
// added depending on where the indication is drawn.
//
// When touch is used and touch selection handles are shown, they are using CSS
// nodes with name cursor-handle. They get the .top or .bottom style class
// depending on where they are shown in relation to the selection. If there is
// just a single handle for the text cursor, it gets the style class
// .insertion-cursor.
//
//
// Accessibility
//
// GtkText uses the GTK_ACCESSIBLE_ROLE_NONE role, which causes it to be skipped
// for accessibility. This is because GtkText is expected to be used as a
// delegate for a GtkEditable implementation that will be represented to
// accessibility.
type Text struct {
	Widget

	Editable
}

var _ gextras.Nativer = (*Text)(nil)

func wrapText(obj *externglib.Object) *Text {
	return &Text{
		Widget: Widget{
			InitiallyUnowned: externglib.InitiallyUnowned{
				Object: obj,
			},
			Accessible: Accessible{
				Object: obj,
			},
			Buildable: Buildable{
				Object: obj,
			},
			ConstraintTarget: ConstraintTarget{
				Object: obj,
			},
		},
		Editable: Editable{
			Widget: Widget{
				InitiallyUnowned: externglib.InitiallyUnowned{
					Object: obj,
				},
				Accessible: Accessible{
					Object: obj,
				},
				Buildable: Buildable{
					Object: obj,
				},
				ConstraintTarget: ConstraintTarget{
					Object: obj,
				},
			},
		},
	}
}

func marshalTexter(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapText(obj), nil
}

// NewText creates a new GtkText.
func NewText() *Text {
	var _cret *C.GtkWidget // in

	_cret = C.gtk_text_new()

	var _text *Text // out

	_text = wrapText(externglib.Take(unsafe.Pointer(_cret)))

	return _text
}

// NewTextWithBuffer creates a new GtkText with the specified text buffer.
func NewTextWithBuffer(buffer *EntryBuffer) *Text {
	var _arg1 *C.GtkEntryBuffer // out
	var _cret *C.GtkWidget      // in

	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_new_with_buffer(_arg1)

	var _text *Text // out

	_text = wrapText(externglib.Take(unsafe.Pointer(_cret)))

	return _text
}

// Native implements gextras.Nativer. It returns the underlying GObject
// field.
func (v *Text) Native() uintptr {
	return v.Widget.InitiallyUnowned.Object.Native()
}

// ActivatesDefault retrieves the value set by gtk_text_set_activates_default().
func (self *Text) ActivatesDefault() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_activates_default(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Attributes gets the attribute list that was set on the GtkText using
// gtk_text_set_attributes().
func (self *Text) Attributes() *pango.AttrList {
	var _arg0 *C.GtkText       // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_attributes(_arg0)

	var _attrList *pango.AttrList // out

	_attrList = (*pango.AttrList)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(_attrList, func(v *pango.AttrList) {
		C.pango_attr_list_unref((*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(v))))
	})

	return _attrList
}

// Buffer: get the GtkEntryBuffer object which holds the text for this self.
func (self *Text) Buffer() *EntryBuffer {
	var _arg0 *C.GtkText        // out
	var _cret *C.GtkEntryBuffer // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_buffer(_arg0)

	var _entryBuffer *EntryBuffer // out

	_entryBuffer = wrapEntryBuffer(externglib.Take(unsafe.Pointer(_cret)))

	return _entryBuffer
}

// EnableEmojiCompletion returns whether Emoji completion is enabled for this
// GtkText widget.
func (self *Text) EnableEmojiCompletion() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_enable_emoji_completion(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ExtraMenu gets the menu model set with gtk_text_set_extra_menu().
func (self *Text) ExtraMenu() gio.MenuModeller {
	var _arg0 *C.GtkText    // out
	var _cret *C.GMenuModel // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_extra_menu(_arg0)

	var _menuModel gio.MenuModeller // out

	_menuModel = (gextras.CastObject(externglib.Take(unsafe.Pointer(_cret)))).(gio.MenuModeller)

	return _menuModel
}

// InputHints gets the input hints of the GtkText.
func (self *Text) InputHints() InputHints {
	var _arg0 *C.GtkText      // out
	var _cret C.GtkInputHints // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_input_hints(_arg0)

	var _inputHints InputHints // out

	_inputHints = InputHints(_cret)

	return _inputHints
}

// InputPurpose gets the input purpose of the GtkText.
func (self *Text) InputPurpose() InputPurpose {
	var _arg0 *C.GtkText        // out
	var _cret C.GtkInputPurpose // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_input_purpose(_arg0)

	var _inputPurpose InputPurpose // out

	_inputPurpose = InputPurpose(_cret)

	return _inputPurpose
}

// InvisibleChar retrieves the character displayed in place of the real
// characters for entries with visibility set to false.
//
// Note that GTK does not compute this value unless it needs it, so the value
// returned by this function is not very useful unless it has been explicitly
// set with gtk.Text.SetInvisibleChar().
func (self *Text) InvisibleChar() uint32 {
	var _arg0 *C.GtkText // out
	var _cret C.gunichar // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_invisible_char(_arg0)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// MaxLength retrieves the maximum allowed length of the text in self.
//
// See gtk.Text.SetMaxLength().
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.GetMaxLength() on it.
func (self *Text) MaxLength() int {
	var _arg0 *C.GtkText // out
	var _cret C.int      // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_max_length(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// OverwriteMode gets the value set by gtk_text_set_overwrite_mode().
func (self *Text) OverwriteMode() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_overwrite_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PlaceholderText retrieves the text that will be displayed when self is empty
// and unfocused
func (self *Text) PlaceholderText() string {
	var _arg0 *C.GtkText // out
	var _cret *C.char    // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_placeholder_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// PropagateTextWidth returns whether the GtkText will grow and shrink with the
// content.
func (self *Text) PropagateTextWidth() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_propagate_text_width(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Tabs gets the tabstops that were set on the GtkText using
// gtk_text_set_tabs().
func (self *Text) Tabs() *pango.TabArray {
	var _arg0 *C.GtkText       // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_tabs(_arg0)

	var _tabArray *pango.TabArray // out

	_tabArray = (*pango.TabArray)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _tabArray
}

// TextLength retrieves the current length of the text in self.
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.GetLength() on it.
func (self *Text) TextLength() uint16 {
	var _arg0 *C.GtkText // out
	var _cret C.guint16  // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_text_length(_arg0)

	var _guint16 uint16 // out

	_guint16 = uint16(_cret)

	return _guint16
}

// TruncateMultiline returns whether the GtkText will truncate multi-line text
// that is pasted into the widget
func (self *Text) TruncateMultiline() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_truncate_multiline(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Visibility retrieves whether the text in self is visible.
func (self *Text) Visibility() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_get_visibility(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GrabFocusWithoutSelecting causes self to have keyboard focus.
//
// It behaves like gtk.Widget.GrabFocus(), except that it doesn't select the
// contents of self. You only want to call this on some special entries which
// the user usually doesn't want to replace all text in, such as
// search-as-you-type entries.
func (self *Text) GrabFocusWithoutSelecting() bool {
	var _arg0 *C.GtkText // out
	var _cret C.gboolean // in

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	_cret = C.gtk_text_grab_focus_without_selecting(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SetActivatesDefault: if activates is TRUE, pressing Enter in the self will
// activate the default widget for the window containing self.
//
// This usually means that the dialog containing the GtkText will be closed,
// since the default widget is usually one of the dialog buttons.
func (self *Text) SetActivatesDefault(activates bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	if activates {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_activates_default(_arg0, _arg1)
}

// SetAttributes sets attributes that are applied to the text.
func (self *Text) SetAttributes(attrs *pango.AttrList) {
	var _arg0 *C.GtkText       // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.PangoAttrList)(gextras.StructNative(unsafe.Pointer(attrs)))

	C.gtk_text_set_attributes(_arg0, _arg1)
}

// SetBuffer: set the GtkEntryBuffer object which holds the text for this
// widget.
func (self *Text) SetBuffer(buffer *EntryBuffer) {
	var _arg0 *C.GtkText        // out
	var _arg1 *C.GtkEntryBuffer // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GtkEntryBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_set_buffer(_arg0, _arg1)
}

// SetEnableEmojiCompletion sets whether Emoji completion is enabled.
//
// If it is, typing ':', followed by a recognized keyword, will pop up a window
// with suggested Emojis matching the keyword.
func (self *Text) SetEnableEmojiCompletion(enableEmojiCompletion bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	if enableEmojiCompletion {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_enable_emoji_completion(_arg0, _arg1)
}

// SetExtraMenu sets a menu model to add when constructing the context menu for
// self.
func (self *Text) SetExtraMenu(model gio.MenuModeller) {
	var _arg0 *C.GtkText    // out
	var _arg1 *C.GMenuModel // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.GMenuModel)(unsafe.Pointer((model).(gextras.Nativer).Native()))

	C.gtk_text_set_extra_menu(_arg0, _arg1)
}

// SetInputHints sets input hints that allow input methods to fine-tune their
// behaviour.
func (self *Text) SetInputHints(hints InputHints) {
	var _arg0 *C.GtkText      // out
	var _arg1 C.GtkInputHints // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = C.GtkInputHints(hints)

	C.gtk_text_set_input_hints(_arg0, _arg1)
}

// SetInputPurpose sets the input purpose of the GtkText.
//
// This can be used by on-screen keyboards and other input methods to adjust
// their behaviour.
func (self *Text) SetInputPurpose(purpose InputPurpose) {
	var _arg0 *C.GtkText        // out
	var _arg1 C.GtkInputPurpose // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = C.GtkInputPurpose(purpose)

	C.gtk_text_set_input_purpose(_arg0, _arg1)
}

// SetInvisibleChar sets the character to use in place of the actual text when
// in “password mode”.
//
// By default, GTK picks the best invisible char available in the current font.
// If you set the invisible char to 0, then the user will get no feedback at
// all; there will be no text on the screen as they type.
func (self *Text) SetInvisibleChar(ch uint32) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gunichar // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = C.gunichar(ch)

	C.gtk_text_set_invisible_char(_arg0, _arg1)
}

// SetMaxLength sets the maximum allowed length of the contents of the widget.
//
// If the current contents are longer than the given length, then they will be
// truncated to fit.
//
// This is equivalent to getting self's GtkEntryBuffer and calling
// gtk.EntryBuffer.SetMaxLength() on it.
func (self *Text) SetMaxLength(length int) {
	var _arg0 *C.GtkText // out
	var _arg1 C.int      // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = C.int(length)

	C.gtk_text_set_max_length(_arg0, _arg1)
}

// SetOverwriteMode sets whether the text is overwritten when typing in the
// GtkText.
func (self *Text) SetOverwriteMode(overwrite bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	if overwrite {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_overwrite_mode(_arg0, _arg1)
}

// SetPlaceholderText sets text to be displayed in self when it is empty.
//
// This can be used to give a visual hint of the expected contents of the
// GtkText.
func (self *Text) SetPlaceholderText(text string) {
	var _arg0 *C.GtkText // out
	var _arg1 *C.char    // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_set_placeholder_text(_arg0, _arg1)
}

// SetPropagateTextWidth sets whether the GtkText should grow and shrink with
// the content.
func (self *Text) SetPropagateTextWidth(propagateTextWidth bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	if propagateTextWidth {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_propagate_text_width(_arg0, _arg1)
}

// SetTabs sets tabstops that are applied to the text.
func (self *Text) SetTabs(tabs *pango.TabArray) {
	var _arg0 *C.GtkText       // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	_arg1 = (*C.PangoTabArray)(gextras.StructNative(unsafe.Pointer(tabs)))

	C.gtk_text_set_tabs(_arg0, _arg1)
}

// SetTruncateMultiline sets whether the GtkText should truncate multi-line text
// that is pasted into the widget.
func (self *Text) SetTruncateMultiline(truncateMultiline bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	if truncateMultiline {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_truncate_multiline(_arg0, _arg1)
}

// SetVisibility sets whether the contents of the GtkText are visible or not.
//
// When visibility is set to FALSE, characters are displayed as the invisible
// char, and will also appear that way when the text in the widget is copied to
// the clipboard.
//
// By default, GTK picks the best invisible character available in the current
// font, but it can be changed with gtk.Text.SetInvisibleChar().
//
// Note that you probably want to set gtk.Text:input-purpose to
// GTK_INPUT_PURPOSE_PASSWORD or GTK_INPUT_PURPOSE_PIN to inform input methods
// about the purpose of this self, in addition to setting visibility to FALSE.
func (self *Text) SetVisibility(visible bool) {
	var _arg0 *C.GtkText // out
	var _arg1 C.gboolean // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))
	if visible {
		_arg1 = C.TRUE
	}

	C.gtk_text_set_visibility(_arg0, _arg1)
}

// UnsetInvisibleChar unsets the invisible char.
//
// After calling this, the default invisible char is used again.
func (self *Text) UnsetInvisibleChar() {
	var _arg0 *C.GtkText // out

	_arg0 = (*C.GtkText)(unsafe.Pointer(self.Native()))

	C.gtk_text_unset_invisible_char(_arg0)
}
