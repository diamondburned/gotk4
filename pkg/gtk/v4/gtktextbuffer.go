// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include "stubs.h"
// #include <glib-object.h>
// #include <gtk/gtk.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_buffer_get_type()), F: marshalTextBufferer},
	})
}

// TextBufferOverrider contains methods that are overridable.
//
// As of right now, interface overriding and subclassing is not supported
// yet, so the interface currently has no use.
type TextBufferOverrider interface {
	// ApplyTag emits the “apply-tag” signal on buffer.
	//
	// The default handler for the signal applies tag to the given range. start
	// and end do not have to be in order.
	ApplyTag(tag *TextTag, start *TextIter, end *TextIter)
	// BeginUserAction: called to indicate that the buffer operations between
	// here and a call to gtk_text_buffer_end_user_action() are part of a single
	// user-visible operation.
	//
	// The operations between gtk_text_buffer_begin_user_action() and
	// gtk_text_buffer_end_user_action() can then be grouped when creating an
	// undo stack. GtkTextBuffer maintains a count of calls to
	// gtk_text_buffer_begin_user_action() that have not been closed with a call
	// to gtk_text_buffer_end_user_action(), and emits the “begin-user-action”
	// and “end-user-action” signals only for the outermost pair of calls. This
	// allows you to build user actions from other user actions.
	//
	// The “interactive” buffer mutation functions, such as
	// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user
	// action around the buffer operations they perform, so there's no need to
	// add extra calls if you user action consists solely of a single call to
	// one of those functions.
	BeginUserAction()
	Changed()
	DeleteRange(start *TextIter, end *TextIter)
	// EndUserAction ends a user-visible operation.
	//
	// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See
	// that function for a full explanation.
	EndUserAction()
	// InsertChildAnchor inserts a child widget anchor into the text buffer at
	// iter.
	//
	// The anchor will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode “object replacement character” 0xFFFC. Note that the “slice”
	// variants for obtaining portions of the buffer as a string include this
	// character for child anchors, but the “text” variants do not. E.g. see
	// gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	//
	// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient
	// alternative to this function. The buffer will add a reference to the
	// anchor, so you can unref it after insertion.
	InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor)
	// InsertPaintable inserts an image into the text buffer at iter.
	//
	// The image will be counted as one character in character counts, and when
	// obtaining the buffer contents as a string, will be represented by the
	// Unicode “object replacement character” 0xFFFC. Note that the “slice”
	// variants for obtaining portions of the buffer as a string include this
	// character for paintable, but the “text” variants do not. e.g. see
	// gtk.TextBuffer.GetSlice() and gtk.TextBuffer.GetText().
	InsertPaintable(iter *TextIter, paintable gdk.Paintabler)
	InsertText(pos *TextIter, newText string, newTextLength int)
	MarkDeleted(mark *TextMark)
	MarkSet(location *TextIter, mark *TextMark)
	ModifiedChanged()
	PasteDone(clipboard *gdk.Clipboard)
	// Redo redoes the next redoable action on the buffer, if there is one.
	Redo()
	// RemoveTag emits the “remove-tag” signal.
	//
	// The default handler for the signal removes all occurrences of tag from
	// the given range. start and end don’t have to be in order.
	RemoveTag(tag *TextTag, start *TextIter, end *TextIter)
	// Undo undoes the last undoable action on the buffer, if there is one.
	Undo()
}

// TextBuffer stores text and attributes for display in a GtkTextView.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextBuffer struct {
	*externglib.Object
}

func wrapTextBuffer(obj *externglib.Object) *TextBuffer {
	return &TextBuffer{
		Object: obj,
	}
}

func marshalTextBufferer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return wrapTextBuffer(obj), nil
}

// NewTextBuffer creates a new text buffer.
func NewTextBuffer(table *TextTagTable) *TextBuffer {
	var _arg1 *C.GtkTextTagTable // out
	var _cret *C.GtkTextBuffer   // in

	if table != nil {
		_arg1 = (*C.GtkTextTagTable)(unsafe.Pointer(table.Native()))
	}

	_cret = C.gtk_text_buffer_new(_arg1)
	runtime.KeepAlive(table)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _textBuffer
}

// AddMark adds the mark at position where.
//
// The mark must not be added to another buffer, and if its name is not NULL
// then there must not be another mark in the buffer with the same name.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (buffer *TextBuffer) AddMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_add_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// AddSelectionClipboard adds clipboard to the list of clipboards in which the
// selection contents of buffer are available.
//
// In most cases, clipboard will be the GdkClipboard returned by
// gtk.Widget.GetPrimaryClipboard() for a view of buffer.
func (buffer *TextBuffer) AddSelectionClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_add_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// ApplyTag emits the “apply-tag” signal on buffer.
//
// The default handler for the signal applies tag to the given range. start and
// end do not have to be in order.
func (buffer *TextBuffer) ApplyTag(tag *TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// ApplyTagByName emits the “apply-tag” signal on buffer.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.ApplyTag().
func (buffer *TextBuffer) ApplyTagByName(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_apply_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// Backspace performs the appropriate action as if the user hit the delete key
// with the cursor at the position specified by iter.
//
// In the normal case a single character will be deleted, but when combining
// accents are involved, more than one character can be deleted, and when
// precomposed character and accent combinations are involved, less than one
// character will be deleted.
//
// Because the buffer is modified, all outstanding iterators become invalid
// after calling this function; however, the iter will be re-initialized to
// point to the location where text was deleted.
func (buffer *TextBuffer) Backspace(iter *TextIter, interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 C.gboolean       // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	if interactive {
		_arg2 = C.TRUE
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_backspace(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BeginIrreversibleAction denotes the beginning of an action that may not be
// undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be paired with a call to gtk.TextBuffer.EndIrreversibleAction()
// after the irreversible action has completed.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) BeginIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_begin_irreversible_action(_arg0)
	runtime.KeepAlive(buffer)
}

// BeginUserAction: called to indicate that the buffer operations between here
// and a call to gtk_text_buffer_end_user_action() are part of a single
// user-visible operation.
//
// The operations between gtk_text_buffer_begin_user_action() and
// gtk_text_buffer_end_user_action() can then be grouped when creating an undo
// stack. GtkTextBuffer maintains a count of calls to
// gtk_text_buffer_begin_user_action() that have not been closed with a call to
// gtk_text_buffer_end_user_action(), and emits the “begin-user-action” and
// “end-user-action” signals only for the outermost pair of calls. This allows
// you to build user actions from other user actions.
//
// The “interactive” buffer mutation functions, such as
// gtk.TextBuffer.InsertInteractive(), automatically call begin/end user action
// around the buffer operations they perform, so there's no need to add extra
// calls if you user action consists solely of a single call to one of those
// functions.
func (buffer *TextBuffer) BeginUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_begin_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// CopyClipboard copies the currently-selected text to a clipboard.
func (buffer *TextBuffer) CopyClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_copy_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// CreateChildAnchor creates and inserts a child anchor.
//
// This is a convenience function which simply creates a child anchor with
// gtk.TextChildAnchor.New and inserts it into the buffer with
// gtk.TextBuffer.InsertChildAnchor().
//
// The new anchor is owned by the buffer; no reference count is returned to the
// caller of this function.
func (buffer *TextBuffer) CreateChildAnchor(iter *TextIter) *TextChildAnchor {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))

	_cret = C.gtk_text_buffer_create_child_anchor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(externglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// CreateMark creates a mark at position where.
//
// If mark_name is NULL, the mark is anonymous; otherwise, the mark can be
// retrieved by name using gtk.TextBuffer.GetMark(). If a mark has left gravity,
// and text is inserted at the mark’s current location, the mark will be moved
// to the left of the newly-inserted text. If the mark has right gravity
// (left_gravity = FALSE), the mark will end up on the right of newly-inserted
// text. The standard left-to-right cursor is a mark with right gravity (when
// you type, the cursor stays on the right side of the text you’re typing).
//
// The caller of this function does not own a reference to the returned
// TextMark, so you can ignore the return value if you like. Marks are owned by
// the buffer and go away when the buffer does.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the mark's
// initial placement.
func (buffer *TextBuffer) CreateMark(markName string, where *TextIter, leftGravity bool) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	if markName != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(markName)))
		defer C.free(unsafe.Pointer(_arg1))
	}
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))
	if leftGravity {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_create_mark(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(markName)
	runtime.KeepAlive(where)
	runtime.KeepAlive(leftGravity)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// CutClipboard copies the currently-selected text to a clipboard, then deletes
// said text if it’s editable.
func (buffer *TextBuffer) CutClipboard(clipboard *gdk.Clipboard, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	if defaultEditable {
		_arg2 = C.TRUE
	}

	C.gtk_text_buffer_cut_clipboard(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(defaultEditable)
}

// Delete deletes text between start and end.
//
// The order of start and end is not actually relevant; gtk_text_buffer_delete()
// will reorder them.
//
// This function actually emits the “delete-range” signal, and the default
// handler of that signal deletes the text. Because the buffer is modified, all
// outstanding iterators become invalid after calling this function; however,
// the start and end will be re-initialized to point to the location where text
// was deleted.
func (buffer *TextBuffer) Delete(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_delete(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// DeleteInteractive deletes all editable text in the given range.
//
// Calls gtk.TextBuffer.Delete() for each editable sub-range of [start,end).
// start and end are revalidated to point to the location of the last deleted
// range, or left untouched if no text was deleted.
func (buffer *TextBuffer) DeleteInteractive(startIter *TextIter, endIter *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(startIter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(endIter)))
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_interactive(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(startIter)
	runtime.KeepAlive(endIter)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// DeleteMark deletes mark, so that it’s no longer located anywhere in the
// buffer.
//
// Removes the reference the buffer holds to the mark, so if you haven’t called
// g_object_ref() on the mark, it will be freed. Even if the mark isn’t freed,
// most operations on mark become invalid, until it gets added to a buffer again
// with gtk.TextBuffer.AddMark(). Use gtk.TextMark.GetDeleted() to find out if a
// mark has been removed from its buffer.
//
// The gtk.TextBuffer::mark-deleted signal will be emitted as notification after
// the mark is deleted.
func (buffer *TextBuffer) DeleteMark(mark *TextMark) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_delete_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
}

// DeleteMarkByName deletes the mark named name; the mark must exist.
//
// See gtk.TextBuffer.DeleteMark() for details.
func (buffer *TextBuffer) DeleteMarkByName(name string) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.gtk_text_buffer_delete_mark_by_name(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
}

// DeleteSelection deletes the range between the “insert” and “selection_bound”
// marks, that is, the currently-selected text.
//
// If interactive is TRUE, the editability of the selection will be considered
// (users can’t delete uneditable text).
func (buffer *TextBuffer) DeleteSelection(interactive bool, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out
	var _arg2 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	if interactive {
		_arg1 = C.TRUE
	}
	if defaultEditable {
		_arg2 = C.TRUE
	}

	_cret = C.gtk_text_buffer_delete_selection(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(interactive)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndIrreversibleAction denotes the end of an action that may not be undone.
//
// This will cause any previous operations in the undo/redo queue to be cleared.
//
// This should be called after completing modifications to the text buffer after
// gtk_text_buffer_begin_irreversible_action() was called.
//
// You may nest calls to gtk_text_buffer_begin_irreversible_action() and
// gtk_text_buffer_end_irreversible_action() pairs.
func (buffer *TextBuffer) EndIrreversibleAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_end_irreversible_action(_arg0)
	runtime.KeepAlive(buffer)
}

// EndUserAction ends a user-visible operation.
//
// Should be paired with a call to gtk.TextBuffer.BeginUserAction(). See that
// function for a full explanation.
func (buffer *TextBuffer) EndUserAction() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_end_user_action(_arg0)
	runtime.KeepAlive(buffer)
}

// Bounds retrieves the first and last iterators in the buffer, i.e. the entire
// buffer lies within the range [start,end).
func (buffer *TextBuffer) Bounds() (start TextIter, end TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_get_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start TextIter // out
	var _end TextIter   // out

	_start = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))

	return _start, _end
}

// CanRedo gets whether there is a redoable action in the history.
func (buffer *TextBuffer) CanRedo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_can_redo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanUndo gets whether there is an undoable action in the history.
func (buffer *TextBuffer) CanUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_can_undo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CharCount gets the number of characters in the buffer.
//
// Note that characters and bytes are not the same, you can’t e.g. expect the
// contents of the buffer in string form to be this many bytes long.
//
// The character count is cached, so this function is very fast.
func (buffer *TextBuffer) CharCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_char_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// EnableUndo gets whether the buffer is saving modifications to the buffer to
// allow for undo and redo actions.
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
func (buffer *TextBuffer) EnableUndo() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_enable_undo(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndIter initializes iter with the “end iterator,” one past the last valid
// character in the text buffer.
//
// If dereferenced with gtk.TextIter.GetChar(), the end iterator has a character
// value of 0. The entire buffer lies in the range from the first position in
// the buffer (call gtk.TextBuffer.GetStartIter() to get character position 0)
// to the end iterator.
func (buffer *TextBuffer) EndIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_get_end_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// HasSelection indicates whether the buffer has some text currently selected.
func (buffer *TextBuffer) HasSelection() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_has_selection(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GetInsert returns the mark that represents the cursor (insertion point).
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “insert”, but very slightly more efficient, and involves less typing.
func (buffer *TextBuffer) GetInsert() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_insert(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// IterAtChildAnchor obtains the location of anchor within buffer.
func (buffer *TextBuffer) IterAtChildAnchor(anchor *TextChildAnchor) TextIter {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 C.GtkTextIter         // in
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_get_iter_at_child_anchor(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(anchor)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtLine initializes iter to the start of the given line.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned.
func (buffer *TextBuffer) IterAtLine(lineNumber int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.int(lineNumber)

	_cret = C.gtk_text_buffer_get_iter_at_line(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)

	var _iter TextIter // out
	var _ok bool       // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineIndex obtains an iterator pointing to byte_index within the given
// line.
//
// byte_index must be the start of a UTF-8 character. Note bytes, not
// characters; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if byte_index is off the end of the line,
// the iterator at the end of the line is returned.
func (buffer *TextBuffer) IterAtLineIndex(lineNumber int, byteIndex int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(byteIndex)

	_cret = C.gtk_text_buffer_get_iter_at_line_index(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(byteIndex)

	var _iter TextIter // out
	var _ok bool       // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtLineOffset obtains an iterator pointing to char_offset within the given
// line.
//
// Note characters, not bytes; UTF-8 may encode one character as multiple bytes.
//
// If line_number is greater than or equal to the number of lines in the buffer,
// the end iterator is returned. And if char_offset is off the end of the line,
// the iterator at the end of the line is returned.
func (buffer *TextBuffer) IterAtLineOffset(lineNumber int, charOffset int) (TextIter, bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.int(lineNumber)
	_arg3 = C.int(charOffset)

	_cret = C.gtk_text_buffer_get_iter_at_line_offset(_arg0, &_arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(lineNumber)
	runtime.KeepAlive(charOffset)

	var _iter TextIter // out
	var _ok bool       // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	if _cret != 0 {
		_ok = true
	}

	return _iter, _ok
}

// IterAtMark initializes iter with the current position of mark.
func (buffer *TextBuffer) IterAtMark(mark *TextMark) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 *C.GtkTextMark   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))

	C.gtk_text_buffer_get_iter_at_mark(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// IterAtOffset initializes iter to a position char_offset chars from the start
// of the entire buffer.
//
// If char_offset is -1 or greater than the number of characters in the buffer,
// iter is initialized to the end iterator, the iterator one past the last valid
// character in the buffer.
func (buffer *TextBuffer) IterAtOffset(charOffset int) TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg2 = C.int(charOffset)

	C.gtk_text_buffer_get_iter_at_offset(_arg0, &_arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(charOffset)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// LineCount obtains the number of lines in the buffer.
//
// This value is cached, so the function is very fast.
func (buffer *TextBuffer) LineCount() int {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.int            // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_line_count(_arg0)
	runtime.KeepAlive(buffer)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Mark returns the mark named name in buffer buffer, or NULL if no such mark
// exists in the buffer.
func (buffer *TextBuffer) Mark(name string) *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.gtk_text_buffer_get_mark(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)

	var _textMark *TextMark // out

	if _cret != nil {
		_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))
	}

	return _textMark
}

// MaxUndoLevels gets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
func (buffer *TextBuffer) MaxUndoLevels() uint {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.guint          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_max_undo_levels(_arg0)
	runtime.KeepAlive(buffer)

	var _guint uint // out

	_guint = uint(_cret)

	return _guint
}

// Modified indicates whether the buffer has been modified since the last call
// to gtk.TextBuffer.SetModified() set the modification flag to FALSE.
//
// Used for example to enable a “save” function in a text editor.
func (buffer *TextBuffer) Modified() bool {
	var _arg0 *C.GtkTextBuffer // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_modified(_arg0)
	runtime.KeepAlive(buffer)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// SelectionBound returns the mark that represents the selection bound.
//
// Equivalent to calling gtk.TextBuffer.GetMark() to get the mark named
// “selection_bound”, but very slightly more efficient, and involves less
// typing.
//
// The currently-selected text in buffer is the region between the
// “selection_bound” and “insert” marks. If “selection_bound” and “insert” are
// in the same place, then there is no current selection.
// gtk.TextBuffer.GetSelectionBounds() is another convenient function for
// handling the selection, if you just want to know whether there’s a selection
// and what its bounds are.
func (buffer *TextBuffer) SelectionBound() *TextMark {
	var _arg0 *C.GtkTextBuffer // out
	var _cret *C.GtkTextMark   // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_selection_bound(_arg0)
	runtime.KeepAlive(buffer)

	var _textMark *TextMark // out

	_textMark = wrapTextMark(externglib.Take(unsafe.Pointer(_cret)))

	return _textMark
}

// SelectionBounds returns TRUE if some text is selected; places the bounds of
// the selection in start and end.
//
// If the selection has length 0, then start and end are filled in with the same
// value. start and end will be in ascending order. If start and end are NULL,
// then they are not filled in, but the return value still indicates whether
// text is selected.
func (buffer *TextBuffer) SelectionBounds() (start TextIter, end TextIter, ok bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in
	var _arg2 C.GtkTextIter    // in
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_selection_bounds(_arg0, &_arg1, &_arg2)
	runtime.KeepAlive(buffer)

	var _start TextIter // out
	var _end TextIter   // out
	var _ok bool        // out

	_start = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))
	_end = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg2))))
	if _cret != 0 {
		_ok = true
	}

	return _start, _end, _ok
}

// SelectionContent: get a content provider for this buffer.
//
// It can be used to make the content of buffer available in a GdkClipboard, see
// gdk.Clipboard.SetContent().
func (buffer *TextBuffer) SelectionContent() *gdk.ContentProvider {
	var _arg0 *C.GtkTextBuffer      // out
	var _cret *C.GdkContentProvider // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_selection_content(_arg0)
	runtime.KeepAlive(buffer)

	var _contentProvider *gdk.ContentProvider // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_contentProvider = &gdk.ContentProvider{
			Object: obj,
		}
	}

	return _contentProvider
}

// Slice returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. The returned string includes a
// 0xFFFC character whenever the buffer contains embedded images, so byte and
// character indexes into the returned string do correspond to byte and
// character indexes into the buffer. Contrast with gtk.TextBuffer.GetText().
// Note that 0xFFFC can occur in normal text as well, so it is not a reliable
// indicator that a paintable or widget is in the buffer.
func (buffer *TextBuffer) Slice(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_slice(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// StartIter: initialized iter with the first position in the text buffer.
//
// This is the same as using gtk.TextBuffer.GetIterAtOffset() to get the iter at
// character offset 0.
func (buffer *TextBuffer) StartIter() TextIter {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.GtkTextIter    // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_get_start_iter(_arg0, &_arg1)
	runtime.KeepAlive(buffer)

	var _iter TextIter // out

	_iter = *(*TextIter)(gextras.NewStructNative(unsafe.Pointer((&_arg1))))

	return _iter
}

// TagTable: get the GtkTextTagTable associated with this buffer.
func (buffer *TextBuffer) TagTable() *TextTagTable {
	var _arg0 *C.GtkTextBuffer   // out
	var _cret *C.GtkTextTagTable // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	_cret = C.gtk_text_buffer_get_tag_table(_arg0)
	runtime.KeepAlive(buffer)

	var _textTagTable *TextTagTable // out

	_textTagTable = wrapTextTagTable(externglib.Take(unsafe.Pointer(_cret)))

	return _textTagTable
}

// Text returns the text in the range [start,end).
//
// Excludes undisplayed text (text marked with tags that set the invisibility
// attribute) if include_hidden_chars is FALSE. Does not include characters
// representing embedded images, so byte and character indexes into the returned
// string do not correspond to byte and character indexes into the buffer.
// Contrast with gtk.TextBuffer.GetSlice().
func (buffer *TextBuffer) Text(start *TextIter, end *TextIter, includeHiddenChars bool) string {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out
	var _cret *C.char          // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if includeHiddenChars {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_get_text(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(includeHiddenChars)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Insert inserts len bytes of text at position iter.
//
// If len is -1, text must be nul-terminated and will be inserted in its
// entirety. Emits the “insert-text” signal; insertion actually occurs in the
// default handler for the signal. iter is invalidated when insertion occurs
// (because the buffer contents change), but the default signal handler
// revalidates it to point to the end of the inserted text.
func (buffer *TextBuffer) Insert(iter *TextIter, text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)

	C.gtk_text_buffer_insert(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
}

// InsertAtCursor inserts text in buffer.
//
// Simply calls gtk.TextBuffer.Insert(), using the current cursor position as
// the insertion point.
func (buffer *TextBuffer) InsertAtCursor(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)

	C.gtk_text_buffer_insert_at_cursor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
}

// InsertChildAnchor inserts a child widget anchor into the text buffer at iter.
//
// The anchor will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for child
// anchors, but the “text” variants do not. E.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
//
// Consider gtk.TextBuffer.CreateChildAnchor() as a more convenient alternative
// to this function. The buffer will add a reference to the anchor, so you can
// unref it after insertion.
func (buffer *TextBuffer) InsertChildAnchor(iter *TextIter, anchor *TextChildAnchor) {
	var _arg0 *C.GtkTextBuffer      // out
	var _arg1 *C.GtkTextIter        // out
	var _arg2 *C.GtkTextChildAnchor // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextChildAnchor)(unsafe.Pointer(anchor.Native()))

	C.gtk_text_buffer_insert_child_anchor(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(anchor)
}

// InsertInteractive inserts text in buffer.
//
// Like gtk.TextBuffer.Insert(), but the insertion will not occur if iter is at
// a non-editable location in the buffer. Usually you want to prevent insertions
// at ineditable locations if the insertion results from a user action (is
// interactive).
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
func (buffer *TextBuffer) InsertInteractive(iter *TextIter, text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertInteractiveAtCursor inserts text in buffer.
//
// Calls gtk.TextBuffer.InsertInteractive() at the cursor position.
//
// default_editable indicates the editability of text that doesn't have a tag
// affecting editability applied to it. Typically the result of
// gtk.TextView.GetEditable() is appropriate here.
func (buffer *TextBuffer) InsertInteractiveAtCursor(text string, len int, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out
	var _arg3 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)
	if defaultEditable {
		_arg3 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_interactive_at_cursor(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsertMarkup inserts the text in markup at position iter.
//
// markup will be inserted in its entirety and must be nul-terminated and valid
// UTF-8. Emits the gtk.TextBuffer::insert-text signal, possibly multiple times;
// insertion actually occurs in the default handler for the signal. iter will
// point to the end of the inserted text on return.
func (buffer *TextBuffer) InsertMarkup(iter *TextIter, markup string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.char          // out
	var _arg3 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(markup)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.int(len)

	C.gtk_text_buffer_insert_markup(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(markup)
	runtime.KeepAlive(len)
}

// InsertPaintable inserts an image into the text buffer at iter.
//
// The image will be counted as one character in character counts, and when
// obtaining the buffer contents as a string, will be represented by the Unicode
// “object replacement character” 0xFFFC. Note that the “slice” variants for
// obtaining portions of the buffer as a string include this character for
// paintable, but the “text” variants do not. e.g. see gtk.TextBuffer.GetSlice()
// and gtk.TextBuffer.GetText().
func (buffer *TextBuffer) InsertPaintable(iter *TextIter, paintable gdk.Paintabler) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GdkPaintable  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GdkPaintable)(unsafe.Pointer(paintable.Native()))

	C.gtk_text_buffer_insert_paintable(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(paintable)
}

// InsertRange copies text, tags, and paintables between start and end and
// inserts the copy at iter.
//
// The order of start and end doesn’t matter.
//
// Used instead of simply getting/inserting text because it preserves images and
// tags. If start and end are in a different buffer from buffer, the two buffers
// must share the same tag table.
//
// Implemented via emissions of the insert_text and apply_tag signals, so expect
// those.
func (buffer *TextBuffer) InsertRange(iter *TextIter, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_insert_range(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// InsertRangeInteractive copies text, tags, and paintables between start and
// end and inserts the copy at iter.
//
// Same as gtk.TextBuffer.InsertRange(), but does nothing if the insertion point
// isn’t editable. The default_editable parameter indicates whether the text is
// editable at iter if no tags enclosing iter affect editability. Typically the
// result of gtk.TextView.GetEditable() is appropriate here.
func (buffer *TextBuffer) InsertRangeInteractive(iter *TextIter, start *TextIter, end *TextIter, defaultEditable bool) bool {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out
	var _arg4 C.gboolean       // out
	var _cret C.gboolean       // in

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(iter)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))
	if defaultEditable {
		_arg4 = C.TRUE
	}

	_cret = C.gtk_text_buffer_insert_range_interactive(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(iter)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
	runtime.KeepAlive(defaultEditable)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MoveMark moves mark to the new location where.
//
// Emits the GtkTextBuffer::mark-set signal as notification of the move.
func (buffer *TextBuffer) MoveMark(mark *TextMark, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextMark   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextMark)(unsafe.Pointer(mark.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(mark)
	runtime.KeepAlive(where)
}

// MoveMarkByName moves the mark named name (which must exist) to location
// where.
//
// See gtk.TextBuffer.MoveMark() for details.
func (buffer *TextBuffer) MoveMarkByName(name string, where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_move_mark_by_name(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(where)
}

// PasteClipboard pastes the contents of a clipboard.
//
// If override_location is NULL, the pasted text will be inserted at the cursor
// position, or the buffer selection will be replaced if the selection is
// non-empty.
//
// Note: pasting is asynchronous, that is, we’ll ask for the paste data and
// return, and at some point later after the main loop runs, the paste data will
// be inserted.
func (buffer *TextBuffer) PasteClipboard(clipboard *gdk.Clipboard, overrideLocation *TextIter, defaultEditable bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))
	if overrideLocation != nil {
		_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(overrideLocation)))
	}
	if defaultEditable {
		_arg3 = C.TRUE
	}

	C.gtk_text_buffer_paste_clipboard(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
	runtime.KeepAlive(overrideLocation)
	runtime.KeepAlive(defaultEditable)
}

// PlaceCursor: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them to the same place in two steps with
// gtk.TextBuffer.MoveMark(), you will temporarily select a region in between
// their old and new locations, which can be pretty inefficient since the
// temporarily-selected region will force stuff to be recalculated. This
// function moves them as a unit, which can be optimized.
func (buffer *TextBuffer) PlaceCursor(where *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(where)))

	C.gtk_text_buffer_place_cursor(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(where)
}

// Redo redoes the next redoable action on the buffer, if there is one.
func (buffer *TextBuffer) Redo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_redo(_arg0)
	runtime.KeepAlive(buffer)
}

// RemoveAllTags removes all tags in the range between start and end.
//
// Be careful with this function; it could remove tags added in code unrelated
// to the code you’re currently writing. That is, using this function is
// probably a bad idea if you have two or more unrelated code sections that add
// tags.
func (buffer *TextBuffer) RemoveAllTags(start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_all_tags(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveSelectionClipboard removes a GdkClipboard added with
// gtk_text_buffer_add_selection_clipboard().
func (buffer *TextBuffer) RemoveSelectionClipboard(clipboard *gdk.Clipboard) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GdkClipboard  // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GdkClipboard)(unsafe.Pointer(clipboard.Native()))

	C.gtk_text_buffer_remove_selection_clipboard(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(clipboard)
}

// RemoveTag emits the “remove-tag” signal.
//
// The default handler for the signal removes all occurrences of tag from the
// given range. start and end don’t have to be in order.
func (buffer *TextBuffer) RemoveTag(tag *TextTag, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextTag    // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(tag)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// RemoveTagByName emits the “remove-tag” signal.
//
// Calls gtk.TextTagTable.Lookup() on the buffer’s tag table to get a
// GtkTextTag, then calls gtk.TextBuffer.RemoveTag().
func (buffer *TextBuffer) RemoveTagByName(name string, start *TextIter, end *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 *C.GtkTextIter   // out
	var _arg3 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(start)))
	_arg3 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(end)))

	C.gtk_text_buffer_remove_tag_by_name(_arg0, _arg1, _arg2, _arg3)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(name)
	runtime.KeepAlive(start)
	runtime.KeepAlive(end)
}

// SelectRange: this function moves the “insert” and “selection_bound” marks
// simultaneously.
//
// If you move them in two steps with gtk.TextBuffer.MoveMark(), you will
// temporarily select a region in between their old and new locations, which can
// be pretty inefficient since the temporarily-selected region will force stuff
// to be recalculated. This function moves them as a unit, which can be
// optimized.
func (buffer *TextBuffer) SelectRange(ins *TextIter, bound *TextIter) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.GtkTextIter   // out
	var _arg2 *C.GtkTextIter   // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(ins)))
	_arg2 = (*C.GtkTextIter)(gextras.StructNative(unsafe.Pointer(bound)))

	C.gtk_text_buffer_select_range(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(ins)
	runtime.KeepAlive(bound)
}

// SetEnableUndo sets whether or not to enable undoable actions in the text
// buffer.
//
// If enabled, the user will be able to undo the last number of actions up to
// gtk.TextBuffer.GetMaxUndoLevels().
//
// See gtk.TextBuffer.BeginIrreversibleAction() and
// gtk.TextBuffer.EndIrreversibleAction() to create changes to the buffer that
// cannot be undone.
func (buffer *TextBuffer) SetEnableUndo(enableUndo bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	if enableUndo {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_enable_undo(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(enableUndo)
}

// SetMaxUndoLevels sets the maximum number of undo levels to perform.
//
// If 0, unlimited undo actions may be performed. Note that this may have a
// memory usage impact as it requires storing an additional copy of the inserted
// or removed text within the text buffer.
func (buffer *TextBuffer) SetMaxUndoLevels(maxUndoLevels uint) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.guint          // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = C.guint(maxUndoLevels)

	C.gtk_text_buffer_set_max_undo_levels(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(maxUndoLevels)
}

// SetModified: used to keep track of whether the buffer has been modified since
// the last time it was saved.
//
// Whenever the buffer is saved to disk, call gtk_text_buffer_set_modified
// (buffer, FALSE). When the buffer is modified, it will automatically toggled
// on the modified bit again. When the modified bit flips, the buffer emits the
// gtk.TextBuffer::modified-changed signal.
func (buffer *TextBuffer) SetModified(setting bool) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 C.gboolean       // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.gtk_text_buffer_set_modified(_arg0, _arg1)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(setting)
}

// SetText deletes current contents of buffer, and inserts text instead.
//
// If len is -1, text must be nul-terminated. text must be valid UTF-8.
func (buffer *TextBuffer) SetText(text string, len int) {
	var _arg0 *C.GtkTextBuffer // out
	var _arg1 *C.char          // out
	var _arg2 C.int            // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(text)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.int(len)

	C.gtk_text_buffer_set_text(_arg0, _arg1, _arg2)
	runtime.KeepAlive(buffer)
	runtime.KeepAlive(text)
	runtime.KeepAlive(len)
}

// Undo undoes the last undoable action on the buffer, if there is one.
func (buffer *TextBuffer) Undo() {
	var _arg0 *C.GtkTextBuffer // out

	_arg0 = (*C.GtkTextBuffer)(unsafe.Pointer(buffer.Native()))

	C.gtk_text_buffer_undo(_arg0)
	runtime.KeepAlive(buffer)
}
