// Code generated by girgen. DO NOT EDIT.

package gtk

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/gdk/v4"
	"github.com/diamondburned/gotk4/pkg/pango"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: gtk4
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <gtk/gtk.h>
// gboolean _gotk4_gtk4_TextCharPredicate(gunichar, gpointer);
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.gtk_text_search_flags_get_type()), F: marshalTextSearchFlags},
		{T: externglib.Type(C.gtk_text_iter_get_type()), F: marshalTextIter},
	})
}

// TextSearchFlags flags affecting how a search is done.
//
// If neither GTK_TEXT_SEARCH_VISIBLE_ONLY nor GTK_TEXT_SEARCH_TEXT_ONLY are
// enabled, the match must be exact; the special 0xFFFC character will match
// embedded paintables or child widgets.
type TextSearchFlags int

const (
	// TextSearchFlagsVisibleOnly: search only visible data. A search match may
	// have invisible text interspersed.
	TextSearchFlagsVisibleOnly TextSearchFlags = 0b1
	// TextSearchFlagsTextOnly: search only text. A match may have paintables or
	// child widgets mixed inside the matched range.
	TextSearchFlagsTextOnly TextSearchFlags = 0b10
	// TextSearchFlagsCaseInsensitive: text will be matched regardless of what
	// case it is in.
	TextSearchFlagsCaseInsensitive TextSearchFlags = 0b100
)

func marshalTextSearchFlags(p uintptr) (interface{}, error) {
	return TextSearchFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TextCharPredicate: predicate function used by
// gtk_text_iter_forward_find_char() and gtk_text_iter_backward_find_char().
type TextCharPredicate func(ch uint32) (ok bool)

//export _gotk4_gtk4_TextCharPredicate
func _gotk4_gtk4_TextCharPredicate(arg0 C.gunichar, arg1 C.gpointer) (cret C.gboolean) {
	v := gbox.Get(uintptr(arg1))
	if v == nil {
		panic(`callback not found`)
	}

	var ch uint32 // out

	ch = uint32(arg0)

	fn := v.(TextCharPredicate)
	ok := fn(ch)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// TextIter: iterator for the contents of a GtkTextBuffer.
//
// You may wish to begin by reading the text widget conceptual overview
// (section-text-widget.html), which gives an overview of all the objects and
// data types related to the text widget and how they work together.
type TextIter struct {
	native C.GtkTextIter
}

func marshalTextIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return (*TextIter)(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (t *TextIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Assign assigns the value of other to iter.
//
// This function is not useful in applications, because iterators can be
// assigned with GtkTextIter i = j;.
//
// The function is used by language bindings.
func (iter *TextIter) Assign(other *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(other))

	C.gtk_text_iter_assign(_arg0, _arg1)
}

// BackwardChar moves backward by one character offset.
//
// Returns TRUE if movement was possible; if iter was the first in the buffer
// (character offset 0), this function returns FALSE for convenience when
// writing loops.
func (iter *TextIter) BackwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_char(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardChars moves count characters backward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// FALSE is returned. If count is 0, the function does nothing and returns
// FALSE.
func (iter *TextIter) BackwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_chars(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPosition: like gtk_text_iter_forward_cursor_position(), but
// moves backward.
func (iter *TextIter) BackwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardCursorPositions moves up to count cursor positions.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
func (iter *TextIter) BackwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardFindChar: same as gtk_text_iter_forward_find_char(), but goes
// backward from iter.
func (iter *TextIter) BackwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var _arg0 *C.GtkTextIter         // out
	var _arg1 C.GtkTextCharPredicate // out
	var _arg2 C.gpointer
	var _arg3 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TextCharPredicate)
	_arg2 = C.gpointer(gbox.Assign(pred))
	defer gbox.Delete(uintptr(_arg2))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(limit))

	_cret = C.gtk_text_iter_backward_find_char(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLine moves iter to the start of the previous line.
//
// Returns TRUE if iter could be moved; i.e. if iter was at character offset 0,
// this function returns FALSE. Therefore, if iter was already on line 0, but
// not at the start of the line, iter is snapped to the start of the line and
// the function returns TRUE. (Note that this implies that in a loop calling
// this function, the line number may not change on every iteration, if your
// first iteration is on line 0.)
func (iter *TextIter) BackwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardLines moves count lines backward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves forward by 0 - count lines.
func (iter *TextIter) BackwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSearch: same as gtk_text_iter_forward_search(), but moves backward.
//
// match_end will never be set to a GtkTextIter located after iter, even if
// there is a possible match_start before or at iter.
func (iter *TextIter) BackwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.char              // out
	var _arg2 C.GtkTextSearchFlags // out
	var _matchStart TextIter
	var _matchEnd TextIter
	var _arg5 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	_arg2 = C.GtkTextSearchFlags(flags)
	_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit))

	_cret = C.gtk_text_iter_backward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// BackwardSentenceStart moves backward to the previous sentence start.
//
// If iter is already at the start of a sentence, moves backward to the next
// one.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (iter *TextIter) BackwardSentenceStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_sentence_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardSentenceStarts calls gtk_text_iter_backward_sentence_start() up to
// count times.
//
// If count is negative, moves forward instead of backward.
func (iter *TextIter) BackwardSentenceStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_sentence_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardToTagToggle moves backward to the next toggle (on or off) of the tag,
// or to the next toggle of any tag if tag is NULL.
//
// If no matching tag toggles are found, returns FALSE, otherwise TRUE. Does not
// return toggles located at iter, only toggles before iter. Sets iter to the
// location of the toggle, or the start of the buffer if no toggle is found.
func (iter *TextIter) BackwardToTagToggle(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_backward_to_tag_toggle(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPosition moves iter forward to the previous visible
// cursor position.
//
// See gtk.TextIter.BackwardCursorPosition() for details.
func (iter *TextIter) BackwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_visible_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleCursorPositions moves up to count visible cursor positions.
//
// See gtk.TextIter.BackwardCursorPosition() for details.
func (iter *TextIter) BackwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_visible_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLine moves iter to the start of the previous visible line.
//
// Returns TRUE if iter could be moved; i.e. if iter was at character offset 0,
// this function returns FALSE. Therefore if iter was already on line 0, but not
// at the start of the line, iter is snapped to the start of the line and the
// function returns TRUE. (Note that this implies that in a loop calling this
// function, the line number may not change on every iteration, if your first
// iteration is on line 0.)
func (iter *TextIter) BackwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_visible_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleLines moves count visible lines backward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves forward by 0 - count lines.
func (iter *TextIter) BackwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_visible_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStart moves backward to the previous visible word start.
//
// If iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (iter *TextIter) BackwardVisibleWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_visible_word_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardVisibleWordStarts calls gtk_text_iter_backward_visible_word_start()
// up to count times.
func (iter *TextIter) BackwardVisibleWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_visible_word_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStart moves backward to the previous word start.
//
// If iter is currently on a word start, moves backward to the next one after
// that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language
func (iter *TextIter) BackwardWordStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_backward_word_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// BackwardWordStarts calls gtk_text_iter_backward_word_start() up to count
// times.
func (iter *TextIter) BackwardWordStarts(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_backward_word_starts(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// CanInsert: considering the default editability of the buffer, and tags that
// affect editability, determines whether text inserted at iter would be
// editable.
//
// If text inserted at iter would be editable then the user should be allowed to
// insert text at iter. gtk.TextBuffer.InsertInteractive() uses this function to
// decide whether insertions are allowed at a given position.
func (iter *TextIter) CanInsert(defaultEditability bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	if defaultEditability {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_can_insert(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Compare: qsort()-style function that returns negative if lhs is less than
// rhs, positive if lhs is greater than rhs, and 0 if they’re equal.
//
// Ordering is in character offset order, i.e. the first character in the buffer
// is less than the second character in the buffer.
func (lhs *TextIter) Compare(rhs *TextIter) int {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(lhs))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs))

	_cret = C.gtk_text_iter_compare(_arg0, _arg1)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Copy creates a dynamically-allocated copy of an iterator.
//
// This function is not useful in applications, because iterators can be copied
// with a simple assignment (GtkTextIter i = j;).
//
// The function is used by language bindings.
func (iter *TextIter) Copy() *TextIter {
	var _arg0 *C.GtkTextIter // out
	var _cret *C.GtkTextIter // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_copy(_arg0)

	var _textIter *TextIter // out

	_textIter = (*TextIter)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_textIter, func(v *TextIter) {
		C.gtk_text_iter_free((*C.GtkTextIter)(unsafe.Pointer(v)))
	})

	return _textIter
}

// Editable returns whether the character at iter is within an editable region
// of text.
//
// Non-editable text is “locked” and can’t be changed by the user via TextView.
// If no tags applied to this text affect editability, default_setting will be
// returned.
//
// You don’t want to use this function to decide whether text can be inserted at
// iter, because for insertion you don’t want to know whether the char at iter
// is inside an editable range, you want to know whether a new character
// inserted at iter would be inside an editable range. Use
// gtk.TextIter.CanInsert() to handle this case.
func (iter *TextIter) Editable(defaultSetting bool) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	if defaultSetting {
		_arg1 = C.TRUE
	}

	_cret = C.gtk_text_iter_editable(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsLine returns TRUE if iter points to the start of the paragraph delimiter
// characters for a line.
//
// Delimiters will be either a newline, a carriage return, a carriage return
// followed by a newline, or a Unicode paragraph separator character.
//
// Note that an iterator pointing to the \n of a \r\n pair will not be counted
// as the end of a line, the line ends before the \r. The end iterator is
// considered to be at the end of a line, even though there are no paragraph
// delimiter chars there.
func (iter *TextIter) EndsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_ends_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsSentence determines whether iter ends a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (iter *TextIter) EndsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_ends_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsTag returns TRUE if tag is toggled off at exactly this point.
//
// If tag is NULL, returns TRUE if any tag is toggled off at this point.
//
// Note that if this function returns TRUE, it means that iter is at the end of
// the tagged range, but that the character at iter is outside the tagged range.
// In other words, unlike gtk.TextIter.StartsTag(), if this function returns
// TRUE, gtk.TextIter.HasTag() will return FALSE for the same parameters.
func (iter *TextIter) EndsTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_ends_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// EndsWord determines whether iter ends a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (iter *TextIter) EndsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_ends_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Equal tests whether two iterators are equal, using the fastest possible
// mechanism.
//
// This function is very fast; you can expect it to perform better than e.g.
// getting the character offset for each iterator and comparing the offsets
// yourself. Also, it’s a bit faster than gtk.TextIter.Compare().
func (lhs *TextIter) Equal(rhs *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(lhs))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(rhs))

	_cret = C.gtk_text_iter_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChar moves iter forward by one character offset.
//
// Note that images embedded in the buffer occupy 1 character slot, so this
// function may actually move onto an image instead of a character, if you have
// images in your buffer. If iter is the end iterator or one character before
// it, iter will now point at the end iterator, and this function returns FALSE
// for convenience when writing loops.
func (iter *TextIter) ForwardChar() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_char(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardChars moves count characters if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the new position of iter is different from
// its original position, and dereferenceable (the last iterator in the buffer
// is not dereferenceable). If count is 0, the function does nothing and returns
// FALSE.
func (iter *TextIter) ForwardChars(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_chars(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPosition moves iter forward by a single cursor position.
//
// Cursor positions are (unsurprisingly) positions where the cursor can appear.
// Perhaps surprisingly, there may not be a cursor position between all
// characters. The most common example for European languages would be a
// carriage return/newline sequence.
//
// For some Unicode characters, the equivalent of say the letter “a” with an
// accent mark will be represented as two characters, first the letter then a
// "combining mark" that causes the accent to be rendered; so the cursor can’t
// go between those two characters.
//
// See also the pango.LogAttr struct and the pango.Break() function.
func (iter *TextIter) ForwardCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardCursorPositions moves up to count cursor positions.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
func (iter *TextIter) ForwardCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardFindChar advances iter, calling pred on each character.
//
// If pred returns TRUE, returns TRUE and stops scanning. If pred never returns
// TRUE, iter is set to limit if limit is non-NULL, otherwise to the end
// iterator.
func (iter *TextIter) ForwardFindChar(pred TextCharPredicate, limit *TextIter) bool {
	var _arg0 *C.GtkTextIter         // out
	var _arg1 C.GtkTextCharPredicate // out
	var _arg2 C.gpointer
	var _arg3 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*[0]byte)(C._gotk4_gtk4_TextCharPredicate)
	_arg2 = C.gpointer(gbox.Assign(pred))
	defer gbox.Delete(uintptr(_arg2))
	_arg3 = (*C.GtkTextIter)(unsafe.Pointer(limit))

	_cret = C.gtk_text_iter_forward_find_char(_arg0, _arg1, _arg2, _arg3)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLine moves iter to the start of the next line.
//
// If the iter is already on the last line of the buffer, moves the iter to the
// end of the current line. If after the operation, the iter is at the end of
// the buffer and not dereferenceable, returns FALSE. Otherwise, returns TRUE.
func (iter *TextIter) ForwardLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardLines moves count lines forward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves backward by 0 - count lines.
func (iter *TextIter) ForwardLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSearch searches forward for str.
//
// Any match is returned by setting match_start to the first character of the
// match and match_end to the first character after the match. The search will
// not continue past limit. Note that a search is a linear or O(n) operation, so
// you may wish to use limit to avoid locking up your UI on large buffers.
//
// match_start will never be set to a GtkTextIter located before iter, even if
// there is a possible match_end after or at iter.
func (iter *TextIter) ForwardSearch(str string, flags TextSearchFlags, limit *TextIter) (matchStart TextIter, matchEnd TextIter, ok bool) {
	var _arg0 *C.GtkTextIter       // out
	var _arg1 *C.char              // out
	var _arg2 C.GtkTextSearchFlags // out
	var _matchStart TextIter
	var _matchEnd TextIter
	var _arg5 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(str)))
	_arg2 = C.GtkTextSearchFlags(flags)
	_arg5 = (*C.GtkTextIter)(unsafe.Pointer(limit))

	_cret = C.gtk_text_iter_forward_search(_arg0, _arg1, _arg2, (*C.GtkTextIter)(unsafe.Pointer(&_matchStart)), (*C.GtkTextIter)(unsafe.Pointer(&_matchEnd)), _arg5)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _matchStart, _matchEnd, _ok
}

// ForwardSentenceEnd moves forward to the next sentence end.
//
// If iter is at the end of a sentence, moves to the next end of sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (iter *TextIter) ForwardSentenceEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_sentence_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardSentenceEnds calls gtk_text_iter_forward_sentence_end() count times.
//
// If count is negative, moves backward instead of forward.
func (iter *TextIter) ForwardSentenceEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_sentence_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToEnd moves iter forward to the “end iterator”, which points one past
// the last valid character in the buffer.
//
// gtk_text_iter_get_char() called on the end iterator returns 0, which is
// convenient for writing loops.
func (iter *TextIter) ForwardToEnd() {
	var _arg0 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_iter_forward_to_end(_arg0)
}

// ForwardToLineEnd moves the iterator to point to the paragraph delimiter
// characters.
//
// The possible characters are either a newline, a carriage return, a carriage
// return/newline in sequence, or the Unicode paragraph separator character.
//
// If the iterator is already at the paragraph delimiter characters, moves to
// the paragraph delimiter characters for the next line. If iter is on the last
// line in the buffer, which does not end in paragraph delimiters, moves to the
// end iterator (end of the last line), and returns FALSE.
func (iter *TextIter) ForwardToLineEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_to_line_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardToTagToggle moves forward to the next toggle (on or off) of the tag,
// or to the next toggle of any tag if tag is NULL.
//
// If no matching tag toggles are found, returns FALSE, otherwise TRUE. Does not
// return toggles located at iter, only toggles after iter. Sets iter to the
// location of the toggle, or to the end of the buffer if no toggle is found.
func (iter *TextIter) ForwardToTagToggle(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_forward_to_tag_toggle(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPosition moves iter forward to the next visible cursor
// position.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
func (iter *TextIter) ForwardVisibleCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_visible_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleCursorPositions moves up to count visible cursor positions.
//
// See gtk.TextIter.ForwardCursorPosition() for details.
func (iter *TextIter) ForwardVisibleCursorPositions(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_visible_cursor_positions(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLine moves iter to the start of the next visible line.
//
// Returns TRUE if there was a next line to move to, and FALSE if iter was
// simply moved to the end of the buffer and is now not dereferenceable, or if
// iter was already at the end of the buffer.
func (iter *TextIter) ForwardVisibleLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_visible_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleLines moves count visible lines forward, if possible.
//
// If count would move past the start or end of the buffer, moves to the start
// or end of the buffer.
//
// The return value indicates whether the iterator moved onto a dereferenceable
// position; if the iterator didn’t move, or moved onto the end iterator, then
// FALSE is returned. If count is 0, the function does nothing and returns
// FALSE. If count is negative, moves backward by 0 - count lines.
func (iter *TextIter) ForwardVisibleLines(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_visible_lines(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnd moves forward to the next visible word end.
//
// If iter is currently on a word end, moves forward to the next one after that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language
func (iter *TextIter) ForwardVisibleWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_visible_word_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardVisibleWordEnds calls gtk_text_iter_forward_visible_word_end() up to
// count times.
func (iter *TextIter) ForwardVisibleWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_visible_word_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnd moves forward to the next word end.
//
// If iter is currently on a word end, moves forward to the next one after that.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (iter *TextIter) ForwardWordEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_forward_word_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ForwardWordEnds calls gtk_text_iter_forward_word_end() up to count times.
func (iter *TextIter) ForwardWordEnds(count int) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(count)

	_cret = C.gtk_text_iter_forward_word_ends(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free: free an iterator allocated on the heap.
//
// This function is intended for use in language bindings, and is not especially
// useful for applications, because iterators can simply be allocated on the
// stack.
func (iter *TextIter) free() {
	var _arg0 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	C.gtk_text_iter_free(_arg0)
}

// Buffer returns the GtkTextBuffer this iterator is associated with.
func (iter *TextIter) Buffer() *TextBuffer {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.GtkTextBuffer // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_buffer(_arg0)

	var _textBuffer *TextBuffer // out

	_textBuffer = wrapTextBuffer(externglib.Take(unsafe.Pointer(_cret)))

	return _textBuffer
}

// BytesInLine returns the number of bytes in the line containing iter,
// including the paragraph delimiters.
func (iter *TextIter) BytesInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_bytes_in_line(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Char: unicode character at this iterator is returned.
//
// Equivalent to operator* on a C++ iterator. If the element at this iterator is
// a non-character element, such as an image embedded in the buffer, the Unicode
// “unknown” character 0xFFFC is returned. If invoked on the end iterator, zero
// is returned; zero is not a valid Unicode character.
//
// So you can write a loop which ends when this function returns 0.
func (iter *TextIter) Char() uint32 {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gunichar     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_char(_arg0)

	var _gunichar uint32 // out

	_gunichar = uint32(_cret)

	return _gunichar
}

// CharsInLine returns the number of characters in the line containing iter,
// including the paragraph delimiters.
func (iter *TextIter) CharsInLine() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_chars_in_line(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// ChildAnchor: if the location at iter contains a child anchor, the anchor is
// returned.
//
// Otherwise, NULL is returned.
func (iter *TextIter) ChildAnchor() *TextChildAnchor {
	var _arg0 *C.GtkTextIter        // out
	var _cret *C.GtkTextChildAnchor // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_child_anchor(_arg0)

	var _textChildAnchor *TextChildAnchor // out

	_textChildAnchor = wrapTextChildAnchor(externglib.Take(unsafe.Pointer(_cret)))

	return _textChildAnchor
}

// Language returns the language in effect at iter.
//
// If no tags affecting language apply to iter, the return value is identical to
// that of gtk.GetDefaultLanguage().
func (iter *TextIter) Language() *pango.Language {
	var _arg0 *C.GtkTextIter   // out
	var _cret *C.PangoLanguage // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_language(_arg0)

	var _language *pango.Language // out

	_language = (*pango.Language)(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_language, func(v *pango.Language) {
		C.free(unsafe.Pointer(v))
	})

	return _language
}

// Line returns the line number containing the iterator.
//
// Lines in a GtkTextBuffer are numbered beginning with 0 for the first line in
// the buffer.
func (iter *TextIter) Line() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_line(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineIndex returns the byte index of the iterator, counting from the start of
// a newline-terminated line.
//
// Remember that GtkTextBuffer encodes text in UTF-8, and that characters can
// require a variable number of bytes to represent.
func (iter *TextIter) LineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_line_index(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// LineOffset returns the character offset of the iterator, counting from the
// start of a newline-terminated line.
//
// The first character on the line has offset 0.
func (iter *TextIter) LineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_line_offset(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Offset returns the character offset of an iterator.
//
// Each character in a GtkTextBuffer has an offset, starting with 0 for the
// first character in the buffer. Use gtk,textbuffer.GetIterAtOffset to convert
// an offset back into an iterator.
func (iter *TextIter) Offset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_offset(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Paintable: if the element at iter is a paintable, the paintable is returned.
//
// Otherwise, NULL is returned.
func (iter *TextIter) Paintable() *gdk.Paintable {
	var _arg0 *C.GtkTextIter  // out
	var _cret *C.GdkPaintable // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_paintable(_arg0)

	var _paintable *gdk.Paintable // out

	{
		obj := externglib.Take(unsafe.Pointer(_cret))
		_paintable = &gdk.Paintable{
			Object: obj,
		}
	}

	return _paintable
}

// Slice returns the text in the given range.
//
// A “slice” is an array of characters encoded in UTF-8 format, including the
// Unicode “unknown” character 0xFFFC for iterable non-character elements in the
// buffer, such as images. Because images are encoded in the slice, byte and
// character offsets in the returned array will correspond to byte offsets in
// the text buffer. Note that 0xFFFC can occur in normal text as well, so it is
// not a reliable indicator that a paintable or widget is in the buffer.
func (start *TextIter) Slice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(start))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end))

	_cret = C.gtk_text_iter_get_slice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// Text returns text in the given range.
//
// If the range contains non-text elements such as images, the character and
// byte offsets in the returned string will not correspond to character and byte
// offsets in the buffer. If you want offsets to correspond, see
// gtk.TextIter.GetSlice().
func (start *TextIter) Text(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(start))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end))

	_cret = C.gtk_text_iter_get_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleLineIndex returns the number of bytes from the start of the line to
// the given iter, not counting bytes that are invisible due to tags with the
// “invisible” flag toggled on.
func (iter *TextIter) VisibleLineIndex() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_visible_line_index(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VisibleLineOffset returns the offset in characters from the start of the line
// to the given iter, not counting characters that are invisible due to tags
// with the “invisible” flag toggled on.
func (iter *TextIter) VisibleLineOffset() int {
	var _arg0 *C.GtkTextIter // out
	var _cret C.int          // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_get_visible_line_offset(_arg0)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// VisibleSlice returns visible text in the given range.
//
// Like gtk.TextIter.GetSlice(), but invisible text is not included. Invisible
// text is usually invisible because a GtkTextTag with the “invisible” attribute
// turned on has been applied to it.
func (start *TextIter) VisibleSlice(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(start))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end))

	_cret = C.gtk_text_iter_get_visible_slice(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// VisibleText returns visible text in the given range.
//
// Like gtk.TextIter.GetText(), but invisible text is not included. Invisible
// text is usually invisible because a GtkTextTag with the “invisible” attribute
// turned on has been applied to it.
func (start *TextIter) VisibleText(end *TextIter) string {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _cret *C.char        // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(start))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(end))

	_cret = C.gtk_text_iter_get_visible_text(_arg0, _arg1)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// HasTag returns TRUE if iter points to a character that is part of a range
// tagged with tag.
//
// See also gtk.TextIter.StartsTag() and gtk.TextIter.EndsTag().
func (iter *TextIter) HasTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_has_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InRange checks whether iter falls in the range [start, end).
//
// start and end must be in ascending order.
func (iter *TextIter) InRange(start *TextIter, end *TextIter) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out
	var _arg2 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(start))
	_arg2 = (*C.GtkTextIter)(unsafe.Pointer(end))

	_cret = C.gtk_text_iter_in_range(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideSentence determines whether iter is inside a sentence (as opposed to in
// between two sentences, e.g. after a period and before the first letter of the
// next sentence).
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (iter *TextIter) InsideSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_inside_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InsideWord determines whether the character pointed by iter is part of a
// natural-language word (as opposed to say inside some whitespace).
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
//
// Note that if gtk.TextIter.StartsWord() returns TRUE, then this function
// returns TRUE too, since iter points to the first character of the word.
func (iter *TextIter) InsideWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_inside_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsCursorPosition: determine if iter is at a cursor position.
//
// See gtk.TextIter.ForwardCursorPosition() or pango.LogAttr or pango.Break()
// for details on what a cursor position is.
func (iter *TextIter) IsCursorPosition() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_is_cursor_position(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsEnd returns TRUE if iter is the end iterator.
//
// This means it is one past the last dereferenceable iterator in the buffer.
// gtk_text_iter_is_end() is the most efficient way to check whether an iterator
// is the end iterator.
func (iter *TextIter) IsEnd() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_is_end(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsStart returns TRUE if iter is the first iterator in the buffer.
func (iter *TextIter) IsStart() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_is_start(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Order swaps the value of first and second if second comes before first in the
// buffer.
//
// That is, ensures that first and second are in sequence. Most text buffer
// functions that take a range call this automatically on your behalf, so
// there’s no real reason to call it yourself in those cases. There are some
// exceptions, such as gtk.TextIter.InRange(), that expect a pre-sorted range.
func (first *TextIter) Order(second *TextIter) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextIter // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(first))
	_arg1 = (*C.GtkTextIter)(unsafe.Pointer(second))

	C.gtk_text_iter_order(_arg0, _arg1)
}

// SetLine moves iterator iter to the start of the line line_number.
//
// If line_number is negative or larger than or equal to the number of lines in
// the buffer, moves iter to the start of the last line in the buffer.
func (iter *TextIter) SetLine(lineNumber int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(lineNumber)

	C.gtk_text_iter_set_line(_arg0, _arg1)
}

// SetLineIndex: same as gtk_text_iter_set_line_offset(), but works with a byte
// index. The given byte index must be at the start of a character, it can’t be
// in the middle of a UTF-8 encoded character.
func (iter *TextIter) SetLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(byteOnLine)

	C.gtk_text_iter_set_line_index(_arg0, _arg1)
}

// SetLineOffset moves iter within a line, to a new character (not byte) offset.
//
// The given character offset must be less than or equal to the number of
// characters in the line; if equal, iter moves to the start of the next line.
// See gtk.TextIter.SetLineIndex() if you have a byte index rather than a
// character offset.
func (iter *TextIter) SetLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(charOnLine)

	C.gtk_text_iter_set_line_offset(_arg0, _arg1)
}

// SetOffset sets iter to point to char_offset.
//
// char_offset counts from the start of the entire text buffer, starting with 0.
func (iter *TextIter) SetOffset(charOffset int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(charOffset)

	C.gtk_text_iter_set_offset(_arg0, _arg1)
}

// SetVisibleLineIndex: like gtk_text_iter_set_line_index(), but the index is in
// visible bytes, i.e. text with a tag making it invisible is not counted in the
// index.
func (iter *TextIter) SetVisibleLineIndex(byteOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(byteOnLine)

	C.gtk_text_iter_set_visible_line_index(_arg0, _arg1)
}

// SetVisibleLineOffset: like gtk_text_iter_set_line_offset(), but the offset is
// in visible characters, i.e. text with a tag making it invisible is not
// counted in the offset.
func (iter *TextIter) SetVisibleLineOffset(charOnLine int) {
	var _arg0 *C.GtkTextIter // out
	var _arg1 C.int          // out

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = C.int(charOnLine)

	C.gtk_text_iter_set_visible_line_offset(_arg0, _arg1)
}

// StartsLine returns TRUE if iter begins a paragraph.
//
// This is the case if gtk.TextIter.GetLineOffset() would return 0. However this
// function is potentially more efficient than gtk.TextIter.GetLineOffset(),
// because it doesn’t have to compute the offset, it just has to see whether
// it’s 0.
func (iter *TextIter) StartsLine() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_starts_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsSentence determines whether iter begins a sentence.
//
// Sentence boundaries are determined by Pango and should be correct for nearly
// any language.
func (iter *TextIter) StartsSentence() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_starts_sentence(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsTag returns TRUE if tag is toggled on at exactly this point.
//
// If tag is NULL, returns TRUE if any tag is toggled on at this point.
//
// Note that if this function returns TRUE, it means that iter is at the
// beginning of the tagged range, and that the character at iter is inside the
// tagged range. In other words, unlike gtk.TextIter.EndsTag(), if this function
// returns TRUE, [methodGtk.TextIter.has_tag will also return TRUE for the same
// parameters.
func (iter *TextIter) StartsTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_starts_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// StartsWord determines whether iter begins a natural-language word.
//
// Word breaks are determined by Pango and should be correct for nearly any
// language.
func (iter *TextIter) StartsWord() bool {
	var _arg0 *C.GtkTextIter // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))

	_cret = C.gtk_text_iter_starts_word(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TogglesTag gets whether a range with tag applied to it begins or ends at
// iter.
//
// This is equivalent to (gtk_text_iter_starts_tag() ||
// gtk_text_iter_ends_tag())
func (iter *TextIter) TogglesTag(tag *TextTag) bool {
	var _arg0 *C.GtkTextIter // out
	var _arg1 *C.GtkTextTag  // out
	var _cret C.gboolean     // in

	_arg0 = (*C.GtkTextIter)(unsafe.Pointer(iter))
	_arg1 = (*C.GtkTextTag)(unsafe.Pointer(tag.Native()))

	_cret = C.gtk_text_iter_toggles_tag(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}
