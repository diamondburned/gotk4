// Code generated by girgen. DO NOT EDIT.

package pango

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/core/gerror"
	"github.com/diamondburned/gotk4/core/gextras"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
	externglib "github.com/gotk3/gotk3/glib"
)

// #cgo pkg-config: pango
// #cgo CFLAGS: -Wno-deprecated-declarations
// #include <glib-object.h>
// #include <pango/pango.h>
import "C"

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: externglib.Type(C.pango_alignment_get_type()), F: marshalAlignment},
		{T: externglib.Type(C.pango_attr_type_get_type()), F: marshalAttrType},
		{T: externglib.Type(C.pango_bidi_type_get_type()), F: marshalBidiType},
		{T: externglib.Type(C.pango_coverage_level_get_type()), F: marshalCoverageLevel},
		{T: externglib.Type(C.pango_direction_get_type()), F: marshalDirection},
		{T: externglib.Type(C.pango_ellipsize_mode_get_type()), F: marshalEllipsizeMode},
		{T: externglib.Type(C.pango_gravity_get_type()), F: marshalGravity},
		{T: externglib.Type(C.pango_gravity_hint_get_type()), F: marshalGravityHint},
		{T: externglib.Type(C.pango_overline_get_type()), F: marshalOverline},
		{T: externglib.Type(C.pango_render_part_get_type()), F: marshalRenderPart},
		{T: externglib.Type(C.pango_script_get_type()), F: marshalScript},
		{T: externglib.Type(C.pango_stretch_get_type()), F: marshalStretch},
		{T: externglib.Type(C.pango_style_get_type()), F: marshalStyle},
		{T: externglib.Type(C.pango_tab_align_get_type()), F: marshalTabAlign},
		{T: externglib.Type(C.pango_underline_get_type()), F: marshalUnderline},
		{T: externglib.Type(C.pango_variant_get_type()), F: marshalVariant},
		{T: externglib.Type(C.pango_weight_get_type()), F: marshalWeight},
		{T: externglib.Type(C.pango_wrap_mode_get_type()), F: marshalWrapMode},
		{T: externglib.Type(C.pango_font_mask_get_type()), F: marshalFontMask},
		{T: externglib.Type(C.pango_shape_flags_get_type()), F: marshalShapeFlags},
		{T: externglib.Type(C.pango_show_flags_get_type()), F: marshalShowFlags},
		{T: externglib.Type(C.pango_context_get_type()), F: marshalContext},
		{T: externglib.Type(C.pango_coverage_get_type()), F: marshalCoverage},
		{T: externglib.Type(C.pango_font_get_type()), F: marshalFont},
		{T: externglib.Type(C.pango_font_face_get_type()), F: marshalFontFace},
		{T: externglib.Type(C.pango_font_family_get_type()), F: marshalFontFamily},
		{T: externglib.Type(C.pango_font_map_get_type()), F: marshalFontMap},
		{T: externglib.Type(C.pango_fontset_get_type()), F: marshalFontset},
		{T: externglib.Type(C.pango_fontset_simple_get_type()), F: marshalFontsetSimple},
		{T: externglib.Type(C.pango_layout_get_type()), F: marshalLayout},
		{T: externglib.Type(C.pango_renderer_get_type()), F: marshalRenderer},
		{T: externglib.Type(C.pango_attr_iterator_get_type()), F: marshalAttrIterator},
		{T: externglib.Type(C.pango_attr_list_get_type()), F: marshalAttrList},
		{T: externglib.Type(C.pango_attribute_get_type()), F: marshalAttribute},
		{T: externglib.Type(C.pango_color_get_type()), F: marshalColor},
		{T: externglib.Type(C.pango_font_description_get_type()), F: marshalFontDescription},
		{T: externglib.Type(C.pango_font_metrics_get_type()), F: marshalFontMetrics},
		{T: externglib.Type(C.pango_glyph_item_get_type()), F: marshalGlyphItem},
		{T: externglib.Type(C.pango_glyph_item_iter_get_type()), F: marshalGlyphItemIter},
		{T: externglib.Type(C.pango_glyph_string_get_type()), F: marshalGlyphString},
		{T: externglib.Type(C.pango_item_get_type()), F: marshalItem},
		{T: externglib.Type(C.pango_language_get_type()), F: marshalLanguage},
		{T: externglib.Type(C.pango_layout_iter_get_type()), F: marshalLayoutIter},
		{T: externglib.Type(C.pango_matrix_get_type()), F: marshalMatrix},
		{T: externglib.Type(C.pango_script_iter_get_type()), F: marshalScriptIter},
		{T: externglib.Type(C.pango_tab_array_get_type()), F: marshalTabArray},
	})
}

// Glyph: a `PangoGlyph` represents a single glyph in the output form of a
// string.
type Glyph = uint32

// GlyphUnit: the `PangoGlyphUnit` type is used to store dimensions within
// Pango.
//
// Dimensions are stored in 1/PANGO_SCALE of a device unit. (A device unit might
// be a pixel for screen display, or a point on a printer.) PANGO_SCALE is
// currently 1024, and may change in the future (unlikely though), but you
// should not depend on its exact value. The PANGO_PIXELS() macro can be used to
// convert from glyph units into device units with correct rounding.
type GlyphUnit = int32

// LayoutRun: a `PangoLayoutRun` represents a single run within a
// `PangoLayoutLine`.
//
// It is simply an alternate name for [struct@Pango.GlyphItem]. See the
// [struct@Pango.GlyphItem] docs for details on the fields.
type LayoutRun = GlyphItem

// Alignment: `PangoAlignment` describes how to align the lines of a
// `PangoLayout` within the available space.
//
// If the `PangoLayout` is set to justify using
// [method@Pango.Layout.set_justify], this only has effect for partial lines.
type Alignment int

const (
	// AlignmentLeft: put all available space on the right
	AlignmentLeft Alignment = 0
	// AlignmentCenter: center the line within the available space
	AlignmentCenter Alignment = 1
	// AlignmentRight: put all available space on the left
	AlignmentRight Alignment = 2
)

func marshalAlignment(p uintptr) (interface{}, error) {
	return Alignment(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// AttrType: the `PangoAttrType` distinguishes between different types of
// attributes.
//
// Along with the predefined values, it is possible to allocate additional
// values for custom attributes using [type_func@attr_type_register]. The
// predefined values are given below. The type of structure used to store the
// attribute is listed in parentheses after the description.
type AttrType int

const (
	// AttrTypeInvalid does not happen
	AttrTypeInvalid AttrType = 0
	// AttrTypeLanguage: language ([struct@Pango.AttrLanguage])
	AttrTypeLanguage AttrType = 1
	// AttrTypeFamily: font family name list ([struct@Pango.AttrString])
	AttrTypeFamily AttrType = 2
	// AttrTypeStyle: font slant style ([struct@Pango.AttrInt])
	AttrTypeStyle AttrType = 3
	// AttrTypeWeight: font weight ([struct@Pango.AttrInt])
	AttrTypeWeight AttrType = 4
	// AttrTypeVariant: font variant (normal or small caps)
	// ([struct@Pango.AttrInt])
	AttrTypeVariant AttrType = 5
	// AttrTypeStretch: font stretch ([struct@Pango.AttrInt])
	AttrTypeStretch AttrType = 6
	// AttrTypeSize: font size in points scaled by PANGO_SCALE
	// ([struct@Pango.AttrInt])
	AttrTypeSize AttrType = 7
	// AttrTypeFontDesc: font description ([struct@Pango.AttrFontDesc])
	AttrTypeFontDesc AttrType = 8
	// AttrTypeForeground: foreground color ([struct@Pango.AttrColor])
	AttrTypeForeground AttrType = 9
	// AttrTypeBackground: background color ([struct@Pango.AttrColor])
	AttrTypeBackground AttrType = 10
	// AttrTypeUnderline: whether the text has an underline
	// ([struct@Pango.AttrInt])
	AttrTypeUnderline AttrType = 11
	// AttrTypeStrikethrough: whether the text is struck-through
	// ([struct@Pango.AttrInt])
	AttrTypeStrikethrough AttrType = 12
	// AttrTypeRise: baseline displacement ([struct@Pango.AttrInt])
	AttrTypeRise AttrType = 13
	// AttrTypeShape: shape ([struct@Pango.AttrShape])
	AttrTypeShape AttrType = 14
	// AttrTypeScale: font size scale factor ([struct@Pango.AttrFloat])
	AttrTypeScale AttrType = 15
	// AttrTypeFallback: whether fallback is enabled ([struct@Pango.AttrInt])
	AttrTypeFallback AttrType = 16
	// AttrTypeLetterSpacing: letter spacing ([struct@PangoAttrInt])
	AttrTypeLetterSpacing AttrType = 17
	// AttrTypeUnderlineColor: underline color ([struct@Pango.AttrColor])
	AttrTypeUnderlineColor AttrType = 18
	// AttrTypeStrikethroughColor: strikethrough color
	// ([struct@Pango.AttrColor])
	AttrTypeStrikethroughColor AttrType = 19
	// AttrTypeAbsoluteSize: font size in pixels scaled by PANGO_SCALE
	// ([struct@Pango.AttrInt])
	AttrTypeAbsoluteSize AttrType = 20
	// AttrTypeGravity: base text gravity ([struct@Pango.AttrInt])
	AttrTypeGravity AttrType = 21
	// AttrTypeGravityHint: gravity hint ([struct@Pango.AttrInt])
	AttrTypeGravityHint AttrType = 22
	// AttrTypeFontFeatures: openType font features ([struct@Pango.AttrString]).
	// Since 1.38
	AttrTypeFontFeatures AttrType = 23
	// AttrTypeForegroundAlpha: foreground alpha ([struct@Pango.AttrInt]). Since
	// 1.38
	AttrTypeForegroundAlpha AttrType = 24
	// AttrTypeBackgroundAlpha: background alpha ([struct@Pango.AttrInt]). Since
	// 1.38
	AttrTypeBackgroundAlpha AttrType = 25
	// AttrTypeAllowBreaks: whether breaks are allowed ([struct@Pango.AttrInt]).
	// Since 1.44
	AttrTypeAllowBreaks AttrType = 26
	// AttrTypeShow: how to render invisible characters
	// ([struct@Pango.AttrInt]). Since 1.44
	AttrTypeShow AttrType = 27
	// AttrTypeInsertHyphens: whether to insert hyphens at intra-word line
	// breaks ([struct@Pango.AttrInt]). Since 1.44
	AttrTypeInsertHyphens AttrType = 28
	// AttrTypeOverline: whether the text has an overline
	// ([struct@Pango.AttrInt]). Since 1.46
	AttrTypeOverline AttrType = 29
	// AttrTypeOverlineColor: overline color ([struct@Pango.AttrColor]). Since
	// 1.46
	AttrTypeOverlineColor AttrType = 30
)

func marshalAttrType(p uintptr) (interface{}, error) {
	return AttrType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// BidiType: `PangoBidiType` represents the bidirectional character type of a
// Unicode character as specified by the <ulink
// url="http://www.unicode.org/reports/tr9/">Unicode bidirectional
// algorithm</ulink>.
type BidiType int

const (
	// BidiTypeL: left-to-Right
	BidiTypeL BidiType = 0
	// BidiTypeLre: left-to-Right Embedding
	BidiTypeLre BidiType = 1
	// BidiTypeLro: left-to-Right Override
	BidiTypeLro BidiType = 2
	// BidiTypeR: right-to-Left
	BidiTypeR BidiType = 3
	// BidiTypeAl: right-to-Left Arabic
	BidiTypeAl BidiType = 4
	// BidiTypeRle: right-to-Left Embedding
	BidiTypeRle BidiType = 5
	// BidiTypeRlo: right-to-Left Override
	BidiTypeRlo BidiType = 6
	// BidiTypePDF: pop Directional Format
	BidiTypePDF BidiType = 7
	// BidiTypeEn: european Number
	BidiTypeEn BidiType = 8
	// BidiTypeES: european Number Separator
	BidiTypeES BidiType = 9
	// BidiTypeEt: european Number Terminator
	BidiTypeEt BidiType = 10
	// BidiTypeAn: arabic Number
	BidiTypeAn BidiType = 11
	// BidiTypeCs: common Number Separator
	BidiTypeCs BidiType = 12
	// BidiTypeNsm: nonspacing Mark
	BidiTypeNsm BidiType = 13
	// BidiTypeBn: boundary Neutral
	BidiTypeBn BidiType = 14
	// BidiTypeB: paragraph Separator
	BidiTypeB BidiType = 15
	// BidiTypeS: segment Separator
	BidiTypeS BidiType = 16
	// BidiTypeWs: whitespace
	BidiTypeWs BidiType = 17
	// BidiTypeOn: other Neutrals
	BidiTypeOn BidiType = 18
)

func marshalBidiType(p uintptr) (interface{}, error) {
	return BidiType(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// CoverageLevel: `PangoCoverageLevel` is used to indicate how well a font can
// represent a particular Unicode character for a particular script.
//
// Since 1.44, only PANGO_COVERAGE_NONE and PANGO_COVERAGE_EXACT will be
// returned.
type CoverageLevel int

const (
	// CoverageLevelNone: the character is not representable with the font.
	CoverageLevelNone CoverageLevel = 0
	// CoverageLevelFallback: the character is represented in a way that may be
	// comprehensible but is not the correct graphical form. For instance, a
	// Hangul character represented as a a sequence of Jamos, or a Latin
	// transliteration of a Cyrillic word.
	CoverageLevelFallback CoverageLevel = 1
	// CoverageLevelApproximate: the character is represented as basically the
	// correct graphical form, but with a stylistic variant inappropriate for
	// the current script.
	CoverageLevelApproximate CoverageLevel = 2
	// CoverageLevelExact: the character is represented as the correct graphical
	// form.
	CoverageLevelExact CoverageLevel = 3
)

func marshalCoverageLevel(p uintptr) (interface{}, error) {
	return CoverageLevel(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Direction: `PangoDirection` represents a direction in the Unicode
// bidirectional algorithm.
//
// Not every value in this enumeration makes sense for every usage of
// `PangoDirection`; for example, the return value of [func@unichar_direction]
// and [func@find_base_dir] cannot be PANGO_DIRECTION_WEAK_LTR or
// PANGO_DIRECTION_WEAK_RTL, since every character is either neutral or has a
// strong direction; on the other hand PANGO_DIRECTION_NEUTRAL doesn't make
// sense to pass to [func@itemize_with_base_dir].
//
// The PANGO_DIRECTION_TTB_LTR, PANGO_DIRECTION_TTB_RTL values come from an
// earlier interpretation of this enumeration as the writing direction of a
// block of text and are no longer used; See `PangoGravity` for how vertical
// text is handled in Pango.
//
// If you are interested in text direction, you should really use fribidi
// directly. `PangoDirection` is only retained because it is used in some public
// apis.
type Direction int

const (
	// DirectionLTR: a strong left-to-right direction
	DirectionLTR Direction = 0
	// DirectionRTL: a strong right-to-left direction
	DirectionRTL Direction = 1
	// DirectionTtbLTR: deprecated value; treated the same as
	// PANGO_DIRECTION_RTL.
	DirectionTtbLTR Direction = 2
	// DirectionTtbRTL: deprecated value; treated the same as
	// PANGO_DIRECTION_LTR
	DirectionTtbRTL Direction = 3
	// DirectionWeakLTR: a weak left-to-right direction
	DirectionWeakLTR Direction = 4
	// DirectionWeakRTL: a weak right-to-left direction
	DirectionWeakRTL Direction = 5
	// DirectionNeutral: no direction specified
	DirectionNeutral Direction = 6
)

func marshalDirection(p uintptr) (interface{}, error) {
	return Direction(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// EllipsizeMode: `PangoEllipsizeMode` describes what sort of ellipsization
// should be applied to text.
//
// In the ellipsization process characters are removed from the text in order to
// make it fit to a given width and replaced with an ellipsis.
type EllipsizeMode int

const (
	// EllipsizeModeNone: no ellipsization
	EllipsizeModeNone EllipsizeMode = 0
	// EllipsizeModeStart: omit characters at the start of the text
	EllipsizeModeStart EllipsizeMode = 1
	// EllipsizeModeMiddle: omit characters in the middle of the text
	EllipsizeModeMiddle EllipsizeMode = 2
	// EllipsizeModeEnd: omit characters at the end of the text
	EllipsizeModeEnd EllipsizeMode = 3
)

func marshalEllipsizeMode(p uintptr) (interface{}, error) {
	return EllipsizeMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Gravity: `PangoGravity` represents the orientation of glyphs in a segment of
// text.
//
// This is useful when rendering vertical text layouts. In those situations, the
// layout is rotated using a non-identity [struct@Pango.Matrix], and then glyph
// orientation is controlled using `PangoGravity`.
//
// Not every value in this enumeration makes sense for every usage of
// `PangoGravity`; for example, PANGO_GRAVITY_AUTO only can be passed to
// [method@Pango.Context.set_base_gravity] and can only be returned by
// [method@Pango.Context.get_base_gravity].
//
// See also: [enum@Pango.GravityHint]
type Gravity int

const (
	// GravitySouth glyphs stand upright (default)
	GravitySouth Gravity = 0
	// GravityEast glyphs are rotated 90 degrees clockwise
	GravityEast Gravity = 1
	// GravityNorth glyphs are upside-down
	GravityNorth Gravity = 2
	// GravityWest glyphs are rotated 90 degrees counter-clockwise
	GravityWest Gravity = 3
	// GravityAuto: gravity is resolved from the context matrix
	GravityAuto Gravity = 4
)

func marshalGravity(p uintptr) (interface{}, error) {
	return Gravity(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// GravityHint: `PangoGravityHint` defines how horizontal scripts should behave
// in a vertical context.
//
// That is, English excerpts in a vertical paragraph for example.
//
// See also [enum@Pango.Gravity]
type GravityHint int

const (
	// GravityHintNatural scripts will take their natural gravity based on the
	// base gravity and the script. This is the default.
	GravityHintNatural GravityHint = 0
	// GravityHintStrong always use the base gravity set, regardless of the
	// script.
	GravityHintStrong GravityHint = 1
	// GravityHintLine: for scripts not in their natural direction (eg. Latin in
	// East gravity), choose per-script gravity such that every script respects
	// the line progression. This means, Latin and Arabic will take opposite
	// gravities and both flow top-to-bottom for example.
	GravityHintLine GravityHint = 2
)

func marshalGravityHint(p uintptr) (interface{}, error) {
	return GravityHint(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Overline: the `PangoOverline` enumeration is used to specify whether text
// should be overlined, and if so, the type of line.
type Overline int

const (
	// OverlineNone: no overline should be drawn
	OverlineNone Overline = 0
	// OverlineSingle: draw a single line above the ink extents of the text
	// being underlined.
	OverlineSingle Overline = 1
)

func marshalOverline(p uintptr) (interface{}, error) {
	return Overline(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// RenderPart defines different items to render for such purposes as setting
// colors.
type RenderPart int

const (
	// RenderPartForeground: the text itself
	RenderPartForeground RenderPart = 0
	// RenderPartBackground: the area behind the text
	RenderPartBackground RenderPart = 1
	// RenderPartUnderline: underlines
	RenderPartUnderline RenderPart = 2
	// RenderPartStrikethrough: strikethrough lines
	RenderPartStrikethrough RenderPart = 3
	// RenderPartOverline: overlines
	RenderPartOverline RenderPart = 4
)

func marshalRenderPart(p uintptr) (interface{}, error) {
	return RenderPart(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Script: the `PangoScript` enumeration identifies different writing systems.
//
// The values correspond to the names as defined in the Unicode standard. See
// Unicode Standard Annex 24: Script names
// (http://www.unicode.org/reports/tr24/)
//
// Note that this enumeration is deprecated and will not be updated to include
// values in newer versions of the Unicode standard. Applications should use the
// `GUnicodeScript` enumeration instead, whose values are interchangeable with
// `PangoScript`.
type Script int

const (
	// ScriptInvalidCode: a value never returned from pango_script_for_unichar()
	ScriptInvalidCode Script = -1
	// ScriptCommon: a character used by multiple different scripts
	ScriptCommon Script = 0
	// ScriptInherited: a mark glyph that takes its script from the base glyph
	// to which it is attached
	ScriptInherited Script = 1
	// ScriptArabic: arabic
	ScriptArabic Script = 2
	// ScriptArmenian: armenian
	ScriptArmenian Script = 3
	// ScriptBengali: bengali
	ScriptBengali Script = 4
	// ScriptBopomofo: bopomofo
	ScriptBopomofo Script = 5
	// ScriptCherokee: cherokee
	ScriptCherokee Script = 6
	// ScriptCoptic: coptic
	ScriptCoptic Script = 7
	// ScriptCyrillic: cyrillic
	ScriptCyrillic Script = 8
	// ScriptDeseret: deseret
	ScriptDeseret Script = 9
	// ScriptDevanagari: devanagari
	ScriptDevanagari Script = 10
	// ScriptEthiopic: ethiopic
	ScriptEthiopic Script = 11
	// ScriptGeorgian: georgian
	ScriptGeorgian Script = 12
	// ScriptGothic: gothic
	ScriptGothic Script = 13
	// ScriptGreek: greek
	ScriptGreek Script = 14
	// ScriptGujarati: gujarati
	ScriptGujarati Script = 15
	// ScriptGurmukhi: gurmukhi
	ScriptGurmukhi Script = 16
	// ScriptHan: han
	ScriptHan Script = 17
	// ScriptHangul: hangul
	ScriptHangul Script = 18
	// ScriptHebrew: hebrew
	ScriptHebrew Script = 19
	// ScriptHiragana: hiragana
	ScriptHiragana Script = 20
	// ScriptKannada: kannada
	ScriptKannada Script = 21
	// ScriptKatakana: katakana
	ScriptKatakana Script = 22
	// ScriptKhmer: khmer
	ScriptKhmer Script = 23
	// ScriptLao: lao
	ScriptLao Script = 24
	// ScriptLatin: latin
	ScriptLatin Script = 25
	// ScriptMalayalam: malayalam
	ScriptMalayalam Script = 26
	// ScriptMongolian: mongolian
	ScriptMongolian Script = 27
	// ScriptMyanmar: myanmar
	ScriptMyanmar Script = 28
	// ScriptOgham: ogham
	ScriptOgham Script = 29
	// ScriptOldItalic: old Italic
	ScriptOldItalic Script = 30
	// ScriptOriya: oriya
	ScriptOriya Script = 31
	// ScriptRunic: runic
	ScriptRunic Script = 32
	// ScriptSinhala: sinhala
	ScriptSinhala Script = 33
	// ScriptSyriac: syriac
	ScriptSyriac Script = 34
	// ScriptTamil: tamil
	ScriptTamil Script = 35
	// ScriptTelugu: telugu
	ScriptTelugu Script = 36
	// ScriptThaana: thaana
	ScriptThaana Script = 37
	// ScriptThai: thai
	ScriptThai Script = 38
	// ScriptTibetan: tibetan
	ScriptTibetan Script = 39
	// ScriptCanadianAboriginal: canadian Aboriginal
	ScriptCanadianAboriginal Script = 40
	// ScriptYi: yi
	ScriptYi Script = 41
	// ScriptTagalog: tagalog
	ScriptTagalog Script = 42
	// ScriptHanunoo: hanunoo
	ScriptHanunoo Script = 43
	// ScriptBuhid: buhid
	ScriptBuhid Script = 44
	// ScriptTagbanwa: tagbanwa
	ScriptTagbanwa Script = 45
	// ScriptBraille: braille
	ScriptBraille Script = 46
	// ScriptCypriot: cypriot
	ScriptCypriot Script = 47
	// ScriptLimbu: limbu
	ScriptLimbu Script = 48
	// ScriptOsmanya: osmanya
	ScriptOsmanya Script = 49
	// ScriptShavian: shavian
	ScriptShavian Script = 50
	// ScriptLinearB: linear B
	ScriptLinearB Script = 51
	// ScriptTaiLe: tai Le
	ScriptTaiLe Script = 52
	// ScriptUgaritic: ugaritic
	ScriptUgaritic Script = 53
	// ScriptNewTaiLue: new Tai Lue. Since 1.10
	ScriptNewTaiLue Script = 54
	// ScriptBuginese: buginese. Since 1.10
	ScriptBuginese Script = 55
	// ScriptGlagolitic: glagolitic. Since 1.10
	ScriptGlagolitic Script = 56
	// ScriptTifinagh: tifinagh. Since 1.10
	ScriptTifinagh Script = 57
	// ScriptSylotiNagri: syloti Nagri. Since 1.10
	ScriptSylotiNagri Script = 58
	// ScriptOldPersian: old Persian. Since 1.10
	ScriptOldPersian Script = 59
	// ScriptKharoshthi: kharoshthi. Since 1.10
	ScriptKharoshthi Script = 60
	// ScriptUnknown: an unassigned code point. Since 1.14
	ScriptUnknown Script = 61
	// ScriptBalinese: balinese. Since 1.14
	ScriptBalinese Script = 62
	// ScriptCuneiform: cuneiform. Since 1.14
	ScriptCuneiform Script = 63
	// ScriptPhoenician: phoenician. Since 1.14
	ScriptPhoenician Script = 64
	// ScriptPhagsPa: phags-pa. Since 1.14
	ScriptPhagsPa Script = 65
	// ScriptNko: n'Ko. Since 1.14
	ScriptNko Script = 66
	// ScriptKayahLi: kayah Li. Since 1.20.1
	ScriptKayahLi Script = 67
	// ScriptLepcha: lepcha. Since 1.20.1
	ScriptLepcha Script = 68
	// ScriptRejang: rejang. Since 1.20.1
	ScriptRejang Script = 69
	// ScriptSundanese: sundanese. Since 1.20.1
	ScriptSundanese Script = 70
	// ScriptSaurashtra: saurashtra. Since 1.20.1
	ScriptSaurashtra Script = 71
	// ScriptCham: cham. Since 1.20.1
	ScriptCham Script = 72
	// ScriptOlChiki: ol Chiki. Since 1.20.1
	ScriptOlChiki Script = 73
	// ScriptVai: vai. Since 1.20.1
	ScriptVai Script = 74
	// ScriptCarian: carian. Since 1.20.1
	ScriptCarian Script = 75
	// ScriptLycian: lycian. Since 1.20.1
	ScriptLycian Script = 76
	// ScriptLydian: lydian. Since 1.20.1
	ScriptLydian Script = 77
	// ScriptBatak: batak. Since 1.32
	ScriptBatak Script = 78
	// ScriptBrahmi: brahmi. Since 1.32
	ScriptBrahmi Script = 79
	// ScriptMandaic: mandaic. Since 1.32
	ScriptMandaic Script = 80
	// ScriptChakma: chakma. Since: 1.32
	ScriptChakma Script = 81
	// ScriptMeroiticCursive: meroitic Cursive. Since: 1.32
	ScriptMeroiticCursive Script = 82
	// ScriptMeroiticHieroglyphs: meroitic Hieroglyphs. Since: 1.32
	ScriptMeroiticHieroglyphs Script = 83
	// ScriptMiao: miao. Since: 1.32
	ScriptMiao Script = 84
	// ScriptSharada: sharada. Since: 1.32
	ScriptSharada Script = 85
	// ScriptSoraSompeng: sora Sompeng. Since: 1.32
	ScriptSoraSompeng Script = 86
	// ScriptTakri: takri. Since: 1.32
	ScriptTakri Script = 87
	// ScriptBassaVah: bassa. Since: 1.40
	ScriptBassaVah Script = 88
	// ScriptCaucasianAlbanian: caucasian Albanian. Since: 1.40
	ScriptCaucasianAlbanian Script = 89
	// ScriptDuployan: duployan. Since: 1.40
	ScriptDuployan Script = 90
	// ScriptElbasan: elbasan. Since: 1.40
	ScriptElbasan Script = 91
	// ScriptGrantha: grantha. Since: 1.40
	ScriptGrantha Script = 92
	// ScriptKhojki: kjohki. Since: 1.40
	ScriptKhojki Script = 93
	// ScriptKhudawadi: khudawadi, Sindhi. Since: 1.40
	ScriptKhudawadi Script = 94
	// ScriptLinearA: linear A. Since: 1.40
	ScriptLinearA Script = 95
	// ScriptMahajani: mahajani. Since: 1.40
	ScriptMahajani Script = 96
	// ScriptManichaean: manichaean. Since: 1.40
	ScriptManichaean Script = 97
	// ScriptMendeKikakui: mende Kikakui. Since: 1.40
	ScriptMendeKikakui Script = 98
	// ScriptModi: modi. Since: 1.40
	ScriptModi Script = 99
	// ScriptMro: mro. Since: 1.40
	ScriptMro Script = 100
	// ScriptNabataean: nabataean. Since: 1.40
	ScriptNabataean Script = 101
	// ScriptOldNorthArabian: old North Arabian. Since: 1.40
	ScriptOldNorthArabian Script = 102
	// ScriptOldPermic: old Permic. Since: 1.40
	ScriptOldPermic Script = 103
	// ScriptPahawhHmong: pahawh Hmong. Since: 1.40
	ScriptPahawhHmong Script = 104
	// ScriptPalmyrene: palmyrene. Since: 1.40
	ScriptPalmyrene Script = 105
	// ScriptPauCinHau: pau Cin Hau. Since: 1.40
	ScriptPauCinHau Script = 106
	// ScriptPsalterPahlavi: psalter Pahlavi. Since: 1.40
	ScriptPsalterPahlavi Script = 107
	// ScriptSiddham: siddham. Since: 1.40
	ScriptSiddham Script = 108
	// ScriptTirhuta: tirhuta. Since: 1.40
	ScriptTirhuta Script = 109
	// ScriptWarangCiti: warang Citi. Since: 1.40
	ScriptWarangCiti Script = 110
	// ScriptAhom: ahom. Since: 1.40
	ScriptAhom Script = 111
	// ScriptAnatolianHieroglyphs: anatolian Hieroglyphs. Since: 1.40
	ScriptAnatolianHieroglyphs Script = 112
	// ScriptHatran: hatran. Since: 1.40
	ScriptHatran Script = 113
	// ScriptMultani: multani. Since: 1.40
	ScriptMultani Script = 114
	// ScriptOldHungarian: old Hungarian. Since: 1.40
	ScriptOldHungarian Script = 115
	// ScriptSignwriting: signwriting. Since: 1.40
	ScriptSignwriting Script = 116
)

func marshalScript(p uintptr) (interface{}, error) {
	return Script(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Stretch: an enumeration specifying the width of the font relative to other
// designs within a family.
type Stretch int

const (
	// StretchUltraCondensed: ultra condensed width
	StretchUltraCondensed Stretch = 0
	// StretchExtraCondensed: extra condensed width
	StretchExtraCondensed Stretch = 1
	// StretchCondensed: condensed width
	StretchCondensed Stretch = 2
	// StretchSemiCondensed: semi condensed width
	StretchSemiCondensed Stretch = 3
	// StretchNormal: the normal width
	StretchNormal Stretch = 4
	// StretchSemiExpanded: semi expanded width
	StretchSemiExpanded Stretch = 5
	// StretchExpanded: expanded width
	StretchExpanded Stretch = 6
	// StretchExtraExpanded: extra expanded width
	StretchExtraExpanded Stretch = 7
	// StretchUltraExpanded: ultra expanded width
	StretchUltraExpanded Stretch = 8
)

func marshalStretch(p uintptr) (interface{}, error) {
	return Stretch(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Style: an enumeration specifying the various slant styles possible for a
// font.
type Style int

const (
	// StyleNormal: the font is upright.
	StyleNormal Style = 0
	// StyleOblique: the font is slanted, but in a roman style.
	StyleOblique Style = 1
	// StyleItalic: the font is slanted in an italic style.
	StyleItalic Style = 2
)

func marshalStyle(p uintptr) (interface{}, error) {
	return Style(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// TabAlign: `PangoTabAlign` specifies where a tab stop appears relative to the
// text.
type TabAlign int

const (
	// TabAlignLeft: the tab stop appears to the left of the text.
	TabAlignLeft TabAlign = 0
)

func marshalTabAlign(p uintptr) (interface{}, error) {
	return TabAlign(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Underline: the `PangoUnderline` enumeration is used to specify whether text
// should be underlined, and if so, the type of underlining.
type Underline int

const (
	// UnderlineNone: no underline should be drawn
	UnderlineNone Underline = 0
	// UnderlineSingle: a single underline should be drawn
	UnderlineSingle Underline = 1
	// UnderlineDouble: a double underline should be drawn
	UnderlineDouble Underline = 2
	// UnderlineLow: a single underline should be drawn at a position beneath
	// the ink extents of the text being underlined. This should be used only
	// for underlining single characters, such as for keyboard accelerators.
	// PANGO_UNDERLINE_SINGLE should be used for extended portions of text.
	UnderlineLow Underline = 3
	// UnderlineError: a wavy underline should be drawn below. This underline is
	// typically used to indicate an error such as a possible mispelling; in
	// some cases a contrasting color may automatically be used. This type of
	// underlining is available since Pango 1.4.
	UnderlineError Underline = 4
	// UnderlineSingleLine: like @PANGO_UNDERLINE_SINGLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineSingleLine Underline = 5
	// UnderlineDoubleLine: like @PANGO_UNDERLINE_DOUBLE, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineDoubleLine Underline = 6
	// UnderlineErrorLine: like @PANGO_UNDERLINE_ERROR, but drawn continuously
	// across multiple runs. This type of underlining is available since Pango
	// 1.46.
	UnderlineErrorLine Underline = 7
)

func marshalUnderline(p uintptr) (interface{}, error) {
	return Underline(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Variant: an enumeration specifying capitalization variant of the font.
type Variant int

const (
	// VariantNormal: a normal font.
	VariantNormal Variant = 0
	// VariantSmallCaps: a font with the lower case characters replaced by
	// smaller variants of the capital characters.
	VariantSmallCaps Variant = 1
)

func marshalVariant(p uintptr) (interface{}, error) {
	return Variant(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// Weight: an enumeration specifying the weight (boldness) of a font.
//
// This is a numerical value ranging from 100 to 1000, but there are some
// predefined values.
type Weight int

const (
	// WeightThin: the thin weight (= 100; Since: 1.24)
	WeightThin Weight = 100
	// WeightUltralight: the ultralight weight (= 200)
	WeightUltralight Weight = 200
	// WeightLight: the light weight (= 300)
	WeightLight Weight = 300
	// WeightSemilight: the semilight weight (= 350; Since: 1.36.7)
	WeightSemilight Weight = 350
	// WeightBook: the book weight (= 380; Since: 1.24)
	WeightBook Weight = 380
	// WeightNormal: the default weight (= 400)
	WeightNormal Weight = 400
	// WeightMedium: the normal weight (= 500; Since: 1.24)
	WeightMedium Weight = 500
	// WeightSemibold: the semibold weight (= 600)
	WeightSemibold Weight = 600
	// WeightBold: the bold weight (= 700)
	WeightBold Weight = 700
	// WeightUltrabold: the ultrabold weight (= 800)
	WeightUltrabold Weight = 800
	// WeightHeavy: the heavy weight (= 900)
	WeightHeavy Weight = 900
	// WeightUltraheavy: the ultraheavy weight (= 1000; Since: 1.24)
	WeightUltraheavy Weight = 1000
)

func marshalWeight(p uintptr) (interface{}, error) {
	return Weight(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// WrapMode: `PangoWrapMode` describes how to wrap the lines of a `PangoLayout`
// to the desired width.
type WrapMode int

const (
	// WrapModeWord: wrap lines at word boundaries.
	WrapModeWord WrapMode = 0
	// WrapModeChar: wrap lines at character boundaries.
	WrapModeChar WrapMode = 1
	// WrapModeWordChar: wrap lines at word boundaries, but fall back to
	// character boundaries if there is not enough space for a full word.
	WrapModeWordChar WrapMode = 2
)

func marshalWrapMode(p uintptr) (interface{}, error) {
	return WrapMode(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// FontMask: the bits in a `PangoFontMask` correspond to the set fields in a
// `PangoFontDescription`.
type FontMask int

const (
	// FontMaskFamily: the font family is specified.
	FontMaskFamily FontMask = 1
	// FontMaskStyle: the font style is specified.
	FontMaskStyle FontMask = 2
	// FontMaskVariant: the font variant is specified.
	FontMaskVariant FontMask = 4
	// FontMaskWeight: the font weight is specified.
	FontMaskWeight FontMask = 8
	// FontMaskStretch: the font stretch is specified.
	FontMaskStretch FontMask = 16
	// FontMaskSize: the font size is specified.
	FontMaskSize FontMask = 32
	// FontMaskGravity: the font gravity is specified (Since: 1.16.)
	FontMaskGravity FontMask = 64
	// FontMaskVariations: openType font variations are specified (Since: 1.42)
	FontMaskVariations FontMask = 128
)

func marshalFontMask(p uintptr) (interface{}, error) {
	return FontMask(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShapeFlags flags influencing the shaping process.
//
// `PangoShapeFlags` can be passed to pango_shape_with_flags().
type ShapeFlags int

const (
	// ShapeFlagsNone: default value.
	ShapeFlagsNone ShapeFlags = 0
	// ShapeFlagsRoundPositions: round glyph positions and widths to whole
	// device units. This option should be set if the target renderer can't do
	// subpixel positioning of glyphs.
	ShapeFlagsRoundPositions ShapeFlags = 1
)

func marshalShapeFlags(p uintptr) (interface{}, error) {
	return ShapeFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// ShowFlags: these flags affect how Pango treats characters that are normally
// not visible in the output.
type ShowFlags int

const (
	// ShowFlagsNone: no special treatment for invisible characters
	ShowFlagsNone ShowFlags = 0
	// ShowFlagsSpaces: render spaces, tabs and newlines visibly
	ShowFlagsSpaces ShowFlags = 1
	// ShowFlagsLineBreaks: render line breaks visibly
	ShowFlagsLineBreaks ShowFlags = 2
	// ShowFlagsIgnorables: render default-ignorable Unicode characters visibly
	ShowFlagsIgnorables ShowFlags = 4
)

func marshalShowFlags(p uintptr) (interface{}, error) {
	return ShowFlags(C.g_value_get_enum((*C.GValue)(unsafe.Pointer(p)))), nil
}

// NewAttrAllowBreaks: create a new allow-breaks attribute.
//
// If breaks are disabled, the range will be kept in a single run, as far as
// possible.
func NewAttrAllowBreaks(allowBreaks bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if allowBreaks {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_allow_breaks_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrBackgroundAlpha: create a new background alpha attribute.
func NewAttrBackgroundAlpha(alpha uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.guint16)(alpha)

	_cret = C.pango_attr_background_alpha_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrBackground: create a new background color attribute.
func NewAttrBackground(red uint16, green uint16, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.guint16)(red)
	_arg2 = (C.guint16)(green)
	_arg3 = (C.guint16)(blue)

	_cret = C.pango_attr_background_new(_arg1, _arg2, _arg3)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrFallback: create a new font fallback attribute.
//
// If fallback is disabled, characters will only be used from the closest
// matching font on the system. No fallback will be done to other fonts on the
// system that might contain the characters in the text.
func NewAttrFallback(enableFallback bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if enableFallback {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_fallback_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrFamily: create a new font family attribute.
func NewAttrFamily(family string) *Attribute {
	var _arg1 *C.char           // out
	var _cret *C.PangoAttribute // in

	_arg1 = (*C.char)(C.CString(family))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_attr_family_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrForegroundAlpha: create a new foreground alpha attribute.
func NewAttrForegroundAlpha(alpha uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.guint16)(alpha)

	_cret = C.pango_attr_foreground_alpha_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrForeground: create a new foreground color attribute.
func NewAttrForeground(red uint16, green uint16, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.guint16)(red)
	_arg2 = (C.guint16)(green)
	_arg3 = (C.guint16)(blue)

	_cret = C.pango_attr_foreground_new(_arg1, _arg2, _arg3)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrGravityHint: create a new gravity hint attribute.
func NewAttrGravityHint(hint GravityHint) *Attribute {
	var _arg1 C.PangoGravityHint // out
	var _cret *C.PangoAttribute  // in

	_arg1 = (C.PangoGravityHint)(hint)

	_cret = C.pango_attr_gravity_hint_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrGravity: create a new gravity attribute.
func NewAttrGravity(gravity Gravity) *Attribute {
	var _arg1 C.PangoGravity    // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoGravity)(gravity)

	_cret = C.pango_attr_gravity_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrInsertHyphens: create a new insert-hyphens attribute.
//
// Pango will insert hyphens when breaking lines in the middle of a word. This
// attribute can be used to suppress the hyphen.
func NewAttrInsertHyphens(insertHyphens bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if insertHyphens {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_insert_hyphens_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrLetterSpacing: create a new letter-spacing attribute.
func NewAttrLetterSpacing(letterSpacing int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.int)(letterSpacing)

	_cret = C.pango_attr_letter_spacing_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrOverlineColor: create a new overline color attribute.
//
// This attribute modifies the color of overlines. If not set, overlines will
// use the foreground color.
func NewAttrOverlineColor(red uint16, green uint16, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.guint16)(red)
	_arg2 = (C.guint16)(green)
	_arg3 = (C.guint16)(blue)

	_cret = C.pango_attr_overline_color_new(_arg1, _arg2, _arg3)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrOverline: create a new overline-style attribute.
func NewAttrOverline(overline Overline) *Attribute {
	var _arg1 C.PangoOverline   // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoOverline)(overline)

	_cret = C.pango_attr_overline_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrRise: create a new baseline displacement attribute.
func NewAttrRise(rise int) *Attribute {
	var _arg1 C.int             // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.int)(rise)

	_cret = C.pango_attr_rise_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrScale: create a new font size scale attribute.
//
// The base font for the affected text will have its size multiplied by
// @scale_factor.
func NewAttrScale(scaleFactor float64) *Attribute {
	var _arg1 C.double          // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.double)(scaleFactor)

	_cret = C.pango_attr_scale_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrShow: create a new attribute that influences how invisible characters
// are rendered.
func NewAttrShow(flags ShowFlags) *Attribute {
	var _arg1 C.PangoShowFlags  // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoShowFlags)(flags)

	_cret = C.pango_attr_show_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrStretch: create a new font stretch attribute.
func NewAttrStretch(stretch Stretch) *Attribute {
	var _arg1 C.PangoStretch    // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoStretch)(stretch)

	_cret = C.pango_attr_stretch_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrStrikethroughColor: create a new strikethrough color attribute.
//
// This attribute modifies the color of strikethrough lines. If not set,
// strikethrough lines will use the foreground color.
func NewAttrStrikethroughColor(red uint16, green uint16, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.guint16)(red)
	_arg2 = (C.guint16)(green)
	_arg3 = (C.guint16)(blue)

	_cret = C.pango_attr_strikethrough_color_new(_arg1, _arg2, _arg3)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrStrikethrough: create a new strike-through attribute.
func NewAttrStrikethrough(strikethrough bool) *Attribute {
	var _arg1 C.gboolean        // out
	var _cret *C.PangoAttribute // in

	if strikethrough {
		_arg1 = C.TRUE
	}

	_cret = C.pango_attr_strikethrough_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrStyle: create a new font slant style attribute.
func NewAttrStyle(style Style) *Attribute {
	var _arg1 C.PangoStyle      // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoStyle)(style)

	_cret = C.pango_attr_style_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrUnderlineColor: create a new underline color attribute.
//
// This attribute modifies the color of underlines. If not set, underlines will
// use the foreground color.
func NewAttrUnderlineColor(red uint16, green uint16, blue uint16) *Attribute {
	var _arg1 C.guint16         // out
	var _arg2 C.guint16         // out
	var _arg3 C.guint16         // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.guint16)(red)
	_arg2 = (C.guint16)(green)
	_arg3 = (C.guint16)(blue)

	_cret = C.pango_attr_underline_color_new(_arg1, _arg2, _arg3)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrUnderline: create a new underline-style attribute.
func NewAttrUnderline(underline Underline) *Attribute {
	var _arg1 C.PangoUnderline  // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoUnderline)(underline)

	_cret = C.pango_attr_underline_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrVariant: create a new font variant attribute (normal or small caps).
func NewAttrVariant(variant Variant) *Attribute {
	var _arg1 C.PangoVariant    // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoVariant)(variant)

	_cret = C.pango_attr_variant_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// NewAttrWeight: create a new font weight attribute.
func NewAttrWeight(weight Weight) *Attribute {
	var _arg1 C.PangoWeight     // out
	var _cret *C.PangoAttribute // in

	_arg1 = (C.PangoWeight)(weight)

	_cret = C.pango_attr_weight_new(_arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// ExtentsToPixels converts extents from Pango units to device units.
//
// The conversion is done by dividing by the PANGO_SCALE factor and performing
// rounding.
//
// The @inclusive rectangle is converted by flooring the x/y coordinates and
// extending width/height, such that the final rectangle completely includes the
// original rectangle.
//
// The @nearest rectangle is converted by rounding the coordinates of the
// rectangle to the nearest device unit (pixel).
//
// The rule to which argument to use is: if you want the resulting device-space
// rectangle to completely contain the original rectangle, pass it in as
// @inclusive. If you want two touching-but-not-overlapping rectangles stay
// touching-but-not-overlapping after rounding to device units, pass them in as
// @nearest.
func ExtentsToPixels(inclusive *Rectangle, nearest *Rectangle) {
	var _arg1 *C.PangoRectangle // out
	var _arg2 *C.PangoRectangle // out

	_arg1 = (*C.PangoRectangle)(unsafe.Pointer(inclusive.Native()))
	_arg2 = (*C.PangoRectangle)(unsafe.Pointer(nearest.Native()))

	C.pango_extents_to_pixels(_arg1, _arg2)
}

// FindBaseDir searches a string the first character that has a strong
// direction, according to the Unicode bidirectional algorithm.
func FindBaseDir(text string, length int) Direction {
	var _arg1 *C.gchar         // out
	var _arg2 C.gint           // out
	var _cret C.PangoDirection // in

	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(length)

	_cret = C.pango_find_base_dir(_arg1, _arg2)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// FindParagraphBoundary locates a paragraph boundary in @text.
//
// A boundary is caused by delimiter characters, such as a newline, carriage
// return, carriage return-newline pair, or Unicode paragraph separator
// character. The index of the run of delimiters is returned in
// @paragraph_delimiter_index. The index of the start of the paragrap (index
// after all delimiters) is stored in @next_paragraph_start.
//
// If no delimiters are found, both @paragraph_delimiter_index and
// @next_paragraph_start are filled with the length of @text (an index one off
// the end).
func FindParagraphBoundary(text string, length int) (paragraphDelimiterIndex int, nextParagraphStart int) {
	var _arg1 *C.gchar // out
	var _arg2 C.gint   // out
	var _arg3 C.gint   // in
	var _arg4 C.gint   // in

	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.gint)(length)

	C.pango_find_paragraph_boundary(_arg1, _arg2, &_arg3, &_arg4)

	var _paragraphDelimiterIndex int // out
	var _nextParagraphStart int      // out

	_paragraphDelimiterIndex = (int)(_arg3)
	_nextParagraphStart = (int)(_arg4)

	return _paragraphDelimiterIndex, _nextParagraphStart
}

// GetLogAttrs computes a `PangoLogAttr` for each character in @text.
//
// The @log_attrs array must have one `PangoLogAttr` for each position in @text;
// if @text contains N characters, it has N+1 positions, including the last
// position at the end of the text. @text should be an entire paragraph; logical
// attributes can't be computed without context (for example you need to see
// spaces on either side of a word to know the word is a word).
func GetLogAttrs(text string, length int, level int, language *Language, logAttrs []LogAttr) {
	var _arg1 *C.char          // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 *C.PangoLanguage // out
	var _arg5 *C.PangoLogAttr
	var _arg6 C.int

	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(length)
	_arg3 = (C.int)(level)
	_arg4 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))
	_arg6 = C.int(len(logAttrs))
	_arg5 = (*C.PangoLogAttr)(unsafe.Pointer(&logAttrs[0]))

	C.pango_get_log_attrs(_arg1, _arg2, _arg3, _arg4, _arg5, _arg6)
}

// GetMirrorChar returns the mirrored character of a Unicode character.
//
// Mirror characters are determined by the Unicode mirrored property.
//
// Use g_unichar_get_mirror_char() instead; the docs for that function provide
// full details.
func GetMirrorChar(ch uint32, mirroredCh *uint32) bool {
	var _arg1 C.gunichar  // out
	var _arg2 *C.gunichar // out
	var _cret C.gboolean  // in

	_arg1 = (C.gunichar)(ch)
	_arg2 = (*C.gunichar)(unsafe.Pointer(mirroredCh))

	_cret = C.pango_get_mirror_char(_arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// IsZeroWidth checks if a character that should not be normally rendered.
//
// This includes all Unicode characters with "ZERO WIDTH" in their name, as well
// as *bidi* formatting characters, and a few other ones. This is totally
// different from g_unichar_iszerowidth() and is at best misnamed.
func IsZeroWidth(ch uint32) bool {
	var _arg1 C.gunichar // out
	var _cret C.gboolean // in

	_arg1 = (C.gunichar)(ch)

	_cret = C.pango_is_zero_width(_arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Log2VisGetEmbeddingLevels: return the bidirectional embedding levels of the
// input paragraph.
//
// The bidirectional embedding levels are defined by the Unicode Bidirectional
// Algorithm available at:
//
//    http://www.unicode.org/reports/tr9/
//
// If the input base direction is a weak direction, the direction of the
// characters in the text will determine the final resolved direction.
func Log2VisGetEmbeddingLevels(text string, length int, pbaseDir *Direction) *byte {
	var _arg1 *C.gchar          // out
	var _arg2 C.int             // out
	var _arg3 *C.PangoDirection // out
	var _cret *C.guint8         // in

	_arg1 = (*C.gchar)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(length)
	_arg3 = (*C.PangoDirection)(unsafe.Pointer(pbaseDir))

	_cret = C.pango_log2vis_get_embedding_levels(_arg1, _arg2, _arg3)

	var _guint8 *byte // out

	_guint8 = (*byte)(_cret)

	return _guint8
}

// MarkupParserFinish finishes parsing markup.
//
// After feeding a Pango markup parser some data with
// g_markup_parse_context_parse(), use this function to get the list of
// attributes and text out of the markup. This function will not free @context,
// use g_markup_parse_context_free() to do so.
func MarkupParserFinish(context *glib.MarkupParseContext) (*AttrList, string, uint32, error) {
	var _arg1 *C.GMarkupParseContext // out
	var _attrList *AttrList
	var _arg3 *C.char    // in
	var _arg4 C.gunichar // in
	var _cerr *C.GError  // in

	_arg1 = (*C.GMarkupParseContext)(unsafe.Pointer(context.Native()))

	C.pango_markup_parser_finish(_arg1, (**C.PangoAttrList)(unsafe.Pointer(&_attrList)), &_arg3, &_arg4, &_cerr)

	var _text string      // out
	var _accelChar uint32 // out
	var _goerr error      // out

	_text = C.GoString(_arg3)
	defer C.free(unsafe.Pointer(_arg3))
	_accelChar = (uint32)(_arg4)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _attrList, _text, _accelChar, _goerr
}

// NewMarkupParser: incrementally parses marked-up text to create a plain-text
// string and an attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If @accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, @accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in @accel_char, when calling [func@markup_parser_finish]. Two
// @accel_marker characters following each other produce a single literal
// @accel_marker character.
//
// To feed markup to the parser, use g_markup_parse_context_parse() on the
// returned `GMarkupParseContext`. When done with feeding markup to the parser,
// use [func@markup_parser_finish] to get the data out of it, and then use
// g_markup_parse_context_free() to free it.
//
// This function is designed for applications that read Pango markup from
// streams. To simply parse a string containing Pango markup, the
// [func@parse_markup] API is recommended instead.
func NewMarkupParser(accelMarker uint32) *glib.MarkupParseContext {
	var _arg1 C.gunichar             // out
	var _cret *C.GMarkupParseContext // in

	_arg1 = (C.gunichar)(accelMarker)

	_cret = C.pango_markup_parser_new(_arg1)

	var _markupParseContext *glib.MarkupParseContext // out

	_markupParseContext = glib.WrapMarkupParseContext(unsafe.Pointer(_cret))

	return _markupParseContext
}

// ParseEnum parses an enum type and stores the result in @value.
//
// If @str does not match the nick name of any of the possible values for the
// enum and is not an integer, false is returned, a warning is issued if @warn
// is true, and a string representing the list of possible values is stored in
// @possible_values. The list is slash-separated, eg. "none/start/middle/end".
// If failed and @possible_values is not nil, returned string should be freed
// using g_free().
func ParseEnum(typ externglib.Type, str string, warn bool) (int, string, bool) {
	var _arg1 C.GType    // out
	var _arg2 *C.char    // out
	var _arg3 C.int      // in
	var _arg4 C.gboolean // out
	var _arg5 *C.char    // in
	var _cret C.gboolean // in

	_arg1 = C.GType(typ)
	_arg2 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg2))
	if warn {
		_arg4 = C.TRUE
	}

	_cret = C.pango_parse_enum(_arg1, _arg2, &_arg3, _arg4, &_arg5)

	var _value int             // out
	var _possibleValues string // out
	var _ok bool               // out

	_value = (int)(_arg3)
	_possibleValues = C.GoString(_arg5)
	defer C.free(unsafe.Pointer(_arg5))
	if _cret != 0 {
		_ok = true
	}

	return _value, _possibleValues, _ok
}

// ParseMarkup parses marked-up text to create a plain-text string and an
// attribute list.
//
// See the Pango Markup (pango_markup.html) docs for details about the supported
// markup.
//
// If @accel_marker is nonzero, the given character will mark the character
// following it as an accelerator. For example, @accel_marker might be an
// ampersand or underscore. All characters marked as an accelerator will receive
// a PANGO_UNDERLINE_LOW attribute, and the first character so marked will be
// returned in @accel_char. Two @accel_marker characters following each other
// produce a single literal @accel_marker character.
//
// To parse a stream of pango markup incrementally, use
// [func@markup_parser_new].
//
// If any error happens, none of the output arguments are touched except for
// @error.
func ParseMarkup(markupText string, length int, accelMarker uint32) (*AttrList, string, uint32, error) {
	var _arg1 *C.char    // out
	var _arg2 C.int      // out
	var _arg3 C.gunichar // out
	var _attrList *AttrList
	var _arg5 *C.char    // in
	var _arg6 C.gunichar // in
	var _cerr *C.GError  // in

	_arg1 = (*C.char)(C.CString(markupText))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(length)
	_arg3 = (C.gunichar)(accelMarker)

	C.pango_parse_markup(_arg1, _arg2, _arg3, (**C.PangoAttrList)(unsafe.Pointer(&_attrList)), &_arg5, &_arg6, &_cerr)

	var _text string      // out
	var _accelChar uint32 // out
	var _goerr error      // out

	_text = C.GoString(_arg5)
	defer C.free(unsafe.Pointer(_arg5))
	_accelChar = (uint32)(_arg6)
	_goerr = gerror.Take(unsafe.Pointer(_cerr))

	return _attrList, _text, _accelChar, _goerr
}

// ParseStretch parses a font stretch.
//
// The allowed values are "ultra_condensed", "extra_condensed", "condensed",
// "semi_condensed", "normal", "semi_expanded", "expanded", "extra_expanded" and
// "ultra_expanded". Case variations are ignored and the '_' characters may be
// omitted.
func ParseStretch(str string, warn bool) (Stretch, bool) {
	var _arg1 *C.char        // out
	var _arg2 C.PangoStretch // in
	var _arg3 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_stretch(_arg1, &_arg2, _arg3)

	var _stretch Stretch // out
	var _ok bool         // out

	_stretch = Stretch(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _stretch, _ok
}

// ParseStyle parses a font style.
//
// The allowed values are "normal", "italic" and "oblique", case variations
// being ignored.
func ParseStyle(str string, warn bool) (Style, bool) {
	var _arg1 *C.char      // out
	var _arg2 C.PangoStyle // in
	var _arg3 C.gboolean   // out
	var _cret C.gboolean   // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_style(_arg1, &_arg2, _arg3)

	var _style Style // out
	var _ok bool     // out

	_style = Style(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _style, _ok
}

// ParseVariant parses a font variant.
//
// The allowed values are "normal" and "smallcaps" or "small_caps", case
// variations being ignored.
func ParseVariant(str string, warn bool) (Variant, bool) {
	var _arg1 *C.char        // out
	var _arg2 C.PangoVariant // in
	var _arg3 C.gboolean     // out
	var _cret C.gboolean     // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_variant(_arg1, &_arg2, _arg3)

	var _variant Variant // out
	var _ok bool         // out

	_variant = Variant(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _variant, _ok
}

// ParseWeight parses a font weight.
//
// The allowed values are "heavy", "ultrabold", "bold", "normal", "light",
// "ultraleight" and integers. Case variations are ignored.
func ParseWeight(str string, warn bool) (Weight, bool) {
	var _arg1 *C.char       // out
	var _arg2 C.PangoWeight // in
	var _arg3 C.gboolean    // out
	var _cret C.gboolean    // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))
	if warn {
		_arg3 = C.TRUE
	}

	_cret = C.pango_parse_weight(_arg1, &_arg2, _arg3)

	var _weight Weight // out
	var _ok bool       // out

	_weight = Weight(_arg2)
	if _cret != 0 {
		_ok = true
	}

	return _weight, _ok
}

// SplitFileList splits a G_SEARCHPATH_SEPARATOR-separated list of files,
// stripping white space and substituting ~/ with $HOME/.
func SplitFileList(str string) []string {
	var _arg1 *C.char // out
	var _cret **C.char

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_split_file_list(_arg1)

	var _utf8s []string

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, i+1)[i] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString(src[i])
			defer C.free(unsafe.Pointer(src[i]))
		}
	}

	return _utf8s
}

// TrimString trims leading and trailing whitespace from a string.
func TrimString(str string) string {
	var _arg1 *C.char // out
	var _cret *C.char // in

	_arg1 = (*C.char)(C.CString(str))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_trim_string(_arg1)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UnicharDirection determines the inherent direction of a character.
//
// The inherent direction is either PANGO_DIRECTION_LTR, PANGO_DIRECTION_RTL, or
// PANGO_DIRECTION_NEUTRAL.
//
// This function is useful to categorize characters into left-to-right letters,
// right-to-left letters, and everything else. If full Unicode bidirectional
// type of a character is needed, [type_func@Pango.BidiType.for_unichar] can be
// used instead.
func UnicharDirection(ch uint32) Direction {
	var _arg1 C.gunichar       // out
	var _cret C.PangoDirection // in

	_arg1 = (C.gunichar)(ch)

	_cret = C.pango_unichar_direction(_arg1)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

// UnitsFromDouble converts a floating-point number to Pango units.
//
// The conversion is done by multiplying @d by PANGO_SCALE and rounding the
// result to nearest integer.
func UnitsFromDouble(d float64) int {
	var _arg1 C.double // out
	var _cret C.int    // in

	_arg1 = (C.double)(d)

	_cret = C.pango_units_from_double(_arg1)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnitsToDouble converts a number in Pango units to floating-point.
//
// The conversion is done by dividing @i by PANGO_SCALE.
func UnitsToDouble(i int) float64 {
	var _arg1 C.int    // out
	var _cret C.double // in

	_arg1 = (C.int)(i)

	_cret = C.pango_units_to_double(_arg1)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// Version returns the encoded version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION except that the macro returns the
// encoded version available at compile-time. A version number can be encoded
// into an integer using PANGO_VERSION_ENCODE().
func Version() int {
	var _cret C.int // in

	_cret = C.pango_version()

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// VersionCheck checks that the Pango library in use is compatible with the
// given version.
//
// Generally you would pass in the constants PANGO_VERSION_MAJOR,
// PANGO_VERSION_MINOR, PANGO_VERSION_MICRO as the three arguments to this
// function; that produces a check that the library in use at run-time is
// compatible with the version of Pango the application or module was compiled
// against.
//
// Compatibility is defined by two things: first the version of the running
// library is newer than the version
// @required_major.required_minor.@required_micro. Second the running library
// must be binary compatible with the version
// @required_major.required_minor.@required_micro (same major version.)
//
// For compile-time version checking use PANGO_VERSION_CHECK().
func VersionCheck(requiredMajor int, requiredMinor int, requiredMicro int) string {
	var _arg1 C.int   // out
	var _arg2 C.int   // out
	var _arg3 C.int   // out
	var _cret *C.char // in

	_arg1 = (C.int)(requiredMajor)
	_arg2 = (C.int)(requiredMinor)
	_arg3 = (C.int)(requiredMicro)

	_cret = C.pango_version_check(_arg1, _arg2, _arg3)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// VersionString returns the version of Pango available at run-time.
//
// This is similar to the macro PANGO_VERSION_STRING except that the macro
// returns the version available at compile-time.
func VersionString() string {
	var _cret *C.char // in

	_cret = C.pango_version_string()

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Context: a `PangoContext` stores global information used to control the
// itemization process.
//
// The information stored by `PangoContext includes the fontmap used to look up
// fonts, and default values such as the default language, default gravity, or
// default font.
//
// To obtain a `PangoContext`, use [method@Pango.FontMap.create_context].
type Context interface {
	gextras.Objector

	// Changed forces a change in the context, which will cause any
	// `PangoLayout` using this context to re-layout.
	//
	// This function is only useful when implementing a new backend for Pango,
	// something applications won't do. Backends should call this function if
	// they have attached extra data to the context and such data is changed.
	Changed()
	// BaseDir retrieves the base direction for the context.
	//
	// See [method@Pango.Context.set_base_dir].
	BaseDir() Direction
	// BaseGravity retrieves the base gravity for the context.
	//
	// See [method@Pango.Context.set_base_gravity].
	BaseGravity() Gravity
	// FontDescription: retrieve the default font description for the context.
	FontDescription() *FontDescription
	// FontMap gets the `PangoFontMap` used to look up fonts for this context.
	FontMap() FontMap
	// Gravity retrieves the gravity for the context.
	//
	// This is similar to [method@Pango.Context.get_base_gravity], except for
	// when the base gravity is PANGO_GRAVITY_AUTO for which
	// [type_func@Pango.Gravity.get_for_matrix] is used to return the gravity
	// from the current context matrix.
	Gravity() Gravity
	// GravityHint retrieves the gravity hint for the context.
	//
	// See [method@Pango.Context.set_gravity_hint] for details.
	GravityHint() GravityHint
	// Language retrieves the global language tag for the context.
	Language() *Language
	// Matrix gets the transformation matrix that will be applied when rendering
	// with this context.
	//
	// See [method@Pango.Context.set_matrix].
	Matrix() *Matrix
	// Metrics: get overall metric information for a particular font
	// description.
	//
	// Since the metrics may be substantially different for different scripts, a
	// language tag can be provided to indicate that the metrics should be
	// retrieved that correspond to the script(s) used by that language.
	//
	// The `PangoFontDescription` is interpreted in the same way as by
	// [func@itemize], and the family name may be a comma separated list of
	// names. If characters from multiple of these families would be used to
	// render the string, then the returned fonts would be a composite of the
	// metrics for the fonts loaded for the individual families.
	Metrics(desc *FontDescription, language *Language) *FontMetrics
	// RoundGlyphPositions returns whether font rendering with this context
	// should round glyph positions and widths.
	RoundGlyphPositions() bool
	// Serial returns the current serial number of @context.
	//
	// The serial number is initialized to an small number larger than zero when
	// a new context is created and is increased whenever the context is changed
	// using any of the setter functions, or the `PangoFontMap` it uses to find
	// fonts has changed. The serial may wrap, but will never have the value 0.
	// Since it can wrap, never compare it with "less than", always use "not
	// equals".
	//
	// This can be used to automatically detect changes to a `PangoContext`, and
	// is only useful when implementing objects that need update when their
	// `PangoContext` changes, like `PangoLayout`.
	Serial() uint
	// ListFamilies: list all families for a context.
	ListFamilies() []FontFamily
	// LoadFont loads the font in one of the fontmaps in the context that is the
	// closest match for @desc.
	LoadFont(desc *FontDescription) Font
	// LoadFontset: load a set of fonts in the context that can be used to
	// render a font matching @desc.
	LoadFontset(desc *FontDescription, language *Language) Fontset
	// SetBaseDir sets the base direction for the context.
	//
	// The base direction is used in applying the Unicode bidirectional
	// algorithm; if the @direction is PANGO_DIRECTION_LTR or
	// PANGO_DIRECTION_RTL, then the value will be used as the paragraph
	// direction in the Unicode bidirectional algorithm. A value of
	// PANGO_DIRECTION_WEAK_LTR or PANGO_DIRECTION_WEAK_RTL is used only for
	// paragraphs that do not contain any strong characters themselves.
	SetBaseDir(direction Direction)
	// SetBaseGravity sets the base gravity for the context.
	//
	// The base gravity is used in laying vertical text out.
	SetBaseGravity(gravity Gravity)
	// SetFontDescription: set the default font description for the context
	SetFontDescription(desc *FontDescription)
	// SetFontMap sets the font map to be searched when fonts are looked-up in
	// this context.
	//
	// This is only for internal use by Pango backends, a `PangoContext`
	// obtained via one of the recommended methods should already have a
	// suitable font map.
	SetFontMap(fontMap FontMap)
	// SetGravityHint sets the gravity hint for the context.
	//
	// The gravity hint is used in laying vertical text out, and is only
	// relevant if gravity of the context as returned by
	// [method@Pango.Context.get_gravity] is set to PANGO_GRAVITY_EAST or
	// PANGO_GRAVITY_WEST.
	SetGravityHint(hint GravityHint)
	// SetLanguage sets the global language tag for the context.
	//
	// The default language for the locale of the running process can be found
	// using [type_func@Pango.Language.get_default].
	SetLanguage(language *Language)
	// SetMatrix sets the transformation matrix that will be applied when
	// rendering with this context.
	//
	// Note that reported metrics are in the user space coordinates before the
	// application of the matrix, not device-space coordinates after the
	// application of the matrix. So, they don't scale with the matrix, though
	// they may change slightly for different matrices, depending on how the
	// text is fit to the pixel grid.
	SetMatrix(matrix *Matrix)
	// SetRoundGlyphPositions sets whether font rendering with this context
	// should round glyph positions and widths to integral positions, in device
	// units.
	//
	// This is useful when the renderer can't handle subpixel positioning of
	// glyphs.
	//
	// The default value is to round glyph positions, to remain compatible with
	// previous Pango behavior.
	SetRoundGlyphPositions(roundPositions bool)
}

// context implements the Context class.
type context struct {
	gextras.Objector
}

var _ Context = (*context)(nil)

// WrapContext wraps a GObject to the right type. It is
// primarily used internally.
func WrapContext(obj *externglib.Object) Context {
	return context{
		Objector: obj,
	}
}

func marshalContext(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapContext(obj), nil
}

// NewContext creates a new `PangoContext` initialized to default values.
//
// This function is not particularly useful as it should always be followed by a
// [method@Pango.Context.set_font_map] call, and the function
// [method@Pango.FontMap.create_context] does these two steps together and hence
// users are recommended to use that.
//
// If you are using Pango as part of a higher-level system, that system may have
// it's own way of create a `PangoContext`. For instance, the GTK toolkit has,
// among others, `gtk_widget_get_pango_context()`. Use those instead.
func NewContext() Context {
	var _cret *C.PangoContext // in

	_cret = C.pango_context_new()

	var _context Context // out

	_context = WrapContext(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _context
}

func (c context) Changed() {
	var _arg0 *C.PangoContext // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	C.pango_context_changed(_arg0)
}

func (c context) BaseDir() Direction {
	var _arg0 *C.PangoContext  // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_base_dir(_arg0)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

func (c context) BaseGravity() Gravity {
	var _arg0 *C.PangoContext // out
	var _cret C.PangoGravity  // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_base_gravity(_arg0)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

func (c context) FontDescription() *FontDescription {
	var _arg0 *C.PangoContext         // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_font_description(_arg0)

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))

	return _fontDescription
}

func (c context) FontMap() FontMap {
	var _arg0 *C.PangoContext // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_font_map(_arg0)

	var _fontMap FontMap // out

	_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FontMap)

	return _fontMap
}

func (c context) Gravity() Gravity {
	var _arg0 *C.PangoContext // out
	var _cret C.PangoGravity  // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_gravity(_arg0)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

func (c context) GravityHint() GravityHint {
	var _arg0 *C.PangoContext    // out
	var _cret C.PangoGravityHint // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_gravity_hint(_arg0)

	var _gravityHint GravityHint // out

	_gravityHint = GravityHint(_cret)

	return _gravityHint
}

func (c context) Language() *Language {
	var _arg0 *C.PangoContext  // out
	var _cret *C.PangoLanguage // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_language(_arg0)

	var _language *Language // out

	_language = WrapLanguage(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_language, func(v *Language) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _language
}

func (c context) Matrix() *Matrix {
	var _arg0 *C.PangoContext // out
	var _cret *C.PangoMatrix  // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_matrix(_arg0)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

func (c context) Metrics(desc *FontDescription, language *Language) *FontMetrics {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 *C.PangoLanguage        // out
	var _cret *C.PangoFontMetrics     // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))
	_arg2 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))

	_cret = C.pango_context_get_metrics(_arg0, _arg1, _arg2)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = WrapFontMetrics(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontMetrics, func(v *FontMetrics) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontMetrics
}

func (c context) RoundGlyphPositions() bool {
	var _arg0 *C.PangoContext // out
	var _cret C.gboolean      // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_round_glyph_positions(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (c context) Serial() uint {
	var _arg0 *C.PangoContext // out
	var _cret C.guint         // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	_cret = C.pango_context_get_serial(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (c context) ListFamilies() []FontFamily {
	var _arg0 *C.PangoContext // out
	var _arg1 **C.PangoFontFamily
	var _arg2 C.int // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))

	C.pango_context_list_families(_arg0, &_arg1, &_arg2)

	var _families []FontFamily

	{
		src := unsafe.Slice(_arg1, _arg2)
		defer C.free(unsafe.Pointer(_arg1))
		_families = make([]FontFamily, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_families[i] = gextras.CastObject(externglib.Take(unsafe.Pointer(src[i]))).(FontFamily)
		}
	}

	return _families
}

func (c context) LoadFont(desc *FontDescription) Font {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out
	var _cret *C.PangoFont            // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))

	_cret = C.pango_context_load_font(_arg0, _arg1)

	var _font Font // out

	_font = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Font)

	return _font
}

func (c context) LoadFontset(desc *FontDescription, language *Language) Fontset {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 *C.PangoLanguage        // out
	var _cret *C.PangoFontset         // in

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))
	_arg2 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))

	_cret = C.pango_context_load_fontset(_arg0, _arg1, _arg2)

	var _fontset Fontset // out

	_fontset = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Fontset)

	return _fontset
}

func (c context) SetBaseDir(direction Direction) {
	var _arg0 *C.PangoContext  // out
	var _arg1 C.PangoDirection // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.PangoDirection)(direction)

	C.pango_context_set_base_dir(_arg0, _arg1)
}

func (c context) SetBaseGravity(gravity Gravity) {
	var _arg0 *C.PangoContext // out
	var _arg1 C.PangoGravity  // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.PangoGravity)(gravity)

	C.pango_context_set_base_gravity(_arg0, _arg1)
}

func (c context) SetFontDescription(desc *FontDescription) {
	var _arg0 *C.PangoContext         // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))

	C.pango_context_set_font_description(_arg0, _arg1)
}

func (c context) SetFontMap(fontMap FontMap) {
	var _arg0 *C.PangoContext // out
	var _arg1 *C.PangoFontMap // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoFontMap)(unsafe.Pointer(fontMap.Native()))

	C.pango_context_set_font_map(_arg0, _arg1)
}

func (c context) SetGravityHint(hint GravityHint) {
	var _arg0 *C.PangoContext    // out
	var _arg1 C.PangoGravityHint // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (C.PangoGravityHint)(hint)

	C.pango_context_set_gravity_hint(_arg0, _arg1)
}

func (c context) SetLanguage(language *Language) {
	var _arg0 *C.PangoContext  // out
	var _arg1 *C.PangoLanguage // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))

	C.pango_context_set_language(_arg0, _arg1)
}

func (c context) SetMatrix(matrix *Matrix) {
	var _arg0 *C.PangoContext // out
	var _arg1 *C.PangoMatrix  // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoMatrix)(unsafe.Pointer(matrix.Native()))

	C.pango_context_set_matrix(_arg0, _arg1)
}

func (c context) SetRoundGlyphPositions(roundPositions bool) {
	var _arg0 *C.PangoContext // out
	var _arg1 C.gboolean      // out

	_arg0 = (*C.PangoContext)(unsafe.Pointer(c.Native()))
	if roundPositions {
		_arg1 = C.TRUE
	}

	C.pango_context_set_round_glyph_positions(_arg0, _arg1)
}

// Coverage: a Coverage structure is a map from Unicode characters to
// CoverageLevel values.
//
// It is often necessary in Pango to determine if a particular font can
// represent a particular character, and also how well it can represent that
// character. The Coverage is a data structure that is used to represent that
// information. It is an opaque structure with no public fields.
type Coverage interface {
	gextras.Objector

	// Copy: copy an existing `PangoCoverage`.
	Copy() Coverage
	// Get: determine whether a particular index is covered by @coverage.
	Get(index_ int) CoverageLevel
	// Max: set the coverage for each index in @coverage to be the max (better)
	// value of the current coverage for the index and the coverage for the
	// corresponding index in @other.
	Max(other Coverage)
	// Ref: increase the reference count on the `PangoCoverage` by one.
	Ref() Coverage
	// Set: modify a particular index within @coverage
	Set(index_ int, level CoverageLevel)
	// ToBytes: convert a `PangoCoverage` structure into a flat binary format.
	ToBytes() []byte
	// Unref: decrease the reference count on the `PangoCoverage` by one.
	//
	// If the result is zero, free the coverage and all associated memory.
	Unref()
}

// coverage implements the Coverage class.
type coverage struct {
	gextras.Objector
}

var _ Coverage = (*coverage)(nil)

// WrapCoverage wraps a GObject to the right type. It is
// primarily used internally.
func WrapCoverage(obj *externglib.Object) Coverage {
	return coverage{
		Objector: obj,
	}
}

func marshalCoverage(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapCoverage(obj), nil
}

// NewCoverage: create a new `PangoCoverage`
func NewCoverage() Coverage {
	var _cret *C.PangoCoverage // in

	_cret = C.pango_coverage_new()

	var _coverage Coverage // out

	_coverage = WrapCoverage(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _coverage
}

func (c coverage) Copy() Coverage {
	var _arg0 *C.PangoCoverage // out
	var _cret *C.PangoCoverage // in

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(c.Native()))

	_cret = C.pango_coverage_copy(_arg0)

	var _ret Coverage // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Coverage)

	return _ret
}

func (c coverage) Get(index_ int) CoverageLevel {
	var _arg0 *C.PangoCoverage     // out
	var _arg1 C.int                // out
	var _cret C.PangoCoverageLevel // in

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(index_)

	_cret = C.pango_coverage_get(_arg0, _arg1)

	var _coverageLevel CoverageLevel // out

	_coverageLevel = CoverageLevel(_cret)

	return _coverageLevel
}

func (c coverage) Max(other Coverage) {
	var _arg0 *C.PangoCoverage // out
	var _arg1 *C.PangoCoverage // out

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.PangoCoverage)(unsafe.Pointer(other.Native()))

	C.pango_coverage_max(_arg0, _arg1)
}

func (c coverage) Ref() Coverage {
	var _arg0 *C.PangoCoverage // out
	var _cret *C.PangoCoverage // in

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(c.Native()))

	_cret = C.pango_coverage_ref(_arg0)

	var _ret Coverage // out

	_ret = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Coverage)

	return _ret
}

func (c coverage) Set(index_ int, level CoverageLevel) {
	var _arg0 *C.PangoCoverage     // out
	var _arg1 C.int                // out
	var _arg2 C.PangoCoverageLevel // out

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(c.Native()))
	_arg1 = (C.int)(index_)
	_arg2 = (C.PangoCoverageLevel)(level)

	C.pango_coverage_set(_arg0, _arg1, _arg2)
}

func (c coverage) ToBytes() []byte {
	var _arg0 *C.PangoCoverage // out
	var _arg1 *C.guchar
	var _arg2 C.int // in

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(c.Native()))

	C.pango_coverage_to_bytes(_arg0, &_arg1, &_arg2)

	var _bytes []byte

	_bytes = unsafe.Slice((*byte)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_bytes, func(v *[]byte) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})

	return _bytes
}

func (c coverage) Unref() {
	var _arg0 *C.PangoCoverage // out

	_arg0 = (*C.PangoCoverage)(unsafe.Pointer(c.Native()))

	C.pango_coverage_unref(_arg0)
}

// Font: a `PangoFont` is used to represent a font in a
// rendering-system-independent manner.
type Font interface {
	gextras.Objector

	// Describe returns a description of the font, with font size set in points.
	//
	// Use [method@Pango.Font.describe_with_absolute_size] if you want the font
	// size in device units.
	Describe() *FontDescription
	// DescribeWithAbsoluteSize returns a description of the font, with absolute
	// font size set in device units.
	//
	// Use [method@Pango.Font.describe] if you want the font size in points.
	DescribeWithAbsoluteSize() *FontDescription
	// Coverage computes the coverage map for a given font and language tag.
	Coverage(language *Language) Coverage
	// Face gets the `PangoFontFace` to which @font belongs.
	Face() FontFace
	// FontMap gets the font map for which the font was created.
	//
	// Note that the font maintains a *weak* reference to the font map, so if
	// all references to font map are dropped, the font map will be finalized
	// even if there are fonts created with the font map that are still alive.
	// In that case this function will return nil.
	//
	// It is the responsibility of the user to ensure that the font map is kept
	// alive. In most uses this is not an issue as a Context holds a reference
	// to the font map.
	FontMap() FontMap
	// Metrics gets overall metric information for a font.
	//
	// Since the metrics may be substantially different for different scripts, a
	// language tag can be provided to indicate that the metrics should be
	// retrieved that correspond to the script(s) used by that language.
	//
	// If @font is nil, this function gracefully sets some sane values in the
	// output variables and returns.
	Metrics(language *Language) *FontMetrics
	// HasChar returns whether the font provides a glyph for this character.
	//
	// Returns true if @font can render @wc
	HasChar(wc uint32) bool
}

// font implements the Font class.
type font struct {
	gextras.Objector
}

var _ Font = (*font)(nil)

// WrapFont wraps a GObject to the right type. It is
// primarily used internally.
func WrapFont(obj *externglib.Object) Font {
	return font{
		Objector: obj,
	}
}

func marshalFont(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFont(obj), nil
}

func (f font) Describe() *FontDescription {
	var _arg0 *C.PangoFont            // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_describe(_arg0)

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

func (f font) DescribeWithAbsoluteSize() *FontDescription {
	var _arg0 *C.PangoFont            // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_describe_with_absolute_size(_arg0)

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

func (f font) Coverage(language *Language) Coverage {
	var _arg0 *C.PangoFont     // out
	var _arg1 *C.PangoLanguage // out
	var _cret *C.PangoCoverage // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))

	_cret = C.pango_font_get_coverage(_arg0, _arg1)

	var _coverage Coverage // out

	_coverage = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Coverage)

	return _coverage
}

func (f font) Face() FontFace {
	var _arg0 *C.PangoFont     // out
	var _cret *C.PangoFontFace // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_get_face(_arg0)

	var _fontFace FontFace // out

	_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FontFace)

	return _fontFace
}

func (f font) FontMap() FontMap {
	var _arg0 *C.PangoFont    // out
	var _cret *C.PangoFontMap // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_get_font_map(_arg0)

	var _fontMap FontMap // out

	_fontMap = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FontMap)

	return _fontMap
}

func (f font) Metrics(language *Language) *FontMetrics {
	var _arg0 *C.PangoFont        // out
	var _arg1 *C.PangoLanguage    // out
	var _cret *C.PangoFontMetrics // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))

	_cret = C.pango_font_get_metrics(_arg0, _arg1)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = WrapFontMetrics(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontMetrics, func(v *FontMetrics) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontMetrics
}

func (f font) HasChar(wc uint32) bool {
	var _arg0 *C.PangoFont // out
	var _arg1 C.gunichar   // out
	var _cret C.gboolean   // in

	_arg0 = (*C.PangoFont)(unsafe.Pointer(f.Native()))
	_arg1 = (C.gunichar)(wc)

	_cret = C.pango_font_has_char(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// FontFace: a `PangoFontFace` is used to represent a group of fonts with the
// same family, slant, weight, and width, but varying sizes.
type FontFace interface {
	gextras.Objector

	// Describe returns the family, style, variant, weight and stretch of a
	// `PangoFontFace`. The size field of the resulting font description will be
	// unset.
	Describe() *FontDescription
	// FaceName gets a name representing the style of this face among the
	// different faces in the `PangoFontFamily` for the face. The name is
	// suitable for displaying to users.
	FaceName() string
	// Family gets the `PangoFontFamily` that @face belongs to.
	Family() FontFamily
	// IsSynthesized returns whether a `PangoFontFace` is synthesized by the
	// underlying font rendering engine from another face, perhaps by shearing,
	// emboldening, or lightening it.
	IsSynthesized() bool
	// ListSizes: list the available sizes for a font.
	//
	// This is only applicable to bitmap fonts. For scalable fonts, stores nil
	// at the location pointed to by @sizes and 0 at the location pointed to by
	// @n_sizes. The sizes returned are in Pango units and are sorted in
	// ascending order.
	ListSizes() []int
}

// fontFace implements the FontFace class.
type fontFace struct {
	gextras.Objector
}

var _ FontFace = (*fontFace)(nil)

// WrapFontFace wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontFace(obj *externglib.Object) FontFace {
	return fontFace{
		Objector: obj,
	}
}

func marshalFontFace(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontFace(obj), nil
}

func (f fontFace) Describe() *FontDescription {
	var _arg0 *C.PangoFontFace        // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_face_describe(_arg0)

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

func (f fontFace) FaceName() string {
	var _arg0 *C.PangoFontFace // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_face_get_face_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (f fontFace) Family() FontFamily {
	var _arg0 *C.PangoFontFace   // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_face_get_family(_arg0)

	var _fontFamily FontFamily // out

	_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FontFamily)

	return _fontFamily
}

func (f fontFace) IsSynthesized() bool {
	var _arg0 *C.PangoFontFace // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_face_is_synthesized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f fontFace) ListSizes() []int {
	var _arg0 *C.PangoFontFace // out
	var _arg1 *C.int
	var _arg2 C.int // in

	_arg0 = (*C.PangoFontFace)(unsafe.Pointer(f.Native()))

	C.pango_font_face_list_sizes(_arg0, &_arg1, &_arg2)

	var _sizes []int

	_sizes = unsafe.Slice((*int)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_sizes, func(v *[]int) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})

	return _sizes
}

// FontFamily: a `PangoFontFamily` is used to represent a family of related font
// faces.
//
// The font faces in a family share a common design, but differ in slant,
// weight, width or other aspects.
type FontFamily interface {
	gextras.Objector

	// Face gets the `PangoFontFace` of @family with the given name.
	Face(name string) FontFace
	// Name gets the name of the family.
	//
	// The name is unique among all fonts for the font backend and can be used
	// in a `PangoFontDescription` to specify that a face from this family is
	// desired.
	Name() string
	// IsMonospace: a monospace font is a font designed for text display where
	// the the characters form a regular grid.
	//
	// For Western languages this would mean that the advance width of all
	// characters are the same, but this categorization also includes Asian
	// fonts which include double-width characters: characters that occupy two
	// grid cells. g_unichar_iswide() returns a result that indicates whether a
	// character is typically double-width in a monospace font.
	//
	// The best way to find out the grid-cell size is to call
	// [method@Pango.FontMetrics.get_approximate_digit_width], since the results
	// of [method@Pango.FontMetrics.get_approximate_char_width] may be affected
	// by double-width characters.
	IsMonospace() bool
	// IsVariable: a variable font is a font which has axes that can be modified
	// to produce different faces.
	IsVariable() bool
	// ListFaces lists the different font faces that make up @family.
	//
	// The faces in a family share a common design, but differ in slant, weight,
	// width and other aspects.
	ListFaces() []FontFace
}

// fontFamily implements the FontFamily class.
type fontFamily struct {
	gextras.Objector
}

var _ FontFamily = (*fontFamily)(nil)

// WrapFontFamily wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontFamily(obj *externglib.Object) FontFamily {
	return fontFamily{
		Objector: obj,
	}
}

func marshalFontFamily(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontFamily(obj), nil
}

func (f fontFamily) Face(name string) FontFace {
	var _arg0 *C.PangoFontFamily // out
	var _arg1 *C.char            // out
	var _cret *C.PangoFontFace   // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_font_family_get_face(_arg0, _arg1)

	var _fontFace FontFace // out

	_fontFace = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FontFace)

	return _fontFace
}

func (f fontFamily) Name() string {
	var _arg0 *C.PangoFontFamily // out
	var _cret *C.char            // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_family_get_name(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (f fontFamily) IsMonospace() bool {
	var _arg0 *C.PangoFontFamily // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_family_is_monospace(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f fontFamily) IsVariable() bool {
	var _arg0 *C.PangoFontFamily // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_family_is_variable(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (f fontFamily) ListFaces() []FontFace {
	var _arg0 *C.PangoFontFamily // out
	var _arg1 **C.PangoFontFace
	var _arg2 C.int // in

	_arg0 = (*C.PangoFontFamily)(unsafe.Pointer(f.Native()))

	C.pango_font_family_list_faces(_arg0, &_arg1, &_arg2)

	var _faces []FontFace

	{
		src := unsafe.Slice(_arg1, _arg2)
		defer C.free(unsafe.Pointer(_arg1))
		_faces = make([]FontFace, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_faces[i] = gextras.CastObject(externglib.Take(unsafe.Pointer(src[i]))).(FontFace)
		}
	}

	return _faces
}

// FontMap: a `PangoFontMap` represents the set of fonts available for a
// particular rendering system.
//
// This is a virtual object with implementations being specific to particular
// rendering systems.
type FontMap interface {
	gextras.Objector

	// Changed forces a change in the context, which will cause any
	// `PangoContext` using this fontmap to change.
	//
	// This function is only useful when implementing a new backend for Pango,
	// something applications won't do. Backends should call this function if
	// they have attached extra data to the context and such data is changed.
	Changed()
	// CreateContext creates a `PangoContext` connected to @fontmap.
	//
	// This is equivalent to [ctor@Pango.Context.new] followed by
	// [method@Pango.Context.set_font_map].
	//
	// If you are using Pango as part of a higher-level system, that system may
	// have it's own way of create a `PangoContext`. For instance, the GTK
	// toolkit has, among others, gtk_widget_get_pango_context(). Use those
	// instead.
	CreateContext() Context
	// Family gets a font family by name.
	Family(name string) FontFamily
	// Serial returns the current serial number of @fontmap.
	//
	// The serial number is initialized to an small number larger than zero when
	// a new fontmap is created and is increased whenever the fontmap is
	// changed. It may wrap, but will never have the value 0. Since it can wrap,
	// never compare it with "less than", always use "not equals".
	//
	// The fontmap can only be changed using backend-specific API, like changing
	// fontmap resolution.
	//
	// This can be used to automatically detect changes to a `PangoFontMap`,
	// like in `PangoContext`.
	Serial() uint
	// ListFamilies: list all families for a fontmap.
	ListFamilies() []FontFamily
	// LoadFont: load the font in the fontmap that is the closest match for
	// @desc.
	LoadFont(context Context, desc *FontDescription) Font
	// LoadFontset: load a set of fonts in the fontmap that can be used to
	// render a font matching @desc.
	LoadFontset(context Context, desc *FontDescription, language *Language) Fontset
}

// fontMap implements the FontMap class.
type fontMap struct {
	gextras.Objector
}

var _ FontMap = (*fontMap)(nil)

// WrapFontMap wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontMap(obj *externglib.Object) FontMap {
	return fontMap{
		Objector: obj,
	}
}

func marshalFontMap(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontMap(obj), nil
}

func (f fontMap) Changed() {
	var _arg0 *C.PangoFontMap // out

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(f.Native()))

	C.pango_font_map_changed(_arg0)
}

func (f fontMap) CreateContext() Context {
	var _arg0 *C.PangoFontMap // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_map_create_context(_arg0)

	var _context Context // out

	_context = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Context)

	return _context
}

func (f fontMap) Family(name string) FontFamily {
	var _arg0 *C.PangoFontMap    // out
	var _arg1 *C.char            // out
	var _cret *C.PangoFontFamily // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.char)(C.CString(name))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_font_map_get_family(_arg0, _arg1)

	var _fontFamily FontFamily // out

	_fontFamily = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(FontFamily)

	return _fontFamily
}

func (f fontMap) Serial() uint {
	var _arg0 *C.PangoFontMap // out
	var _cret C.guint         // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(f.Native()))

	_cret = C.pango_font_map_get_serial(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (f fontMap) ListFamilies() []FontFamily {
	var _arg0 *C.PangoFontMap // out
	var _arg1 **C.PangoFontFamily
	var _arg2 C.int // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(f.Native()))

	C.pango_font_map_list_families(_arg0, &_arg1, &_arg2)

	var _families []FontFamily

	{
		src := unsafe.Slice(_arg1, _arg2)
		defer C.free(unsafe.Pointer(_arg1))
		_families = make([]FontFamily, _arg2)
		for i := 0; i < int(_arg2); i++ {
			_families[i] = gextras.CastObject(externglib.Take(unsafe.Pointer(src[i]))).(FontFamily)
		}
	}

	return _families
}

func (f fontMap) LoadFont(context Context, desc *FontDescription) Font {
	var _arg0 *C.PangoFontMap         // out
	var _arg1 *C.PangoContext         // out
	var _arg2 *C.PangoFontDescription // out
	var _cret *C.PangoFont            // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))

	_cret = C.pango_font_map_load_font(_arg0, _arg1, _arg2)

	var _font Font // out

	_font = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Font)

	return _font
}

func (f fontMap) LoadFontset(context Context, desc *FontDescription, language *Language) Fontset {
	var _arg0 *C.PangoFontMap         // out
	var _arg1 *C.PangoContext         // out
	var _arg2 *C.PangoFontDescription // out
	var _arg3 *C.PangoLanguage        // out
	var _cret *C.PangoFontset         // in

	_arg0 = (*C.PangoFontMap)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoContext)(unsafe.Pointer(context.Native()))
	_arg2 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))
	_arg3 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))

	_cret = C.pango_font_map_load_fontset(_arg0, _arg1, _arg2, _arg3)

	var _fontset Fontset // out

	_fontset = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Fontset)

	return _fontset
}

// Fontset: a `PangoFontset` represents a set of `PangoFont` to use when
// rendering text.
//
// A `PAngoFontset` is the result of resolving a `PangoFontDescription` against
// a particular `PangoContext`. It has operations for finding the component font
// for a particular Unicode character, and for finding a composite set of
// metrics for the entire fontset.
type Fontset interface {
	gextras.Objector

	// Font returns the font in the fontset that contains the best glyph for a
	// Unicode character.
	Font(wc uint) Font
	// Metrics: get overall metric information for the fonts in the fontset.
	Metrics() *FontMetrics
}

// fontset implements the Fontset class.
type fontset struct {
	gextras.Objector
}

var _ Fontset = (*fontset)(nil)

// WrapFontset wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontset(obj *externglib.Object) Fontset {
	return fontset{
		Objector: obj,
	}
}

func marshalFontset(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontset(obj), nil
}

func (f fontset) Font(wc uint) Font {
	var _arg0 *C.PangoFontset // out
	var _arg1 C.guint         // out
	var _cret *C.PangoFont    // in

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(f.Native()))
	_arg1 = (C.guint)(wc)

	_cret = C.pango_fontset_get_font(_arg0, _arg1)

	var _font Font // out

	_font = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Font)

	return _font
}

func (f fontset) Metrics() *FontMetrics {
	var _arg0 *C.PangoFontset     // out
	var _cret *C.PangoFontMetrics // in

	_arg0 = (*C.PangoFontset)(unsafe.Pointer(f.Native()))

	_cret = C.pango_fontset_get_metrics(_arg0)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = WrapFontMetrics(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontMetrics, func(v *FontMetrics) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontMetrics
}

// FontsetSimple: `PangoFontsetSimple` is a implementation of the abstract
// `PangoFontset` base class as an array of fonts.
//
// When creating a `PangoFontsetSimple`, you have to provide the array of fonts
// that make up the fontset.
type FontsetSimple interface {
	Fontset

	// Append adds a font to the fontset.
	Append(font Font)
	// Size returns the number of fonts in the fontset.
	Size() int
}

// fontsetSimple implements the FontsetSimple class.
type fontsetSimple struct {
	Fontset
}

var _ FontsetSimple = (*fontsetSimple)(nil)

// WrapFontsetSimple wraps a GObject to the right type. It is
// primarily used internally.
func WrapFontsetSimple(obj *externglib.Object) FontsetSimple {
	return fontsetSimple{
		Fontset: WrapFontset(obj),
	}
}

func marshalFontsetSimple(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapFontsetSimple(obj), nil
}

// NewFontsetSimple creates a new `PangoFontsetSimple` for the given language.
func NewFontsetSimple(language *Language) FontsetSimple {
	var _arg1 *C.PangoLanguage      // out
	var _cret *C.PangoFontsetSimple // in

	_arg1 = (*C.PangoLanguage)(unsafe.Pointer(language.Native()))

	_cret = C.pango_fontset_simple_new(_arg1)

	var _fontsetSimple FontsetSimple // out

	_fontsetSimple = WrapFontsetSimple(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _fontsetSimple
}

func (f fontsetSimple) Append(font Font) {
	var _arg0 *C.PangoFontsetSimple // out
	var _arg1 *C.PangoFont          // out

	_arg0 = (*C.PangoFontsetSimple)(unsafe.Pointer(f.Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))

	C.pango_fontset_simple_append(_arg0, _arg1)
}

func (f fontsetSimple) Size() int {
	var _arg0 *C.PangoFontsetSimple // out
	var _cret C.int                 // in

	_arg0 = (*C.PangoFontsetSimple)(unsafe.Pointer(f.Native()))

	_cret = C.pango_fontset_simple_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Layout: a `PangoLayout` structure represents an entire paragraph of text.
//
// While complete access to the layout capabilities of Pango is provided using
// the detailed interfaces for itemization and shaping, using that functionality
// directly involves writing a fairly large amount of code. `PangoLayout`
// provides a high-level driver for formatting entire paragraphs of text at
// once. This includes paragraph-level functionality such as line breaking,
// justification, alignment and ellipsization.
//
// A `PangoLayout is initialized with a `PangoContext`, UTF-8 string and set of
// attributes for that string. Once that is done, the set of formatted lines can
// be extracted from the object, the layout can be rendered, and conversion
// between logical character positions within the layout's text, and the
// physical position of the resulting glyphs can be made.
//
// There are a number of parameters to adjust the formatting of a `PangoLayout`.
// The following image shows adjustable parameters (on the left) and font
// metrics (on the right):
//
// !Pango Layout Parameters (layout.png)
//
// It is possible, as well, to ignore the 2-D setup, and simply treat the
// results of a `PangoLayout` as a list of lines.
type Layout interface {
	gextras.Objector

	// ContextChanged forces recomputation of any state in the `PangoLayout`
	// that might depend on the layout's context.
	//
	// This function should be called if you make changes to the context
	// subsequent to creating the layout.
	ContextChanged()
	// Copy creates a deep copy-by-value of the layout.
	//
	// The attribute list, tab array, and text from the original layout are all
	// copied by value.
	Copy() Layout
	// Alignment gets the alignment for the layout: how partial lines are
	// positioned within the horizontal space available.
	Alignment() Alignment
	// Attributes gets the attribute list for the layout, if any.
	Attributes() *AttrList
	// AutoDir gets whether to calculate the base direction for the layout
	// according to its contents.
	//
	// See [method@Pango.Layout.set_auto_dir].
	AutoDir() bool
	// Baseline gets the Y position of baseline of the first line in @layout.
	Baseline() int
	// CharacterCount returns the number of Unicode characters in the the text
	// of @layout.
	CharacterCount() int
	// Context retrieves the `PangoContext` used for this layout.
	Context() Context
	// CursorPos: given an index within a layout, determines the positions that
	// of the strong and weak cursors if the insertion point is at that index.
	//
	// The position of each cursor is stored as a zero-width rectangle. The
	// strong cursor location is the location where characters of the
	// directionality equal to the base direction of the layout are inserted.
	// The weak cursor location is the location where characters of the
	// directionality opposite to the base direction of the layout are inserted.
	CursorPos(index_ int) (strongPos Rectangle, weakPos Rectangle)
	// Direction gets the text direction at the given character position in
	// @layout.
	Direction(index int) Direction
	// Ellipsize gets the type of ellipsization being performed for @layout.
	//
	// See [method@Pango.Layout.set_ellipsize].
	//
	// Use [method@Pango.Layout.is_ellipsized] to query whether any paragraphs
	// were actually ellipsized.
	Ellipsize() EllipsizeMode
	// Extents computes the logical and ink extents of @layout.
	//
	// Logical extents are usually what you want for positioning things. Note
	// that both extents may have non-zero x and y. You may want to use those to
	// offset where you render the layout. Not doing that is a very typical bug
	// that shows up as right-to-left layouts not being correctly positioned in
	// a layout with a set width.
	//
	// The extents are given in layout coordinates and in Pango units; layout
	// coordinates begin at the top left corner of the layout.
	Extents() (inkRect Rectangle, logicalRect Rectangle)
	// FontDescription gets the font description for the layout, if any.
	FontDescription() *FontDescription
	// Height gets the height of layout used for ellipsization.
	//
	// See [method@Pango.Layout.set_height] for details.
	Height() int
	// Indent gets the paragraph indent width in Pango units.
	//
	// A negative value indicates a hanging indentation.
	Indent() int
	// Iter returns an iterator to iterate over the visual extents of the
	// layout.
	Iter() *LayoutIter
	// Justify gets whether each complete line should be stretched to fill the
	// entire width of the layout.
	Justify() bool
	// LineCount retrieves the count of lines for the @layout.
	LineCount() int
	// LineSpacing gets the line spacing factor of @layout.
	//
	// See [method@Pango.Layout.set_line_spacing].
	LineSpacing() float32
	// LogAttrs retrieves an array of logical attributes for each character in
	// the @layout.
	LogAttrs() []LogAttr
	// PixelExtents computes the logical and ink extents of @layout in device
	// units.
	//
	// This function just calls [method@Pango.Layout.get_extents] followed by
	// two [func@extents_to_pixels] calls, rounding @ink_rect and @logical_rect
	// such that the rounded rectangles fully contain the unrounded one (that
	// is, passes them as first argument to `pango_extents_to_pixels()`).
	PixelExtents() (inkRect Rectangle, logicalRect Rectangle)
	// PixelSize determines the logical width and height of a `PangoLayout` in
	// device units.
	//
	// [method@Pango.Layout.get_size] returns the width and height scaled by
	// PANGO_SCALE. This is simply a convenience function around
	// [method@Pango.Layout.get_pixel_extents].
	PixelSize() (width int, height int)
	// Serial returns the current serial number of @layout.
	//
	// The serial number is initialized to an small number larger than zero when
	// a new layout is created and is increased whenever the layout is changed
	// using any of the setter functions, or the `PangoContext` it uses has
	// changed. The serial may wrap, but will never have the value 0. Since it
	// can wrap, never compare it with "less than", always use "not equals".
	//
	// This can be used to automatically detect changes to a `PangoLayout`, and
	// is useful for example to decide whether a layout needs redrawing. To
	// force the serial to be increased, use
	// [method@Pango.Layout.context_changed].
	Serial() uint
	// SingleParagraphMode obtains whether @layout is in single paragraph mode.
	//
	// See [method@Pango.Layout.set_single_paragraph_mode].
	SingleParagraphMode() bool
	// Size determines the logical width and height of a `PangoLayout` in Pango
	// units.
	//
	// This is simply a convenience function around
	// [method@Pango.Layout.get_extents].
	Size() (width int, height int)
	// Spacing gets the amount of spacing between the lines of the layout.
	Spacing() int
	// Tabs gets the current `PangoTabArray` used by this layout.
	//
	// If no `PangoTabArray` has been set, then the default tabs are in use and
	// nil is returned. Default tabs are every 8 spaces.
	//
	// The return value should be freed with [method@Pango.TabArray.free].
	Tabs() *TabArray
	// Text gets the text in the layout. The returned text should not be freed
	// or modified.
	Text() string
	// UnknownGlyphsCount counts the number of unknown glyphs in @layout.
	//
	// This function can be used to determine if there are any fonts available
	// to render all characters in a certain string, or when used in combination
	// with PANGO_ATTR_FALLBACK, to check if a certain font supports all the
	// characters in the string.
	UnknownGlyphsCount() int
	// Width gets the width to which the lines of the `PangoLayout` should wrap.
	Width() int
	// Wrap gets the wrap mode for the layout.
	//
	// Use [method@Pango.Layout.is_wrapped] to query whether any paragraphs were
	// actually wrapped.
	Wrap() WrapMode
	// IndexToLineX converts from byte @index_ within the @layout to line and X
	// position.
	//
	// The X position is measured from the left edge of the line.
	IndexToLineX(index_ int, trailing bool) (line int, xPos int)
	// IndexToPos converts from an index within a `PangoLayout` to the onscreen
	// position corresponding to the grapheme at that index.
	//
	// The return value is represented as rectangle. Note that `pos->x` is
	// always the leading edge of the grapheme and `pos->x + pos->width` the
	// trailing edge of the grapheme. If the directionality of the grapheme is
	// right-to-left, then `pos->width` will be negative.
	IndexToPos(index_ int) Rectangle
	// IsEllipsized queries whether the layout had to ellipsize any paragraphs.
	//
	// This returns true if the ellipsization mode for @layout is not
	// PANGO_ELLIPSIZE_NONE, a positive width is set on @layout, and there are
	// paragraphs exceeding that width that have to be ellipsized.
	IsEllipsized() bool
	// IsWrapped queries whether the layout had to wrap any paragraphs.
	//
	// This returns true if a positive width is set on @layout, ellipsization
	// mode of @layout is set to PANGO_ELLIPSIZE_NONE, and there are paragraphs
	// exceeding the layout width that have to be wrapped.
	IsWrapped() bool
	// MoveCursorVisually computes a new cursor position from an old position
	// and a count of positions to move visually.
	//
	// If @direction is positive, then the new strong cursor position will be
	// one position to the right of the old cursor position. If @direction is
	// negative, then the new strong cursor position will be one position to the
	// left of the old cursor position.
	//
	// In the presence of bidirectional text, the correspondence between logical
	// and visual order will depend on the direction of the current run, and
	// there may be jumps when the cursor is moved off of the end of a run.
	//
	// Motion here is in cursor positions, not in characters, so a single call
	// to [method@Pango.Layout.move_cursor_visually] may move the cursor over
	// multiple characters when multiple characters combine to form a single
	// grapheme.
	MoveCursorVisually(strong bool, oldIndex int, oldTrailing int, direction int) (newIndex int, newTrailing int)
	// SetAlignment sets the alignment for the layout: how partial lines are
	// positioned within the horizontal space available.
	SetAlignment(alignment Alignment)
	// SetAttributes sets the text attributes for a layout object. References
	// @attrs, so the caller can unref its reference.
	SetAttributes(attrs *AttrList)
	// SetAutoDir sets whether to calculate the base direction for the layout
	// according to its contents.
	//
	// When this flag is on (the default), then paragraphs in @layout that begin
	// with strong right-to-left characters (Arabic and Hebrew principally),
	// will have right-to-left layout, paragraphs with letters from other
	// scripts will have left-to-right layout. Paragraphs with only neutral
	// characters get their direction from the surrounding paragraphs.
	//
	// When false, the choice between left-to-right and right-to-left layout is
	// done according to the base direction of the layout's `PangoContext`. (See
	// [method@Pango.Context.set_base_dir]).
	//
	// When the auto-computed direction of a paragraph differs from the base
	// direction of the context, the interpretation of PANGO_ALIGN_LEFT and
	// PANGO_ALIGN_RIGHT are swapped.
	SetAutoDir(autoDir bool)
	// SetEllipsize sets the type of ellipsization being performed for @layout.
	//
	// Depending on the ellipsization mode @ellipsize text is removed from the
	// start, middle, or end of text so they fit within the width and height of
	// layout set with [method@Pango.Layout.set_width] and
	// [method@Pango.Layout.set_height].
	//
	// If the layout contains characters such as newlines that force it to be
	// layed out in multiple paragraphs, then whether each paragraph is
	// ellipsized separately or the entire layout is ellipsized as a whole
	// depends on the set height of the layout. See
	// [method@Pango.Layout.set_height] for details.
	SetEllipsize(ellipsize EllipsizeMode)
	// SetFontDescription sets the default font description for the layout.
	//
	// If no font description is set on the layout, the font description from
	// the layout's context is used.
	SetFontDescription(desc *FontDescription)
	// SetHeight sets the height to which the `PangoLayout` should be ellipsized
	// at.
	//
	// There are two different behaviors, based on whether @height is positive
	// or negative.
	//
	// If @height is positive, it will be the maximum height of the layout. Only
	// lines would be shown that would fit, and if there is any text omitted, an
	// ellipsis added. At least one line is included in each paragraph
	// regardless of how small the height value is. A value of zero will render
	// exactly one line for the entire layout.
	//
	// If @height is negative, it will be the (negative of) maximum number of
	// lines per paragraph. That is, the total number of lines shown may well be
	// more than this value if the layout contains multiple paragraphs of text.
	// The default value of -1 means that first line of each paragraph is
	// ellipsized. This behavior may be changed in the future to act per layout
	// instead of per paragraph. File a bug against pango at
	// https://gitlab.gnome.org/gnome/pango
	// (https://gitlab.gnome.org/gnome/pango) if your code relies on this
	// behavior.
	//
	// Height setting only has effect if a positive width is set on @layout and
	// ellipsization mode of @layout is not PANGO_ELLIPSIZE_NONE. The behavior
	// is undefined if a height other than -1 is set and ellipsization mode is
	// set to PANGO_ELLIPSIZE_NONE, and may change in the future.
	SetHeight(height int)
	// SetIndent sets the width in Pango units to indent each paragraph.
	//
	// A negative value of @indent will produce a hanging indentation. That is,
	// the first line will have the full width, and subsequent lines will be
	// indented by the absolute value of @indent.
	//
	// The indent setting is ignored if layout alignment is set to
	// PANGO_ALIGN_CENTER.
	SetIndent(indent int)
	// SetJustify sets whether each complete line should be stretched to fill
	// the entire width of the layout.
	//
	// Stretching is typically done by adding whitespace, but for some scripts
	// (such as Arabic), the justification may be done in more complex ways,
	// like extending the characters.
	//
	// Note that this setting is not implemented and so is ignored in Pango
	// older than 1.18.
	SetJustify(justify bool)
	// SetLineSpacing sets a factor for line spacing.
	//
	// Typical values are: 0, 1, 1.5, 2. The default values is 0.
	//
	// If @factor is non-zero, lines are placed so that
	//
	//    baseline2 = baseline1 + factor * height2
	//
	// where height2 is the line height of the second line (as determined by the
	// font(s)). In this case, the spacing set with
	// [method@Pango.Layout.set_spacing] is ignored.
	//
	// If @factor is zero, spacing is applied as before.
	SetLineSpacing(factor float32)
	// SetMarkup sets the layout text and attribute list from marked-up text.
	//
	// See Pango Markup (pango_markup.html)). Replaces the current text and
	// attribute list.
	//
	// This is the Same as [method@Pango.Layout.set_markup_with_accel], but the
	// markup text isn't scanned for accelerators.
	SetMarkup(markup string, length int)
	// SetMarkupWithAccel sets the layout text and attribute list from marked-up
	// text.
	//
	// See Pango Markup (pango_markup.html)). Replaces the current text and
	// attribute list.
	//
	// If @accel_marker is nonzero, the given character will mark the character
	// following it as an accelerator. For example, @accel_marker might be an
	// ampersand or underscore. All characters marked as an accelerator will
	// receive a PANGO_UNDERLINE_LOW attribute, and the first character so
	// marked will be returned in @accel_char. Two @accel_marker characters
	// following each other produce a single literal @accel_marker character.
	SetMarkupWithAccel(markup string, length int, accelMarker uint32) uint32
	// SetSingleParagraphMode sets the single paragraph mode of @layout.
	//
	// If @setting is true, do not treat newlines and similar characters as
	// paragraph separators; instead, keep all text in a single paragraph, and
	// display a glyph for paragraph separator characters. Used when you want to
	// allow editing of newlines on a single text line.
	SetSingleParagraphMode(setting bool)
	// SetSpacing sets the amount of spacing in Pango unit between the lines of
	// the layout.
	//
	//
	// When placing lines with spacing, Pango arranges things so that
	//
	// line2.top = line1.bottom + spacing
	//
	// Note: Since 1.44, Pango defaults to using the line height (as determined
	// by the font) for placing lines. The @spacing set with this function is
	// only taken into account when the line height factor is set to zero with
	// [method@Pango.Layout.set_line_spacing].
	SetSpacing(spacing int)
	// SetTabs sets the tabs to use for @layout, overriding the default tabs.
	//
	// By default, tabs are every 8 spaces. If @tabs is nil, the default tabs
	// are reinstated. @tabs is copied into the layout; you must free your copy
	// of @tabs yourself.
	SetTabs(tabs *TabArray)
	// SetText sets the text of the layout.
	//
	// This function validates @text and renders invalid UTF-8 with a
	// placeholder glyph.
	//
	// Note that if you have used [method@Pango.Layout.set_markup] or
	// [method@Pango.Layout.set_markup_with_accel] on @layout before, you may
	// want to call [method@Pango.Layout.set_attributes] to clear the attributes
	// set on the layout from the markup as this function does not clear
	// attributes.
	SetText(text string, length int)
	// SetWidth sets the width to which the lines of the `PangoLayout` should
	// wrap or ellipsized.
	//
	// The default value is -1: no width set.
	SetWidth(width int)
	// SetWrap sets the wrap mode.
	//
	// The wrap mode only has effect if a width is set on the layout with
	// [method@Pango.Layout.set_width]. To turn off wrapping, set the width to
	// -1.
	SetWrap(wrap WrapMode)
	// XYToIndex converts from X and Y position within a layout to the byte
	// index to the character at that logical position.
	//
	// If the Y position is not inside the layout, the closest position is
	// chosen (the position will be clamped inside the layout). If the X
	// position is not within the layout, then the start or the end of the line
	// is chosen as described for [method@Pango.LayoutLine.x_to_index]. If
	// either the X or Y positions were not inside the layout, then the function
	// returns false; on an exact hit, it returns true.
	XYToIndex(x int, y int) (index_ int, trailing int, ok bool)
}

// layout implements the Layout class.
type layout struct {
	gextras.Objector
}

var _ Layout = (*layout)(nil)

// WrapLayout wraps a GObject to the right type. It is
// primarily used internally.
func WrapLayout(obj *externglib.Object) Layout {
	return layout{
		Objector: obj,
	}
}

func marshalLayout(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapLayout(obj), nil
}

// NewLayout: create a new `PangoLayout` object with attributes initialized to
// default values for a particular `PangoContext`.
func NewLayout(context Context) Layout {
	var _arg1 *C.PangoContext // out
	var _cret *C.PangoLayout  // in

	_arg1 = (*C.PangoContext)(unsafe.Pointer(context.Native()))

	_cret = C.pango_layout_new(_arg1)

	var _layout Layout // out

	_layout = WrapLayout(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _layout
}

func (l layout) ContextChanged() {
	var _arg0 *C.PangoLayout // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_context_changed(_arg0)
}

func (s layout) Copy() Layout {
	var _arg0 *C.PangoLayout // out
	var _cret *C.PangoLayout // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(s.Native()))

	_cret = C.pango_layout_copy(_arg0)

	var _layout Layout // out

	_layout = gextras.CastObject(externglib.AssumeOwnership(unsafe.Pointer(_cret))).(Layout)

	return _layout
}

func (l layout) Alignment() Alignment {
	var _arg0 *C.PangoLayout   // out
	var _cret C.PangoAlignment // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_alignment(_arg0)

	var _alignment Alignment // out

	_alignment = Alignment(_cret)

	return _alignment
}

func (l layout) Attributes() *AttrList {
	var _arg0 *C.PangoLayout   // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_attributes(_arg0)

	var _attrList *AttrList // out

	_attrList = WrapAttrList(unsafe.Pointer(_cret))

	return _attrList
}

func (l layout) AutoDir() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_auto_dir(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (l layout) Baseline() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_baseline(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) CharacterCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.gint         // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_character_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) Context() Context {
	var _arg0 *C.PangoLayout  // out
	var _cret *C.PangoContext // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_context(_arg0)

	var _context Context // out

	_context = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Context)

	return _context
}

func (l layout) CursorPos(index_ int) (strongPos Rectangle, weakPos Rectangle) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _strongPos Rectangle
	var _weakPos Rectangle

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(index_)

	C.pango_layout_get_cursor_pos(_arg0, _arg1, (*C.PangoRectangle)(unsafe.Pointer(&_strongPos)), (*C.PangoRectangle)(unsafe.Pointer(&_weakPos)))

	return _strongPos, _weakPos
}

func (l layout) Direction(index int) Direction {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.int            // out
	var _cret C.PangoDirection // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(index)

	_cret = C.pango_layout_get_direction(_arg0, _arg1)

	var _direction Direction // out

	_direction = Direction(_cret)

	return _direction
}

func (l layout) Ellipsize() EllipsizeMode {
	var _arg0 *C.PangoLayout       // out
	var _cret C.PangoEllipsizeMode // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_ellipsize(_arg0)

	var _ellipsizeMode EllipsizeMode // out

	_ellipsizeMode = EllipsizeMode(_cret)

	return _ellipsizeMode
}

func (l layout) Extents() (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoLayout // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_get_extents(_arg0, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

func (l layout) FontDescription() *FontDescription {
	var _arg0 *C.PangoLayout          // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_font_description(_arg0)

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))

	return _fontDescription
}

func (l layout) Height() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) Indent() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_indent(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) Iter() *LayoutIter {
	var _arg0 *C.PangoLayout     // out
	var _cret *C.PangoLayoutIter // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_iter(_arg0)

	var _layoutIter *LayoutIter // out

	_layoutIter = WrapLayoutIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_layoutIter, func(v *LayoutIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _layoutIter
}

func (l layout) Justify() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_justify(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (l layout) LineCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_line_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) LineSpacing() float32 {
	var _arg0 *C.PangoLayout // out
	var _cret C.float        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_line_spacing(_arg0)

	var _gfloat float32 // out

	_gfloat = (float32)(_cret)

	return _gfloat
}

func (l layout) LogAttrs() []LogAttr {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.PangoLogAttr
	var _arg2 C.gint // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_get_log_attrs(_arg0, &_arg1, &_arg2)

	var _attrs []LogAttr

	_attrs = unsafe.Slice((*LogAttr)(unsafe.Pointer(_arg1)), _arg2)
	runtime.SetFinalizer(&_attrs, func(v *[]LogAttr) {
		C.free(unsafe.Pointer(&(*v)[0]))
	})

	return _attrs
}

func (l layout) PixelExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoLayout // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_get_pixel_extents(_arg0, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

func (l layout) PixelSize() (width int, height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_get_pixel_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

func (l layout) Serial() uint {
	var _arg0 *C.PangoLayout // out
	var _cret C.guint        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_serial(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

func (l layout) SingleParagraphMode() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_single_paragraph_mode(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (l layout) Size() (width int, height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // in
	var _arg2 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	C.pango_layout_get_size(_arg0, &_arg1, &_arg2)

	var _width int  // out
	var _height int // out

	_width = (int)(_arg1)
	_height = (int)(_arg2)

	return _width, _height
}

func (l layout) Spacing() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_spacing(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) Tabs() *TabArray {
	var _arg0 *C.PangoLayout   // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_tabs(_arg0)

	var _tabArray *TabArray // out

	_tabArray = WrapTabArray(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_tabArray, func(v *TabArray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _tabArray
}

func (l layout) Text() string {
	var _arg0 *C.PangoLayout // out
	var _cret *C.char        // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_text(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

func (l layout) UnknownGlyphsCount() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_unknown_glyphs_count(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) Width() int {
	var _arg0 *C.PangoLayout // out
	var _cret C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

func (l layout) Wrap() WrapMode {
	var _arg0 *C.PangoLayout  // out
	var _cret C.PangoWrapMode // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_get_wrap(_arg0)

	var _wrapMode WrapMode // out

	_wrapMode = WrapMode(_cret)

	return _wrapMode
}

func (l layout) IndexToLineX(index_ int, trailing bool) (line int, xPos int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _arg2 C.gboolean     // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(index_)
	if trailing {
		_arg2 = C.TRUE
	}

	C.pango_layout_index_to_line_x(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _line int // out
	var _xPos int // out

	_line = (int)(_arg3)
	_xPos = (int)(_arg4)

	return _line, _xPos
}

func (l layout) IndexToPos(index_ int) Rectangle {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _pos Rectangle

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(index_)

	C.pango_layout_index_to_pos(_arg0, _arg1, (*C.PangoRectangle)(unsafe.Pointer(&_pos)))

	return _pos
}

func (l layout) IsEllipsized() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_is_ellipsized(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (l layout) IsWrapped() bool {
	var _arg0 *C.PangoLayout // out
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))

	_cret = C.pango_layout_is_wrapped(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

func (l layout) MoveCursorVisually(strong bool, oldIndex int, oldTrailing int, direction int) (newIndex int, newTrailing int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out
	var _arg2 C.int          // out
	var _arg3 C.int          // out
	var _arg4 C.int          // out
	var _arg5 C.int          // in
	var _arg6 C.int          // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if strong {
		_arg1 = C.TRUE
	}
	_arg2 = (C.int)(oldIndex)
	_arg3 = (C.int)(oldTrailing)
	_arg4 = (C.int)(direction)

	C.pango_layout_move_cursor_visually(_arg0, _arg1, _arg2, _arg3, _arg4, &_arg5, &_arg6)

	var _newIndex int    // out
	var _newTrailing int // out

	_newIndex = (int)(_arg5)
	_newTrailing = (int)(_arg6)

	return _newIndex, _newTrailing
}

func (l layout) SetAlignment(alignment Alignment) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 C.PangoAlignment // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.PangoAlignment)(alignment)

	C.pango_layout_set_alignment(_arg0, _arg1)
}

func (l layout) SetAttributes(attrs *AttrList) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 *C.PangoAttrList // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(attrs.Native()))

	C.pango_layout_set_attributes(_arg0, _arg1)
}

func (l layout) SetAutoDir(autoDir bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if autoDir {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_auto_dir(_arg0, _arg1)
}

func (l layout) SetEllipsize(ellipsize EllipsizeMode) {
	var _arg0 *C.PangoLayout       // out
	var _arg1 C.PangoEllipsizeMode // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.PangoEllipsizeMode)(ellipsize)

	C.pango_layout_set_ellipsize(_arg0, _arg1)
}

func (l layout) SetFontDescription(desc *FontDescription) {
	var _arg0 *C.PangoLayout          // out
	var _arg1 *C.PangoFontDescription // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(desc.Native()))

	C.pango_layout_set_font_description(_arg0, _arg1)
}

func (l layout) SetHeight(height int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(height)

	C.pango_layout_set_height(_arg0, _arg1)
}

func (l layout) SetIndent(indent int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(indent)

	C.pango_layout_set_indent(_arg0, _arg1)
}

func (l layout) SetJustify(justify bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if justify {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_justify(_arg0, _arg1)
}

func (l layout) SetLineSpacing(factor float32) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.float        // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.float)(factor)

	C.pango_layout_set_line_spacing(_arg0, _arg1)
}

func (l layout) SetMarkup(markup string, length int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(length)

	C.pango_layout_set_markup(_arg0, _arg1, _arg2)
}

func (l layout) SetMarkupWithAccel(markup string, length int, accelMarker uint32) uint32 {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int          // out
	var _arg3 C.gunichar     // out
	var _arg4 C.gunichar     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(markup))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(length)
	_arg3 = (C.gunichar)(accelMarker)

	C.pango_layout_set_markup_with_accel(_arg0, _arg1, _arg2, _arg3, &_arg4)

	var _accelChar uint32 // out

	_accelChar = (uint32)(_arg4)

	return _accelChar
}

func (l layout) SetSingleParagraphMode(setting bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.gboolean     // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	if setting {
		_arg1 = C.TRUE
	}

	C.pango_layout_set_single_paragraph_mode(_arg0, _arg1)
}

func (l layout) SetSpacing(spacing int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(spacing)

	C.pango_layout_set_spacing(_arg0, _arg1)
}

func (l layout) SetTabs(tabs *TabArray) {
	var _arg0 *C.PangoLayout   // out
	var _arg1 *C.PangoTabArray // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoTabArray)(unsafe.Pointer(tabs.Native()))

	C.pango_layout_set_tabs(_arg0, _arg1)
}

func (l layout) SetText(text string, length int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 *C.char        // out
	var _arg2 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(length)

	C.pango_layout_set_text(_arg0, _arg1, _arg2)
}

func (l layout) SetWidth(width int) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(width)

	C.pango_layout_set_width(_arg0, _arg1)
}

func (l layout) SetWrap(wrap WrapMode) {
	var _arg0 *C.PangoLayout  // out
	var _arg1 C.PangoWrapMode // out

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.PangoWrapMode)(wrap)

	C.pango_layout_set_wrap(_arg0, _arg1)
}

func (l layout) XYToIndex(x int, y int) (index_ int, trailing int, ok bool) {
	var _arg0 *C.PangoLayout // out
	var _arg1 C.int          // out
	var _arg2 C.int          // out
	var _arg3 C.int          // in
	var _arg4 C.int          // in
	var _cret C.gboolean     // in

	_arg0 = (*C.PangoLayout)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)

	_cret = C.pango_layout_xy_to_index(_arg0, _arg1, _arg2, &_arg3, &_arg4)

	var _index_ int   // out
	var _trailing int // out
	var _ok bool      // out

	_index_ = (int)(_arg3)
	_trailing = (int)(_arg4)
	if _cret != 0 {
		_ok = true
	}

	return _index_, _trailing, _ok
}

// Renderer: `PangoRenderer` is a base class for objects that can render text
// provided as `PangoGlyphString` or `PangoLayout`.
//
// By subclassing `PangoRenderer` and overriding operations such as @draw_glyphs
// and @draw_rectangle, renderers for particular font backends and destinations
// can be created.
type Renderer interface {
	gextras.Objector

	// Activate does initial setup before rendering operations on @renderer.
	//
	// [method@Pango.Renderer.deactivate] should be called when done drawing.
	// Calls such as [method@Pango.Renderer.draw_layout] automatically activate
	// the layout before drawing on it. Calls to `pango_renderer_activate()` and
	// `pango_renderer_deactivate()` can be nested and the renderer will only be
	// initialized and deinitialized once.
	Activate()
	// Deactivate cleans up after rendering operations on @renderer.
	//
	// See docs for [method@Pango.Renderer.activate].
	Deactivate()
	// DrawErrorUnderline: draw a squiggly line that approximately covers the
	// given rectangle in the style of an underline used to indicate a spelling
	// error.
	//
	// The width of the underline is rounded to an integer number of up/down
	// segments and the resulting rectangle is centered in the original
	// rectangle.
	//
	// This should be called while @renderer is already active. Use
	// [method@Pango.Renderer.activate] to activate a renderer.
	DrawErrorUnderline(x int, y int, width int, height int)
	// DrawGlyphItem draws the glyphs in @glyph_item with the specified
	// `PangoRenderer`, embedding the text associated with the glyphs in the
	// output if the output format supports it.
	//
	// This is useful for rendering text in PDF.
	//
	// Note that @text is the start of the text for layout, which is then
	// indexed by `glyph_item->item->offset`.
	//
	// If @text is nil, this simply calls [method@Pango.Renderer.draw_glyphs].
	//
	// The default implementation of this method simply falls back to
	// [method@Pango.Renderer.draw_glyphs].
	DrawGlyphItem(text string, glyphItem *GlyphItem, x int, y int)
	// DrawGlyphs draws the glyphs in @glyphs with the specified
	// `PangoRenderer`.
	DrawGlyphs(font Font, glyphs *GlyphString, x int, y int)
	// DrawLayout draws @layout with the specified `PangoRenderer`.
	DrawLayout(layout Layout, x int, y int)
	// DrawRectangle draws an axis-aligned rectangle in user space coordinates
	// with the specified `PangoRenderer`.
	//
	// This should be called while @renderer is already active. Use
	// [method@Pango.Renderer.activate] to activate a renderer.
	DrawRectangle(part RenderPart, x int, y int, width int, height int)
	// DrawTrapezoid draws a trapezoid with the parallel sides aligned with the
	// X axis using the given `PangoRenderer`; coordinates are in device space.
	DrawTrapezoid(part RenderPart, y1 float64, x11 float64, x21 float64, y2 float64, x12 float64, x22 float64)
	// Alpha gets the current alpha for the specified part.
	Alpha(part RenderPart) uint16
	// Color gets the current rendering color for the specified part.
	Color(part RenderPart) *Color
	// Layout gets the layout currently being rendered using @renderer.
	//
	// Calling this function only makes sense from inside a subclass's methods,
	// like in its draw_shape vfunc, for example.
	//
	// The returned layout should not be modified while still being rendered.
	Layout() Layout
	// Matrix gets the transformation matrix that will be applied when
	// rendering.
	//
	// See [method@Pango.Renderer.set_matrix].
	Matrix() *Matrix
	// PartChanged informs Pango that the way that the rendering is done for
	// @part has changed.
	//
	// This should be called if the rendering changes in a way that would
	// prevent multiple pieces being joined together into one drawing call. For
	// instance, if a subclass of `PangoRenderer` was to add a stipple option
	// for drawing underlines, it needs to call
	//
	// ` pango_renderer_part_changed (render, PANGO_RENDER_PART_UNDERLINE); `
	//
	// When the stipple changes or underlines with different stipples might be
	// joined together. Pango automatically calls this for changes to colors.
	// (See [method@Pango.Renderer.set_color])
	PartChanged(part RenderPart)
	// SetAlpha sets the alpha for part of the rendering.
	//
	// Note that the alpha may only be used if a color is specified for @part as
	// well.
	SetAlpha(part RenderPart, alpha uint16)
	// SetColor sets the color for part of the rendering.
	//
	// Also see [method@Pango.Renderer.set_alpha].
	SetColor(part RenderPart, color *Color)
	// SetMatrix sets the transformation matrix that will be applied when
	// rendering.
	SetMatrix(matrix *Matrix)
}

// renderer implements the Renderer class.
type renderer struct {
	gextras.Objector
}

var _ Renderer = (*renderer)(nil)

// WrapRenderer wraps a GObject to the right type. It is
// primarily used internally.
func WrapRenderer(obj *externglib.Object) Renderer {
	return renderer{
		Objector: obj,
	}
}

func marshalRenderer(p uintptr) (interface{}, error) {
	val := C.g_value_get_object((*C.GValue)(unsafe.Pointer(p)))
	obj := externglib.Take(unsafe.Pointer(val))
	return WrapRenderer(obj), nil
}

func (r renderer) Activate() {
	var _arg0 *C.PangoRenderer // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))

	C.pango_renderer_activate(_arg0)
}

func (r renderer) Deactivate() {
	var _arg0 *C.PangoRenderer // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))

	C.pango_renderer_deactivate(_arg0)
}

func (r renderer) DrawErrorUnderline(x int, y int, width int, height int) {
	var _arg0 *C.PangoRenderer // out
	var _arg1 C.int            // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out
	var _arg4 C.int            // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.int)(x)
	_arg2 = (C.int)(y)
	_arg3 = (C.int)(width)
	_arg4 = (C.int)(height)

	C.pango_renderer_draw_error_underline(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (r renderer) DrawGlyphItem(text string, glyphItem *GlyphItem, x int, y int) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 *C.char           // out
	var _arg2 *C.PangoGlyphItem // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.PangoGlyphItem)(unsafe.Pointer(glyphItem.Native()))
	_arg3 = (C.int)(x)
	_arg4 = (C.int)(y)

	C.pango_renderer_draw_glyph_item(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (r renderer) DrawGlyphs(font Font, glyphs *GlyphString, x int, y int) {
	var _arg0 *C.PangoRenderer    // out
	var _arg1 *C.PangoFont        // out
	var _arg2 *C.PangoGlyphString // out
	var _arg3 C.int               // out
	var _arg4 C.int               // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))
	_arg2 = (*C.PangoGlyphString)(unsafe.Pointer(glyphs.Native()))
	_arg3 = (C.int)(x)
	_arg4 = (C.int)(y)

	C.pango_renderer_draw_glyphs(_arg0, _arg1, _arg2, _arg3, _arg4)
}

func (r renderer) DrawLayout(layout Layout, x int, y int) {
	var _arg0 *C.PangoRenderer // out
	var _arg1 *C.PangoLayout   // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.PangoLayout)(unsafe.Pointer(layout.Native()))
	_arg2 = (C.int)(x)
	_arg3 = (C.int)(y)

	C.pango_renderer_draw_layout(_arg0, _arg1, _arg2, _arg3)
}

func (r renderer) DrawRectangle(part RenderPart, x int, y int, width int, height int) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.int             // out
	var _arg3 C.int             // out
	var _arg4 C.int             // out
	var _arg5 C.int             // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.PangoRenderPart)(part)
	_arg2 = (C.int)(x)
	_arg3 = (C.int)(y)
	_arg4 = (C.int)(width)
	_arg5 = (C.int)(height)

	C.pango_renderer_draw_rectangle(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5)
}

func (r renderer) DrawTrapezoid(part RenderPart, y1 float64, x11 float64, x21 float64, y2 float64, x12 float64, x22 float64) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.double          // out
	var _arg3 C.double          // out
	var _arg4 C.double          // out
	var _arg5 C.double          // out
	var _arg6 C.double          // out
	var _arg7 C.double          // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.PangoRenderPart)(part)
	_arg2 = (C.double)(y1)
	_arg3 = (C.double)(x11)
	_arg4 = (C.double)(x21)
	_arg5 = (C.double)(y2)
	_arg6 = (C.double)(x12)
	_arg7 = (C.double)(x22)

	C.pango_renderer_draw_trapezoid(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7)
}

func (r renderer) Alpha(part RenderPart) uint16 {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _cret C.guint16         // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.PangoRenderPart)(part)

	_cret = C.pango_renderer_get_alpha(_arg0, _arg1)

	var _guint16 uint16 // out

	_guint16 = (uint16)(_cret)

	return _guint16
}

func (r renderer) Color(part RenderPart) *Color {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _cret *C.PangoColor     // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.PangoRenderPart)(part)

	_cret = C.pango_renderer_get_color(_arg0, _arg1)

	var _color *Color // out

	_color = WrapColor(unsafe.Pointer(_cret))

	return _color
}

func (r renderer) Layout() Layout {
	var _arg0 *C.PangoRenderer // out
	var _cret *C.PangoLayout   // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))

	_cret = C.pango_renderer_get_layout(_arg0)

	var _layout Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Layout)

	return _layout
}

func (r renderer) Matrix() *Matrix {
	var _arg0 *C.PangoRenderer // out
	var _cret *C.PangoMatrix   // in

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))

	_cret = C.pango_renderer_get_matrix(_arg0)

	var _matrix *Matrix // out

	_matrix = WrapMatrix(unsafe.Pointer(_cret))

	return _matrix
}

func (r renderer) PartChanged(part RenderPart) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.PangoRenderPart)(part)

	C.pango_renderer_part_changed(_arg0, _arg1)
}

func (r renderer) SetAlpha(part RenderPart, alpha uint16) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 C.guint16         // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.PangoRenderPart)(part)
	_arg2 = (C.guint16)(alpha)

	C.pango_renderer_set_alpha(_arg0, _arg1, _arg2)
}

func (r renderer) SetColor(part RenderPart, color *Color) {
	var _arg0 *C.PangoRenderer  // out
	var _arg1 C.PangoRenderPart // out
	var _arg2 *C.PangoColor     // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (C.PangoRenderPart)(part)
	_arg2 = (*C.PangoColor)(unsafe.Pointer(color.Native()))

	C.pango_renderer_set_color(_arg0, _arg1, _arg2)
}

func (r renderer) SetMatrix(matrix *Matrix) {
	var _arg0 *C.PangoRenderer // out
	var _arg1 *C.PangoMatrix   // out

	_arg0 = (*C.PangoRenderer)(unsafe.Pointer(r.Native()))
	_arg1 = (*C.PangoMatrix)(unsafe.Pointer(matrix.Native()))

	C.pango_renderer_set_matrix(_arg0, _arg1)
}

// AttrColor: the `PangoAttrColor` structure is used to represent attributes
// that are colors.
type AttrColor struct {
	native C.PangoAttrColor
}

// WrapAttrColor wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrColor(ptr unsafe.Pointer) *AttrColor {
	if ptr == nil {
		return nil
	}

	return (*AttrColor)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrColor) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrFloat: the `PangoAttrFloat` structure is used to represent attributes
// with a float or double value.
type AttrFloat struct {
	native C.PangoAttrFloat
}

// WrapAttrFloat wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrFloat(ptr unsafe.Pointer) *AttrFloat {
	if ptr == nil {
		return nil
	}

	return (*AttrFloat)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrFloat) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrFontDesc: the `PangoAttrFontDesc` structure is used to store an attribute
// that sets all aspects of the font description at once.
type AttrFontDesc struct {
	native C.PangoAttrFontDesc
}

// WrapAttrFontDesc wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrFontDesc(ptr unsafe.Pointer) *AttrFontDesc {
	if ptr == nil {
		return nil
	}

	return (*AttrFontDesc)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrFontDesc) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrFontFeatures: the `PangoAttrFontFeatures` structure is used to represent
// OpenType font features as an attribute.
type AttrFontFeatures struct {
	native C.PangoAttrFontFeatures
}

// WrapAttrFontFeatures wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrFontFeatures(ptr unsafe.Pointer) *AttrFontFeatures {
	if ptr == nil {
		return nil
	}

	return (*AttrFontFeatures)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrFontFeatures) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrInt: the `PangoAttrInt` structure is used to represent attributes with an
// integer or enumeration value.
type AttrInt struct {
	native C.PangoAttrInt
}

// WrapAttrInt wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrInt(ptr unsafe.Pointer) *AttrInt {
	if ptr == nil {
		return nil
	}

	return (*AttrInt)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrInt) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrIterator: a `PangoAttrIterator` is used to iterate through a
// `PangoAttrList`.
//
// A new iterator is created with [method@Pango.AttrList.get_iterator]. Once the
// iterator is created, it can be advanced through the style changes in the text
// using [method@Pango.AttrIterator.next]. At each style change, the range of
// the current style segment and the attributes currently in effect can be
// queried.
type AttrIterator struct {
	native C.PangoAttrIterator
}

// WrapAttrIterator wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrIterator(ptr unsafe.Pointer) *AttrIterator {
	if ptr == nil {
		return nil
	}

	return (*AttrIterator)(ptr)
}

func marshalAttrIterator(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrIterator(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *AttrIterator) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Copy: copy a `PangoAttrIterator`.
func (i *AttrIterator) Copy() *AttrIterator {
	var _arg0 *C.PangoAttrIterator // out
	var _cret *C.PangoAttrIterator // in

	_arg0 = (*C.PangoAttrIterator)(unsafe.Pointer(i.Native()))

	_cret = C.pango_attr_iterator_copy(_arg0)

	var _attrIterator *AttrIterator // out

	_attrIterator = WrapAttrIterator(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attrIterator, func(v *AttrIterator) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attrIterator
}

// Destroy: destroy a `PangoAttrIterator` and free all associated memory.
func (i *AttrIterator) Destroy() {
	var _arg0 *C.PangoAttrIterator // out

	_arg0 = (*C.PangoAttrIterator)(unsafe.Pointer(i.Native()))

	C.pango_attr_iterator_destroy(_arg0)
}

// Get: find the current attribute of a particular type at the iterator
// location. When multiple attributes of the same type overlap, the attribute
// whose range starts closest to the current location is used.
func (i *AttrIterator) Get(typ AttrType) *Attribute {
	var _arg0 *C.PangoAttrIterator // out
	var _arg1 C.PangoAttrType      // out
	var _cret *C.PangoAttribute    // in

	_arg0 = (*C.PangoAttrIterator)(unsafe.Pointer(i.Native()))
	_arg1 = (C.PangoAttrType)(typ)

	_cret = C.pango_attr_iterator_get(_arg0, _arg1)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))

	return _attribute
}

// Next: advance the iterator until the next change of style.
func (i *AttrIterator) Next() bool {
	var _arg0 *C.PangoAttrIterator // out
	var _cret C.gboolean           // in

	_arg0 = (*C.PangoAttrIterator)(unsafe.Pointer(i.Native()))

	_cret = C.pango_attr_iterator_next(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Range: get the range of the current segment. Note that the stored return
// values are signed, not unsigned like the values in `PangoAttribute`. To deal
// with this API oversight, stored return values that wouldn't fit into a signed
// integer are clamped to G_MAXINT.
func (i *AttrIterator) Range() (start int, end int) {
	var _arg0 *C.PangoAttrIterator // out
	var _arg1 C.gint               // in
	var _arg2 C.gint               // in

	_arg0 = (*C.PangoAttrIterator)(unsafe.Pointer(i.Native()))

	C.pango_attr_iterator_range(_arg0, &_arg1, &_arg2)

	var _start int // out
	var _end int   // out

	_start = (int)(_arg1)
	_end = (int)(_arg2)

	return _start, _end
}

// AttrLanguage: the `PangoAttrLanguage` structure is used to represent
// attributes that are languages.
type AttrLanguage struct {
	native C.PangoAttrLanguage
}

// WrapAttrLanguage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrLanguage(ptr unsafe.Pointer) *AttrLanguage {
	if ptr == nil {
		return nil
	}

	return (*AttrLanguage)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrLanguage) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrList: a `PangoAttrList` represents a list of attributes that apply to a
// section of text.
//
// The attributes in a `PangoAttrList` are, in general, allowed to overlap in an
// arbitrary fashion. However, if the attributes are manipulated only through
// [method@Pango.AttrList.change], the overlap between properties will meet
// stricter criteria.
//
// Since the `PangoAttrList` structure is stored as a linear list, it is not
// suitable for storing attributes for large amounts of text. In general, you
// should not use a single `PangoAttrList` for more than one paragraph of text.
type AttrList struct {
	native C.PangoAttrList
}

// WrapAttrList wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrList(ptr unsafe.Pointer) *AttrList {
	if ptr == nil {
		return nil
	}

	return (*AttrList)(ptr)
}

func marshalAttrList(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttrList(unsafe.Pointer(b)), nil
}

// NewAttrList constructs a struct AttrList.
func NewAttrList() *AttrList {
	var _cret *C.PangoAttrList // in

	_cret = C.pango_attr_list_new()

	var _attrList *AttrList // out

	_attrList = WrapAttrList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attrList, func(v *AttrList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attrList
}

// Native returns the underlying C source pointer.
func (a *AttrList) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Change: insert the given attribute into the `PangoAttrList`.
//
// It will replace any attributes of the same type on that segment and be merged
// with any adjoining attributes that are identical.
//
// This function is slower than [method@Pango.AttrList.insert] for creating an
// attribute list in order (potentially much slower for large lists). However,
// [method@Pango.AttrList.insert] is not suitable for continually changing a set
// of attributes since it never removes or combines existing attributes.
func (l *AttrList) Change(attr *Attribute) {
	var _arg0 *C.PangoAttrList  // out
	var _arg1 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoAttribute)(unsafe.Pointer(attr.Native()))

	C.pango_attr_list_change(_arg0, _arg1)
}

// Copy: copy @list and return an identical new list.
func (l *AttrList) Copy() *AttrList {
	var _arg0 *C.PangoAttrList // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))

	_cret = C.pango_attr_list_copy(_arg0)

	var _attrList *AttrList // out

	_attrList = WrapAttrList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attrList, func(v *AttrList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attrList
}

// Equal checks whether @list and @other_list contain the same attributes and
// whether those attributes apply to the same ranges. Beware that this will
// return wrong values if any list contains duplicates.
func (l *AttrList) Equal(otherList *AttrList) bool {
	var _arg0 *C.PangoAttrList // out
	var _arg1 *C.PangoAttrList // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(otherList.Native()))

	_cret = C.pango_attr_list_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Iterator: create a iterator initialized to the beginning of the list. @list
// must not be modified until this iterator is freed.
func (l *AttrList) Iterator() *AttrIterator {
	var _arg0 *C.PangoAttrList     // out
	var _cret *C.PangoAttrIterator // in

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))

	_cret = C.pango_attr_list_get_iterator(_arg0)

	var _attrIterator *AttrIterator // out

	_attrIterator = WrapAttrIterator(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attrIterator, func(v *AttrIterator) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attrIterator
}

// Insert: insert the given attribute into the `PangoAttrList`.
//
// It will be inserted after all other attributes with a matching @start_index.
func (l *AttrList) Insert(attr *Attribute) {
	var _arg0 *C.PangoAttrList  // out
	var _arg1 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoAttribute)(unsafe.Pointer(attr.Native()))

	C.pango_attr_list_insert(_arg0, _arg1)
}

// InsertBefore: insert the given attribute into the `PangoAttrList`.
//
// It will be inserted before all other attributes with a matching @start_index.
func (l *AttrList) InsertBefore(attr *Attribute) {
	var _arg0 *C.PangoAttrList  // out
	var _arg1 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoAttribute)(unsafe.Pointer(attr.Native()))

	C.pango_attr_list_insert_before(_arg0, _arg1)
}

// Ref: increase the reference count of the given attribute list by one.
func (l *AttrList) Ref() *AttrList {
	var _arg0 *C.PangoAttrList // out
	var _cret *C.PangoAttrList // in

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))

	_cret = C.pango_attr_list_ref(_arg0)

	var _attrList *AttrList // out

	_attrList = WrapAttrList(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attrList, func(v *AttrList) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attrList
}

// Splice: this function opens up a hole in @list, fills it in with attributes
// from the left, and then merges @other on top of the hole.
//
// This operation is equivalent to stretching every attribute that applies at
// position @pos in @list by an amount @len, and then calling
// [method@Pango.AttrList.change] with a copy of each attribute in @other in
// sequence (offset in position by @pos).
//
// This operation proves useful for, for instance, inserting a pre-edit string
// in the middle of an edit buffer.
func (l *AttrList) Splice(other *AttrList, pos int, len int) {
	var _arg0 *C.PangoAttrList // out
	var _arg1 *C.PangoAttrList // out
	var _arg2 C.gint           // out
	var _arg3 C.gint           // out

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.PangoAttrList)(unsafe.Pointer(other.Native()))
	_arg2 = (C.gint)(pos)
	_arg3 = (C.gint)(len)

	C.pango_attr_list_splice(_arg0, _arg1, _arg2, _arg3)
}

// Unref: decrease the reference count of the given attribute list by one. If
// the result is zero, free the attribute list and the attributes it contains.
func (l *AttrList) Unref() {
	var _arg0 *C.PangoAttrList // out

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))

	C.pango_attr_list_unref(_arg0)
}

// Update: update indices of attributes in @list for a change in the text they
// refer to.
//
// The change that this function applies is removing @remove bytes at position
// @pos and inserting @add bytes instead.
//
// Attributes that fall entirely in the (@pos, @pos + @remove) range are
// removed.
//
// Attributes that start or end inside the (@pos, @pos + @remove) range are
// shortened to reflect the removal.
//
// Attributes start and end positions are updated if they are behind @pos +
// @remove.
func (l *AttrList) Update(pos int, remove int, add int) {
	var _arg0 *C.PangoAttrList // out
	var _arg1 C.int            // out
	var _arg2 C.int            // out
	var _arg3 C.int            // out

	_arg0 = (*C.PangoAttrList)(unsafe.Pointer(l.Native()))
	_arg1 = (C.int)(pos)
	_arg2 = (C.int)(remove)
	_arg3 = (C.int)(add)

	C.pango_attr_list_update(_arg0, _arg1, _arg2, _arg3)
}

// AttrShape: the `PangoAttrShape` structure is used to represent attributes
// which impose shape restrictions.
type AttrShape struct {
	native C.PangoAttrShape
}

// WrapAttrShape wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrShape(ptr unsafe.Pointer) *AttrShape {
	if ptr == nil {
		return nil
	}

	return (*AttrShape)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrShape) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrSize: the `PangoAttrSize` structure is used to represent attributes which
// set font size.
type AttrSize struct {
	native C.PangoAttrSize
}

// WrapAttrSize wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrSize(ptr unsafe.Pointer) *AttrSize {
	if ptr == nil {
		return nil
	}

	return (*AttrSize)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrSize) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// AttrString: the `PangoAttrString` structure is used to represent attributes
// with a string value.
type AttrString struct {
	native C.PangoAttrString
}

// WrapAttrString wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttrString(ptr unsafe.Pointer) *AttrString {
	if ptr == nil {
		return nil
	}

	return (*AttrString)(ptr)
}

// Native returns the underlying C source pointer.
func (a *AttrString) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Attribute: the `PangoAttribute` structure represents the common portions of
// all attributes.
//
// Particular types of attributes include this structure as their initial
// portion. The common portion of the attribute holds the range to which the
// value in the type-specific part of the attribute applies and should be
// initialized using [method@Pango.Attribute.init]. By default, an attribute
// will have an all-inclusive range of [0,G_MAXUINT].
type Attribute struct {
	native C.PangoAttribute
}

// WrapAttribute wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapAttribute(ptr unsafe.Pointer) *Attribute {
	if ptr == nil {
		return nil
	}

	return (*Attribute)(ptr)
}

func marshalAttribute(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapAttribute(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (a *Attribute) Native() unsafe.Pointer {
	return unsafe.Pointer(&a.native)
}

// Copy: make a copy of an attribute.
func (a *Attribute) Copy() *Attribute {
	var _arg0 *C.PangoAttribute // out
	var _cret *C.PangoAttribute // in

	_arg0 = (*C.PangoAttribute)(unsafe.Pointer(a.Native()))

	_cret = C.pango_attribute_copy(_arg0)

	var _attribute *Attribute // out

	_attribute = WrapAttribute(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_attribute, func(v *Attribute) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _attribute
}

// Destroy: destroy a `PangoAttribute` and free all associated memory.
func (a *Attribute) Destroy() {
	var _arg0 *C.PangoAttribute // out

	_arg0 = (*C.PangoAttribute)(unsafe.Pointer(a.Native()))

	C.pango_attribute_destroy(_arg0)
}

// Equal: compare two attributes for equality. This compares only the actual
// value of the two attributes and not the ranges that the attributes apply to.
func (a *Attribute) Equal(attr2 *Attribute) bool {
	var _arg0 *C.PangoAttribute // out
	var _arg1 *C.PangoAttribute // out
	var _cret C.gboolean        // in

	_arg0 = (*C.PangoAttribute)(unsafe.Pointer(a.Native()))
	_arg1 = (*C.PangoAttribute)(unsafe.Pointer(attr2.Native()))

	_cret = C.pango_attribute_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Color: the `PangoColor` structure is used to represent a color in an
// uncalibrated RGB color-space.
type Color struct {
	native C.PangoColor
}

// WrapColor wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapColor(ptr unsafe.Pointer) *Color {
	if ptr == nil {
		return nil
	}

	return (*Color)(ptr)
}

func marshalColor(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapColor(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (c *Color) Native() unsafe.Pointer {
	return unsafe.Pointer(&c.native)
}

// Copy creates a copy of @src.
//
// The copy should be freed with pango_color_free(). Primarily used by language
// bindings, not that useful otherwise (since colors can just be copied by
// assignment in C).
func (s *Color) Copy() *Color {
	var _arg0 *C.PangoColor // out
	var _cret *C.PangoColor // in

	_arg0 = (*C.PangoColor)(unsafe.Pointer(s.Native()))

	_cret = C.pango_color_copy(_arg0)

	var _color *Color // out

	_color = WrapColor(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_color, func(v *Color) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _color
}

// Free frees a color allocated by pango_color_copy().
func (c *Color) Free() {
	var _arg0 *C.PangoColor // out

	_arg0 = (*C.PangoColor)(unsafe.Pointer(c.Native()))

	C.pango_color_free(_arg0)
}

// Parse: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors), or
// it can be a value in the form `#rgb`, `#rrggbb`, `#rrrgggbbb` or
// `#rrrrggggbbbb`, where `r`, `g` and `b` are hex digits of the red, green, and
// blue components of the color, respectively. (White in the four forms is
// `#fff`, `#ffffff`, `#fffffffff` and `#ffffffffffff`.)
func (c *Color) Parse(spec string) bool {
	var _arg0 *C.PangoColor // out
	var _arg1 *C.char       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.PangoColor)(unsafe.Pointer(c.Native()))
	_arg1 = (*C.char)(C.CString(spec))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_color_parse(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// ParseWithAlpha: fill in the fields of a color from a string specification.
//
// The string can either one of a large set of standard names. (Taken from the
// CSS Color specification (https://www.w3.org/TR/css-color-4/#named-colors), or
// it can be a hexadecimal value in the form `#rgb`, `#rrggbb`, `#rrrgggbbb` or
// `#rrrrggggbbbb` where `r`, `g` and `b` are hex digits of the red, green, and
// blue components of the color, respectively. (White in the four forms is
// `#fff`, `#ffffff`, `#fffffffff` and `#ffffffffffff`.)
//
// Additionally, parse strings of the form `#rgba`, `#rrggbbaa`,
// `#rrrrggggbbbbaaaa`, if @alpha is not nil, and set @alpha to the value
// specified by the hex digits for `a`. If no alpha component is found in @spec,
// @alpha is set to 0xffff (for a solid color).
func (c *Color) ParseWithAlpha(spec string) (uint16, bool) {
	var _arg0 *C.PangoColor // out
	var _arg1 C.guint16     // in
	var _arg2 *C.char       // out
	var _cret C.gboolean    // in

	_arg0 = (*C.PangoColor)(unsafe.Pointer(c.Native()))
	_arg2 = (*C.char)(C.CString(spec))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.pango_color_parse_with_alpha(_arg0, &_arg1, _arg2)

	var _alpha uint16 // out
	var _ok bool      // out

	_alpha = (uint16)(_arg1)
	if _cret != 0 {
		_ok = true
	}

	return _alpha, _ok
}

// String returns a textual specification of @color.
//
// The string is in the hexadecimal form `#rrrrggggbbbb`, where `r`, `g` and `b`
// are hex digits representing the red, green, and blue components respectively.
func (c *Color) String() string {
	var _arg0 *C.PangoColor // out
	var _cret *C.gchar      // in

	_arg0 = (*C.PangoColor)(unsafe.Pointer(c.Native()))

	_cret = C.pango_color_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// FontDescription: a `PangoFontDescription` describes a font in an
// implementation-independent manner.
//
// `PangoFontDescription` structures are used both to list what fonts are
// available on the system and also for specifying the characteristics of a font
// to load.
type FontDescription struct {
	native C.PangoFontDescription
}

// WrapFontDescription wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontDescription(ptr unsafe.Pointer) *FontDescription {
	if ptr == nil {
		return nil
	}

	return (*FontDescription)(ptr)
}

func marshalFontDescription(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontDescription(unsafe.Pointer(b)), nil
}

// NewFontDescription constructs a struct FontDescription.
func NewFontDescription() *FontDescription {
	var _cret *C.PangoFontDescription // in

	_cret = C.pango_font_description_new()

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

// Native returns the underlying C source pointer.
func (f *FontDescription) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// BetterMatch determines if the style attributes of @new_match are a closer
// match for @desc than those of @old_match are, or if @old_match is nil,
// determines if @new_match is a match at all.
//
// Approximate matching is done for weight and style; other style attributes
// must match exactly. Style attributes are all attributes other than family and
// size-related attributes. Approximate matching for style considers
// PANGO_STYLE_OBLIQUE and PANGO_STYLE_ITALIC as matches, but not as good a
// match as when the styles are equal.
//
// Note that @old_match must match @desc.
func (d *FontDescription) BetterMatch(oldMatch *FontDescription, newMatch *FontDescription) bool {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 *C.PangoFontDescription // out
	var _cret C.gboolean              // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(oldMatch.Native()))
	_arg2 = (*C.PangoFontDescription)(unsafe.Pointer(newMatch.Native()))

	_cret = C.pango_font_description_better_match(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy: make a copy of a `PangoFontDescription`.
func (d *FontDescription) Copy() *FontDescription {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_copy(_arg0)

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

// CopyStatic: make a copy of a `PangoFontDescription`, but don't duplicate
// allocated fields.
//
// This is like [method@Pango.FontDescription.copy], but only a shallow copy is
// made of the family name and other allocated fields. The result can only be
// used until @desc is modified or freed. This is meant to be used when the copy
// is only needed temporarily.
func (d *FontDescription) CopyStatic() *FontDescription {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.PangoFontDescription // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_copy_static(_arg0)

	var _fontDescription *FontDescription // out

	_fontDescription = WrapFontDescription(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontDescription, func(v *FontDescription) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontDescription
}

// Equal compares two font descriptions for equality.
//
// Two font descriptions are considered equal if the fonts they describe are
// provably identical. This means that their masks do not have to match, as long
// as other fields are all the same. (Two font descriptions may result in
// identical fonts being loaded, but still compare false.)
func (d *FontDescription) Equal(desc2 *FontDescription) bool {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _cret C.gboolean              // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(desc2.Native()))

	_cret = C.pango_font_description_equal(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Free frees a font description.
func (d *FontDescription) Free() {
	var _arg0 *C.PangoFontDescription // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	C.pango_font_description_free(_arg0)
}

// Family gets the family name field of a font description.
//
// See [method@Pango.FontDescription.set_family].
func (d *FontDescription) Family() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_family(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Gravity gets the gravity field of a font description.
//
// See [method@Pango.FontDescription.set_gravity].
func (d *FontDescription) Gravity() Gravity {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoGravity          // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_gravity(_arg0)

	var _gravity Gravity // out

	_gravity = Gravity(_cret)

	return _gravity
}

// SetFields determines which fields in a font description have been set.
func (d *FontDescription) SetFields() FontMask {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoFontMask         // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_set_fields(_arg0)

	var _fontMask FontMask // out

	_fontMask = FontMask(_cret)

	return _fontMask
}

// Size gets the size field of a font description.
//
// See [method@Pango.FontDescription.set_size].
func (d *FontDescription) Size() int {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.gint                  // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SizeIsAbsolute determines whether the size of the font is in points (not
// absolute) or device units (absolute).
//
// See [method@Pango.FontDescription.set_size] and
// [method@Pango.FontDescription.set_absolute_size].
func (d *FontDescription) SizeIsAbsolute() bool {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.gboolean              // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_size_is_absolute(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Stretch gets the stretch field of a font description.
//
// See [method@Pango.FontDescription.set_stretch].
func (d *FontDescription) Stretch() Stretch {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoStretch          // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_stretch(_arg0)

	var _stretch Stretch // out

	_stretch = Stretch(_cret)

	return _stretch
}

// Style gets the style field of a `PangoFontDescription`.
//
// See [method@Pango.FontDescription.set_style].
func (d *FontDescription) Style() Style {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoStyle            // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_style(_arg0)

	var _style Style // out

	_style = Style(_cret)

	return _style
}

// Variant gets the variant field of a `PangoFontDescription`.
//
// See [method@Pango.FontDescription.set_variant].
func (d *FontDescription) Variant() Variant {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoVariant          // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_variant(_arg0)

	var _variant Variant // out

	_variant = Variant(_cret)

	return _variant
}

// Variations gets the variations field of a font description.
//
// See [method@Pango.FontDescription.set_variations].
func (d *FontDescription) Variations() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_variations(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// Weight gets the weight field of a font description.
//
// See [method@Pango.FontDescription.set_weight].
func (d *FontDescription) Weight() Weight {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.PangoWeight           // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_get_weight(_arg0)

	var _weight Weight // out

	_weight = Weight(_cret)

	return _weight
}

// Hash computes a hash of a `PangoFontDescription` structure.
//
// This is suitable to be used, for example, as an argument to
// g_hash_table_new(). The hash value is independent of @desc->mask.
func (d *FontDescription) Hash() uint {
	var _arg0 *C.PangoFontDescription // out
	var _cret C.guint                 // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_hash(_arg0)

	var _guint uint // out

	_guint = (uint)(_cret)

	return _guint
}

// Merge merges the fields that are set in @desc_to_merge into the fields in
// @desc.
//
// If @replace_existing is false, only fields in @desc that are not already set
// are affected. If true, then fields that are already set will be replaced as
// well.
//
// If @desc_to_merge is nil, this function performs nothing.
func (d *FontDescription) Merge(descToMerge *FontDescription, replaceExisting bool) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 C.gboolean              // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(descToMerge.Native()))
	if replaceExisting {
		_arg2 = C.TRUE
	}

	C.pango_font_description_merge(_arg0, _arg1, _arg2)
}

// MergeStatic merges the fields that are set in @desc_to_merge into the fields
// in @desc, without copying allocated fields.
//
// This is like [method@Pango.FontDescription.merge], but only a shallow copy is
// made of the family name and other allocated fields. @desc can only be used
// until @desc_to_merge is modified or freed. This is meant to be used when the
// merged font description is only needed temporarily.
func (d *FontDescription) MergeStatic(descToMerge *FontDescription, replaceExisting bool) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.PangoFontDescription // out
	var _arg2 C.gboolean              // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.PangoFontDescription)(unsafe.Pointer(descToMerge.Native()))
	if replaceExisting {
		_arg2 = C.TRUE
	}

	C.pango_font_description_merge_static(_arg0, _arg1, _arg2)
}

// SetAbsoluteSize sets the size field of a font description, in device units.
//
// This is mutually exclusive with [method@Pango.FontDescription.set_size] which
// sets the font size in points.
func (d *FontDescription) SetAbsoluteSize(size float64) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.double                // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.double)(size)

	C.pango_font_description_set_absolute_size(_arg0, _arg1)
}

// SetFamily sets the family name field of a font description.
//
// The family name represents a family of related font styles, and will resolve
// to a particular `PangoFontFamily`. In some uses of `PangoFontDescription`, it
// is also possible to use a comma separated list of family names for this
// field.
func (d *FontDescription) SetFamily(family string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(family))
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_font_description_set_family(_arg0, _arg1)
}

// SetFamilyStatic sets the family name field of a font description, without
// copying the string.
//
// This is like [method@Pango.FontDescription.set_family], except that no copy
// of @family is made. The caller must make sure that the string passed in stays
// around until @desc has been freed or the name is set again. This function can
// be used if @family is a static string such as a C string literal, or if @desc
// is only needed temporarily.
func (d *FontDescription) SetFamilyStatic(family string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(family))
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_font_description_set_family_static(_arg0, _arg1)
}

// SetGravity sets the gravity field of a font description.
//
// The gravity field specifies how the glyphs should be rotated. If @gravity is
// PANGO_GRAVITY_AUTO, this actually unsets the gravity mask on the font
// description.
//
// This function is seldom useful to the user. Gravity should normally be set on
// a `PangoContext`.
func (d *FontDescription) SetGravity(gravity Gravity) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoGravity          // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.PangoGravity)(gravity)

	C.pango_font_description_set_gravity(_arg0, _arg1)
}

// SetSize sets the size field of a font description in fractional points.
//
// This is mutually exclusive with
// [method@Pango.FontDescription.set_absolute_size].
func (d *FontDescription) SetSize(size int) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.gint                  // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.gint)(size)

	C.pango_font_description_set_size(_arg0, _arg1)
}

// SetStretch sets the stretch field of a font description.
//
// The [enum@Pango.Stretch] field specifies how narrow or wide the font should
// be.
func (d *FontDescription) SetStretch(stretch Stretch) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoStretch          // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.PangoStretch)(stretch)

	C.pango_font_description_set_stretch(_arg0, _arg1)
}

// SetStyle sets the style field of a `PangoFontDescription`.
//
// The [enum@Pango.Style] enumeration describes whether the font is slanted and
// the manner in which it is slanted; it can be either NGO_STYLE_NORMAL,
// NGO_STYLE_ITALIC, or NGO_STYLE_OBLIQUE.
//
// Most fonts will either have a italic style or an oblique style, but not both,
// and font matching in Pango will match italic specifications with oblique
// fonts and vice-versa if an exact match is not found.
func (d *FontDescription) SetStyle(style Style) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoStyle            // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.PangoStyle)(style)

	C.pango_font_description_set_style(_arg0, _arg1)
}

// SetVariant sets the variant field of a font description.
//
// The [enum@Pango.Variant] can either be PANGO_VARIANT_NORMAL or
// PANGO_VARIANT_SMALL_CAPS.
func (d *FontDescription) SetVariant(variant Variant) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoVariant          // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.PangoVariant)(variant)

	C.pango_font_description_set_variant(_arg0, _arg1)
}

// SetVariations sets the variations field of a font description.
//
// OpenType font variations allow to select a font instance by specifying values
// for a number of axes, such as width or weight.
//
// The format of the variations string is
//
//    AXIS1=VALUE,AXIS2=VALUE...
//
// with each AXIS a 4 character tag that identifies a font axis, and each VALUE
// a floating point number. Unknown axes are ignored, and values are clamped to
// their allowed range.
//
// Pango does not currently have a way to find supported axes of a font. Both
// harfbuzz or freetype have API for this.
func (d *FontDescription) SetVariations(variations string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(variations))
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_font_description_set_variations(_arg0, _arg1)
}

// SetVariationsStatic sets the variations field of a font description.
//
// This is like [method@Pango.FontDescription.set_variations], except that no
// copy of @variations is made. The caller must make sure that the string passed
// in stays around until @desc has been freed or the name is set again. This
// function can be used if @variations is a static string such as a C string
// literal, or if @desc is only needed temporarily.
func (d *FontDescription) SetVariationsStatic(variations string) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 *C.char                 // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (*C.char)(C.CString(variations))
	defer C.free(unsafe.Pointer(_arg1))

	C.pango_font_description_set_variations_static(_arg0, _arg1)
}

// SetWeight sets the weight field of a font description.
//
// The weight field specifies how bold or light the font should be. In addition
// to the values of the [enum@Pango.Weight] enumeration, other intermediate
// numeric values are possible.
func (d *FontDescription) SetWeight(weight Weight) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoWeight           // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.PangoWeight)(weight)

	C.pango_font_description_set_weight(_arg0, _arg1)
}

// ToFilename creates a filename representation of a font description.
//
// The filename is identical to the result from calling
// [method@Pango.FontDescription.to_string], but with underscores instead of
// characters that are untypical in filenames, and in lower case only.
func (d *FontDescription) ToFilename() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_to_filename(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// String creates a string representation of a font description.
//
// See [type_func@Pango.FontDescription.from_string] for a description of the
// format of the string representation. The family list in the string
// description will only have a terminating comma if the last word of the list
// is a valid style option.
func (d *FontDescription) String() string {
	var _arg0 *C.PangoFontDescription // out
	var _cret *C.char                 // in

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))

	_cret = C.pango_font_description_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// UnsetFields unsets some of the fields in a `PangoFontDescription`.
//
// The unset fields will get back to their default values.
func (d *FontDescription) UnsetFields(toUnset FontMask) {
	var _arg0 *C.PangoFontDescription // out
	var _arg1 C.PangoFontMask         // out

	_arg0 = (*C.PangoFontDescription)(unsafe.Pointer(d.Native()))
	_arg1 = (C.PangoFontMask)(toUnset)

	C.pango_font_description_unset_fields(_arg0, _arg1)
}

// FontMetrics: a `PangoFontMetrics` structure holds the overall metric
// information for a font.
//
// The information in a `PangoFontMetrics` structure may be restricted to a
// script. The fields of this structure are private to implementations of a font
// backend. See the documentation of the corresponding getters for documentation
// of their meaning.
type FontMetrics struct {
	native C.PangoFontMetrics
}

// WrapFontMetrics wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapFontMetrics(ptr unsafe.Pointer) *FontMetrics {
	if ptr == nil {
		return nil
	}

	return (*FontMetrics)(ptr)
}

func marshalFontMetrics(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapFontMetrics(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (f *FontMetrics) Native() unsafe.Pointer {
	return unsafe.Pointer(&f.native)
}

// ApproximateCharWidth gets the approximate character width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual characters in text will be wider and
// narrower than this.
func (m *FontMetrics) ApproximateCharWidth() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_approximate_char_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// ApproximateDigitWidth gets the approximate digit width for a font metrics
// structure.
//
// This is merely a representative value useful, for example, for determining
// the initial size for a window. Actual digits in text can be wider or narrower
// than this, though this value is generally somewhat more accurate than the
// result of pango_font_metrics_get_approximate_char_width() for digits.
func (m *FontMetrics) ApproximateDigitWidth() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_approximate_digit_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Ascent gets the ascent from a font metrics structure.
//
// The ascent is the distance from the baseline to the logical top of a line of
// text. (The logical top may be above or below the top of the actual drawn ink.
// It is necessary to lay out the text to figure where the ink will be.)
func (m *FontMetrics) Ascent() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_ascent(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Descent gets the descent from a font metrics structure.
//
// The descent is the distance from the baseline to the logical bottom of a line
// of text. (The logical bottom may be above or below the bottom of the actual
// drawn ink. It is necessary to lay out the text to figure where the ink will
// be.)
func (m *FontMetrics) Descent() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_descent(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Height gets the line height from a font metrics structure.
//
// The line height is the distance between successive baselines in wrapped text.
//
// If the line height is not available, 0 is returned.
func (m *FontMetrics) Height() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_height(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// StrikethroughPosition gets the suggested position to draw the strikethrough.
//
// The value returned is the distance *above* the baseline of the top of the
// strikethrough.
func (m *FontMetrics) StrikethroughPosition() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_strikethrough_position(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// StrikethroughThickness gets the suggested thickness to draw for the
// strikethrough.
func (m *FontMetrics) StrikethroughThickness() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_strikethrough_thickness(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnderlinePosition gets the suggested position to draw the underline.
//
// The value returned is the distance *above* the baseline of the top of the
// underline. Since most fonts have underline positions beneath the baseline,
// this value is typically negative.
func (m *FontMetrics) UnderlinePosition() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_underline_position(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// UnderlineThickness gets the suggested thickness to draw for the underline.
func (m *FontMetrics) UnderlineThickness() int {
	var _arg0 *C.PangoFontMetrics // out
	var _cret C.int               // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_get_underline_thickness(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Ref: increase the reference count of a font metrics structure by one.
func (m *FontMetrics) Ref() *FontMetrics {
	var _arg0 *C.PangoFontMetrics // out
	var _cret *C.PangoFontMetrics // in

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	_cret = C.pango_font_metrics_ref(_arg0)

	var _fontMetrics *FontMetrics // out

	_fontMetrics = WrapFontMetrics(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_fontMetrics, func(v *FontMetrics) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _fontMetrics
}

// Unref: decrease the reference count of a font metrics structure by one. If
// the result is zero, frees the structure and any associated memory.
func (m *FontMetrics) Unref() {
	var _arg0 *C.PangoFontMetrics // out

	_arg0 = (*C.PangoFontMetrics)(unsafe.Pointer(m.Native()))

	C.pango_font_metrics_unref(_arg0)
}

// GlyphGeometry: the `PangoGlyphGeometry` structure contains width and
// positioning information for a single glyph.
type GlyphGeometry struct {
	native C.PangoGlyphGeometry
}

// WrapGlyphGeometry wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphGeometry(ptr unsafe.Pointer) *GlyphGeometry {
	if ptr == nil {
		return nil
	}

	return (*GlyphGeometry)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphGeometry) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// GlyphInfo: a `PangoGlyphInfo` structure represents a single glyph with
// positioning information and visual attributes.
type GlyphInfo struct {
	native C.PangoGlyphInfo
}

// WrapGlyphInfo wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphInfo(ptr unsafe.Pointer) *GlyphInfo {
	if ptr == nil {
		return nil
	}

	return (*GlyphInfo)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphInfo) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// GlyphItem: a `PangoGlyphItem` is a pair of a `PangoItem` and the glyphs
// resulting from shaping the items text.
//
// As an example of the usage of `PangoGlyphItem`, the results of shaping text
// with `PangoLayout` is a list of `PangoLayoutLine`, each of which contains a
// list of `PangoGlyphItem`.
type GlyphItem struct {
	native C.PangoGlyphItem
}

// WrapGlyphItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphItem(ptr unsafe.Pointer) *GlyphItem {
	if ptr == nil {
		return nil
	}

	return (*GlyphItem)(ptr)
}

func marshalGlyphItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphItem(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (g *GlyphItem) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Copy: make a deep copy of an existing `PangoGlyphItem` structure.
func (o *GlyphItem) Copy() *GlyphItem {
	var _arg0 *C.PangoGlyphItem // out
	var _cret *C.PangoGlyphItem // in

	_arg0 = (*C.PangoGlyphItem)(unsafe.Pointer(o.Native()))

	_cret = C.pango_glyph_item_copy(_arg0)

	var _glyphItem *GlyphItem // out

	_glyphItem = WrapGlyphItem(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_glyphItem, func(v *GlyphItem) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _glyphItem
}

// Free frees a `PangoGlyphItem` and resources to which it points.
func (g *GlyphItem) Free() {
	var _arg0 *C.PangoGlyphItem // out

	_arg0 = (*C.PangoGlyphItem)(unsafe.Pointer(g.Native()))

	C.pango_glyph_item_free(_arg0)
}

// Split modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item).
//
// This function is similar in function to pango_item_split() (and uses it
// internally.)
func (o *GlyphItem) Split(text string, splitIndex int) *GlyphItem {
	var _arg0 *C.PangoGlyphItem // out
	var _arg1 *C.char           // out
	var _arg2 C.int             // out
	var _cret *C.PangoGlyphItem // in

	_arg0 = (*C.PangoGlyphItem)(unsafe.Pointer(o.Native()))
	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(splitIndex)

	_cret = C.pango_glyph_item_split(_arg0, _arg1, _arg2)

	var _glyphItem *GlyphItem // out

	_glyphItem = WrapGlyphItem(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_glyphItem, func(v *GlyphItem) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _glyphItem
}

// GlyphItemIter: a `PangoGlyphItemIter` is an iterator over the clusters in a
// `PangoGlyphItem`.
//
// The *forward direction* of the iterator is the logical direction of text.
// That is, with increasing @start_index and @start_char values. If @glyph_item
// is right-to-left (that is, if `glyph_item->item->analysis.level` is odd),
// then @start_glyph decreases as the iterator moves forward. Moreover, in
// right-to-left cases, @start_glyph is greater than @end_glyph.
//
// An iterator should be initialized using either
// pango_glyph_item_iter_init_start() or pango_glyph_item_iter_init_end(), for
// forward and backward iteration respectively, and walked over using any
// desired mixture of pango_glyph_item_iter_next_cluster() and
// pango_glyph_item_iter_prev_cluster().
//
// A common idiom for doing a forward iteration over the clusters is:
//
// ` PangoGlyphItemIter cluster_iter; gboolean have_cluster;
//
// for (have_cluster = pango_glyph_item_iter_init_start (&cluster_iter,
// glyph_item, text); have_cluster; have_cluster =
// pango_glyph_item_iter_next_cluster (&cluster_iter)) { ... } `
//
// Note that @text is the start of the text for layout, which is then indexed by
// `glyph_item->item->offset` to get to the text of @glyph_item. The
// @start_index and @end_index values can directly index into @text. The
// @start_glyph, @end_glyph, @start_char, and @end_char values however are
// zero-based for the @glyph_item. For each cluster, the item pointed at by the
// start variables is included in the cluster while the one pointed at by end
// variables is not.
//
// None of the members of a `PangoGlyphItemIter` should be modified manually.
type GlyphItemIter struct {
	native C.PangoGlyphItemIter
}

// WrapGlyphItemIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphItemIter(ptr unsafe.Pointer) *GlyphItemIter {
	if ptr == nil {
		return nil
	}

	return (*GlyphItemIter)(ptr)
}

func marshalGlyphItemIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphItemIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (g *GlyphItemIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Copy: make a shallow copy of an existing `PangoGlyphItemIter` structure.
func (o *GlyphItemIter) Copy() *GlyphItemIter {
	var _arg0 *C.PangoGlyphItemIter // out
	var _cret *C.PangoGlyphItemIter // in

	_arg0 = (*C.PangoGlyphItemIter)(unsafe.Pointer(o.Native()))

	_cret = C.pango_glyph_item_iter_copy(_arg0)

	var _glyphItemIter *GlyphItemIter // out

	_glyphItemIter = WrapGlyphItemIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_glyphItemIter, func(v *GlyphItemIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _glyphItemIter
}

// Free frees a `PangoGlyphItem`Iter.
func (i *GlyphItemIter) Free() {
	var _arg0 *C.PangoGlyphItemIter // out

	_arg0 = (*C.PangoGlyphItemIter)(unsafe.Pointer(i.Native()))

	C.pango_glyph_item_iter_free(_arg0)
}

// InitEnd initializes a `PangoGlyphItemIter` structure to point to the last
// cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) InitEnd(glyphItem *GlyphItem, text string) bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _arg1 *C.PangoGlyphItem     // out
	var _arg2 *C.char               // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.PangoGlyphItem)(unsafe.Pointer(glyphItem.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.pango_glyph_item_iter_init_end(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// InitStart initializes a `PangoGlyphItemIter` structure to point to the first
// cluster in a glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) InitStart(glyphItem *GlyphItem, text string) bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _arg1 *C.PangoGlyphItem     // out
	var _arg2 *C.char               // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.PangoGlyphItem)(unsafe.Pointer(glyphItem.Native()))
	_arg2 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg2))

	_cret = C.pango_glyph_item_iter_init_start(_arg0, _arg1, _arg2)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextCluster advances the iterator to the next cluster in the glyph item.
//
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) NextCluster() bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_glyph_item_iter_next_cluster(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// PrevCluster moves the iterator to the preceding cluster in the glyph item.
// See `PangoGlyphItemIter` for details of cluster orders.
func (i *GlyphItemIter) PrevCluster() bool {
	var _arg0 *C.PangoGlyphItemIter // out
	var _cret C.gboolean            // in

	_arg0 = (*C.PangoGlyphItemIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_glyph_item_iter_prev_cluster(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// GlyphString: a `PangoGlyphString` is used to store strings of glyphs with
// geometry and visual attribute information.
//
// The storage for the glyph information is owned by the structure which
// simplifies memory management.
type GlyphString struct {
	native C.PangoGlyphString
}

// WrapGlyphString wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphString(ptr unsafe.Pointer) *GlyphString {
	if ptr == nil {
		return nil
	}

	return (*GlyphString)(ptr)
}

func marshalGlyphString(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapGlyphString(unsafe.Pointer(b)), nil
}

// NewGlyphString constructs a struct GlyphString.
func NewGlyphString() *GlyphString {
	var _cret *C.PangoGlyphString // in

	_cret = C.pango_glyph_string_new()

	var _glyphString *GlyphString // out

	_glyphString = WrapGlyphString(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_glyphString, func(v *GlyphString) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _glyphString
}

// Native returns the underlying C source pointer.
func (g *GlyphString) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Copy: copy a glyph string and associated storage.
func (s *GlyphString) Copy() *GlyphString {
	var _arg0 *C.PangoGlyphString // out
	var _cret *C.PangoGlyphString // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))

	_cret = C.pango_glyph_string_copy(_arg0)

	var _glyphString *GlyphString // out

	_glyphString = WrapGlyphString(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_glyphString, func(v *GlyphString) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _glyphString
}

// Extents: compute the logical and ink extents of a glyph string.
//
// See the documentation for [method@Pango.Font.get_glyph_extents] for details
// about the interpretation of the rectangles.
//
// Examples of logical (red) and ink (green) rects:
//
// ! (rects1.png) ! (rects2.png)
func (g *GlyphString) Extents(font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 *C.PangoFont        // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = (*C.PangoFont)(unsafe.Pointer(font.Native()))

	C.pango_glyph_string_extents(_arg0, _arg1, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// ExtentsRange computes the extents of a sub-portion of a glyph string.
//
// The extents are relative to the start of the glyph string range (the origin
// of their coordinate system is at the start of the range, not at the start of
// the entire glyph string).
func (g *GlyphString) ExtentsRange(start int, end int, font Font) (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.int               // out
	var _arg2 C.int               // out
	var _arg3 *C.PangoFont        // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))
	_arg1 = (C.int)(start)
	_arg2 = (C.int)(end)
	_arg3 = (*C.PangoFont)(unsafe.Pointer(font.Native()))

	C.pango_glyph_string_extents_range(_arg0, _arg1, _arg2, _arg3, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// Free: free a glyph string and associated storage.
func (s *GlyphString) Free() {
	var _arg0 *C.PangoGlyphString // out

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))

	C.pango_glyph_string_free(_arg0)
}

// Width computes the logical width of the glyph string.
//
// This can also be computed using [method@Pango.GlyphString.extents]. However,
// since this only computes the width, it's much faster. This is in fact only a
// convenience function that computes the sum of @geometry.width for each glyph
// in the @glyphs.
func (g *GlyphString) Width() int {
	var _arg0 *C.PangoGlyphString // out
	var _cret C.int               // in

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(g.Native()))

	_cret = C.pango_glyph_string_get_width(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// SetSize: resize a glyph string to the given length.
func (s *GlyphString) SetSize(newLen int) {
	var _arg0 *C.PangoGlyphString // out
	var _arg1 C.gint              // out

	_arg0 = (*C.PangoGlyphString)(unsafe.Pointer(s.Native()))
	_arg1 = (C.gint)(newLen)

	C.pango_glyph_string_set_size(_arg0, _arg1)
}

// GlyphVisAttr: a `PangoGlyphVisAttr` structure communicates information
// between the shaping and rendering phases.
//
// Currently, it contains only cluster start information. yMore attributes may
// be added in the future.
type GlyphVisAttr struct {
	native C.PangoGlyphVisAttr
}

// WrapGlyphVisAttr wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapGlyphVisAttr(ptr unsafe.Pointer) *GlyphVisAttr {
	if ptr == nil {
		return nil
	}

	return (*GlyphVisAttr)(ptr)
}

// Native returns the underlying C source pointer.
func (g *GlyphVisAttr) Native() unsafe.Pointer {
	return unsafe.Pointer(&g.native)
}

// Item: the `PangoItem` structure stores information about a segment of text.
//
// You typically obtain `PangoItems` by itemizing a piece of text with
// [func@itemize].
type Item struct {
	native C.PangoItem
}

// WrapItem wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapItem(ptr unsafe.Pointer) *Item {
	if ptr == nil {
		return nil
	}

	return (*Item)(ptr)
}

func marshalItem(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapItem(unsafe.Pointer(b)), nil
}

// NewItem constructs a struct Item.
func NewItem() *Item {
	var _cret *C.PangoItem // in

	_cret = C.pango_item_new()

	var _item *Item // out

	_item = WrapItem(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_item, func(v *Item) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _item
}

// Native returns the underlying C source pointer.
func (i *Item) Native() unsafe.Pointer {
	return unsafe.Pointer(&i.native)
}

// ApplyAttrs: add attributes to a `PangoItem`.
//
// The idea is that you have attributes that don't affect itemization, such as
// font features, so you filter them out using [method@Pango.AttrList.filter],
// itemize your text, then reapply the attributes to the resulting items using
// this function.
//
// The @iter should be positioned before the range of the item, and will be
// advanced past it. This function is meant to be called in a loop over the
// items resulting from itemization, while passing the iter to each call.
func (i *Item) ApplyAttrs(iter *AttrIterator) {
	var _arg0 *C.PangoItem         // out
	var _arg1 *C.PangoAttrIterator // out

	_arg0 = (*C.PangoItem)(unsafe.Pointer(i.Native()))
	_arg1 = (*C.PangoAttrIterator)(unsafe.Pointer(iter.Native()))

	C.pango_item_apply_attrs(_arg0, _arg1)
}

// Copy: copy an existing `PangoItem` structure.
func (i *Item) Copy() *Item {
	var _arg0 *C.PangoItem // out
	var _cret *C.PangoItem // in

	_arg0 = (*C.PangoItem)(unsafe.Pointer(i.Native()))

	_cret = C.pango_item_copy(_arg0)

	var _ret *Item // out

	_ret = WrapItem(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Item) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Free: free a `PangoItem` and all associated memory.
func (i *Item) Free() {
	var _arg0 *C.PangoItem // out

	_arg0 = (*C.PangoItem)(unsafe.Pointer(i.Native()))

	C.pango_item_free(_arg0)
}

// Split modifies @orig to cover only the text after @split_index, and returns a
// new item that covers the text before @split_index that used to be in @orig.
//
// You can think of @split_index as the length of the returned item.
// @split_index may not be 0, and it may not be greater than or equal to the
// length of @orig (that is, there must be at least one byte assigned to each
// item, you can't create a zero-length item). @split_offset is the length of
// the first item in chars, and must be provided because the text used to
// generate the item isn't available, so `pango_item_split()` can't count the
// char length of the split items itself.
func (o *Item) Split(splitIndex int, splitOffset int) *Item {
	var _arg0 *C.PangoItem // out
	var _arg1 C.int        // out
	var _arg2 C.int        // out
	var _cret *C.PangoItem // in

	_arg0 = (*C.PangoItem)(unsafe.Pointer(o.Native()))
	_arg1 = (C.int)(splitIndex)
	_arg2 = (C.int)(splitOffset)

	_cret = C.pango_item_split(_arg0, _arg1, _arg2)

	var _item *Item // out

	_item = WrapItem(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_item, func(v *Item) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _item
}

// Language: the `PangoLanguage` structure is used to represent a language.
//
// `PangoLanguage` pointers can be efficiently copied and compared with each
// other.
type Language struct {
	native C.PangoLanguage
}

// WrapLanguage wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLanguage(ptr unsafe.Pointer) *Language {
	if ptr == nil {
		return nil
	}

	return (*Language)(ptr)
}

func marshalLanguage(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLanguage(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *Language) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// SampleString: get a string that is representative of the characters needed to
// render a particular language.
//
// The sample text may be a pangram, but is not necessarily. It is chosen to be
// demonstrative of normal text in the language, as well as exposing font
// feature requirements unique to the language. It is suitable for use as sample
// text in a font selection dialog.
//
// If @language is nil, the default language as found by
// [type_func@Pango.Language.get_default] is used.
//
// If Pango does not have a sample string for @language, the classic "The quick
// brown fox..." is returned. This can be detected by comparing the returned
// pointer value to that returned for (non-existent) language code "xx". That
// is, compare to:
//
// ` pango_language_get_sample_string (pango_language_from_string ("xx")) `
func (l *Language) SampleString() string {
	var _arg0 *C.PangoLanguage // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))

	_cret = C.pango_language_get_sample_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// IncludesScript determines if @script is one of the scripts used to write
// @language. The returned value is conservative; if nothing is known about the
// language tag @language, true will be returned, since, as far as Pango knows,
// @script might be used to write @language.
//
// This routine is used in Pango's itemization process when determining if a
// supplied language tag is relevant to a particular section of text. It
// probably is not useful for applications in most circumstances.
//
// This function uses [method@Pango.Language.get_scripts] internally.
func (l *Language) IncludesScript(script Script) bool {
	var _arg0 *C.PangoLanguage // out
	var _arg1 C.PangoScript    // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))
	_arg1 = (C.PangoScript)(script)

	_cret = C.pango_language_includes_script(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Matches checks if a language tag matches one of the elements in a list of
// language ranges.
//
// A language tag is considered to match a range in the list if the range is
// '*', the range is exactly the tag, or the range is a prefix of the tag, and
// the character after it in the tag is '-'.
func (l *Language) Matches(rangeList string) bool {
	var _arg0 *C.PangoLanguage // out
	var _arg1 *C.char          // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))
	_arg1 = (*C.char)(C.CString(rangeList))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.pango_language_matches(_arg0, _arg1)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// String gets the RFC-3066 format string representing the given language tag.
func (l *Language) String() string {
	var _arg0 *C.PangoLanguage // out
	var _cret *C.char          // in

	_arg0 = (*C.PangoLanguage)(unsafe.Pointer(l.Native()))

	_cret = C.pango_language_to_string(_arg0)

	var _utf8 string // out

	_utf8 = C.GoString(_cret)

	return _utf8
}

// LayoutIter: a `PangoLayoutIter` can be used to iterate over the visual
// extents of a `PangoLayout`.
//
// To obtain a `PangoLayoutIter`, use [method@Pango.Layout.get_iter].
//
// The `PangoLayoutIter` structure is opaque, and has no user-visible fields.
type LayoutIter struct {
	native C.PangoLayoutIter
}

// WrapLayoutIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLayoutIter(ptr unsafe.Pointer) *LayoutIter {
	if ptr == nil {
		return nil
	}

	return (*LayoutIter)(ptr)
}

func marshalLayoutIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapLayoutIter(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (l *LayoutIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// AtLastLine determines whether @iter is on the last line of the layout.
func (i *LayoutIter) AtLastLine() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_at_last_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Copy copies a `PangoLayoutIter`.
func (i *LayoutIter) Copy() *LayoutIter {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayoutIter // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_copy(_arg0)

	var _layoutIter *LayoutIter // out

	_layoutIter = WrapLayoutIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_layoutIter, func(v *LayoutIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _layoutIter
}

// Free frees an iterator that's no longer in use.
func (i *LayoutIter) Free() {
	var _arg0 *C.PangoLayoutIter // out

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_free(_arg0)
}

// Baseline gets the Y position of the current line's baseline, in layout
// coordinates (origin at top left of the entire layout).
func (i *LayoutIter) Baseline() int {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_get_baseline(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// CharExtents gets the extents of the current character, in layout coordinates
// (origin is the top left of the entire layout). Only logical extents can
// sensibly be obtained for characters; ink extents make sense only down to the
// level of clusters.
func (i *LayoutIter) CharExtents() Rectangle {
	var _arg0 *C.PangoLayoutIter // out
	var _logicalRect Rectangle

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_get_char_extents(_arg0, (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _logicalRect
}

// ClusterExtents gets the extents of the current cluster, in layout coordinates
// (origin is the top left of the entire layout).
func (i *LayoutIter) ClusterExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_get_cluster_extents(_arg0, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// Index gets the current byte index. Note that iterating forward by char moves
// in visual order, not logical order, so indexes may not be sequential. Also,
// the index may be equal to the length of the text in the layout, if on the nil
// run (see [method@Pango.LayoutIter.get_run]).
func (i *LayoutIter) Index() int {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.int              // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_get_index(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Layout gets the layout associated with a `PangoLayoutIter`.
func (i *LayoutIter) Layout() Layout {
	var _arg0 *C.PangoLayoutIter // out
	var _cret *C.PangoLayout     // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_get_layout(_arg0)

	var _layout Layout // out

	_layout = gextras.CastObject(externglib.Take(unsafe.Pointer(_cret))).(Layout)

	return _layout
}

// LayoutExtents obtains the extents of the `PangoLayout` being iterated over.
// @ink_rect or @logical_rect can be nil if you aren't interested in them.
func (i *LayoutIter) LayoutExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_get_layout_extents(_arg0, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// LineExtents obtains the extents of the current line. @ink_rect or
// @logical_rect can be nil if you aren't interested in them. Extents are in
// layout coordinates (origin is the top-left corner of the entire
// `PangoLayout`). Thus the extents returned by this function will be the same
// width/height but not at the same x/y as the extents returned from
// [method@Pango.LayoutLine.get_extents].
func (i *LayoutIter) LineExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_get_line_extents(_arg0, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// LineYrange divides the vertical space in the `PangoLayout` being iterated
// over between the lines in the layout, and returns the space belonging to the
// current line. A line's range includes the line's logical extents, plus half
// of the spacing above and below the line, if [method@Pango.Layout.set_spacing]
// has been called to set layout spacing. The Y positions are in layout
// coordinates (origin at top left of the entire layout).
//
// Note: Since 1.44, Pango uses line heights for placing lines, and there may be
// gaps between the ranges returned by this function.
func (i *LayoutIter) LineYrange() (y0 int, y1 int) {
	var _arg0 *C.PangoLayoutIter // out
	var _arg1 C.int              // in
	var _arg2 C.int              // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_get_line_yrange(_arg0, &_arg1, &_arg2)

	var _y0 int // out
	var _y1 int // out

	_y0 = (int)(_arg1)
	_y1 = (int)(_arg2)

	return _y0, _y1
}

// RunExtents gets the extents of the current run in layout coordinates (origin
// is the top left of the entire layout).
func (i *LayoutIter) RunExtents() (inkRect Rectangle, logicalRect Rectangle) {
	var _arg0 *C.PangoLayoutIter // out
	var _inkRect Rectangle
	var _logicalRect Rectangle

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	C.pango_layout_iter_get_run_extents(_arg0, (*C.PangoRectangle)(unsafe.Pointer(&_inkRect)), (*C.PangoRectangle)(unsafe.Pointer(&_logicalRect)))

	return _inkRect, _logicalRect
}

// NextChar moves @iter forward to the next character in visual order. If @iter
// was already at the end of the layout, returns false.
func (i *LayoutIter) NextChar() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_next_char(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextCluster moves @iter forward to the next cluster in visual order. If @iter
// was already at the end of the layout, returns false.
func (i *LayoutIter) NextCluster() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_next_cluster(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextLine moves @iter forward to the start of the next line. If @iter is
// already on the last line, returns false.
func (i *LayoutIter) NextLine() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_next_line(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NextRun moves @iter forward to the next run in visual order. If @iter was
// already at the end of the layout, returns false.
func (i *LayoutIter) NextRun() bool {
	var _arg0 *C.PangoLayoutIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoLayoutIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_layout_iter_next_run(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// LogAttr: the `PangoLogAttr` structure stores information about the attributes
// of a single character.
type LogAttr struct {
	native C.PangoLogAttr
}

// WrapLogAttr wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapLogAttr(ptr unsafe.Pointer) *LogAttr {
	if ptr == nil {
		return nil
	}

	return (*LogAttr)(ptr)
}

// Native returns the underlying C source pointer.
func (l *LogAttr) Native() unsafe.Pointer {
	return unsafe.Pointer(&l.native)
}

// Matrix: a `PangoMatrix` specifies a transformation between user-space and
// device coordinates.
//
//
// The transformation is given by
//
// ` x_device = x_user * matrix->xx + y_user * matrix->xy + matrix->x0;
// y_device = x_user * matrix->yx + y_user * matrix->yy + matrix->y0; `
type Matrix struct {
	native C.PangoMatrix
}

// WrapMatrix wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapMatrix(ptr unsafe.Pointer) *Matrix {
	if ptr == nil {
		return nil
	}

	return (*Matrix)(ptr)
}

func marshalMatrix(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapMatrix(unsafe.Pointer(b)), nil
}

// Native returns the underlying C source pointer.
func (m *Matrix) Native() unsafe.Pointer {
	return unsafe.Pointer(&m.native)
}

// Concat changes the transformation represented by @matrix to be the
// transformation given by first applying transformation given by @new_matrix
// then applying the original transformation.
func (m *Matrix) Concat(newMatrix *Matrix) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 *C.PangoMatrix // out

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))
	_arg1 = (*C.PangoMatrix)(unsafe.Pointer(newMatrix.Native()))

	C.pango_matrix_concat(_arg0, _arg1)
}

// Copy copies a `PangoMatrix`.
func (m *Matrix) Copy() *Matrix {
	var _arg0 *C.PangoMatrix // out
	var _cret *C.PangoMatrix // in

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))

	_cret = C.pango_matrix_copy(_arg0)

	var _ret *Matrix // out

	_ret = WrapMatrix(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_ret, func(v *Matrix) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _ret
}

// Free: free a `PangoMatrix`.
func (m *Matrix) Free() {
	var _arg0 *C.PangoMatrix // out

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))

	C.pango_matrix_free(_arg0)
}

// FontScaleFactor returns the scale factor of a matrix on the height of the
// font.
//
// That is, the scale factor in the direction perpendicular to the vector that
// the X coordinate is mapped to. If the scale in the X coordinate is needed as
// well, use [method@Pango.Matrix.get_font_scale_factors].
func (m *Matrix) FontScaleFactor() float64 {
	var _arg0 *C.PangoMatrix // out
	var _cret C.double       // in

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))

	_cret = C.pango_matrix_get_font_scale_factor(_arg0)

	var _gdouble float64 // out

	_gdouble = (float64)(_cret)

	return _gdouble
}

// FontScaleFactors calculates the scale factor of a matrix on the width and
// height of the font.
//
// That is, @xscale is the scale factor in the direction of the X coordinate,
// and @yscale is the scale factor in the direction perpendicular to the vector
// that the X coordinate is mapped to.
//
// Note that output numbers will always be non-negative.
func (m *Matrix) FontScaleFactors() (xscale float64, yscale float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // in
	var _arg2 C.double       // in

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))

	C.pango_matrix_get_font_scale_factors(_arg0, &_arg1, &_arg2)

	var _xscale float64 // out
	var _yscale float64 // out

	_xscale = (float64)(_arg1)
	_yscale = (float64)(_arg2)

	return _xscale, _yscale
}

// Rotate changes the transformation represented by @matrix to be the
// transformation given by first rotating by @degrees degrees counter-clockwise
// then applying the original transformation.
func (m *Matrix) Rotate(degrees float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))
	_arg1 = (C.double)(degrees)

	C.pango_matrix_rotate(_arg0, _arg1)
}

// Scale changes the transformation represented by @matrix to be the
// transformation given by first scaling by @sx in the X direction and @sy in
// the Y direction then applying the original transformation.
func (m *Matrix) Scale(scaleX float64, scaleY float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))
	_arg1 = (C.double)(scaleX)
	_arg2 = (C.double)(scaleY)

	C.pango_matrix_scale(_arg0, _arg1, _arg2)
}

// Translate changes the transformation represented by @matrix to be the
// transformation given by first translating by (@tx, @ty) then applying the
// original transformation.
func (m *Matrix) Translate(tx float64, ty float64) {
	var _arg0 *C.PangoMatrix // out
	var _arg1 C.double       // out
	var _arg2 C.double       // out

	_arg0 = (*C.PangoMatrix)(unsafe.Pointer(m.Native()))
	_arg1 = (C.double)(tx)
	_arg2 = (C.double)(ty)

	C.pango_matrix_translate(_arg0, _arg1, _arg2)
}

// Rectangle: the `PangoRectangle` structure represents a rectangle.
//
// `PangoRectangle` is frequently used to represent the logical or ink extents
// of a single glyph or section of text. (See, for instance,
// [method@Pango.Font.get_glyph_extents].)
type Rectangle struct {
	native C.PangoRectangle
}

// WrapRectangle wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapRectangle(ptr unsafe.Pointer) *Rectangle {
	if ptr == nil {
		return nil
	}

	return (*Rectangle)(ptr)
}

// Native returns the underlying C source pointer.
func (r *Rectangle) Native() unsafe.Pointer {
	return unsafe.Pointer(&r.native)
}

// ScriptIter: a `PangoScriptIter` is used to iterate through a string and
// identify ranges in different scripts.
type ScriptIter struct {
	native C.PangoScriptIter
}

// WrapScriptIter wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapScriptIter(ptr unsafe.Pointer) *ScriptIter {
	if ptr == nil {
		return nil
	}

	return (*ScriptIter)(ptr)
}

func marshalScriptIter(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapScriptIter(unsafe.Pointer(b)), nil
}

// NewScriptIter constructs a struct ScriptIter.
func NewScriptIter(text string, length int) *ScriptIter {
	var _arg1 *C.char            // out
	var _arg2 C.int              // out
	var _cret *C.PangoScriptIter // in

	_arg1 = (*C.char)(C.CString(text))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (C.int)(length)

	_cret = C.pango_script_iter_new(_arg1, _arg2)

	var _scriptIter *ScriptIter // out

	_scriptIter = WrapScriptIter(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_scriptIter, func(v *ScriptIter) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _scriptIter
}

// Native returns the underlying C source pointer.
func (s *ScriptIter) Native() unsafe.Pointer {
	return unsafe.Pointer(&s.native)
}

// Free frees a ScriptIter created with pango_script_iter_new().
func (i *ScriptIter) Free() {
	var _arg0 *C.PangoScriptIter // out

	_arg0 = (*C.PangoScriptIter)(unsafe.Pointer(i.Native()))

	C.pango_script_iter_free(_arg0)
}

// Range gets information about the range to which @iter currently points. The
// range is the set of locations p where *start <= p < *end. (That is, it
// doesn't include the character stored at *end)
//
// Note that while the type of the @script argument is declared as PangoScript,
// as of Pango 1.18, this function simply returns GUnicodeScript values. Callers
// must be prepared to handle unknown values.
func (i *ScriptIter) Range() (start string, end string, script Script) {
	var _arg0 *C.PangoScriptIter // out
	var _arg1 *C.char            // in
	var _arg2 *C.char            // in
	var _arg3 C.PangoScript      // in

	_arg0 = (*C.PangoScriptIter)(unsafe.Pointer(i.Native()))

	C.pango_script_iter_get_range(_arg0, &_arg1, &_arg2, &_arg3)

	var _start string  // out
	var _end string    // out
	var _script Script // out

	_start = C.GoString(_arg1)
	defer C.free(unsafe.Pointer(_arg1))
	_end = C.GoString(_arg2)
	defer C.free(unsafe.Pointer(_arg2))
	_script = Script(_arg3)

	return _start, _end, _script
}

// Next advances a ScriptIter to the next range. If @iter is already at the end,
// it is left unchanged and false is returned.
func (i *ScriptIter) Next() bool {
	var _arg0 *C.PangoScriptIter // out
	var _cret C.gboolean         // in

	_arg0 = (*C.PangoScriptIter)(unsafe.Pointer(i.Native()))

	_cret = C.pango_script_iter_next(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// TabArray: a `PangoTabArray` contains an array of tab stops.
//
// `PangoTabArray` can be used to set tab stops in a `PangoLayout`. Each tab
// stop has an alignment and a position.
type TabArray struct {
	native C.PangoTabArray
}

// WrapTabArray wraps the C unsafe.Pointer to be the right type. It is
// primarily used internally.
func WrapTabArray(ptr unsafe.Pointer) *TabArray {
	if ptr == nil {
		return nil
	}

	return (*TabArray)(ptr)
}

func marshalTabArray(p uintptr) (interface{}, error) {
	b := C.g_value_get_boxed((*C.GValue)(unsafe.Pointer(p)))
	return WrapTabArray(unsafe.Pointer(b)), nil
}

// NewTabArray constructs a struct TabArray.
func NewTabArray(initialSize int, positionsInPixels bool) *TabArray {
	var _arg1 C.gint           // out
	var _arg2 C.gboolean       // out
	var _cret *C.PangoTabArray // in

	_arg1 = (C.gint)(initialSize)
	if positionsInPixels {
		_arg2 = C.TRUE
	}

	_cret = C.pango_tab_array_new(_arg1, _arg2)

	var _tabArray *TabArray // out

	_tabArray = WrapTabArray(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_tabArray, func(v *TabArray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _tabArray
}

// Native returns the underlying C source pointer.
func (t *TabArray) Native() unsafe.Pointer {
	return unsafe.Pointer(&t.native)
}

// Copy copies a `PangoTabArray`.
func (s *TabArray) Copy() *TabArray {
	var _arg0 *C.PangoTabArray // out
	var _cret *C.PangoTabArray // in

	_arg0 = (*C.PangoTabArray)(unsafe.Pointer(s.Native()))

	_cret = C.pango_tab_array_copy(_arg0)

	var _tabArray *TabArray // out

	_tabArray = WrapTabArray(unsafe.Pointer(_cret))
	runtime.SetFinalizer(_tabArray, func(v *TabArray) {
		C.free(unsafe.Pointer(v.Native()))
	})

	return _tabArray
}

// Free frees a tab array and associated resources.
func (t *TabArray) Free() {
	var _arg0 *C.PangoTabArray // out

	_arg0 = (*C.PangoTabArray)(unsafe.Pointer(t.Native()))

	C.pango_tab_array_free(_arg0)
}

// PositionsInPixels returns true if the tab positions are in pixels, false if
// they are in Pango units.
func (t *TabArray) PositionsInPixels() bool {
	var _arg0 *C.PangoTabArray // out
	var _cret C.gboolean       // in

	_arg0 = (*C.PangoTabArray)(unsafe.Pointer(t.Native()))

	_cret = C.pango_tab_array_get_positions_in_pixels(_arg0)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Size gets the number of tab stops in @tab_array.
func (t *TabArray) Size() int {
	var _arg0 *C.PangoTabArray // out
	var _cret C.gint           // in

	_arg0 = (*C.PangoTabArray)(unsafe.Pointer(t.Native()))

	_cret = C.pango_tab_array_get_size(_arg0)

	var _gint int // out

	_gint = (int)(_cret)

	return _gint
}

// Tab gets the alignment and position of a tab stop.
func (t *TabArray) Tab(tabIndex int) (TabAlign, int) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.gint           // out
	var _arg2 C.PangoTabAlign  // in
	var _arg3 C.gint           // in

	_arg0 = (*C.PangoTabArray)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(tabIndex)

	C.pango_tab_array_get_tab(_arg0, _arg1, &_arg2, &_arg3)

	var _alignment TabAlign // out
	var _location int       // out

	_alignment = TabAlign(_arg2)
	_location = (int)(_arg3)

	return _alignment, _location
}

// Resize resizes a tab array.
//
// You must subsequently initialize any tabs that were added as a result of
// growing the array.
func (t *TabArray) Resize(newSize int) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.gint           // out

	_arg0 = (*C.PangoTabArray)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(newSize)

	C.pango_tab_array_resize(_arg0, _arg1)
}

// SetTab sets the alignment and location of a tab stop.
//
// @alignment must always be PANGO_TAB_LEFT in the current implementation.
func (t *TabArray) SetTab(tabIndex int, alignment TabAlign, location int) {
	var _arg0 *C.PangoTabArray // out
	var _arg1 C.gint           // out
	var _arg2 C.PangoTabAlign  // out
	var _arg3 C.gint           // out

	_arg0 = (*C.PangoTabArray)(unsafe.Pointer(t.Native()))
	_arg1 = (C.gint)(tabIndex)
	_arg2 = (C.PangoTabAlign)(alignment)
	_arg3 = (C.gint)(location)

	C.pango_tab_array_set_tab(_arg0, _arg1, _arg2, _arg3)
}
